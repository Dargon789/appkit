const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      'assets/embedded-wallet-CalfqdNI.js',
      'assets/if-defined-DVOmkLu5.js',
      'assets/index-BxwsSeIL.js',
      'assets/index-QpqlfPgl.js',
      'assets/index-Cn1TwpSs.js',
      'assets/index-B2osUT2V.js',
      'assets/index-BfDAOq8h.js',
      'assets/index-BGjtclTS.js',
      'assets/index-Cxc8tIRM.js',
      'assets/index-DeEXhxyT.js',
      'assets/email-5kUJw0ce.js',
      'assets/index-C22vu2Z6.js',
      'assets/socials-Uau0-5BN.js',
      'assets/index-C5GW1wiz.js',
      'assets/index-DcIuyBCN.js',
      'assets/index-BeTGsQ0g.js',
      'assets/index-CTojmOJx.js',
      'assets/swaps-BYyffamV.js',
      'assets/index-QVU1uMUX.js',
      'assets/index-swSfGf8i.js',
      'assets/index-BIRMkK39.js',
      'assets/send-CrjHOw2Z.js',
      'assets/index-DsF4Gov6.js',
      'assets/receive-BTHURE40.js',
      'assets/index-BaPrYmVj.js',
      'assets/onramp-BzOH_Bbb.js',
      'assets/index-kA5-QyMM.js',
      'assets/index-vgifefJD.js',
      'assets/transactions-C-U2YbwL.js',
      'assets/index-B4eb2ffY.js',
      'assets/index-DHeF6YgC.js',
      'assets/index-Bz4Ul6tQ.js',
      'assets/w3m-modal-2k5y_YMI.js'
    ])
) => i.map(i => d[i])
var _C = t => {
  throw TypeError(t)
}
var iv = (t, e, n) => e.has(t) || _C('Cannot ' + n)
var W = (t, e, n) => (iv(t, e, 'read from private field'), n ? n.call(t) : e.get(t)),
  Ue = (t, e, n) =>
    e.has(t)
      ? _C('Cannot add the same private member more than once')
      : e instanceof WeakSet
        ? e.add(t)
        : e.set(t, n),
  Ee = (t, e, n, r) => (iv(t, e, 'write to private field'), r ? r.call(t, n) : e.set(t, n), n),
  Ye = (t, e, n) => (iv(t, e, 'access private method'), n)
var W0 = (t, e, n, r) => ({
  set _(i) {
    Ee(t, e, i, n)
  },
  get _() {
    return W(t, e, r)
  }
})
;(function () {
  const e = document.createElement('link').relList
  if (e && e.supports && e.supports('modulepreload')) return
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i)
  new MutationObserver(i => {
    for (const s of i)
      if (s.type === 'childList')
        for (const c of s.addedNodes) c.tagName === 'LINK' && c.rel === 'modulepreload' && r(c)
  }).observe(document, { childList: !0, subtree: !0 })
  function n(i) {
    const s = {}
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === 'use-credentials'
        ? (s.credentials = 'include')
        : i.crossOrigin === 'anonymous'
          ? (s.credentials = 'omit')
          : (s.credentials = 'same-origin'),
      s
    )
  }
  function r(i) {
    if (i.ep) return
    i.ep = !0
    const s = n(i)
    fetch(i.href, s)
  }
})()
var $s =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
      ? window
      : typeof global < 'u'
        ? global
        : typeof self < 'u'
          ? self
          : {}
function pd(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t
}
function j8(t) {
  if (Object.prototype.hasOwnProperty.call(t, '__esModule')) return t
  var e = t.default
  if (typeof e == 'function') {
    var n = function r() {
      return this instanceof r
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments)
    }
    n.prototype = e.prototype
  } else n = {}
  return (
    Object.defineProperty(n, '__esModule', { value: !0 }),
    Object.keys(t).forEach(function (r) {
      var i = Object.getOwnPropertyDescriptor(t, r)
      Object.defineProperty(
        n,
        r,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return t[r]
              }
            }
      )
    }),
    n
  )
}
var sv = { exports: {} },
  Nf = {}
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var CC
function XR() {
  if (CC) return Nf
  CC = 1
  var t = Symbol.for('react.transitional.element'),
    e = Symbol.for('react.fragment')
  function n(r, i, s) {
    var c = null
    if ((s !== void 0 && (c = '' + s), i.key !== void 0 && (c = '' + i.key), 'key' in i)) {
      s = {}
      for (var u in i) u !== 'key' && (s[u] = i[u])
    } else s = i
    return (i = s.ref), { $$typeof: t, type: r, key: c, ref: i !== void 0 ? i : null, props: s }
  }
  return (Nf.Fragment = e), (Nf.jsx = n), (Nf.jsxs = n), Nf
}
var SC
function JR() {
  return SC || ((SC = 1), (sv.exports = XR())), sv.exports
}
var De = JR(),
  av = { exports: {} },
  We = {}
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var TC
function e7() {
  if (TC) return We
  TC = 1
  var t = Symbol.for('react.transitional.element'),
    e = Symbol.for('react.portal'),
    n = Symbol.for('react.fragment'),
    r = Symbol.for('react.strict_mode'),
    i = Symbol.for('react.profiler'),
    s = Symbol.for('react.consumer'),
    c = Symbol.for('react.context'),
    u = Symbol.for('react.forward_ref'),
    f = Symbol.for('react.suspense'),
    d = Symbol.for('react.memo'),
    p = Symbol.for('react.lazy'),
    g = Symbol.iterator
  function m(w) {
    return w === null || typeof w != 'object'
      ? null
      : ((w = (g && w[g]) || w['@@iterator']), typeof w == 'function' ? w : null)
  }
  var y = {
      isMounted: function () {
        return !1
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {}
    },
    A = Object.assign,
    E = {}
  function x(w, B, Z) {
    ;(this.props = w), (this.context = B), (this.refs = E), (this.updater = Z || y)
  }
  ;(x.prototype.isReactComponent = {}),
    (x.prototype.setState = function (w, B) {
      if (typeof w != 'object' && typeof w != 'function' && w != null)
        throw Error(
          'takes an object of state variables to update or a function which returns an object of state variables.'
        )
      this.updater.enqueueSetState(this, w, B, 'setState')
    }),
    (x.prototype.forceUpdate = function (w) {
      this.updater.enqueueForceUpdate(this, w, 'forceUpdate')
    })
  function O() {}
  O.prototype = x.prototype
  function I(w, B, Z) {
    ;(this.props = w), (this.context = B), (this.refs = E), (this.updater = Z || y)
  }
  var M = (I.prototype = new O())
  ;(M.constructor = I), A(M, x.prototype), (M.isPureReactComponent = !0)
  var $ = Array.isArray,
    D = { H: null, A: null, T: null, S: null },
    R = Object.prototype.hasOwnProperty
  function z(w, B, Z, ee, Y, se) {
    return (Z = se.ref), { $$typeof: t, type: w, key: B, ref: Z !== void 0 ? Z : null, props: se }
  }
  function G(w, B) {
    return z(w.type, B, void 0, void 0, void 0, w.props)
  }
  function j(w) {
    return typeof w == 'object' && w !== null && w.$$typeof === t
  }
  function V(w) {
    var B = { '=': '=0', ':': '=2' }
    return (
      '$' +
      w.replace(/[=:]/g, function (Z) {
        return B[Z]
      })
    )
  }
  var L = /\/+/g
  function v(w, B) {
    return typeof w == 'object' && w !== null && w.key != null ? V('' + w.key) : B.toString(36)
  }
  function C() {}
  function N(w) {
    switch (w.status) {
      case 'fulfilled':
        return w.value
      case 'rejected':
        throw w.reason
      default:
        switch (
          (typeof w.status == 'string'
            ? w.then(C, C)
            : ((w.status = 'pending'),
              w.then(
                function (B) {
                  w.status === 'pending' && ((w.status = 'fulfilled'), (w.value = B))
                },
                function (B) {
                  w.status === 'pending' && ((w.status = 'rejected'), (w.reason = B))
                }
              )),
          w.status)
        ) {
          case 'fulfilled':
            return w.value
          case 'rejected':
            throw w.reason
        }
    }
    throw w
  }
  function T(w, B, Z, ee, Y) {
    var se = typeof w
    ;(se === 'undefined' || se === 'boolean') && (w = null)
    var ce = !1
    if (w === null) ce = !0
    else
      switch (se) {
        case 'bigint':
        case 'string':
        case 'number':
          ce = !0
          break
        case 'object':
          switch (w.$$typeof) {
            case t:
            case e:
              ce = !0
              break
            case p:
              return (ce = w._init), T(ce(w._payload), B, Z, ee, Y)
          }
      }
    if (ce)
      return (
        (Y = Y(w)),
        (ce = ee === '' ? '.' + v(w, 0) : ee),
        $(Y)
          ? ((Z = ''),
            ce != null && (Z = ce.replace(L, '$&/') + '/'),
            T(Y, B, Z, '', function (ye) {
              return ye
            }))
          : Y != null &&
            (j(Y) &&
              (Y = G(
                Y,
                Z +
                  (Y.key == null || (w && w.key === Y.key)
                    ? ''
                    : ('' + Y.key).replace(L, '$&/') + '/') +
                  ce
              )),
            B.push(Y)),
        1
      )
    ce = 0
    var we = ee === '' ? '.' : ee + ':'
    if ($(w))
      for (var _e = 0; _e < w.length; _e++)
        (ee = w[_e]), (se = we + v(ee, _e)), (ce += T(ee, B, Z, se, Y))
    else if (((_e = m(w)), typeof _e == 'function'))
      for (w = _e.call(w), _e = 0; !(ee = w.next()).done; )
        (ee = ee.value), (se = we + v(ee, _e++)), (ce += T(ee, B, Z, se, Y))
    else if (se === 'object') {
      if (typeof w.then == 'function') return T(N(w), B, Z, ee, Y)
      throw (
        ((B = String(w)),
        Error(
          'Objects are not valid as a React child (found: ' +
            (B === '[object Object]' ? 'object with keys {' + Object.keys(w).join(', ') + '}' : B) +
            '). If you meant to render a collection of children, use an array instead.'
        ))
      )
    }
    return ce
  }
  function S(w, B, Z) {
    if (w == null) return w
    var ee = [],
      Y = 0
    return (
      T(w, ee, '', '', function (se) {
        return B.call(Z, se, Y++)
      }),
      ee
    )
  }
  function k(w) {
    if (w._status === -1) {
      var B = w._result
      ;(B = B()),
        B.then(
          function (Z) {
            ;(w._status === 0 || w._status === -1) && ((w._status = 1), (w._result = Z))
          },
          function (Z) {
            ;(w._status === 0 || w._status === -1) && ((w._status = 2), (w._result = Z))
          }
        ),
        w._status === -1 && ((w._status = 0), (w._result = B))
    }
    if (w._status === 1) return w._result.default
    throw w._result
  }
  var F =
    typeof reportError == 'function'
      ? reportError
      : function (w) {
          if (typeof window == 'object' && typeof window.ErrorEvent == 'function') {
            var B = new window.ErrorEvent('error', {
              bubbles: !0,
              cancelable: !0,
              message:
                typeof w == 'object' && w !== null && typeof w.message == 'string'
                  ? String(w.message)
                  : String(w),
              error: w
            })
            if (!window.dispatchEvent(B)) return
          } else if (typeof process == 'object' && typeof process.emit == 'function') {
            process.emit('uncaughtException', w)
            return
          }
          console.error(w)
        }
  function P() {}
  return (
    (We.Children = {
      map: S,
      forEach: function (w, B, Z) {
        S(
          w,
          function () {
            B.apply(this, arguments)
          },
          Z
        )
      },
      count: function (w) {
        var B = 0
        return (
          S(w, function () {
            B++
          }),
          B
        )
      },
      toArray: function (w) {
        return (
          S(w, function (B) {
            return B
          }) || []
        )
      },
      only: function (w) {
        if (!j(w))
          throw Error('React.Children.only expected to receive a single React element child.')
        return w
      }
    }),
    (We.Component = x),
    (We.Fragment = n),
    (We.Profiler = i),
    (We.PureComponent = I),
    (We.StrictMode = r),
    (We.Suspense = f),
    (We.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = D),
    (We.act = function () {
      throw Error('act(...) is not supported in production builds of React.')
    }),
    (We.cache = function (w) {
      return function () {
        return w.apply(null, arguments)
      }
    }),
    (We.cloneElement = function (w, B, Z) {
      if (w == null) throw Error('The argument must be a React element, but you passed ' + w + '.')
      var ee = A({}, w.props),
        Y = w.key,
        se = void 0
      if (B != null)
        for (ce in (B.ref !== void 0 && (se = void 0), B.key !== void 0 && (Y = '' + B.key), B))
          !R.call(B, ce) ||
            ce === 'key' ||
            ce === '__self' ||
            ce === '__source' ||
            (ce === 'ref' && B.ref === void 0) ||
            (ee[ce] = B[ce])
      var ce = arguments.length - 2
      if (ce === 1) ee.children = Z
      else if (1 < ce) {
        for (var we = Array(ce), _e = 0; _e < ce; _e++) we[_e] = arguments[_e + 2]
        ee.children = we
      }
      return z(w.type, Y, void 0, void 0, se, ee)
    }),
    (We.createContext = function (w) {
      return (
        (w = {
          $$typeof: c,
          _currentValue: w,
          _currentValue2: w,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        }),
        (w.Provider = w),
        (w.Consumer = { $$typeof: s, _context: w }),
        w
      )
    }),
    (We.createElement = function (w, B, Z) {
      var ee,
        Y = {},
        se = null
      if (B != null)
        for (ee in (B.key !== void 0 && (se = '' + B.key), B))
          R.call(B, ee) && ee !== 'key' && ee !== '__self' && ee !== '__source' && (Y[ee] = B[ee])
      var ce = arguments.length - 2
      if (ce === 1) Y.children = Z
      else if (1 < ce) {
        for (var we = Array(ce), _e = 0; _e < ce; _e++) we[_e] = arguments[_e + 2]
        Y.children = we
      }
      if (w && w.defaultProps)
        for (ee in ((ce = w.defaultProps), ce)) Y[ee] === void 0 && (Y[ee] = ce[ee])
      return z(w, se, void 0, void 0, null, Y)
    }),
    (We.createRef = function () {
      return { current: null }
    }),
    (We.forwardRef = function (w) {
      return { $$typeof: u, render: w }
    }),
    (We.isValidElement = j),
    (We.lazy = function (w) {
      return { $$typeof: p, _payload: { _status: -1, _result: w }, _init: k }
    }),
    (We.memo = function (w, B) {
      return { $$typeof: d, type: w, compare: B === void 0 ? null : B }
    }),
    (We.startTransition = function (w) {
      var B = D.T,
        Z = {}
      D.T = Z
      try {
        var ee = w(),
          Y = D.S
        Y !== null && Y(Z, ee),
          typeof ee == 'object' && ee !== null && typeof ee.then == 'function' && ee.then(P, F)
      } catch (se) {
        F(se)
      } finally {
        D.T = B
      }
    }),
    (We.unstable_useCacheRefresh = function () {
      return D.H.useCacheRefresh()
    }),
    (We.use = function (w) {
      return D.H.use(w)
    }),
    (We.useActionState = function (w, B, Z) {
      return D.H.useActionState(w, B, Z)
    }),
    (We.useCallback = function (w, B) {
      return D.H.useCallback(w, B)
    }),
    (We.useContext = function (w) {
      return D.H.useContext(w)
    }),
    (We.useDebugValue = function () {}),
    (We.useDeferredValue = function (w, B) {
      return D.H.useDeferredValue(w, B)
    }),
    (We.useEffect = function (w, B) {
      return D.H.useEffect(w, B)
    }),
    (We.useId = function () {
      return D.H.useId()
    }),
    (We.useImperativeHandle = function (w, B, Z) {
      return D.H.useImperativeHandle(w, B, Z)
    }),
    (We.useInsertionEffect = function (w, B) {
      return D.H.useInsertionEffect(w, B)
    }),
    (We.useLayoutEffect = function (w, B) {
      return D.H.useLayoutEffect(w, B)
    }),
    (We.useMemo = function (w, B) {
      return D.H.useMemo(w, B)
    }),
    (We.useOptimistic = function (w, B) {
      return D.H.useOptimistic(w, B)
    }),
    (We.useReducer = function (w, B, Z) {
      return D.H.useReducer(w, B, Z)
    }),
    (We.useRef = function (w) {
      return D.H.useRef(w)
    }),
    (We.useState = function (w) {
      return D.H.useState(w)
    }),
    (We.useSyncExternalStore = function (w, B, Z) {
      return D.H.useSyncExternalStore(w, B, Z)
    }),
    (We.useTransition = function () {
      return D.H.useTransition()
    }),
    (We.version = '19.0.0'),
    We
  )
}
var xC
function gd() {
  return xC || ((xC = 1), (av.exports = e7())), av.exports
}
var Le = gd()
const t7 = pd(Le)
var ov = { exports: {} },
  If = {},
  cv = { exports: {} },
  uv = {}
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var NC
function n7() {
  return (
    NC ||
      ((NC = 1),
      (function (t) {
        function e(S, k) {
          var F = S.length
          S.push(k)
          e: for (; 0 < F; ) {
            var P = (F - 1) >>> 1,
              w = S[P]
            if (0 < i(w, k)) (S[P] = k), (S[F] = w), (F = P)
            else break e
          }
        }
        function n(S) {
          return S.length === 0 ? null : S[0]
        }
        function r(S) {
          if (S.length === 0) return null
          var k = S[0],
            F = S.pop()
          if (F !== k) {
            S[0] = F
            e: for (var P = 0, w = S.length, B = w >>> 1; P < B; ) {
              var Z = 2 * (P + 1) - 1,
                ee = S[Z],
                Y = Z + 1,
                se = S[Y]
              if (0 > i(ee, F))
                Y < w && 0 > i(se, ee)
                  ? ((S[P] = se), (S[Y] = F), (P = Y))
                  : ((S[P] = ee), (S[Z] = F), (P = Z))
              else if (Y < w && 0 > i(se, F)) (S[P] = se), (S[Y] = F), (P = Y)
              else break e
            }
          }
          return k
        }
        function i(S, k) {
          var F = S.sortIndex - k.sortIndex
          return F !== 0 ? F : S.id - k.id
        }
        if (
          ((t.unstable_now = void 0),
          typeof performance == 'object' && typeof performance.now == 'function')
        ) {
          var s = performance
          t.unstable_now = function () {
            return s.now()
          }
        } else {
          var c = Date,
            u = c.now()
          t.unstable_now = function () {
            return c.now() - u
          }
        }
        var f = [],
          d = [],
          p = 1,
          g = null,
          m = 3,
          y = !1,
          A = !1,
          E = !1,
          x = typeof setTimeout == 'function' ? setTimeout : null,
          O = typeof clearTimeout == 'function' ? clearTimeout : null,
          I = typeof setImmediate < 'u' ? setImmediate : null
        function M(S) {
          for (var k = n(d); k !== null; ) {
            if (k.callback === null) r(d)
            else if (k.startTime <= S) r(d), (k.sortIndex = k.expirationTime), e(f, k)
            else break
            k = n(d)
          }
        }
        function $(S) {
          if (((E = !1), M(S), !A))
            if (n(f) !== null) (A = !0), N()
            else {
              var k = n(d)
              k !== null && T($, k.startTime - S)
            }
        }
        var D = !1,
          R = -1,
          z = 5,
          G = -1
        function j() {
          return !(t.unstable_now() - G < z)
        }
        function V() {
          if (D) {
            var S = t.unstable_now()
            G = S
            var k = !0
            try {
              e: {
                ;(A = !1), E && ((E = !1), O(R), (R = -1)), (y = !0)
                var F = m
                try {
                  t: {
                    for (M(S), g = n(f); g !== null && !(g.expirationTime > S && j()); ) {
                      var P = g.callback
                      if (typeof P == 'function') {
                        ;(g.callback = null), (m = g.priorityLevel)
                        var w = P(g.expirationTime <= S)
                        if (((S = t.unstable_now()), typeof w == 'function')) {
                          ;(g.callback = w), M(S), (k = !0)
                          break t
                        }
                        g === n(f) && r(f), M(S)
                      } else r(f)
                      g = n(f)
                    }
                    if (g !== null) k = !0
                    else {
                      var B = n(d)
                      B !== null && T($, B.startTime - S), (k = !1)
                    }
                  }
                  break e
                } finally {
                  ;(g = null), (m = F), (y = !1)
                }
                k = void 0
              }
            } finally {
              k ? L() : (D = !1)
            }
          }
        }
        var L
        if (typeof I == 'function')
          L = function () {
            I(V)
          }
        else if (typeof MessageChannel < 'u') {
          var v = new MessageChannel(),
            C = v.port2
          ;(v.port1.onmessage = V),
            (L = function () {
              C.postMessage(null)
            })
        } else
          L = function () {
            x(V, 0)
          }
        function N() {
          D || ((D = !0), L())
        }
        function T(S, k) {
          R = x(function () {
            S(t.unstable_now())
          }, k)
        }
        ;(t.unstable_IdlePriority = 5),
          (t.unstable_ImmediatePriority = 1),
          (t.unstable_LowPriority = 4),
          (t.unstable_NormalPriority = 3),
          (t.unstable_Profiling = null),
          (t.unstable_UserBlockingPriority = 2),
          (t.unstable_cancelCallback = function (S) {
            S.callback = null
          }),
          (t.unstable_continueExecution = function () {
            A || y || ((A = !0), N())
          }),
          (t.unstable_forceFrameRate = function (S) {
            0 > S || 125 < S
              ? console.error(
                  'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
                )
              : (z = 0 < S ? Math.floor(1e3 / S) : 5)
          }),
          (t.unstable_getCurrentPriorityLevel = function () {
            return m
          }),
          (t.unstable_getFirstCallbackNode = function () {
            return n(f)
          }),
          (t.unstable_next = function (S) {
            switch (m) {
              case 1:
              case 2:
              case 3:
                var k = 3
                break
              default:
                k = m
            }
            var F = m
            m = k
            try {
              return S()
            } finally {
              m = F
            }
          }),
          (t.unstable_pauseExecution = function () {}),
          (t.unstable_requestPaint = function () {}),
          (t.unstable_runWithPriority = function (S, k) {
            switch (S) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break
              default:
                S = 3
            }
            var F = m
            m = S
            try {
              return k()
            } finally {
              m = F
            }
          }),
          (t.unstable_scheduleCallback = function (S, k, F) {
            var P = t.unstable_now()
            switch (
              (typeof F == 'object' && F !== null
                ? ((F = F.delay), (F = typeof F == 'number' && 0 < F ? P + F : P))
                : (F = P),
              S)
            ) {
              case 1:
                var w = -1
                break
              case 2:
                w = 250
                break
              case 5:
                w = 1073741823
                break
              case 4:
                w = 1e4
                break
              default:
                w = 5e3
            }
            return (
              (w = F + w),
              (S = {
                id: p++,
                callback: k,
                priorityLevel: S,
                startTime: F,
                expirationTime: w,
                sortIndex: -1
              }),
              F > P
                ? ((S.sortIndex = F),
                  e(d, S),
                  n(f) === null && S === n(d) && (E ? (O(R), (R = -1)) : (E = !0), T($, F - P)))
                : ((S.sortIndex = w), e(f, S), A || y || ((A = !0), N())),
              S
            )
          }),
          (t.unstable_shouldYield = j),
          (t.unstable_wrapCallback = function (S) {
            var k = m
            return function () {
              var F = m
              m = k
              try {
                return S.apply(this, arguments)
              } finally {
                m = F
              }
            }
          })
      })(uv)),
    uv
  )
}
var IC
function r7() {
  return IC || ((IC = 1), (cv.exports = n7())), cv.exports
}
var lv = { exports: {} },
  Sr = {}
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var OC
function i7() {
  if (OC) return Sr
  OC = 1
  var t = gd()
  function e(f) {
    var d = 'https://react.dev/errors/' + f
    if (1 < arguments.length) {
      d += '?args[]=' + encodeURIComponent(arguments[1])
      for (var p = 2; p < arguments.length; p++) d += '&args[]=' + encodeURIComponent(arguments[p])
    }
    return (
      'Minified React error #' +
      f +
      '; visit ' +
      d +
      ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    )
  }
  function n() {}
  var r = {
      d: {
        f: n,
        r: function () {
          throw Error(e(522))
        },
        D: n,
        C: n,
        L: n,
        m: n,
        X: n,
        S: n,
        M: n
      },
      p: 0,
      findDOMNode: null
    },
    i = Symbol.for('react.portal')
  function s(f, d, p) {
    var g = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
    return {
      $$typeof: i,
      key: g == null ? null : '' + g,
      children: f,
      containerInfo: d,
      implementation: p
    }
  }
  var c = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
  function u(f, d) {
    if (f === 'font') return ''
    if (typeof d == 'string') return d === 'use-credentials' ? d : ''
  }
  return (
    (Sr.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r),
    (Sr.createPortal = function (f, d) {
      var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
      if (!d || (d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11)) throw Error(e(299))
      return s(f, d, null, p)
    }),
    (Sr.flushSync = function (f) {
      var d = c.T,
        p = r.p
      try {
        if (((c.T = null), (r.p = 2), f)) return f()
      } finally {
        ;(c.T = d), (r.p = p), r.d.f()
      }
    }),
    (Sr.preconnect = function (f, d) {
      typeof f == 'string' &&
        (d
          ? ((d = d.crossOrigin),
            (d = typeof d == 'string' ? (d === 'use-credentials' ? d : '') : void 0))
          : (d = null),
        r.d.C(f, d))
    }),
    (Sr.prefetchDNS = function (f) {
      typeof f == 'string' && r.d.D(f)
    }),
    (Sr.preinit = function (f, d) {
      if (typeof f == 'string' && d && typeof d.as == 'string') {
        var p = d.as,
          g = u(p, d.crossOrigin),
          m = typeof d.integrity == 'string' ? d.integrity : void 0,
          y = typeof d.fetchPriority == 'string' ? d.fetchPriority : void 0
        p === 'style'
          ? r.d.S(f, typeof d.precedence == 'string' ? d.precedence : void 0, {
              crossOrigin: g,
              integrity: m,
              fetchPriority: y
            })
          : p === 'script' &&
            r.d.X(f, {
              crossOrigin: g,
              integrity: m,
              fetchPriority: y,
              nonce: typeof d.nonce == 'string' ? d.nonce : void 0
            })
      }
    }),
    (Sr.preinitModule = function (f, d) {
      if (typeof f == 'string')
        if (typeof d == 'object' && d !== null) {
          if (d.as == null || d.as === 'script') {
            var p = u(d.as, d.crossOrigin)
            r.d.M(f, {
              crossOrigin: p,
              integrity: typeof d.integrity == 'string' ? d.integrity : void 0,
              nonce: typeof d.nonce == 'string' ? d.nonce : void 0
            })
          }
        } else d == null && r.d.M(f)
    }),
    (Sr.preload = function (f, d) {
      if (typeof f == 'string' && typeof d == 'object' && d !== null && typeof d.as == 'string') {
        var p = d.as,
          g = u(p, d.crossOrigin)
        r.d.L(f, p, {
          crossOrigin: g,
          integrity: typeof d.integrity == 'string' ? d.integrity : void 0,
          nonce: typeof d.nonce == 'string' ? d.nonce : void 0,
          type: typeof d.type == 'string' ? d.type : void 0,
          fetchPriority: typeof d.fetchPriority == 'string' ? d.fetchPriority : void 0,
          referrerPolicy: typeof d.referrerPolicy == 'string' ? d.referrerPolicy : void 0,
          imageSrcSet: typeof d.imageSrcSet == 'string' ? d.imageSrcSet : void 0,
          imageSizes: typeof d.imageSizes == 'string' ? d.imageSizes : void 0,
          media: typeof d.media == 'string' ? d.media : void 0
        })
      }
    }),
    (Sr.preloadModule = function (f, d) {
      if (typeof f == 'string')
        if (d) {
          var p = u(d.as, d.crossOrigin)
          r.d.m(f, {
            as: typeof d.as == 'string' && d.as !== 'script' ? d.as : void 0,
            crossOrigin: p,
            integrity: typeof d.integrity == 'string' ? d.integrity : void 0
          })
        } else r.d.m(f)
    }),
    (Sr.requestFormReset = function (f) {
      r.d.r(f)
    }),
    (Sr.unstable_batchedUpdates = function (f, d) {
      return f(d)
    }),
    (Sr.useFormState = function (f, d, p) {
      return c.H.useFormState(f, d, p)
    }),
    (Sr.useFormStatus = function () {
      return c.H.useHostTransitionStatus()
    }),
    (Sr.version = '19.0.0'),
    Sr
  )
}
var RC
function s7() {
  if (RC) return lv.exports
  RC = 1
  function t() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)
      } catch (e) {
        console.error(e)
      }
  }
  return t(), (lv.exports = i7()), lv.exports
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var DC
function a7() {
  if (DC) return If
  DC = 1
  var t = r7(),
    e = gd(),
    n = s7()
  function r(a) {
    var o = 'https://react.dev/errors/' + a
    if (1 < arguments.length) {
      o += '?args[]=' + encodeURIComponent(arguments[1])
      for (var l = 2; l < arguments.length; l++) o += '&args[]=' + encodeURIComponent(arguments[l])
    }
    return (
      'Minified React error #' +
      a +
      '; visit ' +
      o +
      ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    )
  }
  function i(a) {
    return !(!a || (a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11))
  }
  var s = Symbol.for('react.element'),
    c = Symbol.for('react.transitional.element'),
    u = Symbol.for('react.portal'),
    f = Symbol.for('react.fragment'),
    d = Symbol.for('react.strict_mode'),
    p = Symbol.for('react.profiler'),
    g = Symbol.for('react.provider'),
    m = Symbol.for('react.consumer'),
    y = Symbol.for('react.context'),
    A = Symbol.for('react.forward_ref'),
    E = Symbol.for('react.suspense'),
    x = Symbol.for('react.suspense_list'),
    O = Symbol.for('react.memo'),
    I = Symbol.for('react.lazy'),
    M = Symbol.for('react.offscreen'),
    $ = Symbol.for('react.memo_cache_sentinel'),
    D = Symbol.iterator
  function R(a) {
    return a === null || typeof a != 'object'
      ? null
      : ((a = (D && a[D]) || a['@@iterator']), typeof a == 'function' ? a : null)
  }
  var z = Symbol.for('react.client.reference')
  function G(a) {
    if (a == null) return null
    if (typeof a == 'function') return a.$$typeof === z ? null : a.displayName || a.name || null
    if (typeof a == 'string') return a
    switch (a) {
      case f:
        return 'Fragment'
      case u:
        return 'Portal'
      case p:
        return 'Profiler'
      case d:
        return 'StrictMode'
      case E:
        return 'Suspense'
      case x:
        return 'SuspenseList'
    }
    if (typeof a == 'object')
      switch (a.$$typeof) {
        case y:
          return (a.displayName || 'Context') + '.Provider'
        case m:
          return (a._context.displayName || 'Context') + '.Consumer'
        case A:
          var o = a.render
          return (
            (a = a.displayName),
            a ||
              ((a = o.displayName || o.name || ''),
              (a = a !== '' ? 'ForwardRef(' + a + ')' : 'ForwardRef')),
            a
          )
        case O:
          return (o = a.displayName || null), o !== null ? o : G(a.type) || 'Memo'
        case I:
          ;(o = a._payload), (a = a._init)
          try {
            return G(a(o))
          } catch {}
      }
    return null
  }
  var j = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    V = Object.assign,
    L,
    v
  function C(a) {
    if (L === void 0)
      try {
        throw Error()
      } catch (l) {
        var o = l.stack.trim().match(/\n( *(at )?)/)
        ;(L = (o && o[1]) || ''),
          (v =
            -1 <
            l.stack.indexOf(`
    at`)
              ? ' (<anonymous>)'
              : -1 < l.stack.indexOf('@')
                ? '@unknown:0:0'
                : '')
      }
    return (
      `
` +
      L +
      a +
      v
    )
  }
  var N = !1
  function T(a, o) {
    if (!a || N) return ''
    N = !0
    var l = Error.prepareStackTrace
    Error.prepareStackTrace = void 0
    try {
      var h = {
        DetermineComponentFrameRoot: function () {
          try {
            if (o) {
              var le = function () {
                throw Error()
              }
              if (
                (Object.defineProperty(le.prototype, 'props', {
                  set: function () {
                    throw Error()
                  }
                }),
                typeof Reflect == 'object' && Reflect.construct)
              ) {
                try {
                  Reflect.construct(le, [])
                } catch (ae) {
                  var ie = ae
                }
                Reflect.construct(a, [], le)
              } else {
                try {
                  le.call()
                } catch (ae) {
                  ie = ae
                }
                a.call(le.prototype)
              }
            } else {
              try {
                throw Error()
              } catch (ae) {
                ie = ae
              }
              ;(le = a()) && typeof le.catch == 'function' && le.catch(function () {})
            }
          } catch (ae) {
            if (ae && ie && typeof ae.stack == 'string') return [ae.stack, ie.stack]
          }
          return [null, null]
        }
      }
      h.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot'
      var b = Object.getOwnPropertyDescriptor(h.DetermineComponentFrameRoot, 'name')
      b &&
        b.configurable &&
        Object.defineProperty(h.DetermineComponentFrameRoot, 'name', {
          value: 'DetermineComponentFrameRoot'
        })
      var _ = h.DetermineComponentFrameRoot(),
        U = _[0],
        q = _[1]
      if (U && q) {
        var K = U.split(`
`),
          J = q.split(`
`)
        for (b = h = 0; h < K.length && !K[h].includes('DetermineComponentFrameRoot'); ) h++
        for (; b < J.length && !J[b].includes('DetermineComponentFrameRoot'); ) b++
        if (h === K.length || b === J.length)
          for (h = K.length - 1, b = J.length - 1; 1 <= h && 0 <= b && K[h] !== J[b]; ) b--
        for (; 1 <= h && 0 <= b; h--, b--)
          if (K[h] !== J[b]) {
            if (h !== 1 || b !== 1)
              do
                if ((h--, b--, 0 > b || K[h] !== J[b])) {
                  var oe =
                    `
` + K[h].replace(' at new ', ' at ')
                  return (
                    a.displayName &&
                      oe.includes('<anonymous>') &&
                      (oe = oe.replace('<anonymous>', a.displayName)),
                    oe
                  )
                }
              while (1 <= h && 0 <= b)
            break
          }
      }
    } finally {
      ;(N = !1), (Error.prepareStackTrace = l)
    }
    return (l = a ? a.displayName || a.name : '') ? C(l) : ''
  }
  function S(a) {
    switch (a.tag) {
      case 26:
      case 27:
      case 5:
        return C(a.type)
      case 16:
        return C('Lazy')
      case 13:
        return C('Suspense')
      case 19:
        return C('SuspenseList')
      case 0:
      case 15:
        return (a = T(a.type, !1)), a
      case 11:
        return (a = T(a.type.render, !1)), a
      case 1:
        return (a = T(a.type, !0)), a
      default:
        return ''
    }
  }
  function k(a) {
    try {
      var o = ''
      do (o += S(a)), (a = a.return)
      while (a)
      return o
    } catch (l) {
      return (
        `
Error generating stack: ` +
        l.message +
        `
` +
        l.stack
      )
    }
  }
  function F(a) {
    var o = a,
      l = a
    if (a.alternate) for (; o.return; ) o = o.return
    else {
      a = o
      do (o = a), (o.flags & 4098) !== 0 && (l = o.return), (a = o.return)
      while (a)
    }
    return o.tag === 3 ? l : null
  }
  function P(a) {
    if (a.tag === 13) {
      var o = a.memoizedState
      if ((o === null && ((a = a.alternate), a !== null && (o = a.memoizedState)), o !== null))
        return o.dehydrated
    }
    return null
  }
  function w(a) {
    if (F(a) !== a) throw Error(r(188))
  }
  function B(a) {
    var o = a.alternate
    if (!o) {
      if (((o = F(a)), o === null)) throw Error(r(188))
      return o !== a ? null : a
    }
    for (var l = a, h = o; ; ) {
      var b = l.return
      if (b === null) break
      var _ = b.alternate
      if (_ === null) {
        if (((h = b.return), h !== null)) {
          l = h
          continue
        }
        break
      }
      if (b.child === _.child) {
        for (_ = b.child; _; ) {
          if (_ === l) return w(b), a
          if (_ === h) return w(b), o
          _ = _.sibling
        }
        throw Error(r(188))
      }
      if (l.return !== h.return) (l = b), (h = _)
      else {
        for (var U = !1, q = b.child; q; ) {
          if (q === l) {
            ;(U = !0), (l = b), (h = _)
            break
          }
          if (q === h) {
            ;(U = !0), (h = b), (l = _)
            break
          }
          q = q.sibling
        }
        if (!U) {
          for (q = _.child; q; ) {
            if (q === l) {
              ;(U = !0), (l = _), (h = b)
              break
            }
            if (q === h) {
              ;(U = !0), (h = _), (l = b)
              break
            }
            q = q.sibling
          }
          if (!U) throw Error(r(189))
        }
      }
      if (l.alternate !== h) throw Error(r(190))
    }
    if (l.tag !== 3) throw Error(r(188))
    return l.stateNode.current === l ? a : o
  }
  function Z(a) {
    var o = a.tag
    if (o === 5 || o === 26 || o === 27 || o === 6) return a
    for (a = a.child; a !== null; ) {
      if (((o = Z(a)), o !== null)) return o
      a = a.sibling
    }
    return null
  }
  var ee = Array.isArray,
    Y = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    se = { pending: !1, data: null, method: null, action: null },
    ce = [],
    we = -1
  function _e(a) {
    return { current: a }
  }
  function ye(a) {
    0 > we || ((a.current = ce[we]), (ce[we] = null), we--)
  }
  function Ce(a, o) {
    we++, (ce[we] = a.current), (a.current = o)
  }
  var kt = _e(null),
    tt = _e(null),
    Ke = _e(null),
    jn = _e(null)
  function ut(a, o) {
    switch ((Ce(Ke, o), Ce(tt, a), Ce(kt, null), (a = o.nodeType), a)) {
      case 9:
      case 11:
        o = (o = o.documentElement) && (o = o.namespaceURI) ? X_(o) : 0
        break
      default:
        if (((a = a === 8 ? o.parentNode : o), (o = a.tagName), (a = a.namespaceURI)))
          (a = X_(a)), (o = J_(a, o))
        else
          switch (o) {
            case 'svg':
              o = 1
              break
            case 'math':
              o = 2
              break
            default:
              o = 0
          }
    }
    ye(kt), Ce(kt, o)
  }
  function lt() {
    ye(kt), ye(tt), ye(Ke)
  }
  function qr(a) {
    a.memoizedState !== null && Ce(jn, a)
    var o = kt.current,
      l = J_(o, a.type)
    o !== l && (Ce(tt, a), Ce(kt, l))
  }
  function It(a) {
    tt.current === a && (ye(kt), ye(tt)), jn.current === a && (ye(jn), (_f._currentValue = se))
  }
  var Ot = Object.prototype.hasOwnProperty,
    yi = t.unstable_scheduleCallback,
    xt = t.unstable_cancelCallback,
    zt = t.unstable_shouldYield,
    ms = t.unstable_requestPaint,
    Je = t.unstable_now,
    Rt = t.unstable_getCurrentPriorityLevel,
    Ki = t.unstable_ImmediatePriority,
    qt = t.unstable_UserBlockingPriority,
    Zt = t.unstable_NormalPriority,
    _u = t.unstable_LowPriority,
    dn = t.unstable_IdlePriority,
    Tn = t.log,
    Bp = t.unstable_setDisableYieldValue,
    rn = null,
    mt = null
  function Lp(a) {
    if (mt && typeof mt.onCommitFiberRoot == 'function')
      try {
        mt.onCommitFiberRoot(rn, a, void 0, (a.current.flags & 128) === 128)
      } catch {}
  }
  function Ut(a) {
    if ((typeof Tn == 'function' && Bp(a), mt && typeof mt.setStrictMode == 'function'))
      try {
        mt.setStrictMode(rn, a)
      } catch {}
  }
  var bt = Math.clz32 ? Math.clz32 : Nn,
    $p = Math.log,
    xn = Math.LN2
  function Nn(a) {
    return (a >>>= 0), a === 0 ? 32 : (31 - (($p(a) / xn) | 0)) | 0
  }
  var Zo = 128,
    fn = 4194304
  function Ht(a) {
    var o = a & 42
    if (o !== 0) return o
    switch (a & -a) {
      case 1:
        return 1
      case 2:
        return 2
      case 4:
        return 4
      case 8:
        return 8
      case 16:
        return 16
      case 32:
        return 32
      case 64:
        return 64
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194176
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return a & 62914560
      case 67108864:
        return 67108864
      case 134217728:
        return 134217728
      case 268435456:
        return 268435456
      case 536870912:
        return 536870912
      case 1073741824:
        return 0
      default:
        return a
    }
  }
  function Xo(a, o) {
    var l = a.pendingLanes
    if (l === 0) return 0
    var h = 0,
      b = a.suspendedLanes,
      _ = a.pingedLanes,
      U = a.warmLanes
    a = a.finishedLanes !== 0
    var q = l & 134217727
    return (
      q !== 0
        ? ((l = q & ~b),
          l !== 0
            ? (h = Ht(l))
            : ((_ &= q), _ !== 0 ? (h = Ht(_)) : a || ((U = q & ~U), U !== 0 && (h = Ht(U)))))
        : ((q = l & ~b),
          q !== 0
            ? (h = Ht(q))
            : _ !== 0
              ? (h = Ht(_))
              : a || ((U = l & ~U), U !== 0 && (h = Ht(U)))),
      h === 0
        ? 0
        : o !== 0 &&
            o !== h &&
            (o & b) === 0 &&
            ((b = h & -h), (U = o & -o), b >= U || (b === 32 && (U & 4194176) !== 0))
          ? o
          : h
    )
  }
  function sn(a, o) {
    return (a.pendingLanes & ~(a.suspendedLanes & ~a.pingedLanes) & o) === 0
  }
  function In(a, o) {
    switch (a) {
      case 1:
      case 2:
      case 4:
      case 8:
        return o + 250
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o + 5e3
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1
      default:
        return -1
    }
  }
  function Od() {
    var a = Zo
    return (Zo <<= 1), (Zo & 4194176) === 0 && (Zo = 128), a
  }
  function vn() {
    var a = fn
    return (fn <<= 1), (fn & 62914560) === 0 && (fn = 4194304), a
  }
  function mn(a) {
    for (var o = [], l = 0; 31 > l; l++) o.push(a)
    return o
  }
  function za(a, o) {
    ;(a.pendingLanes |= o),
      o !== 268435456 && ((a.suspendedLanes = 0), (a.pingedLanes = 0), (a.warmLanes = 0))
  }
  function On(a, o, l, h, b, _) {
    var U = a.pendingLanes
    ;(a.pendingLanes = l),
      (a.suspendedLanes = 0),
      (a.pingedLanes = 0),
      (a.warmLanes = 0),
      (a.expiredLanes &= l),
      (a.entangledLanes &= l),
      (a.errorRecoveryDisabledLanes &= l),
      (a.shellSuspendCounter = 0)
    var q = a.entanglements,
      K = a.expirationTimes,
      J = a.hiddenUpdates
    for (l = U & ~l; 0 < l; ) {
      var oe = 31 - bt(l),
        le = 1 << oe
      ;(q[oe] = 0), (K[oe] = -1)
      var ie = J[oe]
      if (ie !== null)
        for (J[oe] = null, oe = 0; oe < ie.length; oe++) {
          var ae = ie[oe]
          ae !== null && (ae.lane &= -536870913)
        }
      l &= ~le
    }
    h !== 0 && wn(a, h, 0), _ !== 0 && b === 0 && a.tag !== 0 && (a.suspendedLanes |= _ & ~(U & ~o))
  }
  function wn(a, o, l) {
    ;(a.pendingLanes |= o), (a.suspendedLanes &= ~o)
    var h = 31 - bt(o)
    ;(a.entangledLanes |= o), (a.entanglements[h] = a.entanglements[h] | 1073741824 | (l & 4194218))
  }
  function Rd(a, o) {
    var l = (a.entangledLanes |= o)
    for (a = a.entanglements; l; ) {
      var h = 31 - bt(l),
        b = 1 << h
      ;(b & o) | (a[h] & o) && (a[h] |= o), (l &= ~b)
    }
  }
  function En(a) {
    return (a &= -a), 2 < a ? (8 < a ? ((a & 134217727) !== 0 ? 32 : 268435456) : 8) : 2
  }
  function An() {
    var a = Y.p
    return a !== 0 ? a : ((a = window.event), a === void 0 ? 32 : bC(a.type))
  }
  function Fp(a, o) {
    var l = Y.p
    try {
      return (Y.p = a), o()
    } finally {
      Y.p = l
    }
  }
  var Bt = Math.random().toString(36).slice(2),
    st = '__reactFiber$' + Bt,
    dr = '__reactProps$' + Bt,
    Xt = '__reactContainer$' + Bt,
    bn = '__reactEvents$' + Bt,
    Dd = '__reactListeners$' + Bt,
    Pd = '__reactHandles$' + Bt,
    Cu = '__reactResources$' + Bt,
    Zs = '__reactMarker$' + Bt
  function Jo(a) {
    delete a[st], delete a[dr], delete a[bn], delete a[Dd], delete a[Pd]
  }
  function Wi(a) {
    var o = a[st]
    if (o) return o
    for (var l = a.parentNode; l; ) {
      if ((o = l[Xt] || l[st])) {
        if (((l = o.alternate), o.child !== null || (l !== null && l.child !== null)))
          for (a = nC(a); a !== null; ) {
            if ((l = a[st])) return l
            a = nC(a)
          }
        return o
      }
      ;(a = l), (l = a.parentNode)
    }
    return null
  }
  function bs(a) {
    if ((a = a[st] || a[Xt])) {
      var o = a.tag
      if (o === 5 || o === 6 || o === 13 || o === 26 || o === 27 || o === 3) return a
    }
    return null
  }
  function Xs(a) {
    var o = a.tag
    if (o === 5 || o === 26 || o === 27 || o === 6) return a.stateNode
    throw Error(r(33))
  }
  function ys(a) {
    var o = a[Cu]
    return o || (o = a[Cu] = { hoistableStyles: new Map(), hoistableScripts: new Map() }), o
  }
  function Rn(a) {
    a[Zs] = !0
  }
  var Su = new Set(),
    Tu = {}
  function Qi(a, o) {
    vs(a, o), vs(a + 'Capture', o)
  }
  function vs(a, o) {
    for (Tu[a] = o, a = 0; a < o.length; a++) Su.add(o[a])
  }
  var ii = !(
      typeof window > 'u' ||
      typeof window.document > 'u' ||
      typeof window.document.createElement > 'u'
    ),
    Md = RegExp(
      '^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'
    ),
    xu = {},
    Nu = {}
  function kd(a) {
    return Ot.call(Nu, a)
      ? !0
      : Ot.call(xu, a)
        ? !1
        : Md.test(a)
          ? (Nu[a] = !0)
          : ((xu[a] = !0), !1)
  }
  function jp(a, o, l) {
    if (kd(o))
      if (l === null) a.removeAttribute(o)
      else {
        switch (typeof l) {
          case 'undefined':
          case 'function':
          case 'symbol':
            a.removeAttribute(o)
            return
          case 'boolean':
            var h = o.toLowerCase().slice(0, 5)
            if (h !== 'data-' && h !== 'aria-') {
              a.removeAttribute(o)
              return
            }
        }
        a.setAttribute(o, '' + l)
      }
  }
  function zp(a, o, l) {
    if (l === null) a.removeAttribute(o)
    else {
      switch (typeof l) {
        case 'undefined':
        case 'function':
        case 'symbol':
        case 'boolean':
          a.removeAttribute(o)
          return
      }
      a.setAttribute(o, '' + l)
    }
  }
  function Js(a, o, l, h) {
    if (h === null) a.removeAttribute(l)
    else {
      switch (typeof h) {
        case 'undefined':
        case 'function':
        case 'symbol':
        case 'boolean':
          a.removeAttribute(l)
          return
      }
      a.setAttributeNS(o, l, '' + h)
    }
  }
  function vi(a) {
    switch (typeof a) {
      case 'bigint':
      case 'boolean':
      case 'number':
      case 'string':
      case 'undefined':
        return a
      case 'object':
        return a
      default:
        return ''
    }
  }
  function tA(a) {
    var o = a.type
    return (a = a.nodeName) && a.toLowerCase() === 'input' && (o === 'checkbox' || o === 'radio')
  }
  function KI(a) {
    var o = tA(a) ? 'checked' : 'value',
      l = Object.getOwnPropertyDescriptor(a.constructor.prototype, o),
      h = '' + a[o]
    if (
      !a.hasOwnProperty(o) &&
      typeof l < 'u' &&
      typeof l.get == 'function' &&
      typeof l.set == 'function'
    ) {
      var b = l.get,
        _ = l.set
      return (
        Object.defineProperty(a, o, {
          configurable: !0,
          get: function () {
            return b.call(this)
          },
          set: function (U) {
            ;(h = '' + U), _.call(this, U)
          }
        }),
        Object.defineProperty(a, o, { enumerable: l.enumerable }),
        {
          getValue: function () {
            return h
          },
          setValue: function (U) {
            h = '' + U
          },
          stopTracking: function () {
            ;(a._valueTracker = null), delete a[o]
          }
        }
      )
    }
  }
  function qp(a) {
    a._valueTracker || (a._valueTracker = KI(a))
  }
  function nA(a) {
    if (!a) return !1
    var o = a._valueTracker
    if (!o) return !0
    var l = o.getValue(),
      h = ''
    return (
      a && (h = tA(a) ? (a.checked ? 'true' : 'false') : a.value),
      (a = h),
      a !== l ? (o.setValue(a), !0) : !1
    )
  }
  function Hp(a) {
    if (((a = a || (typeof document < 'u' ? document : void 0)), typeof a > 'u')) return null
    try {
      return a.activeElement || a.body
    } catch {
      return a.body
    }
  }
  var WI = /[\n"\\]/g
  function wi(a) {
    return a.replace(WI, function (o) {
      return '\\' + o.charCodeAt(0).toString(16) + ' '
    })
  }
  function nb(a, o, l, h, b, _, U, q) {
    ;(a.name = ''),
      U != null && typeof U != 'function' && typeof U != 'symbol' && typeof U != 'boolean'
        ? (a.type = U)
        : a.removeAttribute('type'),
      o != null
        ? U === 'number'
          ? ((o === 0 && a.value === '') || a.value != o) && (a.value = '' + vi(o))
          : a.value !== '' + vi(o) && (a.value = '' + vi(o))
        : (U !== 'submit' && U !== 'reset') || a.removeAttribute('value'),
      o != null
        ? rb(a, U, vi(o))
        : l != null
          ? rb(a, U, vi(l))
          : h != null && a.removeAttribute('value'),
      b == null && _ != null && (a.defaultChecked = !!_),
      b != null && (a.checked = b && typeof b != 'function' && typeof b != 'symbol'),
      q != null && typeof q != 'function' && typeof q != 'symbol' && typeof q != 'boolean'
        ? (a.name = '' + vi(q))
        : a.removeAttribute('name')
  }
  function rA(a, o, l, h, b, _, U, q) {
    if (
      (_ != null &&
        typeof _ != 'function' &&
        typeof _ != 'symbol' &&
        typeof _ != 'boolean' &&
        (a.type = _),
      o != null || l != null)
    ) {
      if (!((_ !== 'submit' && _ !== 'reset') || o != null)) return
      ;(l = l != null ? '' + vi(l) : ''),
        (o = o != null ? '' + vi(o) : l),
        q || o === a.value || (a.value = o),
        (a.defaultValue = o)
    }
    ;(h = h ?? b),
      (h = typeof h != 'function' && typeof h != 'symbol' && !!h),
      (a.checked = q ? a.checked : !!h),
      (a.defaultChecked = !!h),
      U != null &&
        typeof U != 'function' &&
        typeof U != 'symbol' &&
        typeof U != 'boolean' &&
        (a.name = U)
  }
  function rb(a, o, l) {
    ;(o === 'number' && Hp(a.ownerDocument) === a) ||
      a.defaultValue === '' + l ||
      (a.defaultValue = '' + l)
  }
  function Iu(a, o, l, h) {
    if (((a = a.options), o)) {
      o = {}
      for (var b = 0; b < l.length; b++) o['$' + l[b]] = !0
      for (l = 0; l < a.length; l++)
        (b = o.hasOwnProperty('$' + a[l].value)),
          a[l].selected !== b && (a[l].selected = b),
          b && h && (a[l].defaultSelected = !0)
    } else {
      for (l = '' + vi(l), o = null, b = 0; b < a.length; b++) {
        if (a[b].value === l) {
          ;(a[b].selected = !0), h && (a[b].defaultSelected = !0)
          return
        }
        o !== null || a[b].disabled || (o = a[b])
      }
      o !== null && (o.selected = !0)
    }
  }
  function iA(a, o, l) {
    if (o != null && ((o = '' + vi(o)), o !== a.value && (a.value = o), l == null)) {
      a.defaultValue !== o && (a.defaultValue = o)
      return
    }
    a.defaultValue = l != null ? '' + vi(l) : ''
  }
  function sA(a, o, l, h) {
    if (o == null) {
      if (h != null) {
        if (l != null) throw Error(r(92))
        if (ee(h)) {
          if (1 < h.length) throw Error(r(93))
          h = h[0]
        }
        l = h
      }
      l == null && (l = ''), (o = l)
    }
    ;(l = vi(o)),
      (a.defaultValue = l),
      (h = a.textContent),
      h === l && h !== '' && h !== null && (a.value = h)
  }
  function Ou(a, o) {
    if (o) {
      var l = a.firstChild
      if (l && l === a.lastChild && l.nodeType === 3) {
        l.nodeValue = o
        return
      }
    }
    a.textContent = o
  }
  var QI = new Set(
    'animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp'.split(
      ' '
    )
  )
  function aA(a, o, l) {
    var h = o.indexOf('--') === 0
    l == null || typeof l == 'boolean' || l === ''
      ? h
        ? a.setProperty(o, '')
        : o === 'float'
          ? (a.cssFloat = '')
          : (a[o] = '')
      : h
        ? a.setProperty(o, l)
        : typeof l != 'number' || l === 0 || QI.has(o)
          ? o === 'float'
            ? (a.cssFloat = l)
            : (a[o] = ('' + l).trim())
          : (a[o] = l + 'px')
  }
  function oA(a, o, l) {
    if (o != null && typeof o != 'object') throw Error(r(62))
    if (((a = a.style), l != null)) {
      for (var h in l)
        !l.hasOwnProperty(h) ||
          (o != null && o.hasOwnProperty(h)) ||
          (h.indexOf('--') === 0
            ? a.setProperty(h, '')
            : h === 'float'
              ? (a.cssFloat = '')
              : (a[h] = ''))
      for (var b in o) (h = o[b]), o.hasOwnProperty(b) && l[b] !== h && aA(a, b, h)
    } else for (var _ in o) o.hasOwnProperty(_) && aA(a, _, o[_])
  }
  function ib(a) {
    if (a.indexOf('-') === -1) return !1
    switch (a) {
      case 'annotation-xml':
      case 'color-profile':
      case 'font-face':
      case 'font-face-src':
      case 'font-face-uri':
      case 'font-face-format':
      case 'font-face-name':
      case 'missing-glyph':
        return !1
      default:
        return !0
    }
  }
  var YI = new Map([
      ['acceptCharset', 'accept-charset'],
      ['htmlFor', 'for'],
      ['httpEquiv', 'http-equiv'],
      ['crossOrigin', 'crossorigin'],
      ['accentHeight', 'accent-height'],
      ['alignmentBaseline', 'alignment-baseline'],
      ['arabicForm', 'arabic-form'],
      ['baselineShift', 'baseline-shift'],
      ['capHeight', 'cap-height'],
      ['clipPath', 'clip-path'],
      ['clipRule', 'clip-rule'],
      ['colorInterpolation', 'color-interpolation'],
      ['colorInterpolationFilters', 'color-interpolation-filters'],
      ['colorProfile', 'color-profile'],
      ['colorRendering', 'color-rendering'],
      ['dominantBaseline', 'dominant-baseline'],
      ['enableBackground', 'enable-background'],
      ['fillOpacity', 'fill-opacity'],
      ['fillRule', 'fill-rule'],
      ['floodColor', 'flood-color'],
      ['floodOpacity', 'flood-opacity'],
      ['fontFamily', 'font-family'],
      ['fontSize', 'font-size'],
      ['fontSizeAdjust', 'font-size-adjust'],
      ['fontStretch', 'font-stretch'],
      ['fontStyle', 'font-style'],
      ['fontVariant', 'font-variant'],
      ['fontWeight', 'font-weight'],
      ['glyphName', 'glyph-name'],
      ['glyphOrientationHorizontal', 'glyph-orientation-horizontal'],
      ['glyphOrientationVertical', 'glyph-orientation-vertical'],
      ['horizAdvX', 'horiz-adv-x'],
      ['horizOriginX', 'horiz-origin-x'],
      ['imageRendering', 'image-rendering'],
      ['letterSpacing', 'letter-spacing'],
      ['lightingColor', 'lighting-color'],
      ['markerEnd', 'marker-end'],
      ['markerMid', 'marker-mid'],
      ['markerStart', 'marker-start'],
      ['overlinePosition', 'overline-position'],
      ['overlineThickness', 'overline-thickness'],
      ['paintOrder', 'paint-order'],
      ['panose-1', 'panose-1'],
      ['pointerEvents', 'pointer-events'],
      ['renderingIntent', 'rendering-intent'],
      ['shapeRendering', 'shape-rendering'],
      ['stopColor', 'stop-color'],
      ['stopOpacity', 'stop-opacity'],
      ['strikethroughPosition', 'strikethrough-position'],
      ['strikethroughThickness', 'strikethrough-thickness'],
      ['strokeDasharray', 'stroke-dasharray'],
      ['strokeDashoffset', 'stroke-dashoffset'],
      ['strokeLinecap', 'stroke-linecap'],
      ['strokeLinejoin', 'stroke-linejoin'],
      ['strokeMiterlimit', 'stroke-miterlimit'],
      ['strokeOpacity', 'stroke-opacity'],
      ['strokeWidth', 'stroke-width'],
      ['textAnchor', 'text-anchor'],
      ['textDecoration', 'text-decoration'],
      ['textRendering', 'text-rendering'],
      ['transformOrigin', 'transform-origin'],
      ['underlinePosition', 'underline-position'],
      ['underlineThickness', 'underline-thickness'],
      ['unicodeBidi', 'unicode-bidi'],
      ['unicodeRange', 'unicode-range'],
      ['unitsPerEm', 'units-per-em'],
      ['vAlphabetic', 'v-alphabetic'],
      ['vHanging', 'v-hanging'],
      ['vIdeographic', 'v-ideographic'],
      ['vMathematical', 'v-mathematical'],
      ['vectorEffect', 'vector-effect'],
      ['vertAdvY', 'vert-adv-y'],
      ['vertOriginX', 'vert-origin-x'],
      ['vertOriginY', 'vert-origin-y'],
      ['wordSpacing', 'word-spacing'],
      ['writingMode', 'writing-mode'],
      ['xmlnsXlink', 'xmlns:xlink'],
      ['xHeight', 'x-height']
    ]),
    ZI =
      /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i
  function Gp(a) {
    return ZI.test('' + a)
      ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
      : a
  }
  var sb = null
  function ab(a) {
    return (
      (a = a.target || a.srcElement || window),
      a.correspondingUseElement && (a = a.correspondingUseElement),
      a.nodeType === 3 ? a.parentNode : a
    )
  }
  var Ru = null,
    Du = null
  function cA(a) {
    var o = bs(a)
    if (o && (a = o.stateNode)) {
      var l = a[dr] || null
      e: switch (((a = o.stateNode), o.type)) {
        case 'input':
          if (
            (nb(
              a,
              l.value,
              l.defaultValue,
              l.defaultValue,
              l.checked,
              l.defaultChecked,
              l.type,
              l.name
            ),
            (o = l.name),
            l.type === 'radio' && o != null)
          ) {
            for (l = a; l.parentNode; ) l = l.parentNode
            for (
              l = l.querySelectorAll('input[name="' + wi('' + o) + '"][type="radio"]'), o = 0;
              o < l.length;
              o++
            ) {
              var h = l[o]
              if (h !== a && h.form === a.form) {
                var b = h[dr] || null
                if (!b) throw Error(r(90))
                nb(
                  h,
                  b.value,
                  b.defaultValue,
                  b.defaultValue,
                  b.checked,
                  b.defaultChecked,
                  b.type,
                  b.name
                )
              }
            }
            for (o = 0; o < l.length; o++) (h = l[o]), h.form === a.form && nA(h)
          }
          break e
        case 'textarea':
          iA(a, l.value, l.defaultValue)
          break e
        case 'select':
          ;(o = l.value), o != null && Iu(a, !!l.multiple, o, !1)
      }
    }
  }
  var ob = !1
  function uA(a, o, l) {
    if (ob) return a(o, l)
    ob = !0
    try {
      var h = a(o)
      return h
    } finally {
      if (
        ((ob = !1),
        (Ru !== null || Du !== null) &&
          (N0(), Ru && ((o = Ru), (a = Du), (Du = Ru = null), cA(o), a)))
      )
        for (o = 0; o < a.length; o++) cA(a[o])
    }
  }
  function Ud(a, o) {
    var l = a.stateNode
    if (l === null) return null
    var h = l[dr] || null
    if (h === null) return null
    l = h[o]
    e: switch (o) {
      case 'onClick':
      case 'onClickCapture':
      case 'onDoubleClick':
      case 'onDoubleClickCapture':
      case 'onMouseDown':
      case 'onMouseDownCapture':
      case 'onMouseMove':
      case 'onMouseMoveCapture':
      case 'onMouseUp':
      case 'onMouseUpCapture':
      case 'onMouseEnter':
        ;(h = !h.disabled) ||
          ((a = a.type),
          (h = !(a === 'button' || a === 'input' || a === 'select' || a === 'textarea'))),
          (a = !h)
        break e
      default:
        a = !1
    }
    if (a) return null
    if (l && typeof l != 'function') throw Error(r(231, o, typeof l))
    return l
  }
  var cb = !1
  if (ii)
    try {
      var Bd = {}
      Object.defineProperty(Bd, 'passive', {
        get: function () {
          cb = !0
        }
      }),
        window.addEventListener('test', Bd, Bd),
        window.removeEventListener('test', Bd, Bd)
    } catch {
      cb = !1
    }
  var qa = null,
    ub = null,
    Vp = null
  function lA() {
    if (Vp) return Vp
    var a,
      o = ub,
      l = o.length,
      h,
      b = 'value' in qa ? qa.value : qa.textContent,
      _ = b.length
    for (a = 0; a < l && o[a] === b[a]; a++);
    var U = l - a
    for (h = 1; h <= U && o[l - h] === b[_ - h]; h++);
    return (Vp = b.slice(a, 1 < h ? 1 - h : void 0))
  }
  function Kp(a) {
    var o = a.keyCode
    return (
      'charCode' in a ? ((a = a.charCode), a === 0 && o === 13 && (a = 13)) : (a = o),
      a === 10 && (a = 13),
      32 <= a || a === 13 ? a : 0
    )
  }
  function Wp() {
    return !0
  }
  function dA() {
    return !1
  }
  function Hr(a) {
    function o(l, h, b, _, U) {
      ;(this._reactName = l),
        (this._targetInst = b),
        (this.type = h),
        (this.nativeEvent = _),
        (this.target = U),
        (this.currentTarget = null)
      for (var q in a) a.hasOwnProperty(q) && ((l = a[q]), (this[q] = l ? l(_) : _[q]))
      return (
        (this.isDefaultPrevented = (
          _.defaultPrevented != null ? _.defaultPrevented : _.returnValue === !1
        )
          ? Wp
          : dA),
        (this.isPropagationStopped = dA),
        this
      )
    }
    return (
      V(o.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0
          var l = this.nativeEvent
          l &&
            (l.preventDefault
              ? l.preventDefault()
              : typeof l.returnValue != 'unknown' && (l.returnValue = !1),
            (this.isDefaultPrevented = Wp))
        },
        stopPropagation: function () {
          var l = this.nativeEvent
          l &&
            (l.stopPropagation
              ? l.stopPropagation()
              : typeof l.cancelBubble != 'unknown' && (l.cancelBubble = !0),
            (this.isPropagationStopped = Wp))
        },
        persist: function () {},
        isPersistent: Wp
      }),
      o
    )
  }
  var ec = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (a) {
        return a.timeStamp || Date.now()
      },
      defaultPrevented: 0,
      isTrusted: 0
    },
    Qp = Hr(ec),
    Ld = V({}, ec, { view: 0, detail: 0 }),
    XI = Hr(Ld),
    lb,
    db,
    $d,
    Yp = V({}, Ld, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: hb,
      button: 0,
      buttons: 0,
      relatedTarget: function (a) {
        return a.relatedTarget === void 0
          ? a.fromElement === a.srcElement
            ? a.toElement
            : a.fromElement
          : a.relatedTarget
      },
      movementX: function (a) {
        return 'movementX' in a
          ? a.movementX
          : (a !== $d &&
              ($d && a.type === 'mousemove'
                ? ((lb = a.screenX - $d.screenX), (db = a.screenY - $d.screenY))
                : (db = lb = 0),
              ($d = a)),
            lb)
      },
      movementY: function (a) {
        return 'movementY' in a ? a.movementY : db
      }
    }),
    fA = Hr(Yp),
    JI = V({}, Yp, { dataTransfer: 0 }),
    eO = Hr(JI),
    tO = V({}, Ld, { relatedTarget: 0 }),
    fb = Hr(tO),
    nO = V({}, ec, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    rO = Hr(nO),
    iO = V({}, ec, {
      clipboardData: function (a) {
        return 'clipboardData' in a ? a.clipboardData : window.clipboardData
      }
    }),
    sO = Hr(iO),
    aO = V({}, ec, { data: 0 }),
    hA = Hr(aO),
    oO = {
      Esc: 'Escape',
      Spacebar: ' ',
      Left: 'ArrowLeft',
      Up: 'ArrowUp',
      Right: 'ArrowRight',
      Down: 'ArrowDown',
      Del: 'Delete',
      Win: 'OS',
      Menu: 'ContextMenu',
      Apps: 'ContextMenu',
      Scroll: 'ScrollLock',
      MozPrintableKey: 'Unidentified'
    },
    cO = {
      8: 'Backspace',
      9: 'Tab',
      12: 'Clear',
      13: 'Enter',
      16: 'Shift',
      17: 'Control',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Escape',
      32: ' ',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'ArrowLeft',
      38: 'ArrowUp',
      39: 'ArrowRight',
      40: 'ArrowDown',
      45: 'Insert',
      46: 'Delete',
      112: 'F1',
      113: 'F2',
      114: 'F3',
      115: 'F4',
      116: 'F5',
      117: 'F6',
      118: 'F7',
      119: 'F8',
      120: 'F9',
      121: 'F10',
      122: 'F11',
      123: 'F12',
      144: 'NumLock',
      145: 'ScrollLock',
      224: 'Meta'
    },
    uO = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }
  function lO(a) {
    var o = this.nativeEvent
    return o.getModifierState ? o.getModifierState(a) : (a = uO[a]) ? !!o[a] : !1
  }
  function hb() {
    return lO
  }
  var dO = V({}, Ld, {
      key: function (a) {
        if (a.key) {
          var o = oO[a.key] || a.key
          if (o !== 'Unidentified') return o
        }
        return a.type === 'keypress'
          ? ((a = Kp(a)), a === 13 ? 'Enter' : String.fromCharCode(a))
          : a.type === 'keydown' || a.type === 'keyup'
            ? cO[a.keyCode] || 'Unidentified'
            : ''
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: hb,
      charCode: function (a) {
        return a.type === 'keypress' ? Kp(a) : 0
      },
      keyCode: function (a) {
        return a.type === 'keydown' || a.type === 'keyup' ? a.keyCode : 0
      },
      which: function (a) {
        return a.type === 'keypress'
          ? Kp(a)
          : a.type === 'keydown' || a.type === 'keyup'
            ? a.keyCode
            : 0
      }
    }),
    fO = Hr(dO),
    hO = V({}, Yp, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }),
    pA = Hr(hO),
    pO = V({}, Ld, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: hb
    }),
    gO = Hr(pO),
    mO = V({}, ec, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    bO = Hr(mO),
    yO = V({}, Yp, {
      deltaX: function (a) {
        return 'deltaX' in a ? a.deltaX : 'wheelDeltaX' in a ? -a.wheelDeltaX : 0
      },
      deltaY: function (a) {
        return 'deltaY' in a
          ? a.deltaY
          : 'wheelDeltaY' in a
            ? -a.wheelDeltaY
            : 'wheelDelta' in a
              ? -a.wheelDelta
              : 0
      },
      deltaZ: 0,
      deltaMode: 0
    }),
    vO = Hr(yO),
    wO = V({}, ec, { newState: 0, oldState: 0 }),
    EO = Hr(wO),
    AO = [9, 13, 27, 32],
    pb = ii && 'CompositionEvent' in window,
    Fd = null
  ii && 'documentMode' in document && (Fd = document.documentMode)
  var _O = ii && 'TextEvent' in window && !Fd,
    gA = ii && (!pb || (Fd && 8 < Fd && 11 >= Fd)),
    mA = ' ',
    bA = !1
  function yA(a, o) {
    switch (a) {
      case 'keyup':
        return AO.indexOf(o.keyCode) !== -1
      case 'keydown':
        return o.keyCode !== 229
      case 'keypress':
      case 'mousedown':
      case 'focusout':
        return !0
      default:
        return !1
    }
  }
  function vA(a) {
    return (a = a.detail), typeof a == 'object' && 'data' in a ? a.data : null
  }
  var Pu = !1
  function CO(a, o) {
    switch (a) {
      case 'compositionend':
        return vA(o)
      case 'keypress':
        return o.which !== 32 ? null : ((bA = !0), mA)
      case 'textInput':
        return (a = o.data), a === mA && bA ? null : a
      default:
        return null
    }
  }
  function SO(a, o) {
    if (Pu)
      return a === 'compositionend' || (!pb && yA(a, o))
        ? ((a = lA()), (Vp = ub = qa = null), (Pu = !1), a)
        : null
    switch (a) {
      case 'paste':
        return null
      case 'keypress':
        if (!(o.ctrlKey || o.altKey || o.metaKey) || (o.ctrlKey && o.altKey)) {
          if (o.char && 1 < o.char.length) return o.char
          if (o.which) return String.fromCharCode(o.which)
        }
        return null
      case 'compositionend':
        return gA && o.locale !== 'ko' ? null : o.data
      default:
        return null
    }
  }
  var TO = {
    color: !0,
    date: !0,
    datetime: !0,
    'datetime-local': !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  }
  function wA(a) {
    var o = a && a.nodeName && a.nodeName.toLowerCase()
    return o === 'input' ? !!TO[a.type] : o === 'textarea'
  }
  function EA(a, o, l, h) {
    Ru ? (Du ? Du.push(h) : (Du = [h])) : (Ru = h),
      (o = P0(o, 'onChange')),
      0 < o.length &&
        ((l = new Qp('onChange', 'change', null, l, h)), a.push({ event: l, listeners: o }))
  }
  var jd = null,
    zd = null
  function xO(a) {
    K_(a, 0)
  }
  function Zp(a) {
    var o = Xs(a)
    if (nA(o)) return a
  }
  function AA(a, o) {
    if (a === 'change') return o
  }
  var _A = !1
  if (ii) {
    var gb
    if (ii) {
      var mb = 'oninput' in document
      if (!mb) {
        var CA = document.createElement('div')
        CA.setAttribute('oninput', 'return;'), (mb = typeof CA.oninput == 'function')
      }
      gb = mb
    } else gb = !1
    _A = gb && (!document.documentMode || 9 < document.documentMode)
  }
  function SA() {
    jd && (jd.detachEvent('onpropertychange', TA), (zd = jd = null))
  }
  function TA(a) {
    if (a.propertyName === 'value' && Zp(zd)) {
      var o = []
      EA(o, zd, a, ab(a)), uA(xO, o)
    }
  }
  function NO(a, o, l) {
    a === 'focusin'
      ? (SA(), (jd = o), (zd = l), jd.attachEvent('onpropertychange', TA))
      : a === 'focusout' && SA()
  }
  function IO(a) {
    if (a === 'selectionchange' || a === 'keyup' || a === 'keydown') return Zp(zd)
  }
  function OO(a, o) {
    if (a === 'click') return Zp(o)
  }
  function RO(a, o) {
    if (a === 'input' || a === 'change') return Zp(o)
  }
  function DO(a, o) {
    return (a === o && (a !== 0 || 1 / a === 1 / o)) || (a !== a && o !== o)
  }
  var si = typeof Object.is == 'function' ? Object.is : DO
  function qd(a, o) {
    if (si(a, o)) return !0
    if (typeof a != 'object' || a === null || typeof o != 'object' || o === null) return !1
    var l = Object.keys(a),
      h = Object.keys(o)
    if (l.length !== h.length) return !1
    for (h = 0; h < l.length; h++) {
      var b = l[h]
      if (!Ot.call(o, b) || !si(a[b], o[b])) return !1
    }
    return !0
  }
  function xA(a) {
    for (; a && a.firstChild; ) a = a.firstChild
    return a
  }
  function NA(a, o) {
    var l = xA(a)
    a = 0
    for (var h; l; ) {
      if (l.nodeType === 3) {
        if (((h = a + l.textContent.length), a <= o && h >= o)) return { node: l, offset: o - a }
        a = h
      }
      e: {
        for (; l; ) {
          if (l.nextSibling) {
            l = l.nextSibling
            break e
          }
          l = l.parentNode
        }
        l = void 0
      }
      l = xA(l)
    }
  }
  function IA(a, o) {
    return a && o
      ? a === o
        ? !0
        : a && a.nodeType === 3
          ? !1
          : o && o.nodeType === 3
            ? IA(a, o.parentNode)
            : 'contains' in a
              ? a.contains(o)
              : a.compareDocumentPosition
                ? !!(a.compareDocumentPosition(o) & 16)
                : !1
      : !1
  }
  function OA(a) {
    a =
      a != null && a.ownerDocument != null && a.ownerDocument.defaultView != null
        ? a.ownerDocument.defaultView
        : window
    for (var o = Hp(a.document); o instanceof a.HTMLIFrameElement; ) {
      try {
        var l = typeof o.contentWindow.location.href == 'string'
      } catch {
        l = !1
      }
      if (l) a = o.contentWindow
      else break
      o = Hp(a.document)
    }
    return o
  }
  function bb(a) {
    var o = a && a.nodeName && a.nodeName.toLowerCase()
    return (
      o &&
      ((o === 'input' &&
        (a.type === 'text' ||
          a.type === 'search' ||
          a.type === 'tel' ||
          a.type === 'url' ||
          a.type === 'password')) ||
        o === 'textarea' ||
        a.contentEditable === 'true')
    )
  }
  function PO(a, o) {
    var l = OA(o)
    o = a.focusedElem
    var h = a.selectionRange
    if (l !== o && o && o.ownerDocument && IA(o.ownerDocument.documentElement, o)) {
      if (h !== null && bb(o)) {
        if (((a = h.start), (l = h.end), l === void 0 && (l = a), 'selectionStart' in o))
          (o.selectionStart = a), (o.selectionEnd = Math.min(l, o.value.length))
        else if (
          ((l = ((a = o.ownerDocument || document) && a.defaultView) || window), l.getSelection)
        ) {
          l = l.getSelection()
          var b = o.textContent.length,
            _ = Math.min(h.start, b)
          ;(h = h.end === void 0 ? _ : Math.min(h.end, b)),
            !l.extend && _ > h && ((b = h), (h = _), (_ = b)),
            (b = NA(o, _))
          var U = NA(o, h)
          b &&
            U &&
            (l.rangeCount !== 1 ||
              l.anchorNode !== b.node ||
              l.anchorOffset !== b.offset ||
              l.focusNode !== U.node ||
              l.focusOffset !== U.offset) &&
            ((a = a.createRange()),
            a.setStart(b.node, b.offset),
            l.removeAllRanges(),
            _ > h
              ? (l.addRange(a), l.extend(U.node, U.offset))
              : (a.setEnd(U.node, U.offset), l.addRange(a)))
        }
      }
      for (a = [], l = o; (l = l.parentNode); )
        l.nodeType === 1 && a.push({ element: l, left: l.scrollLeft, top: l.scrollTop })
      for (typeof o.focus == 'function' && o.focus(), o = 0; o < a.length; o++)
        (l = a[o]), (l.element.scrollLeft = l.left), (l.element.scrollTop = l.top)
    }
  }
  var MO = ii && 'documentMode' in document && 11 >= document.documentMode,
    Mu = null,
    yb = null,
    Hd = null,
    vb = !1
  function RA(a, o, l) {
    var h = l.window === l ? l.document : l.nodeType === 9 ? l : l.ownerDocument
    vb ||
      Mu == null ||
      Mu !== Hp(h) ||
      ((h = Mu),
      'selectionStart' in h && bb(h)
        ? (h = { start: h.selectionStart, end: h.selectionEnd })
        : ((h = ((h.ownerDocument && h.ownerDocument.defaultView) || window).getSelection()),
          (h = {
            anchorNode: h.anchorNode,
            anchorOffset: h.anchorOffset,
            focusNode: h.focusNode,
            focusOffset: h.focusOffset
          })),
      (Hd && qd(Hd, h)) ||
        ((Hd = h),
        (h = P0(yb, 'onSelect')),
        0 < h.length &&
          ((o = new Qp('onSelect', 'select', null, o, l)),
          a.push({ event: o, listeners: h }),
          (o.target = Mu))))
  }
  function tc(a, o) {
    var l = {}
    return (
      (l[a.toLowerCase()] = o.toLowerCase()),
      (l['Webkit' + a] = 'webkit' + o),
      (l['Moz' + a] = 'moz' + o),
      l
    )
  }
  var ku = {
      animationend: tc('Animation', 'AnimationEnd'),
      animationiteration: tc('Animation', 'AnimationIteration'),
      animationstart: tc('Animation', 'AnimationStart'),
      transitionrun: tc('Transition', 'TransitionRun'),
      transitionstart: tc('Transition', 'TransitionStart'),
      transitioncancel: tc('Transition', 'TransitionCancel'),
      transitionend: tc('Transition', 'TransitionEnd')
    },
    wb = {},
    DA = {}
  ii &&
    ((DA = document.createElement('div').style),
    'AnimationEvent' in window ||
      (delete ku.animationend.animation,
      delete ku.animationiteration.animation,
      delete ku.animationstart.animation),
    'TransitionEvent' in window || delete ku.transitionend.transition)
  function nc(a) {
    if (wb[a]) return wb[a]
    if (!ku[a]) return a
    var o = ku[a],
      l
    for (l in o) if (o.hasOwnProperty(l) && l in DA) return (wb[a] = o[l])
    return a
  }
  var PA = nc('animationend'),
    MA = nc('animationiteration'),
    kA = nc('animationstart'),
    kO = nc('transitionrun'),
    UO = nc('transitionstart'),
    BO = nc('transitioncancel'),
    UA = nc('transitionend'),
    BA = new Map(),
    LA =
      'abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel'.split(
        ' '
      )
  function Yi(a, o) {
    BA.set(a, o), Qi(o, [a])
  }
  var Ei = [],
    Uu = 0,
    Eb = 0
  function Xp() {
    for (var a = Uu, o = (Eb = Uu = 0); o < a; ) {
      var l = Ei[o]
      Ei[o++] = null
      var h = Ei[o]
      Ei[o++] = null
      var b = Ei[o]
      Ei[o++] = null
      var _ = Ei[o]
      if (((Ei[o++] = null), h !== null && b !== null)) {
        var U = h.pending
        U === null ? (b.next = b) : ((b.next = U.next), (U.next = b)), (h.pending = b)
      }
      _ !== 0 && $A(l, b, _)
    }
  }
  function Jp(a, o, l, h) {
    ;(Ei[Uu++] = a),
      (Ei[Uu++] = o),
      (Ei[Uu++] = l),
      (Ei[Uu++] = h),
      (Eb |= h),
      (a.lanes |= h),
      (a = a.alternate),
      a !== null && (a.lanes |= h)
  }
  function Ab(a, o, l, h) {
    return Jp(a, o, l, h), e0(a)
  }
  function Ha(a, o) {
    return Jp(a, null, null, o), e0(a)
  }
  function $A(a, o, l) {
    a.lanes |= l
    var h = a.alternate
    h !== null && (h.lanes |= l)
    for (var b = !1, _ = a.return; _ !== null; )
      (_.childLanes |= l),
        (h = _.alternate),
        h !== null && (h.childLanes |= l),
        _.tag === 22 && ((a = _.stateNode), a === null || a._visibility & 1 || (b = !0)),
        (a = _),
        (_ = _.return)
    b &&
      o !== null &&
      a.tag === 3 &&
      ((_ = a.stateNode),
      (b = 31 - bt(l)),
      (_ = _.hiddenUpdates),
      (a = _[b]),
      a === null ? (_[b] = [o]) : a.push(o),
      (o.lane = l | 536870912))
  }
  function e0(a) {
    if (50 < mf) throw ((mf = 0), (Ny = null), Error(r(185)))
    for (var o = a.return; o !== null; ) (a = o), (o = a.return)
    return a.tag === 3 ? a.stateNode : null
  }
  var Bu = {},
    FA = new WeakMap()
  function Ai(a, o) {
    if (typeof a == 'object' && a !== null) {
      var l = FA.get(a)
      return l !== void 0 ? l : ((o = { value: a, source: o, stack: k(o) }), FA.set(a, o), o)
    }
    return { value: a, source: o, stack: k(o) }
  }
  var Lu = [],
    $u = 0,
    t0 = null,
    n0 = 0,
    _i = [],
    Ci = 0,
    rc = null,
    ea = 1,
    ta = ''
  function ic(a, o) {
    ;(Lu[$u++] = n0), (Lu[$u++] = t0), (t0 = a), (n0 = o)
  }
  function jA(a, o, l) {
    ;(_i[Ci++] = ea), (_i[Ci++] = ta), (_i[Ci++] = rc), (rc = a)
    var h = ea
    a = ta
    var b = 32 - bt(h) - 1
    ;(h &= ~(1 << b)), (l += 1)
    var _ = 32 - bt(o) + b
    if (30 < _) {
      var U = b - (b % 5)
      ;(_ = (h & ((1 << U) - 1)).toString(32)),
        (h >>= U),
        (b -= U),
        (ea = (1 << (32 - bt(o) + b)) | (l << b) | h),
        (ta = _ + a)
    } else (ea = (1 << _) | (l << b) | h), (ta = a)
  }
  function _b(a) {
    a.return !== null && (ic(a, 1), jA(a, 1, 0))
  }
  function Cb(a) {
    for (; a === t0; ) (t0 = Lu[--$u]), (Lu[$u] = null), (n0 = Lu[--$u]), (Lu[$u] = null)
    for (; a === rc; )
      (rc = _i[--Ci]),
        (_i[Ci] = null),
        (ta = _i[--Ci]),
        (_i[Ci] = null),
        (ea = _i[--Ci]),
        (_i[Ci] = null)
  }
  var Mr = null,
    fr = null,
    Et = !1,
    Zi = null,
    ws = !1,
    Sb = Error(r(519))
  function sc(a) {
    var o = Error(r(418, ''))
    throw (Kd(Ai(o, a)), Sb)
  }
  function zA(a) {
    var o = a.stateNode,
      l = a.type,
      h = a.memoizedProps
    switch (((o[st] = a), (o[dr] = h), l)) {
      case 'dialog':
        dt('cancel', o), dt('close', o)
        break
      case 'iframe':
      case 'object':
      case 'embed':
        dt('load', o)
        break
      case 'video':
      case 'audio':
        for (l = 0; l < yf.length; l++) dt(yf[l], o)
        break
      case 'source':
        dt('error', o)
        break
      case 'img':
      case 'image':
      case 'link':
        dt('error', o), dt('load', o)
        break
      case 'details':
        dt('toggle', o)
        break
      case 'input':
        dt('invalid', o),
          rA(o, h.value, h.defaultValue, h.checked, h.defaultChecked, h.type, h.name, !0),
          qp(o)
        break
      case 'select':
        dt('invalid', o)
        break
      case 'textarea':
        dt('invalid', o), sA(o, h.value, h.defaultValue, h.children), qp(o)
    }
    ;(l = h.children),
      (typeof l != 'string' && typeof l != 'number' && typeof l != 'bigint') ||
      o.textContent === '' + l ||
      h.suppressHydrationWarning === !0 ||
      Z_(o.textContent, l)
        ? (h.popover != null && (dt('beforetoggle', o), dt('toggle', o)),
          h.onScroll != null && dt('scroll', o),
          h.onScrollEnd != null && dt('scrollend', o),
          h.onClick != null && (o.onclick = M0),
          (o = !0))
        : (o = !1),
      o || sc(a)
  }
  function qA(a) {
    for (Mr = a.return; Mr; )
      switch (Mr.tag) {
        case 3:
        case 27:
          ws = !0
          return
        case 5:
        case 13:
          ws = !1
          return
        default:
          Mr = Mr.return
      }
  }
  function Gd(a) {
    if (a !== Mr) return !1
    if (!Et) return qA(a), (Et = !0), !1
    var o = !1,
      l
    if (
      ((l = a.tag !== 3 && a.tag !== 27) &&
        ((l = a.tag === 5) &&
          ((l = a.type), (l = !(l !== 'form' && l !== 'button') || Gy(a.type, a.memoizedProps))),
        (l = !l)),
      l && (o = !0),
      o && fr && sc(a),
      qA(a),
      a.tag === 13)
    ) {
      if (((a = a.memoizedState), (a = a !== null ? a.dehydrated : null), !a)) throw Error(r(317))
      e: {
        for (a = a.nextSibling, o = 0; a; ) {
          if (a.nodeType === 8)
            if (((l = a.data), l === '/$')) {
              if (o === 0) {
                fr = Ji(a.nextSibling)
                break e
              }
              o--
            } else (l !== '$' && l !== '$!' && l !== '$?') || o++
          a = a.nextSibling
        }
        fr = null
      }
    } else fr = Mr ? Ji(a.stateNode.nextSibling) : null
    return !0
  }
  function Vd() {
    ;(fr = Mr = null), (Et = !1)
  }
  function Kd(a) {
    Zi === null ? (Zi = [a]) : Zi.push(a)
  }
  var Wd = Error(r(460)),
    HA = Error(r(474)),
    Tb = { then: function () {} }
  function GA(a) {
    return (a = a.status), a === 'fulfilled' || a === 'rejected'
  }
  function r0() {}
  function VA(a, o, l) {
    switch (
      ((l = a[l]), l === void 0 ? a.push(o) : l !== o && (o.then(r0, r0), (o = l)), o.status)
    ) {
      case 'fulfilled':
        return o.value
      case 'rejected':
        throw ((a = o.reason), a === Wd ? Error(r(483)) : a)
      default:
        if (typeof o.status == 'string') o.then(r0, r0)
        else {
          if (((a = an), a !== null && 100 < a.shellSuspendCounter)) throw Error(r(482))
          ;(a = o),
            (a.status = 'pending'),
            a.then(
              function (h) {
                if (o.status === 'pending') {
                  var b = o
                  ;(b.status = 'fulfilled'), (b.value = h)
                }
              },
              function (h) {
                if (o.status === 'pending') {
                  var b = o
                  ;(b.status = 'rejected'), (b.reason = h)
                }
              }
            )
        }
        switch (o.status) {
          case 'fulfilled':
            return o.value
          case 'rejected':
            throw ((a = o.reason), a === Wd ? Error(r(483)) : a)
        }
        throw ((Qd = o), Wd)
    }
  }
  var Qd = null
  function KA() {
    if (Qd === null) throw Error(r(459))
    var a = Qd
    return (Qd = null), a
  }
  var Fu = null,
    Yd = 0
  function i0(a) {
    var o = Yd
    return (Yd += 1), Fu === null && (Fu = []), VA(Fu, a, o)
  }
  function Zd(a, o) {
    ;(o = o.props.ref), (a.ref = o !== void 0 ? o : null)
  }
  function s0(a, o) {
    throw o.$$typeof === s
      ? Error(r(525))
      : ((a = Object.prototype.toString.call(o)),
        Error(
          r(
            31,
            a === '[object Object]' ? 'object with keys {' + Object.keys(o).join(', ') + '}' : a
          )
        ))
  }
  function WA(a) {
    var o = a._init
    return o(a._payload)
  }
  function QA(a) {
    function o(te, X) {
      if (a) {
        var ne = te.deletions
        ne === null ? ((te.deletions = [X]), (te.flags |= 16)) : ne.push(X)
      }
    }
    function l(te, X) {
      if (!a) return null
      for (; X !== null; ) o(te, X), (X = X.sibling)
      return null
    }
    function h(te) {
      for (var X = new Map(); te !== null; )
        te.key !== null ? X.set(te.key, te) : X.set(te.index, te), (te = te.sibling)
      return X
    }
    function b(te, X) {
      return (te = no(te, X)), (te.index = 0), (te.sibling = null), te
    }
    function _(te, X, ne) {
      return (
        (te.index = ne),
        a
          ? ((ne = te.alternate),
            ne !== null
              ? ((ne = ne.index), ne < X ? ((te.flags |= 33554434), X) : ne)
              : ((te.flags |= 33554434), X))
          : ((te.flags |= 1048576), X)
      )
    }
    function U(te) {
      return a && te.alternate === null && (te.flags |= 33554434), te
    }
    function q(te, X, ne, ue) {
      return X === null || X.tag !== 6
        ? ((X = wy(ne, te.mode, ue)), (X.return = te), X)
        : ((X = b(X, ne)), (X.return = te), X)
    }
    function K(te, X, ne, ue) {
      var Ie = ne.type
      return Ie === f
        ? oe(te, X, ne.props.children, ue, ne.key)
        : X !== null &&
            (X.elementType === Ie ||
              (typeof Ie == 'object' && Ie !== null && Ie.$$typeof === I && WA(Ie) === X.type))
          ? ((X = b(X, ne.props)), Zd(X, ne), (X.return = te), X)
          : ((X = _0(ne.type, ne.key, ne.props, null, te.mode, ue)), Zd(X, ne), (X.return = te), X)
    }
    function J(te, X, ne, ue) {
      return X === null ||
        X.tag !== 4 ||
        X.stateNode.containerInfo !== ne.containerInfo ||
        X.stateNode.implementation !== ne.implementation
        ? ((X = Ey(ne, te.mode, ue)), (X.return = te), X)
        : ((X = b(X, ne.children || [])), (X.return = te), X)
    }
    function oe(te, X, ne, ue, Ie) {
      return X === null || X.tag !== 7
        ? ((X = gc(ne, te.mode, ue, Ie)), (X.return = te), X)
        : ((X = b(X, ne)), (X.return = te), X)
    }
    function le(te, X, ne) {
      if ((typeof X == 'string' && X !== '') || typeof X == 'number' || typeof X == 'bigint')
        return (X = wy('' + X, te.mode, ne)), (X.return = te), X
      if (typeof X == 'object' && X !== null) {
        switch (X.$$typeof) {
          case c:
            return (
              (ne = _0(X.type, X.key, X.props, null, te.mode, ne)), Zd(ne, X), (ne.return = te), ne
            )
          case u:
            return (X = Ey(X, te.mode, ne)), (X.return = te), X
          case I:
            var ue = X._init
            return (X = ue(X._payload)), le(te, X, ne)
        }
        if (ee(X) || R(X)) return (X = gc(X, te.mode, ne, null)), (X.return = te), X
        if (typeof X.then == 'function') return le(te, i0(X), ne)
        if (X.$$typeof === y) return le(te, w0(te, X), ne)
        s0(te, X)
      }
      return null
    }
    function ie(te, X, ne, ue) {
      var Ie = X !== null ? X.key : null
      if ((typeof ne == 'string' && ne !== '') || typeof ne == 'number' || typeof ne == 'bigint')
        return Ie !== null ? null : q(te, X, '' + ne, ue)
      if (typeof ne == 'object' && ne !== null) {
        switch (ne.$$typeof) {
          case c:
            return ne.key === Ie ? K(te, X, ne, ue) : null
          case u:
            return ne.key === Ie ? J(te, X, ne, ue) : null
          case I:
            return (Ie = ne._init), (ne = Ie(ne._payload)), ie(te, X, ne, ue)
        }
        if (ee(ne) || R(ne)) return Ie !== null ? null : oe(te, X, ne, ue, null)
        if (typeof ne.then == 'function') return ie(te, X, i0(ne), ue)
        if (ne.$$typeof === y) return ie(te, X, w0(te, ne), ue)
        s0(te, ne)
      }
      return null
    }
    function ae(te, X, ne, ue, Ie) {
      if ((typeof ue == 'string' && ue !== '') || typeof ue == 'number' || typeof ue == 'bigint')
        return (te = te.get(ne) || null), q(X, te, '' + ue, Ie)
      if (typeof ue == 'object' && ue !== null) {
        switch (ue.$$typeof) {
          case c:
            return (te = te.get(ue.key === null ? ne : ue.key) || null), K(X, te, ue, Ie)
          case u:
            return (te = te.get(ue.key === null ? ne : ue.key) || null), J(X, te, ue, Ie)
          case I:
            var nt = ue._init
            return (ue = nt(ue._payload)), ae(te, X, ne, ue, Ie)
        }
        if (ee(ue) || R(ue)) return (te = te.get(ne) || null), oe(X, te, ue, Ie, null)
        if (typeof ue.then == 'function') return ae(te, X, ne, i0(ue), Ie)
        if (ue.$$typeof === y) return ae(te, X, ne, w0(X, ue), Ie)
        s0(X, ue)
      }
      return null
    }
    function Pe(te, X, ne, ue) {
      for (
        var Ie = null, nt = null, ke = X, Fe = (X = 0), rr = null;
        ke !== null && Fe < ne.length;
        Fe++
      ) {
        ke.index > Fe ? ((rr = ke), (ke = null)) : (rr = ke.sibling)
        var At = ie(te, ke, ne[Fe], ue)
        if (At === null) {
          ke === null && (ke = rr)
          break
        }
        a && ke && At.alternate === null && o(te, ke),
          (X = _(At, X, Fe)),
          nt === null ? (Ie = At) : (nt.sibling = At),
          (nt = At),
          (ke = rr)
      }
      if (Fe === ne.length) return l(te, ke), Et && ic(te, Fe), Ie
      if (ke === null) {
        for (; Fe < ne.length; Fe++)
          (ke = le(te, ne[Fe], ue)),
            ke !== null &&
              ((X = _(ke, X, Fe)), nt === null ? (Ie = ke) : (nt.sibling = ke), (nt = ke))
        return Et && ic(te, Fe), Ie
      }
      for (ke = h(ke); Fe < ne.length; Fe++)
        (rr = ae(ke, te, Fe, ne[Fe], ue)),
          rr !== null &&
            (a && rr.alternate !== null && ke.delete(rr.key === null ? Fe : rr.key),
            (X = _(rr, X, Fe)),
            nt === null ? (Ie = rr) : (nt.sibling = rr),
            (nt = rr))
      return (
        a &&
          ke.forEach(function (uo) {
            return o(te, uo)
          }),
        Et && ic(te, Fe),
        Ie
      )
    }
    function qe(te, X, ne, ue) {
      if (ne == null) throw Error(r(151))
      for (
        var Ie = null, nt = null, ke = X, Fe = (X = 0), rr = null, At = ne.next();
        ke !== null && !At.done;
        Fe++, At = ne.next()
      ) {
        ke.index > Fe ? ((rr = ke), (ke = null)) : (rr = ke.sibling)
        var uo = ie(te, ke, At.value, ue)
        if (uo === null) {
          ke === null && (ke = rr)
          break
        }
        a && ke && uo.alternate === null && o(te, ke),
          (X = _(uo, X, Fe)),
          nt === null ? (Ie = uo) : (nt.sibling = uo),
          (nt = uo),
          (ke = rr)
      }
      if (At.done) return l(te, ke), Et && ic(te, Fe), Ie
      if (ke === null) {
        for (; !At.done; Fe++, At = ne.next())
          (At = le(te, At.value, ue)),
            At !== null &&
              ((X = _(At, X, Fe)), nt === null ? (Ie = At) : (nt.sibling = At), (nt = At))
        return Et && ic(te, Fe), Ie
      }
      for (ke = h(ke); !At.done; Fe++, At = ne.next())
        (At = ae(ke, te, Fe, At.value, ue)),
          At !== null &&
            (a && At.alternate !== null && ke.delete(At.key === null ? Fe : At.key),
            (X = _(At, X, Fe)),
            nt === null ? (Ie = At) : (nt.sibling = At),
            (nt = At))
      return (
        a &&
          ke.forEach(function (ZR) {
            return o(te, ZR)
          }),
        Et && ic(te, Fe),
        Ie
      )
    }
    function Mn(te, X, ne, ue) {
      if (
        (typeof ne == 'object' &&
          ne !== null &&
          ne.type === f &&
          ne.key === null &&
          (ne = ne.props.children),
        typeof ne == 'object' && ne !== null)
      ) {
        switch (ne.$$typeof) {
          case c:
            e: {
              for (var Ie = ne.key; X !== null; ) {
                if (X.key === Ie) {
                  if (((Ie = ne.type), Ie === f)) {
                    if (X.tag === 7) {
                      l(te, X.sibling), (ue = b(X, ne.props.children)), (ue.return = te), (te = ue)
                      break e
                    }
                  } else if (
                    X.elementType === Ie ||
                    (typeof Ie == 'object' && Ie !== null && Ie.$$typeof === I && WA(Ie) === X.type)
                  ) {
                    l(te, X.sibling), (ue = b(X, ne.props)), Zd(ue, ne), (ue.return = te), (te = ue)
                    break e
                  }
                  l(te, X)
                  break
                } else o(te, X)
                X = X.sibling
              }
              ne.type === f
                ? ((ue = gc(ne.props.children, te.mode, ue, ne.key)), (ue.return = te), (te = ue))
                : ((ue = _0(ne.type, ne.key, ne.props, null, te.mode, ue)),
                  Zd(ue, ne),
                  (ue.return = te),
                  (te = ue))
            }
            return U(te)
          case u:
            e: {
              for (Ie = ne.key; X !== null; ) {
                if (X.key === Ie)
                  if (
                    X.tag === 4 &&
                    X.stateNode.containerInfo === ne.containerInfo &&
                    X.stateNode.implementation === ne.implementation
                  ) {
                    l(te, X.sibling), (ue = b(X, ne.children || [])), (ue.return = te), (te = ue)
                    break e
                  } else {
                    l(te, X)
                    break
                  }
                else o(te, X)
                X = X.sibling
              }
              ;(ue = Ey(ne, te.mode, ue)), (ue.return = te), (te = ue)
            }
            return U(te)
          case I:
            return (Ie = ne._init), (ne = Ie(ne._payload)), Mn(te, X, ne, ue)
        }
        if (ee(ne)) return Pe(te, X, ne, ue)
        if (R(ne)) {
          if (((Ie = R(ne)), typeof Ie != 'function')) throw Error(r(150))
          return (ne = Ie.call(ne)), qe(te, X, ne, ue)
        }
        if (typeof ne.then == 'function') return Mn(te, X, i0(ne), ue)
        if (ne.$$typeof === y) return Mn(te, X, w0(te, ne), ue)
        s0(te, ne)
      }
      return (typeof ne == 'string' && ne !== '') || typeof ne == 'number' || typeof ne == 'bigint'
        ? ((ne = '' + ne),
          X !== null && X.tag === 6
            ? (l(te, X.sibling), (ue = b(X, ne)), (ue.return = te), (te = ue))
            : (l(te, X), (ue = wy(ne, te.mode, ue)), (ue.return = te), (te = ue)),
          U(te))
        : l(te, X)
    }
    return function (te, X, ne, ue) {
      try {
        Yd = 0
        var Ie = Mn(te, X, ne, ue)
        return (Fu = null), Ie
      } catch (ke) {
        if (ke === Wd) throw ke
        var nt = Ni(29, ke, null, te.mode)
        return (nt.lanes = ue), (nt.return = te), nt
      } finally {
      }
    }
  }
  var ac = QA(!0),
    YA = QA(!1),
    ju = _e(null),
    a0 = _e(0)
  function ZA(a, o) {
    ;(a = fa), Ce(a0, a), Ce(ju, o), (fa = a | o.baseLanes)
  }
  function xb() {
    Ce(a0, fa), Ce(ju, ju.current)
  }
  function Nb() {
    ;(fa = a0.current), ye(ju), ye(a0)
  }
  var Si = _e(null),
    Es = null
  function Ga(a) {
    var o = a.alternate
    Ce(Wn, Wn.current & 1),
      Ce(Si, a),
      Es === null && (o === null || ju.current !== null || o.memoizedState !== null) && (Es = a)
  }
  function XA(a) {
    if (a.tag === 22) {
      if ((Ce(Wn, Wn.current), Ce(Si, a), Es === null)) {
        var o = a.alternate
        o !== null && o.memoizedState !== null && (Es = a)
      }
    } else Va()
  }
  function Va() {
    Ce(Wn, Wn.current), Ce(Si, Si.current)
  }
  function na(a) {
    ye(Si), Es === a && (Es = null), ye(Wn)
  }
  var Wn = _e(0)
  function o0(a) {
    for (var o = a; o !== null; ) {
      if (o.tag === 13) {
        var l = o.memoizedState
        if (l !== null && ((l = l.dehydrated), l === null || l.data === '$?' || l.data === '$!'))
          return o
      } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
        if ((o.flags & 128) !== 0) return o
      } else if (o.child !== null) {
        ;(o.child.return = o), (o = o.child)
        continue
      }
      if (o === a) break
      for (; o.sibling === null; ) {
        if (o.return === null || o.return === a) return null
        o = o.return
      }
      ;(o.sibling.return = o.return), (o = o.sibling)
    }
    return null
  }
  var LO =
      typeof AbortController < 'u'
        ? AbortController
        : function () {
            var a = [],
              o = (this.signal = {
                aborted: !1,
                addEventListener: function (l, h) {
                  a.push(h)
                }
              })
            this.abort = function () {
              ;(o.aborted = !0),
                a.forEach(function (l) {
                  return l()
                })
            }
          },
    $O = t.unstable_scheduleCallback,
    FO = t.unstable_NormalPriority,
    Qn = {
      $$typeof: y,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    }
  function Ib() {
    return { controller: new LO(), data: new Map(), refCount: 0 }
  }
  function Xd(a) {
    a.refCount--,
      a.refCount === 0 &&
        $O(FO, function () {
          a.controller.abort()
        })
  }
  var Jd = null,
    Ob = 0,
    zu = 0,
    qu = null
  function jO(a, o) {
    if (Jd === null) {
      var l = (Jd = [])
      ;(Ob = 0),
        (zu = Uy()),
        (qu = {
          status: 'pending',
          value: void 0,
          then: function (h) {
            l.push(h)
          }
        })
    }
    return Ob++, o.then(JA, JA), o
  }
  function JA() {
    if (--Ob === 0 && Jd !== null) {
      qu !== null && (qu.status = 'fulfilled')
      var a = Jd
      ;(Jd = null), (zu = 0), (qu = null)
      for (var o = 0; o < a.length; o++) (0, a[o])()
    }
  }
  function zO(a, o) {
    var l = [],
      h = {
        status: 'pending',
        value: null,
        reason: null,
        then: function (b) {
          l.push(b)
        }
      }
    return (
      a.then(
        function () {
          ;(h.status = 'fulfilled'), (h.value = o)
          for (var b = 0; b < l.length; b++) (0, l[b])(o)
        },
        function (b) {
          for (h.status = 'rejected', h.reason = b, b = 0; b < l.length; b++) (0, l[b])(void 0)
        }
      ),
      h
    )
  }
  var e3 = j.S
  j.S = function (a, o) {
    typeof o == 'object' && o !== null && typeof o.then == 'function' && jO(a, o),
      e3 !== null && e3(a, o)
  }
  var oc = _e(null)
  function Rb() {
    var a = oc.current
    return a !== null ? a : an.pooledCache
  }
  function c0(a, o) {
    o === null ? Ce(oc, oc.current) : Ce(oc, o.pool)
  }
  function t3() {
    var a = Rb()
    return a === null ? null : { parent: Qn._currentValue, pool: a }
  }
  var Ka = 0,
    et = null,
    Gt = null,
    zn = null,
    u0 = !1,
    Hu = !1,
    cc = !1,
    l0 = 0,
    ef = 0,
    Gu = null,
    qO = 0
  function Bn() {
    throw Error(r(321))
  }
  function Db(a, o) {
    if (o === null) return !1
    for (var l = 0; l < o.length && l < a.length; l++) if (!si(a[l], o[l])) return !1
    return !0
  }
  function Pb(a, o, l, h, b, _) {
    return (
      (Ka = _),
      (et = o),
      (o.memoizedState = null),
      (o.updateQueue = null),
      (o.lanes = 0),
      (j.H = a === null || a.memoizedState === null ? uc : Wa),
      (cc = !1),
      (_ = l(h, b)),
      (cc = !1),
      Hu && (_ = r3(o, l, h, b)),
      n3(a),
      _
    )
  }
  function n3(a) {
    j.H = As
    var o = Gt !== null && Gt.next !== null
    if (((Ka = 0), (zn = Gt = et = null), (u0 = !1), (ef = 0), (Gu = null), o)) throw Error(r(300))
    a === null || tr || ((a = a.dependencies), a !== null && v0(a) && (tr = !0))
  }
  function r3(a, o, l, h) {
    et = a
    var b = 0
    do {
      if ((Hu && (Gu = null), (ef = 0), (Hu = !1), 25 <= b)) throw Error(r(301))
      if (((b += 1), (zn = Gt = null), a.updateQueue != null)) {
        var _ = a.updateQueue
        ;(_.lastEffect = null),
          (_.events = null),
          (_.stores = null),
          _.memoCache != null && (_.memoCache.index = 0)
      }
      ;(j.H = lc), (_ = o(l, h))
    } while (Hu)
    return _
  }
  function HO() {
    var a = j.H,
      o = a.useState()[0]
    return (
      (o = typeof o.then == 'function' ? tf(o) : o),
      (a = a.useState()[0]),
      (Gt !== null ? Gt.memoizedState : null) !== a && (et.flags |= 1024),
      o
    )
  }
  function Mb() {
    var a = l0 !== 0
    return (l0 = 0), a
  }
  function kb(a, o, l) {
    ;(o.updateQueue = a.updateQueue), (o.flags &= -2053), (a.lanes &= ~l)
  }
  function Ub(a) {
    if (u0) {
      for (a = a.memoizedState; a !== null; ) {
        var o = a.queue
        o !== null && (o.pending = null), (a = a.next)
      }
      u0 = !1
    }
    ;(Ka = 0), (zn = Gt = et = null), (Hu = !1), (ef = l0 = 0), (Gu = null)
  }
  function Gr() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }
    return zn === null ? (et.memoizedState = zn = a) : (zn = zn.next = a), zn
  }
  function qn() {
    if (Gt === null) {
      var a = et.alternate
      a = a !== null ? a.memoizedState : null
    } else a = Gt.next
    var o = zn === null ? et.memoizedState : zn.next
    if (o !== null) (zn = o), (Gt = a)
    else {
      if (a === null) throw et.alternate === null ? Error(r(467)) : Error(r(310))
      ;(Gt = a),
        (a = {
          memoizedState: Gt.memoizedState,
          baseState: Gt.baseState,
          baseQueue: Gt.baseQueue,
          queue: Gt.queue,
          next: null
        }),
        zn === null ? (et.memoizedState = zn = a) : (zn = zn.next = a)
    }
    return zn
  }
  var d0
  d0 = function () {
    return { lastEffect: null, events: null, stores: null, memoCache: null }
  }
  function tf(a) {
    var o = ef
    return (
      (ef += 1),
      Gu === null && (Gu = []),
      (a = VA(Gu, a, o)),
      (o = et),
      (zn === null ? o.memoizedState : zn.next) === null &&
        ((o = o.alternate), (j.H = o === null || o.memoizedState === null ? uc : Wa)),
      a
    )
  }
  function f0(a) {
    if (a !== null && typeof a == 'object') {
      if (typeof a.then == 'function') return tf(a)
      if (a.$$typeof === y) return Cr(a)
    }
    throw Error(r(438, String(a)))
  }
  function Bb(a) {
    var o = null,
      l = et.updateQueue
    if ((l !== null && (o = l.memoCache), o == null)) {
      var h = et.alternate
      h !== null &&
        ((h = h.updateQueue),
        h !== null &&
          ((h = h.memoCache),
          h != null &&
            (o = {
              data: h.data.map(function (b) {
                return b.slice()
              }),
              index: 0
            })))
    }
    if (
      (o == null && (o = { data: [], index: 0 }),
      l === null && ((l = d0()), (et.updateQueue = l)),
      (l.memoCache = o),
      (l = o.data[o.index]),
      l === void 0)
    )
      for (l = o.data[o.index] = Array(a), h = 0; h < a; h++) l[h] = $
    return o.index++, l
  }
  function ra(a, o) {
    return typeof o == 'function' ? o(a) : o
  }
  function h0(a) {
    var o = qn()
    return Lb(o, Gt, a)
  }
  function Lb(a, o, l) {
    var h = a.queue
    if (h === null) throw Error(r(311))
    h.lastRenderedReducer = l
    var b = a.baseQueue,
      _ = h.pending
    if (_ !== null) {
      if (b !== null) {
        var U = b.next
        ;(b.next = _.next), (_.next = U)
      }
      ;(o.baseQueue = b = _), (h.pending = null)
    }
    if (((_ = a.baseState), b === null)) a.memoizedState = _
    else {
      o = b.next
      var q = (U = null),
        K = null,
        J = o,
        oe = !1
      do {
        var le = J.lane & -536870913
        if (le !== J.lane ? (yt & le) === le : (Ka & le) === le) {
          var ie = J.revertLane
          if (ie === 0)
            K !== null &&
              (K = K.next =
                {
                  lane: 0,
                  revertLane: 0,
                  action: J.action,
                  hasEagerState: J.hasEagerState,
                  eagerState: J.eagerState,
                  next: null
                }),
              le === zu && (oe = !0)
          else if ((Ka & ie) === ie) {
            ;(J = J.next), ie === zu && (oe = !0)
            continue
          } else
            (le = {
              lane: 0,
              revertLane: J.revertLane,
              action: J.action,
              hasEagerState: J.hasEagerState,
              eagerState: J.eagerState,
              next: null
            }),
              K === null ? ((q = K = le), (U = _)) : (K = K.next = le),
              (et.lanes |= ie),
              (ro |= ie)
          ;(le = J.action), cc && l(_, le), (_ = J.hasEagerState ? J.eagerState : l(_, le))
        } else
          (ie = {
            lane: le,
            revertLane: J.revertLane,
            action: J.action,
            hasEagerState: J.hasEagerState,
            eagerState: J.eagerState,
            next: null
          }),
            K === null ? ((q = K = ie), (U = _)) : (K = K.next = ie),
            (et.lanes |= le),
            (ro |= le)
        J = J.next
      } while (J !== null && J !== o)
      if (
        (K === null ? (U = _) : (K.next = q),
        !si(_, a.memoizedState) && ((tr = !0), oe && ((l = qu), l !== null)))
      )
        throw l
      ;(a.memoizedState = _), (a.baseState = U), (a.baseQueue = K), (h.lastRenderedState = _)
    }
    return b === null && (h.lanes = 0), [a.memoizedState, h.dispatch]
  }
  function $b(a) {
    var o = qn(),
      l = o.queue
    if (l === null) throw Error(r(311))
    l.lastRenderedReducer = a
    var h = l.dispatch,
      b = l.pending,
      _ = o.memoizedState
    if (b !== null) {
      l.pending = null
      var U = (b = b.next)
      do (_ = a(_, U.action)), (U = U.next)
      while (U !== b)
      si(_, o.memoizedState) || (tr = !0),
        (o.memoizedState = _),
        o.baseQueue === null && (o.baseState = _),
        (l.lastRenderedState = _)
    }
    return [_, h]
  }
  function i3(a, o, l) {
    var h = et,
      b = qn(),
      _ = Et
    if (_) {
      if (l === void 0) throw Error(r(407))
      l = l()
    } else l = o()
    var U = !si((Gt || b).memoizedState, l)
    if (
      (U && ((b.memoizedState = l), (tr = !0)),
      (b = b.queue),
      zb(o3.bind(null, h, b, a), [a]),
      b.getSnapshot !== o || U || (zn !== null && zn.memoizedState.tag & 1))
    ) {
      if (
        ((h.flags |= 2048),
        Vu(9, a3.bind(null, h, b, l, o), { destroy: void 0 }, null),
        an === null)
      )
        throw Error(r(349))
      _ || (Ka & 60) !== 0 || s3(h, o, l)
    }
    return l
  }
  function s3(a, o, l) {
    ;(a.flags |= 16384),
      (a = { getSnapshot: o, value: l }),
      (o = et.updateQueue),
      o === null
        ? ((o = d0()), (et.updateQueue = o), (o.stores = [a]))
        : ((l = o.stores), l === null ? (o.stores = [a]) : l.push(a))
  }
  function a3(a, o, l, h) {
    ;(o.value = l), (o.getSnapshot = h), c3(o) && u3(a)
  }
  function o3(a, o, l) {
    return l(function () {
      c3(o) && u3(a)
    })
  }
  function c3(a) {
    var o = a.getSnapshot
    a = a.value
    try {
      var l = o()
      return !si(a, l)
    } catch {
      return !0
    }
  }
  function u3(a) {
    var o = Ha(a, 2)
    o !== null && kr(o, a, 2)
  }
  function Fb(a) {
    var o = Gr()
    if (typeof a == 'function') {
      var l = a
      if (((a = l()), cc)) {
        Ut(!0)
        try {
          l()
        } finally {
          Ut(!1)
        }
      }
    }
    return (
      (o.memoizedState = o.baseState = a),
      (o.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ra,
        lastRenderedState: a
      }),
      o
    )
  }
  function l3(a, o, l, h) {
    return (a.baseState = l), Lb(a, Gt, typeof h == 'function' ? h : ra)
  }
  function GO(a, o, l, h, b) {
    if (m0(a)) throw Error(r(485))
    if (((a = o.action), a !== null)) {
      var _ = {
        payload: b,
        action: a,
        next: null,
        isTransition: !0,
        status: 'pending',
        value: null,
        reason: null,
        listeners: [],
        then: function (U) {
          _.listeners.push(U)
        }
      }
      j.T !== null ? l(!0) : (_.isTransition = !1),
        h(_),
        (l = o.pending),
        l === null
          ? ((_.next = o.pending = _), d3(o, _))
          : ((_.next = l.next), (o.pending = l.next = _))
    }
  }
  function d3(a, o) {
    var l = o.action,
      h = o.payload,
      b = a.state
    if (o.isTransition) {
      var _ = j.T,
        U = {}
      j.T = U
      try {
        var q = l(b, h),
          K = j.S
        K !== null && K(U, q), f3(a, o, q)
      } catch (J) {
        jb(a, o, J)
      } finally {
        j.T = _
      }
    } else
      try {
        ;(_ = l(b, h)), f3(a, o, _)
      } catch (J) {
        jb(a, o, J)
      }
  }
  function f3(a, o, l) {
    l !== null && typeof l == 'object' && typeof l.then == 'function'
      ? l.then(
          function (h) {
            h3(a, o, h)
          },
          function (h) {
            return jb(a, o, h)
          }
        )
      : h3(a, o, l)
  }
  function h3(a, o, l) {
    ;(o.status = 'fulfilled'),
      (o.value = l),
      p3(o),
      (a.state = l),
      (o = a.pending),
      o !== null &&
        ((l = o.next), l === o ? (a.pending = null) : ((l = l.next), (o.next = l), d3(a, l)))
  }
  function jb(a, o, l) {
    var h = a.pending
    if (((a.pending = null), h !== null)) {
      h = h.next
      do (o.status = 'rejected'), (o.reason = l), p3(o), (o = o.next)
      while (o !== h)
    }
    a.action = null
  }
  function p3(a) {
    a = a.listeners
    for (var o = 0; o < a.length; o++) (0, a[o])()
  }
  function g3(a, o) {
    return o
  }
  function m3(a, o) {
    if (Et) {
      var l = an.formState
      if (l !== null) {
        e: {
          var h = et
          if (Et) {
            if (fr) {
              t: {
                for (var b = fr, _ = ws; b.nodeType !== 8; ) {
                  if (!_) {
                    b = null
                    break t
                  }
                  if (((b = Ji(b.nextSibling)), b === null)) {
                    b = null
                    break t
                  }
                }
                ;(_ = b.data), (b = _ === 'F!' || _ === 'F' ? b : null)
              }
              if (b) {
                ;(fr = Ji(b.nextSibling)), (h = b.data === 'F!')
                break e
              }
            }
            sc(h)
          }
          h = !1
        }
        h && (o = l[0])
      }
    }
    return (
      (l = Gr()),
      (l.memoizedState = l.baseState = o),
      (h = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: g3,
        lastRenderedState: o
      }),
      (l.queue = h),
      (l = M3.bind(null, et, h)),
      (h.dispatch = l),
      (h = Fb(!1)),
      (_ = Kb.bind(null, et, !1, h.queue)),
      (h = Gr()),
      (b = { state: o, dispatch: null, action: a, pending: null }),
      (h.queue = b),
      (l = GO.bind(null, et, b, _, l)),
      (b.dispatch = l),
      (h.memoizedState = a),
      [o, l, !1]
    )
  }
  function b3(a) {
    var o = qn()
    return y3(o, Gt, a)
  }
  function y3(a, o, l) {
    ;(o = Lb(a, o, g3)[0]),
      (a = h0(ra)[0]),
      (o = typeof o == 'object' && o !== null && typeof o.then == 'function' ? tf(o) : o)
    var h = qn(),
      b = h.queue,
      _ = b.dispatch
    return (
      l !== h.memoizedState &&
        ((et.flags |= 2048), Vu(9, VO.bind(null, b, l), { destroy: void 0 }, null)),
      [o, _, a]
    )
  }
  function VO(a, o) {
    a.action = o
  }
  function v3(a) {
    var o = qn(),
      l = Gt
    if (l !== null) return y3(o, l, a)
    qn(), (o = o.memoizedState), (l = qn())
    var h = l.queue.dispatch
    return (l.memoizedState = a), [o, h, !1]
  }
  function Vu(a, o, l, h) {
    return (
      (a = { tag: a, create: o, inst: l, deps: h, next: null }),
      (o = et.updateQueue),
      o === null && ((o = d0()), (et.updateQueue = o)),
      (l = o.lastEffect),
      l === null
        ? (o.lastEffect = a.next = a)
        : ((h = l.next), (l.next = a), (a.next = h), (o.lastEffect = a)),
      a
    )
  }
  function w3() {
    return qn().memoizedState
  }
  function p0(a, o, l, h) {
    var b = Gr()
    ;(et.flags |= a), (b.memoizedState = Vu(1 | o, l, { destroy: void 0 }, h === void 0 ? null : h))
  }
  function g0(a, o, l, h) {
    var b = qn()
    h = h === void 0 ? null : h
    var _ = b.memoizedState.inst
    Gt !== null && h !== null && Db(h, Gt.memoizedState.deps)
      ? (b.memoizedState = Vu(o, l, _, h))
      : ((et.flags |= a), (b.memoizedState = Vu(1 | o, l, _, h)))
  }
  function E3(a, o) {
    p0(8390656, 8, a, o)
  }
  function zb(a, o) {
    g0(2048, 8, a, o)
  }
  function A3(a, o) {
    return g0(4, 2, a, o)
  }
  function _3(a, o) {
    return g0(4, 4, a, o)
  }
  function C3(a, o) {
    if (typeof o == 'function') {
      a = a()
      var l = o(a)
      return function () {
        typeof l == 'function' ? l() : o(null)
      }
    }
    if (o != null)
      return (
        (a = a()),
        (o.current = a),
        function () {
          o.current = null
        }
      )
  }
  function S3(a, o, l) {
    ;(l = l != null ? l.concat([a]) : null), g0(4, 4, C3.bind(null, o, a), l)
  }
  function qb() {}
  function T3(a, o) {
    var l = qn()
    o = o === void 0 ? null : o
    var h = l.memoizedState
    return o !== null && Db(o, h[1]) ? h[0] : ((l.memoizedState = [a, o]), a)
  }
  function x3(a, o) {
    var l = qn()
    o = o === void 0 ? null : o
    var h = l.memoizedState
    if (o !== null && Db(o, h[1])) return h[0]
    if (((h = a()), cc)) {
      Ut(!0)
      try {
        a()
      } finally {
        Ut(!1)
      }
    }
    return (l.memoizedState = [h, o]), h
  }
  function Hb(a, o, l) {
    return l === void 0 || (Ka & 1073741824) !== 0
      ? (a.memoizedState = o)
      : ((a.memoizedState = l), (a = I_()), (et.lanes |= a), (ro |= a), l)
  }
  function N3(a, o, l, h) {
    return si(l, o)
      ? l
      : ju.current !== null
        ? ((a = Hb(a, l, h)), si(a, o) || (tr = !0), a)
        : (Ka & 42) === 0
          ? ((tr = !0), (a.memoizedState = l))
          : ((a = I_()), (et.lanes |= a), (ro |= a), o)
  }
  function I3(a, o, l, h, b) {
    var _ = Y.p
    Y.p = _ !== 0 && 8 > _ ? _ : 8
    var U = j.T,
      q = {}
    ;(j.T = q), Kb(a, !1, o, l)
    try {
      var K = b(),
        J = j.S
      if (
        (J !== null && J(q, K), K !== null && typeof K == 'object' && typeof K.then == 'function')
      ) {
        var oe = zO(K, h)
        nf(a, o, oe, ui(a))
      } else nf(a, o, h, ui(a))
    } catch (le) {
      nf(a, o, { then: function () {}, status: 'rejected', reason: le }, ui())
    } finally {
      ;(Y.p = _), (j.T = U)
    }
  }
  function KO() {}
  function Gb(a, o, l, h) {
    if (a.tag !== 5) throw Error(r(476))
    var b = O3(a).queue
    I3(
      a,
      b,
      o,
      se,
      l === null
        ? KO
        : function () {
            return R3(a), l(h)
          }
    )
  }
  function O3(a) {
    var o = a.memoizedState
    if (o !== null) return o
    o = {
      memoizedState: se,
      baseState: se,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ra,
        lastRenderedState: se
      },
      next: null
    }
    var l = {}
    return (
      (o.next = {
        memoizedState: l,
        baseState: l,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: ra,
          lastRenderedState: l
        },
        next: null
      }),
      (a.memoizedState = o),
      (a = a.alternate),
      a !== null && (a.memoizedState = o),
      o
    )
  }
  function R3(a) {
    var o = O3(a).next.queue
    nf(a, o, {}, ui())
  }
  function Vb() {
    return Cr(_f)
  }
  function D3() {
    return qn().memoizedState
  }
  function P3() {
    return qn().memoizedState
  }
  function WO(a) {
    for (var o = a.return; o !== null; ) {
      switch (o.tag) {
        case 24:
        case 3:
          var l = ui()
          a = Za(l)
          var h = Xa(o, a, l)
          h !== null && (kr(h, o, l), af(h, o, l)), (o = { cache: Ib() }), (a.payload = o)
          return
      }
      o = o.return
    }
  }
  function QO(a, o, l) {
    var h = ui()
    ;(l = { lane: h, revertLane: 0, action: l, hasEagerState: !1, eagerState: null, next: null }),
      m0(a) ? k3(o, l) : ((l = Ab(a, o, l, h)), l !== null && (kr(l, a, h), U3(l, o, h)))
  }
  function M3(a, o, l) {
    var h = ui()
    nf(a, o, l, h)
  }
  function nf(a, o, l, h) {
    var b = { lane: h, revertLane: 0, action: l, hasEagerState: !1, eagerState: null, next: null }
    if (m0(a)) k3(o, b)
    else {
      var _ = a.alternate
      if (
        a.lanes === 0 &&
        (_ === null || _.lanes === 0) &&
        ((_ = o.lastRenderedReducer), _ !== null)
      )
        try {
          var U = o.lastRenderedState,
            q = _(U, l)
          if (((b.hasEagerState = !0), (b.eagerState = q), si(q, U)))
            return Jp(a, o, b, 0), an === null && Xp(), !1
        } catch {
        } finally {
        }
      if (((l = Ab(a, o, b, h)), l !== null)) return kr(l, a, h), U3(l, o, h), !0
    }
    return !1
  }
  function Kb(a, o, l, h) {
    if (
      ((h = {
        lane: 2,
        revertLane: Uy(),
        action: h,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }),
      m0(a))
    ) {
      if (o) throw Error(r(479))
    } else (o = Ab(a, l, h, 2)), o !== null && kr(o, a, 2)
  }
  function m0(a) {
    var o = a.alternate
    return a === et || (o !== null && o === et)
  }
  function k3(a, o) {
    Hu = u0 = !0
    var l = a.pending
    l === null ? (o.next = o) : ((o.next = l.next), (l.next = o)), (a.pending = o)
  }
  function U3(a, o, l) {
    if ((l & 4194176) !== 0) {
      var h = o.lanes
      ;(h &= a.pendingLanes), (l |= h), (o.lanes = l), Rd(a, l)
    }
  }
  var As = {
    readContext: Cr,
    use: f0,
    useCallback: Bn,
    useContext: Bn,
    useEffect: Bn,
    useImperativeHandle: Bn,
    useLayoutEffect: Bn,
    useInsertionEffect: Bn,
    useMemo: Bn,
    useReducer: Bn,
    useRef: Bn,
    useState: Bn,
    useDebugValue: Bn,
    useDeferredValue: Bn,
    useTransition: Bn,
    useSyncExternalStore: Bn,
    useId: Bn
  }
  ;(As.useCacheRefresh = Bn),
    (As.useMemoCache = Bn),
    (As.useHostTransitionStatus = Bn),
    (As.useFormState = Bn),
    (As.useActionState = Bn),
    (As.useOptimistic = Bn)
  var uc = {
    readContext: Cr,
    use: f0,
    useCallback: function (a, o) {
      return (Gr().memoizedState = [a, o === void 0 ? null : o]), a
    },
    useContext: Cr,
    useEffect: E3,
    useImperativeHandle: function (a, o, l) {
      ;(l = l != null ? l.concat([a]) : null), p0(4194308, 4, C3.bind(null, o, a), l)
    },
    useLayoutEffect: function (a, o) {
      return p0(4194308, 4, a, o)
    },
    useInsertionEffect: function (a, o) {
      p0(4, 2, a, o)
    },
    useMemo: function (a, o) {
      var l = Gr()
      o = o === void 0 ? null : o
      var h = a()
      if (cc) {
        Ut(!0)
        try {
          a()
        } finally {
          Ut(!1)
        }
      }
      return (l.memoizedState = [h, o]), h
    },
    useReducer: function (a, o, l) {
      var h = Gr()
      if (l !== void 0) {
        var b = l(o)
        if (cc) {
          Ut(!0)
          try {
            l(o)
          } finally {
            Ut(!1)
          }
        }
      } else b = o
      return (
        (h.memoizedState = h.baseState = b),
        (a = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: a,
          lastRenderedState: b
        }),
        (h.queue = a),
        (a = a.dispatch = QO.bind(null, et, a)),
        [h.memoizedState, a]
      )
    },
    useRef: function (a) {
      var o = Gr()
      return (a = { current: a }), (o.memoizedState = a)
    },
    useState: function (a) {
      a = Fb(a)
      var o = a.queue,
        l = M3.bind(null, et, o)
      return (o.dispatch = l), [a.memoizedState, l]
    },
    useDebugValue: qb,
    useDeferredValue: function (a, o) {
      var l = Gr()
      return Hb(l, a, o)
    },
    useTransition: function () {
      var a = Fb(!1)
      return (a = I3.bind(null, et, a.queue, !0, !1)), (Gr().memoizedState = a), [!1, a]
    },
    useSyncExternalStore: function (a, o, l) {
      var h = et,
        b = Gr()
      if (Et) {
        if (l === void 0) throw Error(r(407))
        l = l()
      } else {
        if (((l = o()), an === null)) throw Error(r(349))
        ;(yt & 60) !== 0 || s3(h, o, l)
      }
      b.memoizedState = l
      var _ = { value: l, getSnapshot: o }
      return (
        (b.queue = _),
        E3(o3.bind(null, h, _, a), [a]),
        (h.flags |= 2048),
        Vu(9, a3.bind(null, h, _, l, o), { destroy: void 0 }, null),
        l
      )
    },
    useId: function () {
      var a = Gr(),
        o = an.identifierPrefix
      if (Et) {
        var l = ta,
          h = ea
        ;(l = (h & ~(1 << (32 - bt(h) - 1))).toString(32) + l),
          (o = ':' + o + 'R' + l),
          (l = l0++),
          0 < l && (o += 'H' + l.toString(32)),
          (o += ':')
      } else (l = qO++), (o = ':' + o + 'r' + l.toString(32) + ':')
      return (a.memoizedState = o)
    },
    useCacheRefresh: function () {
      return (Gr().memoizedState = WO.bind(null, et))
    }
  }
  ;(uc.useMemoCache = Bb),
    (uc.useHostTransitionStatus = Vb),
    (uc.useFormState = m3),
    (uc.useActionState = m3),
    (uc.useOptimistic = function (a) {
      var o = Gr()
      o.memoizedState = o.baseState = a
      var l = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      }
      return (o.queue = l), (o = Kb.bind(null, et, !0, l)), (l.dispatch = o), [a, o]
    })
  var Wa = {
    readContext: Cr,
    use: f0,
    useCallback: T3,
    useContext: Cr,
    useEffect: zb,
    useImperativeHandle: S3,
    useInsertionEffect: A3,
    useLayoutEffect: _3,
    useMemo: x3,
    useReducer: h0,
    useRef: w3,
    useState: function () {
      return h0(ra)
    },
    useDebugValue: qb,
    useDeferredValue: function (a, o) {
      var l = qn()
      return N3(l, Gt.memoizedState, a, o)
    },
    useTransition: function () {
      var a = h0(ra)[0],
        o = qn().memoizedState
      return [typeof a == 'boolean' ? a : tf(a), o]
    },
    useSyncExternalStore: i3,
    useId: D3
  }
  ;(Wa.useCacheRefresh = P3),
    (Wa.useMemoCache = Bb),
    (Wa.useHostTransitionStatus = Vb),
    (Wa.useFormState = b3),
    (Wa.useActionState = b3),
    (Wa.useOptimistic = function (a, o) {
      var l = qn()
      return l3(l, Gt, a, o)
    })
  var lc = {
    readContext: Cr,
    use: f0,
    useCallback: T3,
    useContext: Cr,
    useEffect: zb,
    useImperativeHandle: S3,
    useInsertionEffect: A3,
    useLayoutEffect: _3,
    useMemo: x3,
    useReducer: $b,
    useRef: w3,
    useState: function () {
      return $b(ra)
    },
    useDebugValue: qb,
    useDeferredValue: function (a, o) {
      var l = qn()
      return Gt === null ? Hb(l, a, o) : N3(l, Gt.memoizedState, a, o)
    },
    useTransition: function () {
      var a = $b(ra)[0],
        o = qn().memoizedState
      return [typeof a == 'boolean' ? a : tf(a), o]
    },
    useSyncExternalStore: i3,
    useId: D3
  }
  ;(lc.useCacheRefresh = P3),
    (lc.useMemoCache = Bb),
    (lc.useHostTransitionStatus = Vb),
    (lc.useFormState = v3),
    (lc.useActionState = v3),
    (lc.useOptimistic = function (a, o) {
      var l = qn()
      return Gt !== null ? l3(l, Gt, a, o) : ((l.baseState = a), [a, l.queue.dispatch])
    })
  function Wb(a, o, l, h) {
    ;(o = a.memoizedState),
      (l = l(h, o)),
      (l = l == null ? o : V({}, o, l)),
      (a.memoizedState = l),
      a.lanes === 0 && (a.updateQueue.baseState = l)
  }
  var Qb = {
    isMounted: function (a) {
      return (a = a._reactInternals) ? F(a) === a : !1
    },
    enqueueSetState: function (a, o, l) {
      a = a._reactInternals
      var h = ui(),
        b = Za(h)
      ;(b.payload = o),
        l != null && (b.callback = l),
        (o = Xa(a, b, h)),
        o !== null && (kr(o, a, h), af(o, a, h))
    },
    enqueueReplaceState: function (a, o, l) {
      a = a._reactInternals
      var h = ui(),
        b = Za(h)
      ;(b.tag = 1),
        (b.payload = o),
        l != null && (b.callback = l),
        (o = Xa(a, b, h)),
        o !== null && (kr(o, a, h), af(o, a, h))
    },
    enqueueForceUpdate: function (a, o) {
      a = a._reactInternals
      var l = ui(),
        h = Za(l)
      ;(h.tag = 2),
        o != null && (h.callback = o),
        (o = Xa(a, h, l)),
        o !== null && (kr(o, a, l), af(o, a, l))
    }
  }
  function B3(a, o, l, h, b, _, U) {
    return (
      (a = a.stateNode),
      typeof a.shouldComponentUpdate == 'function'
        ? a.shouldComponentUpdate(h, _, U)
        : o.prototype && o.prototype.isPureReactComponent
          ? !qd(l, h) || !qd(b, _)
          : !0
    )
  }
  function L3(a, o, l, h) {
    ;(a = o.state),
      typeof o.componentWillReceiveProps == 'function' && o.componentWillReceiveProps(l, h),
      typeof o.UNSAFE_componentWillReceiveProps == 'function' &&
        o.UNSAFE_componentWillReceiveProps(l, h),
      o.state !== a && Qb.enqueueReplaceState(o, o.state, null)
  }
  function dc(a, o) {
    var l = o
    if ('ref' in o) {
      l = {}
      for (var h in o) h !== 'ref' && (l[h] = o[h])
    }
    if ((a = a.defaultProps)) {
      l === o && (l = V({}, l))
      for (var b in a) l[b] === void 0 && (l[b] = a[b])
    }
    return l
  }
  var b0 =
    typeof reportError == 'function'
      ? reportError
      : function (a) {
          if (typeof window == 'object' && typeof window.ErrorEvent == 'function') {
            var o = new window.ErrorEvent('error', {
              bubbles: !0,
              cancelable: !0,
              message:
                typeof a == 'object' && a !== null && typeof a.message == 'string'
                  ? String(a.message)
                  : String(a),
              error: a
            })
            if (!window.dispatchEvent(o)) return
          } else if (typeof process == 'object' && typeof process.emit == 'function') {
            process.emit('uncaughtException', a)
            return
          }
          console.error(a)
        }
  function $3(a) {
    b0(a)
  }
  function F3(a) {
    console.error(a)
  }
  function j3(a) {
    b0(a)
  }
  function y0(a, o) {
    try {
      var l = a.onUncaughtError
      l(o.value, { componentStack: o.stack })
    } catch (h) {
      setTimeout(function () {
        throw h
      })
    }
  }
  function z3(a, o, l) {
    try {
      var h = a.onCaughtError
      h(l.value, { componentStack: l.stack, errorBoundary: o.tag === 1 ? o.stateNode : null })
    } catch (b) {
      setTimeout(function () {
        throw b
      })
    }
  }
  function Yb(a, o, l) {
    return (
      (l = Za(l)),
      (l.tag = 3),
      (l.payload = { element: null }),
      (l.callback = function () {
        y0(a, o)
      }),
      l
    )
  }
  function q3(a) {
    return (a = Za(a)), (a.tag = 3), a
  }
  function H3(a, o, l, h) {
    var b = l.type.getDerivedStateFromError
    if (typeof b == 'function') {
      var _ = h.value
      ;(a.payload = function () {
        return b(_)
      }),
        (a.callback = function () {
          z3(o, l, h)
        })
    }
    var U = l.stateNode
    U !== null &&
      typeof U.componentDidCatch == 'function' &&
      (a.callback = function () {
        z3(o, l, h), typeof b != 'function' && (io === null ? (io = new Set([this])) : io.add(this))
        var q = h.stack
        this.componentDidCatch(h.value, { componentStack: q !== null ? q : '' })
      })
  }
  function YO(a, o, l, h, b) {
    if (((l.flags |= 32768), h !== null && typeof h == 'object' && typeof h.then == 'function')) {
      if (((o = l.alternate), o !== null && sf(o, l, b, !0), (l = Si.current), l !== null)) {
        switch (l.tag) {
          case 13:
            return (
              Es === null ? Ry() : l.alternate === null && Pn === 0 && (Pn = 3),
              (l.flags &= -257),
              (l.flags |= 65536),
              (l.lanes = b),
              h === Tb
                ? (l.flags |= 16384)
                : ((o = l.updateQueue),
                  o === null ? (l.updateQueue = new Set([h])) : o.add(h),
                  Py(a, h, b)),
              !1
            )
          case 22:
            return (
              (l.flags |= 65536),
              h === Tb
                ? (l.flags |= 16384)
                : ((o = l.updateQueue),
                  o === null
                    ? ((o = { transitions: null, markerInstances: null, retryQueue: new Set([h]) }),
                      (l.updateQueue = o))
                    : ((l = o.retryQueue), l === null ? (o.retryQueue = new Set([h])) : l.add(h)),
                  Py(a, h, b)),
              !1
            )
        }
        throw Error(r(435, l.tag))
      }
      return Py(a, h, b), Ry(), !1
    }
    if (Et)
      return (
        (o = Si.current),
        o !== null
          ? ((o.flags & 65536) === 0 && (o.flags |= 256),
            (o.flags |= 65536),
            (o.lanes = b),
            h !== Sb && ((a = Error(r(422), { cause: h })), Kd(Ai(a, l))))
          : (h !== Sb && ((o = Error(r(423), { cause: h })), Kd(Ai(o, l))),
            (a = a.current.alternate),
            (a.flags |= 65536),
            (b &= -b),
            (a.lanes |= b),
            (h = Ai(h, l)),
            (b = Yb(a.stateNode, h, b)),
            dy(a, b),
            Pn !== 4 && (Pn = 2)),
        !1
      )
    var _ = Error(r(520), { cause: h })
    if (((_ = Ai(_, l)), pf === null ? (pf = [_]) : pf.push(_), Pn !== 4 && (Pn = 2), o === null))
      return !0
    ;(h = Ai(h, l)), (l = o)
    do {
      switch (l.tag) {
        case 3:
          return (
            (l.flags |= 65536),
            (a = b & -b),
            (l.lanes |= a),
            (a = Yb(l.stateNode, h, a)),
            dy(l, a),
            !1
          )
        case 1:
          if (
            ((o = l.type),
            (_ = l.stateNode),
            (l.flags & 128) === 0 &&
              (typeof o.getDerivedStateFromError == 'function' ||
                (_ !== null &&
                  typeof _.componentDidCatch == 'function' &&
                  (io === null || !io.has(_)))))
          )
            return (
              (l.flags |= 65536),
              (b &= -b),
              (l.lanes |= b),
              (b = q3(b)),
              H3(b, a, l, h),
              dy(l, b),
              !1
            )
      }
      l = l.return
    } while (l !== null)
    return !1
  }
  var G3 = Error(r(461)),
    tr = !1
  function hr(a, o, l, h) {
    o.child = a === null ? YA(o, null, l, h) : ac(o, a.child, l, h)
  }
  function V3(a, o, l, h, b) {
    l = l.render
    var _ = o.ref
    if ('ref' in h) {
      var U = {}
      for (var q in h) q !== 'ref' && (U[q] = h[q])
    } else U = h
    return (
      hc(o),
      (h = Pb(a, o, l, U, _, b)),
      (q = Mb()),
      a !== null && !tr
        ? (kb(a, o, b), ia(a, o, b))
        : (Et && q && _b(o), (o.flags |= 1), hr(a, o, h, b), o.child)
    )
  }
  function K3(a, o, l, h, b) {
    if (a === null) {
      var _ = l.type
      return typeof _ == 'function' && !vy(_) && _.defaultProps === void 0 && l.compare === null
        ? ((o.tag = 15), (o.type = _), W3(a, o, _, h, b))
        : ((a = _0(l.type, null, h, o, o.mode, b)), (a.ref = o.ref), (a.return = o), (o.child = a))
    }
    if (((_ = a.child), !sy(a, b))) {
      var U = _.memoizedProps
      if (((l = l.compare), (l = l !== null ? l : qd), l(U, h) && a.ref === o.ref))
        return ia(a, o, b)
    }
    return (o.flags |= 1), (a = no(_, h)), (a.ref = o.ref), (a.return = o), (o.child = a)
  }
  function W3(a, o, l, h, b) {
    if (a !== null) {
      var _ = a.memoizedProps
      if (qd(_, h) && a.ref === o.ref)
        if (((tr = !1), (o.pendingProps = h = _), sy(a, b))) (a.flags & 131072) !== 0 && (tr = !0)
        else return (o.lanes = a.lanes), ia(a, o, b)
    }
    return Zb(a, o, l, h, b)
  }
  function Q3(a, o, l) {
    var h = o.pendingProps,
      b = h.children,
      _ = (o.stateNode._pendingVisibility & 2) !== 0,
      U = a !== null ? a.memoizedState : null
    if ((rf(a, o), h.mode === 'hidden' || _)) {
      if ((o.flags & 128) !== 0) {
        if (((h = U !== null ? U.baseLanes | l : l), a !== null)) {
          for (b = o.child = a.child, _ = 0; b !== null; )
            (_ = _ | b.lanes | b.childLanes), (b = b.sibling)
          o.childLanes = _ & ~h
        } else (o.childLanes = 0), (o.child = null)
        return Y3(a, o, h, l)
      }
      if ((l & 536870912) !== 0)
        (o.memoizedState = { baseLanes: 0, cachePool: null }),
          a !== null && c0(o, U !== null ? U.cachePool : null),
          U !== null ? ZA(o, U) : xb(),
          XA(o)
      else
        return (o.lanes = o.childLanes = 536870912), Y3(a, o, U !== null ? U.baseLanes | l : l, l)
    } else
      U !== null
        ? (c0(o, U.cachePool), ZA(o, U), Va(), (o.memoizedState = null))
        : (a !== null && c0(o, null), xb(), Va())
    return hr(a, o, b, l), o.child
  }
  function Y3(a, o, l, h) {
    var b = Rb()
    return (
      (b = b === null ? null : { parent: Qn._currentValue, pool: b }),
      (o.memoizedState = { baseLanes: l, cachePool: b }),
      a !== null && c0(o, null),
      xb(),
      XA(o),
      a !== null && sf(a, o, h, !0),
      null
    )
  }
  function rf(a, o) {
    var l = o.ref
    if (l === null) a !== null && a.ref !== null && (o.flags |= 2097664)
    else {
      if (typeof l != 'function' && typeof l != 'object') throw Error(r(284))
      ;(a === null || a.ref !== l) && (o.flags |= 2097664)
    }
  }
  function Zb(a, o, l, h, b) {
    return (
      hc(o),
      (l = Pb(a, o, l, h, void 0, b)),
      (h = Mb()),
      a !== null && !tr
        ? (kb(a, o, b), ia(a, o, b))
        : (Et && h && _b(o), (o.flags |= 1), hr(a, o, l, b), o.child)
    )
  }
  function Z3(a, o, l, h, b, _) {
    return (
      hc(o),
      (o.updateQueue = null),
      (l = r3(o, h, l, b)),
      n3(a),
      (h = Mb()),
      a !== null && !tr
        ? (kb(a, o, _), ia(a, o, _))
        : (Et && h && _b(o), (o.flags |= 1), hr(a, o, l, _), o.child)
    )
  }
  function X3(a, o, l, h, b) {
    if ((hc(o), o.stateNode === null)) {
      var _ = Bu,
        U = l.contextType
      typeof U == 'object' && U !== null && (_ = Cr(U)),
        (_ = new l(h, _)),
        (o.memoizedState = _.state !== null && _.state !== void 0 ? _.state : null),
        (_.updater = Qb),
        (o.stateNode = _),
        (_._reactInternals = o),
        (_ = o.stateNode),
        (_.props = h),
        (_.state = o.memoizedState),
        (_.refs = {}),
        uy(o),
        (U = l.contextType),
        (_.context = typeof U == 'object' && U !== null ? Cr(U) : Bu),
        (_.state = o.memoizedState),
        (U = l.getDerivedStateFromProps),
        typeof U == 'function' && (Wb(o, l, U, h), (_.state = o.memoizedState)),
        typeof l.getDerivedStateFromProps == 'function' ||
          typeof _.getSnapshotBeforeUpdate == 'function' ||
          (typeof _.UNSAFE_componentWillMount != 'function' &&
            typeof _.componentWillMount != 'function') ||
          ((U = _.state),
          typeof _.componentWillMount == 'function' && _.componentWillMount(),
          typeof _.UNSAFE_componentWillMount == 'function' && _.UNSAFE_componentWillMount(),
          U !== _.state && Qb.enqueueReplaceState(_, _.state, null),
          cf(o, h, _, b),
          of(),
          (_.state = o.memoizedState)),
        typeof _.componentDidMount == 'function' && (o.flags |= 4194308),
        (h = !0)
    } else if (a === null) {
      _ = o.stateNode
      var q = o.memoizedProps,
        K = dc(l, q)
      _.props = K
      var J = _.context,
        oe = l.contextType
      ;(U = Bu), typeof oe == 'object' && oe !== null && (U = Cr(oe))
      var le = l.getDerivedStateFromProps
      ;(oe = typeof le == 'function' || typeof _.getSnapshotBeforeUpdate == 'function'),
        (q = o.pendingProps !== q),
        oe ||
          (typeof _.UNSAFE_componentWillReceiveProps != 'function' &&
            typeof _.componentWillReceiveProps != 'function') ||
          ((q || J !== U) && L3(o, _, h, U)),
        (Ya = !1)
      var ie = o.memoizedState
      ;(_.state = ie),
        cf(o, h, _, b),
        of(),
        (J = o.memoizedState),
        q || ie !== J || Ya
          ? (typeof le == 'function' && (Wb(o, l, le, h), (J = o.memoizedState)),
            (K = Ya || B3(o, l, K, h, ie, J, U))
              ? (oe ||
                  (typeof _.UNSAFE_componentWillMount != 'function' &&
                    typeof _.componentWillMount != 'function') ||
                  (typeof _.componentWillMount == 'function' && _.componentWillMount(),
                  typeof _.UNSAFE_componentWillMount == 'function' &&
                    _.UNSAFE_componentWillMount()),
                typeof _.componentDidMount == 'function' && (o.flags |= 4194308))
              : (typeof _.componentDidMount == 'function' && (o.flags |= 4194308),
                (o.memoizedProps = h),
                (o.memoizedState = J)),
            (_.props = h),
            (_.state = J),
            (_.context = U),
            (h = K))
          : (typeof _.componentDidMount == 'function' && (o.flags |= 4194308), (h = !1))
    } else {
      ;(_ = o.stateNode),
        ly(a, o),
        (U = o.memoizedProps),
        (oe = dc(l, U)),
        (_.props = oe),
        (le = o.pendingProps),
        (ie = _.context),
        (J = l.contextType),
        (K = Bu),
        typeof J == 'object' && J !== null && (K = Cr(J)),
        (q = l.getDerivedStateFromProps),
        (J = typeof q == 'function' || typeof _.getSnapshotBeforeUpdate == 'function') ||
          (typeof _.UNSAFE_componentWillReceiveProps != 'function' &&
            typeof _.componentWillReceiveProps != 'function') ||
          ((U !== le || ie !== K) && L3(o, _, h, K)),
        (Ya = !1),
        (ie = o.memoizedState),
        (_.state = ie),
        cf(o, h, _, b),
        of()
      var ae = o.memoizedState
      U !== le || ie !== ae || Ya || (a !== null && a.dependencies !== null && v0(a.dependencies))
        ? (typeof q == 'function' && (Wb(o, l, q, h), (ae = o.memoizedState)),
          (oe =
            Ya ||
            B3(o, l, oe, h, ie, ae, K) ||
            (a !== null && a.dependencies !== null && v0(a.dependencies)))
            ? (J ||
                (typeof _.UNSAFE_componentWillUpdate != 'function' &&
                  typeof _.componentWillUpdate != 'function') ||
                (typeof _.componentWillUpdate == 'function' && _.componentWillUpdate(h, ae, K),
                typeof _.UNSAFE_componentWillUpdate == 'function' &&
                  _.UNSAFE_componentWillUpdate(h, ae, K)),
              typeof _.componentDidUpdate == 'function' && (o.flags |= 4),
              typeof _.getSnapshotBeforeUpdate == 'function' && (o.flags |= 1024))
            : (typeof _.componentDidUpdate != 'function' ||
                (U === a.memoizedProps && ie === a.memoizedState) ||
                (o.flags |= 4),
              typeof _.getSnapshotBeforeUpdate != 'function' ||
                (U === a.memoizedProps && ie === a.memoizedState) ||
                (o.flags |= 1024),
              (o.memoizedProps = h),
              (o.memoizedState = ae)),
          (_.props = h),
          (_.state = ae),
          (_.context = K),
          (h = oe))
        : (typeof _.componentDidUpdate != 'function' ||
            (U === a.memoizedProps && ie === a.memoizedState) ||
            (o.flags |= 4),
          typeof _.getSnapshotBeforeUpdate != 'function' ||
            (U === a.memoizedProps && ie === a.memoizedState) ||
            (o.flags |= 1024),
          (h = !1))
    }
    return (
      (_ = h),
      rf(a, o),
      (h = (o.flags & 128) !== 0),
      _ || h
        ? ((_ = o.stateNode),
          (l = h && typeof l.getDerivedStateFromError != 'function' ? null : _.render()),
          (o.flags |= 1),
          a !== null && h
            ? ((o.child = ac(o, a.child, null, b)), (o.child = ac(o, null, l, b)))
            : hr(a, o, l, b),
          (o.memoizedState = _.state),
          (a = o.child))
        : (a = ia(a, o, b)),
      a
    )
  }
  function J3(a, o, l, h) {
    return Vd(), (o.flags |= 256), hr(a, o, l, h), o.child
  }
  var Xb = { dehydrated: null, treeContext: null, retryLane: 0 }
  function Jb(a) {
    return { baseLanes: a, cachePool: t3() }
  }
  function ey(a, o, l) {
    return (a = a !== null ? a.childLanes & ~l : 0), o && (a |= Ii), a
  }
  function e_(a, o, l) {
    var h = o.pendingProps,
      b = !1,
      _ = (o.flags & 128) !== 0,
      U
    if (
      ((U = _) || (U = a !== null && a.memoizedState === null ? !1 : (Wn.current & 2) !== 0),
      U && ((b = !0), (o.flags &= -129)),
      (U = (o.flags & 32) !== 0),
      (o.flags &= -33),
      a === null)
    ) {
      if (Et) {
        if ((b ? Ga(o) : Va(), Et)) {
          var q = fr,
            K
          if ((K = q)) {
            e: {
              for (K = q, q = ws; K.nodeType !== 8; ) {
                if (!q) {
                  q = null
                  break e
                }
                if (((K = Ji(K.nextSibling)), K === null)) {
                  q = null
                  break e
                }
              }
              q = K
            }
            q !== null
              ? ((o.memoizedState = {
                  dehydrated: q,
                  treeContext: rc !== null ? { id: ea, overflow: ta } : null,
                  retryLane: 536870912
                }),
                (K = Ni(18, null, null, 0)),
                (K.stateNode = q),
                (K.return = o),
                (o.child = K),
                (Mr = o),
                (fr = null),
                (K = !0))
              : (K = !1)
          }
          K || sc(o)
        }
        if (((q = o.memoizedState), q !== null && ((q = q.dehydrated), q !== null)))
          return q.data === '$!' ? (o.lanes = 16) : (o.lanes = 536870912), null
        na(o)
      }
      return (
        (q = h.children),
        (h = h.fallback),
        b
          ? (Va(),
            (b = o.mode),
            (q = ny({ mode: 'hidden', children: q }, b)),
            (h = gc(h, b, l, null)),
            (q.return = o),
            (h.return = o),
            (q.sibling = h),
            (o.child = q),
            (b = o.child),
            (b.memoizedState = Jb(l)),
            (b.childLanes = ey(a, U, l)),
            (o.memoizedState = Xb),
            h)
          : (Ga(o), ty(o, q))
      )
    }
    if (((K = a.memoizedState), K !== null && ((q = K.dehydrated), q !== null))) {
      if (_)
        o.flags & 256
          ? (Ga(o), (o.flags &= -257), (o = ry(a, o, l)))
          : o.memoizedState !== null
            ? (Va(), (o.child = a.child), (o.flags |= 128), (o = null))
            : (Va(),
              (b = h.fallback),
              (q = o.mode),
              (h = ny({ mode: 'visible', children: h.children }, q)),
              (b = gc(b, q, l, null)),
              (b.flags |= 2),
              (h.return = o),
              (b.return = o),
              (h.sibling = b),
              (o.child = h),
              ac(o, a.child, null, l),
              (h = o.child),
              (h.memoizedState = Jb(l)),
              (h.childLanes = ey(a, U, l)),
              (o.memoizedState = Xb),
              (o = b))
      else if ((Ga(o), q.data === '$!')) {
        if (((U = q.nextSibling && q.nextSibling.dataset), U)) var J = U.dgst
        ;(U = J),
          (h = Error(r(419))),
          (h.stack = ''),
          (h.digest = U),
          Kd({ value: h, source: null, stack: null }),
          (o = ry(a, o, l))
      } else if ((tr || sf(a, o, l, !1), (U = (l & a.childLanes) !== 0), tr || U)) {
        if (((U = an), U !== null)) {
          if (((h = l & -l), (h & 42) !== 0)) h = 1
          else
            switch (h) {
              case 2:
                h = 1
                break
              case 8:
                h = 4
                break
              case 32:
                h = 16
                break
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                h = 64
                break
              case 268435456:
                h = 134217728
                break
              default:
                h = 0
            }
          if (((h = (h & (U.suspendedLanes | l)) !== 0 ? 0 : h), h !== 0 && h !== K.retryLane))
            throw ((K.retryLane = h), Ha(a, h), kr(U, a, h), G3)
        }
        q.data === '$?' || Ry(), (o = ry(a, o, l))
      } else
        q.data === '$?'
          ? ((o.flags |= 128),
            (o.child = a.child),
            (o = dR.bind(null, a)),
            (q._reactRetry = o),
            (o = null))
          : ((a = K.treeContext),
            (fr = Ji(q.nextSibling)),
            (Mr = o),
            (Et = !0),
            (Zi = null),
            (ws = !1),
            a !== null &&
              ((_i[Ci++] = ea),
              (_i[Ci++] = ta),
              (_i[Ci++] = rc),
              (ea = a.id),
              (ta = a.overflow),
              (rc = o)),
            (o = ty(o, h.children)),
            (o.flags |= 4096))
      return o
    }
    return b
      ? (Va(),
        (b = h.fallback),
        (q = o.mode),
        (K = a.child),
        (J = K.sibling),
        (h = no(K, { mode: 'hidden', children: h.children })),
        (h.subtreeFlags = K.subtreeFlags & 31457280),
        J !== null ? (b = no(J, b)) : ((b = gc(b, q, l, null)), (b.flags |= 2)),
        (b.return = o),
        (h.return = o),
        (h.sibling = b),
        (o.child = h),
        (h = b),
        (b = o.child),
        (q = a.child.memoizedState),
        q === null
          ? (q = Jb(l))
          : ((K = q.cachePool),
            K !== null
              ? ((J = Qn._currentValue), (K = K.parent !== J ? { parent: J, pool: J } : K))
              : (K = t3()),
            (q = { baseLanes: q.baseLanes | l, cachePool: K })),
        (b.memoizedState = q),
        (b.childLanes = ey(a, U, l)),
        (o.memoizedState = Xb),
        h)
      : (Ga(o),
        (l = a.child),
        (a = l.sibling),
        (l = no(l, { mode: 'visible', children: h.children })),
        (l.return = o),
        (l.sibling = null),
        a !== null &&
          ((U = o.deletions), U === null ? ((o.deletions = [a]), (o.flags |= 16)) : U.push(a)),
        (o.child = l),
        (o.memoizedState = null),
        l)
  }
  function ty(a, o) {
    return (o = ny({ mode: 'visible', children: o }, a.mode)), (o.return = a), (a.child = o)
  }
  function ny(a, o) {
    return T_(a, o, 0, null)
  }
  function ry(a, o, l) {
    return (
      ac(o, a.child, null, l),
      (a = ty(o, o.pendingProps.children)),
      (a.flags |= 2),
      (o.memoizedState = null),
      a
    )
  }
  function t_(a, o, l) {
    a.lanes |= o
    var h = a.alternate
    h !== null && (h.lanes |= o), oy(a.return, o, l)
  }
  function iy(a, o, l, h, b) {
    var _ = a.memoizedState
    _ === null
      ? (a.memoizedState = {
          isBackwards: o,
          rendering: null,
          renderingStartTime: 0,
          last: h,
          tail: l,
          tailMode: b
        })
      : ((_.isBackwards = o),
        (_.rendering = null),
        (_.renderingStartTime = 0),
        (_.last = h),
        (_.tail = l),
        (_.tailMode = b))
  }
  function n_(a, o, l) {
    var h = o.pendingProps,
      b = h.revealOrder,
      _ = h.tail
    if ((hr(a, o, h.children, l), (h = Wn.current), (h & 2) !== 0))
      (h = (h & 1) | 2), (o.flags |= 128)
    else {
      if (a !== null && (a.flags & 128) !== 0)
        e: for (a = o.child; a !== null; ) {
          if (a.tag === 13) a.memoizedState !== null && t_(a, l, o)
          else if (a.tag === 19) t_(a, l, o)
          else if (a.child !== null) {
            ;(a.child.return = a), (a = a.child)
            continue
          }
          if (a === o) break e
          for (; a.sibling === null; ) {
            if (a.return === null || a.return === o) break e
            a = a.return
          }
          ;(a.sibling.return = a.return), (a = a.sibling)
        }
      h &= 1
    }
    switch ((Ce(Wn, h), b)) {
      case 'forwards':
        for (l = o.child, b = null; l !== null; )
          (a = l.alternate), a !== null && o0(a) === null && (b = l), (l = l.sibling)
        ;(l = b),
          l === null ? ((b = o.child), (o.child = null)) : ((b = l.sibling), (l.sibling = null)),
          iy(o, !1, b, l, _)
        break
      case 'backwards':
        for (l = null, b = o.child, o.child = null; b !== null; ) {
          if (((a = b.alternate), a !== null && o0(a) === null)) {
            o.child = b
            break
          }
          ;(a = b.sibling), (b.sibling = l), (l = b), (b = a)
        }
        iy(o, !0, l, null, _)
        break
      case 'together':
        iy(o, !1, null, null, void 0)
        break
      default:
        o.memoizedState = null
    }
    return o.child
  }
  function ia(a, o, l) {
    if (
      (a !== null && (o.dependencies = a.dependencies), (ro |= o.lanes), (l & o.childLanes) === 0)
    )
      if (a !== null) {
        if ((sf(a, o, l, !1), (l & o.childLanes) === 0)) return null
      } else return null
    if (a !== null && o.child !== a.child) throw Error(r(153))
    if (o.child !== null) {
      for (a = o.child, l = no(a, a.pendingProps), o.child = l, l.return = o; a.sibling !== null; )
        (a = a.sibling), (l = l.sibling = no(a, a.pendingProps)), (l.return = o)
      l.sibling = null
    }
    return o.child
  }
  function sy(a, o) {
    return (a.lanes & o) !== 0 ? !0 : ((a = a.dependencies), !!(a !== null && v0(a)))
  }
  function ZO(a, o, l) {
    switch (o.tag) {
      case 3:
        ut(o, o.stateNode.containerInfo), Qa(o, Qn, a.memoizedState.cache), Vd()
        break
      case 27:
      case 5:
        qr(o)
        break
      case 4:
        ut(o, o.stateNode.containerInfo)
        break
      case 10:
        Qa(o, o.type, o.memoizedProps.value)
        break
      case 13:
        var h = o.memoizedState
        if (h !== null)
          return h.dehydrated !== null
            ? (Ga(o), (o.flags |= 128), null)
            : (l & o.child.childLanes) !== 0
              ? e_(a, o, l)
              : (Ga(o), (a = ia(a, o, l)), a !== null ? a.sibling : null)
        Ga(o)
        break
      case 19:
        var b = (a.flags & 128) !== 0
        if (
          ((h = (l & o.childLanes) !== 0),
          h || (sf(a, o, l, !1), (h = (l & o.childLanes) !== 0)),
          b)
        ) {
          if (h) return n_(a, o, l)
          o.flags |= 128
        }
        if (
          ((b = o.memoizedState),
          b !== null && ((b.rendering = null), (b.tail = null), (b.lastEffect = null)),
          Ce(Wn, Wn.current),
          h)
        )
          break
        return null
      case 22:
      case 23:
        return (o.lanes = 0), Q3(a, o, l)
      case 24:
        Qa(o, Qn, a.memoizedState.cache)
    }
    return ia(a, o, l)
  }
  function r_(a, o, l) {
    if (a !== null)
      if (a.memoizedProps !== o.pendingProps) tr = !0
      else {
        if (!sy(a, l) && (o.flags & 128) === 0) return (tr = !1), ZO(a, o, l)
        tr = (a.flags & 131072) !== 0
      }
    else (tr = !1), Et && (o.flags & 1048576) !== 0 && jA(o, n0, o.index)
    switch (((o.lanes = 0), o.tag)) {
      case 16:
        e: {
          a = o.pendingProps
          var h = o.elementType,
            b = h._init
          if (((h = b(h._payload)), (o.type = h), typeof h == 'function'))
            vy(h)
              ? ((a = dc(h, a)), (o.tag = 1), (o = X3(null, o, h, a, l)))
              : ((o.tag = 0), (o = Zb(null, o, h, a, l)))
          else {
            if (h != null) {
              if (((b = h.$$typeof), b === A)) {
                ;(o.tag = 11), (o = V3(null, o, h, a, l))
                break e
              } else if (b === O) {
                ;(o.tag = 14), (o = K3(null, o, h, a, l))
                break e
              }
            }
            throw ((o = G(h) || h), Error(r(306, o, '')))
          }
        }
        return o
      case 0:
        return Zb(a, o, o.type, o.pendingProps, l)
      case 1:
        return (h = o.type), (b = dc(h, o.pendingProps)), X3(a, o, h, b, l)
      case 3:
        e: {
          if ((ut(o, o.stateNode.containerInfo), a === null)) throw Error(r(387))
          var _ = o.pendingProps
          ;(b = o.memoizedState), (h = b.element), ly(a, o), cf(o, _, null, l)
          var U = o.memoizedState
          if (
            ((_ = U.cache),
            Qa(o, Qn, _),
            _ !== b.cache && cy(o, [Qn], l, !0),
            of(),
            (_ = U.element),
            b.isDehydrated)
          )
            if (
              ((b = { element: _, isDehydrated: !1, cache: U.cache }),
              (o.updateQueue.baseState = b),
              (o.memoizedState = b),
              o.flags & 256)
            ) {
              o = J3(a, o, _, l)
              break e
            } else if (_ !== h) {
              ;(h = Ai(Error(r(424)), o)), Kd(h), (o = J3(a, o, _, l))
              break e
            } else
              for (
                fr = Ji(o.stateNode.containerInfo.firstChild),
                  Mr = o,
                  Et = !0,
                  Zi = null,
                  ws = !0,
                  l = YA(o, null, _, l),
                  o.child = l;
                l;

              )
                (l.flags = (l.flags & -3) | 4096), (l = l.sibling)
          else {
            if ((Vd(), _ === h)) {
              o = ia(a, o, l)
              break e
            }
            hr(a, o, _, l)
          }
          o = o.child
        }
        return o
      case 26:
        return (
          rf(a, o),
          a === null
            ? (l = aC(o.type, null, o.pendingProps, null))
              ? (o.memoizedState = l)
              : Et ||
                ((l = o.type),
                (a = o.pendingProps),
                (h = k0(Ke.current).createElement(l)),
                (h[st] = o),
                (h[dr] = a),
                pr(h, l, a),
                Rn(h),
                (o.stateNode = h))
            : (o.memoizedState = aC(o.type, a.memoizedProps, o.pendingProps, a.memoizedState)),
          null
        )
      case 27:
        return (
          qr(o),
          a === null &&
            Et &&
            ((h = o.stateNode = rC(o.type, o.pendingProps, Ke.current)),
            (Mr = o),
            (ws = !0),
            (fr = Ji(h.firstChild))),
          (h = o.pendingProps.children),
          a !== null || Et ? hr(a, o, h, l) : (o.child = ac(o, null, h, l)),
          rf(a, o),
          o.child
        )
      case 5:
        return (
          a === null &&
            Et &&
            ((b = h = fr) &&
              ((h = xR(h, o.type, o.pendingProps, ws)),
              h !== null
                ? ((o.stateNode = h), (Mr = o), (fr = Ji(h.firstChild)), (ws = !1), (b = !0))
                : (b = !1)),
            b || sc(o)),
          qr(o),
          (b = o.type),
          (_ = o.pendingProps),
          (U = a !== null ? a.memoizedProps : null),
          (h = _.children),
          Gy(b, _) ? (h = null) : U !== null && Gy(b, U) && (o.flags |= 32),
          o.memoizedState !== null && ((b = Pb(a, o, HO, null, null, l)), (_f._currentValue = b)),
          rf(a, o),
          hr(a, o, h, l),
          o.child
        )
      case 6:
        return (
          a === null &&
            Et &&
            ((a = l = fr) &&
              ((l = NR(l, o.pendingProps, ws)),
              l !== null ? ((o.stateNode = l), (Mr = o), (fr = null), (a = !0)) : (a = !1)),
            a || sc(o)),
          null
        )
      case 13:
        return e_(a, o, l)
      case 4:
        return (
          ut(o, o.stateNode.containerInfo),
          (h = o.pendingProps),
          a === null ? (o.child = ac(o, null, h, l)) : hr(a, o, h, l),
          o.child
        )
      case 11:
        return V3(a, o, o.type, o.pendingProps, l)
      case 7:
        return hr(a, o, o.pendingProps, l), o.child
      case 8:
        return hr(a, o, o.pendingProps.children, l), o.child
      case 12:
        return hr(a, o, o.pendingProps.children, l), o.child
      case 10:
        return (h = o.pendingProps), Qa(o, o.type, h.value), hr(a, o, h.children, l), o.child
      case 9:
        return (
          (b = o.type._context),
          (h = o.pendingProps.children),
          hc(o),
          (b = Cr(b)),
          (h = h(b)),
          (o.flags |= 1),
          hr(a, o, h, l),
          o.child
        )
      case 14:
        return K3(a, o, o.type, o.pendingProps, l)
      case 15:
        return W3(a, o, o.type, o.pendingProps, l)
      case 19:
        return n_(a, o, l)
      case 22:
        return Q3(a, o, l)
      case 24:
        return (
          hc(o),
          (h = Cr(Qn)),
          a === null
            ? ((b = Rb()),
              b === null &&
                ((b = an),
                (_ = Ib()),
                (b.pooledCache = _),
                _.refCount++,
                _ !== null && (b.pooledCacheLanes |= l),
                (b = _)),
              (o.memoizedState = { parent: h, cache: b }),
              uy(o),
              Qa(o, Qn, b))
            : ((a.lanes & l) !== 0 && (ly(a, o), cf(o, null, null, l), of()),
              (b = a.memoizedState),
              (_ = o.memoizedState),
              b.parent !== h
                ? ((b = { parent: h, cache: h }),
                  (o.memoizedState = b),
                  o.lanes === 0 && (o.memoizedState = o.updateQueue.baseState = b),
                  Qa(o, Qn, h))
                : ((h = _.cache), Qa(o, Qn, h), h !== b.cache && cy(o, [Qn], l, !0))),
          hr(a, o, o.pendingProps.children, l),
          o.child
        )
      case 29:
        throw o.pendingProps
    }
    throw Error(r(156, o.tag))
  }
  var ay = _e(null),
    fc = null,
    sa = null
  function Qa(a, o, l) {
    Ce(ay, o._currentValue), (o._currentValue = l)
  }
  function aa(a) {
    ;(a._currentValue = ay.current), ye(ay)
  }
  function oy(a, o, l) {
    for (; a !== null; ) {
      var h = a.alternate
      if (
        ((a.childLanes & o) !== o
          ? ((a.childLanes |= o), h !== null && (h.childLanes |= o))
          : h !== null && (h.childLanes & o) !== o && (h.childLanes |= o),
        a === l)
      )
        break
      a = a.return
    }
  }
  function cy(a, o, l, h) {
    var b = a.child
    for (b !== null && (b.return = a); b !== null; ) {
      var _ = b.dependencies
      if (_ !== null) {
        var U = b.child
        _ = _.firstContext
        e: for (; _ !== null; ) {
          var q = _
          _ = b
          for (var K = 0; K < o.length; K++)
            if (q.context === o[K]) {
              ;(_.lanes |= l),
                (q = _.alternate),
                q !== null && (q.lanes |= l),
                oy(_.return, l, a),
                h || (U = null)
              break e
            }
          _ = q.next
        }
      } else if (b.tag === 18) {
        if (((U = b.return), U === null)) throw Error(r(341))
        ;(U.lanes |= l), (_ = U.alternate), _ !== null && (_.lanes |= l), oy(U, l, a), (U = null)
      } else U = b.child
      if (U !== null) U.return = b
      else
        for (U = b; U !== null; ) {
          if (U === a) {
            U = null
            break
          }
          if (((b = U.sibling), b !== null)) {
            ;(b.return = U.return), (U = b)
            break
          }
          U = U.return
        }
      b = U
    }
  }
  function sf(a, o, l, h) {
    a = null
    for (var b = o, _ = !1; b !== null; ) {
      if (!_) {
        if ((b.flags & 524288) !== 0) _ = !0
        else if ((b.flags & 262144) !== 0) break
      }
      if (b.tag === 10) {
        var U = b.alternate
        if (U === null) throw Error(r(387))
        if (((U = U.memoizedProps), U !== null)) {
          var q = b.type
          si(b.pendingProps.value, U.value) || (a !== null ? a.push(q) : (a = [q]))
        }
      } else if (b === jn.current) {
        if (((U = b.alternate), U === null)) throw Error(r(387))
        U.memoizedState.memoizedState !== b.memoizedState.memoizedState &&
          (a !== null ? a.push(_f) : (a = [_f]))
      }
      b = b.return
    }
    a !== null && cy(o, a, l, h), (o.flags |= 262144)
  }
  function v0(a) {
    for (a = a.firstContext; a !== null; ) {
      if (!si(a.context._currentValue, a.memoizedValue)) return !0
      a = a.next
    }
    return !1
  }
  function hc(a) {
    ;(fc = a), (sa = null), (a = a.dependencies), a !== null && (a.firstContext = null)
  }
  function Cr(a) {
    return i_(fc, a)
  }
  function w0(a, o) {
    return fc === null && hc(a), i_(a, o)
  }
  function i_(a, o) {
    var l = o._currentValue
    if (((o = { context: o, memoizedValue: l, next: null }), sa === null)) {
      if (a === null) throw Error(r(308))
      ;(sa = o), (a.dependencies = { lanes: 0, firstContext: o }), (a.flags |= 524288)
    } else sa = sa.next = o
    return l
  }
  var Ya = !1
  function uy(a) {
    a.updateQueue = {
      baseState: a.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    }
  }
  function ly(a, o) {
    ;(a = a.updateQueue),
      o.updateQueue === a &&
        (o.updateQueue = {
          baseState: a.baseState,
          firstBaseUpdate: a.firstBaseUpdate,
          lastBaseUpdate: a.lastBaseUpdate,
          shared: a.shared,
          callbacks: null
        })
  }
  function Za(a) {
    return { lane: a, tag: 0, payload: null, callback: null, next: null }
  }
  function Xa(a, o, l) {
    var h = a.updateQueue
    if (h === null) return null
    if (((h = h.shared), (Cn & 2) !== 0)) {
      var b = h.pending
      return (
        b === null ? (o.next = o) : ((o.next = b.next), (b.next = o)),
        (h.pending = o),
        (o = e0(a)),
        $A(a, null, l),
        o
      )
    }
    return Jp(a, h, o, l), e0(a)
  }
  function af(a, o, l) {
    if (((o = o.updateQueue), o !== null && ((o = o.shared), (l & 4194176) !== 0))) {
      var h = o.lanes
      ;(h &= a.pendingLanes), (l |= h), (o.lanes = l), Rd(a, l)
    }
  }
  function dy(a, o) {
    var l = a.updateQueue,
      h = a.alternate
    if (h !== null && ((h = h.updateQueue), l === h)) {
      var b = null,
        _ = null
      if (((l = l.firstBaseUpdate), l !== null)) {
        do {
          var U = { lane: l.lane, tag: l.tag, payload: l.payload, callback: null, next: null }
          _ === null ? (b = _ = U) : (_ = _.next = U), (l = l.next)
        } while (l !== null)
        _ === null ? (b = _ = o) : (_ = _.next = o)
      } else b = _ = o
      ;(l = {
        baseState: h.baseState,
        firstBaseUpdate: b,
        lastBaseUpdate: _,
        shared: h.shared,
        callbacks: h.callbacks
      }),
        (a.updateQueue = l)
      return
    }
    ;(a = l.lastBaseUpdate),
      a === null ? (l.firstBaseUpdate = o) : (a.next = o),
      (l.lastBaseUpdate = o)
  }
  var fy = !1
  function of() {
    if (fy) {
      var a = qu
      if (a !== null) throw a
    }
  }
  function cf(a, o, l, h) {
    fy = !1
    var b = a.updateQueue
    Ya = !1
    var _ = b.firstBaseUpdate,
      U = b.lastBaseUpdate,
      q = b.shared.pending
    if (q !== null) {
      b.shared.pending = null
      var K = q,
        J = K.next
      ;(K.next = null), U === null ? (_ = J) : (U.next = J), (U = K)
      var oe = a.alternate
      oe !== null &&
        ((oe = oe.updateQueue),
        (q = oe.lastBaseUpdate),
        q !== U && (q === null ? (oe.firstBaseUpdate = J) : (q.next = J), (oe.lastBaseUpdate = K)))
    }
    if (_ !== null) {
      var le = b.baseState
      ;(U = 0), (oe = J = K = null), (q = _)
      do {
        var ie = q.lane & -536870913,
          ae = ie !== q.lane
        if (ae ? (yt & ie) === ie : (h & ie) === ie) {
          ie !== 0 && ie === zu && (fy = !0),
            oe !== null &&
              (oe = oe.next =
                { lane: 0, tag: q.tag, payload: q.payload, callback: null, next: null })
          e: {
            var Pe = a,
              qe = q
            ie = o
            var Mn = l
            switch (qe.tag) {
              case 1:
                if (((Pe = qe.payload), typeof Pe == 'function')) {
                  le = Pe.call(Mn, le, ie)
                  break e
                }
                le = Pe
                break e
              case 3:
                Pe.flags = (Pe.flags & -65537) | 128
              case 0:
                if (
                  ((Pe = qe.payload),
                  (ie = typeof Pe == 'function' ? Pe.call(Mn, le, ie) : Pe),
                  ie == null)
                )
                  break e
                le = V({}, le, ie)
                break e
              case 2:
                Ya = !0
            }
          }
          ;(ie = q.callback),
            ie !== null &&
              ((a.flags |= 64),
              ae && (a.flags |= 8192),
              (ae = b.callbacks),
              ae === null ? (b.callbacks = [ie]) : ae.push(ie))
        } else
          (ae = { lane: ie, tag: q.tag, payload: q.payload, callback: q.callback, next: null }),
            oe === null ? ((J = oe = ae), (K = le)) : (oe = oe.next = ae),
            (U |= ie)
        if (((q = q.next), q === null)) {
          if (((q = b.shared.pending), q === null)) break
          ;(ae = q),
            (q = ae.next),
            (ae.next = null),
            (b.lastBaseUpdate = ae),
            (b.shared.pending = null)
        }
      } while (!0)
      oe === null && (K = le),
        (b.baseState = K),
        (b.firstBaseUpdate = J),
        (b.lastBaseUpdate = oe),
        _ === null && (b.shared.lanes = 0),
        (ro |= U),
        (a.lanes = U),
        (a.memoizedState = le)
    }
  }
  function s_(a, o) {
    if (typeof a != 'function') throw Error(r(191, a))
    a.call(o)
  }
  function a_(a, o) {
    var l = a.callbacks
    if (l !== null) for (a.callbacks = null, a = 0; a < l.length; a++) s_(l[a], o)
  }
  function uf(a, o) {
    try {
      var l = o.updateQueue,
        h = l !== null ? l.lastEffect : null
      if (h !== null) {
        var b = h.next
        l = b
        do {
          if ((l.tag & a) === a) {
            h = void 0
            var _ = l.create,
              U = l.inst
            ;(h = _()), (U.destroy = h)
          }
          l = l.next
        } while (l !== b)
      }
    } catch (q) {
      Jt(o, o.return, q)
    }
  }
  function Ja(a, o, l) {
    try {
      var h = o.updateQueue,
        b = h !== null ? h.lastEffect : null
      if (b !== null) {
        var _ = b.next
        h = _
        do {
          if ((h.tag & a) === a) {
            var U = h.inst,
              q = U.destroy
            if (q !== void 0) {
              ;(U.destroy = void 0), (b = o)
              var K = l
              try {
                q()
              } catch (J) {
                Jt(b, K, J)
              }
            }
          }
          h = h.next
        } while (h !== _)
      }
    } catch (J) {
      Jt(o, o.return, J)
    }
  }
  function o_(a) {
    var o = a.updateQueue
    if (o !== null) {
      var l = a.stateNode
      try {
        a_(o, l)
      } catch (h) {
        Jt(a, a.return, h)
      }
    }
  }
  function c_(a, o, l) {
    ;(l.props = dc(a.type, a.memoizedProps)), (l.state = a.memoizedState)
    try {
      l.componentWillUnmount()
    } catch (h) {
      Jt(a, o, h)
    }
  }
  function pc(a, o) {
    try {
      var l = a.ref
      if (l !== null) {
        var h = a.stateNode
        switch (a.tag) {
          case 26:
          case 27:
          case 5:
            var b = h
            break
          default:
            b = h
        }
        typeof l == 'function' ? (a.refCleanup = l(b)) : (l.current = b)
      }
    } catch (_) {
      Jt(a, o, _)
    }
  }
  function ai(a, o) {
    var l = a.ref,
      h = a.refCleanup
    if (l !== null)
      if (typeof h == 'function')
        try {
          h()
        } catch (b) {
          Jt(a, o, b)
        } finally {
          ;(a.refCleanup = null), (a = a.alternate), a != null && (a.refCleanup = null)
        }
      else if (typeof l == 'function')
        try {
          l(null)
        } catch (b) {
          Jt(a, o, b)
        }
      else l.current = null
  }
  function u_(a) {
    var o = a.type,
      l = a.memoizedProps,
      h = a.stateNode
    try {
      e: switch (o) {
        case 'button':
        case 'input':
        case 'select':
        case 'textarea':
          l.autoFocus && h.focus()
          break e
        case 'img':
          l.src ? (h.src = l.src) : l.srcSet && (h.srcset = l.srcSet)
      }
    } catch (b) {
      Jt(a, a.return, b)
    }
  }
  function l_(a, o, l) {
    try {
      var h = a.stateNode
      AR(h, a.type, l, o), (h[dr] = o)
    } catch (b) {
      Jt(a, a.return, b)
    }
  }
  function d_(a) {
    return a.tag === 5 || a.tag === 3 || a.tag === 26 || a.tag === 27 || a.tag === 4
  }
  function hy(a) {
    e: for (;;) {
      for (; a.sibling === null; ) {
        if (a.return === null || d_(a.return)) return null
        a = a.return
      }
      for (
        a.sibling.return = a.return, a = a.sibling;
        a.tag !== 5 && a.tag !== 6 && a.tag !== 27 && a.tag !== 18;

      ) {
        if (a.flags & 2 || a.child === null || a.tag === 4) continue e
        ;(a.child.return = a), (a = a.child)
      }
      if (!(a.flags & 2)) return a.stateNode
    }
  }
  function py(a, o, l) {
    var h = a.tag
    if (h === 5 || h === 6)
      (a = a.stateNode),
        o
          ? l.nodeType === 8
            ? l.parentNode.insertBefore(a, o)
            : l.insertBefore(a, o)
          : (l.nodeType === 8
              ? ((o = l.parentNode), o.insertBefore(a, l))
              : ((o = l), o.appendChild(a)),
            (l = l._reactRootContainer),
            l != null || o.onclick !== null || (o.onclick = M0))
    else if (h !== 4 && h !== 27 && ((a = a.child), a !== null))
      for (py(a, o, l), a = a.sibling; a !== null; ) py(a, o, l), (a = a.sibling)
  }
  function E0(a, o, l) {
    var h = a.tag
    if (h === 5 || h === 6) (a = a.stateNode), o ? l.insertBefore(a, o) : l.appendChild(a)
    else if (h !== 4 && h !== 27 && ((a = a.child), a !== null))
      for (E0(a, o, l), a = a.sibling; a !== null; ) E0(a, o, l), (a = a.sibling)
  }
  var oa = !1,
    Dn = !1,
    gy = !1,
    f_ = typeof WeakSet == 'function' ? WeakSet : Set,
    nr = null,
    h_ = !1
  function XO(a, o) {
    if (((a = a.containerInfo), (qy = j0), (a = OA(a)), bb(a))) {
      if ('selectionStart' in a) var l = { start: a.selectionStart, end: a.selectionEnd }
      else
        e: {
          l = ((l = a.ownerDocument) && l.defaultView) || window
          var h = l.getSelection && l.getSelection()
          if (h && h.rangeCount !== 0) {
            l = h.anchorNode
            var b = h.anchorOffset,
              _ = h.focusNode
            h = h.focusOffset
            try {
              l.nodeType, _.nodeType
            } catch {
              l = null
              break e
            }
            var U = 0,
              q = -1,
              K = -1,
              J = 0,
              oe = 0,
              le = a,
              ie = null
            t: for (;;) {
              for (
                var ae;
                le !== l || (b !== 0 && le.nodeType !== 3) || (q = U + b),
                  le !== _ || (h !== 0 && le.nodeType !== 3) || (K = U + h),
                  le.nodeType === 3 && (U += le.nodeValue.length),
                  (ae = le.firstChild) !== null;

              )
                (ie = le), (le = ae)
              for (;;) {
                if (le === a) break t
                if (
                  (ie === l && ++J === b && (q = U),
                  ie === _ && ++oe === h && (K = U),
                  (ae = le.nextSibling) !== null)
                )
                  break
                ;(le = ie), (ie = le.parentNode)
              }
              le = ae
            }
            l = q === -1 || K === -1 ? null : { start: q, end: K }
          } else l = null
        }
      l = l || { start: 0, end: 0 }
    } else l = null
    for (Hy = { focusedElem: a, selectionRange: l }, j0 = !1, nr = o; nr !== null; )
      if (((o = nr), (a = o.child), (o.subtreeFlags & 1028) !== 0 && a !== null))
        (a.return = o), (nr = a)
      else
        for (; nr !== null; ) {
          switch (((o = nr), (_ = o.alternate), (a = o.flags), o.tag)) {
            case 0:
              break
            case 11:
            case 15:
              break
            case 1:
              if ((a & 1024) !== 0 && _ !== null) {
                ;(a = void 0),
                  (l = o),
                  (b = _.memoizedProps),
                  (_ = _.memoizedState),
                  (h = l.stateNode)
                try {
                  var Pe = dc(l.type, b, l.elementType === l.type)
                  ;(a = h.getSnapshotBeforeUpdate(Pe, _)),
                    (h.__reactInternalSnapshotBeforeUpdate = a)
                } catch (qe) {
                  Jt(l, l.return, qe)
                }
              }
              break
            case 3:
              if ((a & 1024) !== 0) {
                if (((a = o.stateNode.containerInfo), (l = a.nodeType), l === 9)) Wy(a)
                else if (l === 1)
                  switch (a.nodeName) {
                    case 'HEAD':
                    case 'HTML':
                    case 'BODY':
                      Wy(a)
                      break
                    default:
                      a.textContent = ''
                  }
              }
              break
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break
            default:
              if ((a & 1024) !== 0) throw Error(r(163))
          }
          if (((a = o.sibling), a !== null)) {
            ;(a.return = o.return), (nr = a)
            break
          }
          nr = o.return
        }
    return (Pe = h_), (h_ = !1), Pe
  }
  function p_(a, o, l) {
    var h = l.flags
    switch (l.tag) {
      case 0:
      case 11:
      case 15:
        ua(a, l), h & 4 && uf(5, l)
        break
      case 1:
        if ((ua(a, l), h & 4))
          if (((a = l.stateNode), o === null))
            try {
              a.componentDidMount()
            } catch (q) {
              Jt(l, l.return, q)
            }
          else {
            var b = dc(l.type, o.memoizedProps)
            o = o.memoizedState
            try {
              a.componentDidUpdate(b, o, a.__reactInternalSnapshotBeforeUpdate)
            } catch (q) {
              Jt(l, l.return, q)
            }
          }
        h & 64 && o_(l), h & 512 && pc(l, l.return)
        break
      case 3:
        if ((ua(a, l), h & 64 && ((h = l.updateQueue), h !== null))) {
          if (((a = null), l.child !== null))
            switch (l.child.tag) {
              case 27:
              case 5:
                a = l.child.stateNode
                break
              case 1:
                a = l.child.stateNode
            }
          try {
            a_(h, a)
          } catch (q) {
            Jt(l, l.return, q)
          }
        }
        break
      case 26:
        ua(a, l), h & 512 && pc(l, l.return)
        break
      case 27:
      case 5:
        ua(a, l), o === null && h & 4 && u_(l), h & 512 && pc(l, l.return)
        break
      case 12:
        ua(a, l)
        break
      case 13:
        ua(a, l), h & 4 && b_(a, l)
        break
      case 22:
        if (((b = l.memoizedState !== null || oa), !b)) {
          o = (o !== null && o.memoizedState !== null) || Dn
          var _ = oa,
            U = Dn
          ;(oa = b),
            (Dn = o) && !U ? eo(a, l, (l.subtreeFlags & 8772) !== 0) : ua(a, l),
            (oa = _),
            (Dn = U)
        }
        h & 512 && (l.memoizedProps.mode === 'manual' ? pc(l, l.return) : ai(l, l.return))
        break
      default:
        ua(a, l)
    }
  }
  function g_(a) {
    var o = a.alternate
    o !== null && ((a.alternate = null), g_(o)),
      (a.child = null),
      (a.deletions = null),
      (a.sibling = null),
      a.tag === 5 && ((o = a.stateNode), o !== null && Jo(o)),
      (a.stateNode = null),
      (a.return = null),
      (a.dependencies = null),
      (a.memoizedProps = null),
      (a.memoizedState = null),
      (a.pendingProps = null),
      (a.stateNode = null),
      (a.updateQueue = null)
  }
  var Hn = null,
    oi = !1
  function ca(a, o, l) {
    for (l = l.child; l !== null; ) m_(a, o, l), (l = l.sibling)
  }
  function m_(a, o, l) {
    if (mt && typeof mt.onCommitFiberUnmount == 'function')
      try {
        mt.onCommitFiberUnmount(rn, l)
      } catch {}
    switch (l.tag) {
      case 26:
        Dn || ai(l, o),
          ca(a, o, l),
          l.memoizedState
            ? l.memoizedState.count--
            : l.stateNode && ((l = l.stateNode), l.parentNode.removeChild(l))
        break
      case 27:
        Dn || ai(l, o)
        var h = Hn,
          b = oi
        for (Hn = l.stateNode, ca(a, o, l), l = l.stateNode, o = l.attributes; o.length; )
          l.removeAttributeNode(o[0])
        Jo(l), (Hn = h), (oi = b)
        break
      case 5:
        Dn || ai(l, o)
      case 6:
        b = Hn
        var _ = oi
        if (((Hn = null), ca(a, o, l), (Hn = b), (oi = _), Hn !== null))
          if (oi)
            try {
              ;(a = Hn),
                (h = l.stateNode),
                a.nodeType === 8 ? a.parentNode.removeChild(h) : a.removeChild(h)
            } catch (U) {
              Jt(l, o, U)
            }
          else
            try {
              Hn.removeChild(l.stateNode)
            } catch (U) {
              Jt(l, o, U)
            }
        break
      case 18:
        Hn !== null &&
          (oi
            ? ((o = Hn),
              (l = l.stateNode),
              o.nodeType === 8 ? Ky(o.parentNode, l) : o.nodeType === 1 && Ky(o, l),
              xf(o))
            : Ky(Hn, l.stateNode))
        break
      case 4:
        ;(h = Hn),
          (b = oi),
          (Hn = l.stateNode.containerInfo),
          (oi = !0),
          ca(a, o, l),
          (Hn = h),
          (oi = b)
        break
      case 0:
      case 11:
      case 14:
      case 15:
        Dn || Ja(2, l, o), Dn || Ja(4, l, o), ca(a, o, l)
        break
      case 1:
        Dn ||
          (ai(l, o), (h = l.stateNode), typeof h.componentWillUnmount == 'function' && c_(l, o, h)),
          ca(a, o, l)
        break
      case 21:
        ca(a, o, l)
        break
      case 22:
        Dn || ai(l, o), (Dn = (h = Dn) || l.memoizedState !== null), ca(a, o, l), (Dn = h)
        break
      default:
        ca(a, o, l)
    }
  }
  function b_(a, o) {
    if (
      o.memoizedState === null &&
      ((a = o.alternate),
      a !== null && ((a = a.memoizedState), a !== null && ((a = a.dehydrated), a !== null)))
    )
      try {
        xf(a)
      } catch (l) {
        Jt(o, o.return, l)
      }
  }
  function JO(a) {
    switch (a.tag) {
      case 13:
      case 19:
        var o = a.stateNode
        return o === null && (o = a.stateNode = new f_()), o
      case 22:
        return (
          (a = a.stateNode), (o = a._retryCache), o === null && (o = a._retryCache = new f_()), o
        )
      default:
        throw Error(r(435, a.tag))
    }
  }
  function my(a, o) {
    var l = JO(a)
    o.forEach(function (h) {
      var b = fR.bind(null, a, h)
      l.has(h) || (l.add(h), h.then(b, b))
    })
  }
  function Ti(a, o) {
    var l = o.deletions
    if (l !== null)
      for (var h = 0; h < l.length; h++) {
        var b = l[h],
          _ = a,
          U = o,
          q = U
        e: for (; q !== null; ) {
          switch (q.tag) {
            case 27:
            case 5:
              ;(Hn = q.stateNode), (oi = !1)
              break e
            case 3:
              ;(Hn = q.stateNode.containerInfo), (oi = !0)
              break e
            case 4:
              ;(Hn = q.stateNode.containerInfo), (oi = !0)
              break e
          }
          q = q.return
        }
        if (Hn === null) throw Error(r(160))
        m_(_, U, b),
          (Hn = null),
          (oi = !1),
          (_ = b.alternate),
          _ !== null && (_.return = null),
          (b.return = null)
      }
    if (o.subtreeFlags & 13878) for (o = o.child; o !== null; ) y_(o, a), (o = o.sibling)
  }
  var Xi = null
  function y_(a, o) {
    var l = a.alternate,
      h = a.flags
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Ti(o, a), xi(a), h & 4 && (Ja(3, a, a.return), uf(3, a), Ja(5, a, a.return))
        break
      case 1:
        Ti(o, a),
          xi(a),
          h & 512 && (Dn || l === null || ai(l, l.return)),
          h & 64 &&
            oa &&
            ((a = a.updateQueue),
            a !== null &&
              ((h = a.callbacks),
              h !== null &&
                ((l = a.shared.hiddenCallbacks),
                (a.shared.hiddenCallbacks = l === null ? h : l.concat(h)))))
        break
      case 26:
        var b = Xi
        if ((Ti(o, a), xi(a), h & 512 && (Dn || l === null || ai(l, l.return)), h & 4)) {
          var _ = l !== null ? l.memoizedState : null
          if (((h = a.memoizedState), l === null))
            if (h === null)
              if (a.stateNode === null) {
                e: {
                  ;(h = a.type), (l = a.memoizedProps), (b = b.ownerDocument || b)
                  t: switch (h) {
                    case 'title':
                      ;(_ = b.getElementsByTagName('title')[0]),
                        (!_ ||
                          _[Zs] ||
                          _[st] ||
                          _.namespaceURI === 'http://www.w3.org/2000/svg' ||
                          _.hasAttribute('itemprop')) &&
                          ((_ = b.createElement(h)),
                          b.head.insertBefore(_, b.querySelector('head > title'))),
                        pr(_, h, l),
                        (_[st] = a),
                        Rn(_),
                        (h = _)
                      break e
                    case 'link':
                      var U = uC('link', 'href', b).get(h + (l.href || ''))
                      if (U) {
                        for (var q = 0; q < U.length; q++)
                          if (
                            ((_ = U[q]),
                            _.getAttribute('href') === (l.href == null ? null : l.href) &&
                              _.getAttribute('rel') === (l.rel == null ? null : l.rel) &&
                              _.getAttribute('title') === (l.title == null ? null : l.title) &&
                              _.getAttribute('crossorigin') ===
                                (l.crossOrigin == null ? null : l.crossOrigin))
                          ) {
                            U.splice(q, 1)
                            break t
                          }
                      }
                      ;(_ = b.createElement(h)), pr(_, h, l), b.head.appendChild(_)
                      break
                    case 'meta':
                      if ((U = uC('meta', 'content', b).get(h + (l.content || '')))) {
                        for (q = 0; q < U.length; q++)
                          if (
                            ((_ = U[q]),
                            _.getAttribute('content') ===
                              (l.content == null ? null : '' + l.content) &&
                              _.getAttribute('name') === (l.name == null ? null : l.name) &&
                              _.getAttribute('property') ===
                                (l.property == null ? null : l.property) &&
                              _.getAttribute('http-equiv') ===
                                (l.httpEquiv == null ? null : l.httpEquiv) &&
                              _.getAttribute('charset') === (l.charSet == null ? null : l.charSet))
                          ) {
                            U.splice(q, 1)
                            break t
                          }
                      }
                      ;(_ = b.createElement(h)), pr(_, h, l), b.head.appendChild(_)
                      break
                    default:
                      throw Error(r(468, h))
                  }
                  ;(_[st] = a), Rn(_), (h = _)
                }
                a.stateNode = h
              } else lC(b, a.type, a.stateNode)
            else a.stateNode = cC(b, h, a.memoizedProps)
          else
            _ !== h
              ? (_ === null
                  ? l.stateNode !== null && ((l = l.stateNode), l.parentNode.removeChild(l))
                  : _.count--,
                h === null ? lC(b, a.type, a.stateNode) : cC(b, h, a.memoizedProps))
              : h === null && a.stateNode !== null && l_(a, a.memoizedProps, l.memoizedProps)
        }
        break
      case 27:
        if (h & 4 && a.alternate === null) {
          ;(b = a.stateNode), (_ = a.memoizedProps)
          try {
            for (var K = b.firstChild; K; ) {
              var J = K.nextSibling,
                oe = K.nodeName
              K[Zs] ||
                oe === 'HEAD' ||
                oe === 'BODY' ||
                oe === 'SCRIPT' ||
                oe === 'STYLE' ||
                (oe === 'LINK' && K.rel.toLowerCase() === 'stylesheet') ||
                b.removeChild(K),
                (K = J)
            }
            for (var le = a.type, ie = b.attributes; ie.length; ) b.removeAttributeNode(ie[0])
            pr(b, le, _), (b[st] = a), (b[dr] = _)
          } catch (Pe) {
            Jt(a, a.return, Pe)
          }
        }
      case 5:
        if ((Ti(o, a), xi(a), h & 512 && (Dn || l === null || ai(l, l.return)), a.flags & 32)) {
          b = a.stateNode
          try {
            Ou(b, '')
          } catch (Pe) {
            Jt(a, a.return, Pe)
          }
        }
        h & 4 &&
          a.stateNode != null &&
          ((b = a.memoizedProps), l_(a, b, l !== null ? l.memoizedProps : b)),
          h & 1024 && (gy = !0)
        break
      case 6:
        if ((Ti(o, a), xi(a), h & 4)) {
          if (a.stateNode === null) throw Error(r(162))
          ;(h = a.memoizedProps), (l = a.stateNode)
          try {
            l.nodeValue = h
          } catch (Pe) {
            Jt(a, a.return, Pe)
          }
        }
        break
      case 3:
        if (
          ((L0 = null),
          (b = Xi),
          (Xi = U0(o.containerInfo)),
          Ti(o, a),
          (Xi = b),
          xi(a),
          h & 4 && l !== null && l.memoizedState.isDehydrated)
        )
          try {
            xf(o.containerInfo)
          } catch (Pe) {
            Jt(a, a.return, Pe)
          }
        gy && ((gy = !1), v_(a))
        break
      case 4:
        ;(h = Xi), (Xi = U0(a.stateNode.containerInfo)), Ti(o, a), xi(a), (Xi = h)
        break
      case 12:
        Ti(o, a), xi(a)
        break
      case 13:
        Ti(o, a),
          xi(a),
          a.child.flags & 8192 &&
            (a.memoizedState !== null) != (l !== null && l.memoizedState !== null) &&
            (Sy = Je()),
          h & 4 && ((h = a.updateQueue), h !== null && ((a.updateQueue = null), my(a, h)))
        break
      case 22:
        if (
          (h & 512 && (Dn || l === null || ai(l, l.return)),
          (K = a.memoizedState !== null),
          (J = l !== null && l.memoizedState !== null),
          (oe = oa),
          (le = Dn),
          (oa = oe || K),
          (Dn = le || J),
          Ti(o, a),
          (Dn = le),
          (oa = oe),
          xi(a),
          (o = a.stateNode),
          (o._current = a),
          (o._visibility &= -3),
          (o._visibility |= o._pendingVisibility & 2),
          h & 8192 &&
            ((o._visibility = K ? o._visibility & -2 : o._visibility | 1),
            K && ((o = oa || Dn), l === null || J || o || Ku(a)),
            a.memoizedProps === null || a.memoizedProps.mode !== 'manual'))
        )
          e: for (l = null, o = a; ; ) {
            if (o.tag === 5 || o.tag === 26 || o.tag === 27) {
              if (l === null) {
                J = l = o
                try {
                  if (((b = J.stateNode), K))
                    (_ = b.style),
                      typeof _.setProperty == 'function'
                        ? _.setProperty('display', 'none', 'important')
                        : (_.display = 'none')
                  else {
                    ;(U = J.stateNode), (q = J.memoizedProps.style)
                    var ae = q != null && q.hasOwnProperty('display') ? q.display : null
                    U.style.display = ae == null || typeof ae == 'boolean' ? '' : ('' + ae).trim()
                  }
                } catch (Pe) {
                  Jt(J, J.return, Pe)
                }
              }
            } else if (o.tag === 6) {
              if (l === null) {
                J = o
                try {
                  J.stateNode.nodeValue = K ? '' : J.memoizedProps
                } catch (Pe) {
                  Jt(J, J.return, Pe)
                }
              }
            } else if (
              ((o.tag !== 22 && o.tag !== 23) || o.memoizedState === null || o === a) &&
              o.child !== null
            ) {
              ;(o.child.return = o), (o = o.child)
              continue
            }
            if (o === a) break e
            for (; o.sibling === null; ) {
              if (o.return === null || o.return === a) break e
              l === o && (l = null), (o = o.return)
            }
            l === o && (l = null), (o.sibling.return = o.return), (o = o.sibling)
          }
        h & 4 &&
          ((h = a.updateQueue),
          h !== null && ((l = h.retryQueue), l !== null && ((h.retryQueue = null), my(a, l))))
        break
      case 19:
        Ti(o, a),
          xi(a),
          h & 4 && ((h = a.updateQueue), h !== null && ((a.updateQueue = null), my(a, h)))
        break
      case 21:
        break
      default:
        Ti(o, a), xi(a)
    }
  }
  function xi(a) {
    var o = a.flags
    if (o & 2) {
      try {
        if (a.tag !== 27) {
          e: {
            for (var l = a.return; l !== null; ) {
              if (d_(l)) {
                var h = l
                break e
              }
              l = l.return
            }
            throw Error(r(160))
          }
          switch (h.tag) {
            case 27:
              var b = h.stateNode,
                _ = hy(a)
              E0(a, _, b)
              break
            case 5:
              var U = h.stateNode
              h.flags & 32 && (Ou(U, ''), (h.flags &= -33))
              var q = hy(a)
              E0(a, q, U)
              break
            case 3:
            case 4:
              var K = h.stateNode.containerInfo,
                J = hy(a)
              py(a, J, K)
              break
            default:
              throw Error(r(161))
          }
        }
      } catch (oe) {
        Jt(a, a.return, oe)
      }
      a.flags &= -3
    }
    o & 4096 && (a.flags &= -4097)
  }
  function v_(a) {
    if (a.subtreeFlags & 1024)
      for (a = a.child; a !== null; ) {
        var o = a
        v_(o), o.tag === 5 && o.flags & 1024 && o.stateNode.reset(), (a = a.sibling)
      }
  }
  function ua(a, o) {
    if (o.subtreeFlags & 8772)
      for (o = o.child; o !== null; ) p_(a, o.alternate, o), (o = o.sibling)
  }
  function Ku(a) {
    for (a = a.child; a !== null; ) {
      var o = a
      switch (o.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ja(4, o, o.return), Ku(o)
          break
        case 1:
          ai(o, o.return)
          var l = o.stateNode
          typeof l.componentWillUnmount == 'function' && c_(o, o.return, l), Ku(o)
          break
        case 26:
        case 27:
        case 5:
          ai(o, o.return), Ku(o)
          break
        case 22:
          ai(o, o.return), o.memoizedState === null && Ku(o)
          break
        default:
          Ku(o)
      }
      a = a.sibling
    }
  }
  function eo(a, o, l) {
    for (l = l && (o.subtreeFlags & 8772) !== 0, o = o.child; o !== null; ) {
      var h = o.alternate,
        b = a,
        _ = o,
        U = _.flags
      switch (_.tag) {
        case 0:
        case 11:
        case 15:
          eo(b, _, l), uf(4, _)
          break
        case 1:
          if ((eo(b, _, l), (h = _), (b = h.stateNode), typeof b.componentDidMount == 'function'))
            try {
              b.componentDidMount()
            } catch (J) {
              Jt(h, h.return, J)
            }
          if (((h = _), (b = h.updateQueue), b !== null)) {
            var q = h.stateNode
            try {
              var K = b.shared.hiddenCallbacks
              if (K !== null)
                for (b.shared.hiddenCallbacks = null, b = 0; b < K.length; b++) s_(K[b], q)
            } catch (J) {
              Jt(h, h.return, J)
            }
          }
          l && U & 64 && o_(_), pc(_, _.return)
          break
        case 26:
        case 27:
        case 5:
          eo(b, _, l), l && h === null && U & 4 && u_(_), pc(_, _.return)
          break
        case 12:
          eo(b, _, l)
          break
        case 13:
          eo(b, _, l), l && U & 4 && b_(b, _)
          break
        case 22:
          _.memoizedState === null && eo(b, _, l), pc(_, _.return)
          break
        default:
          eo(b, _, l)
      }
      o = o.sibling
    }
  }
  function by(a, o) {
    var l = null
    a !== null &&
      a.memoizedState !== null &&
      a.memoizedState.cachePool !== null &&
      (l = a.memoizedState.cachePool.pool),
      (a = null),
      o.memoizedState !== null &&
        o.memoizedState.cachePool !== null &&
        (a = o.memoizedState.cachePool.pool),
      a !== l && (a != null && a.refCount++, l != null && Xd(l))
  }
  function yy(a, o) {
    ;(a = null),
      o.alternate !== null && (a = o.alternate.memoizedState.cache),
      (o = o.memoizedState.cache),
      o !== a && (o.refCount++, a != null && Xd(a))
  }
  function to(a, o, l, h) {
    if (o.subtreeFlags & 10256) for (o = o.child; o !== null; ) w_(a, o, l, h), (o = o.sibling)
  }
  function w_(a, o, l, h) {
    var b = o.flags
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        to(a, o, l, h), b & 2048 && uf(9, o)
        break
      case 3:
        to(a, o, l, h),
          b & 2048 &&
            ((a = null),
            o.alternate !== null && (a = o.alternate.memoizedState.cache),
            (o = o.memoizedState.cache),
            o !== a && (o.refCount++, a != null && Xd(a)))
        break
      case 12:
        if (b & 2048) {
          to(a, o, l, h), (a = o.stateNode)
          try {
            var _ = o.memoizedProps,
              U = _.id,
              q = _.onPostCommit
            typeof q == 'function' &&
              q(U, o.alternate === null ? 'mount' : 'update', a.passiveEffectDuration, -0)
          } catch (K) {
            Jt(o, o.return, K)
          }
        } else to(a, o, l, h)
        break
      case 23:
        break
      case 22:
        ;(_ = o.stateNode),
          o.memoizedState !== null
            ? _._visibility & 4
              ? to(a, o, l, h)
              : lf(a, o)
            : _._visibility & 4
              ? to(a, o, l, h)
              : ((_._visibility |= 4), Wu(a, o, l, h, (o.subtreeFlags & 10256) !== 0)),
          b & 2048 && by(o.alternate, o)
        break
      case 24:
        to(a, o, l, h), b & 2048 && yy(o.alternate, o)
        break
      default:
        to(a, o, l, h)
    }
  }
  function Wu(a, o, l, h, b) {
    for (b = b && (o.subtreeFlags & 10256) !== 0, o = o.child; o !== null; ) {
      var _ = a,
        U = o,
        q = l,
        K = h,
        J = U.flags
      switch (U.tag) {
        case 0:
        case 11:
        case 15:
          Wu(_, U, q, K, b), uf(8, U)
          break
        case 23:
          break
        case 22:
          var oe = U.stateNode
          U.memoizedState !== null
            ? oe._visibility & 4
              ? Wu(_, U, q, K, b)
              : lf(_, U)
            : ((oe._visibility |= 4), Wu(_, U, q, K, b)),
            b && J & 2048 && by(U.alternate, U)
          break
        case 24:
          Wu(_, U, q, K, b), b && J & 2048 && yy(U.alternate, U)
          break
        default:
          Wu(_, U, q, K, b)
      }
      o = o.sibling
    }
  }
  function lf(a, o) {
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; ) {
        var l = a,
          h = o,
          b = h.flags
        switch (h.tag) {
          case 22:
            lf(l, h), b & 2048 && by(h.alternate, h)
            break
          case 24:
            lf(l, h), b & 2048 && yy(h.alternate, h)
            break
          default:
            lf(l, h)
        }
        o = o.sibling
      }
  }
  var df = 8192
  function Qu(a) {
    if (a.subtreeFlags & df) for (a = a.child; a !== null; ) E_(a), (a = a.sibling)
  }
  function E_(a) {
    switch (a.tag) {
      case 26:
        Qu(a), a.flags & df && a.memoizedState !== null && jR(Xi, a.memoizedState, a.memoizedProps)
        break
      case 5:
        Qu(a)
        break
      case 3:
      case 4:
        var o = Xi
        ;(Xi = U0(a.stateNode.containerInfo)), Qu(a), (Xi = o)
        break
      case 22:
        a.memoizedState === null &&
          ((o = a.alternate),
          o !== null && o.memoizedState !== null
            ? ((o = df), (df = 16777216), Qu(a), (df = o))
            : Qu(a))
        break
      default:
        Qu(a)
    }
  }
  function A_(a) {
    var o = a.alternate
    if (o !== null && ((a = o.child), a !== null)) {
      o.child = null
      do (o = a.sibling), (a.sibling = null), (a = o)
      while (a !== null)
    }
  }
  function ff(a) {
    var o = a.deletions
    if ((a.flags & 16) !== 0) {
      if (o !== null)
        for (var l = 0; l < o.length; l++) {
          var h = o[l]
          ;(nr = h), C_(h, a)
        }
      A_(a)
    }
    if (a.subtreeFlags & 10256) for (a = a.child; a !== null; ) __(a), (a = a.sibling)
  }
  function __(a) {
    switch (a.tag) {
      case 0:
      case 11:
      case 15:
        ff(a), a.flags & 2048 && Ja(9, a, a.return)
        break
      case 3:
        ff(a)
        break
      case 12:
        ff(a)
        break
      case 22:
        var o = a.stateNode
        a.memoizedState !== null && o._visibility & 4 && (a.return === null || a.return.tag !== 13)
          ? ((o._visibility &= -5), A0(a))
          : ff(a)
        break
      default:
        ff(a)
    }
  }
  function A0(a) {
    var o = a.deletions
    if ((a.flags & 16) !== 0) {
      if (o !== null)
        for (var l = 0; l < o.length; l++) {
          var h = o[l]
          ;(nr = h), C_(h, a)
        }
      A_(a)
    }
    for (a = a.child; a !== null; ) {
      switch (((o = a), o.tag)) {
        case 0:
        case 11:
        case 15:
          Ja(8, o, o.return), A0(o)
          break
        case 22:
          ;(l = o.stateNode), l._visibility & 4 && ((l._visibility &= -5), A0(o))
          break
        default:
          A0(o)
      }
      a = a.sibling
    }
  }
  function C_(a, o) {
    for (; nr !== null; ) {
      var l = nr
      switch (l.tag) {
        case 0:
        case 11:
        case 15:
          Ja(8, l, o)
          break
        case 23:
        case 22:
          if (l.memoizedState !== null && l.memoizedState.cachePool !== null) {
            var h = l.memoizedState.cachePool.pool
            h != null && h.refCount++
          }
          break
        case 24:
          Xd(l.memoizedState.cache)
      }
      if (((h = l.child), h !== null)) (h.return = l), (nr = h)
      else
        e: for (l = a; nr !== null; ) {
          h = nr
          var b = h.sibling,
            _ = h.return
          if ((g_(h), h === l)) {
            nr = null
            break e
          }
          if (b !== null) {
            ;(b.return = _), (nr = b)
            break e
          }
          nr = _
        }
    }
  }
  function eR(a, o, l, h) {
    ;(this.tag = a),
      (this.key = l),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.refCleanup = this.ref = null),
      (this.pendingProps = o),
      (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
      (this.mode = h),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null)
  }
  function Ni(a, o, l, h) {
    return new eR(a, o, l, h)
  }
  function vy(a) {
    return (a = a.prototype), !(!a || !a.isReactComponent)
  }
  function no(a, o) {
    var l = a.alternate
    return (
      l === null
        ? ((l = Ni(a.tag, o, a.key, a.mode)),
          (l.elementType = a.elementType),
          (l.type = a.type),
          (l.stateNode = a.stateNode),
          (l.alternate = a),
          (a.alternate = l))
        : ((l.pendingProps = o),
          (l.type = a.type),
          (l.flags = 0),
          (l.subtreeFlags = 0),
          (l.deletions = null)),
      (l.flags = a.flags & 31457280),
      (l.childLanes = a.childLanes),
      (l.lanes = a.lanes),
      (l.child = a.child),
      (l.memoizedProps = a.memoizedProps),
      (l.memoizedState = a.memoizedState),
      (l.updateQueue = a.updateQueue),
      (o = a.dependencies),
      (l.dependencies = o === null ? null : { lanes: o.lanes, firstContext: o.firstContext }),
      (l.sibling = a.sibling),
      (l.index = a.index),
      (l.ref = a.ref),
      (l.refCleanup = a.refCleanup),
      l
    )
  }
  function S_(a, o) {
    a.flags &= 31457282
    var l = a.alternate
    return (
      l === null
        ? ((a.childLanes = 0),
          (a.lanes = o),
          (a.child = null),
          (a.subtreeFlags = 0),
          (a.memoizedProps = null),
          (a.memoizedState = null),
          (a.updateQueue = null),
          (a.dependencies = null),
          (a.stateNode = null))
        : ((a.childLanes = l.childLanes),
          (a.lanes = l.lanes),
          (a.child = l.child),
          (a.subtreeFlags = 0),
          (a.deletions = null),
          (a.memoizedProps = l.memoizedProps),
          (a.memoizedState = l.memoizedState),
          (a.updateQueue = l.updateQueue),
          (a.type = l.type),
          (o = l.dependencies),
          (a.dependencies = o === null ? null : { lanes: o.lanes, firstContext: o.firstContext })),
      a
    )
  }
  function _0(a, o, l, h, b, _) {
    var U = 0
    if (((h = a), typeof a == 'function')) vy(a) && (U = 1)
    else if (typeof a == 'string')
      U = $R(a, l, kt.current) ? 26 : a === 'html' || a === 'head' || a === 'body' ? 27 : 5
    else
      e: switch (a) {
        case f:
          return gc(l.children, b, _, o)
        case d:
          ;(U = 8), (b |= 24)
          break
        case p:
          return (a = Ni(12, l, o, b | 2)), (a.elementType = p), (a.lanes = _), a
        case E:
          return (a = Ni(13, l, o, b)), (a.elementType = E), (a.lanes = _), a
        case x:
          return (a = Ni(19, l, o, b)), (a.elementType = x), (a.lanes = _), a
        case M:
          return T_(l, b, _, o)
        default:
          if (typeof a == 'object' && a !== null)
            switch (a.$$typeof) {
              case g:
              case y:
                U = 10
                break e
              case m:
                U = 9
                break e
              case A:
                U = 11
                break e
              case O:
                U = 14
                break e
              case I:
                ;(U = 16), (h = null)
                break e
            }
          ;(U = 29), (l = Error(r(130, a === null ? 'null' : typeof a, ''))), (h = null)
      }
    return (o = Ni(U, l, o, b)), (o.elementType = a), (o.type = h), (o.lanes = _), o
  }
  function gc(a, o, l, h) {
    return (a = Ni(7, a, h, o)), (a.lanes = l), a
  }
  function T_(a, o, l, h) {
    ;(a = Ni(22, a, h, o)), (a.elementType = M), (a.lanes = l)
    var b = {
      _visibility: 1,
      _pendingVisibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null,
      _current: null,
      detach: function () {
        var _ = b._current
        if (_ === null) throw Error(r(456))
        if ((b._pendingVisibility & 2) === 0) {
          var U = Ha(_, 2)
          U !== null && ((b._pendingVisibility |= 2), kr(U, _, 2))
        }
      },
      attach: function () {
        var _ = b._current
        if (_ === null) throw Error(r(456))
        if ((b._pendingVisibility & 2) !== 0) {
          var U = Ha(_, 2)
          U !== null && ((b._pendingVisibility &= -3), kr(U, _, 2))
        }
      }
    }
    return (a.stateNode = b), a
  }
  function wy(a, o, l) {
    return (a = Ni(6, a, null, o)), (a.lanes = l), a
  }
  function Ey(a, o, l) {
    return (
      (o = Ni(4, a.children !== null ? a.children : [], a.key, o)),
      (o.lanes = l),
      (o.stateNode = {
        containerInfo: a.containerInfo,
        pendingChildren: null,
        implementation: a.implementation
      }),
      o
    )
  }
  function la(a) {
    a.flags |= 4
  }
  function x_(a, o) {
    if (o.type !== 'stylesheet' || (o.state.loading & 4) !== 0) a.flags &= -16777217
    else if (((a.flags |= 16777216), !dC(o))) {
      if (
        ((o = Si.current),
        o !== null &&
          ((yt & 4194176) === yt
            ? Es !== null
            : ((yt & 62914560) !== yt && (yt & 536870912) === 0) || o !== Es))
      )
        throw ((Qd = Tb), HA)
      a.flags |= 8192
    }
  }
  function C0(a, o) {
    o !== null && (a.flags |= 4),
      a.flags & 16384 && ((o = a.tag !== 22 ? vn() : 536870912), (a.lanes |= o), (Zu |= o))
  }
  function hf(a, o) {
    if (!Et)
      switch (a.tailMode) {
        case 'hidden':
          o = a.tail
          for (var l = null; o !== null; ) o.alternate !== null && (l = o), (o = o.sibling)
          l === null ? (a.tail = null) : (l.sibling = null)
          break
        case 'collapsed':
          l = a.tail
          for (var h = null; l !== null; ) l.alternate !== null && (h = l), (l = l.sibling)
          h === null
            ? o || a.tail === null
              ? (a.tail = null)
              : (a.tail.sibling = null)
            : (h.sibling = null)
      }
  }
  function _n(a) {
    var o = a.alternate !== null && a.alternate.child === a.child,
      l = 0,
      h = 0
    if (o)
      for (var b = a.child; b !== null; )
        (l |= b.lanes | b.childLanes),
          (h |= b.subtreeFlags & 31457280),
          (h |= b.flags & 31457280),
          (b.return = a),
          (b = b.sibling)
    else
      for (b = a.child; b !== null; )
        (l |= b.lanes | b.childLanes),
          (h |= b.subtreeFlags),
          (h |= b.flags),
          (b.return = a),
          (b = b.sibling)
    return (a.subtreeFlags |= h), (a.childLanes = l), o
  }
  function tR(a, o, l) {
    var h = o.pendingProps
    switch ((Cb(o), o.tag)) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return _n(o), null
      case 1:
        return _n(o), null
      case 3:
        return (
          (l = o.stateNode),
          (h = null),
          a !== null && (h = a.memoizedState.cache),
          o.memoizedState.cache !== h && (o.flags |= 2048),
          aa(Qn),
          lt(),
          l.pendingContext && ((l.context = l.pendingContext), (l.pendingContext = null)),
          (a === null || a.child === null) &&
            (Gd(o)
              ? la(o)
              : a === null ||
                (a.memoizedState.isDehydrated && (o.flags & 256) === 0) ||
                ((o.flags |= 1024), Zi !== null && (Iy(Zi), (Zi = null)))),
          _n(o),
          null
        )
      case 26:
        return (
          (l = o.memoizedState),
          a === null
            ? (la(o), l !== null ? (_n(o), x_(o, l)) : (_n(o), (o.flags &= -16777217)))
            : l
              ? l !== a.memoizedState
                ? (la(o), _n(o), x_(o, l))
                : (_n(o), (o.flags &= -16777217))
              : (a.memoizedProps !== h && la(o), _n(o), (o.flags &= -16777217)),
          null
        )
      case 27:
        It(o), (l = Ke.current)
        var b = o.type
        if (a !== null && o.stateNode != null) a.memoizedProps !== h && la(o)
        else {
          if (!h) {
            if (o.stateNode === null) throw Error(r(166))
            return _n(o), null
          }
          ;(a = kt.current), Gd(o) ? zA(o) : ((a = rC(b, h, l)), (o.stateNode = a), la(o))
        }
        return _n(o), null
      case 5:
        if ((It(o), (l = o.type), a !== null && o.stateNode != null)) a.memoizedProps !== h && la(o)
        else {
          if (!h) {
            if (o.stateNode === null) throw Error(r(166))
            return _n(o), null
          }
          if (((a = kt.current), Gd(o))) zA(o)
          else {
            switch (((b = k0(Ke.current)), a)) {
              case 1:
                a = b.createElementNS('http://www.w3.org/2000/svg', l)
                break
              case 2:
                a = b.createElementNS('http://www.w3.org/1998/Math/MathML', l)
                break
              default:
                switch (l) {
                  case 'svg':
                    a = b.createElementNS('http://www.w3.org/2000/svg', l)
                    break
                  case 'math':
                    a = b.createElementNS('http://www.w3.org/1998/Math/MathML', l)
                    break
                  case 'script':
                    ;(a = b.createElement('div')),
                      (a.innerHTML = '<script><\/script>'),
                      (a = a.removeChild(a.firstChild))
                    break
                  case 'select':
                    ;(a =
                      typeof h.is == 'string'
                        ? b.createElement('select', { is: h.is })
                        : b.createElement('select')),
                      h.multiple ? (a.multiple = !0) : h.size && (a.size = h.size)
                    break
                  default:
                    a =
                      typeof h.is == 'string'
                        ? b.createElement(l, { is: h.is })
                        : b.createElement(l)
                }
            }
            ;(a[st] = o), (a[dr] = h)
            e: for (b = o.child; b !== null; ) {
              if (b.tag === 5 || b.tag === 6) a.appendChild(b.stateNode)
              else if (b.tag !== 4 && b.tag !== 27 && b.child !== null) {
                ;(b.child.return = b), (b = b.child)
                continue
              }
              if (b === o) break e
              for (; b.sibling === null; ) {
                if (b.return === null || b.return === o) break e
                b = b.return
              }
              ;(b.sibling.return = b.return), (b = b.sibling)
            }
            o.stateNode = a
            e: switch ((pr(a, l, h), l)) {
              case 'button':
              case 'input':
              case 'select':
              case 'textarea':
                a = !!h.autoFocus
                break e
              case 'img':
                a = !0
                break e
              default:
                a = !1
            }
            a && la(o)
          }
        }
        return _n(o), (o.flags &= -16777217), null
      case 6:
        if (a && o.stateNode != null) a.memoizedProps !== h && la(o)
        else {
          if (typeof h != 'string' && o.stateNode === null) throw Error(r(166))
          if (((a = Ke.current), Gd(o))) {
            if (((a = o.stateNode), (l = o.memoizedProps), (h = null), (b = Mr), b !== null))
              switch (b.tag) {
                case 27:
                case 5:
                  h = b.memoizedProps
              }
            ;(a[st] = o),
              (a = !!(
                a.nodeValue === l ||
                (h !== null && h.suppressHydrationWarning === !0) ||
                Z_(a.nodeValue, l)
              )),
              a || sc(o)
          } else (a = k0(a).createTextNode(h)), (a[st] = o), (o.stateNode = a)
        }
        return _n(o), null
      case 13:
        if (
          ((h = o.memoizedState),
          a === null || (a.memoizedState !== null && a.memoizedState.dehydrated !== null))
        ) {
          if (((b = Gd(o)), h !== null && h.dehydrated !== null)) {
            if (a === null) {
              if (!b) throw Error(r(318))
              if (((b = o.memoizedState), (b = b !== null ? b.dehydrated : null), !b))
                throw Error(r(317))
              b[st] = o
            } else Vd(), (o.flags & 128) === 0 && (o.memoizedState = null), (o.flags |= 4)
            _n(o), (b = !1)
          } else Zi !== null && (Iy(Zi), (Zi = null)), (b = !0)
          if (!b) return o.flags & 256 ? (na(o), o) : (na(o), null)
        }
        if ((na(o), (o.flags & 128) !== 0)) return (o.lanes = l), o
        if (((l = h !== null), (a = a !== null && a.memoizedState !== null), l)) {
          ;(h = o.child),
            (b = null),
            h.alternate !== null &&
              h.alternate.memoizedState !== null &&
              h.alternate.memoizedState.cachePool !== null &&
              (b = h.alternate.memoizedState.cachePool.pool)
          var _ = null
          h.memoizedState !== null &&
            h.memoizedState.cachePool !== null &&
            (_ = h.memoizedState.cachePool.pool),
            _ !== b && (h.flags |= 2048)
        }
        return l !== a && l && (o.child.flags |= 8192), C0(o, o.updateQueue), _n(o), null
      case 4:
        return lt(), a === null && Fy(o.stateNode.containerInfo), _n(o), null
      case 10:
        return aa(o.type), _n(o), null
      case 19:
        if ((ye(Wn), (b = o.memoizedState), b === null)) return _n(o), null
        if (((h = (o.flags & 128) !== 0), (_ = b.rendering), _ === null))
          if (h) hf(b, !1)
          else {
            if (Pn !== 0 || (a !== null && (a.flags & 128) !== 0))
              for (a = o.child; a !== null; ) {
                if (((_ = o0(a)), _ !== null)) {
                  for (
                    o.flags |= 128,
                      hf(b, !1),
                      a = _.updateQueue,
                      o.updateQueue = a,
                      C0(o, a),
                      o.subtreeFlags = 0,
                      a = l,
                      l = o.child;
                    l !== null;

                  )
                    S_(l, a), (l = l.sibling)
                  return Ce(Wn, (Wn.current & 1) | 2), o.child
                }
                a = a.sibling
              }
            b.tail !== null &&
              Je() > S0 &&
              ((o.flags |= 128), (h = !0), hf(b, !1), (o.lanes = 4194304))
          }
        else {
          if (!h)
            if (((a = o0(_)), a !== null)) {
              if (
                ((o.flags |= 128),
                (h = !0),
                (a = a.updateQueue),
                (o.updateQueue = a),
                C0(o, a),
                hf(b, !0),
                b.tail === null && b.tailMode === 'hidden' && !_.alternate && !Et)
              )
                return _n(o), null
            } else
              2 * Je() - b.renderingStartTime > S0 &&
                l !== 536870912 &&
                ((o.flags |= 128), (h = !0), hf(b, !1), (o.lanes = 4194304))
          b.isBackwards
            ? ((_.sibling = o.child), (o.child = _))
            : ((a = b.last), a !== null ? (a.sibling = _) : (o.child = _), (b.last = _))
        }
        return b.tail !== null
          ? ((o = b.tail),
            (b.rendering = o),
            (b.tail = o.sibling),
            (b.renderingStartTime = Je()),
            (o.sibling = null),
            (a = Wn.current),
            Ce(Wn, h ? (a & 1) | 2 : a & 1),
            o)
          : (_n(o), null)
      case 22:
      case 23:
        return (
          na(o),
          Nb(),
          (h = o.memoizedState !== null),
          a !== null
            ? (a.memoizedState !== null) !== h && (o.flags |= 8192)
            : h && (o.flags |= 8192),
          h
            ? (l & 536870912) !== 0 &&
              (o.flags & 128) === 0 &&
              (_n(o), o.subtreeFlags & 6 && (o.flags |= 8192))
            : _n(o),
          (l = o.updateQueue),
          l !== null && C0(o, l.retryQueue),
          (l = null),
          a !== null &&
            a.memoizedState !== null &&
            a.memoizedState.cachePool !== null &&
            (l = a.memoizedState.cachePool.pool),
          (h = null),
          o.memoizedState !== null &&
            o.memoizedState.cachePool !== null &&
            (h = o.memoizedState.cachePool.pool),
          h !== l && (o.flags |= 2048),
          a !== null && ye(oc),
          null
        )
      case 24:
        return (
          (l = null),
          a !== null && (l = a.memoizedState.cache),
          o.memoizedState.cache !== l && (o.flags |= 2048),
          aa(Qn),
          _n(o),
          null
        )
      case 25:
        return null
    }
    throw Error(r(156, o.tag))
  }
  function nR(a, o) {
    switch ((Cb(o), o.tag)) {
      case 1:
        return (a = o.flags), a & 65536 ? ((o.flags = (a & -65537) | 128), o) : null
      case 3:
        return (
          aa(Qn),
          lt(),
          (a = o.flags),
          (a & 65536) !== 0 && (a & 128) === 0 ? ((o.flags = (a & -65537) | 128), o) : null
        )
      case 26:
      case 27:
      case 5:
        return It(o), null
      case 13:
        if ((na(o), (a = o.memoizedState), a !== null && a.dehydrated !== null)) {
          if (o.alternate === null) throw Error(r(340))
          Vd()
        }
        return (a = o.flags), a & 65536 ? ((o.flags = (a & -65537) | 128), o) : null
      case 19:
        return ye(Wn), null
      case 4:
        return lt(), null
      case 10:
        return aa(o.type), null
      case 22:
      case 23:
        return (
          na(o),
          Nb(),
          a !== null && ye(oc),
          (a = o.flags),
          a & 65536 ? ((o.flags = (a & -65537) | 128), o) : null
        )
      case 24:
        return aa(Qn), null
      case 25:
        return null
      default:
        return null
    }
  }
  function N_(a, o) {
    switch ((Cb(o), o.tag)) {
      case 3:
        aa(Qn), lt()
        break
      case 26:
      case 27:
      case 5:
        It(o)
        break
      case 4:
        lt()
        break
      case 13:
        na(o)
        break
      case 19:
        ye(Wn)
        break
      case 10:
        aa(o.type)
        break
      case 22:
      case 23:
        na(o), Nb(), a !== null && ye(oc)
        break
      case 24:
        aa(Qn)
    }
  }
  var rR = {
      getCacheForType: function (a) {
        var o = Cr(Qn),
          l = o.data.get(a)
        return l === void 0 && ((l = a()), o.data.set(a, l)), l
      }
    },
    iR = typeof WeakMap == 'function' ? WeakMap : Map,
    Cn = 0,
    an = null,
    at = null,
    yt = 0,
    on = 0,
    ci = null,
    da = !1,
    Yu = !1,
    Ay = !1,
    fa = 0,
    Pn = 0,
    ro = 0,
    mc = 0,
    _y = 0,
    Ii = 0,
    Zu = 0,
    pf = null,
    _s = null,
    Cy = !1,
    Sy = 0,
    S0 = 1 / 0,
    T0 = null,
    io = null,
    x0 = !1,
    bc = null,
    gf = 0,
    Ty = 0,
    xy = null,
    mf = 0,
    Ny = null
  function ui() {
    if ((Cn & 2) !== 0 && yt !== 0) return yt & -yt
    if (j.T !== null) {
      var a = zu
      return a !== 0 ? a : Uy()
    }
    return An()
  }
  function I_() {
    Ii === 0 && (Ii = (yt & 536870912) === 0 || Et ? Od() : 536870912)
    var a = Si.current
    return a !== null && (a.flags |= 32), Ii
  }
  function kr(a, o, l) {
    ;((a === an && on === 2) || a.cancelPendingCommit !== null) && (Xu(a, 0), ha(a, yt, Ii, !1)),
      za(a, l),
      ((Cn & 2) === 0 || a !== an) &&
        (a === an && ((Cn & 2) === 0 && (mc |= l), Pn === 4 && ha(a, yt, Ii, !1)), Cs(a))
  }
  function O_(a, o, l) {
    if ((Cn & 6) !== 0) throw Error(r(327))
    var h = (!l && (o & 60) === 0 && (o & a.expiredLanes) === 0) || sn(a, o),
      b = h ? oR(a, o) : Dy(a, o, !0),
      _ = h
    do {
      if (b === 0) {
        Yu && !h && ha(a, o, 0, !1)
        break
      } else if (b === 6) ha(a, o, 0, !da)
      else {
        if (((l = a.current.alternate), _ && !sR(l))) {
          ;(b = Dy(a, o, !1)), (_ = !1)
          continue
        }
        if (b === 2) {
          if (((_ = o), a.errorRecoveryDisabledLanes & _)) var U = 0
          else (U = a.pendingLanes & -536870913), (U = U !== 0 ? U : U & 536870912 ? 536870912 : 0)
          if (U !== 0) {
            o = U
            e: {
              var q = a
              b = pf
              var K = q.current.memoizedState.isDehydrated
              if ((K && (Xu(q, U).flags |= 256), (U = Dy(q, U, !1)), U !== 2)) {
                if (Ay && !K) {
                  ;(q.errorRecoveryDisabledLanes |= _), (mc |= _), (b = 4)
                  break e
                }
                ;(_ = _s), (_s = b), _ !== null && Iy(_)
              }
              b = U
            }
            if (((_ = !1), b !== 2)) continue
          }
        }
        if (b === 1) {
          Xu(a, 0), ha(a, o, 0, !0)
          break
        }
        e: {
          switch (((h = a), b)) {
            case 0:
            case 1:
              throw Error(r(345))
            case 4:
              if ((o & 4194176) === o) {
                ha(h, o, Ii, !da)
                break e
              }
              break
            case 2:
              _s = null
              break
            case 3:
            case 5:
              break
            default:
              throw Error(r(329))
          }
          if (
            ((h.finishedWork = l),
            (h.finishedLanes = o),
            (o & 62914560) === o && ((_ = Sy + 300 - Je()), 10 < _))
          ) {
            if ((ha(h, o, Ii, !da), Xo(h, 0) !== 0)) break e
            h.timeoutHandle = eC(R_.bind(null, h, l, _s, T0, Cy, o, Ii, mc, Zu, da, 2, -0, 0), _)
            break e
          }
          R_(h, l, _s, T0, Cy, o, Ii, mc, Zu, da, 0, -0, 0)
        }
      }
      break
    } while (!0)
    Cs(a)
  }
  function Iy(a) {
    _s === null ? (_s = a) : _s.push.apply(_s, a)
  }
  function R_(a, o, l, h, b, _, U, q, K, J, oe, le, ie) {
    var ae = o.subtreeFlags
    if (
      (ae & 8192 || (ae & 16785408) === 16785408) &&
      ((Af = { stylesheets: null, count: 0, unsuspend: FR }), E_(o), (o = zR()), o !== null)
    ) {
      ;(a.cancelPendingCommit = o(L_.bind(null, a, l, h, b, U, q, K, 1, le, ie))), ha(a, _, U, !J)
      return
    }
    L_(a, l, h, b, U, q, K, oe, le, ie)
  }
  function sR(a) {
    for (var o = a; ; ) {
      var l = o.tag
      if (
        (l === 0 || l === 11 || l === 15) &&
        o.flags & 16384 &&
        ((l = o.updateQueue), l !== null && ((l = l.stores), l !== null))
      )
        for (var h = 0; h < l.length; h++) {
          var b = l[h],
            _ = b.getSnapshot
          b = b.value
          try {
            if (!si(_(), b)) return !1
          } catch {
            return !1
          }
        }
      if (((l = o.child), o.subtreeFlags & 16384 && l !== null)) (l.return = o), (o = l)
      else {
        if (o === a) break
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === a) return !0
          o = o.return
        }
        ;(o.sibling.return = o.return), (o = o.sibling)
      }
    }
    return !0
  }
  function ha(a, o, l, h) {
    ;(o &= ~_y),
      (o &= ~mc),
      (a.suspendedLanes |= o),
      (a.pingedLanes &= ~o),
      h && (a.warmLanes |= o),
      (h = a.expirationTimes)
    for (var b = o; 0 < b; ) {
      var _ = 31 - bt(b),
        U = 1 << _
      ;(h[_] = -1), (b &= ~U)
    }
    l !== 0 && wn(a, l, o)
  }
  function N0() {
    return (Cn & 6) === 0 ? (bf(0), !1) : !0
  }
  function Oy() {
    if (at !== null) {
      if (on === 0) var a = at.return
      else (a = at), (sa = fc = null), Ub(a), (Fu = null), (Yd = 0), (a = at)
      for (; a !== null; ) N_(a.alternate, a), (a = a.return)
      at = null
    }
  }
  function Xu(a, o) {
    ;(a.finishedWork = null), (a.finishedLanes = 0)
    var l = a.timeoutHandle
    l !== -1 && ((a.timeoutHandle = -1), CR(l)),
      (l = a.cancelPendingCommit),
      l !== null && ((a.cancelPendingCommit = null), l()),
      Oy(),
      (an = a),
      (at = l = no(a.current, null)),
      (yt = o),
      (on = 0),
      (ci = null),
      (da = !1),
      (Yu = sn(a, o)),
      (Ay = !1),
      (Zu = Ii = _y = mc = ro = Pn = 0),
      (_s = pf = null),
      (Cy = !1),
      (o & 8) !== 0 && (o |= o & 32)
    var h = a.entangledLanes
    if (h !== 0)
      for (a = a.entanglements, h &= o; 0 < h; ) {
        var b = 31 - bt(h),
          _ = 1 << b
        ;(o |= a[b]), (h &= ~_)
      }
    return (fa = o), Xp(), l
  }
  function D_(a, o) {
    ;(et = null),
      (j.H = As),
      o === Wd
        ? ((o = KA()), (on = 3))
        : o === HA
          ? ((o = KA()), (on = 4))
          : (on =
              o === G3
                ? 8
                : o !== null && typeof o == 'object' && typeof o.then == 'function'
                  ? 6
                  : 1),
      (ci = o),
      at === null && ((Pn = 1), y0(a, Ai(o, a.current)))
  }
  function P_() {
    var a = j.H
    return (j.H = As), a === null ? As : a
  }
  function M_() {
    var a = j.A
    return (j.A = rR), a
  }
  function Ry() {
    ;(Pn = 4),
      da || ((yt & 4194176) !== yt && Si.current !== null) || (Yu = !0),
      ((ro & 134217727) === 0 && (mc & 134217727) === 0) || an === null || ha(an, yt, Ii, !1)
  }
  function Dy(a, o, l) {
    var h = Cn
    Cn |= 2
    var b = P_(),
      _ = M_()
    ;(an !== a || yt !== o) && ((T0 = null), Xu(a, o)), (o = !1)
    var U = Pn
    e: do
      try {
        if (on !== 0 && at !== null) {
          var q = at,
            K = ci
          switch (on) {
            case 8:
              Oy(), (U = 6)
              break e
            case 3:
            case 2:
            case 6:
              Si.current === null && (o = !0)
              var J = on
              if (((on = 0), (ci = null), Ju(a, q, K, J), l && Yu)) {
                U = 0
                break e
              }
              break
            default:
              ;(J = on), (on = 0), (ci = null), Ju(a, q, K, J)
          }
        }
        aR(), (U = Pn)
        break
      } catch (oe) {
        D_(a, oe)
      }
    while (!0)
    return (
      o && a.shellSuspendCounter++,
      (sa = fc = null),
      (Cn = h),
      (j.H = b),
      (j.A = _),
      at === null && ((an = null), (yt = 0), Xp()),
      U
    )
  }
  function aR() {
    for (; at !== null; ) k_(at)
  }
  function oR(a, o) {
    var l = Cn
    Cn |= 2
    var h = P_(),
      b = M_()
    an !== a || yt !== o ? ((T0 = null), (S0 = Je() + 500), Xu(a, o)) : (Yu = sn(a, o))
    e: do
      try {
        if (on !== 0 && at !== null) {
          o = at
          var _ = ci
          t: switch (on) {
            case 1:
              ;(on = 0), (ci = null), Ju(a, o, _, 1)
              break
            case 2:
              if (GA(_)) {
                ;(on = 0), (ci = null), U_(o)
                break
              }
              ;(o = function () {
                on === 2 && an === a && (on = 7), Cs(a)
              }),
                _.then(o, o)
              break e
            case 3:
              on = 7
              break e
            case 4:
              on = 5
              break e
            case 7:
              GA(_) ? ((on = 0), (ci = null), U_(o)) : ((on = 0), (ci = null), Ju(a, o, _, 7))
              break
            case 5:
              var U = null
              switch (at.tag) {
                case 26:
                  U = at.memoizedState
                case 5:
                case 27:
                  var q = at
                  if (!U || dC(U)) {
                    ;(on = 0), (ci = null)
                    var K = q.sibling
                    if (K !== null) at = K
                    else {
                      var J = q.return
                      J !== null ? ((at = J), I0(J)) : (at = null)
                    }
                    break t
                  }
              }
              ;(on = 0), (ci = null), Ju(a, o, _, 5)
              break
            case 6:
              ;(on = 0), (ci = null), Ju(a, o, _, 6)
              break
            case 8:
              Oy(), (Pn = 6)
              break e
            default:
              throw Error(r(462))
          }
        }
        cR()
        break
      } catch (oe) {
        D_(a, oe)
      }
    while (!0)
    return (
      (sa = fc = null),
      (j.H = h),
      (j.A = b),
      (Cn = l),
      at !== null ? 0 : ((an = null), (yt = 0), Xp(), Pn)
    )
  }
  function cR() {
    for (; at !== null && !zt(); ) k_(at)
  }
  function k_(a) {
    var o = r_(a.alternate, a, fa)
    ;(a.memoizedProps = a.pendingProps), o === null ? I0(a) : (at = o)
  }
  function U_(a) {
    var o = a,
      l = o.alternate
    switch (o.tag) {
      case 15:
      case 0:
        o = Z3(l, o, o.pendingProps, o.type, void 0, yt)
        break
      case 11:
        o = Z3(l, o, o.pendingProps, o.type.render, o.ref, yt)
        break
      case 5:
        Ub(o)
      default:
        N_(l, o), (o = at = S_(o, fa)), (o = r_(l, o, fa))
    }
    ;(a.memoizedProps = a.pendingProps), o === null ? I0(a) : (at = o)
  }
  function Ju(a, o, l, h) {
    ;(sa = fc = null), Ub(o), (Fu = null), (Yd = 0)
    var b = o.return
    try {
      if (YO(a, b, o, l, yt)) {
        ;(Pn = 1), y0(a, Ai(l, a.current)), (at = null)
        return
      }
    } catch (_) {
      if (b !== null) throw ((at = b), _)
      ;(Pn = 1), y0(a, Ai(l, a.current)), (at = null)
      return
    }
    o.flags & 32768
      ? (Et || h === 1
          ? (a = !0)
          : Yu || (yt & 536870912) !== 0
            ? (a = !1)
            : ((da = a = !0),
              (h === 2 || h === 3 || h === 6) &&
                ((h = Si.current), h !== null && h.tag === 13 && (h.flags |= 16384))),
        B_(o, a))
      : I0(o)
  }
  function I0(a) {
    var o = a
    do {
      if ((o.flags & 32768) !== 0) {
        B_(o, da)
        return
      }
      a = o.return
      var l = tR(o.alternate, o, fa)
      if (l !== null) {
        at = l
        return
      }
      if (((o = o.sibling), o !== null)) {
        at = o
        return
      }
      at = o = a
    } while (o !== null)
    Pn === 0 && (Pn = 5)
  }
  function B_(a, o) {
    do {
      var l = nR(a.alternate, a)
      if (l !== null) {
        ;(l.flags &= 32767), (at = l)
        return
      }
      if (
        ((l = a.return),
        l !== null && ((l.flags |= 32768), (l.subtreeFlags = 0), (l.deletions = null)),
        !o && ((a = a.sibling), a !== null))
      ) {
        at = a
        return
      }
      at = a = l
    } while (a !== null)
    ;(Pn = 6), (at = null)
  }
  function L_(a, o, l, h, b, _, U, q, K, J) {
    var oe = j.T,
      le = Y.p
    try {
      ;(Y.p = 2), (j.T = null), uR(a, o, l, h, le, b, _, U, q, K, J)
    } finally {
      ;(j.T = oe), (Y.p = le)
    }
  }
  function uR(a, o, l, h, b, _, U, q) {
    do el()
    while (bc !== null)
    if ((Cn & 6) !== 0) throw Error(r(327))
    var K = a.finishedWork
    if (((h = a.finishedLanes), K === null)) return null
    if (((a.finishedWork = null), (a.finishedLanes = 0), K === a.current)) throw Error(r(177))
    ;(a.callbackNode = null), (a.callbackPriority = 0), (a.cancelPendingCommit = null)
    var J = K.lanes | K.childLanes
    if (
      ((J |= Eb),
      On(a, h, J, _, U, q),
      a === an && ((at = an = null), (yt = 0)),
      ((K.subtreeFlags & 10256) === 0 && (K.flags & 10256) === 0) ||
        x0 ||
        ((x0 = !0),
        (Ty = J),
        (xy = l),
        hR(Zt, function () {
          return el(), null
        })),
      (l = (K.flags & 15990) !== 0),
      (K.subtreeFlags & 15990) !== 0 || l
        ? ((l = j.T),
          (j.T = null),
          (_ = Y.p),
          (Y.p = 2),
          (U = Cn),
          (Cn |= 4),
          XO(a, K),
          y_(K, a),
          PO(Hy, a.containerInfo),
          (j0 = !!qy),
          (Hy = qy = null),
          (a.current = K),
          p_(a, K.alternate, K),
          ms(),
          (Cn = U),
          (Y.p = _),
          (j.T = l))
        : (a.current = K),
      x0 ? ((x0 = !1), (bc = a), (gf = h)) : $_(a, J),
      (J = a.pendingLanes),
      J === 0 && (io = null),
      Lp(K.stateNode),
      Cs(a),
      o !== null)
    )
      for (b = a.onRecoverableError, K = 0; K < o.length; K++)
        (J = o[K]), b(J.value, { componentStack: J.stack })
    return (
      (gf & 3) !== 0 && el(),
      (J = a.pendingLanes),
      (h & 4194218) !== 0 && (J & 42) !== 0 ? (a === Ny ? mf++ : ((mf = 0), (Ny = a))) : (mf = 0),
      bf(0),
      null
    )
  }
  function $_(a, o) {
    ;(a.pooledCacheLanes &= o) === 0 &&
      ((o = a.pooledCache), o != null && ((a.pooledCache = null), Xd(o)))
  }
  function el() {
    if (bc !== null) {
      var a = bc,
        o = Ty
      Ty = 0
      var l = En(gf),
        h = j.T,
        b = Y.p
      try {
        if (((Y.p = 32 > l ? 32 : l), (j.T = null), bc === null)) var _ = !1
        else {
          ;(l = xy), (xy = null)
          var U = bc,
            q = gf
          if (((bc = null), (gf = 0), (Cn & 6) !== 0)) throw Error(r(331))
          var K = Cn
          if (
            ((Cn |= 4),
            __(U.current),
            w_(U, U.current, q, l),
            (Cn = K),
            bf(0, !1),
            mt && typeof mt.onPostCommitFiberRoot == 'function')
          )
            try {
              mt.onPostCommitFiberRoot(rn, U)
            } catch {}
          _ = !0
        }
        return _
      } finally {
        ;(Y.p = b), (j.T = h), $_(a, o)
      }
    }
    return !1
  }
  function F_(a, o, l) {
    ;(o = Ai(l, o)), (o = Yb(a.stateNode, o, 2)), (a = Xa(a, o, 2)), a !== null && (za(a, 2), Cs(a))
  }
  function Jt(a, o, l) {
    if (a.tag === 3) F_(a, a, l)
    else
      for (; o !== null; ) {
        if (o.tag === 3) {
          F_(o, a, l)
          break
        } else if (o.tag === 1) {
          var h = o.stateNode
          if (
            typeof o.type.getDerivedStateFromError == 'function' ||
            (typeof h.componentDidCatch == 'function' && (io === null || !io.has(h)))
          ) {
            ;(a = Ai(l, a)),
              (l = q3(2)),
              (h = Xa(o, l, 2)),
              h !== null && (H3(l, h, o, a), za(h, 2), Cs(h))
            break
          }
        }
        o = o.return
      }
  }
  function Py(a, o, l) {
    var h = a.pingCache
    if (h === null) {
      h = a.pingCache = new iR()
      var b = new Set()
      h.set(o, b)
    } else (b = h.get(o)), b === void 0 && ((b = new Set()), h.set(o, b))
    b.has(l) || ((Ay = !0), b.add(l), (a = lR.bind(null, a, o, l)), o.then(a, a))
  }
  function lR(a, o, l) {
    var h = a.pingCache
    h !== null && h.delete(o),
      (a.pingedLanes |= a.suspendedLanes & l),
      (a.warmLanes &= ~l),
      an === a &&
        (yt & l) === l &&
        (Pn === 4 || (Pn === 3 && (yt & 62914560) === yt && 300 > Je() - Sy)
          ? (Cn & 2) === 0 && Xu(a, 0)
          : (_y |= l),
        Zu === yt && (Zu = 0)),
      Cs(a)
  }
  function j_(a, o) {
    o === 0 && (o = vn()), (a = Ha(a, o)), a !== null && (za(a, o), Cs(a))
  }
  function dR(a) {
    var o = a.memoizedState,
      l = 0
    o !== null && (l = o.retryLane), j_(a, l)
  }
  function fR(a, o) {
    var l = 0
    switch (a.tag) {
      case 13:
        var h = a.stateNode,
          b = a.memoizedState
        b !== null && (l = b.retryLane)
        break
      case 19:
        h = a.stateNode
        break
      case 22:
        h = a.stateNode._retryCache
        break
      default:
        throw Error(r(314))
    }
    h !== null && h.delete(o), j_(a, l)
  }
  function hR(a, o) {
    return yi(a, o)
  }
  var O0 = null,
    tl = null,
    My = !1,
    R0 = !1,
    ky = !1,
    yc = 0
  function Cs(a) {
    a !== tl && a.next === null && (tl === null ? (O0 = tl = a) : (tl = tl.next = a)),
      (R0 = !0),
      My || ((My = !0), gR(pR))
  }
  function bf(a, o) {
    if (!ky && R0) {
      ky = !0
      do
        for (var l = !1, h = O0; h !== null; ) {
          if (a !== 0) {
            var b = h.pendingLanes
            if (b === 0) var _ = 0
            else {
              var U = h.suspendedLanes,
                q = h.pingedLanes
              ;(_ = (1 << (31 - bt(42 | a) + 1)) - 1),
                (_ &= b & ~(U & ~q)),
                (_ = _ & 201326677 ? (_ & 201326677) | 1 : _ ? _ | 2 : 0)
            }
            _ !== 0 && ((l = !0), H_(h, _))
          } else
            (_ = yt),
              (_ = Xo(h, h === an ? _ : 0)),
              (_ & 3) === 0 || sn(h, _) || ((l = !0), H_(h, _))
          h = h.next
        }
      while (l)
      ky = !1
    }
  }
  function pR() {
    R0 = My = !1
    var a = 0
    yc !== 0 && (_R() && (a = yc), (yc = 0))
    for (var o = Je(), l = null, h = O0; h !== null; ) {
      var b = h.next,
        _ = z_(h, o)
      _ === 0
        ? ((h.next = null), l === null ? (O0 = b) : (l.next = b), b === null && (tl = l))
        : ((l = h), (a !== 0 || (_ & 3) !== 0) && (R0 = !0)),
        (h = b)
    }
    bf(a)
  }
  function z_(a, o) {
    for (
      var l = a.suspendedLanes,
        h = a.pingedLanes,
        b = a.expirationTimes,
        _ = a.pendingLanes & -62914561;
      0 < _;

    ) {
      var U = 31 - bt(_),
        q = 1 << U,
        K = b[U]
      K === -1
        ? ((q & l) === 0 || (q & h) !== 0) && (b[U] = In(q, o))
        : K <= o && (a.expiredLanes |= q),
        (_ &= ~q)
    }
    if (
      ((o = an),
      (l = yt),
      (l = Xo(a, a === o ? l : 0)),
      (h = a.callbackNode),
      l === 0 || (a === o && on === 2) || a.cancelPendingCommit !== null)
    )
      return h !== null && h !== null && xt(h), (a.callbackNode = null), (a.callbackPriority = 0)
    if ((l & 3) === 0 || sn(a, l)) {
      if (((o = l & -l), o === a.callbackPriority)) return o
      switch ((h !== null && xt(h), En(l))) {
        case 2:
        case 8:
          l = qt
          break
        case 32:
          l = Zt
          break
        case 268435456:
          l = dn
          break
        default:
          l = Zt
      }
      return (
        (h = q_.bind(null, a)), (l = yi(l, h)), (a.callbackPriority = o), (a.callbackNode = l), o
      )
    }
    return h !== null && h !== null && xt(h), (a.callbackPriority = 2), (a.callbackNode = null), 2
  }
  function q_(a, o) {
    var l = a.callbackNode
    if (el() && a.callbackNode !== l) return null
    var h = yt
    return (
      (h = Xo(a, a === an ? h : 0)),
      h === 0
        ? null
        : (O_(a, h, o),
          z_(a, Je()),
          a.callbackNode != null && a.callbackNode === l ? q_.bind(null, a) : null)
    )
  }
  function H_(a, o) {
    if (el()) return null
    O_(a, o, !0)
  }
  function gR(a) {
    SR(function () {
      ;(Cn & 6) !== 0 ? yi(Ki, a) : a()
    })
  }
  function Uy() {
    return yc === 0 && (yc = Od()), yc
  }
  function G_(a) {
    return a == null || typeof a == 'symbol' || typeof a == 'boolean'
      ? null
      : typeof a == 'function'
        ? a
        : Gp('' + a)
  }
  function V_(a, o) {
    var l = o.ownerDocument.createElement('input')
    return (
      (l.name = o.name),
      (l.value = o.value),
      a.id && l.setAttribute('form', a.id),
      o.parentNode.insertBefore(l, o),
      (a = new FormData(a)),
      l.parentNode.removeChild(l),
      a
    )
  }
  function mR(a, o, l, h, b) {
    if (o === 'submit' && l && l.stateNode === b) {
      var _ = G_((b[dr] || null).action),
        U = h.submitter
      U &&
        ((o = (o = U[dr] || null) ? G_(o.formAction) : U.getAttribute('formAction')),
        o !== null && ((_ = o), (U = null)))
      var q = new Qp('action', 'action', null, h, b)
      a.push({
        event: q,
        listeners: [
          {
            instance: null,
            listener: function () {
              if (h.defaultPrevented) {
                if (yc !== 0) {
                  var K = U ? V_(b, U) : new FormData(b)
                  Gb(l, { pending: !0, data: K, method: b.method, action: _ }, null, K)
                }
              } else
                typeof _ == 'function' &&
                  (q.preventDefault(),
                  (K = U ? V_(b, U) : new FormData(b)),
                  Gb(l, { pending: !0, data: K, method: b.method, action: _ }, _, K))
            },
            currentTarget: b
          }
        ]
      })
    }
  }
  for (var By = 0; By < LA.length; By++) {
    var Ly = LA[By],
      bR = Ly.toLowerCase(),
      yR = Ly[0].toUpperCase() + Ly.slice(1)
    Yi(bR, 'on' + yR)
  }
  Yi(PA, 'onAnimationEnd'),
    Yi(MA, 'onAnimationIteration'),
    Yi(kA, 'onAnimationStart'),
    Yi('dblclick', 'onDoubleClick'),
    Yi('focusin', 'onFocus'),
    Yi('focusout', 'onBlur'),
    Yi(kO, 'onTransitionRun'),
    Yi(UO, 'onTransitionStart'),
    Yi(BO, 'onTransitionCancel'),
    Yi(UA, 'onTransitionEnd'),
    vs('onMouseEnter', ['mouseout', 'mouseover']),
    vs('onMouseLeave', ['mouseout', 'mouseover']),
    vs('onPointerEnter', ['pointerout', 'pointerover']),
    vs('onPointerLeave', ['pointerout', 'pointerover']),
    Qi('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' ')),
    Qi(
      'onSelect',
      'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(
        ' '
      )
    ),
    Qi('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']),
    Qi('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' ')),
    Qi(
      'onCompositionStart',
      'compositionstart focusout keydown keypress keyup mousedown'.split(' ')
    ),
    Qi(
      'onCompositionUpdate',
      'compositionupdate focusout keydown keypress keyup mousedown'.split(' ')
    )
  var yf =
      'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
        ' '
      ),
    vR = new Set(
      'beforetoggle cancel close invalid load scroll scrollend toggle'.split(' ').concat(yf)
    )
  function K_(a, o) {
    o = (o & 4) !== 0
    for (var l = 0; l < a.length; l++) {
      var h = a[l],
        b = h.event
      h = h.listeners
      e: {
        var _ = void 0
        if (o)
          for (var U = h.length - 1; 0 <= U; U--) {
            var q = h[U],
              K = q.instance,
              J = q.currentTarget
            if (((q = q.listener), K !== _ && b.isPropagationStopped())) break e
            ;(_ = q), (b.currentTarget = J)
            try {
              _(b)
            } catch (oe) {
              b0(oe)
            }
            ;(b.currentTarget = null), (_ = K)
          }
        else
          for (U = 0; U < h.length; U++) {
            if (
              ((q = h[U]),
              (K = q.instance),
              (J = q.currentTarget),
              (q = q.listener),
              K !== _ && b.isPropagationStopped())
            )
              break e
            ;(_ = q), (b.currentTarget = J)
            try {
              _(b)
            } catch (oe) {
              b0(oe)
            }
            ;(b.currentTarget = null), (_ = K)
          }
      }
    }
  }
  function dt(a, o) {
    var l = o[bn]
    l === void 0 && (l = o[bn] = new Set())
    var h = a + '__bubble'
    l.has(h) || (W_(o, a, 2, !1), l.add(h))
  }
  function $y(a, o, l) {
    var h = 0
    o && (h |= 4), W_(l, a, h, o)
  }
  var D0 = '_reactListening' + Math.random().toString(36).slice(2)
  function Fy(a) {
    if (!a[D0]) {
      ;(a[D0] = !0),
        Su.forEach(function (l) {
          l !== 'selectionchange' && (vR.has(l) || $y(l, !1, a), $y(l, !0, a))
        })
      var o = a.nodeType === 9 ? a : a.ownerDocument
      o === null || o[D0] || ((o[D0] = !0), $y('selectionchange', !1, o))
    }
  }
  function W_(a, o, l, h) {
    switch (bC(o)) {
      case 2:
        var b = GR
        break
      case 8:
        b = VR
        break
      default:
        b = Jy
    }
    ;(l = b.bind(null, o, l, a)),
      (b = void 0),
      !cb || (o !== 'touchstart' && o !== 'touchmove' && o !== 'wheel') || (b = !0),
      h
        ? b !== void 0
          ? a.addEventListener(o, l, { capture: !0, passive: b })
          : a.addEventListener(o, l, !0)
        : b !== void 0
          ? a.addEventListener(o, l, { passive: b })
          : a.addEventListener(o, l, !1)
  }
  function jy(a, o, l, h, b) {
    var _ = h
    if ((o & 1) === 0 && (o & 2) === 0 && h !== null)
      e: for (;;) {
        if (h === null) return
        var U = h.tag
        if (U === 3 || U === 4) {
          var q = h.stateNode.containerInfo
          if (q === b || (q.nodeType === 8 && q.parentNode === b)) break
          if (U === 4)
            for (U = h.return; U !== null; ) {
              var K = U.tag
              if (
                (K === 3 || K === 4) &&
                ((K = U.stateNode.containerInfo),
                K === b || (K.nodeType === 8 && K.parentNode === b))
              )
                return
              U = U.return
            }
          for (; q !== null; ) {
            if (((U = Wi(q)), U === null)) return
            if (((K = U.tag), K === 5 || K === 6 || K === 26 || K === 27)) {
              h = _ = U
              continue e
            }
            q = q.parentNode
          }
        }
        h = h.return
      }
    uA(function () {
      var J = _,
        oe = ab(l),
        le = []
      e: {
        var ie = BA.get(a)
        if (ie !== void 0) {
          var ae = Qp,
            Pe = a
          switch (a) {
            case 'keypress':
              if (Kp(l) === 0) break e
            case 'keydown':
            case 'keyup':
              ae = fO
              break
            case 'focusin':
              ;(Pe = 'focus'), (ae = fb)
              break
            case 'focusout':
              ;(Pe = 'blur'), (ae = fb)
              break
            case 'beforeblur':
            case 'afterblur':
              ae = fb
              break
            case 'click':
              if (l.button === 2) break e
            case 'auxclick':
            case 'dblclick':
            case 'mousedown':
            case 'mousemove':
            case 'mouseup':
            case 'mouseout':
            case 'mouseover':
            case 'contextmenu':
              ae = fA
              break
            case 'drag':
            case 'dragend':
            case 'dragenter':
            case 'dragexit':
            case 'dragleave':
            case 'dragover':
            case 'dragstart':
            case 'drop':
              ae = eO
              break
            case 'touchcancel':
            case 'touchend':
            case 'touchmove':
            case 'touchstart':
              ae = gO
              break
            case PA:
            case MA:
            case kA:
              ae = rO
              break
            case UA:
              ae = bO
              break
            case 'scroll':
            case 'scrollend':
              ae = XI
              break
            case 'wheel':
              ae = vO
              break
            case 'copy':
            case 'cut':
            case 'paste':
              ae = sO
              break
            case 'gotpointercapture':
            case 'lostpointercapture':
            case 'pointercancel':
            case 'pointerdown':
            case 'pointermove':
            case 'pointerout':
            case 'pointerover':
            case 'pointerup':
              ae = pA
              break
            case 'toggle':
            case 'beforetoggle':
              ae = EO
          }
          var qe = (o & 4) !== 0,
            Mn = !qe && (a === 'scroll' || a === 'scrollend'),
            te = qe ? (ie !== null ? ie + 'Capture' : null) : ie
          qe = []
          for (var X = J, ne; X !== null; ) {
            var ue = X
            if (
              ((ne = ue.stateNode),
              (ue = ue.tag),
              (ue !== 5 && ue !== 26 && ue !== 27) ||
                ne === null ||
                te === null ||
                ((ue = Ud(X, te)), ue != null && qe.push(vf(X, ue, ne))),
              Mn)
            )
              break
            X = X.return
          }
          0 < qe.length &&
            ((ie = new ae(ie, Pe, null, l, oe)), le.push({ event: ie, listeners: qe }))
        }
      }
      if ((o & 7) === 0) {
        e: {
          if (
            ((ie = a === 'mouseover' || a === 'pointerover'),
            (ae = a === 'mouseout' || a === 'pointerout'),
            ie && l !== sb && (Pe = l.relatedTarget || l.fromElement) && (Wi(Pe) || Pe[Xt]))
          )
            break e
          if (
            (ae || ie) &&
            ((ie =
              oe.window === oe
                ? oe
                : (ie = oe.ownerDocument)
                  ? ie.defaultView || ie.parentWindow
                  : window),
            ae
              ? ((Pe = l.relatedTarget || l.toElement),
                (ae = J),
                (Pe = Pe ? Wi(Pe) : null),
                Pe !== null &&
                  ((Mn = F(Pe)), (qe = Pe.tag), Pe !== Mn || (qe !== 5 && qe !== 27 && qe !== 6)) &&
                  (Pe = null))
              : ((ae = null), (Pe = J)),
            ae !== Pe)
          ) {
            if (
              ((qe = fA),
              (ue = 'onMouseLeave'),
              (te = 'onMouseEnter'),
              (X = 'mouse'),
              (a === 'pointerout' || a === 'pointerover') &&
                ((qe = pA), (ue = 'onPointerLeave'), (te = 'onPointerEnter'), (X = 'pointer')),
              (Mn = ae == null ? ie : Xs(ae)),
              (ne = Pe == null ? ie : Xs(Pe)),
              (ie = new qe(ue, X + 'leave', ae, l, oe)),
              (ie.target = Mn),
              (ie.relatedTarget = ne),
              (ue = null),
              Wi(oe) === J &&
                ((qe = new qe(te, X + 'enter', Pe, l, oe)),
                (qe.target = ne),
                (qe.relatedTarget = Mn),
                (ue = qe)),
              (Mn = ue),
              ae && Pe)
            )
              t: {
                for (qe = ae, te = Pe, X = 0, ne = qe; ne; ne = nl(ne)) X++
                for (ne = 0, ue = te; ue; ue = nl(ue)) ne++
                for (; 0 < X - ne; ) (qe = nl(qe)), X--
                for (; 0 < ne - X; ) (te = nl(te)), ne--
                for (; X--; ) {
                  if (qe === te || (te !== null && qe === te.alternate)) break t
                  ;(qe = nl(qe)), (te = nl(te))
                }
                qe = null
              }
            else qe = null
            ae !== null && Q_(le, ie, ae, qe, !1),
              Pe !== null && Mn !== null && Q_(le, Mn, Pe, qe, !0)
          }
        }
        e: {
          if (
            ((ie = J ? Xs(J) : window),
            (ae = ie.nodeName && ie.nodeName.toLowerCase()),
            ae === 'select' || (ae === 'input' && ie.type === 'file'))
          )
            var Ie = AA
          else if (wA(ie))
            if (_A) Ie = RO
            else {
              Ie = IO
              var nt = NO
            }
          else
            (ae = ie.nodeName),
              !ae || ae.toLowerCase() !== 'input' || (ie.type !== 'checkbox' && ie.type !== 'radio')
                ? J && ib(J.elementType) && (Ie = AA)
                : (Ie = OO)
          if (Ie && (Ie = Ie(a, J))) {
            EA(le, Ie, l, oe)
            break e
          }
          nt && nt(a, ie, J),
            a === 'focusout' &&
              J &&
              ie.type === 'number' &&
              J.memoizedProps.value != null &&
              rb(ie, 'number', ie.value)
        }
        switch (((nt = J ? Xs(J) : window), a)) {
          case 'focusin':
            ;(wA(nt) || nt.contentEditable === 'true') && ((Mu = nt), (yb = J), (Hd = null))
            break
          case 'focusout':
            Hd = yb = Mu = null
            break
          case 'mousedown':
            vb = !0
            break
          case 'contextmenu':
          case 'mouseup':
          case 'dragend':
            ;(vb = !1), RA(le, l, oe)
            break
          case 'selectionchange':
            if (MO) break
          case 'keydown':
          case 'keyup':
            RA(le, l, oe)
        }
        var ke
        if (pb)
          e: {
            switch (a) {
              case 'compositionstart':
                var Fe = 'onCompositionStart'
                break e
              case 'compositionend':
                Fe = 'onCompositionEnd'
                break e
              case 'compositionupdate':
                Fe = 'onCompositionUpdate'
                break e
            }
            Fe = void 0
          }
        else
          Pu
            ? yA(a, l) && (Fe = 'onCompositionEnd')
            : a === 'keydown' && l.keyCode === 229 && (Fe = 'onCompositionStart')
        Fe &&
          (gA &&
            l.locale !== 'ko' &&
            (Pu || Fe !== 'onCompositionStart'
              ? Fe === 'onCompositionEnd' && Pu && (ke = lA())
              : ((qa = oe), (ub = 'value' in qa ? qa.value : qa.textContent), (Pu = !0))),
          (nt = P0(J, Fe)),
          0 < nt.length &&
            ((Fe = new hA(Fe, a, null, l, oe)),
            le.push({ event: Fe, listeners: nt }),
            ke ? (Fe.data = ke) : ((ke = vA(l)), ke !== null && (Fe.data = ke)))),
          (ke = _O ? CO(a, l) : SO(a, l)) &&
            ((Fe = P0(J, 'onBeforeInput')),
            0 < Fe.length &&
              ((nt = new hA('onBeforeInput', 'beforeinput', null, l, oe)),
              le.push({ event: nt, listeners: Fe }),
              (nt.data = ke))),
          mR(le, a, J, l, oe)
      }
      K_(le, o)
    })
  }
  function vf(a, o, l) {
    return { instance: a, listener: o, currentTarget: l }
  }
  function P0(a, o) {
    for (var l = o + 'Capture', h = []; a !== null; ) {
      var b = a,
        _ = b.stateNode
      ;(b = b.tag),
        (b !== 5 && b !== 26 && b !== 27) ||
          _ === null ||
          ((b = Ud(a, l)),
          b != null && h.unshift(vf(a, b, _)),
          (b = Ud(a, o)),
          b != null && h.push(vf(a, b, _))),
        (a = a.return)
    }
    return h
  }
  function nl(a) {
    if (a === null) return null
    do a = a.return
    while (a && a.tag !== 5 && a.tag !== 27)
    return a || null
  }
  function Q_(a, o, l, h, b) {
    for (var _ = o._reactName, U = []; l !== null && l !== h; ) {
      var q = l,
        K = q.alternate,
        J = q.stateNode
      if (((q = q.tag), K !== null && K === h)) break
      ;(q !== 5 && q !== 26 && q !== 27) ||
        J === null ||
        ((K = J),
        b
          ? ((J = Ud(l, _)), J != null && U.unshift(vf(l, J, K)))
          : b || ((J = Ud(l, _)), J != null && U.push(vf(l, J, K)))),
        (l = l.return)
    }
    U.length !== 0 && a.push({ event: o, listeners: U })
  }
  var wR = /\r\n?/g,
    ER = /\u0000|\uFFFD/g
  function Y_(a) {
    return (typeof a == 'string' ? a : '' + a)
      .replace(
        wR,
        `
`
      )
      .replace(ER, '')
  }
  function Z_(a, o) {
    return (o = Y_(o)), Y_(a) === o
  }
  function M0() {}
  function Vt(a, o, l, h, b, _) {
    switch (l) {
      case 'children':
        typeof h == 'string'
          ? o === 'body' || (o === 'textarea' && h === '') || Ou(a, h)
          : (typeof h == 'number' || typeof h == 'bigint') && o !== 'body' && Ou(a, '' + h)
        break
      case 'className':
        zp(a, 'class', h)
        break
      case 'tabIndex':
        zp(a, 'tabindex', h)
        break
      case 'dir':
      case 'role':
      case 'viewBox':
      case 'width':
      case 'height':
        zp(a, l, h)
        break
      case 'style':
        oA(a, h, _)
        break
      case 'data':
        if (o !== 'object') {
          zp(a, 'data', h)
          break
        }
      case 'src':
      case 'href':
        if (h === '' && (o !== 'a' || l !== 'href')) {
          a.removeAttribute(l)
          break
        }
        if (h == null || typeof h == 'function' || typeof h == 'symbol' || typeof h == 'boolean') {
          a.removeAttribute(l)
          break
        }
        ;(h = Gp('' + h)), a.setAttribute(l, h)
        break
      case 'action':
      case 'formAction':
        if (typeof h == 'function') {
          a.setAttribute(
            l,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          )
          break
        } else
          typeof _ == 'function' &&
            (l === 'formAction'
              ? (o !== 'input' && Vt(a, o, 'name', b.name, b, null),
                Vt(a, o, 'formEncType', b.formEncType, b, null),
                Vt(a, o, 'formMethod', b.formMethod, b, null),
                Vt(a, o, 'formTarget', b.formTarget, b, null))
              : (Vt(a, o, 'encType', b.encType, b, null),
                Vt(a, o, 'method', b.method, b, null),
                Vt(a, o, 'target', b.target, b, null)))
        if (h == null || typeof h == 'symbol' || typeof h == 'boolean') {
          a.removeAttribute(l)
          break
        }
        ;(h = Gp('' + h)), a.setAttribute(l, h)
        break
      case 'onClick':
        h != null && (a.onclick = M0)
        break
      case 'onScroll':
        h != null && dt('scroll', a)
        break
      case 'onScrollEnd':
        h != null && dt('scrollend', a)
        break
      case 'dangerouslySetInnerHTML':
        if (h != null) {
          if (typeof h != 'object' || !('__html' in h)) throw Error(r(61))
          if (((l = h.__html), l != null)) {
            if (b.children != null) throw Error(r(60))
            a.innerHTML = l
          }
        }
        break
      case 'multiple':
        a.multiple = h && typeof h != 'function' && typeof h != 'symbol'
        break
      case 'muted':
        a.muted = h && typeof h != 'function' && typeof h != 'symbol'
        break
      case 'suppressContentEditableWarning':
      case 'suppressHydrationWarning':
      case 'defaultValue':
      case 'defaultChecked':
      case 'innerHTML':
      case 'ref':
        break
      case 'autoFocus':
        break
      case 'xlinkHref':
        if (h == null || typeof h == 'function' || typeof h == 'boolean' || typeof h == 'symbol') {
          a.removeAttribute('xlink:href')
          break
        }
        ;(l = Gp('' + h)), a.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', l)
        break
      case 'contentEditable':
      case 'spellCheck':
      case 'draggable':
      case 'value':
      case 'autoReverse':
      case 'externalResourcesRequired':
      case 'focusable':
      case 'preserveAlpha':
        h != null && typeof h != 'function' && typeof h != 'symbol'
          ? a.setAttribute(l, '' + h)
          : a.removeAttribute(l)
        break
      case 'inert':
      case 'allowFullScreen':
      case 'async':
      case 'autoPlay':
      case 'controls':
      case 'default':
      case 'defer':
      case 'disabled':
      case 'disablePictureInPicture':
      case 'disableRemotePlayback':
      case 'formNoValidate':
      case 'hidden':
      case 'loop':
      case 'noModule':
      case 'noValidate':
      case 'open':
      case 'playsInline':
      case 'readOnly':
      case 'required':
      case 'reversed':
      case 'scoped':
      case 'seamless':
      case 'itemScope':
        h && typeof h != 'function' && typeof h != 'symbol'
          ? a.setAttribute(l, '')
          : a.removeAttribute(l)
        break
      case 'capture':
      case 'download':
        h === !0
          ? a.setAttribute(l, '')
          : h !== !1 && h != null && typeof h != 'function' && typeof h != 'symbol'
            ? a.setAttribute(l, h)
            : a.removeAttribute(l)
        break
      case 'cols':
      case 'rows':
      case 'size':
      case 'span':
        h != null && typeof h != 'function' && typeof h != 'symbol' && !isNaN(h) && 1 <= h
          ? a.setAttribute(l, h)
          : a.removeAttribute(l)
        break
      case 'rowSpan':
      case 'start':
        h == null || typeof h == 'function' || typeof h == 'symbol' || isNaN(h)
          ? a.removeAttribute(l)
          : a.setAttribute(l, h)
        break
      case 'popover':
        dt('beforetoggle', a), dt('toggle', a), jp(a, 'popover', h)
        break
      case 'xlinkActuate':
        Js(a, 'http://www.w3.org/1999/xlink', 'xlink:actuate', h)
        break
      case 'xlinkArcrole':
        Js(a, 'http://www.w3.org/1999/xlink', 'xlink:arcrole', h)
        break
      case 'xlinkRole':
        Js(a, 'http://www.w3.org/1999/xlink', 'xlink:role', h)
        break
      case 'xlinkShow':
        Js(a, 'http://www.w3.org/1999/xlink', 'xlink:show', h)
        break
      case 'xlinkTitle':
        Js(a, 'http://www.w3.org/1999/xlink', 'xlink:title', h)
        break
      case 'xlinkType':
        Js(a, 'http://www.w3.org/1999/xlink', 'xlink:type', h)
        break
      case 'xmlBase':
        Js(a, 'http://www.w3.org/XML/1998/namespace', 'xml:base', h)
        break
      case 'xmlLang':
        Js(a, 'http://www.w3.org/XML/1998/namespace', 'xml:lang', h)
        break
      case 'xmlSpace':
        Js(a, 'http://www.w3.org/XML/1998/namespace', 'xml:space', h)
        break
      case 'is':
        jp(a, 'is', h)
        break
      case 'innerText':
      case 'textContent':
        break
      default:
        ;(!(2 < l.length) || (l[0] !== 'o' && l[0] !== 'O') || (l[1] !== 'n' && l[1] !== 'N')) &&
          ((l = YI.get(l) || l), jp(a, l, h))
    }
  }
  function zy(a, o, l, h, b, _) {
    switch (l) {
      case 'style':
        oA(a, h, _)
        break
      case 'dangerouslySetInnerHTML':
        if (h != null) {
          if (typeof h != 'object' || !('__html' in h)) throw Error(r(61))
          if (((l = h.__html), l != null)) {
            if (b.children != null) throw Error(r(60))
            a.innerHTML = l
          }
        }
        break
      case 'children':
        typeof h == 'string'
          ? Ou(a, h)
          : (typeof h == 'number' || typeof h == 'bigint') && Ou(a, '' + h)
        break
      case 'onScroll':
        h != null && dt('scroll', a)
        break
      case 'onScrollEnd':
        h != null && dt('scrollend', a)
        break
      case 'onClick':
        h != null && (a.onclick = M0)
        break
      case 'suppressContentEditableWarning':
      case 'suppressHydrationWarning':
      case 'innerHTML':
      case 'ref':
        break
      case 'innerText':
      case 'textContent':
        break
      default:
        if (!Tu.hasOwnProperty(l))
          e: {
            if (
              l[0] === 'o' &&
              l[1] === 'n' &&
              ((b = l.endsWith('Capture')),
              (o = l.slice(2, b ? l.length - 7 : void 0)),
              (_ = a[dr] || null),
              (_ = _ != null ? _[l] : null),
              typeof _ == 'function' && a.removeEventListener(o, _, b),
              typeof h == 'function')
            ) {
              typeof _ != 'function' &&
                _ !== null &&
                (l in a ? (a[l] = null) : a.hasAttribute(l) && a.removeAttribute(l)),
                a.addEventListener(o, h, b)
              break e
            }
            l in a ? (a[l] = h) : h === !0 ? a.setAttribute(l, '') : jp(a, l, h)
          }
    }
  }
  function pr(a, o, l) {
    switch (o) {
      case 'div':
      case 'span':
      case 'svg':
      case 'path':
      case 'a':
      case 'g':
      case 'p':
      case 'li':
        break
      case 'img':
        dt('error', a), dt('load', a)
        var h = !1,
          b = !1,
          _
        for (_ in l)
          if (l.hasOwnProperty(_)) {
            var U = l[_]
            if (U != null)
              switch (_) {
                case 'src':
                  h = !0
                  break
                case 'srcSet':
                  b = !0
                  break
                case 'children':
                case 'dangerouslySetInnerHTML':
                  throw Error(r(137, o))
                default:
                  Vt(a, o, _, U, l, null)
              }
          }
        b && Vt(a, o, 'srcSet', l.srcSet, l, null), h && Vt(a, o, 'src', l.src, l, null)
        return
      case 'input':
        dt('invalid', a)
        var q = (_ = U = b = null),
          K = null,
          J = null
        for (h in l)
          if (l.hasOwnProperty(h)) {
            var oe = l[h]
            if (oe != null)
              switch (h) {
                case 'name':
                  b = oe
                  break
                case 'type':
                  U = oe
                  break
                case 'checked':
                  K = oe
                  break
                case 'defaultChecked':
                  J = oe
                  break
                case 'value':
                  _ = oe
                  break
                case 'defaultValue':
                  q = oe
                  break
                case 'children':
                case 'dangerouslySetInnerHTML':
                  if (oe != null) throw Error(r(137, o))
                  break
                default:
                  Vt(a, o, h, oe, l, null)
              }
          }
        rA(a, _, q, K, J, U, b, !1), qp(a)
        return
      case 'select':
        dt('invalid', a), (h = U = _ = null)
        for (b in l)
          if (l.hasOwnProperty(b) && ((q = l[b]), q != null))
            switch (b) {
              case 'value':
                _ = q
                break
              case 'defaultValue':
                U = q
                break
              case 'multiple':
                h = q
              default:
                Vt(a, o, b, q, l, null)
            }
        ;(o = _),
          (l = U),
          (a.multiple = !!h),
          o != null ? Iu(a, !!h, o, !1) : l != null && Iu(a, !!h, l, !0)
        return
      case 'textarea':
        dt('invalid', a), (_ = b = h = null)
        for (U in l)
          if (l.hasOwnProperty(U) && ((q = l[U]), q != null))
            switch (U) {
              case 'value':
                h = q
                break
              case 'defaultValue':
                b = q
                break
              case 'children':
                _ = q
                break
              case 'dangerouslySetInnerHTML':
                if (q != null) throw Error(r(91))
                break
              default:
                Vt(a, o, U, q, l, null)
            }
        sA(a, h, b, _), qp(a)
        return
      case 'option':
        for (K in l)
          if (l.hasOwnProperty(K) && ((h = l[K]), h != null))
            switch (K) {
              case 'selected':
                a.selected = h && typeof h != 'function' && typeof h != 'symbol'
                break
              default:
                Vt(a, o, K, h, l, null)
            }
        return
      case 'dialog':
        dt('cancel', a), dt('close', a)
        break
      case 'iframe':
      case 'object':
        dt('load', a)
        break
      case 'video':
      case 'audio':
        for (h = 0; h < yf.length; h++) dt(yf[h], a)
        break
      case 'image':
        dt('error', a), dt('load', a)
        break
      case 'details':
        dt('toggle', a)
        break
      case 'embed':
      case 'source':
      case 'link':
        dt('error', a), dt('load', a)
      case 'area':
      case 'base':
      case 'br':
      case 'col':
      case 'hr':
      case 'keygen':
      case 'meta':
      case 'param':
      case 'track':
      case 'wbr':
      case 'menuitem':
        for (J in l)
          if (l.hasOwnProperty(J) && ((h = l[J]), h != null))
            switch (J) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw Error(r(137, o))
              default:
                Vt(a, o, J, h, l, null)
            }
        return
      default:
        if (ib(o)) {
          for (oe in l)
            l.hasOwnProperty(oe) && ((h = l[oe]), h !== void 0 && zy(a, o, oe, h, l, void 0))
          return
        }
    }
    for (q in l) l.hasOwnProperty(q) && ((h = l[q]), h != null && Vt(a, o, q, h, l, null))
  }
  function AR(a, o, l, h) {
    switch (o) {
      case 'div':
      case 'span':
      case 'svg':
      case 'path':
      case 'a':
      case 'g':
      case 'p':
      case 'li':
        break
      case 'input':
        var b = null,
          _ = null,
          U = null,
          q = null,
          K = null,
          J = null,
          oe = null
        for (ae in l) {
          var le = l[ae]
          if (l.hasOwnProperty(ae) && le != null)
            switch (ae) {
              case 'checked':
                break
              case 'value':
                break
              case 'defaultValue':
                K = le
              default:
                h.hasOwnProperty(ae) || Vt(a, o, ae, null, h, le)
            }
        }
        for (var ie in h) {
          var ae = h[ie]
          if (((le = l[ie]), h.hasOwnProperty(ie) && (ae != null || le != null)))
            switch (ie) {
              case 'type':
                _ = ae
                break
              case 'name':
                b = ae
                break
              case 'checked':
                J = ae
                break
              case 'defaultChecked':
                oe = ae
                break
              case 'value':
                U = ae
                break
              case 'defaultValue':
                q = ae
                break
              case 'children':
              case 'dangerouslySetInnerHTML':
                if (ae != null) throw Error(r(137, o))
                break
              default:
                ae !== le && Vt(a, o, ie, ae, h, le)
            }
        }
        nb(a, U, q, K, J, oe, _, b)
        return
      case 'select':
        ae = U = q = ie = null
        for (_ in l)
          if (((K = l[_]), l.hasOwnProperty(_) && K != null))
            switch (_) {
              case 'value':
                break
              case 'multiple':
                ae = K
              default:
                h.hasOwnProperty(_) || Vt(a, o, _, null, h, K)
            }
        for (b in h)
          if (((_ = h[b]), (K = l[b]), h.hasOwnProperty(b) && (_ != null || K != null)))
            switch (b) {
              case 'value':
                ie = _
                break
              case 'defaultValue':
                q = _
                break
              case 'multiple':
                U = _
              default:
                _ !== K && Vt(a, o, b, _, h, K)
            }
        ;(o = q),
          (l = U),
          (h = ae),
          ie != null
            ? Iu(a, !!l, ie, !1)
            : !!h != !!l && (o != null ? Iu(a, !!l, o, !0) : Iu(a, !!l, l ? [] : '', !1))
        return
      case 'textarea':
        ae = ie = null
        for (q in l)
          if (((b = l[q]), l.hasOwnProperty(q) && b != null && !h.hasOwnProperty(q)))
            switch (q) {
              case 'value':
                break
              case 'children':
                break
              default:
                Vt(a, o, q, null, h, b)
            }
        for (U in h)
          if (((b = h[U]), (_ = l[U]), h.hasOwnProperty(U) && (b != null || _ != null)))
            switch (U) {
              case 'value':
                ie = b
                break
              case 'defaultValue':
                ae = b
                break
              case 'children':
                break
              case 'dangerouslySetInnerHTML':
                if (b != null) throw Error(r(91))
                break
              default:
                b !== _ && Vt(a, o, U, b, h, _)
            }
        iA(a, ie, ae)
        return
      case 'option':
        for (var Pe in l)
          if (((ie = l[Pe]), l.hasOwnProperty(Pe) && ie != null && !h.hasOwnProperty(Pe)))
            switch (Pe) {
              case 'selected':
                a.selected = !1
                break
              default:
                Vt(a, o, Pe, null, h, ie)
            }
        for (K in h)
          if (
            ((ie = h[K]),
            (ae = l[K]),
            h.hasOwnProperty(K) && ie !== ae && (ie != null || ae != null))
          )
            switch (K) {
              case 'selected':
                a.selected = ie && typeof ie != 'function' && typeof ie != 'symbol'
                break
              default:
                Vt(a, o, K, ie, h, ae)
            }
        return
      case 'img':
      case 'link':
      case 'area':
      case 'base':
      case 'br':
      case 'col':
      case 'embed':
      case 'hr':
      case 'keygen':
      case 'meta':
      case 'param':
      case 'source':
      case 'track':
      case 'wbr':
      case 'menuitem':
        for (var qe in l)
          (ie = l[qe]),
            l.hasOwnProperty(qe) && ie != null && !h.hasOwnProperty(qe) && Vt(a, o, qe, null, h, ie)
        for (J in h)
          if (
            ((ie = h[J]),
            (ae = l[J]),
            h.hasOwnProperty(J) && ie !== ae && (ie != null || ae != null))
          )
            switch (J) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                if (ie != null) throw Error(r(137, o))
                break
              default:
                Vt(a, o, J, ie, h, ae)
            }
        return
      default:
        if (ib(o)) {
          for (var Mn in l)
            (ie = l[Mn]),
              l.hasOwnProperty(Mn) &&
                ie !== void 0 &&
                !h.hasOwnProperty(Mn) &&
                zy(a, o, Mn, void 0, h, ie)
          for (oe in h)
            (ie = h[oe]),
              (ae = l[oe]),
              !h.hasOwnProperty(oe) ||
                ie === ae ||
                (ie === void 0 && ae === void 0) ||
                zy(a, o, oe, ie, h, ae)
          return
        }
    }
    for (var te in l)
      (ie = l[te]),
        l.hasOwnProperty(te) && ie != null && !h.hasOwnProperty(te) && Vt(a, o, te, null, h, ie)
    for (le in h)
      (ie = h[le]),
        (ae = l[le]),
        !h.hasOwnProperty(le) || ie === ae || (ie == null && ae == null) || Vt(a, o, le, ie, h, ae)
  }
  var qy = null,
    Hy = null
  function k0(a) {
    return a.nodeType === 9 ? a : a.ownerDocument
  }
  function X_(a) {
    switch (a) {
      case 'http://www.w3.org/2000/svg':
        return 1
      case 'http://www.w3.org/1998/Math/MathML':
        return 2
      default:
        return 0
    }
  }
  function J_(a, o) {
    if (a === 0)
      switch (o) {
        case 'svg':
          return 1
        case 'math':
          return 2
        default:
          return 0
      }
    return a === 1 && o === 'foreignObject' ? 0 : a
  }
  function Gy(a, o) {
    return (
      a === 'textarea' ||
      a === 'noscript' ||
      typeof o.children == 'string' ||
      typeof o.children == 'number' ||
      typeof o.children == 'bigint' ||
      (typeof o.dangerouslySetInnerHTML == 'object' &&
        o.dangerouslySetInnerHTML !== null &&
        o.dangerouslySetInnerHTML.__html != null)
    )
  }
  var Vy = null
  function _R() {
    var a = window.event
    return a && a.type === 'popstate' ? (a === Vy ? !1 : ((Vy = a), !0)) : ((Vy = null), !1)
  }
  var eC = typeof setTimeout == 'function' ? setTimeout : void 0,
    CR = typeof clearTimeout == 'function' ? clearTimeout : void 0,
    tC = typeof Promise == 'function' ? Promise : void 0,
    SR =
      typeof queueMicrotask == 'function'
        ? queueMicrotask
        : typeof tC < 'u'
          ? function (a) {
              return tC.resolve(null).then(a).catch(TR)
            }
          : eC
  function TR(a) {
    setTimeout(function () {
      throw a
    })
  }
  function Ky(a, o) {
    var l = o,
      h = 0
    do {
      var b = l.nextSibling
      if ((a.removeChild(l), b && b.nodeType === 8))
        if (((l = b.data), l === '/$')) {
          if (h === 0) {
            a.removeChild(b), xf(o)
            return
          }
          h--
        } else (l !== '$' && l !== '$?' && l !== '$!') || h++
      l = b
    } while (l)
    xf(o)
  }
  function Wy(a) {
    var o = a.firstChild
    for (o && o.nodeType === 10 && (o = o.nextSibling); o; ) {
      var l = o
      switch (((o = o.nextSibling), l.nodeName)) {
        case 'HTML':
        case 'HEAD':
        case 'BODY':
          Wy(l), Jo(l)
          continue
        case 'SCRIPT':
        case 'STYLE':
          continue
        case 'LINK':
          if (l.rel.toLowerCase() === 'stylesheet') continue
      }
      a.removeChild(l)
    }
  }
  function xR(a, o, l, h) {
    for (; a.nodeType === 1; ) {
      var b = l
      if (a.nodeName.toLowerCase() !== o.toLowerCase()) {
        if (!h && (a.nodeName !== 'INPUT' || a.type !== 'hidden')) break
      } else if (h) {
        if (!a[Zs])
          switch (o) {
            case 'meta':
              if (!a.hasAttribute('itemprop')) break
              return a
            case 'link':
              if (
                ((_ = a.getAttribute('rel')),
                _ === 'stylesheet' && a.hasAttribute('data-precedence'))
              )
                break
              if (
                _ !== b.rel ||
                a.getAttribute('href') !== (b.href == null ? null : b.href) ||
                a.getAttribute('crossorigin') !== (b.crossOrigin == null ? null : b.crossOrigin) ||
                a.getAttribute('title') !== (b.title == null ? null : b.title)
              )
                break
              return a
            case 'style':
              if (a.hasAttribute('data-precedence')) break
              return a
            case 'script':
              if (
                ((_ = a.getAttribute('src')),
                (_ !== (b.src == null ? null : b.src) ||
                  a.getAttribute('type') !== (b.type == null ? null : b.type) ||
                  a.getAttribute('crossorigin') !==
                    (b.crossOrigin == null ? null : b.crossOrigin)) &&
                  _ &&
                  a.hasAttribute('async') &&
                  !a.hasAttribute('itemprop'))
              )
                break
              return a
            default:
              return a
          }
      } else if (o === 'input' && a.type === 'hidden') {
        var _ = b.name == null ? null : '' + b.name
        if (b.type === 'hidden' && a.getAttribute('name') === _) return a
      } else return a
      if (((a = Ji(a.nextSibling)), a === null)) break
    }
    return null
  }
  function NR(a, o, l) {
    if (o === '') return null
    for (; a.nodeType !== 3; )
      if (
        ((a.nodeType !== 1 || a.nodeName !== 'INPUT' || a.type !== 'hidden') && !l) ||
        ((a = Ji(a.nextSibling)), a === null)
      )
        return null
    return a
  }
  function Ji(a) {
    for (; a != null; a = a.nextSibling) {
      var o = a.nodeType
      if (o === 1 || o === 3) break
      if (o === 8) {
        if (((o = a.data), o === '$' || o === '$!' || o === '$?' || o === 'F!' || o === 'F')) break
        if (o === '/$') return null
      }
    }
    return a
  }
  function nC(a) {
    a = a.previousSibling
    for (var o = 0; a; ) {
      if (a.nodeType === 8) {
        var l = a.data
        if (l === '$' || l === '$!' || l === '$?') {
          if (o === 0) return a
          o--
        } else l === '/$' && o++
      }
      a = a.previousSibling
    }
    return null
  }
  function rC(a, o, l) {
    switch (((o = k0(l)), a)) {
      case 'html':
        if (((a = o.documentElement), !a)) throw Error(r(452))
        return a
      case 'head':
        if (((a = o.head), !a)) throw Error(r(453))
        return a
      case 'body':
        if (((a = o.body), !a)) throw Error(r(454))
        return a
      default:
        throw Error(r(451))
    }
  }
  var Oi = new Map(),
    iC = new Set()
  function U0(a) {
    return typeof a.getRootNode == 'function' ? a.getRootNode() : a.ownerDocument
  }
  var pa = Y.d
  Y.d = { f: IR, r: OR, D: RR, C: DR, L: PR, m: MR, X: UR, S: kR, M: BR }
  function IR() {
    var a = pa.f(),
      o = N0()
    return a || o
  }
  function OR(a) {
    var o = bs(a)
    o !== null && o.tag === 5 && o.type === 'form' ? R3(o) : pa.r(a)
  }
  var rl = typeof document > 'u' ? null : document
  function sC(a, o, l) {
    var h = rl
    if (h && typeof o == 'string' && o) {
      var b = wi(o)
      ;(b = 'link[rel="' + a + '"][href="' + b + '"]'),
        typeof l == 'string' && (b += '[crossorigin="' + l + '"]'),
        iC.has(b) ||
          (iC.add(b),
          (a = { rel: a, crossOrigin: l, href: o }),
          h.querySelector(b) === null &&
            ((o = h.createElement('link')), pr(o, 'link', a), Rn(o), h.head.appendChild(o)))
    }
  }
  function RR(a) {
    pa.D(a), sC('dns-prefetch', a, null)
  }
  function DR(a, o) {
    pa.C(a, o), sC('preconnect', a, o)
  }
  function PR(a, o, l) {
    pa.L(a, o, l)
    var h = rl
    if (h && a && o) {
      var b = 'link[rel="preload"][as="' + wi(o) + '"]'
      o === 'image' && l && l.imageSrcSet
        ? ((b += '[imagesrcset="' + wi(l.imageSrcSet) + '"]'),
          typeof l.imageSizes == 'string' && (b += '[imagesizes="' + wi(l.imageSizes) + '"]'))
        : (b += '[href="' + wi(a) + '"]')
      var _ = b
      switch (o) {
        case 'style':
          _ = il(a)
          break
        case 'script':
          _ = sl(a)
      }
      Oi.has(_) ||
        ((a = V(
          { rel: 'preload', href: o === 'image' && l && l.imageSrcSet ? void 0 : a, as: o },
          l
        )),
        Oi.set(_, a),
        h.querySelector(b) !== null ||
          (o === 'style' && h.querySelector(wf(_))) ||
          (o === 'script' && h.querySelector(Ef(_))) ||
          ((o = h.createElement('link')), pr(o, 'link', a), Rn(o), h.head.appendChild(o)))
    }
  }
  function MR(a, o) {
    pa.m(a, o)
    var l = rl
    if (l && a) {
      var h = o && typeof o.as == 'string' ? o.as : 'script',
        b = 'link[rel="modulepreload"][as="' + wi(h) + '"][href="' + wi(a) + '"]',
        _ = b
      switch (h) {
        case 'audioworklet':
        case 'paintworklet':
        case 'serviceworker':
        case 'sharedworker':
        case 'worker':
        case 'script':
          _ = sl(a)
      }
      if (
        !Oi.has(_) &&
        ((a = V({ rel: 'modulepreload', href: a }, o)), Oi.set(_, a), l.querySelector(b) === null)
      ) {
        switch (h) {
          case 'audioworklet':
          case 'paintworklet':
          case 'serviceworker':
          case 'sharedworker':
          case 'worker':
          case 'script':
            if (l.querySelector(Ef(_))) return
        }
        ;(h = l.createElement('link')), pr(h, 'link', a), Rn(h), l.head.appendChild(h)
      }
    }
  }
  function kR(a, o, l) {
    pa.S(a, o, l)
    var h = rl
    if (h && a) {
      var b = ys(h).hoistableStyles,
        _ = il(a)
      o = o || 'default'
      var U = b.get(_)
      if (!U) {
        var q = { loading: 0, preload: null }
        if ((U = h.querySelector(wf(_)))) q.loading = 5
        else {
          ;(a = V({ rel: 'stylesheet', href: a, 'data-precedence': o }, l)),
            (l = Oi.get(_)) && Qy(a, l)
          var K = (U = h.createElement('link'))
          Rn(K),
            pr(K, 'link', a),
            (K._p = new Promise(function (J, oe) {
              ;(K.onload = J), (K.onerror = oe)
            })),
            K.addEventListener('load', function () {
              q.loading |= 1
            }),
            K.addEventListener('error', function () {
              q.loading |= 2
            }),
            (q.loading |= 4),
            B0(U, o, h)
        }
        ;(U = { type: 'stylesheet', instance: U, count: 1, state: q }), b.set(_, U)
      }
    }
  }
  function UR(a, o) {
    pa.X(a, o)
    var l = rl
    if (l && a) {
      var h = ys(l).hoistableScripts,
        b = sl(a),
        _ = h.get(b)
      _ ||
        ((_ = l.querySelector(Ef(b))),
        _ ||
          ((a = V({ src: a, async: !0 }, o)),
          (o = Oi.get(b)) && Yy(a, o),
          (_ = l.createElement('script')),
          Rn(_),
          pr(_, 'link', a),
          l.head.appendChild(_)),
        (_ = { type: 'script', instance: _, count: 1, state: null }),
        h.set(b, _))
    }
  }
  function BR(a, o) {
    pa.M(a, o)
    var l = rl
    if (l && a) {
      var h = ys(l).hoistableScripts,
        b = sl(a),
        _ = h.get(b)
      _ ||
        ((_ = l.querySelector(Ef(b))),
        _ ||
          ((a = V({ src: a, async: !0, type: 'module' }, o)),
          (o = Oi.get(b)) && Yy(a, o),
          (_ = l.createElement('script')),
          Rn(_),
          pr(_, 'link', a),
          l.head.appendChild(_)),
        (_ = { type: 'script', instance: _, count: 1, state: null }),
        h.set(b, _))
    }
  }
  function aC(a, o, l, h) {
    var b = (b = Ke.current) ? U0(b) : null
    if (!b) throw Error(r(446))
    switch (a) {
      case 'meta':
      case 'title':
        return null
      case 'style':
        return typeof l.precedence == 'string' && typeof l.href == 'string'
          ? ((o = il(l.href)),
            (l = ys(b).hoistableStyles),
            (h = l.get(o)),
            h || ((h = { type: 'style', instance: null, count: 0, state: null }), l.set(o, h)),
            h)
          : { type: 'void', instance: null, count: 0, state: null }
      case 'link':
        if (
          l.rel === 'stylesheet' &&
          typeof l.href == 'string' &&
          typeof l.precedence == 'string'
        ) {
          a = il(l.href)
          var _ = ys(b).hoistableStyles,
            U = _.get(a)
          if (
            (U ||
              ((b = b.ownerDocument || b),
              (U = {
                type: 'stylesheet',
                instance: null,
                count: 0,
                state: { loading: 0, preload: null }
              }),
              _.set(a, U),
              (_ = b.querySelector(wf(a))) && !_._p && ((U.instance = _), (U.state.loading = 5)),
              Oi.has(a) ||
                ((l = {
                  rel: 'preload',
                  as: 'style',
                  href: l.href,
                  crossOrigin: l.crossOrigin,
                  integrity: l.integrity,
                  media: l.media,
                  hrefLang: l.hrefLang,
                  referrerPolicy: l.referrerPolicy
                }),
                Oi.set(a, l),
                _ || LR(b, a, l, U.state))),
            o && h === null)
          )
            throw Error(r(528, ''))
          return U
        }
        if (o && h !== null) throw Error(r(529, ''))
        return null
      case 'script':
        return (
          (o = l.async),
          (l = l.src),
          typeof l == 'string' && o && typeof o != 'function' && typeof o != 'symbol'
            ? ((o = sl(l)),
              (l = ys(b).hoistableScripts),
              (h = l.get(o)),
              h || ((h = { type: 'script', instance: null, count: 0, state: null }), l.set(o, h)),
              h)
            : { type: 'void', instance: null, count: 0, state: null }
        )
      default:
        throw Error(r(444, a))
    }
  }
  function il(a) {
    return 'href="' + wi(a) + '"'
  }
  function wf(a) {
    return 'link[rel="stylesheet"][' + a + ']'
  }
  function oC(a) {
    return V({}, a, { 'data-precedence': a.precedence, precedence: null })
  }
  function LR(a, o, l, h) {
    a.querySelector('link[rel="preload"][as="style"][' + o + ']')
      ? (h.loading = 1)
      : ((o = a.createElement('link')),
        (h.preload = o),
        o.addEventListener('load', function () {
          return (h.loading |= 1)
        }),
        o.addEventListener('error', function () {
          return (h.loading |= 2)
        }),
        pr(o, 'link', l),
        Rn(o),
        a.head.appendChild(o))
  }
  function sl(a) {
    return '[src="' + wi(a) + '"]'
  }
  function Ef(a) {
    return 'script[async]' + a
  }
  function cC(a, o, l) {
    if ((o.count++, o.instance === null))
      switch (o.type) {
        case 'style':
          var h = a.querySelector('style[data-href~="' + wi(l.href) + '"]')
          if (h) return (o.instance = h), Rn(h), h
          var b = V({}, l, {
            'data-href': l.href,
            'data-precedence': l.precedence,
            href: null,
            precedence: null
          })
          return (
            (h = (a.ownerDocument || a).createElement('style')),
            Rn(h),
            pr(h, 'style', b),
            B0(h, l.precedence, a),
            (o.instance = h)
          )
        case 'stylesheet':
          b = il(l.href)
          var _ = a.querySelector(wf(b))
          if (_) return (o.state.loading |= 4), (o.instance = _), Rn(_), _
          ;(h = oC(l)),
            (b = Oi.get(b)) && Qy(h, b),
            (_ = (a.ownerDocument || a).createElement('link')),
            Rn(_)
          var U = _
          return (
            (U._p = new Promise(function (q, K) {
              ;(U.onload = q), (U.onerror = K)
            })),
            pr(_, 'link', h),
            (o.state.loading |= 4),
            B0(_, l.precedence, a),
            (o.instance = _)
          )
        case 'script':
          return (
            (_ = sl(l.src)),
            (b = a.querySelector(Ef(_)))
              ? ((o.instance = b), Rn(b), b)
              : ((h = l),
                (b = Oi.get(_)) && ((h = V({}, l)), Yy(h, b)),
                (a = a.ownerDocument || a),
                (b = a.createElement('script')),
                Rn(b),
                pr(b, 'link', h),
                a.head.appendChild(b),
                (o.instance = b))
          )
        case 'void':
          return null
        default:
          throw Error(r(443, o.type))
      }
    else
      o.type === 'stylesheet' &&
        (o.state.loading & 4) === 0 &&
        ((h = o.instance), (o.state.loading |= 4), B0(h, l.precedence, a))
    return o.instance
  }
  function B0(a, o, l) {
    for (
      var h = l.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),
        b = h.length ? h[h.length - 1] : null,
        _ = b,
        U = 0;
      U < h.length;
      U++
    ) {
      var q = h[U]
      if (q.dataset.precedence === o) _ = q
      else if (_ !== b) break
    }
    _
      ? _.parentNode.insertBefore(a, _.nextSibling)
      : ((o = l.nodeType === 9 ? l.head : l), o.insertBefore(a, o.firstChild))
  }
  function Qy(a, o) {
    a.crossOrigin == null && (a.crossOrigin = o.crossOrigin),
      a.referrerPolicy == null && (a.referrerPolicy = o.referrerPolicy),
      a.title == null && (a.title = o.title)
  }
  function Yy(a, o) {
    a.crossOrigin == null && (a.crossOrigin = o.crossOrigin),
      a.referrerPolicy == null && (a.referrerPolicy = o.referrerPolicy),
      a.integrity == null && (a.integrity = o.integrity)
  }
  var L0 = null
  function uC(a, o, l) {
    if (L0 === null) {
      var h = new Map(),
        b = (L0 = new Map())
      b.set(l, h)
    } else (b = L0), (h = b.get(l)), h || ((h = new Map()), b.set(l, h))
    if (h.has(a)) return h
    for (h.set(a, null), l = l.getElementsByTagName(a), b = 0; b < l.length; b++) {
      var _ = l[b]
      if (
        !(_[Zs] || _[st] || (a === 'link' && _.getAttribute('rel') === 'stylesheet')) &&
        _.namespaceURI !== 'http://www.w3.org/2000/svg'
      ) {
        var U = _.getAttribute(o) || ''
        U = a + U
        var q = h.get(U)
        q ? q.push(_) : h.set(U, [_])
      }
    }
    return h
  }
  function lC(a, o, l) {
    ;(a = a.ownerDocument || a),
      a.head.insertBefore(l, o === 'title' ? a.querySelector('head > title') : null)
  }
  function $R(a, o, l) {
    if (l === 1 || o.itemProp != null) return !1
    switch (a) {
      case 'meta':
      case 'title':
        return !0
      case 'style':
        if (typeof o.precedence != 'string' || typeof o.href != 'string' || o.href === '') break
        return !0
      case 'link':
        if (
          typeof o.rel != 'string' ||
          typeof o.href != 'string' ||
          o.href === '' ||
          o.onLoad ||
          o.onError
        )
          break
        switch (o.rel) {
          case 'stylesheet':
            return (a = o.disabled), typeof o.precedence == 'string' && a == null
          default:
            return !0
        }
      case 'script':
        if (
          o.async &&
          typeof o.async != 'function' &&
          typeof o.async != 'symbol' &&
          !o.onLoad &&
          !o.onError &&
          o.src &&
          typeof o.src == 'string'
        )
          return !0
    }
    return !1
  }
  function dC(a) {
    return !(a.type === 'stylesheet' && (a.state.loading & 3) === 0)
  }
  var Af = null
  function FR() {}
  function jR(a, o, l) {
    if (Af === null) throw Error(r(475))
    var h = Af
    if (
      o.type === 'stylesheet' &&
      (typeof l.media != 'string' || matchMedia(l.media).matches !== !1) &&
      (o.state.loading & 4) === 0
    ) {
      if (o.instance === null) {
        var b = il(l.href),
          _ = a.querySelector(wf(b))
        if (_) {
          ;(a = _._p),
            a !== null &&
              typeof a == 'object' &&
              typeof a.then == 'function' &&
              (h.count++, (h = $0.bind(h)), a.then(h, h)),
            (o.state.loading |= 4),
            (o.instance = _),
            Rn(_)
          return
        }
        ;(_ = a.ownerDocument || a),
          (l = oC(l)),
          (b = Oi.get(b)) && Qy(l, b),
          (_ = _.createElement('link')),
          Rn(_)
        var U = _
        ;(U._p = new Promise(function (q, K) {
          ;(U.onload = q), (U.onerror = K)
        })),
          pr(_, 'link', l),
          (o.instance = _)
      }
      h.stylesheets === null && (h.stylesheets = new Map()),
        h.stylesheets.set(o, a),
        (a = o.state.preload) &&
          (o.state.loading & 3) === 0 &&
          (h.count++,
          (o = $0.bind(h)),
          a.addEventListener('load', o),
          a.addEventListener('error', o))
    }
  }
  function zR() {
    if (Af === null) throw Error(r(475))
    var a = Af
    return (
      a.stylesheets && a.count === 0 && Zy(a, a.stylesheets),
      0 < a.count
        ? function (o) {
            var l = setTimeout(function () {
              if ((a.stylesheets && Zy(a, a.stylesheets), a.unsuspend)) {
                var h = a.unsuspend
                ;(a.unsuspend = null), h()
              }
            }, 6e4)
            return (
              (a.unsuspend = o),
              function () {
                ;(a.unsuspend = null), clearTimeout(l)
              }
            )
          }
        : null
    )
  }
  function $0() {
    if ((this.count--, this.count === 0)) {
      if (this.stylesheets) Zy(this, this.stylesheets)
      else if (this.unsuspend) {
        var a = this.unsuspend
        ;(this.unsuspend = null), a()
      }
    }
  }
  var F0 = null
  function Zy(a, o) {
    ;(a.stylesheets = null),
      a.unsuspend !== null &&
        (a.count++, (F0 = new Map()), o.forEach(qR, a), (F0 = null), $0.call(a))
  }
  function qR(a, o) {
    if (!(o.state.loading & 4)) {
      var l = F0.get(a)
      if (l) var h = l.get(null)
      else {
        ;(l = new Map()), F0.set(a, l)
        for (
          var b = a.querySelectorAll('link[data-precedence],style[data-precedence]'), _ = 0;
          _ < b.length;
          _++
        ) {
          var U = b[_]
          ;(U.nodeName === 'LINK' || U.getAttribute('media') !== 'not all') &&
            (l.set(U.dataset.precedence, U), (h = U))
        }
        h && l.set(null, h)
      }
      ;(b = o.instance),
        (U = b.getAttribute('data-precedence')),
        (_ = l.get(U) || h),
        _ === h && l.set(null, b),
        l.set(U, b),
        this.count++,
        (h = $0.bind(this)),
        b.addEventListener('load', h),
        b.addEventListener('error', h),
        _
          ? _.parentNode.insertBefore(b, _.nextSibling)
          : ((a = a.nodeType === 9 ? a.head : a), a.insertBefore(b, a.firstChild)),
        (o.state.loading |= 4)
    }
  }
  var _f = {
    $$typeof: y,
    Provider: null,
    Consumer: null,
    _currentValue: se,
    _currentValue2: se,
    _threadCount: 0
  }
  function HR(a, o, l, h, b, _, U, q) {
    ;(this.tag = 1),
      (this.containerInfo = a),
      (this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
      (this.timeoutHandle = -1),
      (this.callbackNode =
        this.next =
        this.pendingContext =
        this.context =
        this.cancelPendingCommit =
          null),
      (this.callbackPriority = 0),
      (this.expirationTimes = mn(-1)),
      (this.entangledLanes =
        this.shellSuspendCounter =
        this.errorRecoveryDisabledLanes =
        this.finishedLanes =
        this.expiredLanes =
        this.warmLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = mn(0)),
      (this.hiddenUpdates = mn(null)),
      (this.identifierPrefix = h),
      (this.onUncaughtError = b),
      (this.onCaughtError = _),
      (this.onRecoverableError = U),
      (this.pooledCache = null),
      (this.pooledCacheLanes = 0),
      (this.formState = q),
      (this.incompleteTransitions = new Map())
  }
  function fC(a, o, l, h, b, _, U, q, K, J, oe, le) {
    return (
      (a = new HR(a, o, l, U, q, K, J, le)),
      (o = 1),
      _ === !0 && (o |= 24),
      (_ = Ni(3, null, null, o)),
      (a.current = _),
      (_.stateNode = a),
      (o = Ib()),
      o.refCount++,
      (a.pooledCache = o),
      o.refCount++,
      (_.memoizedState = { element: h, isDehydrated: l, cache: o }),
      uy(_),
      a
    )
  }
  function hC(a) {
    return a ? ((a = Bu), a) : Bu
  }
  function pC(a, o, l, h, b, _) {
    ;(b = hC(b)),
      h.context === null ? (h.context = b) : (h.pendingContext = b),
      (h = Za(o)),
      (h.payload = { element: l }),
      (_ = _ === void 0 ? null : _),
      _ !== null && (h.callback = _),
      (l = Xa(a, h, o)),
      l !== null && (kr(l, a, o), af(l, a, o))
  }
  function gC(a, o) {
    if (((a = a.memoizedState), a !== null && a.dehydrated !== null)) {
      var l = a.retryLane
      a.retryLane = l !== 0 && l < o ? l : o
    }
  }
  function Xy(a, o) {
    gC(a, o), (a = a.alternate) && gC(a, o)
  }
  function mC(a) {
    if (a.tag === 13) {
      var o = Ha(a, 67108864)
      o !== null && kr(o, a, 67108864), Xy(a, 67108864)
    }
  }
  var j0 = !0
  function GR(a, o, l, h) {
    var b = j.T
    j.T = null
    var _ = Y.p
    try {
      ;(Y.p = 2), Jy(a, o, l, h)
    } finally {
      ;(Y.p = _), (j.T = b)
    }
  }
  function VR(a, o, l, h) {
    var b = j.T
    j.T = null
    var _ = Y.p
    try {
      ;(Y.p = 8), Jy(a, o, l, h)
    } finally {
      ;(Y.p = _), (j.T = b)
    }
  }
  function Jy(a, o, l, h) {
    if (j0) {
      var b = ev(h)
      if (b === null) jy(a, o, h, z0, l), yC(a, h)
      else if (WR(b, a, o, l, h)) h.stopPropagation()
      else if ((yC(a, h), o & 4 && -1 < KR.indexOf(a))) {
        for (; b !== null; ) {
          var _ = bs(b)
          if (_ !== null)
            switch (_.tag) {
              case 3:
                if (((_ = _.stateNode), _.current.memoizedState.isDehydrated)) {
                  var U = Ht(_.pendingLanes)
                  if (U !== 0) {
                    var q = _
                    for (q.pendingLanes |= 2, q.entangledLanes |= 2; U; ) {
                      var K = 1 << (31 - bt(U))
                      ;(q.entanglements[1] |= K), (U &= ~K)
                    }
                    Cs(_), (Cn & 6) === 0 && ((S0 = Je() + 500), bf(0))
                  }
                }
                break
              case 13:
                ;(q = Ha(_, 2)), q !== null && kr(q, _, 2), N0(), Xy(_, 2)
            }
          if (((_ = ev(h)), _ === null && jy(a, o, h, z0, l), _ === b)) break
          b = _
        }
        b !== null && h.stopPropagation()
      } else jy(a, o, h, null, l)
    }
  }
  function ev(a) {
    return (a = ab(a)), tv(a)
  }
  var z0 = null
  function tv(a) {
    if (((z0 = null), (a = Wi(a)), a !== null)) {
      var o = F(a)
      if (o === null) a = null
      else {
        var l = o.tag
        if (l === 13) {
          if (((a = P(o)), a !== null)) return a
          a = null
        } else if (l === 3) {
          if (o.stateNode.current.memoizedState.isDehydrated)
            return o.tag === 3 ? o.stateNode.containerInfo : null
          a = null
        } else o !== a && (a = null)
      }
    }
    return (z0 = a), null
  }
  function bC(a) {
    switch (a) {
      case 'beforetoggle':
      case 'cancel':
      case 'click':
      case 'close':
      case 'contextmenu':
      case 'copy':
      case 'cut':
      case 'auxclick':
      case 'dblclick':
      case 'dragend':
      case 'dragstart':
      case 'drop':
      case 'focusin':
      case 'focusout':
      case 'input':
      case 'invalid':
      case 'keydown':
      case 'keypress':
      case 'keyup':
      case 'mousedown':
      case 'mouseup':
      case 'paste':
      case 'pause':
      case 'play':
      case 'pointercancel':
      case 'pointerdown':
      case 'pointerup':
      case 'ratechange':
      case 'reset':
      case 'resize':
      case 'seeked':
      case 'submit':
      case 'toggle':
      case 'touchcancel':
      case 'touchend':
      case 'touchstart':
      case 'volumechange':
      case 'change':
      case 'selectionchange':
      case 'textInput':
      case 'compositionstart':
      case 'compositionend':
      case 'compositionupdate':
      case 'beforeblur':
      case 'afterblur':
      case 'beforeinput':
      case 'blur':
      case 'fullscreenchange':
      case 'focus':
      case 'hashchange':
      case 'popstate':
      case 'select':
      case 'selectstart':
        return 2
      case 'drag':
      case 'dragenter':
      case 'dragexit':
      case 'dragleave':
      case 'dragover':
      case 'mousemove':
      case 'mouseout':
      case 'mouseover':
      case 'pointermove':
      case 'pointerout':
      case 'pointerover':
      case 'scroll':
      case 'touchmove':
      case 'wheel':
      case 'mouseenter':
      case 'mouseleave':
      case 'pointerenter':
      case 'pointerleave':
        return 8
      case 'message':
        switch (Rt()) {
          case Ki:
            return 2
          case qt:
            return 8
          case Zt:
          case _u:
            return 32
          case dn:
            return 268435456
          default:
            return 32
        }
      default:
        return 32
    }
  }
  var nv = !1,
    so = null,
    ao = null,
    oo = null,
    Cf = new Map(),
    Sf = new Map(),
    co = [],
    KR =
      'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset'.split(
        ' '
      )
  function yC(a, o) {
    switch (a) {
      case 'focusin':
      case 'focusout':
        so = null
        break
      case 'dragenter':
      case 'dragleave':
        ao = null
        break
      case 'mouseover':
      case 'mouseout':
        oo = null
        break
      case 'pointerover':
      case 'pointerout':
        Cf.delete(o.pointerId)
        break
      case 'gotpointercapture':
      case 'lostpointercapture':
        Sf.delete(o.pointerId)
    }
  }
  function Tf(a, o, l, h, b, _) {
    return a === null || a.nativeEvent !== _
      ? ((a = {
          blockedOn: o,
          domEventName: l,
          eventSystemFlags: h,
          nativeEvent: _,
          targetContainers: [b]
        }),
        o !== null && ((o = bs(o)), o !== null && mC(o)),
        a)
      : ((a.eventSystemFlags |= h),
        (o = a.targetContainers),
        b !== null && o.indexOf(b) === -1 && o.push(b),
        a)
  }
  function WR(a, o, l, h, b) {
    switch (o) {
      case 'focusin':
        return (so = Tf(so, a, o, l, h, b)), !0
      case 'dragenter':
        return (ao = Tf(ao, a, o, l, h, b)), !0
      case 'mouseover':
        return (oo = Tf(oo, a, o, l, h, b)), !0
      case 'pointerover':
        var _ = b.pointerId
        return Cf.set(_, Tf(Cf.get(_) || null, a, o, l, h, b)), !0
      case 'gotpointercapture':
        return (_ = b.pointerId), Sf.set(_, Tf(Sf.get(_) || null, a, o, l, h, b)), !0
    }
    return !1
  }
  function vC(a) {
    var o = Wi(a.target)
    if (o !== null) {
      var l = F(o)
      if (l !== null) {
        if (((o = l.tag), o === 13)) {
          if (((o = P(l)), o !== null)) {
            ;(a.blockedOn = o),
              Fp(a.priority, function () {
                if (l.tag === 13) {
                  var h = ui(),
                    b = Ha(l, h)
                  b !== null && kr(b, l, h), Xy(l, h)
                }
              })
            return
          }
        } else if (o === 3 && l.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = l.tag === 3 ? l.stateNode.containerInfo : null
          return
        }
      }
    }
    a.blockedOn = null
  }
  function q0(a) {
    if (a.blockedOn !== null) return !1
    for (var o = a.targetContainers; 0 < o.length; ) {
      var l = ev(a.nativeEvent)
      if (l === null) {
        l = a.nativeEvent
        var h = new l.constructor(l.type, l)
        ;(sb = h), l.target.dispatchEvent(h), (sb = null)
      } else return (o = bs(l)), o !== null && mC(o), (a.blockedOn = l), !1
      o.shift()
    }
    return !0
  }
  function wC(a, o, l) {
    q0(a) && l.delete(o)
  }
  function QR() {
    ;(nv = !1),
      so !== null && q0(so) && (so = null),
      ao !== null && q0(ao) && (ao = null),
      oo !== null && q0(oo) && (oo = null),
      Cf.forEach(wC),
      Sf.forEach(wC)
  }
  function H0(a, o) {
    a.blockedOn === o &&
      ((a.blockedOn = null),
      nv || ((nv = !0), t.unstable_scheduleCallback(t.unstable_NormalPriority, QR)))
  }
  var G0 = null
  function EC(a) {
    G0 !== a &&
      ((G0 = a),
      t.unstable_scheduleCallback(t.unstable_NormalPriority, function () {
        G0 === a && (G0 = null)
        for (var o = 0; o < a.length; o += 3) {
          var l = a[o],
            h = a[o + 1],
            b = a[o + 2]
          if (typeof h != 'function') {
            if (tv(h || l) === null) continue
            break
          }
          var _ = bs(l)
          _ !== null &&
            (a.splice(o, 3),
            (o -= 3),
            Gb(_, { pending: !0, data: b, method: l.method, action: h }, h, b))
        }
      }))
  }
  function xf(a) {
    function o(K) {
      return H0(K, a)
    }
    so !== null && H0(so, a),
      ao !== null && H0(ao, a),
      oo !== null && H0(oo, a),
      Cf.forEach(o),
      Sf.forEach(o)
    for (var l = 0; l < co.length; l++) {
      var h = co[l]
      h.blockedOn === a && (h.blockedOn = null)
    }
    for (; 0 < co.length && ((l = co[0]), l.blockedOn === null); )
      vC(l), l.blockedOn === null && co.shift()
    if (((l = (a.ownerDocument || a).$$reactFormReplay), l != null))
      for (h = 0; h < l.length; h += 3) {
        var b = l[h],
          _ = l[h + 1],
          U = b[dr] || null
        if (typeof _ == 'function') U || EC(l)
        else if (U) {
          var q = null
          if (_ && _.hasAttribute('formAction')) {
            if (((b = _), (U = _[dr] || null))) q = U.formAction
            else if (tv(b) !== null) continue
          } else q = U.action
          typeof q == 'function' ? (l[h + 1] = q) : (l.splice(h, 3), (h -= 3)), EC(l)
        }
      }
  }
  function rv(a) {
    this._internalRoot = a
  }
  ;(V0.prototype.render = rv.prototype.render =
    function (a) {
      var o = this._internalRoot
      if (o === null) throw Error(r(409))
      var l = o.current,
        h = ui()
      pC(l, h, a, o, null, null)
    }),
    (V0.prototype.unmount = rv.prototype.unmount =
      function () {
        var a = this._internalRoot
        if (a !== null) {
          this._internalRoot = null
          var o = a.containerInfo
          a.tag === 0 && el(), pC(a.current, 2, null, a, null, null), N0(), (o[Xt] = null)
        }
      })
  function V0(a) {
    this._internalRoot = a
  }
  V0.prototype.unstable_scheduleHydration = function (a) {
    if (a) {
      var o = An()
      a = { blockedOn: null, target: a, priority: o }
      for (var l = 0; l < co.length && o !== 0 && o < co[l].priority; l++);
      co.splice(l, 0, a), l === 0 && vC(a)
    }
  }
  var AC = e.version
  if (AC !== '19.0.0') throw Error(r(527, AC, '19.0.0'))
  Y.findDOMNode = function (a) {
    var o = a._reactInternals
    if (o === void 0)
      throw typeof a.render == 'function'
        ? Error(r(188))
        : ((a = Object.keys(a).join(',')), Error(r(268, a)))
    return (a = B(o)), (a = a !== null ? Z(a) : null), (a = a === null ? null : a.stateNode), a
  }
  var YR = {
    bundleType: 0,
    version: '19.0.0',
    rendererPackageName: 'react-dom',
    currentDispatcherRef: j,
    findFiberByHostInstance: Wi,
    reconcilerVersion: '19.0.0'
  }
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') {
    var K0 = __REACT_DEVTOOLS_GLOBAL_HOOK__
    if (!K0.isDisabled && K0.supportsFiber)
      try {
        ;(rn = K0.inject(YR)), (mt = K0)
      } catch {}
  }
  return (
    (If.createRoot = function (a, o) {
      if (!i(a)) throw Error(r(299))
      var l = !1,
        h = '',
        b = $3,
        _ = F3,
        U = j3,
        q = null
      return (
        o != null &&
          (o.unstable_strictMode === !0 && (l = !0),
          o.identifierPrefix !== void 0 && (h = o.identifierPrefix),
          o.onUncaughtError !== void 0 && (b = o.onUncaughtError),
          o.onCaughtError !== void 0 && (_ = o.onCaughtError),
          o.onRecoverableError !== void 0 && (U = o.onRecoverableError),
          o.unstable_transitionCallbacks !== void 0 && (q = o.unstable_transitionCallbacks)),
        (o = fC(a, 1, !1, null, null, l, h, b, _, U, q, null)),
        (a[Xt] = o.current),
        Fy(a.nodeType === 8 ? a.parentNode : a),
        new rv(o)
      )
    }),
    (If.hydrateRoot = function (a, o, l) {
      if (!i(a)) throw Error(r(299))
      var h = !1,
        b = '',
        _ = $3,
        U = F3,
        q = j3,
        K = null,
        J = null
      return (
        l != null &&
          (l.unstable_strictMode === !0 && (h = !0),
          l.identifierPrefix !== void 0 && (b = l.identifierPrefix),
          l.onUncaughtError !== void 0 && (_ = l.onUncaughtError),
          l.onCaughtError !== void 0 && (U = l.onCaughtError),
          l.onRecoverableError !== void 0 && (q = l.onRecoverableError),
          l.unstable_transitionCallbacks !== void 0 && (K = l.unstable_transitionCallbacks),
          l.formState !== void 0 && (J = l.formState)),
        (o = fC(a, 1, !0, o, l ?? null, h, b, _, U, q, K, J)),
        (o.context = hC(null)),
        (l = o.current),
        (h = ui()),
        (b = Za(h)),
        (b.callback = null),
        Xa(l, b, h),
        (o.current.lanes = h),
        za(o, h),
        Cs(o),
        (a[Xt] = o.current),
        Fy(a),
        new V0(o)
      )
    }),
    (If.version = '19.0.0'),
    If
  )
}
var PC
function o7() {
  if (PC) return ov.exports
  PC = 1
  function t() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)
      } catch (e) {
        console.error(e)
      }
  }
  return t(), (ov.exports = a7()), ov.exports
}
var c7 = o7()
const u7 = Symbol(),
  BE = Symbol(),
  Of = 'a',
  oh = 'w'
let l7 = (t, e) => new Proxy(t, e)
const sw = Object.getPrototypeOf,
  aw = new WeakMap(),
  z8 = t => t && (aw.has(t) ? aw.get(t) : sw(t) === Object.prototype || sw(t) === Array.prototype),
  jg = t => typeof t == 'object' && t !== null,
  d7 = t => {
    if (Array.isArray(t)) return Array.from(t)
    const e = Object.getOwnPropertyDescriptors(t)
    return (
      Object.values(e).forEach(n => {
        n.configurable = !0
      }),
      Object.create(sw(t), e)
    )
  },
  LE = t => t[BE] || t,
  q8 = (t, e, n, r) => {
    if (!z8(t)) return t
    let i = r && r.get(t)
    if (!i) {
      const f = LE(t)
      ;(i = (d =>
        Object.values(Object.getOwnPropertyDescriptors(d)).some(
          p => !p.configurable && !p.writable
        ))(f)
        ? [f, d7(f)]
        : [f]),
        r == null || r.set(t, i)
    }
    const [s, c] = i
    let u = n && n.get(s)
    return (
      (u && u[1].f === !!c) ||
        ((u = ((f, d) => {
          const p = { f: d }
          let g = !1
          const m = (A, E) => {
              if (!g) {
                let x = p[Of].get(f)
                if ((x || ((x = {}), p[Of].set(f, x)), A === oh)) x[oh] = !0
                else {
                  let O = x[A]
                  O || ((O = new Set()), (x[A] = O)), O.add(E)
                }
              }
            },
            y = {
              get: (A, E) => (E === BE ? f : (m('k', E), q8(Reflect.get(A, E), p[Of], p.c, p.t))),
              has: (A, E) =>
                E === u7 ? ((g = !0), p[Of].delete(f), !0) : (m('h', E), Reflect.has(A, E)),
              getOwnPropertyDescriptor: (A, E) => (
                m('o', E), Reflect.getOwnPropertyDescriptor(A, E)
              ),
              ownKeys: A => (m(oh), Reflect.ownKeys(A))
            }
          return d && (y.set = y.deleteProperty = () => !1), [y, p]
        })(s, !!c)),
        (u[1].p = l7(c || s, u[0])),
        n && n.set(s, u)),
      (u[1][Of] = e),
      (u[1].c = n),
      (u[1].t = r),
      u[1].p
    )
  },
  H8 = (t, e, n, r, i = Object.is) => {
    if (i(t, e)) return !1
    if (!jg(t) || !jg(e)) return !0
    const s = n.get(LE(t))
    if (!s) return !0
    if (r) {
      const u = r.get(t)
      if (u && u.n === e) return u.g
      r.set(t, { n: e, g: !1 })
    }
    let c = null
    try {
      for (const u of s.h || []) if (((c = Reflect.has(t, u) !== Reflect.has(e, u)), c)) return c
      if (s[oh] === !0) {
        if (
          ((c = ((u, f) => {
            const d = Reflect.ownKeys(u),
              p = Reflect.ownKeys(f)
            return d.length !== p.length || d.some((g, m) => g !== p[m])
          })(t, e)),
          c)
        )
          return c
      } else
        for (const u of s.o || [])
          if (
            ((c =
              !!Reflect.getOwnPropertyDescriptor(t, u) != !!Reflect.getOwnPropertyDescriptor(e, u)),
            c)
          )
            return c
      for (const u of s.k || []) if (((c = H8(t[u], e[u], n, r, i)), c)) return c
      return c === null && (c = !0), c
    } finally {
      r && r.set(t, { n: e, g: c })
    }
  },
  f7 = t => (z8(t) && t[BE]) || null,
  MC = (t, e = !0) => {
    aw.set(t, e)
  },
  h7 = (t, e, n) => {
    const r = [],
      i = new WeakSet(),
      s = (c, u) => {
        if (i.has(c)) return
        jg(c) && i.add(c)
        const f = jg(c) && e.get(LE(c))
        if (f) {
          var d, p
          if (
            ((d = f.h) == null ||
              d.forEach(m => {
                const y = `:has(${String(m)})`
                r.push(u ? [...u, y] : [y])
              }),
            f[oh] === !0)
          ) {
            const m = ':ownKeys'
            r.push(u ? [...u, m] : [m])
          } else {
            var g
            ;(g = f.o) == null ||
              g.forEach(m => {
                const y = `:hasOwn(${String(m)})`
                r.push(u ? [...u, y] : [y])
              })
          }
          ;(p = f.k) == null ||
            p.forEach(m => {
              !('value' in (Object.getOwnPropertyDescriptor(c, m) || {})) ||
                s(c[m], u ? [...u, m] : [m])
            })
        } else u && r.push(u)
      }
    return s(t), r
  },
  zg = {},
  dv = t => typeof t == 'object' && t !== null,
  wo = new WeakMap(),
  Jf = new WeakSet(),
  p7 = (
    t = Object.is,
    e = (d, p) => new Proxy(d, p),
    n = d =>
      dv(d) &&
      !Jf.has(d) &&
      (Array.isArray(d) || !(Symbol.iterator in d)) &&
      !(d instanceof WeakMap) &&
      !(d instanceof WeakSet) &&
      !(d instanceof Error) &&
      !(d instanceof Number) &&
      !(d instanceof Date) &&
      !(d instanceof String) &&
      !(d instanceof RegExp) &&
      !(d instanceof ArrayBuffer),
    r = d => {
      switch (d.status) {
        case 'fulfilled':
          return d.value
        case 'rejected':
          throw d.reason
        default:
          throw d
      }
    },
    i = new WeakMap(),
    s = (d, p, g = r) => {
      const m = i.get(d)
      if ((m == null ? void 0 : m[0]) === p) return m[1]
      const y = Array.isArray(d) ? [] : Object.create(Object.getPrototypeOf(d))
      return (
        MC(y, !0),
        i.set(d, [p, y]),
        Reflect.ownKeys(d).forEach(A => {
          if (Object.getOwnPropertyDescriptor(y, A)) return
          const E = Reflect.get(d, A),
            { enumerable: x } = Reflect.getOwnPropertyDescriptor(d, A),
            O = { value: E, enumerable: x, configurable: !0 }
          if (Jf.has(E)) MC(E, !1)
          else if (E instanceof Promise) delete O.value, (O.get = () => g(E))
          else if (wo.has(E)) {
            const [I, M] = wo.get(E)
            O.value = s(I, M(), g)
          }
          Object.defineProperty(y, A, O)
        }),
        Object.preventExtensions(y)
      )
    },
    c = new WeakMap(),
    u = [1, 1],
    f = d => {
      if (!dv(d)) throw new Error('object required')
      const p = c.get(d)
      if (p) return p
      let g = u[0]
      const m = new Set(),
        y = (j, V = ++u[0]) => {
          g !== V && ((g = V), m.forEach(L => L(j, V)))
        }
      let A = u[1]
      const E = (j = ++u[1]) => (
          A !== j &&
            !m.size &&
            ((A = j),
            O.forEach(([V]) => {
              const L = V[1](j)
              L > g && (g = L)
            })),
          g
        ),
        x = j => (V, L) => {
          const v = [...V]
          ;(v[1] = [j, ...v[1]]), y(v, L)
        },
        O = new Map(),
        I = (j, V) => {
          if ((zg ? 'production' : void 0) !== 'production' && O.has(j))
            throw new Error('prop listener already exists')
          if (m.size) {
            const L = V[3](x(j))
            O.set(j, [V, L])
          } else O.set(j, [V])
        },
        M = j => {
          var V
          const L = O.get(j)
          L && (O.delete(j), (V = L[1]) == null || V.call(L))
        },
        $ = j => (
          m.add(j),
          m.size === 1 &&
            O.forEach(([L, v], C) => {
              if ((zg ? 'production' : void 0) !== 'production' && v)
                throw new Error('remove already exists')
              const N = L[3](x(C))
              O.set(C, [L, N])
            }),
          () => {
            m.delete(j),
              m.size === 0 &&
                O.forEach(([L, v], C) => {
                  v && (v(), O.set(C, [L]))
                })
          }
        ),
        D = Array.isArray(d) ? [] : Object.create(Object.getPrototypeOf(d)),
        z = e(D, {
          deleteProperty(j, V) {
            const L = Reflect.get(j, V)
            M(V)
            const v = Reflect.deleteProperty(j, V)
            return v && y(['delete', [V], L]), v
          },
          set(j, V, L, v) {
            const C = Reflect.has(j, V),
              N = Reflect.get(j, V, v)
            if (C && (t(N, L) || (c.has(L) && t(N, c.get(L))))) return !0
            M(V), dv(L) && (L = f7(L) || L)
            let T = L
            if (L instanceof Promise)
              L.then(S => {
                ;(L.status = 'fulfilled'), (L.value = S), y(['resolve', [V], S])
              }).catch(S => {
                ;(L.status = 'rejected'), (L.reason = S), y(['reject', [V], S])
              })
            else {
              !wo.has(L) && n(L) && (T = f(L))
              const S = !Jf.has(T) && wo.get(T)
              S && I(V, S)
            }
            return Reflect.set(j, V, T, v), y(['set', [V], L, N]), !0
          }
        })
      c.set(d, z)
      const G = [D, E, s, $]
      return (
        wo.set(z, G),
        Reflect.ownKeys(d).forEach(j => {
          const V = Object.getOwnPropertyDescriptor(d, j)
          'value' in V && ((z[j] = d[j]), delete V.value, delete V.writable),
            Object.defineProperty(D, j, V)
        }),
        z
      )
    }
  ) => [f, wo, Jf, t, e, n, r, i, s, c, u],
  [g7] = p7()
function gn(t = {}) {
  return g7(t)
}
function Rr(t, e, n) {
  const r = wo.get(t)
  ;(zg ? 'production' : void 0) !== 'production' && !r && console.warn('Please use proxy object')
  let i
  const s = [],
    c = r[3]
  let u = !1
  const d = c(p => {
    s.push(p),
      i ||
        (i = Promise.resolve().then(() => {
          ;(i = void 0), u && e(s.splice(0))
        }))
  })
  return (
    (u = !0),
    () => {
      ;(u = !1), d()
    }
  )
}
function Yc(t, e) {
  const n = wo.get(t)
  ;(zg ? 'production' : void 0) !== 'production' && !n && console.warn('Please use proxy object')
  const [r, i, s] = n
  return s(r, i(), e)
}
function Zc(t) {
  return Jf.add(t), t
}
function zr(t, e, n, r) {
  let i = t[e]
  return Rr(t, () => {
    const s = t[e]
    Object.is(i, s) || n((i = s))
  })
}
function m7(t) {
  const e = gn({
    data: Array.from([]),
    has(n) {
      return this.data.some(r => r[0] === n)
    },
    set(n, r) {
      const i = this.data.find(s => s[0] === n)
      return i ? (i[1] = r) : this.data.push([n, r]), this
    },
    get(n) {
      var r
      return (r = this.data.find(i => i[0] === n)) == null ? void 0 : r[1]
    },
    delete(n) {
      const r = this.data.findIndex(i => i[0] === n)
      return r === -1 ? !1 : (this.data.splice(r, 1), !0)
    },
    clear() {
      this.data.splice(0)
    },
    get size() {
      return this.data.length
    },
    toJSON() {
      return new Map(this.data)
    },
    forEach(n) {
      this.data.forEach(r => {
        n(r[1], r[0], this)
      })
    },
    keys() {
      return this.data.map(n => n[0]).values()
    },
    values() {
      return this.data.map(n => n[1]).values()
    },
    entries() {
      return new Map(this.data).entries()
    },
    get [Symbol.toStringTag]() {
      return 'Map'
    },
    [Symbol.iterator]() {
      return this.entries()
    }
  })
  return (
    Object.defineProperties(e, {
      data: { enumerable: !1 },
      size: { enumerable: !1 },
      toJSON: { enumerable: !1 }
    }),
    Object.seal(e),
    e
  )
}
const yh = {
  caipNetworkIdToNumber(t) {
    return t ? Number(t.split(':')[1]) : void 0
  },
  parseEvmChainId(t) {
    return typeof t == 'string' ? this.caipNetworkIdToNumber(t) : t
  },
  getNetworksByNamespace(t, e) {
    return (t == null ? void 0 : t.filter(n => n.chainNamespace === e)) || []
  },
  getFirstNetworkByNamespace(t, e) {
    return this.getNetworksByNamespace(t, e)[0]
  }
}
var b7 = 20,
  y7 = 1,
  md = 1e6,
  v7 = 1e6,
  w7 = -7,
  E7 = 21,
  A7 = !1,
  dp = '[big.js] ',
  gu = dp + 'Invalid ',
  Tm = gu + 'decimal places',
  _7 = gu + 'rounding mode',
  G8 = dp + 'Division by zero',
  jt = {},
  js = void 0,
  C7 = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i
function V8() {
  function t(e) {
    var n = this
    if (!(n instanceof t)) return e === js ? V8() : new t(e)
    if (e instanceof t) (n.s = e.s), (n.e = e.e), (n.c = e.c.slice())
    else {
      if (typeof e != 'string') {
        if (t.strict === !0 && typeof e != 'bigint') throw TypeError(gu + 'value')
        e = e === 0 && 1 / e < 0 ? '-0' : String(e)
      }
      S7(n, e)
    }
    n.constructor = t
  }
  return (
    (t.prototype = jt),
    (t.DP = b7),
    (t.RM = y7),
    (t.NE = w7),
    (t.PE = E7),
    (t.strict = A7),
    (t.roundDown = 0),
    (t.roundHalfUp = 1),
    (t.roundHalfEven = 2),
    (t.roundUp = 3),
    t
  )
}
function S7(t, e) {
  var n, r, i
  if (!C7.test(e)) throw Error(gu + 'number')
  for (
    t.s = e.charAt(0) == '-' ? ((e = e.slice(1)), -1) : 1,
      (n = e.indexOf('.')) > -1 && (e = e.replace('.', '')),
      (r = e.search(/e/i)) > 0
        ? (n < 0 && (n = r), (n += +e.slice(r + 1)), (e = e.substring(0, r)))
        : n < 0 && (n = e.length),
      i = e.length,
      r = 0;
    r < i && e.charAt(r) == '0';

  )
    ++r
  if (r == i) t.c = [(t.e = 0)]
  else {
    for (; i > 0 && e.charAt(--i) == '0'; );
    for (t.e = n - r - 1, t.c = [], n = 0; r <= i; ) t.c[n++] = +e.charAt(r++)
  }
  return t
}
function mu(t, e, n, r) {
  var i = t.c
  if ((n === js && (n = t.constructor.RM), n !== 0 && n !== 1 && n !== 2 && n !== 3))
    throw Error(_7)
  if (e < 1)
    (r =
      (n === 3 && (r || !!i[0])) ||
      (e === 0 &&
        ((n === 1 && i[0] >= 5) || (n === 2 && (i[0] > 5 || (i[0] === 5 && (r || i[1] !== js))))))),
      (i.length = 1),
      r ? ((t.e = t.e - e + 1), (i[0] = 1)) : (i[0] = t.e = 0)
  else if (e < i.length) {
    if (
      ((r =
        (n === 1 && i[e] >= 5) ||
        (n === 2 && (i[e] > 5 || (i[e] === 5 && (r || i[e + 1] !== js || i[e - 1] & 1)))) ||
        (n === 3 && (r || !!i[0]))),
      (i.length = e),
      r)
    ) {
      for (; ++i[--e] > 9; )
        if (((i[e] = 0), e === 0)) {
          ++t.e, i.unshift(1)
          break
        }
    }
    for (e = i.length; !i[--e]; ) i.pop()
  }
  return t
}
function bu(t, e, n) {
  var r = t.e,
    i = t.c.join(''),
    s = i.length
  if (e) i = i.charAt(0) + (s > 1 ? '.' + i.slice(1) : '') + (r < 0 ? 'e' : 'e+') + r
  else if (r < 0) {
    for (; ++r; ) i = '0' + i
    i = '0.' + i
  } else if (r > 0)
    if (++r > s) for (r -= s; r--; ) i += '0'
    else r < s && (i = i.slice(0, r) + '.' + i.slice(r))
  else s > 1 && (i = i.charAt(0) + '.' + i.slice(1))
  return t.s < 0 && n ? '-' + i : i
}
jt.abs = function () {
  var t = new this.constructor(this)
  return (t.s = 1), t
}
jt.cmp = function (t) {
  var e,
    n = this,
    r = n.c,
    i = (t = new n.constructor(t)).c,
    s = n.s,
    c = t.s,
    u = n.e,
    f = t.e
  if (!r[0] || !i[0]) return r[0] ? s : i[0] ? -c : 0
  if (s != c) return s
  if (((e = s < 0), u != f)) return (u > f) ^ e ? 1 : -1
  for (c = (u = r.length) < (f = i.length) ? u : f, s = -1; ++s < c; )
    if (r[s] != i[s]) return (r[s] > i[s]) ^ e ? 1 : -1
  return u == f ? 0 : (u > f) ^ e ? 1 : -1
}
jt.div = function (t) {
  var e = this,
    n = e.constructor,
    r = e.c,
    i = (t = new n(t)).c,
    s = e.s == t.s ? 1 : -1,
    c = n.DP
  if (c !== ~~c || c < 0 || c > md) throw Error(Tm)
  if (!i[0]) throw Error(G8)
  if (!r[0]) return (t.s = s), (t.c = [(t.e = 0)]), t
  var u,
    f,
    d,
    p,
    g,
    m = i.slice(),
    y = (u = i.length),
    A = r.length,
    E = r.slice(0, u),
    x = E.length,
    O = t,
    I = (O.c = []),
    M = 0,
    $ = c + (O.e = e.e - t.e) + 1
  for (O.s = s, s = $ < 0 ? 0 : $, m.unshift(0); x++ < u; ) E.push(0)
  do {
    for (d = 0; d < 10; d++) {
      if (u != (x = E.length)) p = u > x ? 1 : -1
      else
        for (g = -1, p = 0; ++g < u; )
          if (i[g] != E[g]) {
            p = i[g] > E[g] ? 1 : -1
            break
          }
      if (p < 0) {
        for (f = x == u ? i : m; x; ) {
          if (E[--x] < f[x]) {
            for (g = x; g && !E[--g]; ) E[g] = 9
            --E[g], (E[x] += 10)
          }
          E[x] -= f[x]
        }
        for (; !E[0]; ) E.shift()
      } else break
    }
    ;(I[M++] = p ? d : ++d), E[0] && p ? (E[x] = r[y] || 0) : (E = [r[y]])
  } while ((y++ < A || E[0] !== js) && s--)
  return !I[0] && M != 1 && (I.shift(), O.e--, $--), M > $ && mu(O, $, n.RM, E[0] !== js), O
}
jt.eq = function (t) {
  return this.cmp(t) === 0
}
jt.gt = function (t) {
  return this.cmp(t) > 0
}
jt.gte = function (t) {
  return this.cmp(t) > -1
}
jt.lt = function (t) {
  return this.cmp(t) < 0
}
jt.lte = function (t) {
  return this.cmp(t) < 1
}
jt.minus = jt.sub = function (t) {
  var e,
    n,
    r,
    i,
    s = this,
    c = s.constructor,
    u = s.s,
    f = (t = new c(t)).s
  if (u != f) return (t.s = -f), s.plus(t)
  var d = s.c.slice(),
    p = s.e,
    g = t.c,
    m = t.e
  if (!d[0] || !g[0]) return g[0] ? (t.s = -f) : d[0] ? (t = new c(s)) : (t.s = 1), t
  if ((u = p - m)) {
    for ((i = u < 0) ? ((u = -u), (r = d)) : ((m = p), (r = g)), r.reverse(), f = u; f--; )
      r.push(0)
    r.reverse()
  } else
    for (n = ((i = d.length < g.length) ? d : g).length, u = f = 0; f < n; f++)
      if (d[f] != g[f]) {
        i = d[f] < g[f]
        break
      }
  if ((i && ((r = d), (d = g), (g = r), (t.s = -t.s)), (f = (n = g.length) - (e = d.length)) > 0))
    for (; f--; ) d[e++] = 0
  for (f = e; n > u; ) {
    if (d[--n] < g[n]) {
      for (e = n; e && !d[--e]; ) d[e] = 9
      --d[e], (d[n] += 10)
    }
    d[n] -= g[n]
  }
  for (; d[--f] === 0; ) d.pop()
  for (; d[0] === 0; ) d.shift(), --m
  return d[0] || ((t.s = 1), (d = [(m = 0)])), (t.c = d), (t.e = m), t
}
jt.mod = function (t) {
  var e,
    n = this,
    r = n.constructor,
    i = n.s,
    s = (t = new r(t)).s
  if (!t.c[0]) throw Error(G8)
  return (
    (n.s = t.s = 1),
    (e = t.cmp(n) == 1),
    (n.s = i),
    (t.s = s),
    e
      ? new r(n)
      : ((i = r.DP),
        (s = r.RM),
        (r.DP = r.RM = 0),
        (n = n.div(t)),
        (r.DP = i),
        (r.RM = s),
        this.minus(n.times(t)))
  )
}
jt.neg = function () {
  var t = new this.constructor(this)
  return (t.s = -t.s), t
}
jt.plus = jt.add = function (t) {
  var e,
    n,
    r,
    i = this,
    s = i.constructor
  if (((t = new s(t)), i.s != t.s)) return (t.s = -t.s), i.minus(t)
  var c = i.e,
    u = i.c,
    f = t.e,
    d = t.c
  if (!u[0] || !d[0]) return d[0] || (u[0] ? (t = new s(i)) : (t.s = i.s)), t
  if (((u = u.slice()), (e = c - f))) {
    for (e > 0 ? ((f = c), (r = d)) : ((e = -e), (r = u)), r.reverse(); e--; ) r.push(0)
    r.reverse()
  }
  for (u.length - d.length < 0 && ((r = d), (d = u), (u = r)), e = d.length, n = 0; e; u[e] %= 10)
    n = ((u[--e] = u[e] + d[e] + n) / 10) | 0
  for (n && (u.unshift(n), ++f), e = u.length; u[--e] === 0; ) u.pop()
  return (t.c = u), (t.e = f), t
}
jt.pow = function (t) {
  var e = this,
    n = new e.constructor('1'),
    r = n,
    i = t < 0
  if (t !== ~~t || t < -1e6 || t > v7) throw Error(gu + 'exponent')
  for (i && (t = -t); t & 1 && (r = r.times(e)), (t >>= 1), !!t; ) e = e.times(e)
  return i ? n.div(r) : r
}
jt.prec = function (t, e) {
  if (t !== ~~t || t < 1 || t > md) throw Error(gu + 'precision')
  return mu(new this.constructor(this), t, e)
}
jt.round = function (t, e) {
  if (t === js) t = 0
  else if (t !== ~~t || t < -1e6 || t > md) throw Error(Tm)
  return mu(new this.constructor(this), t + this.e + 1, e)
}
jt.sqrt = function () {
  var t,
    e,
    n,
    r = this,
    i = r.constructor,
    s = r.s,
    c = r.e,
    u = new i('0.5')
  if (!r.c[0]) return new i(r)
  if (s < 0) throw Error(dp + 'No square root')
  ;(s = Math.sqrt(+bu(r, !0, !0))),
    s === 0 || s === 1 / 0
      ? ((e = r.c.join('')),
        (e.length + c) & 1 || (e += '0'),
        (s = Math.sqrt(e)),
        (c = (((c + 1) / 2) | 0) - (c < 0 || c & 1)),
        (t = new i((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + c)))
      : (t = new i(s + '')),
    (c = t.e + (i.DP += 4))
  do (n = t), (t = u.times(n.plus(r.div(n))))
  while (n.c.slice(0, c).join('') !== t.c.slice(0, c).join(''))
  return mu(t, (i.DP -= 4) + t.e + 1, i.RM)
}
jt.times = jt.mul = function (t) {
  var e,
    n = this,
    r = n.constructor,
    i = n.c,
    s = (t = new r(t)).c,
    c = i.length,
    u = s.length,
    f = n.e,
    d = t.e
  if (((t.s = n.s == t.s ? 1 : -1), !i[0] || !s[0])) return (t.c = [(t.e = 0)]), t
  for (
    t.e = f + d,
      c < u && ((e = i), (i = s), (s = e), (d = c), (c = u), (u = d)),
      e = new Array((d = c + u));
    d--;

  )
    e[d] = 0
  for (f = u; f--; ) {
    for (u = 0, d = c + f; d > f; )
      (u = e[d] + s[f] * i[d - f - 1] + u), (e[d--] = u % 10), (u = (u / 10) | 0)
    e[d] = u
  }
  for (u ? ++t.e : e.shift(), f = e.length; !e[--f]; ) e.pop()
  return (t.c = e), t
}
jt.toExponential = function (t, e) {
  var n = this,
    r = n.c[0]
  if (t !== js) {
    if (t !== ~~t || t < 0 || t > md) throw Error(Tm)
    for (n = mu(new n.constructor(n), ++t, e); n.c.length < t; ) n.c.push(0)
  }
  return bu(n, !0, !!r)
}
jt.toFixed = function (t, e) {
  var n = this,
    r = n.c[0]
  if (t !== js) {
    if (t !== ~~t || t < 0 || t > md) throw Error(Tm)
    for (n = mu(new n.constructor(n), t + n.e + 1, e), t = t + n.e + 1; n.c.length < t; )
      n.c.push(0)
  }
  return bu(n, !1, !!r)
}
jt[Symbol.for('nodejs.util.inspect.custom')] =
  jt.toJSON =
  jt.toString =
    function () {
      var t = this,
        e = t.constructor
      return bu(t, t.e <= e.NE || t.e >= e.PE, !!t.c[0])
    }
jt.toNumber = function () {
  var t = +bu(this, !0, !0)
  if (this.constructor.strict === !0 && !this.eq(t.toString()))
    throw Error(dp + 'Imprecise conversion')
  return t
}
jt.toPrecision = function (t, e) {
  var n = this,
    r = n.constructor,
    i = n.c[0]
  if (t !== js) {
    if (t !== ~~t || t < 1 || t > md) throw Error(gu + 'precision')
    for (n = mu(new r(n), t, e); n.c.length < t; ) n.c.push(0)
  }
  return bu(n, t <= n.e || n.e <= r.NE || n.e >= r.PE, !!i)
}
jt.valueOf = function () {
  var t = this,
    e = t.constructor
  if (e.strict === !0) throw Error(dp + 'valueOf disallowed')
  return bu(t, t.e <= e.NE || t.e >= e.PE, !0)
}
var Rf = V8()
const Lt = {
    bigNumber(t) {
      return t ? new Rf(t) : new Rf(0)
    },
    multiply(t, e) {
      if (t === void 0 || e === void 0) return new Rf(0)
      const n = new Rf(t),
        r = new Rf(e)
      return n.times(r)
    },
    formatNumberToLocalString(t, e = 2) {
      return t === void 0
        ? '0.00'
        : typeof t == 'number'
          ? t.toLocaleString('en-US', { maximumFractionDigits: e, minimumFractionDigits: e })
          : parseFloat(t).toLocaleString('en-US', {
              maximumFractionDigits: e,
              minimumFractionDigits: e
            })
    },
    parseLocalStringToNumber(t) {
      return t === void 0 ? 0 : parseFloat(t.replace(/,/gu, ''))
    }
  },
  T7 = [
    {
      type: 'function',
      name: 'transfer',
      stateMutability: 'nonpayable',
      inputs: [
        { name: '_to', type: 'address' },
        { name: '_value', type: 'uint256' }
      ],
      outputs: [{ name: '', type: 'bool' }]
    },
    {
      type: 'function',
      name: 'transferFrom',
      stateMutability: 'nonpayable',
      inputs: [
        { name: '_from', type: 'address' },
        { name: '_to', type: 'address' },
        { name: '_value', type: 'uint256' }
      ],
      outputs: [{ name: '', type: 'bool' }]
    }
  ],
  x7 = [
    {
      type: 'function',
      name: 'approve',
      stateMutability: 'nonpayable',
      inputs: [
        { name: 'spender', type: 'address' },
        { name: 'amount', type: 'uint256' }
      ],
      outputs: [{ type: 'bool' }]
    }
  ],
  N7 = [
    {
      type: 'function',
      name: 'transfer',
      stateMutability: 'nonpayable',
      inputs: [
        { name: 'recipient', type: 'address' },
        { name: 'amount', type: 'uint256' }
      ],
      outputs: []
    },
    {
      type: 'function',
      name: 'transferFrom',
      stateMutability: 'nonpayable',
      inputs: [
        { name: 'sender', type: 'address' },
        { name: 'recipient', type: 'address' },
        { name: 'amount', type: 'uint256' }
      ],
      outputs: [{ name: '', type: 'bool' }]
    }
  ],
  he = {
    WC_NAME_SUFFIX: '.reown.id',
    WC_NAME_SUFFIX_LEGACY: '.wcn.id',
    BLOCKCHAIN_API_RPC_URL: 'https://rpc.walletconnect.org',
    PULSE_API_URL: 'https://pulse.walletconnect.org',
    W3M_API_URL: 'https://api.web3modal.org',
    CONNECTOR_ID: {
      WALLET_CONNECT: 'walletConnect',
      INJECTED: 'injected',
      WALLET_STANDARD: 'announced',
      COINBASE: 'coinbaseWallet',
      COINBASE_SDK: 'coinbaseWalletSDK',
      SAFE: 'safe',
      LEDGER: 'ledger',
      OKX: 'okx',
      EIP6963: 'eip6963',
      AUTH: 'ID_AUTH'
    },
    CONNECTOR_NAMES: { AUTH: 'Auth' },
    AUTH_CONNECTOR_SUPPORTED_CHAINS: ['eip155', 'solana'],
    LIMITS: { PENDING_TRANSACTIONS: 99 },
    CHAIN: { EVM: 'eip155', SOLANA: 'solana', POLKADOT: 'polkadot', BITCOIN: 'bip122' },
    CHAIN_NAME_MAP: {
      eip155: 'EVM Networks',
      solana: 'Solana',
      polkadot: 'Polkadot',
      bip122: 'Bitcoin'
    },
    USDT_CONTRACT_ADDRESSES: [
      '0xdac17f958d2ee523a2206206994597c13d831ec7',
      '0xc2132d05d31c914a87c6611c10748aeb04b58e8f',
      '0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7',
      '0x919C1c267BC06a7039e03fcc2eF738525769109c',
      '0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e',
      '0x55d398326f99059fF775485246999027B3197955',
      '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9'
    ],
    HTTP_STATUS_CODES: { SERVICE_UNAVAILABLE: 503, FORBIDDEN: 403 },
    UNSUPPORTED_NETWORK_NAME: 'Unknown Network'
  },
  I7 = {
    getERC20Abi: t => (he.USDT_CONTRACT_ADDRESSES.includes(t) ? N7 : T7),
    getSwapAbi: () => x7
  },
  lo = {
    validateCaipAddress(t) {
      var e
      if (((e = t.split(':')) == null ? void 0 : e.length) !== 3)
        throw new Error('Invalid CAIP Address')
      return t
    },
    parseCaipAddress(t) {
      const e = t.split(':')
      if (e.length !== 3) throw new Error(`Invalid CAIP-10 address: ${t}`)
      const [n, r, i] = e
      if (!n || !r || !i) throw new Error(`Invalid CAIP-10 address: ${t}`)
      return { chainNamespace: n, chainId: r, address: i }
    },
    parseCaipNetworkId(t) {
      const e = t.split(':')
      if (e.length !== 2) throw new Error(`Invalid CAIP-2 network id: ${t}`)
      const [n, r] = e
      if (!n || !r) throw new Error(`Invalid CAIP-2 network id: ${t}`)
      return { chainNamespace: n, chainId: r }
    }
  },
  rt = {
    WALLET_ID: '@appkit/wallet_id',
    WALLET_NAME: '@appkit/wallet_name',
    SOLANA_WALLET: '@appkit/solana_wallet',
    SOLANA_CAIP_CHAIN: '@appkit/solana_caip_chain',
    ACTIVE_CAIP_NETWORK_ID: '@appkit/active_caip_network_id',
    CONNECTED_SOCIAL: '@appkit/connected_social',
    CONNECTED_SOCIAL_USERNAME: '@appkit-wallet/SOCIAL_USERNAME',
    RECENT_WALLETS: '@appkit/recent_wallets',
    DEEPLINK_CHOICE: 'WALLETCONNECT_DEEPLINK_CHOICE',
    ACTIVE_NAMESPACE: '@appkit/active_namespace',
    CONNECTED_NAMESPACES: '@appkit/connected_namespaces',
    CONNECTION_STATUS: '@appkit/connection_status',
    SIWX_AUTH_TOKEN: '@appkit/siwx-auth-token',
    SIWX_NONCE_TOKEN: '@appkit/siwx-nonce-token',
    TELEGRAM_SOCIAL_PROVIDER: '@appkit/social_provider',
    NATIVE_BALANCE_CACHE: '@appkit/native_balance_cache',
    PORTFOLIO_CACHE: '@appkit/portfolio_cache',
    ENS_CACHE: '@appkit/ens_cache',
    IDENTITY_CACHE: '@appkit/identity_cache'
  }
function fv(t) {
  if (!t) throw new Error('Namespace is required for CONNECTED_CONNECTOR_ID')
  return `@appkit/${t}:connected_connector_id`
}
const Qe = {
  setItem(t, e) {
    eh() && e !== void 0 && localStorage.setItem(t, e)
  },
  getItem(t) {
    if (eh()) return localStorage.getItem(t) || void 0
  },
  removeItem(t) {
    eh() && localStorage.removeItem(t)
  },
  clear() {
    eh() && localStorage.clear()
  }
}
function eh() {
  return typeof window < 'u' && typeof localStorage < 'u'
}
function Ia(t, e) {
  return e === 'light'
    ? {
        '--w3m-accent': (t == null ? void 0 : t['--w3m-accent']) || 'hsla(231, 100%, 70%, 1)',
        '--w3m-background': '#fff'
      }
    : {
        '--w3m-accent': (t == null ? void 0 : t['--w3m-accent']) || 'hsla(230, 100%, 67%, 1)',
        '--w3m-background': '#121313'
      }
}
function O7(t) {
  return (
    (t == null ? void 0 : t.endsWith(he.WC_NAME_SUFFIX_LEGACY)) ||
    (t == null ? void 0 : t.endsWith(he.WC_NAME_SUFFIX))
  )
}
var kC = {}
const hv =
    (typeof process < 'u' && typeof kC < 'u' ? kC.NEXT_PUBLIC_SECURE_SITE_ORIGIN : void 0) ||
    'https://secure.walletconnect.org',
  Iie = [
    { label: 'Coinbase', name: 'coinbase', feeRange: '1-2%', url: '', supportedChains: ['eip155'] },
    {
      label: 'Meld.io',
      name: 'meld',
      feeRange: '1-2%',
      url: 'https://meldcrypto.com',
      supportedChains: ['eip155', 'solana']
    }
  ],
  Oie = 'WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU',
  Fn = {
    FOUR_MINUTES_MS: 24e4,
    TEN_SEC_MS: 1e4,
    FIVE_SEC_MS: 5e3,
    THREE_SEC_MS: 3e3,
    ONE_SEC_MS: 1e3,
    SECURE_SITE: hv,
    SECURE_SITE_DASHBOARD: `${hv}/dashboard`,
    SECURE_SITE_FAVICON: `${hv}/images/favicon.png`,
    RESTRICTED_TIMEZONES: [
      'ASIA/SHANGHAI',
      'ASIA/URUMQI',
      'ASIA/CHONGQING',
      'ASIA/HARBIN',
      'ASIA/KASHGAR',
      'ASIA/MACAU',
      'ASIA/HONG_KONG',
      'ASIA/MACAO',
      'ASIA/BEIJING',
      'ASIA/HARBIN'
    ],
    WC_COINBASE_PAY_SDK_CHAINS: [
      'ethereum',
      'arbitrum',
      'polygon',
      'berachain',
      'avalanche-c-chain',
      'optimism',
      'celo',
      'base'
    ],
    WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: 'ethereum',
    WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
      Ethereum: 'ethereum',
      'Arbitrum One': 'arbitrum',
      Polygon: 'polygon',
      Berachain: 'berachain',
      Avalanche: 'avalanche-c-chain',
      'OP Mainnet': 'optimism',
      Celo: 'celo',
      Base: 'base'
    },
    WC_COINBASE_ONRAMP_APP_ID: 'bf18c88d-495a-463b-b249-0b9d3656cf5e',
    SWAP_SUGGESTED_TOKENS: [
      'ETH',
      'UNI',
      '1INCH',
      'AAVE',
      'SOL',
      'ADA',
      'AVAX',
      'DOT',
      'LINK',
      'NITRO',
      'GAIA',
      'MILK',
      'TRX',
      'NEAR',
      'GNO',
      'WBTC',
      'DAI',
      'WETH',
      'USDC',
      'USDT',
      'ARB',
      'BAL',
      'BICO',
      'CRV',
      'ENS',
      'MATIC',
      'OP'
    ],
    SWAP_POPULAR_TOKENS: [
      'ETH',
      'UNI',
      '1INCH',
      'AAVE',
      'SOL',
      'ADA',
      'AVAX',
      'DOT',
      'LINK',
      'NITRO',
      'GAIA',
      'MILK',
      'TRX',
      'NEAR',
      'GNO',
      'WBTC',
      'DAI',
      'WETH',
      'USDC',
      'USDT',
      'ARB',
      'BAL',
      'BICO',
      'CRV',
      'ENS',
      'MATIC',
      'OP',
      'METAL',
      'DAI',
      'CHAMP',
      'WOLF',
      'SALE',
      'BAL',
      'BUSD',
      'MUST',
      'BTCpx',
      'ROUTE',
      'HEX',
      'WELT',
      'amDAI',
      'VSQ',
      'VISION',
      'AURUM',
      'pSP',
      'SNX',
      'VC',
      'LINK',
      'CHP',
      'amUSDT',
      'SPHERE',
      'FOX',
      'GIDDY',
      'GFC',
      'OMEN',
      'OX_OLD',
      'DE',
      'WNT'
    ],
    BALANCE_SUPPORTED_CHAINS: ['eip155', 'solana'],
    SWAP_SUPPORTED_NETWORKS: [
      'eip155:1',
      'eip155:42161',
      'eip155:10',
      'eip155:324',
      'eip155:8453',
      'eip155:56',
      'eip155:137',
      'eip155:100',
      'eip155:43114',
      'eip155:250',
      'eip155:8217',
      'eip155:1313161554'
    ],
    NAMES_SUPPORTED_CHAIN_NAMESPACES: ['eip155'],
    ONRAMP_SUPPORTED_CHAIN_NAMESPACES: ['eip155', 'solana'],
    ACTIVITY_ENABLED_CHAIN_NAMESPACES: ['eip155', 'solana'],
    NATIVE_TOKEN_ADDRESS: {
      eip155: '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee',
      solana: 'So11111111111111111111111111111111111111111',
      polkadot: '0x',
      bip122: '0x'
    },
    CONVERT_SLIPPAGE_TOLERANCE: 1,
    CONNECT_LABELS: { MOBILE: 'Open and continue in a new browser tab' },
    DEFAULT_FEATURES: {
      swaps: !0,
      onramp: !0,
      receive: !0,
      send: !0,
      email: !0,
      emailShowWallets: !0,
      socials: ['google', 'x', 'discord', 'farcaster', 'github', 'apple', 'facebook'],
      history: !0,
      analytics: !0,
      allWallets: !0,
      legalCheckbox: !1,
      smartSessions: !1,
      collapseWallets: !1,
      walletFeaturesOrder: ['onramp', 'swaps', 'receive', 'send'],
      connectMethodsOrder: void 0
    },
    DEFAULT_ACCOUNT_TYPES: {
      bip122: 'payment',
      eip155: 'smartAccount',
      polkadot: 'eoa',
      solana: 'eoa'
    },
    ADAPTER_TYPES: {
      UNIVERSAL: 'universal',
      SOLANA: 'solana',
      WAGMI: 'wagmi',
      ETHERS: 'ethers',
      ETHERS5: 'ethers5',
      BITCOIN: 'bitcoin'
    }
  },
  Ne = {
    cacheExpiry: { portfolio: 3e4, nativeBalance: 3e4, ens: 3e5, identity: 3e5 },
    isCacheExpired(t, e) {
      return Date.now() - t > e
    },
    getActiveNetworkProps() {
      const t = Ne.getActiveNamespace(),
        e = Ne.getActiveCaipNetworkId(),
        n = e ? e.split(':')[1] : void 0,
        r = n ? (isNaN(Number(n)) ? n : Number(n)) : void 0
      return { namespace: t, caipNetworkId: e, chainId: r }
    },
    setWalletConnectDeepLink({ name: t, href: e }) {
      try {
        Qe.setItem(rt.DEEPLINK_CHOICE, JSON.stringify({ href: e, name: t }))
      } catch {
        console.info('Unable to set WalletConnect deep link')
      }
    },
    getWalletConnectDeepLink() {
      try {
        const t = Qe.getItem(rt.DEEPLINK_CHOICE)
        if (t) return JSON.parse(t)
      } catch {
        console.info('Unable to get WalletConnect deep link')
      }
    },
    deleteWalletConnectDeepLink() {
      try {
        Qe.removeItem(rt.DEEPLINK_CHOICE)
      } catch {
        console.info('Unable to delete WalletConnect deep link')
      }
    },
    setActiveNamespace(t) {
      try {
        Qe.setItem(rt.ACTIVE_NAMESPACE, t)
      } catch {
        console.info('Unable to set active namespace')
      }
    },
    setActiveCaipNetworkId(t) {
      try {
        Qe.setItem(rt.ACTIVE_CAIP_NETWORK_ID, t), Ne.setActiveNamespace(t.split(':')[0])
      } catch {
        console.info('Unable to set active caip network id')
      }
    },
    getActiveCaipNetworkId() {
      try {
        return Qe.getItem(rt.ACTIVE_CAIP_NETWORK_ID)
      } catch {
        console.info('Unable to get active caip network id')
        return
      }
    },
    deleteActiveCaipNetworkId() {
      try {
        Qe.removeItem(rt.ACTIVE_CAIP_NETWORK_ID)
      } catch {
        console.info('Unable to delete active caip network id')
      }
    },
    deleteConnectedConnectorId(t) {
      try {
        const e = fv(t)
        Qe.removeItem(e)
      } catch {
        console.info('Unable to delete connected connector id')
      }
    },
    setAppKitRecent(t) {
      try {
        const e = Ne.getRecentWallets()
        e.find(r => r.id === t.id) ||
          (e.unshift(t), e.length > 2 && e.pop(), Qe.setItem(rt.RECENT_WALLETS, JSON.stringify(e)))
      } catch {
        console.info('Unable to set AppKit recent')
      }
    },
    getRecentWallets() {
      try {
        const t = Qe.getItem(rt.RECENT_WALLETS)
        return t ? JSON.parse(t) : []
      } catch {
        console.info('Unable to get AppKit recent')
      }
      return []
    },
    setConnectedConnectorId(t, e) {
      try {
        const n = fv(t)
        Qe.setItem(n, e)
      } catch {
        console.info('Unable to set Connected Connector Id')
      }
    },
    getActiveNamespace() {
      try {
        return Qe.getItem(rt.ACTIVE_NAMESPACE)
      } catch {
        console.info('Unable to get active namespace')
      }
    },
    getConnectedConnectorId(t) {
      if (t)
        try {
          const e = fv(t)
          return Qe.getItem(e)
        } catch {
          console.info('Unable to get connected connector id in namespace ', t)
        }
    },
    setConnectedSocialProvider(t) {
      try {
        Qe.setItem(rt.CONNECTED_SOCIAL, t)
      } catch {
        console.info('Unable to set connected social provider')
      }
    },
    getConnectedSocialProvider() {
      try {
        return Qe.getItem(rt.CONNECTED_SOCIAL)
      } catch {
        console.info('Unable to get connected social provider')
      }
    },
    deleteConnectedSocialProvider() {
      try {
        Qe.removeItem(rt.CONNECTED_SOCIAL)
      } catch {
        console.info('Unable to delete connected social provider')
      }
    },
    getConnectedSocialUsername() {
      try {
        return Qe.getItem(rt.CONNECTED_SOCIAL_USERNAME)
      } catch {
        console.info('Unable to get connected social username')
      }
    },
    getStoredActiveCaipNetworkId() {
      var n
      const t = Qe.getItem(rt.ACTIVE_CAIP_NETWORK_ID)
      return (n = t == null ? void 0 : t.split(':')) == null ? void 0 : n[1]
    },
    setConnectionStatus(t) {
      try {
        Qe.setItem(rt.CONNECTION_STATUS, t)
      } catch {
        console.info('Unable to set connection status')
      }
    },
    getConnectionStatus() {
      try {
        return Qe.getItem(rt.CONNECTION_STATUS)
      } catch {
        return
      }
    },
    getConnectedNamespaces() {
      try {
        const t = Qe.getItem(rt.CONNECTED_NAMESPACES)
        return t != null && t.length ? t.split(',') : []
      } catch {
        return []
      }
    },
    setConnectedNamespaces(t) {
      try {
        const e = Array.from(new Set(t))
        Qe.setItem(rt.CONNECTED_NAMESPACES, e.join(','))
      } catch {
        console.info('Unable to set namespaces in storage')
      }
    },
    addConnectedNamespace(t) {
      try {
        const e = Ne.getConnectedNamespaces()
        e.includes(t) || (e.push(t), Ne.setConnectedNamespaces(e))
      } catch {
        console.info('Unable to add connected namespace')
      }
    },
    removeConnectedNamespace(t) {
      try {
        const e = Ne.getConnectedNamespaces(),
          n = e.indexOf(t)
        n > -1 && (e.splice(n, 1), Ne.setConnectedNamespaces(e))
      } catch {
        console.info('Unable to remove connected namespace')
      }
    },
    getTelegramSocialProvider() {
      try {
        return Qe.getItem(rt.TELEGRAM_SOCIAL_PROVIDER)
      } catch {
        return console.info('Unable to get telegram social provider'), null
      }
    },
    setTelegramSocialProvider(t) {
      try {
        Qe.setItem(rt.TELEGRAM_SOCIAL_PROVIDER, t)
      } catch {
        console.info('Unable to set telegram social provider')
      }
    },
    removeTelegramSocialProvider() {
      try {
        Qe.removeItem(rt.TELEGRAM_SOCIAL_PROVIDER)
      } catch {
        console.info('Unable to remove telegram social provider')
      }
    },
    getBalanceCache() {
      let t = {}
      try {
        const e = Qe.getItem(rt.PORTFOLIO_CACHE)
        t = e ? JSON.parse(e) : {}
      } catch {
        console.info('Unable to get balance cache')
      }
      return t
    },
    removeAddressFromBalanceCache(t) {
      try {
        const e = Ne.getBalanceCache()
        Qe.setItem(rt.PORTFOLIO_CACHE, JSON.stringify({ ...e, [t]: void 0 }))
      } catch {
        console.info('Unable to remove address from balance cache', t)
      }
    },
    getBalanceCacheForCaipAddress(t) {
      try {
        const n = Ne.getBalanceCache()[t]
        if (n && !this.isCacheExpired(n.timestamp, this.cacheExpiry.portfolio)) return n.balance
        Ne.removeAddressFromBalanceCache(t)
      } catch {
        console.info('Unable to get balance cache for address', t)
      }
    },
    updateBalanceCache(t) {
      try {
        const e = Ne.getBalanceCache()
        ;(e[t.caipAddress] = t), Qe.setItem(rt.PORTFOLIO_CACHE, JSON.stringify(e))
      } catch {
        console.info('Unable to update balance cache', t)
      }
    },
    getNativeBalanceCache() {
      let t = {}
      try {
        const e = Qe.getItem(rt.NATIVE_BALANCE_CACHE)
        t = e ? JSON.parse(e) : {}
      } catch {
        console.info('Unable to get balance cache')
      }
      return t
    },
    removeAddressFromNativeBalanceCache(t) {
      try {
        const e = Ne.getBalanceCache()
        Qe.setItem(rt.NATIVE_BALANCE_CACHE, JSON.stringify({ ...e, [t]: void 0 }))
      } catch {
        console.info('Unable to remove address from balance cache', t)
      }
    },
    getNativeBalanceCacheForCaipAddress(t) {
      try {
        const n = Ne.getNativeBalanceCache()[t]
        if (n && !this.isCacheExpired(n.timestamp, this.cacheExpiry.nativeBalance)) return n
        console.info('Discarding cache for address', t), Ne.removeAddressFromBalanceCache(t)
      } catch {
        console.info('Unable to get balance cache for address', t)
      }
    },
    updateNativeBalanceCache(t) {
      try {
        const e = Ne.getNativeBalanceCache()
        ;(e[t.caipAddress] = t), Qe.setItem(rt.NATIVE_BALANCE_CACHE, JSON.stringify(e))
      } catch {
        console.info('Unable to update balance cache', t)
      }
    },
    getEnsCache() {
      let t = {}
      try {
        const e = Qe.getItem(rt.ENS_CACHE)
        t = e ? JSON.parse(e) : {}
      } catch {
        console.info('Unable to get ens name cache')
      }
      return t
    },
    getEnsFromCacheForAddress(t) {
      try {
        const n = Ne.getEnsCache()[t]
        if (n && !this.isCacheExpired(n.timestamp, this.cacheExpiry.ens)) return n.ens
        Ne.removeEnsFromCache(t)
      } catch {
        console.info('Unable to get ens name from cache', t)
      }
    },
    updateEnsCache(t) {
      try {
        const e = Ne.getEnsCache()
        ;(e[t.address] = t), Qe.setItem(rt.ENS_CACHE, JSON.stringify(e))
      } catch {
        console.info('Unable to update ens name cache', t)
      }
    },
    removeEnsFromCache(t) {
      try {
        const e = Ne.getEnsCache()
        Qe.setItem(rt.ENS_CACHE, JSON.stringify({ ...e, [t]: void 0 }))
      } catch {
        console.info('Unable to remove ens name from cache', t)
      }
    },
    getIdentityCache() {
      let t = {}
      try {
        const e = Qe.getItem(rt.IDENTITY_CACHE)
        t = e ? JSON.parse(e) : {}
      } catch {
        console.info('Unable to get identity cache')
      }
      return t
    },
    getIdentityFromCacheForAddress(t) {
      try {
        const n = Ne.getIdentityCache()[t]
        if (n && !this.isCacheExpired(n.timestamp, this.cacheExpiry.identity)) return n.identity
        Ne.removeIdentityFromCache(t)
      } catch {
        console.info('Unable to get identity from cache', t)
      }
    },
    updateIdentityCache(t) {
      try {
        const e = Ne.getIdentityCache()
        ;(e[t.address] = { identity: t.identity, timestamp: t.timestamp }),
          Qe.setItem(rt.IDENTITY_CACHE, JSON.stringify(e))
      } catch {
        console.info('Unable to update identity cache', t)
      }
    },
    removeIdentityFromCache(t) {
      try {
        const e = Ne.getIdentityCache()
        Qe.setItem(rt.IDENTITY_CACHE, JSON.stringify({ ...e, [t]: void 0 }))
      } catch {
        console.info('Unable to remove identity from cache', t)
      }
    },
    clearAddressCache() {
      try {
        Qe.removeItem(rt.PORTFOLIO_CACHE),
          Qe.removeItem(rt.NATIVE_BALANCE_CACHE),
          Qe.removeItem(rt.ENS_CACHE),
          Qe.removeItem(rt.IDENTITY_CACHE)
      } catch {
        console.info('Unable to clear address cache')
      }
    }
  },
  $e = {
    isMobile() {
      var t
      return this.isClient()
        ? !!(
            ((t = window == null ? void 0 : window.matchMedia('(pointer:coarse)')) != null &&
              t.matches) ||
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)
          )
        : !1
    },
    checkCaipNetwork(t, e = '') {
      return t == null ? void 0 : t.caipNetworkId.toLocaleLowerCase().includes(e.toLowerCase())
    },
    isAndroid() {
      if (!this.isMobile()) return !1
      const t = window == null ? void 0 : window.navigator.userAgent.toLowerCase()
      return $e.isMobile() && t.includes('android')
    },
    isIos() {
      if (!this.isMobile()) return !1
      const t = window == null ? void 0 : window.navigator.userAgent.toLowerCase()
      return t.includes('iphone') || t.includes('ipad')
    },
    isSafari() {
      return this.isClient()
        ? (window == null ? void 0 : window.navigator.userAgent.toLowerCase()).includes('safari')
        : !1
    },
    isClient() {
      return typeof window < 'u'
    },
    isPairingExpired(t) {
      return t ? t - Date.now() <= Fn.TEN_SEC_MS : !0
    },
    isAllowedRetry(t, e = Fn.ONE_SEC_MS) {
      return Date.now() - t >= e
    },
    copyToClopboard(t) {
      navigator.clipboard.writeText(t)
    },
    isIframe() {
      try {
        return (window == null ? void 0 : window.self) !== (window == null ? void 0 : window.top)
      } catch {
        return !1
      }
    },
    getPairingExpiry() {
      return Date.now() + Fn.FOUR_MINUTES_MS
    },
    getNetworkId(t) {
      return t == null ? void 0 : t.split(':')[1]
    },
    getPlainAddress(t) {
      return t == null ? void 0 : t.split(':')[2]
    },
    async wait(t) {
      return new Promise(e => {
        setTimeout(e, t)
      })
    },
    debounce(t, e = 500) {
      let n
      return (...r) => {
        function i() {
          t(...r)
        }
        n && clearTimeout(n), (n = setTimeout(i, e))
      }
    },
    isHttpUrl(t) {
      return t.startsWith('http://') || t.startsWith('https://')
    },
    formatNativeUrl(t, e) {
      if ($e.isHttpUrl(t)) return this.formatUniversalUrl(t, e)
      let n = t
      n.includes('://') || ((n = t.replaceAll('/', '').replaceAll(':', '')), (n = `${n}://`)),
        n.endsWith('/') || (n = `${n}/`),
        this.isTelegram() && this.isAndroid() && (e = encodeURIComponent(e))
      const r = encodeURIComponent(e)
      return { redirect: `${n}wc?uri=${r}`, href: n }
    },
    formatUniversalUrl(t, e) {
      if (!$e.isHttpUrl(t)) return this.formatNativeUrl(t, e)
      let n = t
      n.endsWith('/') || (n = `${n}/`)
      const r = encodeURIComponent(e)
      return { redirect: `${n}wc?uri=${r}`, href: n }
    },
    getOpenTargetForPlatform(t) {
      return t === 'popupWindow'
        ? t
        : this.isTelegram()
          ? Ne.getTelegramSocialProvider()
            ? '_top'
            : '_blank'
          : t
    },
    openHref(t, e, n) {
      window == null || window.open(t, this.getOpenTargetForPlatform(e), n || 'noreferrer noopener')
    },
    returnOpenHref(t, e, n) {
      return window == null
        ? void 0
        : window.open(t, this.getOpenTargetForPlatform(e), n || 'noreferrer noopener')
    },
    isTelegram() {
      return (
        typeof window < 'u' &&
        (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto)
      )
    },
    async preloadImage(t) {
      const e = new Promise((n, r) => {
        const i = new Image()
        ;(i.onload = n), (i.onerror = r), (i.crossOrigin = 'anonymous'), (i.src = t)
      })
      return Promise.race([e, $e.wait(2e3)])
    },
    formatBalance(t, e) {
      let n = '0.000'
      if (typeof t == 'string') {
        const r = Number(t)
        if (r) {
          const i = Math.floor(r * 1e3) / 1e3
          i && (n = i.toString())
        }
      }
      return `${n}${e ? ` ${e}` : ''}`
    },
    formatBalance2(t, e) {
      var r
      let n
      if (t === '0') n = '0'
      else if (typeof t == 'string') {
        const i = Number(t)
        i && (n = (r = i.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null ? void 0 : r[0])
      }
      return { value: n ?? '0', rest: n === '0' ? '000' : '', symbol: e }
    },
    getApiUrl() {
      return he.W3M_API_URL
    },
    getBlockchainApiUrl() {
      return he.BLOCKCHAIN_API_RPC_URL
    },
    getAnalyticsUrl() {
      return he.PULSE_API_URL
    },
    getUUID() {
      return crypto != null && crypto.randomUUID
        ? crypto.randomUUID()
        : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, t => {
            const e = (Math.random() * 16) | 0
            return (t === 'x' ? e : (e & 3) | 8).toString(16)
          })
    },
    parseError(t) {
      var e, n
      return typeof t == 'string'
        ? t
        : typeof ((n = (e = t == null ? void 0 : t.issues) == null ? void 0 : e[0]) == null
              ? void 0
              : n.message) == 'string'
          ? t.issues[0].message
          : t instanceof Error
            ? t.message
            : 'Unknown error'
    },
    sortRequestedNetworks(t, e = []) {
      const n = {}
      return (
        e &&
          t &&
          (t.forEach((r, i) => {
            n[r] = i
          }),
          e.sort((r, i) => {
            const s = n[r.id],
              c = n[i.id]
            return s !== void 0 && c !== void 0 ? s - c : s !== void 0 ? -1 : c !== void 0 ? 1 : 0
          })),
        e
      )
    },
    calculateBalance(t) {
      let e = 0
      for (const n of t) e += n.value ?? 0
      return e
    },
    formatTokenBalance(t) {
      const e = t.toFixed(2),
        [n, r] = e.split('.')
      return { dollars: n, pennies: r }
    },
    isAddress(t, e = 'eip155') {
      switch (e) {
        case 'eip155':
          if (/^(?:0x)?[0-9a-f]{40}$/iu.test(t)) {
            if (/^(?:0x)?[0-9a-f]{40}$/iu.test(t) || /^(?:0x)?[0-9A-F]{40}$/iu.test(t)) return !0
          } else return !1
          return !1
        case 'solana':
          return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(t)
        default:
          return !1
      }
    },
    uniqueBy(t, e) {
      const n = new Set()
      return t.filter(r => {
        const i = r[e]
        return n.has(i) ? !1 : (n.add(i), !0)
      })
    },
    generateSdkVersion(t, e, n) {
      const i = t.length === 0 ? Fn.ADAPTER_TYPES.UNIVERSAL : t.map(s => s.adapterType).join(',')
      return `${e}-${i}-${n}`
    },
    createAccount(t, e, n, r, i) {
      return { namespace: t, address: e, type: n, publicKey: r, path: i }
    },
    isCaipAddress(t) {
      if (typeof t != 'string') return !1
      const e = t.split(':'),
        n = e[0]
      return e.filter(Boolean).length === 3 && n in he.CHAIN_NAME_MAP
    },
    isMac() {
      const t = window == null ? void 0 : window.navigator.userAgent.toLowerCase()
      return t.includes('macintosh') && !t.includes('safari')
    },
    formatTelegramSocialLoginUrl(t) {
      const e = `--${encodeURIComponent(window == null ? void 0 : window.location.href)}`,
        n = 'state='
      if (new URL(t).host === 'auth.magic.link') {
        const i = 'provider_authorization_url=',
          s = t.substring(t.indexOf(i) + i.length),
          c = this.injectIntoUrl(decodeURIComponent(s), n, e)
        return t.replace(s, encodeURIComponent(c))
      }
      return this.injectIntoUrl(t, n, e)
    },
    injectIntoUrl(t, e, n) {
      const r = t.indexOf(e)
      if (r === -1) throw new Error(`${e} parameter not found in the URL: ${t}`)
      const i = t.indexOf('&', r),
        s = e.length,
        c = i !== -1 ? i : t.length,
        u = t.substring(0, r + s),
        f = t.substring(r + s, c),
        d = t.substring(i),
        p = f + n
      return u + p + d
    }
  },
  li = gn({
    walletImages: {},
    networkImages: {},
    chainImages: {},
    connectorImages: {},
    tokenImages: {},
    currencyImages: {}
  }),
  os = {
    state: li,
    subscribeNetworkImages(t) {
      return Rr(li.networkImages, () => t(li.networkImages))
    },
    subscribeKey(t, e) {
      return zr(li, t, e)
    },
    subscribe(t) {
      return Rr(li, () => t(li))
    },
    setWalletImage(t, e) {
      li.walletImages[t] = e
    },
    setNetworkImage(t, e) {
      li.networkImages[t] = e
    },
    setChainImage(t, e) {
      li.chainImages[t] = e
    },
    setConnectorImage(t, e) {
      li.connectorImages = { ...li.connectorImages, [t]: e }
    },
    setTokenImage(t, e) {
      li.tokenImages[t] = e
    },
    setCurrencyImage(t, e) {
      li.currencyImages[t] = e
    }
  },
  R7 = {
    eip155: 'ba0ba0cd-17c6-4806-ad93-f9d174f17900',
    solana: 'a1b58899-f671-4276-6a5e-56ca5bd59700',
    polkadot: '',
    bip122: ''
  },
  pv = gn({ networkImagePromises: {} }),
  K8 = {
    async fetchWalletImage(t) {
      if (t) return await gt._fetchWalletImage(t), this.getWalletImageById(t)
    },
    async fetchNetworkImage(t) {
      if (!t) return
      const e = this.getNetworkImageById(t)
      return (
        e ||
        (pv.networkImagePromises[t] || (pv.networkImagePromises[t] = gt._fetchNetworkImage(t)),
        await pv.networkImagePromises[t],
        this.getNetworkImageById(t))
      )
    },
    getWalletImageById(t) {
      if (t) return os.state.walletImages[t]
    },
    getWalletImage(t) {
      if (t != null && t.image_url) return t == null ? void 0 : t.image_url
      if (t != null && t.image_id) return os.state.walletImages[t.image_id]
    },
    getNetworkImage(t) {
      var e, n, r
      if ((e = t == null ? void 0 : t.assets) != null && e.imageUrl)
        return (n = t == null ? void 0 : t.assets) == null ? void 0 : n.imageUrl
      if ((r = t == null ? void 0 : t.assets) != null && r.imageId)
        return os.state.networkImages[t.assets.imageId]
    },
    getNetworkImageById(t) {
      if (t) return os.state.networkImages[t]
    },
    getConnectorImage(t) {
      if (t != null && t.imageUrl) return t.imageUrl
      if (t != null && t.imageId) return os.state.connectorImages[t.imageId]
    },
    getChainImage(t) {
      return os.state.networkImages[R7[t]]
    }
  }
async function Df(...t) {
  const e = await fetch(...t)
  if (!e.ok) throw new Error(`HTTP status code: ${e.status}`, { cause: e })
  return e
}
class xm {
  constructor({ baseUrl: e, clientId: n }) {
    ;(this.baseUrl = e), (this.clientId = n)
  }
  async get({ headers: e, signal: n, cache: r, ...i }) {
    const s = this.createUrl(i)
    return (await Df(s, { method: 'GET', headers: e, signal: n, cache: r })).json()
  }
  async getBlob({ headers: e, signal: n, ...r }) {
    const i = this.createUrl(r)
    return (await Df(i, { method: 'GET', headers: e, signal: n })).blob()
  }
  async post({ body: e, headers: n, signal: r, ...i }) {
    const s = this.createUrl(i)
    return (
      await Df(s, { method: 'POST', headers: n, body: e ? JSON.stringify(e) : void 0, signal: r })
    ).json()
  }
  async put({ body: e, headers: n, signal: r, ...i }) {
    const s = this.createUrl(i)
    return (
      await Df(s, { method: 'PUT', headers: n, body: e ? JSON.stringify(e) : void 0, signal: r })
    ).json()
  }
  async delete({ body: e, headers: n, signal: r, ...i }) {
    const s = this.createUrl(i)
    return (
      await Df(s, { method: 'DELETE', headers: n, body: e ? JSON.stringify(e) : void 0, signal: r })
    ).json()
  }
  createUrl({ path: e, params: n }) {
    const r = new URL(e, this.baseUrl)
    return (
      n &&
        Object.entries(n).forEach(([i, s]) => {
          s && r.searchParams.append(i, s)
        }),
      this.clientId && r.searchParams.append('clientId', this.clientId),
      r
    )
  }
}
var Q0 = { exports: {} },
  UC
function D7() {
  if (UC) return Q0.exports
  UC = 1
  var t = typeof Reflect == 'object' ? Reflect : null,
    e =
      t && typeof t.apply == 'function'
        ? t.apply
        : function (D, R, z) {
            return Function.prototype.apply.call(D, R, z)
          },
    n
  t && typeof t.ownKeys == 'function'
    ? (n = t.ownKeys)
    : Object.getOwnPropertySymbols
      ? (n = function (D) {
          return Object.getOwnPropertyNames(D).concat(Object.getOwnPropertySymbols(D))
        })
      : (n = function (D) {
          return Object.getOwnPropertyNames(D)
        })
  function r($) {
    console && console.warn && console.warn($)
  }
  var i =
    Number.isNaN ||
    function (D) {
      return D !== D
    }
  function s() {
    s.init.call(this)
  }
  ;(Q0.exports = s),
    (Q0.exports.once = O),
    (s.EventEmitter = s),
    (s.prototype._events = void 0),
    (s.prototype._eventsCount = 0),
    (s.prototype._maxListeners = void 0)
  var c = 10
  function u($) {
    if (typeof $ != 'function')
      throw new TypeError(
        'The "listener" argument must be of type Function. Received type ' + typeof $
      )
  }
  Object.defineProperty(s, 'defaultMaxListeners', {
    enumerable: !0,
    get: function () {
      return c
    },
    set: function ($) {
      if (typeof $ != 'number' || $ < 0 || i($))
        throw new RangeError(
          'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
            $ +
            '.'
        )
      c = $
    }
  }),
    (s.init = function () {
      ;(this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) &&
        ((this._events = Object.create(null)), (this._eventsCount = 0)),
        (this._maxListeners = this._maxListeners || void 0)
    }),
    (s.prototype.setMaxListeners = function (D) {
      if (typeof D != 'number' || D < 0 || i(D))
        throw new RangeError(
          'The value of "n" is out of range. It must be a non-negative number. Received ' + D + '.'
        )
      return (this._maxListeners = D), this
    })
  function f($) {
    return $._maxListeners === void 0 ? s.defaultMaxListeners : $._maxListeners
  }
  ;(s.prototype.getMaxListeners = function () {
    return f(this)
  }),
    (s.prototype.emit = function (D) {
      for (var R = [], z = 1; z < arguments.length; z++) R.push(arguments[z])
      var G = D === 'error',
        j = this._events
      if (j !== void 0) G = G && j.error === void 0
      else if (!G) return !1
      if (G) {
        var V
        if ((R.length > 0 && (V = R[0]), V instanceof Error)) throw V
        var L = new Error('Unhandled error.' + (V ? ' (' + V.message + ')' : ''))
        throw ((L.context = V), L)
      }
      var v = j[D]
      if (v === void 0) return !1
      if (typeof v == 'function') e(v, this, R)
      else for (var C = v.length, N = A(v, C), z = 0; z < C; ++z) e(N[z], this, R)
      return !0
    })
  function d($, D, R, z) {
    var G, j, V
    if (
      (u(R),
      (j = $._events),
      j === void 0
        ? ((j = $._events = Object.create(null)), ($._eventsCount = 0))
        : (j.newListener !== void 0 &&
            ($.emit('newListener', D, R.listener ? R.listener : R), (j = $._events)),
          (V = j[D])),
      V === void 0)
    )
      (V = j[D] = R), ++$._eventsCount
    else if (
      (typeof V == 'function' ? (V = j[D] = z ? [R, V] : [V, R]) : z ? V.unshift(R) : V.push(R),
      (G = f($)),
      G > 0 && V.length > G && !V.warned)
    ) {
      V.warned = !0
      var L = new Error(
        'Possible EventEmitter memory leak detected. ' +
          V.length +
          ' ' +
          String(D) +
          ' listeners added. Use emitter.setMaxListeners() to increase limit'
      )
      ;(L.name = 'MaxListenersExceededWarning'),
        (L.emitter = $),
        (L.type = D),
        (L.count = V.length),
        r(L)
    }
    return $
  }
  ;(s.prototype.addListener = function (D, R) {
    return d(this, D, R, !1)
  }),
    (s.prototype.on = s.prototype.addListener),
    (s.prototype.prependListener = function (D, R) {
      return d(this, D, R, !0)
    })
  function p() {
    if (!this.fired)
      return (
        this.target.removeListener(this.type, this.wrapFn),
        (this.fired = !0),
        arguments.length === 0
          ? this.listener.call(this.target)
          : this.listener.apply(this.target, arguments)
      )
  }
  function g($, D, R) {
    var z = { fired: !1, wrapFn: void 0, target: $, type: D, listener: R },
      G = p.bind(z)
    return (G.listener = R), (z.wrapFn = G), G
  }
  ;(s.prototype.once = function (D, R) {
    return u(R), this.on(D, g(this, D, R)), this
  }),
    (s.prototype.prependOnceListener = function (D, R) {
      return u(R), this.prependListener(D, g(this, D, R)), this
    }),
    (s.prototype.removeListener = function (D, R) {
      var z, G, j, V, L
      if ((u(R), (G = this._events), G === void 0)) return this
      if (((z = G[D]), z === void 0)) return this
      if (z === R || z.listener === R)
        --this._eventsCount === 0
          ? (this._events = Object.create(null))
          : (delete G[D], G.removeListener && this.emit('removeListener', D, z.listener || R))
      else if (typeof z != 'function') {
        for (j = -1, V = z.length - 1; V >= 0; V--)
          if (z[V] === R || z[V].listener === R) {
            ;(L = z[V].listener), (j = V)
            break
          }
        if (j < 0) return this
        j === 0 ? z.shift() : E(z, j),
          z.length === 1 && (G[D] = z[0]),
          G.removeListener !== void 0 && this.emit('removeListener', D, L || R)
      }
      return this
    }),
    (s.prototype.off = s.prototype.removeListener),
    (s.prototype.removeAllListeners = function (D) {
      var R, z, G
      if (((z = this._events), z === void 0)) return this
      if (z.removeListener === void 0)
        return (
          arguments.length === 0
            ? ((this._events = Object.create(null)), (this._eventsCount = 0))
            : z[D] !== void 0 &&
              (--this._eventsCount === 0 ? (this._events = Object.create(null)) : delete z[D]),
          this
        )
      if (arguments.length === 0) {
        var j = Object.keys(z),
          V
        for (G = 0; G < j.length; ++G)
          (V = j[G]), V !== 'removeListener' && this.removeAllListeners(V)
        return (
          this.removeAllListeners('removeListener'),
          (this._events = Object.create(null)),
          (this._eventsCount = 0),
          this
        )
      }
      if (((R = z[D]), typeof R == 'function')) this.removeListener(D, R)
      else if (R !== void 0) for (G = R.length - 1; G >= 0; G--) this.removeListener(D, R[G])
      return this
    })
  function m($, D, R) {
    var z = $._events
    if (z === void 0) return []
    var G = z[D]
    return G === void 0
      ? []
      : typeof G == 'function'
        ? R
          ? [G.listener || G]
          : [G]
        : R
          ? x(G)
          : A(G, G.length)
  }
  ;(s.prototype.listeners = function (D) {
    return m(this, D, !0)
  }),
    (s.prototype.rawListeners = function (D) {
      return m(this, D, !1)
    }),
    (s.listenerCount = function ($, D) {
      return typeof $.listenerCount == 'function' ? $.listenerCount(D) : y.call($, D)
    }),
    (s.prototype.listenerCount = y)
  function y($) {
    var D = this._events
    if (D !== void 0) {
      var R = D[$]
      if (typeof R == 'function') return 1
      if (R !== void 0) return R.length
    }
    return 0
  }
  s.prototype.eventNames = function () {
    return this._eventsCount > 0 ? n(this._events) : []
  }
  function A($, D) {
    for (var R = new Array(D), z = 0; z < D; ++z) R[z] = $[z]
    return R
  }
  function E($, D) {
    for (; D + 1 < $.length; D++) $[D] = $[D + 1]
    $.pop()
  }
  function x($) {
    for (var D = new Array($.length), R = 0; R < D.length; ++R) D[R] = $[R].listener || $[R]
    return D
  }
  function O($, D) {
    return new Promise(function (R, z) {
      function G(V) {
        $.removeListener(D, j), z(V)
      }
      function j() {
        typeof $.removeListener == 'function' && $.removeListener('error', G),
          R([].slice.call(arguments))
      }
      M($, D, j, { once: !0 }), D !== 'error' && I($, G, { once: !0 })
    })
  }
  function I($, D, R) {
    typeof $.on == 'function' && M($, 'error', D, R)
  }
  function M($, D, R, z) {
    if (typeof $.on == 'function') z.once ? $.once(D, R) : $.on(D, R)
    else if (typeof $.addEventListener == 'function')
      $.addEventListener(D, function G(j) {
        z.once && $.removeEventListener(D, G), R(j)
      })
    else
      throw new TypeError(
        'The "emitter" argument must be of type EventEmitter. Received type ' + typeof $
      )
  }
  return Q0.exports
}
var zi = D7()
const $E = pd(zi)
var gv = {}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var ow = function (
  t,
  e
) {
  return (
    (ow =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (n, r) {
          n.__proto__ = r
        }) ||
      function (n, r) {
        for (var i in r) r.hasOwnProperty(i) && (n[i] = r[i])
      }),
    ow(t, e)
  )
}
function P7(t, e) {
  ow(t, e)
  function n() {
    this.constructor = t
  }
  t.prototype = e === null ? Object.create(e) : ((n.prototype = e.prototype), new n())
}
var cw = function () {
  return (
    (cw =
      Object.assign ||
      function (e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r]
          for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
        }
        return e
      }),
    cw.apply(this, arguments)
  )
}
function M7(t, e) {
  var n = {}
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
  if (t != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]])
  return n
}
function k7(t, e, n, r) {
  var i = arguments.length,
    s = i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, n)) : r,
    c
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
    s = Reflect.decorate(t, e, n, r)
  else
    for (var u = t.length - 1; u >= 0; u--)
      (c = t[u]) && (s = (i < 3 ? c(s) : i > 3 ? c(e, n, s) : c(e, n)) || s)
  return i > 3 && s && Object.defineProperty(e, n, s), s
}
function U7(t, e) {
  return function (n, r) {
    e(n, r, t)
  }
}
function B7(t, e) {
  if (typeof Reflect == 'object' && typeof Reflect.metadata == 'function')
    return Reflect.metadata(t, e)
}
function L7(t, e, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (c) {
          c(s)
        })
  }
  return new (n || (n = Promise))(function (s, c) {
    function u(p) {
      try {
        d(r.next(p))
      } catch (g) {
        c(g)
      }
    }
    function f(p) {
      try {
        d(r.throw(p))
      } catch (g) {
        c(g)
      }
    }
    function d(p) {
      p.done ? s(p.value) : i(p.value).then(u, f)
    }
    d((r = r.apply(t, e || [])).next())
  })
}
function $7(t, e) {
  var n = {
      label: 0,
      sent: function () {
        if (s[0] & 1) throw s[1]
        return s[1]
      },
      trys: [],
      ops: []
    },
    r,
    i,
    s,
    c
  return (
    (c = { next: u(0), throw: u(1), return: u(2) }),
    typeof Symbol == 'function' &&
      (c[Symbol.iterator] = function () {
        return this
      }),
    c
  )
  function u(d) {
    return function (p) {
      return f([d, p])
    }
  }
  function f(d) {
    if (r) throw new TypeError('Generator is already executing.')
    for (; n; )
      try {
        if (
          ((r = 1),
          i &&
            (s =
              d[0] & 2 ? i.return : d[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) &&
            !(s = s.call(i, d[1])).done)
        )
          return s
        switch (((i = 0), s && (d = [d[0] & 2, s.value]), d[0])) {
          case 0:
          case 1:
            s = d
            break
          case 4:
            return n.label++, { value: d[1], done: !1 }
          case 5:
            n.label++, (i = d[1]), (d = [0])
            continue
          case 7:
            ;(d = n.ops.pop()), n.trys.pop()
            continue
          default:
            if (
              ((s = n.trys), !(s = s.length > 0 && s[s.length - 1]) && (d[0] === 6 || d[0] === 2))
            ) {
              n = 0
              continue
            }
            if (d[0] === 3 && (!s || (d[1] > s[0] && d[1] < s[3]))) {
              n.label = d[1]
              break
            }
            if (d[0] === 6 && n.label < s[1]) {
              ;(n.label = s[1]), (s = d)
              break
            }
            if (s && n.label < s[2]) {
              ;(n.label = s[2]), n.ops.push(d)
              break
            }
            s[2] && n.ops.pop(), n.trys.pop()
            continue
        }
        d = e.call(t, n)
      } catch (p) {
        ;(d = [6, p]), (i = 0)
      } finally {
        r = s = 0
      }
    if (d[0] & 5) throw d[1]
    return { value: d[0] ? d[1] : void 0, done: !0 }
  }
}
function F7(t, e, n, r) {
  r === void 0 && (r = n), (t[r] = e[n])
}
function j7(t, e) {
  for (var n in t) n !== 'default' && !e.hasOwnProperty(n) && (e[n] = t[n])
}
function uw(t) {
  var e = typeof Symbol == 'function' && Symbol.iterator,
    n = e && t[e],
    r = 0
  if (n) return n.call(t)
  if (t && typeof t.length == 'number')
    return {
      next: function () {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
      }
    }
  throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
}
function W8(t, e) {
  var n = typeof Symbol == 'function' && t[Symbol.iterator]
  if (!n) return t
  var r = n.call(t),
    i,
    s = [],
    c
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) s.push(i.value)
  } catch (u) {
    c = { error: u }
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r)
    } finally {
      if (c) throw c.error
    }
  }
  return s
}
function z7() {
  for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(W8(arguments[e]))
  return t
}
function q7() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length
  for (var r = Array(t), i = 0, e = 0; e < n; e++)
    for (var s = arguments[e], c = 0, u = s.length; c < u; c++, i++) r[i] = s[c]
  return r
}
function vh(t) {
  return this instanceof vh ? ((this.v = t), this) : new vh(t)
}
function H7(t, e, n) {
  if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.')
  var r = n.apply(t, e || []),
    i,
    s = []
  return (
    (i = {}),
    c('next'),
    c('throw'),
    c('return'),
    (i[Symbol.asyncIterator] = function () {
      return this
    }),
    i
  )
  function c(m) {
    r[m] &&
      (i[m] = function (y) {
        return new Promise(function (A, E) {
          s.push([m, y, A, E]) > 1 || u(m, y)
        })
      })
  }
  function u(m, y) {
    try {
      f(r[m](y))
    } catch (A) {
      g(s[0][3], A)
    }
  }
  function f(m) {
    m.value instanceof vh ? Promise.resolve(m.value.v).then(d, p) : g(s[0][2], m)
  }
  function d(m) {
    u('next', m)
  }
  function p(m) {
    u('throw', m)
  }
  function g(m, y) {
    m(y), s.shift(), s.length && u(s[0][0], s[0][1])
  }
}
function G7(t) {
  var e, n
  return (
    (e = {}),
    r('next'),
    r('throw', function (i) {
      throw i
    }),
    r('return'),
    (e[Symbol.iterator] = function () {
      return this
    }),
    e
  )
  function r(i, s) {
    e[i] = t[i]
      ? function (c) {
          return (n = !n) ? { value: vh(t[i](c)), done: i === 'return' } : s ? s(c) : c
        }
      : s
  }
}
function V7(t) {
  if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.')
  var e = t[Symbol.asyncIterator],
    n
  return e
    ? e.call(t)
    : ((t = typeof uw == 'function' ? uw(t) : t[Symbol.iterator]()),
      (n = {}),
      r('next'),
      r('throw'),
      r('return'),
      (n[Symbol.asyncIterator] = function () {
        return this
      }),
      n)
  function r(s) {
    n[s] =
      t[s] &&
      function (c) {
        return new Promise(function (u, f) {
          ;(c = t[s](c)), i(u, f, c.done, c.value)
        })
      }
  }
  function i(s, c, u, f) {
    Promise.resolve(f).then(function (d) {
      s({ value: d, done: u })
    }, c)
  }
}
function K7(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, 'raw', { value: e }) : (t.raw = e), t
}
function W7(t) {
  if (t && t.__esModule) return t
  var e = {}
  if (t != null) for (var n in t) Object.hasOwnProperty.call(t, n) && (e[n] = t[n])
  return (e.default = t), e
}
function Q7(t) {
  return t && t.__esModule ? t : { default: t }
}
function Y7(t, e) {
  if (!e.has(t)) throw new TypeError('attempted to get private field on non-instance')
  return e.get(t)
}
function Z7(t, e, n) {
  if (!e.has(t)) throw new TypeError('attempted to set private field on non-instance')
  return e.set(t, n), n
}
const X7 = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        get __assign() {
          return cw
        },
        __asyncDelegator: G7,
        __asyncGenerator: H7,
        __asyncValues: V7,
        __await: vh,
        __awaiter: L7,
        __classPrivateFieldGet: Y7,
        __classPrivateFieldSet: Z7,
        __createBinding: F7,
        __decorate: k7,
        __exportStar: j7,
        __extends: P7,
        __generator: $7,
        __importDefault: Q7,
        __importStar: W7,
        __makeTemplateObject: K7,
        __metadata: B7,
        __param: U7,
        __read: W8,
        __rest: M7,
        __spread: z7,
        __spreadArrays: q7,
        __values: uw
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  fp = j8(X7)
var mv = {},
  Pf = {},
  BC
function J7() {
  if (BC) return Pf
  ;(BC = 1), Object.defineProperty(Pf, '__esModule', { value: !0 }), (Pf.delay = void 0)
  function t(e) {
    return new Promise(n => {
      setTimeout(() => {
        n(!0)
      }, e)
    })
  }
  return (Pf.delay = t), Pf
}
var vc = {},
  bv = {},
  wc = {},
  LC
function eD() {
  return (
    LC ||
      ((LC = 1),
      Object.defineProperty(wc, '__esModule', { value: !0 }),
      (wc.ONE_THOUSAND = wc.ONE_HUNDRED = void 0),
      (wc.ONE_HUNDRED = 100),
      (wc.ONE_THOUSAND = 1e3)),
    wc
  )
}
var yv = {},
  $C
function tD() {
  return (
    $C ||
      (($C = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 }),
          (t.ONE_YEAR =
            t.FOUR_WEEKS =
            t.THREE_WEEKS =
            t.TWO_WEEKS =
            t.ONE_WEEK =
            t.THIRTY_DAYS =
            t.SEVEN_DAYS =
            t.FIVE_DAYS =
            t.THREE_DAYS =
            t.ONE_DAY =
            t.TWENTY_FOUR_HOURS =
            t.TWELVE_HOURS =
            t.SIX_HOURS =
            t.THREE_HOURS =
            t.ONE_HOUR =
            t.SIXTY_MINUTES =
            t.THIRTY_MINUTES =
            t.TEN_MINUTES =
            t.FIVE_MINUTES =
            t.ONE_MINUTE =
            t.SIXTY_SECONDS =
            t.THIRTY_SECONDS =
            t.TEN_SECONDS =
            t.FIVE_SECONDS =
            t.ONE_SECOND =
              void 0),
          (t.ONE_SECOND = 1),
          (t.FIVE_SECONDS = 5),
          (t.TEN_SECONDS = 10),
          (t.THIRTY_SECONDS = 30),
          (t.SIXTY_SECONDS = 60),
          (t.ONE_MINUTE = t.SIXTY_SECONDS),
          (t.FIVE_MINUTES = t.ONE_MINUTE * 5),
          (t.TEN_MINUTES = t.ONE_MINUTE * 10),
          (t.THIRTY_MINUTES = t.ONE_MINUTE * 30),
          (t.SIXTY_MINUTES = t.ONE_MINUTE * 60),
          (t.ONE_HOUR = t.SIXTY_MINUTES),
          (t.THREE_HOURS = t.ONE_HOUR * 3),
          (t.SIX_HOURS = t.ONE_HOUR * 6),
          (t.TWELVE_HOURS = t.ONE_HOUR * 12),
          (t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24),
          (t.ONE_DAY = t.TWENTY_FOUR_HOURS),
          (t.THREE_DAYS = t.ONE_DAY * 3),
          (t.FIVE_DAYS = t.ONE_DAY * 5),
          (t.SEVEN_DAYS = t.ONE_DAY * 7),
          (t.THIRTY_DAYS = t.ONE_DAY * 30),
          (t.ONE_WEEK = t.SEVEN_DAYS),
          (t.TWO_WEEKS = t.ONE_WEEK * 2),
          (t.THREE_WEEKS = t.ONE_WEEK * 3),
          (t.FOUR_WEEKS = t.ONE_WEEK * 4),
          (t.ONE_YEAR = t.ONE_DAY * 365)
      })(yv)),
    yv
  )
}
var FC
function Q8() {
  return (
    FC ||
      ((FC = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 })
        const e = fp
        e.__exportStar(eD(), t), e.__exportStar(tD(), t)
      })(bv)),
    bv
  )
}
var jC
function nD() {
  if (jC) return vc
  ;(jC = 1),
    Object.defineProperty(vc, '__esModule', { value: !0 }),
    (vc.fromMiliseconds = vc.toMiliseconds = void 0)
  const t = Q8()
  function e(r) {
    return r * t.ONE_THOUSAND
  }
  vc.toMiliseconds = e
  function n(r) {
    return Math.floor(r / t.ONE_THOUSAND)
  }
  return (vc.fromMiliseconds = n), vc
}
var zC
function rD() {
  return (
    zC ||
      ((zC = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 })
        const e = fp
        e.__exportStar(J7(), t), e.__exportStar(nD(), t)
      })(mv)),
    mv
  )
}
var al = {},
  qC
function iD() {
  if (qC) return al
  ;(qC = 1), Object.defineProperty(al, '__esModule', { value: !0 }), (al.Watch = void 0)
  class t {
    constructor() {
      this.timestamps = new Map()
    }
    start(n) {
      if (this.timestamps.has(n)) throw new Error(`Watch already started for label: ${n}`)
      this.timestamps.set(n, { started: Date.now() })
    }
    stop(n) {
      const r = this.get(n)
      if (typeof r.elapsed < 'u') throw new Error(`Watch already stopped for label: ${n}`)
      const i = Date.now() - r.started
      this.timestamps.set(n, { started: r.started, elapsed: i })
    }
    get(n) {
      const r = this.timestamps.get(n)
      if (typeof r > 'u') throw new Error(`No timestamp found for label: ${n}`)
      return r
    }
    elapsed(n) {
      const r = this.get(n)
      return r.elapsed || Date.now() - r.started
    }
  }
  return (al.Watch = t), (al.default = t), al
}
var vv = {},
  Mf = {},
  HC
function sD() {
  if (HC) return Mf
  ;(HC = 1), Object.defineProperty(Mf, '__esModule', { value: !0 }), (Mf.IWatch = void 0)
  class t {}
  return (Mf.IWatch = t), Mf
}
var GC
function aD() {
  return (
    GC ||
      ((GC = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 }), fp.__exportStar(sD(), t)
      })(vv)),
    vv
  )
}
var VC
function oD() {
  return (
    VC ||
      ((VC = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 })
        const e = fp
        e.__exportStar(rD(), t),
          e.__exportStar(iD(), t),
          e.__exportStar(aD(), t),
          e.__exportStar(Q8(), t)
      })(gv)),
    gv
  )
}
var ge = oD()
class yu {}
let cD = class extends yu {
  constructor(e) {
    super()
  }
}
const KC = ge.FIVE_SECONDS,
  bd = { pulse: 'heartbeat_pulse' }
let uD = class Y8 extends cD {
  constructor(e) {
    super(e),
      (this.events = new zi.EventEmitter()),
      (this.interval = KC),
      (this.interval = (e == null ? void 0 : e.interval) || KC)
  }
  static async init(e) {
    const n = new Y8(e)
    return await n.init(), n
  }
  async init() {
    await this.initialize()
  }
  stop() {
    clearInterval(this.intervalRef)
  }
  on(e, n) {
    this.events.on(e, n)
  }
  once(e, n) {
    this.events.once(e, n)
  }
  off(e, n) {
    this.events.off(e, n)
  }
  removeListener(e, n) {
    this.events.removeListener(e, n)
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), ge.toMiliseconds(this.interval))
  }
  pulse() {
    this.events.emit(bd.pulse)
  }
}
const lD =
    /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
  dD =
    /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
  fD = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/
function hD(t, e) {
  if (t === '__proto__' || (t === 'constructor' && e && typeof e == 'object' && 'prototype' in e)) {
    pD(t)
    return
  }
  return e
}
function pD(t) {
  console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`)
}
function Y0(t, e = {}) {
  if (typeof t != 'string') return t
  const n = t.trim()
  if (t[0] === '"' && t.endsWith('"') && !t.includes('\\')) return n.slice(1, -1)
  if (n.length <= 9) {
    const r = n.toLowerCase()
    if (r === 'true') return !0
    if (r === 'false') return !1
    if (r === 'undefined') return
    if (r === 'null') return null
    if (r === 'nan') return Number.NaN
    if (r === 'infinity') return Number.POSITIVE_INFINITY
    if (r === '-infinity') return Number.NEGATIVE_INFINITY
  }
  if (!fD.test(t)) {
    if (e.strict) throw new SyntaxError('[destr] Invalid JSON')
    return t
  }
  try {
    if (lD.test(t) || dD.test(t)) {
      if (e.strict) throw new Error('[destr] Possible prototype pollution')
      return JSON.parse(t, hD)
    }
    return JSON.parse(t)
  } catch (r) {
    if (e.strict) throw r
    return t
  }
}
function gD(t) {
  return !t || typeof t.then != 'function' ? Promise.resolve(t) : t
}
function ar(t, ...e) {
  try {
    return gD(t(...e))
  } catch (n) {
    return Promise.reject(n)
  }
}
function mD(t) {
  const e = typeof t
  return t === null || (e !== 'object' && e !== 'function')
}
function bD(t) {
  const e = Object.getPrototypeOf(t)
  return !e || e.isPrototypeOf(Object)
}
function _g(t) {
  if (mD(t)) return String(t)
  if (bD(t) || Array.isArray(t)) return JSON.stringify(t)
  if (typeof t.toJSON == 'function') return _g(t.toJSON())
  throw new Error('[unstorage] Cannot stringify value!')
}
const lw = 'base64:'
function yD(t) {
  return typeof t == 'string' ? t : lw + ED(t)
}
function vD(t) {
  return typeof t != 'string' || !t.startsWith(lw) ? t : wD(t.slice(lw.length))
}
function wD(t) {
  return globalThis.Buffer
    ? Buffer.from(t, 'base64')
    : Uint8Array.from(globalThis.atob(t), e => e.codePointAt(0))
}
function ED(t) {
  return globalThis.Buffer
    ? Buffer.from(t).toString('base64')
    : globalThis.btoa(String.fromCodePoint(...t))
}
function Yr(t) {
  var e
  return (
    (t &&
      ((e = t.split('?')[0]) == null
        ? void 0
        : e.replace(/[/\\]/g, ':').replace(/:+/g, ':').replace(/^:|:$/g, ''))) ||
    ''
  )
}
function AD(...t) {
  return Yr(t.join(':'))
}
function Z0(t) {
  return (t = Yr(t)), t ? t + ':' : ''
}
function _D(t, e) {
  if (e === void 0) return !0
  let n = 0,
    r = t.indexOf(':')
  for (; r > -1; ) n++, (r = t.indexOf(':', r + 1))
  return n <= e
}
function CD(t, e) {
  return e ? t.startsWith(e) && t[t.length - 1] !== '$' : t[t.length - 1] !== '$'
}
const SD = 'memory',
  TD = () => {
    const t = new Map()
    return {
      name: SD,
      getInstance: () => t,
      hasItem(e) {
        return t.has(e)
      },
      getItem(e) {
        return t.get(e) ?? null
      },
      getItemRaw(e) {
        return t.get(e) ?? null
      },
      setItem(e, n) {
        t.set(e, n)
      },
      setItemRaw(e, n) {
        t.set(e, n)
      },
      removeItem(e) {
        t.delete(e)
      },
      getKeys() {
        return [...t.keys()]
      },
      clear() {
        t.clear()
      },
      dispose() {
        t.clear()
      }
    }
  }
function xD(t = {}) {
  const e = {
      mounts: { '': t.driver || TD() },
      mountpoints: [''],
      watching: !1,
      watchListeners: [],
      unwatch: {}
    },
    n = d => {
      for (const p of e.mountpoints)
        if (d.startsWith(p)) return { base: p, relativeKey: d.slice(p.length), driver: e.mounts[p] }
      return { base: '', relativeKey: d, driver: e.mounts[''] }
    },
    r = (d, p) =>
      e.mountpoints
        .filter(g => g.startsWith(d) || (p && d.startsWith(g)))
        .map(g => ({
          relativeBase: d.length > g.length ? d.slice(g.length) : void 0,
          mountpoint: g,
          driver: e.mounts[g]
        })),
    i = (d, p) => {
      if (e.watching) {
        p = Yr(p)
        for (const g of e.watchListeners) g(d, p)
      }
    },
    s = async () => {
      if (!e.watching) {
        e.watching = !0
        for (const d in e.mounts) e.unwatch[d] = await WC(e.mounts[d], i, d)
      }
    },
    c = async () => {
      if (e.watching) {
        for (const d in e.unwatch) await e.unwatch[d]()
        ;(e.unwatch = {}), (e.watching = !1)
      }
    },
    u = (d, p, g) => {
      const m = new Map(),
        y = A => {
          let E = m.get(A.base)
          return E || ((E = { driver: A.driver, base: A.base, items: [] }), m.set(A.base, E)), E
        }
      for (const A of d) {
        const E = typeof A == 'string',
          x = Yr(E ? A : A.key),
          O = E ? void 0 : A.value,
          I = E || !A.options ? p : { ...p, ...A.options },
          M = n(x)
        y(M).items.push({ key: x, value: O, relativeKey: M.relativeKey, options: I })
      }
      return Promise.all([...m.values()].map(A => g(A))).then(A => A.flat())
    },
    f = {
      hasItem(d, p = {}) {
        d = Yr(d)
        const { relativeKey: g, driver: m } = n(d)
        return ar(m.hasItem, g, p)
      },
      getItem(d, p = {}) {
        d = Yr(d)
        const { relativeKey: g, driver: m } = n(d)
        return ar(m.getItem, g, p).then(y => Y0(y))
      },
      getItems(d, p = {}) {
        return u(d, p, g =>
          g.driver.getItems
            ? ar(
                g.driver.getItems,
                g.items.map(m => ({ key: m.relativeKey, options: m.options })),
                p
              ).then(m => m.map(y => ({ key: AD(g.base, y.key), value: Y0(y.value) })))
            : Promise.all(
                g.items.map(m =>
                  ar(g.driver.getItem, m.relativeKey, m.options).then(y => ({
                    key: m.key,
                    value: Y0(y)
                  }))
                )
              )
        )
      },
      getItemRaw(d, p = {}) {
        d = Yr(d)
        const { relativeKey: g, driver: m } = n(d)
        return m.getItemRaw ? ar(m.getItemRaw, g, p) : ar(m.getItem, g, p).then(y => vD(y))
      },
      async setItem(d, p, g = {}) {
        if (p === void 0) return f.removeItem(d)
        d = Yr(d)
        const { relativeKey: m, driver: y } = n(d)
        y.setItem && (await ar(y.setItem, m, _g(p), g), y.watch || i('update', d))
      },
      async setItems(d, p) {
        await u(d, p, async g => {
          if (g.driver.setItems)
            return ar(
              g.driver.setItems,
              g.items.map(m => ({ key: m.relativeKey, value: _g(m.value), options: m.options })),
              p
            )
          g.driver.setItem &&
            (await Promise.all(
              g.items.map(m => ar(g.driver.setItem, m.relativeKey, _g(m.value), m.options))
            ))
        })
      },
      async setItemRaw(d, p, g = {}) {
        if (p === void 0) return f.removeItem(d, g)
        d = Yr(d)
        const { relativeKey: m, driver: y } = n(d)
        if (y.setItemRaw) await ar(y.setItemRaw, m, p, g)
        else if (y.setItem) await ar(y.setItem, m, yD(p), g)
        else return
        y.watch || i('update', d)
      },
      async removeItem(d, p = {}) {
        typeof p == 'boolean' && (p = { removeMeta: p }), (d = Yr(d))
        const { relativeKey: g, driver: m } = n(d)
        m.removeItem &&
          (await ar(m.removeItem, g, p),
          (p.removeMeta || p.removeMata) && (await ar(m.removeItem, g + '$', p)),
          m.watch || i('remove', d))
      },
      async getMeta(d, p = {}) {
        typeof p == 'boolean' && (p = { nativeOnly: p }), (d = Yr(d))
        const { relativeKey: g, driver: m } = n(d),
          y = Object.create(null)
        if ((m.getMeta && Object.assign(y, await ar(m.getMeta, g, p)), !p.nativeOnly)) {
          const A = await ar(m.getItem, g + '$', p).then(E => Y0(E))
          A &&
            typeof A == 'object' &&
            (typeof A.atime == 'string' && (A.atime = new Date(A.atime)),
            typeof A.mtime == 'string' && (A.mtime = new Date(A.mtime)),
            Object.assign(y, A))
        }
        return y
      },
      setMeta(d, p, g = {}) {
        return this.setItem(d + '$', p, g)
      },
      removeMeta(d, p = {}) {
        return this.removeItem(d + '$', p)
      },
      async getKeys(d, p = {}) {
        var x
        d = Z0(d)
        const g = r(d, !0)
        let m = []
        const y = []
        let A = !0
        for (const O of g) {
          ;((x = O.driver.flags) != null && x.maxDepth) || (A = !1)
          const I = await ar(O.driver.getKeys, O.relativeBase, p)
          for (const M of I) {
            const $ = O.mountpoint + Yr(M)
            m.some(D => $.startsWith(D)) || y.push($)
          }
          m = [O.mountpoint, ...m.filter(M => !M.startsWith(O.mountpoint))]
        }
        const E = p.maxDepth !== void 0 && !A
        return y.filter(O => (!E || _D(O, p.maxDepth)) && CD(O, d))
      },
      async clear(d, p = {}) {
        ;(d = Z0(d)),
          await Promise.all(
            r(d, !1).map(async g => {
              if (g.driver.clear) return ar(g.driver.clear, g.relativeBase, p)
              if (g.driver.removeItem) {
                const m = await g.driver.getKeys(g.relativeBase || '', p)
                return Promise.all(m.map(y => g.driver.removeItem(y, p)))
              }
            })
          )
      },
      async dispose() {
        await Promise.all(Object.values(e.mounts).map(d => QC(d)))
      },
      async watch(d) {
        return (
          await s(),
          e.watchListeners.push(d),
          async () => {
            ;(e.watchListeners = e.watchListeners.filter(p => p !== d)),
              e.watchListeners.length === 0 && (await c())
          }
        )
      },
      async unwatch() {
        ;(e.watchListeners = []), await c()
      },
      mount(d, p) {
        if (((d = Z0(d)), d && e.mounts[d])) throw new Error(`already mounted at ${d}`)
        return (
          d && (e.mountpoints.push(d), e.mountpoints.sort((g, m) => m.length - g.length)),
          (e.mounts[d] = p),
          e.watching &&
            Promise.resolve(WC(p, i, d))
              .then(g => {
                e.unwatch[d] = g
              })
              .catch(console.error),
          f
        )
      },
      async unmount(d, p = !0) {
        var g, m
        ;(d = Z0(d)),
          !(!d || !e.mounts[d]) &&
            (e.watching &&
              d in e.unwatch &&
              ((m = (g = e.unwatch)[d]) == null || m.call(g), delete e.unwatch[d]),
            p && (await QC(e.mounts[d])),
            (e.mountpoints = e.mountpoints.filter(y => y !== d)),
            delete e.mounts[d])
      },
      getMount(d = '') {
        d = Yr(d) + ':'
        const p = n(d)
        return { driver: p.driver, base: p.base }
      },
      getMounts(d = '', p = {}) {
        return (d = Yr(d)), r(d, p.parents).map(m => ({ driver: m.driver, base: m.mountpoint }))
      },
      keys: (d, p = {}) => f.getKeys(d, p),
      get: (d, p = {}) => f.getItem(d, p),
      set: (d, p, g = {}) => f.setItem(d, p, g),
      has: (d, p = {}) => f.hasItem(d, p),
      del: (d, p = {}) => f.removeItem(d, p),
      remove: (d, p = {}) => f.removeItem(d, p)
    }
  return f
}
function WC(t, e, n) {
  return t.watch ? t.watch((r, i) => e(r, n + i)) : () => {}
}
async function QC(t) {
  typeof t.dispose == 'function' && (await ar(t.dispose))
}
function vu(t) {
  return new Promise((e, n) => {
    ;(t.oncomplete = t.onsuccess = () => e(t.result)), (t.onabort = t.onerror = () => n(t.error))
  })
}
function Z8(t, e) {
  const n = indexedDB.open(t)
  n.onupgradeneeded = () => n.result.createObjectStore(e)
  const r = vu(n)
  return (i, s) => r.then(c => s(c.transaction(e, i).objectStore(e)))
}
let wv
function hp() {
  return wv || (wv = Z8('keyval-store', 'keyval')), wv
}
function YC(t, e = hp()) {
  return e('readonly', n => vu(n.get(t)))
}
function ND(t, e, n = hp()) {
  return n('readwrite', r => (r.put(e, t), vu(r.transaction)))
}
function ID(t, e = hp()) {
  return e('readwrite', n => (n.delete(t), vu(n.transaction)))
}
function OD(t = hp()) {
  return t('readwrite', e => (e.clear(), vu(e.transaction)))
}
function RD(t, e) {
  return (
    (t.openCursor().onsuccess = function () {
      this.result && (e(this.result), this.result.continue())
    }),
    vu(t.transaction)
  )
}
function DD(t = hp()) {
  return t('readonly', e => {
    if (e.getAllKeys) return vu(e.getAllKeys())
    const n = []
    return RD(e, r => n.push(r.key)).then(() => n)
  })
}
const PD = t => JSON.stringify(t, (e, n) => (typeof n == 'bigint' ? n.toString() + 'n' : n)),
  MD = t => {
    const e =
        /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
      n = t.replace(e, '$1"$2n"$3')
    return JSON.parse(n, (r, i) =>
      typeof i == 'string' && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i
    )
  }
function Xc(t) {
  if (typeof t != 'string') throw new Error(`Cannot safe json parse value of type ${typeof t}`)
  try {
    return MD(t)
  } catch {
    return t
  }
}
function ka(t) {
  return typeof t == 'string' ? t : PD(t) || ''
}
const kD = 'idb-keyval'
var UD = (t = {}) => {
  const e = t.base && t.base.length > 0 ? `${t.base}:` : '',
    n = i => e + i
  let r
  return (
    t.dbName && t.storeName && (r = Z8(t.dbName, t.storeName)),
    {
      name: kD,
      options: t,
      async hasItem(i) {
        return !(typeof (await YC(n(i), r)) > 'u')
      },
      async getItem(i) {
        return (await YC(n(i), r)) ?? null
      },
      setItem(i, s) {
        return ND(n(i), s, r)
      },
      removeItem(i) {
        return ID(n(i), r)
      },
      getKeys() {
        return DD(r)
      },
      clear() {
        return OD(r)
      }
    }
  )
}
const BD = 'WALLET_CONNECT_V2_INDEXED_DB',
  LD = 'keyvaluestorage'
let $D = class {
  constructor() {
    this.indexedDb = xD({ driver: UD({ dbName: BD, storeName: LD }) })
  }
  async getKeys() {
    return this.indexedDb.getKeys()
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(e => [
      e.key,
      e.value
    ])
  }
  async getItem(e) {
    const n = await this.indexedDb.getItem(e)
    if (n !== null) return n
  }
  async setItem(e, n) {
    await this.indexedDb.setItem(e, ka(n))
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e)
  }
}
var Ev =
    typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
        ? window
        : typeof global < 'u'
          ? global
          : typeof self < 'u'
            ? self
            : {},
  Cg = { exports: {} }
;(function () {
  let t
  function e() {}
  ;(t = e),
    (t.prototype.getItem = function (n) {
      return this.hasOwnProperty(n) ? String(this[n]) : null
    }),
    (t.prototype.setItem = function (n, r) {
      this[n] = String(r)
    }),
    (t.prototype.removeItem = function (n) {
      delete this[n]
    }),
    (t.prototype.clear = function () {
      const n = this
      Object.keys(n).forEach(function (r) {
        ;(n[r] = void 0), delete n[r]
      })
    }),
    (t.prototype.key = function (n) {
      return (n = n || 0), Object.keys(this)[n]
    }),
    t.prototype.__defineGetter__('length', function () {
      return Object.keys(this).length
    }),
    typeof Ev < 'u' && Ev.localStorage
      ? (Cg.exports = Ev.localStorage)
      : typeof window < 'u' && window.localStorage
        ? (Cg.exports = window.localStorage)
        : (Cg.exports = new e())
})()
function FD(t) {
  var e
  return [t[0], Xc((e = t[1]) != null ? e : '')]
}
let jD = class {
  constructor() {
    this.localStorage = Cg.exports
  }
  async getKeys() {
    return Object.keys(this.localStorage)
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(FD)
  }
  async getItem(e) {
    const n = this.localStorage.getItem(e)
    if (n !== null) return Xc(n)
  }
  async setItem(e, n) {
    this.localStorage.setItem(e, ka(n))
  }
  async removeItem(e) {
    this.localStorage.removeItem(e)
  }
}
const zD = 'wc_storage_version',
  ZC = 1,
  qD = async (t, e, n) => {
    const r = zD,
      i = await e.getItem(r)
    if (i && i >= ZC) {
      n(e)
      return
    }
    const s = await t.getKeys()
    if (!s.length) {
      n(e)
      return
    }
    const c = []
    for (; s.length; ) {
      const u = s.shift()
      if (!u) continue
      const f = u.toLowerCase()
      if (
        f.includes('wc@') ||
        f.includes('walletconnect') ||
        f.includes('wc_') ||
        f.includes('wallet_connect')
      ) {
        const d = await t.getItem(u)
        await e.setItem(u, d), c.push(u)
      }
    }
    await e.setItem(r, ZC), n(e), HD(t, c)
  },
  HD = async (t, e) => {
    e.length &&
      e.forEach(async n => {
        await t.removeItem(n)
      })
  }
let GD = class {
  constructor() {
    ;(this.initialized = !1),
      (this.setInitialized = n => {
        ;(this.storage = n), (this.initialized = !0)
      })
    const e = new jD()
    this.storage = e
    try {
      const n = new $D()
      qD(e, n, this.setInitialized)
    } catch {
      this.initialized = !0
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys()
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries()
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e)
  }
  async setItem(e, n) {
    return await this.initialize(), this.storage.setItem(e, n)
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e)
  }
  async initialize() {
    this.initialized ||
      (await new Promise(e => {
        const n = setInterval(() => {
          this.initialized && (clearInterval(n), e())
        }, 20)
      }))
  }
}
var Av, XC
function VD() {
  if (XC) return Av
  XC = 1
  function t(n) {
    try {
      return JSON.stringify(n)
    } catch {
      return '"[Circular]"'
    }
  }
  Av = e
  function e(n, r, i) {
    var s = (i && i.stringify) || t,
      c = 1
    if (typeof n == 'object' && n !== null) {
      var u = r.length + c
      if (u === 1) return n
      var f = new Array(u)
      f[0] = s(n)
      for (var d = 1; d < u; d++) f[d] = s(r[d])
      return f.join(' ')
    }
    if (typeof n != 'string') return n
    var p = r.length
    if (p === 0) return n
    for (var g = '', m = 1 - c, y = -1, A = (n && n.length) || 0, E = 0; E < A; ) {
      if (n.charCodeAt(E) === 37 && E + 1 < A) {
        switch (((y = y > -1 ? y : 0), n.charCodeAt(E + 1))) {
          case 100:
          case 102:
            if (m >= p || r[m] == null) break
            y < E && (g += n.slice(y, E)), (g += Number(r[m])), (y = E + 2), E++
            break
          case 105:
            if (m >= p || r[m] == null) break
            y < E && (g += n.slice(y, E)), (g += Math.floor(Number(r[m]))), (y = E + 2), E++
            break
          case 79:
          case 111:
          case 106:
            if (m >= p || r[m] === void 0) break
            y < E && (g += n.slice(y, E))
            var x = typeof r[m]
            if (x === 'string') {
              ;(g += "'" + r[m] + "'"), (y = E + 2), E++
              break
            }
            if (x === 'function') {
              ;(g += r[m].name || '<anonymous>'), (y = E + 2), E++
              break
            }
            ;(g += s(r[m])), (y = E + 2), E++
            break
          case 115:
            if (m >= p) break
            y < E && (g += n.slice(y, E)), (g += String(r[m])), (y = E + 2), E++
            break
          case 37:
            y < E && (g += n.slice(y, E)), (g += '%'), (y = E + 2), E++, m--
            break
        }
        ++m
      }
      ++E
    }
    return y === -1 ? n : (y < A && (g += n.slice(y)), g)
  }
  return Av
}
var _v, JC
function KD() {
  if (JC) return _v
  JC = 1
  const t = VD()
  _v = i
  const e = D().console || {},
    n = {
      mapHttpRequest: A,
      mapHttpResponse: A,
      wrapRequestSerializer: E,
      wrapResponseSerializer: E,
      wrapErrorSerializer: E,
      req: A,
      res: A,
      err: m
    }
  function r(R, z) {
    return Array.isArray(R)
      ? R.filter(function (j) {
          return j !== '!stdSerializers.err'
        })
      : R === !0
        ? Object.keys(z)
        : !1
  }
  function i(R) {
    ;(R = R || {}), (R.browser = R.browser || {})
    const z = R.browser.transmit
    if (z && typeof z.send != 'function')
      throw Error('pino: transmit option must have a send function')
    const G = R.browser.write || e
    R.browser.write && (R.browser.asObject = !0)
    const j = R.serializers || {},
      V = r(R.browser.serialize, j)
    let L = R.browser.serialize
    Array.isArray(R.browser.serialize) &&
      R.browser.serialize.indexOf('!stdSerializers.err') > -1 &&
      (L = !1)
    const v = ['error', 'fatal', 'warn', 'info', 'debug', 'trace']
    typeof G == 'function' && (G.error = G.fatal = G.warn = G.info = G.debug = G.trace = G),
      R.enabled === !1 && (R.level = 'silent')
    const C = R.level || 'info',
      N = Object.create(G)
    N.log || (N.log = x),
      Object.defineProperty(N, 'levelVal', { get: S }),
      Object.defineProperty(N, 'level', { get: k, set: F })
    const T = {
      transmit: z,
      serialize: V,
      asObject: R.browser.asObject,
      levels: v,
      timestamp: y(R)
    }
    ;(N.levels = i.levels),
      (N.level = C),
      (N.setMaxListeners =
        N.getMaxListeners =
        N.emit =
        N.addListener =
        N.on =
        N.prependListener =
        N.once =
        N.prependOnceListener =
        N.removeListener =
        N.removeAllListeners =
        N.listeners =
        N.listenerCount =
        N.eventNames =
        N.write =
        N.flush =
          x),
      (N.serializers = j),
      (N._serialize = V),
      (N._stdErrSerialize = L),
      (N.child = P),
      z && (N._logEvent = g())
    function S() {
      return this.level === 'silent' ? 1 / 0 : this.levels.values[this.level]
    }
    function k() {
      return this._level
    }
    function F(w) {
      if (w !== 'silent' && !this.levels.values[w]) throw Error('unknown level ' + w)
      ;(this._level = w),
        s(T, N, 'error', 'log'),
        s(T, N, 'fatal', 'error'),
        s(T, N, 'warn', 'error'),
        s(T, N, 'info', 'log'),
        s(T, N, 'debug', 'log'),
        s(T, N, 'trace', 'log')
    }
    function P(w, B) {
      if (!w) throw new Error('missing bindings for child Pino')
      ;(B = B || {}), V && w.serializers && (B.serializers = w.serializers)
      const Z = B.serializers
      if (V && Z) {
        var ee = Object.assign({}, j, Z),
          Y = R.browser.serialize === !0 ? Object.keys(ee) : V
        delete w.serializers, f([w], Y, ee, this._stdErrSerialize)
      }
      function se(ce) {
        ;(this._childLevel = (ce._childLevel | 0) + 1),
          (this.error = d(ce, w, 'error')),
          (this.fatal = d(ce, w, 'fatal')),
          (this.warn = d(ce, w, 'warn')),
          (this.info = d(ce, w, 'info')),
          (this.debug = d(ce, w, 'debug')),
          (this.trace = d(ce, w, 'trace')),
          ee && ((this.serializers = ee), (this._serialize = Y)),
          z && (this._logEvent = g([].concat(ce._logEvent.bindings, w)))
      }
      return (se.prototype = this), new se(this)
    }
    return N
  }
  ;(i.levels = {
    values: { fatal: 60, error: 50, warn: 40, info: 30, debug: 20, trace: 10 },
    labels: { 10: 'trace', 20: 'debug', 30: 'info', 40: 'warn', 50: 'error', 60: 'fatal' }
  }),
    (i.stdSerializers = n),
    (i.stdTimeFunctions = Object.assign({}, { nullTime: O, epochTime: I, unixTime: M, isoTime: $ }))
  function s(R, z, G, j) {
    const V = Object.getPrototypeOf(z)
    ;(z[G] = z.levelVal > z.levels.values[G] ? x : V[G] ? V[G] : e[G] || e[j] || x), c(R, z, G)
  }
  function c(R, z, G) {
    ;(!R.transmit && z[G] === x) ||
      (z[G] = (function (j) {
        return function () {
          const L = R.timestamp(),
            v = new Array(arguments.length),
            C = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this
          for (var N = 0; N < v.length; N++) v[N] = arguments[N]
          if (
            (R.serialize &&
              !R.asObject &&
              f(v, this._serialize, this.serializers, this._stdErrSerialize),
            R.asObject ? j.call(C, u(this, G, v, L)) : j.apply(C, v),
            R.transmit)
          ) {
            const T = R.transmit.level || z.level,
              S = i.levels.values[T],
              k = i.levels.values[G]
            if (k < S) return
            p(
              this,
              {
                ts: L,
                methodLevel: G,
                methodValue: k,
                transmitValue: i.levels.values[R.transmit.level || z.level],
                send: R.transmit.send,
                val: z.levelVal
              },
              v
            )
          }
        }
      })(z[G]))
  }
  function u(R, z, G, j) {
    R._serialize && f(G, R._serialize, R.serializers, R._stdErrSerialize)
    const V = G.slice()
    let L = V[0]
    const v = {}
    j && (v.time = j), (v.level = i.levels.values[z])
    let C = (R._childLevel | 0) + 1
    if ((C < 1 && (C = 1), L !== null && typeof L == 'object')) {
      for (; C-- && typeof V[0] == 'object'; ) Object.assign(v, V.shift())
      L = V.length ? t(V.shift(), V) : void 0
    } else typeof L == 'string' && (L = t(V.shift(), V))
    return L !== void 0 && (v.msg = L), v
  }
  function f(R, z, G, j) {
    for (const V in R)
      if (j && R[V] instanceof Error) R[V] = i.stdSerializers.err(R[V])
      else if (typeof R[V] == 'object' && !Array.isArray(R[V]))
        for (const L in R[V]) z && z.indexOf(L) > -1 && L in G && (R[V][L] = G[L](R[V][L]))
  }
  function d(R, z, G) {
    return function () {
      const j = new Array(1 + arguments.length)
      j[0] = z
      for (var V = 1; V < j.length; V++) j[V] = arguments[V - 1]
      return R[G].apply(this, j)
    }
  }
  function p(R, z, G) {
    const j = z.send,
      V = z.ts,
      L = z.methodLevel,
      v = z.methodValue,
      C = z.val,
      N = R._logEvent.bindings
    f(
      G,
      R._serialize || Object.keys(R.serializers),
      R.serializers,
      R._stdErrSerialize === void 0 ? !0 : R._stdErrSerialize
    ),
      (R._logEvent.ts = V),
      (R._logEvent.messages = G.filter(function (T) {
        return N.indexOf(T) === -1
      })),
      (R._logEvent.level.label = L),
      (R._logEvent.level.value = v),
      j(L, R._logEvent, C),
      (R._logEvent = g(N))
  }
  function g(R) {
    return { ts: 0, messages: [], bindings: R || [], level: { label: '', value: 0 } }
  }
  function m(R) {
    const z = { type: R.constructor.name, msg: R.message, stack: R.stack }
    for (const G in R) z[G] === void 0 && (z[G] = R[G])
    return z
  }
  function y(R) {
    return typeof R.timestamp == 'function' ? R.timestamp : R.timestamp === !1 ? O : I
  }
  function A() {
    return {}
  }
  function E(R) {
    return R
  }
  function x() {}
  function O() {
    return !1
  }
  function I() {
    return Date.now()
  }
  function M() {
    return Math.round(Date.now() / 1e3)
  }
  function $() {
    return new Date(Date.now()).toISOString()
  }
  function D() {
    function R(z) {
      return typeof z < 'u' && z
    }
    try {
      return (
        typeof globalThis < 'u' ||
          Object.defineProperty(Object.prototype, 'globalThis', {
            get: function () {
              return delete Object.prototype.globalThis, (this.globalThis = this)
            },
            configurable: !0
          }),
        globalThis
      )
    } catch {
      return R(self) || R(window) || R(this) || {}
    }
  }
  return _v
}
var Tl = KD()
const pp = pd(Tl),
  WD = { level: 'info' },
  gp = 'custom_context',
  FE = 1e3 * 1024
let QD = class {
    constructor(e) {
      ;(this.nodeValue = e),
        (this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length),
        (this.next = null)
    }
    get value() {
      return this.nodeValue
    }
    get size() {
      return this.sizeInBytes
    }
  },
  eS = class {
    constructor(e) {
      ;(this.head = null),
        (this.tail = null),
        (this.lengthInNodes = 0),
        (this.maxSizeInBytes = e),
        (this.sizeInBytes = 0)
    }
    append(e) {
      const n = new QD(e)
      if (n.size > this.maxSizeInBytes)
        throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${n.size}`)
      for (; this.size + n.size > this.maxSizeInBytes; ) this.shift()
      this.head
        ? (this.tail && (this.tail.next = n), (this.tail = n))
        : ((this.head = n), (this.tail = n)),
        this.lengthInNodes++,
        (this.sizeInBytes += n.size)
    }
    shift() {
      if (!this.head) return
      const e = this.head
      ;(this.head = this.head.next),
        this.head || (this.tail = null),
        this.lengthInNodes--,
        (this.sizeInBytes -= e.size)
    }
    toArray() {
      const e = []
      let n = this.head
      for (; n !== null; ) e.push(n.value), (n = n.next)
      return e
    }
    get length() {
      return this.lengthInNodes
    }
    get size() {
      return this.sizeInBytes
    }
    toOrderedArray() {
      return Array.from(this)
    }
    [Symbol.iterator]() {
      let e = this.head
      return {
        next: () => {
          if (!e) return { done: !0, value: null }
          const n = e.value
          return (e = e.next), { done: !1, value: n }
        }
      }
    }
  },
  X8 = class {
    constructor(e, n = FE) {
      ;(this.level = e ?? 'error'),
        (this.levelValue = Tl.levels.values[this.level]),
        (this.MAX_LOG_SIZE_IN_BYTES = n),
        (this.logs = new eS(this.MAX_LOG_SIZE_IN_BYTES))
    }
    forwardToConsole(e, n) {
      n === Tl.levels.values.error
        ? console.error(e)
        : n === Tl.levels.values.warn
          ? console.warn(e)
          : n === Tl.levels.values.debug
            ? console.debug(e)
            : n === Tl.levels.values.trace
              ? console.trace(e)
              : console.log(e)
    }
    appendToLogs(e) {
      this.logs.append(ka({ timestamp: new Date().toISOString(), log: e }))
      const n = typeof e == 'string' ? JSON.parse(e).level : e.level
      n >= this.levelValue && this.forwardToConsole(e, n)
    }
    getLogs() {
      return this.logs
    }
    clearLogs() {
      this.logs = new eS(this.MAX_LOG_SIZE_IN_BYTES)
    }
    getLogArray() {
      return Array.from(this.logs)
    }
    logsToBlob(e) {
      const n = this.getLogArray()
      return n.push(ka({ extraMetadata: e })), new Blob(n, { type: 'application/json' })
    }
  },
  YD = class {
    constructor(e, n = FE) {
      this.baseChunkLogger = new X8(e, n)
    }
    write(e) {
      this.baseChunkLogger.appendToLogs(e)
    }
    getLogs() {
      return this.baseChunkLogger.getLogs()
    }
    clearLogs() {
      this.baseChunkLogger.clearLogs()
    }
    getLogArray() {
      return this.baseChunkLogger.getLogArray()
    }
    logsToBlob(e) {
      return this.baseChunkLogger.logsToBlob(e)
    }
    downloadLogsBlobInBrowser(e) {
      const n = URL.createObjectURL(this.logsToBlob(e)),
        r = document.createElement('a')
      ;(r.href = n),
        (r.download = `walletconnect-logs-${new Date().toISOString()}.txt`),
        document.body.appendChild(r),
        r.click(),
        document.body.removeChild(r),
        URL.revokeObjectURL(n)
    }
  },
  ZD = class {
    constructor(e, n = FE) {
      this.baseChunkLogger = new X8(e, n)
    }
    write(e) {
      this.baseChunkLogger.appendToLogs(e)
    }
    getLogs() {
      return this.baseChunkLogger.getLogs()
    }
    clearLogs() {
      this.baseChunkLogger.clearLogs()
    }
    getLogArray() {
      return this.baseChunkLogger.getLogArray()
    }
    logsToBlob(e) {
      return this.baseChunkLogger.logsToBlob(e)
    }
  }
var XD = Object.defineProperty,
  JD = Object.defineProperties,
  eP = Object.getOwnPropertyDescriptors,
  tS = Object.getOwnPropertySymbols,
  tP = Object.prototype.hasOwnProperty,
  nP = Object.prototype.propertyIsEnumerable,
  nS = (t, e, n) =>
    e in t ? XD(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  qg = (t, e) => {
    for (var n in e || (e = {})) tP.call(e, n) && nS(t, n, e[n])
    if (tS) for (var n of tS(e)) nP.call(e, n) && nS(t, n, e[n])
    return t
  },
  Hg = (t, e) => JD(t, eP(e))
function yd(t) {
  return Hg(qg({}, t), { level: (t == null ? void 0 : t.level) || WD.level })
}
function rP(t, e = gp) {
  return t[e] || ''
}
function iP(t, e, n = gp) {
  return (t[n] = e), t
}
function ni(t, e = gp) {
  let n = ''
  return typeof t.bindings > 'u' ? (n = rP(t, e)) : (n = t.bindings().context || ''), n
}
function sP(t, e, n = gp) {
  const r = ni(t, n)
  return r.trim() ? `${r}/${e}` : e
}
function Pr(t, e, n = gp) {
  const r = sP(t, e, n),
    i = t.child({ context: r })
  return iP(i, r, n)
}
function aP(t) {
  var e, n
  const r = new YD((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes)
  return {
    logger: pp(
      Hg(qg({}, t.opts), {
        level: 'trace',
        browser: Hg(qg({}, (n = t.opts) == null ? void 0 : n.browser), { write: i => r.write(i) })
      })
    ),
    chunkLoggerController: r
  }
}
function oP(t) {
  var e
  const n = new ZD((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes)
  return { logger: pp(Hg(qg({}, t.opts), { level: 'trace' }), n), chunkLoggerController: n }
}
function jE(t) {
  return typeof t.loggerOverride < 'u' && typeof t.loggerOverride != 'string'
    ? { logger: t.loggerOverride, chunkLoggerController: null }
    : typeof window < 'u'
      ? aP(t)
      : oP(t)
}
var cP = Object.defineProperty,
  uP = (t, e, n) =>
    e in t ? cP(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  rS = (t, e, n) => uP(t, typeof e != 'symbol' ? e + '' : e, n)
let lP = class extends yu {
  constructor(e) {
    super(), (this.opts = e), rS(this, 'protocol', 'wc'), rS(this, 'version', 2)
  }
}
var dP = Object.defineProperty,
  fP = (t, e, n) =>
    e in t ? dP(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  hP = (t, e, n) => fP(t, e + '', n)
let pP = class extends yu {
    constructor(e, n) {
      super(), (this.core = e), (this.logger = n), hP(this, 'records', new Map())
    }
  },
  gP = class {
    constructor(e, n) {
      ;(this.logger = e), (this.core = n)
    }
  },
  mP = class extends yu {
    constructor(e, n) {
      super(), (this.relayer = e), (this.logger = n)
    }
  },
  bP = class extends yu {
    constructor(e) {
      super()
    }
  },
  yP = class {
    constructor(e, n, r, i) {
      ;(this.core = e), (this.logger = n), (this.name = r)
    }
  },
  vP = class extends yu {
    constructor(e, n) {
      super(), (this.relayer = e), (this.logger = n)
    }
  },
  wP = class extends yu {
    constructor(e, n) {
      super(), (this.core = e), (this.logger = n)
    }
  },
  EP = class {
    constructor(e, n, r) {
      ;(this.core = e), (this.logger = n), (this.store = r)
    }
  },
  AP = class {
    constructor(e, n) {
      ;(this.projectId = e), (this.logger = n)
    }
  },
  _P = class {
    constructor(e, n, r) {
      ;(this.core = e), (this.logger = n), (this.telemetryEnabled = r)
    }
  }
var CP = Object.defineProperty,
  SP = (t, e, n) =>
    e in t ? CP(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  iS = (t, e, n) => SP(t, typeof e != 'symbol' ? e + '' : e, n)
let TP = class {
    constructor(e) {
      ;(this.opts = e), iS(this, 'protocol', 'wc'), iS(this, 'version', 2)
    }
  },
  xP = class {
    constructor(e) {
      this.client = e
    }
  }
function NP(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function J8(t, ...e) {
  if (!NP(t)) throw new Error('Uint8Array expected')
  if (e.length > 0 && !e.includes(t.length))
    throw new Error('Uint8Array expected of length ' + e + ', got length=' + t.length)
}
function sS(t, e = !0) {
  if (t.destroyed) throw new Error('Hash instance has been destroyed')
  if (e && t.finished) throw new Error('Hash#digest() has already been called')
}
function IP(t, e) {
  J8(t)
  const n = e.outputLen
  if (t.length < n) throw new Error('digestInto() expects output buffer of length at least ' + n)
}
const ol = typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Cv = t =>
  new DataView(t.buffer, t.byteOffset, t.byteLength)
function OP(t) {
  if (typeof t != 'string') throw new Error('utf8ToBytes expected string, got ' + typeof t)
  return new Uint8Array(new TextEncoder().encode(t))
}
function eT(t) {
  return typeof t == 'string' && (t = OP(t)), J8(t), t
}
let RP = class {
  clone() {
    return this._cloneInto()
  }
}
function DP(t) {
  const e = r => t().update(eT(r)).digest(),
    n = t()
  return (e.outputLen = n.outputLen), (e.blockLen = n.blockLen), (e.create = () => t()), e
}
function tT(t = 32) {
  if (ol && typeof ol.getRandomValues == 'function') return ol.getRandomValues(new Uint8Array(t))
  if (ol && typeof ol.randomBytes == 'function') return ol.randomBytes(t)
  throw new Error('crypto.getRandomValues must be defined')
}
function PP(t, e, n, r) {
  if (typeof t.setBigUint64 == 'function') return t.setBigUint64(e, n, r)
  const i = BigInt(32),
    s = BigInt(4294967295),
    c = Number((n >> i) & s),
    u = Number(n & s),
    f = r ? 4 : 0,
    d = r ? 0 : 4
  t.setUint32(e + f, c, r), t.setUint32(e + d, u, r)
}
let MP = class extends RP {
  constructor(e, n, r, i) {
    super(),
      (this.blockLen = e),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(e)),
      (this.view = Cv(this.buffer))
  }
  update(e) {
    sS(this)
    const { view: n, buffer: r, blockLen: i } = this
    e = eT(e)
    const s = e.length
    for (let c = 0; c < s; ) {
      const u = Math.min(i - this.pos, s - c)
      if (u === i) {
        const f = Cv(e)
        for (; i <= s - c; c += i) this.process(f, c)
        continue
      }
      r.set(e.subarray(c, c + u), this.pos),
        (this.pos += u),
        (c += u),
        this.pos === i && (this.process(n, 0), (this.pos = 0))
    }
    return (this.length += e.length), this.roundClean(), this
  }
  digestInto(e) {
    sS(this), IP(e, this), (this.finished = !0)
    const { buffer: n, view: r, blockLen: i, isLE: s } = this
    let { pos: c } = this
    ;(n[c++] = 128),
      this.buffer.subarray(c).fill(0),
      this.padOffset > i - c && (this.process(r, 0), (c = 0))
    for (let g = c; g < i; g++) n[g] = 0
    PP(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0)
    const u = Cv(e),
      f = this.outputLen
    if (f % 4) throw new Error('_sha2: outputLen should be aligned to 32bit')
    const d = f / 4,
      p = this.get()
    if (d > p.length) throw new Error('_sha2: outputLen bigger than state')
    for (let g = 0; g < d; g++) u.setUint32(4 * g, p[g], s)
  }
  digest() {
    const { buffer: e, outputLen: n } = this
    this.digestInto(e)
    const r = e.slice(0, n)
    return this.destroy(), r
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get())
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: c, pos: u } = this
    return (
      (e.length = i), (e.pos = u), (e.finished = s), (e.destroyed = c), i % n && e.buffer.set(r), e
    )
  }
}
const X0 = BigInt(2 ** 32 - 1),
  dw = BigInt(32)
function nT(t, e = !1) {
  return e
    ? { h: Number(t & X0), l: Number((t >> dw) & X0) }
    : { h: Number((t >> dw) & X0) | 0, l: Number(t & X0) | 0 }
}
function kP(t, e = !1) {
  let n = new Uint32Array(t.length),
    r = new Uint32Array(t.length)
  for (let i = 0; i < t.length; i++) {
    const { h: s, l: c } = nT(t[i], e)
    ;[n[i], r[i]] = [s, c]
  }
  return [n, r]
}
const UP = (t, e) => (BigInt(t >>> 0) << dw) | BigInt(e >>> 0),
  BP = (t, e, n) => t >>> n,
  LP = (t, e, n) => (t << (32 - n)) | (e >>> n),
  $P = (t, e, n) => (t >>> n) | (e << (32 - n)),
  FP = (t, e, n) => (t << (32 - n)) | (e >>> n),
  jP = (t, e, n) => (t << (64 - n)) | (e >>> (n - 32)),
  zP = (t, e, n) => (t >>> (n - 32)) | (e << (64 - n)),
  qP = (t, e) => e,
  HP = (t, e) => t,
  GP = (t, e, n) => (t << n) | (e >>> (32 - n)),
  VP = (t, e, n) => (e << n) | (t >>> (32 - n)),
  KP = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
  WP = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n))
function QP(t, e, n, r) {
  const i = (e >>> 0) + (r >>> 0)
  return { h: (t + n + ((i / 2 ** 32) | 0)) | 0, l: i | 0 }
}
const YP = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),
  ZP = (t, e, n, r) => (e + n + r + ((t / 2 ** 32) | 0)) | 0,
  XP = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
  JP = (t, e, n, r, i) => (e + n + r + i + ((t / 2 ** 32) | 0)) | 0,
  eM = (t, e, n, r, i) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
  tM = (t, e, n, r, i, s) => (e + n + r + i + s + ((t / 2 ** 32) | 0)) | 0,
  Ze = {
    fromBig: nT,
    split: kP,
    toBig: UP,
    shrSH: BP,
    shrSL: LP,
    rotrSH: $P,
    rotrSL: FP,
    rotrBH: jP,
    rotrBL: zP,
    rotr32H: qP,
    rotr32L: HP,
    rotlSH: GP,
    rotlSL: VP,
    rotlBH: KP,
    rotlBL: WP,
    add: QP,
    add3L: YP,
    add3H: ZP,
    add4L: XP,
    add4H: JP,
    add5H: tM,
    add5L: eM
  },
  [nM, rM] = Ze.split(
    [
      '0x428a2f98d728ae22',
      '0x7137449123ef65cd',
      '0xb5c0fbcfec4d3b2f',
      '0xe9b5dba58189dbbc',
      '0x3956c25bf348b538',
      '0x59f111f1b605d019',
      '0x923f82a4af194f9b',
      '0xab1c5ed5da6d8118',
      '0xd807aa98a3030242',
      '0x12835b0145706fbe',
      '0x243185be4ee4b28c',
      '0x550c7dc3d5ffb4e2',
      '0x72be5d74f27b896f',
      '0x80deb1fe3b1696b1',
      '0x9bdc06a725c71235',
      '0xc19bf174cf692694',
      '0xe49b69c19ef14ad2',
      '0xefbe4786384f25e3',
      '0x0fc19dc68b8cd5b5',
      '0x240ca1cc77ac9c65',
      '0x2de92c6f592b0275',
      '0x4a7484aa6ea6e483',
      '0x5cb0a9dcbd41fbd4',
      '0x76f988da831153b5',
      '0x983e5152ee66dfab',
      '0xa831c66d2db43210',
      '0xb00327c898fb213f',
      '0xbf597fc7beef0ee4',
      '0xc6e00bf33da88fc2',
      '0xd5a79147930aa725',
      '0x06ca6351e003826f',
      '0x142929670a0e6e70',
      '0x27b70a8546d22ffc',
      '0x2e1b21385c26c926',
      '0x4d2c6dfc5ac42aed',
      '0x53380d139d95b3df',
      '0x650a73548baf63de',
      '0x766a0abb3c77b2a8',
      '0x81c2c92e47edaee6',
      '0x92722c851482353b',
      '0xa2bfe8a14cf10364',
      '0xa81a664bbc423001',
      '0xc24b8b70d0f89791',
      '0xc76c51a30654be30',
      '0xd192e819d6ef5218',
      '0xd69906245565a910',
      '0xf40e35855771202a',
      '0x106aa07032bbd1b8',
      '0x19a4c116b8d2d0c8',
      '0x1e376c085141ab53',
      '0x2748774cdf8eeb99',
      '0x34b0bcb5e19b48a8',
      '0x391c0cb3c5c95a63',
      '0x4ed8aa4ae3418acb',
      '0x5b9cca4f7763e373',
      '0x682e6ff3d6b2b8a3',
      '0x748f82ee5defb2fc',
      '0x78a5636f43172f60',
      '0x84c87814a1f0ab72',
      '0x8cc702081a6439ec',
      '0x90befffa23631e28',
      '0xa4506cebde82bde9',
      '0xbef9a3f7b2c67915',
      '0xc67178f2e372532b',
      '0xca273eceea26619c',
      '0xd186b8c721c0c207',
      '0xeada7dd6cde0eb1e',
      '0xf57d4f7fee6ed178',
      '0x06f067aa72176fba',
      '0x0a637dc5a2c898a6',
      '0x113f9804bef90dae',
      '0x1b710b35131c471b',
      '0x28db77f523047d84',
      '0x32caab7b40c72493',
      '0x3c9ebe0a15c9bebc',
      '0x431d67c49c100d4c',
      '0x4cc5d4becb3e42b6',
      '0x597f299cfc657e2a',
      '0x5fcb6fab3ad6faec',
      '0x6c44198c4a475817'
    ].map(t => BigInt(t))
  ),
  fo = new Uint32Array(80),
  ho = new Uint32Array(80)
let iM = class extends MP {
  constructor() {
    super(128, 64, 16, !1),
      (this.Ah = 1779033703),
      (this.Al = -205731576),
      (this.Bh = -1150833019),
      (this.Bl = -2067093701),
      (this.Ch = 1013904242),
      (this.Cl = -23791573),
      (this.Dh = -1521486534),
      (this.Dl = 1595750129),
      (this.Eh = 1359893119),
      (this.El = -1377402159),
      (this.Fh = -1694144372),
      (this.Fl = 725511199),
      (this.Gh = 528734635),
      (this.Gl = -79577749),
      (this.Hh = 1541459225),
      (this.Hl = 327033209)
  }
  get() {
    const {
      Ah: e,
      Al: n,
      Bh: r,
      Bl: i,
      Ch: s,
      Cl: c,
      Dh: u,
      Dl: f,
      Eh: d,
      El: p,
      Fh: g,
      Fl: m,
      Gh: y,
      Gl: A,
      Hh: E,
      Hl: x
    } = this
    return [e, n, r, i, s, c, u, f, d, p, g, m, y, A, E, x]
  }
  set(e, n, r, i, s, c, u, f, d, p, g, m, y, A, E, x) {
    ;(this.Ah = e | 0),
      (this.Al = n | 0),
      (this.Bh = r | 0),
      (this.Bl = i | 0),
      (this.Ch = s | 0),
      (this.Cl = c | 0),
      (this.Dh = u | 0),
      (this.Dl = f | 0),
      (this.Eh = d | 0),
      (this.El = p | 0),
      (this.Fh = g | 0),
      (this.Fl = m | 0),
      (this.Gh = y | 0),
      (this.Gl = A | 0),
      (this.Hh = E | 0),
      (this.Hl = x | 0)
  }
  process(e, n) {
    for (let M = 0; M < 16; M++, n += 4) (fo[M] = e.getUint32(n)), (ho[M] = e.getUint32((n += 4)))
    for (let M = 16; M < 80; M++) {
      const $ = fo[M - 15] | 0,
        D = ho[M - 15] | 0,
        R = Ze.rotrSH($, D, 1) ^ Ze.rotrSH($, D, 8) ^ Ze.shrSH($, D, 7),
        z = Ze.rotrSL($, D, 1) ^ Ze.rotrSL($, D, 8) ^ Ze.shrSL($, D, 7),
        G = fo[M - 2] | 0,
        j = ho[M - 2] | 0,
        V = Ze.rotrSH(G, j, 19) ^ Ze.rotrBH(G, j, 61) ^ Ze.shrSH(G, j, 6),
        L = Ze.rotrSL(G, j, 19) ^ Ze.rotrBL(G, j, 61) ^ Ze.shrSL(G, j, 6),
        v = Ze.add4L(z, L, ho[M - 7], ho[M - 16]),
        C = Ze.add4H(v, R, V, fo[M - 7], fo[M - 16])
      ;(fo[M] = C | 0), (ho[M] = v | 0)
    }
    let {
      Ah: r,
      Al: i,
      Bh: s,
      Bl: c,
      Ch: u,
      Cl: f,
      Dh: d,
      Dl: p,
      Eh: g,
      El: m,
      Fh: y,
      Fl: A,
      Gh: E,
      Gl: x,
      Hh: O,
      Hl: I
    } = this
    for (let M = 0; M < 80; M++) {
      const $ = Ze.rotrSH(g, m, 14) ^ Ze.rotrSH(g, m, 18) ^ Ze.rotrBH(g, m, 41),
        D = Ze.rotrSL(g, m, 14) ^ Ze.rotrSL(g, m, 18) ^ Ze.rotrBL(g, m, 41),
        R = (g & y) ^ (~g & E),
        z = (m & A) ^ (~m & x),
        G = Ze.add5L(I, D, z, rM[M], ho[M]),
        j = Ze.add5H(G, O, $, R, nM[M], fo[M]),
        V = G | 0,
        L = Ze.rotrSH(r, i, 28) ^ Ze.rotrBH(r, i, 34) ^ Ze.rotrBH(r, i, 39),
        v = Ze.rotrSL(r, i, 28) ^ Ze.rotrBL(r, i, 34) ^ Ze.rotrBL(r, i, 39),
        C = (r & s) ^ (r & u) ^ (s & u),
        N = (i & c) ^ (i & f) ^ (c & f)
      ;(O = E | 0),
        (I = x | 0),
        (E = y | 0),
        (x = A | 0),
        (y = g | 0),
        (A = m | 0),
        ({ h: g, l: m } = Ze.add(d | 0, p | 0, j | 0, V | 0)),
        (d = u | 0),
        (p = f | 0),
        (u = s | 0),
        (f = c | 0),
        (s = r | 0),
        (c = i | 0)
      const T = Ze.add3L(V, v, N)
      ;(r = Ze.add3H(T, j, L, C)), (i = T | 0)
    }
    ;({ h: r, l: i } = Ze.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
      ({ h: s, l: c } = Ze.add(this.Bh | 0, this.Bl | 0, s | 0, c | 0)),
      ({ h: u, l: f } = Ze.add(this.Ch | 0, this.Cl | 0, u | 0, f | 0)),
      ({ h: d, l: p } = Ze.add(this.Dh | 0, this.Dl | 0, d | 0, p | 0)),
      ({ h: g, l: m } = Ze.add(this.Eh | 0, this.El | 0, g | 0, m | 0)),
      ({ h: y, l: A } = Ze.add(this.Fh | 0, this.Fl | 0, y | 0, A | 0)),
      ({ h: E, l: x } = Ze.add(this.Gh | 0, this.Gl | 0, E | 0, x | 0)),
      ({ h: O, l: I } = Ze.add(this.Hh | 0, this.Hl | 0, O | 0, I | 0)),
      this.set(r, i, s, c, u, f, d, p, g, m, y, A, E, x, O, I)
  }
  roundClean() {
    fo.fill(0), ho.fill(0)
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  }
}
const sM = DP(() => new iM())
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const zE = BigInt(0),
  rT = BigInt(1),
  aM = BigInt(2)
function qE(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function HE(t) {
  if (!qE(t)) throw new Error('Uint8Array expected')
}
function Sv(t, e) {
  if (typeof e != 'boolean') throw new Error(t + ' boolean expected, got ' + e)
}
const oM = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, '0'))
function GE(t) {
  HE(t)
  let e = ''
  for (let n = 0; n < t.length; n++) e += oM[t[n]]
  return e
}
function iT(t) {
  if (typeof t != 'string') throw new Error('hex string expected, got ' + typeof t)
  return t === '' ? zE : BigInt('0x' + t)
}
const ga = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }
function aS(t) {
  if (t >= ga._0 && t <= ga._9) return t - ga._0
  if (t >= ga.A && t <= ga.F) return t - (ga.A - 10)
  if (t >= ga.a && t <= ga.f) return t - (ga.a - 10)
}
function sT(t) {
  if (typeof t != 'string') throw new Error('hex string expected, got ' + typeof t)
  const e = t.length,
    n = e / 2
  if (e % 2) throw new Error('hex string expected, got unpadded hex of length ' + e)
  const r = new Uint8Array(n)
  for (let i = 0, s = 0; i < n; i++, s += 2) {
    const c = aS(t.charCodeAt(s)),
      u = aS(t.charCodeAt(s + 1))
    if (c === void 0 || u === void 0) {
      const f = t[s] + t[s + 1]
      throw new Error('hex string expected, got non-hex character "' + f + '" at index ' + s)
    }
    r[i] = c * 16 + u
  }
  return r
}
function cM(t) {
  return iT(GE(t))
}
function Sg(t) {
  return HE(t), iT(GE(Uint8Array.from(t).reverse()))
}
function aT(t, e) {
  return sT(t.toString(16).padStart(e * 2, '0'))
}
function fw(t, e) {
  return aT(t, e).reverse()
}
function ma(t, e, n) {
  let r
  if (typeof e == 'string')
    try {
      r = sT(e)
    } catch (s) {
      throw new Error(t + ' must be hex string or Uint8Array, cause: ' + s)
    }
  else if (qE(e)) r = Uint8Array.from(e)
  else throw new Error(t + ' must be hex string or Uint8Array')
  const i = r.length
  if (typeof n == 'number' && i !== n)
    throw new Error(t + ' of length ' + n + ' expected, got ' + i)
  return r
}
function oS(...t) {
  let e = 0
  for (let r = 0; r < t.length; r++) {
    const i = t[r]
    HE(i), (e += i.length)
  }
  const n = new Uint8Array(e)
  for (let r = 0, i = 0; r < t.length; r++) {
    const s = t[r]
    n.set(s, i), (i += s.length)
  }
  return n
}
const Tv = t => typeof t == 'bigint' && zE <= t
function uM(t, e, n) {
  return Tv(t) && Tv(e) && Tv(n) && e <= t && t < n
}
function kf(t, e, n, r) {
  if (!uM(e, n, r))
    throw new Error('expected valid ' + t + ': ' + n + ' <= n < ' + r + ', got ' + e)
}
function lM(t) {
  let e
  for (e = 0; t > zE; t >>= rT, e += 1);
  return e
}
const dM = t => (aM << BigInt(t - 1)) - rT,
  fM = {
    bigint: t => typeof t == 'bigint',
    function: t => typeof t == 'function',
    boolean: t => typeof t == 'boolean',
    string: t => typeof t == 'string',
    stringOrUint8Array: t => typeof t == 'string' || qE(t),
    isSafeInteger: t => Number.isSafeInteger(t),
    array: t => Array.isArray(t),
    field: (t, e) => e.Fp.isValid(t),
    hash: t => typeof t == 'function' && Number.isSafeInteger(t.outputLen)
  }
function VE(t, e, n = {}) {
  const r = (i, s, c) => {
    const u = fM[s]
    if (typeof u != 'function') throw new Error('invalid validator function')
    const f = t[i]
    if (!(c && f === void 0) && !u(f, t))
      throw new Error('param ' + String(i) + ' is invalid. Expected ' + s + ', got ' + f)
  }
  for (const [i, s] of Object.entries(e)) r(i, s, !1)
  for (const [i, s] of Object.entries(n)) r(i, s, !0)
  return t
}
function cS(t) {
  const e = new WeakMap()
  return (n, ...r) => {
    const i = e.get(n)
    if (i !== void 0) return i
    const s = t(n, ...r)
    return e.set(n, s), s
  }
}
const ur = BigInt(0),
  $n = BigInt(1),
  Nc = BigInt(2),
  hM = BigInt(3),
  hw = BigInt(4),
  uS = BigInt(5),
  lS = BigInt(8)
function Jn(t, e) {
  const n = t % e
  return n >= ur ? n : e + n
}
function pM(t, e, n) {
  if (e < ur) throw new Error('invalid exponent, negatives unsupported')
  if (n <= ur) throw new Error('invalid modulus')
  if (n === $n) return ur
  let r = $n
  for (; e > ur; ) e & $n && (r = (r * t) % n), (t = (t * t) % n), (e >>= $n)
  return r
}
function Ss(t, e, n) {
  let r = t
  for (; e-- > ur; ) (r *= r), (r %= n)
  return r
}
function dS(t, e) {
  if (t === ur) throw new Error('invert: expected non-zero number')
  if (e <= ur) throw new Error('invert: expected positive modulus, got ' + e)
  let n = Jn(t, e),
    r = e,
    i = ur,
    s = $n
  for (; n !== ur; ) {
    const c = r / n,
      u = r % n,
      f = i - s * c
    ;(r = n), (n = u), (i = s), (s = f)
  }
  if (r !== $n) throw new Error('invert: does not exist')
  return Jn(i, e)
}
function gM(t) {
  const e = (t - $n) / Nc
  let n, r, i
  for (n = t - $n, r = 0; n % Nc === ur; n /= Nc, r++);
  for (i = Nc; i < t && pM(i, e, t) !== t - $n; i++)
    if (i > 1e3) throw new Error('Cannot find square root: likely non-prime P')
  if (r === 1) {
    const c = (t + $n) / hw
    return function (u, f) {
      const d = u.pow(f, c)
      if (!u.eql(u.sqr(d), f)) throw new Error('Cannot find square root')
      return d
    }
  }
  const s = (n + $n) / Nc
  return function (c, u) {
    if (c.pow(u, e) === c.neg(c.ONE)) throw new Error('Cannot find square root')
    let f = r,
      d = c.pow(c.mul(c.ONE, i), n),
      p = c.pow(u, s),
      g = c.pow(u, n)
    for (; !c.eql(g, c.ONE); ) {
      if (c.eql(g, c.ZERO)) return c.ZERO
      let m = 1
      for (let A = c.sqr(g); m < f && !c.eql(A, c.ONE); m++) A = c.sqr(A)
      const y = c.pow(d, $n << BigInt(f - m - 1))
      ;(d = c.sqr(y)), (p = c.mul(p, y)), (g = c.mul(g, d)), (f = m)
    }
    return p
  }
}
function mM(t) {
  if (t % hw === hM) {
    const e = (t + $n) / hw
    return function (n, r) {
      const i = n.pow(r, e)
      if (!n.eql(n.sqr(i), r)) throw new Error('Cannot find square root')
      return i
    }
  }
  if (t % lS === uS) {
    const e = (t - uS) / lS
    return function (n, r) {
      const i = n.mul(r, Nc),
        s = n.pow(i, e),
        c = n.mul(r, s),
        u = n.mul(n.mul(c, Nc), s),
        f = n.mul(c, n.sub(u, n.ONE))
      if (!n.eql(n.sqr(f), r)) throw new Error('Cannot find square root')
      return f
    }
  }
  return gM(t)
}
const bM = (t, e) => (Jn(t, e) & $n) === $n,
  yM = [
    'create',
    'isValid',
    'is0',
    'neg',
    'inv',
    'sqrt',
    'sqr',
    'eql',
    'add',
    'sub',
    'mul',
    'pow',
    'div',
    'addN',
    'subN',
    'mulN',
    'sqrN'
  ]
function vM(t) {
  const e = { ORDER: 'bigint', MASK: 'bigint', BYTES: 'isSafeInteger', BITS: 'isSafeInteger' },
    n = yM.reduce((r, i) => ((r[i] = 'function'), r), e)
  return VE(t, n)
}
function wM(t, e, n) {
  if (n < ur) throw new Error('invalid exponent, negatives unsupported')
  if (n === ur) return t.ONE
  if (n === $n) return e
  let r = t.ONE,
    i = e
  for (; n > ur; ) n & $n && (r = t.mul(r, i)), (i = t.sqr(i)), (n >>= $n)
  return r
}
function EM(t, e) {
  const n = new Array(e.length),
    r = e.reduce((s, c, u) => (t.is0(c) ? s : ((n[u] = s), t.mul(s, c))), t.ONE),
    i = t.inv(r)
  return e.reduceRight((s, c, u) => (t.is0(c) ? s : ((n[u] = t.mul(s, n[u])), t.mul(s, c))), i), n
}
function oT(t, e) {
  const n = e !== void 0 ? e : t.toString(2).length,
    r = Math.ceil(n / 8)
  return { nBitLength: n, nByteLength: r }
}
function cT(t, e, n = !1, r = {}) {
  if (t <= ur) throw new Error('invalid field: expected ORDER > 0, got ' + t)
  const { nBitLength: i, nByteLength: s } = oT(t, e)
  if (s > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes')
  let c
  const u = Object.freeze({
    ORDER: t,
    isLE: n,
    BITS: i,
    BYTES: s,
    MASK: dM(i),
    ZERO: ur,
    ONE: $n,
    create: f => Jn(f, t),
    isValid: f => {
      if (typeof f != 'bigint')
        throw new Error('invalid field element: expected bigint, got ' + typeof f)
      return ur <= f && f < t
    },
    is0: f => f === ur,
    isOdd: f => (f & $n) === $n,
    neg: f => Jn(-f, t),
    eql: (f, d) => f === d,
    sqr: f => Jn(f * f, t),
    add: (f, d) => Jn(f + d, t),
    sub: (f, d) => Jn(f - d, t),
    mul: (f, d) => Jn(f * d, t),
    pow: (f, d) => wM(u, f, d),
    div: (f, d) => Jn(f * dS(d, t), t),
    sqrN: f => f * f,
    addN: (f, d) => f + d,
    subN: (f, d) => f - d,
    mulN: (f, d) => f * d,
    inv: f => dS(f, t),
    sqrt: r.sqrt || (f => (c || (c = mM(t)), c(u, f))),
    invertBatch: f => EM(u, f),
    cmov: (f, d, p) => (p ? d : f),
    toBytes: f => (n ? fw(f, s) : aT(f, s)),
    fromBytes: f => {
      if (f.length !== s)
        throw new Error('Field.fromBytes: expected ' + s + ' bytes, got ' + f.length)
      return n ? Sg(f) : cM(f)
    }
  })
  return Object.freeze(u)
}
const fS = BigInt(0),
  J0 = BigInt(1)
function xv(t, e) {
  const n = e.negate()
  return t ? n : e
}
function uT(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e)
    throw new Error('invalid window size, expected [1..' + e + '], got W=' + t)
}
function Nv(t, e) {
  uT(t, e)
  const n = Math.ceil(e / t) + 1,
    r = 2 ** (t - 1)
  return { windows: n, windowSize: r }
}
function AM(t, e) {
  if (!Array.isArray(t)) throw new Error('array expected')
  t.forEach((n, r) => {
    if (!(n instanceof e)) throw new Error('invalid point at index ' + r)
  })
}
function _M(t, e) {
  if (!Array.isArray(t)) throw new Error('array of scalars expected')
  t.forEach((n, r) => {
    if (!e.isValid(n)) throw new Error('invalid scalar at index ' + r)
  })
}
const Iv = new WeakMap(),
  lT = new WeakMap()
function Ov(t) {
  return lT.get(t) || 1
}
function CM(t, e) {
  return {
    constTimeNegate: xv,
    hasPrecomputes(n) {
      return Ov(n) !== 1
    },
    unsafeLadder(n, r, i = t.ZERO) {
      let s = n
      for (; r > fS; ) r & J0 && (i = i.add(s)), (s = s.double()), (r >>= J0)
      return i
    },
    precomputeWindow(n, r) {
      const { windows: i, windowSize: s } = Nv(r, e),
        c = []
      let u = n,
        f = u
      for (let d = 0; d < i; d++) {
        ;(f = u), c.push(f)
        for (let p = 1; p < s; p++) (f = f.add(u)), c.push(f)
        u = f.double()
      }
      return c
    },
    wNAF(n, r, i) {
      const { windows: s, windowSize: c } = Nv(n, e)
      let u = t.ZERO,
        f = t.BASE
      const d = BigInt(2 ** n - 1),
        p = 2 ** n,
        g = BigInt(n)
      for (let m = 0; m < s; m++) {
        const y = m * c
        let A = Number(i & d)
        ;(i >>= g), A > c && ((A -= p), (i += J0))
        const E = y,
          x = y + Math.abs(A) - 1,
          O = m % 2 !== 0,
          I = A < 0
        A === 0 ? (f = f.add(xv(O, r[E]))) : (u = u.add(xv(I, r[x])))
      }
      return { p: u, f }
    },
    wNAFUnsafe(n, r, i, s = t.ZERO) {
      const { windows: c, windowSize: u } = Nv(n, e),
        f = BigInt(2 ** n - 1),
        d = 2 ** n,
        p = BigInt(n)
      for (let g = 0; g < c; g++) {
        const m = g * u
        if (i === fS) break
        let y = Number(i & f)
        if (((i >>= p), y > u && ((y -= d), (i += J0)), y === 0)) continue
        let A = r[m + Math.abs(y) - 1]
        y < 0 && (A = A.negate()), (s = s.add(A))
      }
      return s
    },
    getPrecomputes(n, r, i) {
      let s = Iv.get(r)
      return s || ((s = this.precomputeWindow(r, n)), n !== 1 && Iv.set(r, i(s))), s
    },
    wNAFCached(n, r, i) {
      const s = Ov(n)
      return this.wNAF(s, this.getPrecomputes(s, n, i), r)
    },
    wNAFCachedUnsafe(n, r, i, s) {
      const c = Ov(n)
      return c === 1
        ? this.unsafeLadder(n, r, s)
        : this.wNAFUnsafe(c, this.getPrecomputes(c, n, i), r, s)
    },
    setWindowSize(n, r) {
      uT(r, e), lT.set(n, r), Iv.delete(n)
    }
  }
}
function SM(t, e, n, r) {
  if ((AM(n, t), _M(r, e), n.length !== r.length))
    throw new Error('arrays of points and scalars must have equal length')
  const i = t.ZERO,
    s = lM(BigInt(n.length)),
    c = s > 12 ? s - 3 : s > 4 ? s - 2 : s ? 2 : 1,
    u = (1 << c) - 1,
    f = new Array(u + 1).fill(i),
    d = Math.floor((e.BITS - 1) / c) * c
  let p = i
  for (let g = d; g >= 0; g -= c) {
    f.fill(i)
    for (let y = 0; y < r.length; y++) {
      const A = r[y],
        E = Number((A >> BigInt(g)) & BigInt(u))
      f[E] = f[E].add(n[y])
    }
    let m = i
    for (let y = f.length - 1, A = i; y > 0; y--) (A = A.add(f[y])), (m = m.add(A))
    if (((p = p.add(m)), g !== 0)) for (let y = 0; y < c; y++) p = p.double()
  }
  return p
}
function TM(t) {
  return (
    vM(t.Fp),
    VE(
      t,
      { n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field' },
      { nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger' }
    ),
    Object.freeze({ ...oT(t.n, t.nBitLength), ...t, p: t.Fp.ORDER })
  )
}
const es = BigInt(0),
  Vr = BigInt(1),
  eg = BigInt(2),
  xM = BigInt(8),
  NM = { zip215: !0 }
function IM(t) {
  const e = TM(t)
  return (
    VE(
      t,
      { hash: 'function', a: 'bigint', d: 'bigint', randomBytes: 'function' },
      {
        adjustScalarBytes: 'function',
        domain: 'function',
        uvRatio: 'function',
        mapToCurve: 'function'
      }
    ),
    Object.freeze({ ...e })
  )
}
function OM(t) {
  const e = IM(t),
    { Fp: n, n: r, prehash: i, hash: s, randomBytes: c, nByteLength: u, h: f } = e,
    d = eg << (BigInt(u * 8) - Vr),
    p = n.create,
    g = cT(e.n, e.nBitLength),
    m =
      e.uvRatio ||
      ((T, S) => {
        try {
          return { isValid: !0, value: n.sqrt(T * n.inv(S)) }
        } catch {
          return { isValid: !1, value: es }
        }
      }),
    y = e.adjustScalarBytes || (T => T),
    A =
      e.domain ||
      ((T, S, k) => {
        if ((Sv('phflag', k), S.length || k)) throw new Error('Contexts/pre-hash are not supported')
        return T
      })
  function E(T, S) {
    kf('coordinate ' + T, S, es, d)
  }
  function x(T) {
    if (!(T instanceof M)) throw new Error('ExtendedPoint expected')
  }
  const O = cS((T, S) => {
      const { ex: k, ey: F, ez: P } = T,
        w = T.is0()
      S == null && (S = w ? xM : n.inv(P))
      const B = p(k * S),
        Z = p(F * S),
        ee = p(P * S)
      if (w) return { x: es, y: Vr }
      if (ee !== Vr) throw new Error('invZ was invalid')
      return { x: B, y: Z }
    }),
    I = cS(T => {
      const { a: S, d: k } = e
      if (T.is0()) throw new Error('bad point: ZERO')
      const { ex: F, ey: P, ez: w, et: B } = T,
        Z = p(F * F),
        ee = p(P * P),
        Y = p(w * w),
        se = p(Y * Y),
        ce = p(Z * S),
        we = p(Y * p(ce + ee)),
        _e = p(se + p(k * p(Z * ee)))
      if (we !== _e) throw new Error('bad point: equation left != right (1)')
      const ye = p(F * P),
        Ce = p(w * B)
      if (ye !== Ce) throw new Error('bad point: equation left != right (2)')
      return !0
    })
  class M {
    constructor(S, k, F, P) {
      ;(this.ex = S),
        (this.ey = k),
        (this.ez = F),
        (this.et = P),
        E('x', S),
        E('y', k),
        E('z', F),
        E('t', P),
        Object.freeze(this)
    }
    get x() {
      return this.toAffine().x
    }
    get y() {
      return this.toAffine().y
    }
    static fromAffine(S) {
      if (S instanceof M) throw new Error('extended point not allowed')
      const { x: k, y: F } = S || {}
      return E('x', k), E('y', F), new M(k, F, Vr, p(k * F))
    }
    static normalizeZ(S) {
      const k = n.invertBatch(S.map(F => F.ez))
      return S.map((F, P) => F.toAffine(k[P])).map(M.fromAffine)
    }
    static msm(S, k) {
      return SM(M, g, S, k)
    }
    _setWindowSize(S) {
      R.setWindowSize(this, S)
    }
    assertValidity() {
      I(this)
    }
    equals(S) {
      x(S)
      const { ex: k, ey: F, ez: P } = this,
        { ex: w, ey: B, ez: Z } = S,
        ee = p(k * Z),
        Y = p(w * P),
        se = p(F * Z),
        ce = p(B * P)
      return ee === Y && se === ce
    }
    is0() {
      return this.equals(M.ZERO)
    }
    negate() {
      return new M(p(-this.ex), this.ey, this.ez, p(-this.et))
    }
    double() {
      const { a: S } = e,
        { ex: k, ey: F, ez: P } = this,
        w = p(k * k),
        B = p(F * F),
        Z = p(eg * p(P * P)),
        ee = p(S * w),
        Y = k + F,
        se = p(p(Y * Y) - w - B),
        ce = ee + B,
        we = ce - Z,
        _e = ee - B,
        ye = p(se * we),
        Ce = p(ce * _e),
        kt = p(se * _e),
        tt = p(we * ce)
      return new M(ye, Ce, tt, kt)
    }
    add(S) {
      x(S)
      const { a: k, d: F } = e,
        { ex: P, ey: w, ez: B, et: Z } = this,
        { ex: ee, ey: Y, ez: se, et: ce } = S
      if (k === BigInt(-1)) {
        const Ot = p((w - P) * (Y + ee)),
          yi = p((w + P) * (Y - ee)),
          xt = p(yi - Ot)
        if (xt === es) return this.double()
        const zt = p(B * eg * ce),
          ms = p(Z * eg * se),
          Je = ms + zt,
          Rt = yi + Ot,
          Ki = ms - zt,
          qt = p(Je * xt),
          Zt = p(Rt * Ki),
          _u = p(Je * Ki),
          dn = p(xt * Rt)
        return new M(qt, Zt, dn, _u)
      }
      const we = p(P * ee),
        _e = p(w * Y),
        ye = p(Z * F * ce),
        Ce = p(B * se),
        kt = p((P + w) * (ee + Y) - we - _e),
        tt = Ce - ye,
        Ke = Ce + ye,
        jn = p(_e - k * we),
        ut = p(kt * tt),
        lt = p(Ke * jn),
        qr = p(kt * jn),
        It = p(tt * Ke)
      return new M(ut, lt, It, qr)
    }
    subtract(S) {
      return this.add(S.negate())
    }
    wNAF(S) {
      return R.wNAFCached(this, S, M.normalizeZ)
    }
    multiply(S) {
      const k = S
      kf('scalar', k, Vr, r)
      const { p: F, f: P } = this.wNAF(k)
      return M.normalizeZ([F, P])[0]
    }
    multiplyUnsafe(S, k = M.ZERO) {
      const F = S
      return (
        kf('scalar', F, es, r),
        F === es ? D : this.is0() || F === Vr ? this : R.wNAFCachedUnsafe(this, F, M.normalizeZ, k)
      )
    }
    isSmallOrder() {
      return this.multiplyUnsafe(f).is0()
    }
    isTorsionFree() {
      return R.unsafeLadder(this, r).is0()
    }
    toAffine(S) {
      return O(this, S)
    }
    clearCofactor() {
      const { h: S } = e
      return S === Vr ? this : this.multiplyUnsafe(S)
    }
    static fromHex(S, k = !1) {
      const { d: F, a: P } = e,
        w = n.BYTES
      ;(S = ma('pointHex', S, w)), Sv('zip215', k)
      const B = S.slice(),
        Z = S[w - 1]
      B[w - 1] = Z & -129
      const ee = Sg(B),
        Y = k ? d : n.ORDER
      kf('pointHex.y', ee, es, Y)
      const se = p(ee * ee),
        ce = p(se - Vr),
        we = p(F * se - P)
      let { isValid: _e, value: ye } = m(ce, we)
      if (!_e) throw new Error('Point.fromHex: invalid y coordinate')
      const Ce = (ye & Vr) === Vr,
        kt = (Z & 128) !== 0
      if (!k && ye === es && kt) throw new Error('Point.fromHex: x=0 and x_0=1')
      return kt !== Ce && (ye = p(-ye)), M.fromAffine({ x: ye, y: ee })
    }
    static fromPrivateKey(S) {
      return j(S).point
    }
    toRawBytes() {
      const { x: S, y: k } = this.toAffine(),
        F = fw(k, n.BYTES)
      return (F[F.length - 1] |= S & Vr ? 128 : 0), F
    }
    toHex() {
      return GE(this.toRawBytes())
    }
  }
  ;(M.BASE = new M(e.Gx, e.Gy, Vr, p(e.Gx * e.Gy))), (M.ZERO = new M(es, Vr, Vr, es))
  const { BASE: $, ZERO: D } = M,
    R = CM(M, u * 8)
  function z(T) {
    return Jn(T, r)
  }
  function G(T) {
    return z(Sg(T))
  }
  function j(T) {
    const S = n.BYTES
    T = ma('private key', T, S)
    const k = ma('hashed private key', s(T), 2 * S),
      F = y(k.slice(0, S)),
      P = k.slice(S, 2 * S),
      w = G(F),
      B = $.multiply(w),
      Z = B.toRawBytes()
    return { head: F, prefix: P, scalar: w, point: B, pointBytes: Z }
  }
  function V(T) {
    return j(T).pointBytes
  }
  function L(T = new Uint8Array(), ...S) {
    const k = oS(...S)
    return G(s(A(k, ma('context', T), !!i)))
  }
  function v(T, S, k = {}) {
    ;(T = ma('message', T)), i && (T = i(T))
    const { prefix: F, scalar: P, pointBytes: w } = j(S),
      B = L(k.context, F, T),
      Z = $.multiply(B).toRawBytes(),
      ee = L(k.context, Z, w, T),
      Y = z(B + ee * P)
    kf('signature.s', Y, es, r)
    const se = oS(Z, fw(Y, n.BYTES))
    return ma('result', se, n.BYTES * 2)
  }
  const C = NM
  function N(T, S, k, F = C) {
    const { context: P, zip215: w } = F,
      B = n.BYTES
    ;(T = ma('signature', T, 2 * B)),
      (S = ma('message', S)),
      (k = ma('publicKey', k, B)),
      w !== void 0 && Sv('zip215', w),
      i && (S = i(S))
    const Z = Sg(T.slice(B, 2 * B))
    let ee, Y, se
    try {
      ;(ee = M.fromHex(k, w)), (Y = M.fromHex(T.slice(0, B), w)), (se = $.multiplyUnsafe(Z))
    } catch {
      return !1
    }
    if (!w && ee.isSmallOrder()) return !1
    const ce = L(P, Y.toRawBytes(), ee.toRawBytes(), S)
    return Y.add(ee.multiplyUnsafe(ce)).subtract(se).clearCofactor().equals(M.ZERO)
  }
  return (
    $._setWindowSize(8),
    {
      CURVE: e,
      getPublicKey: V,
      sign: v,
      verify: N,
      ExtendedPoint: M,
      utils: {
        getExtendedPublicKey: j,
        randomPrivateKey: () => c(n.BYTES),
        precompute(T = 8, S = M.BASE) {
          return S._setWindowSize(T), S.multiply(BigInt(3)), S
        }
      }
    }
  )
}
BigInt(0), BigInt(1)
const KE = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),
  hS = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752')
BigInt(0)
const RM = BigInt(1),
  pS = BigInt(2)
BigInt(3)
const DM = BigInt(5),
  PM = BigInt(8)
function MM(t) {
  const e = BigInt(10),
    n = BigInt(20),
    r = BigInt(40),
    i = BigInt(80),
    s = KE,
    c = (((t * t) % s) * t) % s,
    u = (Ss(c, pS, s) * c) % s,
    f = (Ss(u, RM, s) * t) % s,
    d = (Ss(f, DM, s) * f) % s,
    p = (Ss(d, e, s) * d) % s,
    g = (Ss(p, n, s) * p) % s,
    m = (Ss(g, r, s) * g) % s,
    y = (Ss(m, i, s) * m) % s,
    A = (Ss(y, i, s) * m) % s,
    E = (Ss(A, e, s) * d) % s
  return { pow_p_5_8: (Ss(E, pS, s) * t) % s, b2: c }
}
function kM(t) {
  return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t
}
function UM(t, e) {
  const n = KE,
    r = Jn(e * e * e, n),
    i = Jn(r * r * e, n),
    s = MM(t * i).pow_p_5_8
  let c = Jn(t * r * s, n)
  const u = Jn(e * c * c, n),
    f = c,
    d = Jn(c * hS, n),
    p = u === t,
    g = u === Jn(-t, n),
    m = u === Jn(-t * hS, n)
  return (
    p && (c = f), (g || m) && (c = d), bM(c, n) && (c = Jn(-c, n)), { isValid: p || g, value: c }
  )
}
const BM = cT(KE, void 0, !0),
  LM = {
    a: BigInt(-1),
    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
    Fp: BM,
    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),
    h: PM,
    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),
    hash: sM,
    randomBytes: tT,
    adjustScalarBytes: kM,
    uvRatio: UM
  },
  dT = OM(LM),
  $M = 'EdDSA',
  FM = 'JWT',
  Gg = '.',
  Nm = 'base64url',
  fT = 'utf8',
  hT = 'utf8',
  jM = ':',
  zM = 'did',
  qM = 'key',
  gS = 'base58btc',
  HM = 'z',
  GM = 'K36',
  VM = 32
function WE(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t
}
function pT(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? WE(globalThis.Buffer.allocUnsafe(t))
    : new Uint8Array(t)
}
function gT(t, e) {
  e || (e = t.reduce((i, s) => i + s.length, 0))
  const n = pT(e)
  let r = 0
  for (const i of t) n.set(i, r), (r += i.length)
  return WE(n)
}
function KM(t, e) {
  if (t.length >= 255) throw new TypeError('Alphabet too long')
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i),
      c = s.charCodeAt(0)
    if (n[c] !== 255) throw new TypeError(s + ' is ambiguous')
    n[c] = i
  }
  var u = t.length,
    f = t.charAt(0),
    d = Math.log(u) / Math.log(256),
    p = Math.log(256) / Math.log(u)
  function g(A) {
    if (
      (A instanceof Uint8Array ||
        (ArrayBuffer.isView(A)
          ? (A = new Uint8Array(A.buffer, A.byteOffset, A.byteLength))
          : Array.isArray(A) && (A = Uint8Array.from(A))),
      !(A instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (A.length === 0) return ''
    for (var E = 0, x = 0, O = 0, I = A.length; O !== I && A[O] === 0; ) O++, E++
    for (var M = ((I - O) * p + 1) >>> 0, $ = new Uint8Array(M); O !== I; ) {
      for (var D = A[O], R = 0, z = M - 1; (D !== 0 || R < x) && z !== -1; z--, R++)
        (D += (256 * $[z]) >>> 0), ($[z] = D % u >>> 0), (D = (D / u) >>> 0)
      if (D !== 0) throw new Error('Non-zero carry')
      ;(x = R), O++
    }
    for (var G = M - x; G !== M && $[G] === 0; ) G++
    for (var j = f.repeat(E); G < M; ++G) j += t.charAt($[G])
    return j
  }
  function m(A) {
    if (typeof A != 'string') throw new TypeError('Expected String')
    if (A.length === 0) return new Uint8Array()
    var E = 0
    if (A[E] !== ' ') {
      for (var x = 0, O = 0; A[E] === f; ) x++, E++
      for (var I = ((A.length - E) * d + 1) >>> 0, M = new Uint8Array(I); A[E]; ) {
        var $ = n[A.charCodeAt(E)]
        if ($ === 255) return
        for (var D = 0, R = I - 1; ($ !== 0 || D < O) && R !== -1; R--, D++)
          ($ += (u * M[R]) >>> 0), (M[R] = $ % 256 >>> 0), ($ = ($ / 256) >>> 0)
        if ($ !== 0) throw new Error('Non-zero carry')
        ;(O = D), E++
      }
      if (A[E] !== ' ') {
        for (var z = I - O; z !== I && M[z] === 0; ) z++
        for (var G = new Uint8Array(x + (I - z)), j = x; z !== I; ) G[j++] = M[z++]
        return G
      }
    }
  }
  function y(A) {
    var E = m(A)
    if (E) return E
    throw new Error(`Non-${e} character`)
  }
  return { encode: g, decodeUnsafe: m, decode: y }
}
var WM = KM,
  QM = WM
const mT = t => {
    if (t instanceof Uint8Array && t.constructor.name === 'Uint8Array') return t
    if (t instanceof ArrayBuffer) return new Uint8Array(t)
    if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
    throw new Error('Unknown type, must be binary type')
  },
  YM = t => new TextEncoder().encode(t),
  ZM = t => new TextDecoder().decode(t)
let XM = class {
    constructor(e, n, r) {
      ;(this.name = e), (this.prefix = n), (this.baseEncode = r)
    }
    encode(e) {
      if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
      throw Error('Unknown type, must be binary type')
    }
  },
  JM = class {
    constructor(e, n, r) {
      if (((this.name = e), (this.prefix = n), n.codePointAt(0) === void 0))
        throw new Error('Invalid prefix character')
      ;(this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = r)
    }
    decode(e) {
      if (typeof e == 'string') {
        if (e.codePointAt(0) !== this.prefixCodePoint)
          throw Error(
            `Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`
          )
        return this.baseDecode(e.slice(this.prefix.length))
      } else throw Error('Can only multibase decode strings')
    }
    or(e) {
      return bT(this, e)
    }
  },
  ek = class {
    constructor(e) {
      this.decoders = e
    }
    or(e) {
      return bT(this, e)
    }
    decode(e) {
      const n = e[0],
        r = this.decoders[n]
      if (r) return r.decode(e)
      throw RangeError(
        `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
      )
    }
  }
const bT = (t, e) =>
  new ek({ ...(t.decoders || { [t.prefix]: t }), ...(e.decoders || { [e.prefix]: e }) })
let tk = class {
  constructor(e, n, r, i) {
    ;(this.name = e),
      (this.prefix = n),
      (this.baseEncode = r),
      (this.baseDecode = i),
      (this.encoder = new XM(e, n, r)),
      (this.decoder = new JM(e, n, i))
  }
  encode(e) {
    return this.encoder.encode(e)
  }
  decode(e) {
    return this.decoder.decode(e)
  }
}
const Im = ({ name: t, prefix: e, encode: n, decode: r }) => new tk(t, e, n, r),
  mp = ({ prefix: t, name: e, alphabet: n }) => {
    const { encode: r, decode: i } = QM(n, e)
    return Im({ prefix: t, name: e, encode: r, decode: s => mT(i(s)) })
  },
  nk = (t, e, n, r) => {
    const i = {}
    for (let p = 0; p < e.length; ++p) i[e[p]] = p
    let s = t.length
    for (; t[s - 1] === '='; ) --s
    const c = new Uint8Array(((s * n) / 8) | 0)
    let u = 0,
      f = 0,
      d = 0
    for (let p = 0; p < s; ++p) {
      const g = i[t[p]]
      if (g === void 0) throw new SyntaxError(`Non-${r} character`)
      ;(f = (f << n) | g), (u += n), u >= 8 && ((u -= 8), (c[d++] = 255 & (f >> u)))
    }
    if (u >= n || 255 & (f << (8 - u))) throw new SyntaxError('Unexpected end of data')
    return c
  },
  rk = (t, e, n) => {
    const r = e[e.length - 1] === '=',
      i = (1 << n) - 1
    let s = '',
      c = 0,
      u = 0
    for (let f = 0; f < t.length; ++f)
      for (u = (u << 8) | t[f], c += 8; c > n; ) (c -= n), (s += e[i & (u >> c)])
    if ((c && (s += e[i & (u << (n - c))]), r)) for (; (s.length * n) & 7; ) s += '='
    return s
  },
  Er = ({ name: t, prefix: e, bitsPerChar: n, alphabet: r }) =>
    Im({
      prefix: e,
      name: t,
      encode(i) {
        return rk(i, r, n)
      },
      decode(i) {
        return nk(i, r, n, t)
      }
    }),
  ik = Im({ prefix: '\0', name: 'identity', encode: t => ZM(t), decode: t => YM(t) })
var sk = Object.freeze({ __proto__: null, identity: ik })
const ak = Er({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 })
var ok = Object.freeze({ __proto__: null, base2: ak })
const ck = Er({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 })
var uk = Object.freeze({ __proto__: null, base8: ck })
const lk = mp({ prefix: '9', name: 'base10', alphabet: '0123456789' })
var dk = Object.freeze({ __proto__: null, base10: lk })
const fk = Er({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 }),
  hk = Er({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 })
var pk = Object.freeze({ __proto__: null, base16: fk, base16upper: hk })
const gk = Er({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
  }),
  mk = Er({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
  }),
  bk = Er({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
  }),
  yk = Er({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
  }),
  vk = Er({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
  }),
  wk = Er({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
  }),
  Ek = Er({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
  }),
  Ak = Er({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
  }),
  _k = Er({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
  })
var Ck = Object.freeze({
  __proto__: null,
  base32: gk,
  base32upper: mk,
  base32pad: bk,
  base32padupper: yk,
  base32hex: vk,
  base32hexupper: wk,
  base32hexpad: Ek,
  base32hexpadupper: Ak,
  base32z: _k
})
const Sk = mp({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' }),
  Tk = mp({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' })
var xk = Object.freeze({ __proto__: null, base36: Sk, base36upper: Tk })
const Nk = mp({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
  }),
  Ik = mp({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
  })
var Ok = Object.freeze({ __proto__: null, base58btc: Nk, base58flickr: Ik })
const Rk = Er({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
  }),
  Dk = Er({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
  }),
  Pk = Er({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
  }),
  Mk = Er({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
  })
var kk = Object.freeze({
  __proto__: null,
  base64: Rk,
  base64pad: Dk,
  base64url: Pk,
  base64urlpad: Mk
})
const yT = Array.from(
    '🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂'
  ),
  Uk = yT.reduce((t, e, n) => ((t[n] = e), t), []),
  Bk = yT.reduce((t, e, n) => ((t[e.codePointAt(0)] = n), t), [])
function Lk(t) {
  return t.reduce((e, n) => ((e += Uk[n]), e), '')
}
function $k(t) {
  const e = []
  for (const n of t) {
    const r = Bk[n.codePointAt(0)]
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`)
    e.push(r)
  }
  return new Uint8Array(e)
}
const Fk = Im({ prefix: '🚀', name: 'base256emoji', encode: Lk, decode: $k })
var jk = Object.freeze({ __proto__: null, base256emoji: Fk }),
  zk = vT,
  mS = 128,
  qk = -128,
  Hk = Math.pow(2, 31)
function vT(t, e, n) {
  ;(e = e || []), (n = n || 0)
  for (var r = n; t >= Hk; ) (e[n++] = (t & 255) | mS), (t /= 128)
  for (; t & qk; ) (e[n++] = (t & 255) | mS), (t >>>= 7)
  return (e[n] = t | 0), (vT.bytes = n - r + 1), e
}
var Gk = pw,
  Vk = 128,
  bS = 127
function pw(t, r) {
  var n = 0,
    r = r || 0,
    i = 0,
    s = r,
    c,
    u = t.length
  do {
    if (s >= u) throw ((pw.bytes = 0), new RangeError('Could not decode varint'))
    ;(c = t[s++]), (n += i < 28 ? (c & bS) << i : (c & bS) * Math.pow(2, i)), (i += 7)
  } while (c >= Vk)
  return (pw.bytes = s - r), n
}
var Kk = Math.pow(2, 7),
  Wk = Math.pow(2, 14),
  Qk = Math.pow(2, 21),
  Yk = Math.pow(2, 28),
  Zk = Math.pow(2, 35),
  Xk = Math.pow(2, 42),
  Jk = Math.pow(2, 49),
  eU = Math.pow(2, 56),
  tU = Math.pow(2, 63),
  nU = function (t) {
    return t < Kk
      ? 1
      : t < Wk
        ? 2
        : t < Qk
          ? 3
          : t < Yk
            ? 4
            : t < Zk
              ? 5
              : t < Xk
                ? 6
                : t < Jk
                  ? 7
                  : t < eU
                    ? 8
                    : t < tU
                      ? 9
                      : 10
  },
  rU = { encode: zk, decode: Gk, encodingLength: nU },
  wT = rU
const yS = (t, e, n = 0) => (wT.encode(t, e, n), e),
  vS = t => wT.encodingLength(t),
  gw = (t, e) => {
    const n = e.byteLength,
      r = vS(t),
      i = r + vS(n),
      s = new Uint8Array(i + n)
    return yS(t, s, 0), yS(n, s, r), s.set(e, i), new iU(t, n, e, s)
  }
let iU = class {
  constructor(e, n, r, i) {
    ;(this.code = e), (this.size = n), (this.digest = r), (this.bytes = i)
  }
}
const ET = ({ name: t, code: e, encode: n }) => new sU(t, e, n)
let sU = class {
  constructor(e, n, r) {
    ;(this.name = e), (this.code = n), (this.encode = r)
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const n = this.encode(e)
      return n instanceof Uint8Array ? gw(this.code, n) : n.then(r => gw(this.code, r))
    } else throw Error('Unknown type, must be binary type')
  }
}
const AT = t => async e => new Uint8Array(await crypto.subtle.digest(t, e)),
  aU = ET({ name: 'sha2-256', code: 18, encode: AT('SHA-256') }),
  oU = ET({ name: 'sha2-512', code: 19, encode: AT('SHA-512') })
var cU = Object.freeze({ __proto__: null, sha256: aU, sha512: oU })
const _T = 0,
  uU = 'identity',
  CT = mT,
  lU = t => gw(_T, CT(t)),
  dU = { code: _T, name: uU, encode: CT, digest: lU }
var fU = Object.freeze({ __proto__: null, identity: dU })
new TextEncoder(), new TextDecoder()
const wS = { ...sk, ...ok, ...uk, ...dk, ...pk, ...Ck, ...xk, ...Ok, ...kk, ...jk }
;({ ...cU, ...fU })
function ST(t, e, n, r) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: n }, decoder: { decode: r } }
}
const ES = ST(
    'utf8',
    'u',
    t => 'u' + new TextDecoder('utf8').decode(t),
    t => new TextEncoder().encode(t.substring(1))
  ),
  Rv = ST(
    'ascii',
    'a',
    t => {
      let e = 'a'
      for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n])
      return e
    },
    t => {
      t = t.substring(1)
      const e = pT(t.length)
      for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n)
      return e
    }
  ),
  TT = { utf8: ES, 'utf-8': ES, hex: wS.base16, latin1: Rv, ascii: Rv, binary: Rv, ...wS }
function Om(t, e = 'utf8') {
  const n = TT[e]
  if (!n) throw new Error(`Unsupported encoding "${e}"`)
  return (e === 'utf8' || e === 'utf-8') &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString('utf8')
    : n.encoder.encode(t).substring(1)
}
function vd(t, e = 'utf8') {
  const n = TT[e]
  if (!n) throw new Error(`Unsupported encoding "${e}"`)
  return (e === 'utf8' || e === 'utf-8') &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? WE(globalThis.Buffer.from(t, 'utf-8'))
    : n.decoder.decode(`${n.prefix}${t}`)
}
function AS(t) {
  return Xc(Om(vd(t, Nm), fT))
}
function Vg(t) {
  return Om(vd(ka(t), fT), Nm)
}
function xT(t) {
  const e = vd(GM, gS),
    n = HM + Om(gT([e, t]), gS)
  return [zM, qM, n].join(jM)
}
function hU(t) {
  return Om(t, Nm)
}
function pU(t) {
  return vd(t, Nm)
}
function gU(t) {
  return vd([Vg(t.header), Vg(t.payload)].join(Gg), hT)
}
function mU(t) {
  return [Vg(t.header), Vg(t.payload), hU(t.signature)].join(Gg)
}
function mw(t) {
  const e = t.split(Gg),
    n = AS(e[0]),
    r = AS(e[1]),
    i = pU(e[2]),
    s = vd(e.slice(0, 2).join(Gg), hT)
  return { header: n, payload: r, signature: i, data: s }
}
function _S(t = tT(VM)) {
  const e = dT.getPublicKey(t)
  return { secretKey: gT([t, e]), publicKey: e }
}
async function bU(t, e, n, r, i = ge.fromMiliseconds(Date.now())) {
  const s = { alg: $M, typ: FM },
    c = xT(r.publicKey),
    u = i + n,
    f = { iss: c, sub: t, aud: e, iat: i, exp: u },
    d = gU({ header: s, payload: f }),
    p = dT.sign(d, r.secretKey.slice(0, 32))
  return mU({ header: s, payload: f, signature: p })
}
var CS = function (t, e, n) {
    if (n || arguments.length === 2)
      for (var r = 0, i = e.length, s; r < i; r++)
        (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), (s[r] = e[r]))
    return t.concat(s || Array.prototype.slice.call(e))
  },
  yU = (function () {
    function t(e, n, r) {
      ;(this.name = e), (this.version = n), (this.os = r), (this.type = 'browser')
    }
    return t
  })(),
  vU = (function () {
    function t(e) {
      ;(this.version = e), (this.type = 'node'), (this.name = 'node'), (this.os = process.platform)
    }
    return t
  })(),
  wU = (function () {
    function t(e, n, r, i) {
      ;(this.name = e),
        (this.version = n),
        (this.os = r),
        (this.bot = i),
        (this.type = 'bot-device')
    }
    return t
  })(),
  EU = (function () {
    function t() {
      ;(this.type = 'bot'),
        (this.bot = !0),
        (this.name = 'bot'),
        (this.version = null),
        (this.os = null)
    }
    return t
  })(),
  AU = (function () {
    function t() {
      ;(this.type = 'react-native'),
        (this.name = 'react-native'),
        (this.version = null),
        (this.os = null)
    }
    return t
  })(),
  _U =
    /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
  CU = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
  SS = 3,
  SU = [
    ['aol', /AOLShield\/([0-9\._]+)/],
    ['edge', /Edge\/([0-9\._]+)/],
    ['edge-ios', /EdgiOS\/([0-9\._]+)/],
    ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
    ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
    ['samsung', /SamsungBrowser\/([0-9\.]+)/],
    ['silk', /\bSilk\/([0-9._-]+)\b/],
    ['miui', /MiuiBrowser\/([0-9\.]+)$/],
    ['beaker', /BeakerBrowser\/([0-9\.]+)/],
    ['edge-chromium', /EdgA?\/([0-9\.]+)/],
    ['chromium-webview', /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
    ['fxios', /FxiOS\/([0-9\.]+)/],
    ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
    ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
    ['pie', /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
    [
      'pie',
      /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/
    ],
    ['netfront', /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
    ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ['android', /Android\s([0-9\.]+)/],
    ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9\._]+).*Safari/],
    ['facebook', /FB[AS]V\/([0-9\.]+)/],
    ['instagram', /Instagram\s([0-9\.]+)/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ['curl', /^curl\/([0-9\.]+)$/],
    ['searchbot', _U]
  ],
  TS = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Windows CE', /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\/2/]
  ]
function TU(t) {
  return typeof document > 'u' && typeof navigator < 'u' && navigator.product === 'ReactNative'
    ? new AU()
    : typeof navigator < 'u'
      ? NU(navigator.userAgent)
      : OU()
}
function xU(t) {
  return (
    t !== '' &&
    SU.reduce(function (e, n) {
      var r = n[0],
        i = n[1]
      if (e) return e
      var s = i.exec(t)
      return !!s && [r, s]
    }, !1)
  )
}
function NU(t) {
  var e = xU(t)
  if (!e) return null
  var n = e[0],
    r = e[1]
  if (n === 'searchbot') return new EU()
  var i = r[1] && r[1].split('.').join('_').split('_').slice(0, 3)
  i ? i.length < SS && (i = CS(CS([], i, !0), RU(SS - i.length), !0)) : (i = [])
  var s = i.join('.'),
    c = IU(t),
    u = CU.exec(t)
  return u && u[1] ? new wU(n, s, c, u[1]) : new yU(n, s, c)
}
function IU(t) {
  for (var e = 0, n = TS.length; e < n; e++) {
    var r = TS[e],
      i = r[0],
      s = r[1],
      c = s.exec(t)
    if (c) return i
  }
  return null
}
function OU() {
  var t = typeof process < 'u' && process.version
  return t ? new vU(process.version.slice(1)) : null
}
function RU(t) {
  for (var e = [], n = 0; n < t; n++) e.push('0')
  return e
}
var en = {},
  xS
function NT() {
  if (xS) return en
  ;(xS = 1),
    Object.defineProperty(en, '__esModule', { value: !0 }),
    (en.getLocalStorage =
      en.getLocalStorageOrThrow =
      en.getCrypto =
      en.getCryptoOrThrow =
      en.getLocation =
      en.getLocationOrThrow =
      en.getNavigator =
      en.getNavigatorOrThrow =
      en.getDocument =
      en.getDocumentOrThrow =
      en.getFromWindowOrThrow =
      en.getFromWindow =
        void 0)
  function t(m) {
    let y
    return typeof window < 'u' && typeof window[m] < 'u' && (y = window[m]), y
  }
  en.getFromWindow = t
  function e(m) {
    const y = t(m)
    if (!y) throw new Error(`${m} is not defined in Window`)
    return y
  }
  en.getFromWindowOrThrow = e
  function n() {
    return e('document')
  }
  en.getDocumentOrThrow = n
  function r() {
    return t('document')
  }
  en.getDocument = r
  function i() {
    return e('navigator')
  }
  en.getNavigatorOrThrow = i
  function s() {
    return t('navigator')
  }
  en.getNavigator = s
  function c() {
    return e('location')
  }
  en.getLocationOrThrow = c
  function u() {
    return t('location')
  }
  en.getLocation = u
  function f() {
    return e('crypto')
  }
  en.getCryptoOrThrow = f
  function d() {
    return t('crypto')
  }
  en.getCrypto = d
  function p() {
    return e('localStorage')
  }
  en.getLocalStorageOrThrow = p
  function g() {
    return t('localStorage')
  }
  return (en.getLocalStorage = g), en
}
var Jc = NT(),
  Uf = {},
  NS
function DU() {
  if (NS) return Uf
  ;(NS = 1), Object.defineProperty(Uf, '__esModule', { value: !0 }), (Uf.getWindowMetadata = void 0)
  const t = NT()
  function e() {
    let n, r
    try {
      ;(n = t.getDocumentOrThrow()), (r = t.getLocationOrThrow())
    } catch {
      return null
    }
    function i() {
      const y = n.getElementsByTagName('link'),
        A = []
      for (let E = 0; E < y.length; E++) {
        const x = y[E],
          O = x.getAttribute('rel')
        if (O && O.toLowerCase().indexOf('icon') > -1) {
          const I = x.getAttribute('href')
          if (I)
            if (
              I.toLowerCase().indexOf('https:') === -1 &&
              I.toLowerCase().indexOf('http:') === -1 &&
              I.indexOf('//') !== 0
            ) {
              let M = r.protocol + '//' + r.host
              if (I.indexOf('/') === 0) M += I
              else {
                const $ = r.pathname.split('/')
                $.pop()
                const D = $.join('/')
                M += D + '/' + I
              }
              A.push(M)
            } else if (I.indexOf('//') === 0) {
              const M = r.protocol + I
              A.push(M)
            } else A.push(I)
        }
      }
      return A
    }
    function s(...y) {
      const A = n.getElementsByTagName('meta')
      for (let E = 0; E < A.length; E++) {
        const x = A[E],
          O = ['itemprop', 'property', 'name']
            .map(I => x.getAttribute(I))
            .filter(I => (I ? y.includes(I) : !1))
        if (O.length && O) {
          const I = x.getAttribute('content')
          if (I) return I
        }
      }
      return ''
    }
    function c() {
      let y = s('name', 'og:site_name', 'og:title', 'twitter:title')
      return y || (y = n.title), y
    }
    function u() {
      return s('description', 'og:description', 'twitter:description', 'keywords')
    }
    const f = c(),
      d = u(),
      p = r.origin,
      g = i()
    return { description: d, url: p, icons: g, name: f }
  }
  return (Uf.getWindowMetadata = e), Uf
}
var PU = DU()
const MU = '1.0.8'
let qi = class bw extends Error {
  constructor(e, n = {}) {
    var c
    const r =
        n.cause instanceof bw
          ? n.cause.details
          : (c = n.cause) != null && c.message
            ? n.cause.message
            : n.details,
      i = (n.cause instanceof bw && n.cause.docsPath) || n.docsPath,
      s = [
        e || 'An error occurred.',
        '',
        ...(n.metaMessages ? [...n.metaMessages, ''] : []),
        ...(i ? [`Docs: https://abitype.dev${i}`] : []),
        ...(r ? [`Details: ${r}`] : []),
        `Version: abitype@${MU}`
      ].join(`
`)
    super(s),
      Object.defineProperty(this, 'details', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'docsPath', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'metaMessages', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'shortMessage', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'AbiTypeError'
      }),
      n.cause && (this.cause = n.cause),
      (this.details = r),
      (this.docsPath = i),
      (this.metaMessages = n.metaMessages),
      (this.shortMessage = e)
  }
}
function $a(t, e) {
  const n = t.exec(e)
  return n == null ? void 0 : n.groups
}
const IT = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
  OT =
    /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
  RT = /^\(.+?\).*?$/,
  IS = /^tuple(?<array>(\[(\d*)\])*)$/
function yw(t) {
  let e = t.type
  if (IS.test(t.type) && 'components' in t) {
    e = '('
    const n = t.components.length
    for (let i = 0; i < n; i++) {
      const s = t.components[i]
      ;(e += yw(s)), i < n - 1 && (e += ', ')
    }
    const r = $a(IS, t.type)
    return (e += `)${(r == null ? void 0 : r.array) ?? ''}`), yw({ ...t, type: e })
  }
  return 'indexed' in t && t.indexed && (e = `${e} indexed`), t.name ? `${e} ${t.name}` : e
}
function Bf(t) {
  let e = ''
  const n = t.length
  for (let r = 0; r < n; r++) {
    const i = t[r]
    ;(e += yw(i)), r !== n - 1 && (e += ', ')
  }
  return e
}
function kU(t) {
  var e
  return t.type === 'function'
    ? `function ${t.name}(${Bf(t.inputs)})${t.stateMutability && t.stateMutability !== 'nonpayable' ? ` ${t.stateMutability}` : ''}${(e = t.outputs) != null && e.length ? ` returns (${Bf(t.outputs)})` : ''}`
    : t.type === 'event'
      ? `event ${t.name}(${Bf(t.inputs)})`
      : t.type === 'error'
        ? `error ${t.name}(${Bf(t.inputs)})`
        : t.type === 'constructor'
          ? `constructor(${Bf(t.inputs)})${t.stateMutability === 'payable' ? ' payable' : ''}`
          : t.type === 'fallback'
            ? `fallback() external${t.stateMutability === 'payable' ? ' payable' : ''}`
            : 'receive() external payable'
}
const DT = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/
function UU(t) {
  return DT.test(t)
}
function BU(t) {
  return $a(DT, t)
}
const PT = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/
function LU(t) {
  return PT.test(t)
}
function $U(t) {
  return $a(PT, t)
}
const MT =
  /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/
function FU(t) {
  return MT.test(t)
}
function jU(t) {
  return $a(MT, t)
}
const kT = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/
function UT(t) {
  return kT.test(t)
}
function zU(t) {
  return $a(kT, t)
}
const BT = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/
function qU(t) {
  return BT.test(t)
}
function HU(t) {
  return $a(BT, t)
}
const LT = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/
function GU(t) {
  return LT.test(t)
}
function VU(t) {
  return $a(LT, t)
}
const KU = /^receive\(\) external payable$/
function WU(t) {
  return KU.test(t)
}
const QU = new Set(['indexed']),
  vw = new Set(['calldata', 'memory', 'storage'])
class YU extends qi {
  constructor({ type: e }) {
    super('Unknown type.', {
      metaMessages: [
        `Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'UnknownTypeError'
      })
  }
}
class ZU extends qi {
  constructor({ type: e }) {
    super('Unknown type.', { metaMessages: [`Type "${e}" is not a valid ABI type.`] }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'UnknownSolidityTypeError'
      })
  }
}
class XU extends qi {
  constructor({ param: e }) {
    super('Invalid ABI parameter.', { details: e }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidParameterError'
      })
  }
}
class JU extends qi {
  constructor({ param: e, name: n }) {
    super('Invalid ABI parameter.', {
      details: e,
      metaMessages: [
        `"${n}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'SolidityProtectedKeywordError'
      })
  }
}
class eB extends qi {
  constructor({ param: e, type: n, modifier: r }) {
    super('Invalid ABI parameter.', {
      details: e,
      metaMessages: [`Modifier "${r}" not allowed${n ? ` in "${n}" type` : ''}.`]
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidModifierError'
      })
  }
}
class tB extends qi {
  constructor({ param: e, type: n, modifier: r }) {
    super('Invalid ABI parameter.', {
      details: e,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ''}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`
      ]
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidFunctionModifierError'
      })
  }
}
class nB extends qi {
  constructor({ abiParameter: e }) {
    super('Invalid ABI parameter.', {
      details: JSON.stringify(e, null, 2),
      metaMessages: ['ABI parameter type is invalid.']
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidAbiTypeParameterError'
      })
  }
}
class wd extends qi {
  constructor({ signature: e, type: n }) {
    super(`Invalid ${n} signature.`, { details: e }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidSignatureError'
      })
  }
}
class rB extends qi {
  constructor({ signature: e }) {
    super('Unknown signature.', { details: e }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'UnknownSignatureError'
      })
  }
}
class iB extends qi {
  constructor({ signature: e }) {
    super('Invalid struct signature.', { details: e, metaMessages: ['No properties exist.'] }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidStructSignatureError'
      })
  }
}
class sB extends qi {
  constructor({ type: e }) {
    super('Circular reference detected.', {
      metaMessages: [`Struct "${e}" is a circular reference.`]
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'CircularReferenceError'
      })
  }
}
class aB extends qi {
  constructor({ current: e, depth: n }) {
    super('Unbalanced parentheses.', {
      metaMessages: [`"${e.trim()}" has too many ${n > 0 ? 'opening' : 'closing'} parentheses.`],
      details: `Depth "${n}"`
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidParenthesisError'
      })
  }
}
function oB(t, e, n) {
  let r = ''
  if (n)
    for (const i of Object.entries(n)) {
      if (!i) continue
      let s = ''
      for (const c of i[1]) s += `[${c.type}${c.name ? `:${c.name}` : ''}]`
      r += `(${i[0]}{${s}})`
    }
  return e ? `${e}:${t}${r}` : t
}
const Dv = new Map([
  ['address', { type: 'address' }],
  ['bool', { type: 'bool' }],
  ['bytes', { type: 'bytes' }],
  ['bytes32', { type: 'bytes32' }],
  ['int', { type: 'int256' }],
  ['int256', { type: 'int256' }],
  ['string', { type: 'string' }],
  ['uint', { type: 'uint256' }],
  ['uint8', { type: 'uint8' }],
  ['uint16', { type: 'uint16' }],
  ['uint24', { type: 'uint24' }],
  ['uint32', { type: 'uint32' }],
  ['uint64', { type: 'uint64' }],
  ['uint96', { type: 'uint96' }],
  ['uint112', { type: 'uint112' }],
  ['uint160', { type: 'uint160' }],
  ['uint192', { type: 'uint192' }],
  ['uint256', { type: 'uint256' }],
  ['address owner', { type: 'address', name: 'owner' }],
  ['address to', { type: 'address', name: 'to' }],
  ['bool approved', { type: 'bool', name: 'approved' }],
  ['bytes _data', { type: 'bytes', name: '_data' }],
  ['bytes data', { type: 'bytes', name: 'data' }],
  ['bytes signature', { type: 'bytes', name: 'signature' }],
  ['bytes32 hash', { type: 'bytes32', name: 'hash' }],
  ['bytes32 r', { type: 'bytes32', name: 'r' }],
  ['bytes32 root', { type: 'bytes32', name: 'root' }],
  ['bytes32 s', { type: 'bytes32', name: 's' }],
  ['string name', { type: 'string', name: 'name' }],
  ['string symbol', { type: 'string', name: 'symbol' }],
  ['string tokenURI', { type: 'string', name: 'tokenURI' }],
  ['uint tokenId', { type: 'uint256', name: 'tokenId' }],
  ['uint8 v', { type: 'uint8', name: 'v' }],
  ['uint256 balance', { type: 'uint256', name: 'balance' }],
  ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],
  ['uint256 value', { type: 'uint256', name: 'value' }],
  ['event:address indexed from', { type: 'address', name: 'from', indexed: !0 }],
  ['event:address indexed to', { type: 'address', name: 'to', indexed: !0 }],
  ['event:uint indexed tokenId', { type: 'uint256', name: 'tokenId', indexed: !0 }],
  ['event:uint256 indexed tokenId', { type: 'uint256', name: 'tokenId', indexed: !0 }]
])
function cB(t, e = {}) {
  if (FU(t)) return uB(t, e)
  if (LU(t)) return lB(t, e)
  if (UU(t)) return dB(t, e)
  if (qU(t)) return fB(t, e)
  if (GU(t)) return hB(t)
  if (WU(t)) return { type: 'receive', stateMutability: 'payable' }
  throw new rB({ signature: t })
}
function uB(t, e = {}) {
  const n = jU(t)
  if (!n) throw new wd({ signature: t, type: 'function' })
  const r = us(n.parameters),
    i = [],
    s = r.length
  for (let u = 0; u < s; u++) i.push(eu(r[u], { modifiers: vw, structs: e, type: 'function' }))
  const c = []
  if (n.returns) {
    const u = us(n.returns),
      f = u.length
    for (let d = 0; d < f; d++) c.push(eu(u[d], { modifiers: vw, structs: e, type: 'function' }))
  }
  return {
    name: n.name,
    type: 'function',
    stateMutability: n.stateMutability ?? 'nonpayable',
    inputs: i,
    outputs: c
  }
}
function lB(t, e = {}) {
  const n = $U(t)
  if (!n) throw new wd({ signature: t, type: 'event' })
  const r = us(n.parameters),
    i = [],
    s = r.length
  for (let c = 0; c < s; c++) i.push(eu(r[c], { modifiers: QU, structs: e, type: 'event' }))
  return { name: n.name, type: 'event', inputs: i }
}
function dB(t, e = {}) {
  const n = BU(t)
  if (!n) throw new wd({ signature: t, type: 'error' })
  const r = us(n.parameters),
    i = [],
    s = r.length
  for (let c = 0; c < s; c++) i.push(eu(r[c], { structs: e, type: 'error' }))
  return { name: n.name, type: 'error', inputs: i }
}
function fB(t, e = {}) {
  const n = HU(t)
  if (!n) throw new wd({ signature: t, type: 'constructor' })
  const r = us(n.parameters),
    i = [],
    s = r.length
  for (let c = 0; c < s; c++) i.push(eu(r[c], { structs: e, type: 'constructor' }))
  return { type: 'constructor', stateMutability: n.stateMutability ?? 'nonpayable', inputs: i }
}
function hB(t) {
  const e = VU(t)
  if (!e) throw new wd({ signature: t, type: 'fallback' })
  return { type: 'fallback', stateMutability: e.stateMutability ?? 'nonpayable' }
}
const pB =
    /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
  gB =
    /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
  mB = /^u?int$/
function eu(t, e) {
  var g, m
  const n = oB(t, e == null ? void 0 : e.type, e == null ? void 0 : e.structs)
  if (Dv.has(n)) return Dv.get(n)
  const r = RT.test(t),
    i = $a(r ? gB : pB, t)
  if (!i) throw new XU({ param: t })
  if (i.name && yB(i.name)) throw new JU({ param: t, name: i.name })
  const s = i.name ? { name: i.name } : {},
    c = i.modifier === 'indexed' ? { indexed: !0 } : {},
    u = (e == null ? void 0 : e.structs) ?? {}
  let f,
    d = {}
  if (r) {
    f = 'tuple'
    const y = us(i.type),
      A = [],
      E = y.length
    for (let x = 0; x < E; x++) A.push(eu(y[x], { structs: u }))
    d = { components: A }
  } else if (i.type in u) (f = 'tuple'), (d = { components: u[i.type] })
  else if (mB.test(i.type)) f = `${i.type}256`
  else if (((f = i.type), (e == null ? void 0 : e.type) !== 'struct' && !$T(f)))
    throw new ZU({ type: f })
  if (i.modifier) {
    if (
      !(
        (m = (g = e == null ? void 0 : e.modifiers) == null ? void 0 : g.has) != null &&
        m.call(g, i.modifier)
      )
    )
      throw new eB({ param: t, type: e == null ? void 0 : e.type, modifier: i.modifier })
    if (vw.has(i.modifier) && !vB(f, !!i.array))
      throw new tB({ param: t, type: e == null ? void 0 : e.type, modifier: i.modifier })
  }
  const p = { type: `${f}${i.array ?? ''}`, ...s, ...c, ...d }
  return Dv.set(n, p), p
}
function us(t, e = [], n = '', r = 0) {
  const i = t.trim().length
  for (let s = 0; s < i; s++) {
    const c = t[s],
      u = t.slice(s + 1)
    switch (c) {
      case ',':
        return r === 0 ? us(u, [...e, n.trim()]) : us(u, e, `${n}${c}`, r)
      case '(':
        return us(u, e, `${n}${c}`, r + 1)
      case ')':
        return us(u, e, `${n}${c}`, r - 1)
      default:
        return us(u, e, `${n}${c}`, r)
    }
  }
  if (n === '') return e
  if (r !== 0) throw new aB({ current: n, depth: r })
  return e.push(n.trim()), e
}
function $T(t) {
  return (
    t === 'address' ||
    t === 'bool' ||
    t === 'function' ||
    t === 'string' ||
    IT.test(t) ||
    OT.test(t)
  )
}
const bB =
  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/
function yB(t) {
  return (
    t === 'address' ||
    t === 'bool' ||
    t === 'function' ||
    t === 'string' ||
    t === 'tuple' ||
    IT.test(t) ||
    OT.test(t) ||
    bB.test(t)
  )
}
function vB(t, e) {
  return e || t === 'bytes' || t === 'string' || t === 'tuple'
}
function wB(t) {
  const e = {},
    n = t.length
  for (let c = 0; c < n; c++) {
    const u = t[c]
    if (!UT(u)) continue
    const f = zU(u)
    if (!f) throw new wd({ signature: u, type: 'struct' })
    const d = f.properties.split(';'),
      p = [],
      g = d.length
    for (let m = 0; m < g; m++) {
      const A = d[m].trim()
      if (!A) continue
      const E = eu(A, { type: 'struct' })
      p.push(E)
    }
    if (!p.length) throw new iB({ signature: u })
    e[f.name] = p
  }
  const r = {},
    i = Object.entries(e),
    s = i.length
  for (let c = 0; c < s; c++) {
    const [u, f] = i[c]
    r[u] = FT(f, e)
  }
  return r
}
const EB = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/
function FT(t, e, n = new Set()) {
  const r = [],
    i = t.length
  for (let s = 0; s < i; s++) {
    const c = t[s]
    if (RT.test(c.type)) r.push(c)
    else {
      const f = $a(EB, c.type)
      if (!(f != null && f.type)) throw new nB({ abiParameter: c })
      const { array: d, type: p } = f
      if (p in e) {
        if (n.has(p)) throw new sB({ type: p })
        r.push({ ...c, type: `tuple${d ?? ''}`, components: FT(e[p] ?? [], e, new Set([...n, p])) })
      } else if ($T(p)) r.push(c)
      else throw new YU({ type: p })
    }
  }
  return r
}
function jT(t) {
  const e = wB(t),
    n = [],
    r = t.length
  for (let i = 0; i < r; i++) {
    const s = t[i]
    UT(s) || n.push(cB(s, e))
  }
  return n
}
function wh(t, { strict: e = !0 } = {}) {
  return !t || typeof t != 'string' ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith('0x')
}
function OS(t) {
  return wh(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length
}
const zT = '2.23.2'
let Lf = {
    getDocsUrl: ({ docsBaseUrl: t, docsPath: e = '', docsSlug: n }) =>
      e ? `${t ?? 'https://viem.sh'}${e}${n ? `#${n}` : ''}` : void 0,
    version: `viem@${zT}`
  },
  Rm = class ww extends Error {
    constructor(e, n = {}) {
      var u
      const r = (() => {
          var f
          return n.cause instanceof ww
            ? n.cause.details
            : (f = n.cause) != null && f.message
              ? n.cause.message
              : n.details
        })(),
        i = (n.cause instanceof ww && n.cause.docsPath) || n.docsPath,
        s = (u = Lf.getDocsUrl) == null ? void 0 : u.call(Lf, { ...n, docsPath: i }),
        c = [
          e || 'An error occurred.',
          '',
          ...(n.metaMessages ? [...n.metaMessages, ''] : []),
          ...(s ? [`Docs: ${s}`] : []),
          ...(r ? [`Details: ${r}`] : []),
          ...(Lf.version ? [`Version: ${Lf.version}`] : [])
        ].join(`
`)
      super(c, n.cause ? { cause: n.cause } : void 0),
        Object.defineProperty(this, 'details', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'docsPath', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'metaMessages', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'shortMessage', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'version', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'name', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: 'BaseError'
        }),
        (this.details = r),
        (this.docsPath = i),
        (this.metaMessages = n.metaMessages),
        (this.name = n.name ?? this.name),
        (this.shortMessage = e),
        (this.version = zT)
    }
    walk(e) {
      return qT(this, e)
    }
  }
function qT(t, e) {
  return e != null && e(t)
    ? t
    : t && typeof t == 'object' && 'cause' in t && t.cause !== void 0
      ? qT(t.cause, e)
      : e
        ? null
        : t
}
let HT = class extends Rm {
  constructor({ size: e, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${e}) exceeds padding size (${n}).`,
      { name: 'SizeExceedsPaddingSizeError' }
    )
  }
}
function Ed(t, { dir: e, size: n = 32 } = {}) {
  return typeof t == 'string' ? AB(t, { dir: e, size: n }) : _B(t, { dir: e, size: n })
}
function AB(t, { dir: e, size: n = 32 } = {}) {
  if (n === null) return t
  const r = t.replace('0x', '')
  if (r.length > n * 2) throw new HT({ size: Math.ceil(r.length / 2), targetSize: n, type: 'hex' })
  return `0x${r[e === 'right' ? 'padEnd' : 'padStart'](n * 2, '0')}`
}
function _B(t, { dir: e, size: n = 32 } = {}) {
  if (n === null) return t
  if (t.length > n) throw new HT({ size: t.length, targetSize: n, type: 'bytes' })
  const r = new Uint8Array(n)
  for (let i = 0; i < n; i++) {
    const s = e === 'right'
    r[s ? i : n - i - 1] = t[s ? i : t.length - i - 1]
  }
  return r
}
let CB = class extends Rm {
    constructor({ max: e, min: n, signed: r, size: i, value: s }) {
      super(
        `Number "${s}" is not in safe ${i ? `${i * 8}-bit ${r ? 'signed' : 'unsigned'} ` : ''}integer range ${e ? `(${n} to ${e})` : `(above ${n})`}`,
        { name: 'IntegerOutOfRangeError' }
      )
    }
  },
  SB = class extends Rm {
    constructor({ givenSize: e, maxSize: n }) {
      super(`Size cannot exceed ${n} bytes. Given size: ${e} bytes.`, { name: 'SizeOverflowError' })
    }
  }
function Ad(t, { size: e }) {
  if (OS(t) > e) throw new SB({ givenSize: OS(t), maxSize: e })
}
function Ew(t, e = {}) {
  const { signed: n } = e
  e.size && Ad(t, { size: e.size })
  const r = BigInt(t)
  if (!n) return r
  const i = (t.length - 2) / 2,
    s = (1n << (BigInt(i) * 8n - 1n)) - 1n
  return r <= s ? r : r - BigInt(`0x${'f'.padStart(i * 2, 'f')}`) - 1n
}
function TB(t, e = {}) {
  return Number(Ew(t, e))
}
const xB = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, '0'))
function Aw(t, e = {}) {
  return typeof t == 'number' || typeof t == 'bigint'
    ? VT(t, e)
    : typeof t == 'string'
      ? OB(t, e)
      : typeof t == 'boolean'
        ? NB(t, e)
        : GT(t, e)
}
function NB(t, e = {}) {
  const n = `0x${Number(t)}`
  return typeof e.size == 'number' ? (Ad(n, { size: e.size }), Ed(n, { size: e.size })) : n
}
function GT(t, e = {}) {
  let n = ''
  for (let i = 0; i < t.length; i++) n += xB[t[i]]
  const r = `0x${n}`
  return typeof e.size == 'number'
    ? (Ad(r, { size: e.size }), Ed(r, { dir: 'right', size: e.size }))
    : r
}
function VT(t, e = {}) {
  const { signed: n, size: r } = e,
    i = BigInt(t)
  let s
  r
    ? n
      ? (s = (1n << (BigInt(r) * 8n - 1n)) - 1n)
      : (s = 2n ** (BigInt(r) * 8n) - 1n)
    : typeof t == 'number' && (s = BigInt(Number.MAX_SAFE_INTEGER))
  const c = typeof s == 'bigint' && n ? -s - 1n : 0
  if ((s && i > s) || i < c) {
    const f = typeof t == 'bigint' ? 'n' : ''
    throw new CB({
      max: s ? `${s}${f}` : void 0,
      min: `${c}${f}`,
      signed: n,
      size: r,
      value: `${t}${f}`
    })
  }
  const u = `0x${(n && i < 0 ? (1n << BigInt(r * 8)) + BigInt(i) : i).toString(16)}`
  return r ? Ed(u, { size: r }) : u
}
const IB = new TextEncoder()
function OB(t, e = {}) {
  const n = IB.encode(t)
  return GT(n, e)
}
const RB = new TextEncoder()
function DB(t, e = {}) {
  return typeof t == 'number' || typeof t == 'bigint'
    ? MB(t, e)
    : typeof t == 'boolean'
      ? PB(t, e)
      : wh(t)
        ? KT(t, e)
        : WT(t, e)
}
function PB(t, e = {}) {
  const n = new Uint8Array(1)
  return (
    (n[0] = Number(t)),
    typeof e.size == 'number' ? (Ad(n, { size: e.size }), Ed(n, { size: e.size })) : n
  )
}
const ba = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 }
function RS(t) {
  if (t >= ba.zero && t <= ba.nine) return t - ba.zero
  if (t >= ba.A && t <= ba.F) return t - (ba.A - 10)
  if (t >= ba.a && t <= ba.f) return t - (ba.a - 10)
}
function KT(t, e = {}) {
  let n = t
  e.size && (Ad(n, { size: e.size }), (n = Ed(n, { dir: 'right', size: e.size })))
  let r = n.slice(2)
  r.length % 2 && (r = `0${r}`)
  const i = r.length / 2,
    s = new Uint8Array(i)
  for (let c = 0, u = 0; c < i; c++) {
    const f = RS(r.charCodeAt(u++)),
      d = RS(r.charCodeAt(u++))
    if (f === void 0 || d === void 0)
      throw new Rm(`Invalid byte sequence ("${r[u - 2]}${r[u - 1]}" in "${r}").`)
    s[c] = f * 16 + d
  }
  return s
}
function MB(t, e) {
  const n = VT(t, e)
  return KT(n)
}
function WT(t, e = {}) {
  const n = RB.encode(t)
  return typeof e.size == 'number'
    ? (Ad(n, { size: e.size }), Ed(n, { dir: 'right', size: e.size }))
    : n
}
function Kg(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error('positive integer expected, got ' + t)
}
function kB(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function bp(t, ...e) {
  if (!kB(t)) throw new Error('Uint8Array expected')
  if (e.length > 0 && !e.includes(t.length))
    throw new Error('Uint8Array expected of length ' + e + ', got length=' + t.length)
}
function dse(t) {
  if (typeof t != 'function' || typeof t.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor')
  Kg(t.outputLen), Kg(t.blockLen)
}
function Wg(t, e = !0) {
  if (t.destroyed) throw new Error('Hash instance has been destroyed')
  if (e && t.finished) throw new Error('Hash#digest() has already been called')
}
function QT(t, e) {
  bp(t)
  const n = e.outputLen
  if (t.length < n) throw new Error('digestInto() expects output buffer of length at least ' + n)
}
const tg = BigInt(2 ** 32 - 1),
  DS = BigInt(32)
function UB(t, e = !1) {
  return e
    ? { h: Number(t & tg), l: Number((t >> DS) & tg) }
    : { h: Number((t >> DS) & tg) | 0, l: Number(t & tg) | 0 }
}
function BB(t, e = !1) {
  let n = new Uint32Array(t.length),
    r = new Uint32Array(t.length)
  for (let i = 0; i < t.length; i++) {
    const { h: s, l: c } = UB(t[i], e)
    ;[n[i], r[i]] = [s, c]
  }
  return [n, r]
}
const LB = (t, e, n) => (t << n) | (e >>> (32 - n)),
  $B = (t, e, n) => (e << n) | (t >>> (32 - n)),
  FB = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
  jB = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n)),
  cl = typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function zB(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4))
}
function Pv(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength)
}
function Ts(t, e) {
  return (t << (32 - e)) | (t >>> e)
}
const PS = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68
function qB(t) {
  return ((t << 24) & 4278190080) | ((t << 8) & 16711680) | ((t >>> 8) & 65280) | ((t >>> 24) & 255)
}
function MS(t) {
  for (let e = 0; e < t.length; e++) t[e] = qB(t[e])
}
const HB = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, '0'))
function fse(t) {
  bp(t)
  let e = ''
  for (let n = 0; n < t.length; n++) e += HB[t[n]]
  return e
}
function GB(t) {
  if (typeof t != 'string') throw new Error('utf8ToBytes expected string, got ' + typeof t)
  return new Uint8Array(new TextEncoder().encode(t))
}
function QE(t) {
  return typeof t == 'string' && (t = GB(t)), bp(t), t
}
function hse(...t) {
  let e = 0
  for (let r = 0; r < t.length; r++) {
    const i = t[r]
    bp(i), (e += i.length)
  }
  const n = new Uint8Array(e)
  for (let r = 0, i = 0; r < t.length; r++) {
    const s = t[r]
    n.set(s, i), (i += s.length)
  }
  return n
}
class YT {
  clone() {
    return this._cloneInto()
  }
}
function ZT(t) {
  const e = r => t().update(QE(r)).digest(),
    n = t()
  return (e.outputLen = n.outputLen), (e.blockLen = n.blockLen), (e.create = () => t()), e
}
function pse(t = 32) {
  if (cl && typeof cl.getRandomValues == 'function') return cl.getRandomValues(new Uint8Array(t))
  if (cl && typeof cl.randomBytes == 'function') return cl.randomBytes(t)
  throw new Error('crypto.getRandomValues must be defined')
}
const XT = [],
  JT = [],
  ex = [],
  VB = BigInt(0),
  $f = BigInt(1),
  KB = BigInt(2),
  WB = BigInt(7),
  QB = BigInt(256),
  YB = BigInt(113)
for (let t = 0, e = $f, n = 1, r = 0; t < 24; t++) {
  ;([n, r] = [r, (2 * n + 3 * r) % 5]),
    XT.push(2 * (5 * r + n)),
    JT.push((((t + 1) * (t + 2)) / 2) % 64)
  let i = VB
  for (let s = 0; s < 7; s++)
    (e = ((e << $f) ^ ((e >> WB) * YB)) % QB), e & KB && (i ^= $f << (($f << BigInt(s)) - $f))
  ex.push(i)
}
const [ZB, XB] = BB(ex, !0),
  kS = (t, e, n) => (n > 32 ? FB(t, e, n) : LB(t, e, n)),
  US = (t, e, n) => (n > 32 ? jB(t, e, n) : $B(t, e, n))
function JB(t, e = 24) {
  const n = new Uint32Array(10)
  for (let r = 24 - e; r < 24; r++) {
    for (let c = 0; c < 10; c++) n[c] = t[c] ^ t[c + 10] ^ t[c + 20] ^ t[c + 30] ^ t[c + 40]
    for (let c = 0; c < 10; c += 2) {
      const u = (c + 8) % 10,
        f = (c + 2) % 10,
        d = n[f],
        p = n[f + 1],
        g = kS(d, p, 1) ^ n[u],
        m = US(d, p, 1) ^ n[u + 1]
      for (let y = 0; y < 50; y += 10) (t[c + y] ^= g), (t[c + y + 1] ^= m)
    }
    let i = t[2],
      s = t[3]
    for (let c = 0; c < 24; c++) {
      const u = JT[c],
        f = kS(i, s, u),
        d = US(i, s, u),
        p = XT[c]
      ;(i = t[p]), (s = t[p + 1]), (t[p] = f), (t[p + 1] = d)
    }
    for (let c = 0; c < 50; c += 10) {
      for (let u = 0; u < 10; u++) n[u] = t[c + u]
      for (let u = 0; u < 10; u++) t[c + u] ^= ~n[(u + 2) % 10] & n[(u + 4) % 10]
    }
    ;(t[0] ^= ZB[r]), (t[1] ^= XB[r])
  }
  n.fill(0)
}
class YE extends YT {
  constructor(e, n, r, i = !1, s = 24) {
    if (
      (super(),
      (this.blockLen = e),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = i),
      (this.rounds = s),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      Kg(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error('Sha3 supports only keccak-f1600 function')
    ;(this.state = new Uint8Array(200)), (this.state32 = zB(this.state))
  }
  keccak() {
    PS || MS(this.state32),
      JB(this.state32, this.rounds),
      PS || MS(this.state32),
      (this.posOut = 0),
      (this.pos = 0)
  }
  update(e) {
    Wg(this)
    const { blockLen: n, state: r } = this
    e = QE(e)
    const i = e.length
    for (let s = 0; s < i; ) {
      const c = Math.min(n - this.pos, i - s)
      for (let u = 0; u < c; u++) r[this.pos++] ^= e[s++]
      this.pos === n && this.keccak()
    }
    return this
  }
  finish() {
    if (this.finished) return
    this.finished = !0
    const { state: e, suffix: n, pos: r, blockLen: i } = this
    ;(e[r] ^= n), (n & 128) !== 0 && r === i - 1 && this.keccak(), (e[i - 1] ^= 128), this.keccak()
  }
  writeInto(e) {
    Wg(this, !1), bp(e), this.finish()
    const n = this.state,
      { blockLen: r } = this
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= r && this.keccak()
      const c = Math.min(r - this.posOut, s - i)
      e.set(n.subarray(this.posOut, this.posOut + c), i), (this.posOut += c), (i += c)
    }
    return e
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error('XOF is not possible for this instance')
    return this.writeInto(e)
  }
  xof(e) {
    return Kg(e), this.xofInto(new Uint8Array(e))
  }
  digestInto(e) {
    if ((QT(e, this), this.finished)) throw new Error('digest() was already called')
    return this.writeInto(e), this.destroy(), e
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen))
  }
  destroy() {
    ;(this.destroyed = !0), this.state.fill(0)
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: i, rounds: s, enableXOF: c } = this
    return (
      e || (e = new YE(n, r, i, c, s)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = s),
      (e.suffix = r),
      (e.outputLen = i),
      (e.enableXOF = c),
      (e.destroyed = this.destroyed),
      e
    )
  }
}
const eL = (t, e, n) => ZT(() => new YE(e, t, n)),
  tx = eL(1, 136, 256 / 8)
function nx(t, e) {
  const n = e || 'hex',
    r = tx(wh(t, { strict: !1 }) ? DB(t) : t)
  return n === 'bytes' ? r : Aw(r)
}
let tL = class extends Map {
  constructor(e) {
    super(),
      Object.defineProperty(this, 'maxSize', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.maxSize = e)
  }
  get(e) {
    const n = super.get(e)
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n
  }
  set(e, n) {
    if ((super.set(e, n), this.maxSize && this.size > this.maxSize)) {
      const r = this.keys().next().value
      r && this.delete(r)
    }
    return this
  }
}
const Mv = new tL(8192)
function nL(t, e) {
  if (Mv.has(`${t}.${e}`)) return Mv.get(`${t}.${e}`)
  const n = t.substring(2).toLowerCase(),
    r = nx(WT(n), 'bytes'),
    i = n.split('')
  for (let c = 0; c < 40; c += 2)
    r[c >> 1] >> 4 >= 8 && i[c] && (i[c] = i[c].toUpperCase()),
      (r[c >> 1] & 15) >= 8 && i[c + 1] && (i[c + 1] = i[c + 1].toUpperCase())
  const s = `0x${i.join('')}`
  return Mv.set(`${t}.${e}`, s), s
}
function rL(t) {
  const e = nx(`0x${t.substring(4)}`).substring(26)
  return nL(`0x${e}`)
}
const iL = 'modulepreload',
  sL = function (t) {
    return '/' + t
  },
  BS = {},
  ei = function (e, n, r) {
    let i = Promise.resolve()
    if (n && n.length > 0) {
      document.getElementsByTagName('link')
      const c = document.querySelector('meta[property=csp-nonce]'),
        u = (c == null ? void 0 : c.nonce) || (c == null ? void 0 : c.getAttribute('nonce'))
      i = Promise.allSettled(
        n.map(f => {
          if (((f = sL(f)), f in BS)) return
          BS[f] = !0
          const d = f.endsWith('.css'),
            p = d ? '[rel="stylesheet"]' : ''
          if (document.querySelector(`link[href="${f}"]${p}`)) return
          const g = document.createElement('link')
          if (
            ((g.rel = d ? 'stylesheet' : iL),
            d || (g.as = 'script'),
            (g.crossOrigin = ''),
            (g.href = f),
            u && g.setAttribute('nonce', u),
            document.head.appendChild(g),
            d)
          )
            return new Promise((m, y) => {
              g.addEventListener('load', m),
                g.addEventListener('error', () => y(new Error(`Unable to preload CSS for ${f}`)))
            })
        })
      )
    }
    function s(c) {
      const u = new Event('vite:preloadError', { cancelable: !0 })
      if (((u.payload = c), window.dispatchEvent(u), !u.defaultPrevented)) throw c
    }
    return i.then(c => {
      for (const u of c || []) u.status === 'rejected' && s(u.reason)
      return e().catch(s)
    })
  }
async function aL({ hash: t, signature: e }) {
  const n = wh(t) ? t : Aw(t),
    { secp256k1: r } = await ei(async () => {
      const { secp256k1: c } = await import('./secp256k1-C-C-k1yE.js')
      return { secp256k1: c }
    }, [])
  return `0x${(() => {
    if (typeof e == 'object' && 'r' in e && 's' in e) {
      const { r: d, s: p, v: g, yParity: m } = e,
        y = Number(m ?? g),
        A = LS(y)
      return new r.Signature(Ew(d), Ew(p)).addRecoveryBit(A)
    }
    const c = wh(e) ? e : Aw(e),
      u = TB(`0x${c.slice(130)}`),
      f = LS(u)
    return r.Signature.fromCompact(c.substring(2, 130)).addRecoveryBit(f)
  })()
    .recoverPublicKey(n.substring(2))
    .toHex(!1)}`
}
function LS(t) {
  if (t === 0 || t === 1) return t
  if (t === 27) return 0
  if (t === 28) return 1
  throw new Error('Invalid yParityOrV value')
}
async function oL({ hash: t, signature: e }) {
  return rL(await aL({ hash: t, signature: e }))
}
function cL(t, e, n, r) {
  if (typeof t.setBigUint64 == 'function') return t.setBigUint64(e, n, r)
  const i = BigInt(32),
    s = BigInt(4294967295),
    c = Number((n >> i) & s),
    u = Number(n & s),
    f = r ? 4 : 0,
    d = r ? 0 : 4
  t.setUint32(e + f, c, r), t.setUint32(e + d, u, r)
}
function uL(t, e, n) {
  return (t & e) ^ (~t & n)
}
function lL(t, e, n) {
  return (t & e) ^ (t & n) ^ (e & n)
}
class dL extends YT {
  constructor(e, n, r, i) {
    super(),
      (this.blockLen = e),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(e)),
      (this.view = Pv(this.buffer))
  }
  update(e) {
    Wg(this)
    const { view: n, buffer: r, blockLen: i } = this
    e = QE(e)
    const s = e.length
    for (let c = 0; c < s; ) {
      const u = Math.min(i - this.pos, s - c)
      if (u === i) {
        const f = Pv(e)
        for (; i <= s - c; c += i) this.process(f, c)
        continue
      }
      r.set(e.subarray(c, c + u), this.pos),
        (this.pos += u),
        (c += u),
        this.pos === i && (this.process(n, 0), (this.pos = 0))
    }
    return (this.length += e.length), this.roundClean(), this
  }
  digestInto(e) {
    Wg(this), QT(e, this), (this.finished = !0)
    const { buffer: n, view: r, blockLen: i, isLE: s } = this
    let { pos: c } = this
    ;(n[c++] = 128),
      this.buffer.subarray(c).fill(0),
      this.padOffset > i - c && (this.process(r, 0), (c = 0))
    for (let g = c; g < i; g++) n[g] = 0
    cL(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0)
    const u = Pv(e),
      f = this.outputLen
    if (f % 4) throw new Error('_sha2: outputLen should be aligned to 32bit')
    const d = f / 4,
      p = this.get()
    if (d > p.length) throw new Error('_sha2: outputLen bigger than state')
    for (let g = 0; g < d; g++) u.setUint32(4 * g, p[g], s)
  }
  digest() {
    const { buffer: e, outputLen: n } = this
    this.digestInto(e)
    const r = e.slice(0, n)
    return this.destroy(), r
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get())
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: c, pos: u } = this
    return (
      (e.length = i), (e.pos = u), (e.finished = s), (e.destroyed = c), i % n && e.buffer.set(r), e
    )
  }
}
const fL = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298
  ]),
  po = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225
  ]),
  go = new Uint32Array(64)
class hL extends dL {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = po[0] | 0),
      (this.B = po[1] | 0),
      (this.C = po[2] | 0),
      (this.D = po[3] | 0),
      (this.E = po[4] | 0),
      (this.F = po[5] | 0),
      (this.G = po[6] | 0),
      (this.H = po[7] | 0)
  }
  get() {
    const { A: e, B: n, C: r, D: i, E: s, F: c, G: u, H: f } = this
    return [e, n, r, i, s, c, u, f]
  }
  set(e, n, r, i, s, c, u, f) {
    ;(this.A = e | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = i | 0),
      (this.E = s | 0),
      (this.F = c | 0),
      (this.G = u | 0),
      (this.H = f | 0)
  }
  process(e, n) {
    for (let g = 0; g < 16; g++, n += 4) go[g] = e.getUint32(n, !1)
    for (let g = 16; g < 64; g++) {
      const m = go[g - 15],
        y = go[g - 2],
        A = Ts(m, 7) ^ Ts(m, 18) ^ (m >>> 3),
        E = Ts(y, 17) ^ Ts(y, 19) ^ (y >>> 10)
      go[g] = (E + go[g - 7] + A + go[g - 16]) | 0
    }
    let { A: r, B: i, C: s, D: c, E: u, F: f, G: d, H: p } = this
    for (let g = 0; g < 64; g++) {
      const m = Ts(u, 6) ^ Ts(u, 11) ^ Ts(u, 25),
        y = (p + m + uL(u, f, d) + fL[g] + go[g]) | 0,
        E = ((Ts(r, 2) ^ Ts(r, 13) ^ Ts(r, 22)) + lL(r, i, s)) | 0
      ;(p = d), (d = f), (f = u), (u = (c + y) | 0), (c = s), (s = i), (i = r), (r = (y + E) | 0)
    }
    ;(r = (r + this.A) | 0),
      (i = (i + this.B) | 0),
      (s = (s + this.C) | 0),
      (c = (c + this.D) | 0),
      (u = (u + this.E) | 0),
      (f = (f + this.F) | 0),
      (d = (d + this.G) | 0),
      (p = (p + this.H) | 0),
      this.set(r, i, s, c, u, f, d, p)
  }
  roundClean() {
    go.fill(0)
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
  }
}
const pL = ZT(() => new hL())
function gL(t) {
  if (t.length >= 255) throw new TypeError('Alphabet too long')
  const e = new Uint8Array(256)
  for (let d = 0; d < e.length; d++) e[d] = 255
  for (let d = 0; d < t.length; d++) {
    const p = t.charAt(d),
      g = p.charCodeAt(0)
    if (e[g] !== 255) throw new TypeError(p + ' is ambiguous')
    e[g] = d
  }
  const n = t.length,
    r = t.charAt(0),
    i = Math.log(n) / Math.log(256),
    s = Math.log(256) / Math.log(n)
  function c(d) {
    if (
      (d instanceof Uint8Array ||
        (ArrayBuffer.isView(d)
          ? (d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength))
          : Array.isArray(d) && (d = Uint8Array.from(d))),
      !(d instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (d.length === 0) return ''
    let p = 0,
      g = 0,
      m = 0
    const y = d.length
    for (; m !== y && d[m] === 0; ) m++, p++
    const A = ((y - m) * s + 1) >>> 0,
      E = new Uint8Array(A)
    for (; m !== y; ) {
      let I = d[m],
        M = 0
      for (let $ = A - 1; (I !== 0 || M < g) && $ !== -1; $--, M++)
        (I += (256 * E[$]) >>> 0), (E[$] = I % n >>> 0), (I = (I / n) >>> 0)
      if (I !== 0) throw new Error('Non-zero carry')
      ;(g = M), m++
    }
    let x = A - g
    for (; x !== A && E[x] === 0; ) x++
    let O = r.repeat(p)
    for (; x < A; ++x) O += t.charAt(E[x])
    return O
  }
  function u(d) {
    if (typeof d != 'string') throw new TypeError('Expected String')
    if (d.length === 0) return new Uint8Array()
    let p = 0,
      g = 0,
      m = 0
    for (; d[p] === r; ) g++, p++
    const y = ((d.length - p) * i + 1) >>> 0,
      A = new Uint8Array(y)
    for (; p < d.length; ) {
      const I = d.charCodeAt(p)
      if (I > 255) return
      let M = e[I]
      if (M === 255) return
      let $ = 0
      for (let D = y - 1; (M !== 0 || $ < m) && D !== -1; D--, $++)
        (M += (n * A[D]) >>> 0), (A[D] = M % 256 >>> 0), (M = (M / 256) >>> 0)
      if (M !== 0) throw new Error('Non-zero carry')
      ;(m = $), p++
    }
    let E = y - m
    for (; E !== y && A[E] === 0; ) E++
    const x = new Uint8Array(g + (y - E))
    let O = g
    for (; E !== y; ) x[O++] = A[E++]
    return x
  }
  function f(d) {
    const p = u(d)
    if (p) return p
    throw new Error('Non-base' + n + ' character')
  }
  return { encode: c, decodeUnsafe: u, decode: f }
}
var mL = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
const rx = gL(mL)
function ix(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? globalThis.Buffer.allocUnsafe(t)
    : new Uint8Array(t)
}
function kv(t, e) {
  e || (e = t.reduce((i, s) => i + s.length, 0))
  const n = ix(e)
  let r = 0
  for (const i of t) n.set(i, r), (r += i.length)
  return n
}
function bL(t, e) {
  if (t.length >= 255) throw new TypeError('Alphabet too long')
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i),
      c = s.charCodeAt(0)
    if (n[c] !== 255) throw new TypeError(s + ' is ambiguous')
    n[c] = i
  }
  var u = t.length,
    f = t.charAt(0),
    d = Math.log(u) / Math.log(256),
    p = Math.log(256) / Math.log(u)
  function g(A) {
    if (
      (A instanceof Uint8Array ||
        (ArrayBuffer.isView(A)
          ? (A = new Uint8Array(A.buffer, A.byteOffset, A.byteLength))
          : Array.isArray(A) && (A = Uint8Array.from(A))),
      !(A instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (A.length === 0) return ''
    for (var E = 0, x = 0, O = 0, I = A.length; O !== I && A[O] === 0; ) O++, E++
    for (var M = ((I - O) * p + 1) >>> 0, $ = new Uint8Array(M); O !== I; ) {
      for (var D = A[O], R = 0, z = M - 1; (D !== 0 || R < x) && z !== -1; z--, R++)
        (D += (256 * $[z]) >>> 0), ($[z] = D % u >>> 0), (D = (D / u) >>> 0)
      if (D !== 0) throw new Error('Non-zero carry')
      ;(x = R), O++
    }
    for (var G = M - x; G !== M && $[G] === 0; ) G++
    for (var j = f.repeat(E); G < M; ++G) j += t.charAt($[G])
    return j
  }
  function m(A) {
    if (typeof A != 'string') throw new TypeError('Expected String')
    if (A.length === 0) return new Uint8Array()
    var E = 0
    if (A[E] !== ' ') {
      for (var x = 0, O = 0; A[E] === f; ) x++, E++
      for (var I = ((A.length - E) * d + 1) >>> 0, M = new Uint8Array(I); A[E]; ) {
        var $ = n[A.charCodeAt(E)]
        if ($ === 255) return
        for (var D = 0, R = I - 1; ($ !== 0 || D < O) && R !== -1; R--, D++)
          ($ += (u * M[R]) >>> 0), (M[R] = $ % 256 >>> 0), ($ = ($ / 256) >>> 0)
        if ($ !== 0) throw new Error('Non-zero carry')
        ;(O = D), E++
      }
      if (A[E] !== ' ') {
        for (var z = I - O; z !== I && M[z] === 0; ) z++
        for (var G = new Uint8Array(x + (I - z)), j = x; z !== I; ) G[j++] = M[z++]
        return G
      }
    }
  }
  function y(A) {
    var E = m(A)
    if (E) return E
    throw new Error(`Non-${e} character`)
  }
  return { encode: g, decodeUnsafe: m, decode: y }
}
var yL = bL,
  vL = yL
const wL = t => {
    if (t instanceof Uint8Array && t.constructor.name === 'Uint8Array') return t
    if (t instanceof ArrayBuffer) return new Uint8Array(t)
    if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
    throw new Error('Unknown type, must be binary type')
  },
  EL = t => new TextEncoder().encode(t),
  AL = t => new TextDecoder().decode(t)
class _L {
  constructor(e, n, r) {
    ;(this.name = e), (this.prefix = n), (this.baseEncode = r)
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
    throw Error('Unknown type, must be binary type')
  }
}
class CL {
  constructor(e, n, r) {
    if (((this.name = e), (this.prefix = n), n.codePointAt(0) === void 0))
      throw new Error('Invalid prefix character')
    ;(this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = r)
  }
  decode(e) {
    if (typeof e == 'string') {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(
          `Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`
        )
      return this.baseDecode(e.slice(this.prefix.length))
    } else throw Error('Can only multibase decode strings')
  }
  or(e) {
    return sx(this, e)
  }
}
class SL {
  constructor(e) {
    this.decoders = e
  }
  or(e) {
    return sx(this, e)
  }
  decode(e) {
    const n = e[0],
      r = this.decoders[n]
    if (r) return r.decode(e)
    throw RangeError(
      `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
    )
  }
}
const sx = (t, e) =>
  new SL({ ...(t.decoders || { [t.prefix]: t }), ...(e.decoders || { [e.prefix]: e }) })
class TL {
  constructor(e, n, r, i) {
    ;(this.name = e),
      (this.prefix = n),
      (this.baseEncode = r),
      (this.baseDecode = i),
      (this.encoder = new _L(e, n, r)),
      (this.decoder = new CL(e, n, i))
  }
  encode(e) {
    return this.encoder.encode(e)
  }
  decode(e) {
    return this.decoder.decode(e)
  }
}
const Dm = ({ name: t, prefix: e, encode: n, decode: r }) => new TL(t, e, n, r),
  yp = ({ prefix: t, name: e, alphabet: n }) => {
    const { encode: r, decode: i } = vL(n, e)
    return Dm({ prefix: t, name: e, encode: r, decode: s => wL(i(s)) })
  },
  xL = (t, e, n, r) => {
    const i = {}
    for (let p = 0; p < e.length; ++p) i[e[p]] = p
    let s = t.length
    for (; t[s - 1] === '='; ) --s
    const c = new Uint8Array(((s * n) / 8) | 0)
    let u = 0,
      f = 0,
      d = 0
    for (let p = 0; p < s; ++p) {
      const g = i[t[p]]
      if (g === void 0) throw new SyntaxError(`Non-${r} character`)
      ;(f = (f << n) | g), (u += n), u >= 8 && ((u -= 8), (c[d++] = 255 & (f >> u)))
    }
    if (u >= n || 255 & (f << (8 - u))) throw new SyntaxError('Unexpected end of data')
    return c
  },
  NL = (t, e, n) => {
    const r = e[e.length - 1] === '=',
      i = (1 << n) - 1
    let s = '',
      c = 0,
      u = 0
    for (let f = 0; f < t.length; ++f)
      for (u = (u << 8) | t[f], c += 8; c > n; ) (c -= n), (s += e[i & (u >> c)])
    if ((c && (s += e[i & (u << (n - c))]), r)) for (; (s.length * n) & 7; ) s += '='
    return s
  },
  Ar = ({ name: t, prefix: e, bitsPerChar: n, alphabet: r }) =>
    Dm({
      prefix: e,
      name: t,
      encode(i) {
        return NL(i, r, n)
      },
      decode(i) {
        return xL(i, r, n, t)
      }
    }),
  IL = Dm({ prefix: '\0', name: 'identity', encode: t => AL(t), decode: t => EL(t) }),
  OL = Object.freeze(
    Object.defineProperty({ __proto__: null, identity: IL }, Symbol.toStringTag, {
      value: 'Module'
    })
  ),
  RL = Ar({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }),
  DL = Object.freeze(
    Object.defineProperty({ __proto__: null, base2: RL }, Symbol.toStringTag, { value: 'Module' })
  ),
  PL = Ar({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }),
  ML = Object.freeze(
    Object.defineProperty({ __proto__: null, base8: PL }, Symbol.toStringTag, { value: 'Module' })
  ),
  kL = yp({ prefix: '9', name: 'base10', alphabet: '0123456789' }),
  UL = Object.freeze(
    Object.defineProperty({ __proto__: null, base10: kL }, Symbol.toStringTag, { value: 'Module' })
  ),
  BL = Ar({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 }),
  LL = Ar({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 }),
  $L = Object.freeze(
    Object.defineProperty({ __proto__: null, base16: BL, base16upper: LL }, Symbol.toStringTag, {
      value: 'Module'
    })
  ),
  FL = Ar({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
  }),
  jL = Ar({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
  }),
  zL = Ar({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
  }),
  qL = Ar({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
  }),
  HL = Ar({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
  }),
  GL = Ar({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
  }),
  VL = Ar({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
  }),
  KL = Ar({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
  }),
  WL = Ar({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
  }),
  QL = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base32: FL,
        base32hex: HL,
        base32hexpad: VL,
        base32hexpadupper: KL,
        base32hexupper: GL,
        base32pad: zL,
        base32padupper: qL,
        base32upper: jL,
        base32z: WL
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  YL = yp({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' }),
  ZL = yp({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' }),
  XL = Object.freeze(
    Object.defineProperty({ __proto__: null, base36: YL, base36upper: ZL }, Symbol.toStringTag, {
      value: 'Module'
    })
  ),
  JL = yp({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
  }),
  e$ = yp({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
  }),
  t$ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base58btc: JL, base58flickr: e$ },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  n$ = Ar({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
  }),
  r$ = Ar({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
  }),
  i$ = Ar({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
  }),
  s$ = Ar({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
  }),
  a$ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base64: n$, base64pad: r$, base64url: i$, base64urlpad: s$ },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  ax = Array.from(
    '🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂'
  ),
  o$ = ax.reduce((t, e, n) => ((t[n] = e), t), []),
  c$ = ax.reduce((t, e, n) => ((t[e.codePointAt(0)] = n), t), [])
function u$(t) {
  return t.reduce((e, n) => ((e += o$[n]), e), '')
}
function l$(t) {
  const e = []
  for (const n of t) {
    const r = c$[n.codePointAt(0)]
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`)
    e.push(r)
  }
  return new Uint8Array(e)
}
const d$ = Dm({ prefix: '🚀', name: 'base256emoji', encode: u$, decode: l$ }),
  f$ = Object.freeze(
    Object.defineProperty({ __proto__: null, base256emoji: d$ }, Symbol.toStringTag, {
      value: 'Module'
    })
  )
new TextEncoder()
new TextDecoder()
const $S = { ...OL, ...DL, ...ML, ...UL, ...$L, ...QL, ...XL, ...t$, ...a$, ...f$ }
function ox(t, e, n, r) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: n }, decoder: { decode: r } }
}
const FS = ox(
    'utf8',
    'u',
    t => 'u' + new TextDecoder('utf8').decode(t),
    t => new TextEncoder().encode(t.substring(1))
  ),
  Uv = ox(
    'ascii',
    'a',
    t => {
      let e = 'a'
      for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n])
      return e
    },
    t => {
      t = t.substring(1)
      const e = ix(t.length)
      for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n)
      return e
    }
  ),
  cx = { utf8: FS, 'utf-8': FS, hex: $S.base16, latin1: Uv, ascii: Uv, binary: Uv, ...$S }
function Fi(t, e = 'utf8') {
  const n = cx[e]
  if (!n) throw new Error(`Unsupported encoding "${e}"`)
  return (e === 'utf8' || e === 'utf-8') &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t, 'utf8')
    : n.decoder.decode(`${n.prefix}${t}`)
}
function $r(t, e = 'utf8') {
  const n = cx[e]
  if (!n) throw new Error(`Unsupported encoding "${e}"`)
  return (e === 'utf8' || e === 'utf-8') &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString('utf8')
    : n.encoder.encode(t).substring(1)
}
var Bv = {}
const h$ = '6.6.1',
  p$ = { version: h$ }
var Lv = {},
  Tg = { exports: {} }
const g$ = {},
  m$ = Object.freeze(
    Object.defineProperty({ __proto__: null, default: g$ }, Symbol.toStringTag, { value: 'Module' })
  ),
  ux = j8(m$)
var b$ = Tg.exports,
  jS
function Fa() {
  return (
    jS ||
      ((jS = 1),
      (function (t) {
        ;(function (e, n) {
          function r(L, v) {
            if (!L) throw new Error(v || 'Assertion failed')
          }
          function i(L, v) {
            L.super_ = v
            var C = function () {}
            ;(C.prototype = v.prototype), (L.prototype = new C()), (L.prototype.constructor = L)
          }
          function s(L, v, C) {
            if (s.isBN(L)) return L
            ;(this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              L !== null &&
                ((v === 'le' || v === 'be') && ((C = v), (v = 10)),
                this._init(L || 0, v || 10, C || 'be'))
          }
          typeof e == 'object' ? (e.exports = s) : (n.BN = s), (s.BN = s), (s.wordSize = 26)
          var c
          try {
            typeof window < 'u' && typeof window.Buffer < 'u'
              ? (c = window.Buffer)
              : (c = ux.Buffer)
          } catch {}
          ;(s.isBN = function (v) {
            return v instanceof s
              ? !0
              : v !== null &&
                  typeof v == 'object' &&
                  v.constructor.wordSize === s.wordSize &&
                  Array.isArray(v.words)
          }),
            (s.max = function (v, C) {
              return v.cmp(C) > 0 ? v : C
            }),
            (s.min = function (v, C) {
              return v.cmp(C) < 0 ? v : C
            }),
            (s.prototype._init = function (v, C, N) {
              if (typeof v == 'number') return this._initNumber(v, C, N)
              if (typeof v == 'object') return this._initArray(v, C, N)
              C === 'hex' && (C = 16),
                r(C === (C | 0) && C >= 2 && C <= 36),
                (v = v.toString().replace(/\s+/g, ''))
              var T = 0
              v[0] === '-' && (T++, (this.negative = 1)),
                T < v.length &&
                  (C === 16
                    ? this._parseHex(v, T, N)
                    : (this._parseBase(v, C, T),
                      N === 'le' && this._initArray(this.toArray(), C, N)))
            }),
            (s.prototype._initNumber = function (v, C, N) {
              v < 0 && ((this.negative = 1), (v = -v)),
                v < 67108864
                  ? ((this.words = [v & 67108863]), (this.length = 1))
                  : v < 4503599627370496
                    ? ((this.words = [v & 67108863, (v / 67108864) & 67108863]), (this.length = 2))
                    : (r(v < 9007199254740992),
                      (this.words = [v & 67108863, (v / 67108864) & 67108863, 1]),
                      (this.length = 3)),
                N === 'le' && this._initArray(this.toArray(), C, N)
            }),
            (s.prototype._initArray = function (v, C, N) {
              if ((r(typeof v.length == 'number'), v.length <= 0))
                return (this.words = [0]), (this.length = 1), this
              ;(this.length = Math.ceil(v.length / 3)), (this.words = new Array(this.length))
              for (var T = 0; T < this.length; T++) this.words[T] = 0
              var S,
                k,
                F = 0
              if (N === 'be')
                for (T = v.length - 1, S = 0; T >= 0; T -= 3)
                  (k = v[T] | (v[T - 1] << 8) | (v[T - 2] << 16)),
                    (this.words[S] |= (k << F) & 67108863),
                    (this.words[S + 1] = (k >>> (26 - F)) & 67108863),
                    (F += 24),
                    F >= 26 && ((F -= 26), S++)
              else if (N === 'le')
                for (T = 0, S = 0; T < v.length; T += 3)
                  (k = v[T] | (v[T + 1] << 8) | (v[T + 2] << 16)),
                    (this.words[S] |= (k << F) & 67108863),
                    (this.words[S + 1] = (k >>> (26 - F)) & 67108863),
                    (F += 24),
                    F >= 26 && ((F -= 26), S++)
              return this.strip()
            })
          function u(L, v) {
            var C = L.charCodeAt(v)
            return C >= 65 && C <= 70 ? C - 55 : C >= 97 && C <= 102 ? C - 87 : (C - 48) & 15
          }
          function f(L, v, C) {
            var N = u(L, C)
            return C - 1 >= v && (N |= u(L, C - 1) << 4), N
          }
          s.prototype._parseHex = function (v, C, N) {
            ;(this.length = Math.ceil((v.length - C) / 6)), (this.words = new Array(this.length))
            for (var T = 0; T < this.length; T++) this.words[T] = 0
            var S = 0,
              k = 0,
              F
            if (N === 'be')
              for (T = v.length - 1; T >= C; T -= 2)
                (F = f(v, C, T) << S),
                  (this.words[k] |= F & 67108863),
                  S >= 18 ? ((S -= 18), (k += 1), (this.words[k] |= F >>> 26)) : (S += 8)
            else {
              var P = v.length - C
              for (T = P % 2 === 0 ? C + 1 : C; T < v.length; T += 2)
                (F = f(v, C, T) << S),
                  (this.words[k] |= F & 67108863),
                  S >= 18 ? ((S -= 18), (k += 1), (this.words[k] |= F >>> 26)) : (S += 8)
            }
            this.strip()
          }
          function d(L, v, C, N) {
            for (var T = 0, S = Math.min(L.length, C), k = v; k < S; k++) {
              var F = L.charCodeAt(k) - 48
              ;(T *= N), F >= 49 ? (T += F - 49 + 10) : F >= 17 ? (T += F - 17 + 10) : (T += F)
            }
            return T
          }
          ;(s.prototype._parseBase = function (v, C, N) {
            ;(this.words = [0]), (this.length = 1)
            for (var T = 0, S = 1; S <= 67108863; S *= C) T++
            T--, (S = (S / C) | 0)
            for (
              var k = v.length - N, F = k % T, P = Math.min(k, k - F) + N, w = 0, B = N;
              B < P;
              B += T
            )
              (w = d(v, B, B + T, C)),
                this.imuln(S),
                this.words[0] + w < 67108864 ? (this.words[0] += w) : this._iaddn(w)
            if (F !== 0) {
              var Z = 1
              for (w = d(v, B, v.length, C), B = 0; B < F; B++) Z *= C
              this.imuln(Z), this.words[0] + w < 67108864 ? (this.words[0] += w) : this._iaddn(w)
            }
            this.strip()
          }),
            (s.prototype.copy = function (v) {
              v.words = new Array(this.length)
              for (var C = 0; C < this.length; C++) v.words[C] = this.words[C]
              ;(v.length = this.length), (v.negative = this.negative), (v.red = this.red)
            }),
            (s.prototype.clone = function () {
              var v = new s(null)
              return this.copy(v), v
            }),
            (s.prototype._expand = function (v) {
              for (; this.length < v; ) this.words[this.length++] = 0
              return this
            }),
            (s.prototype.strip = function () {
              for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--
              return this._normSign()
            }),
            (s.prototype._normSign = function () {
              return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }),
            (s.prototype.inspect = function () {
              return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>'
            })
          var p = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000'
            ],
            g = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5
            ],
            m = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721,
              1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224,
              47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
              17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
            ]
          ;(s.prototype.toString = function (v, C) {
            ;(v = v || 10), (C = C | 0 || 1)
            var N
            if (v === 16 || v === 'hex') {
              N = ''
              for (var T = 0, S = 0, k = 0; k < this.length; k++) {
                var F = this.words[k],
                  P = (((F << T) | S) & 16777215).toString(16)
                ;(S = (F >>> (24 - T)) & 16777215),
                  (T += 2),
                  T >= 26 && ((T -= 26), k--),
                  S !== 0 || k !== this.length - 1 ? (N = p[6 - P.length] + P + N) : (N = P + N)
              }
              for (S !== 0 && (N = S.toString(16) + N); N.length % C !== 0; ) N = '0' + N
              return this.negative !== 0 && (N = '-' + N), N
            }
            if (v === (v | 0) && v >= 2 && v <= 36) {
              var w = g[v],
                B = m[v]
              N = ''
              var Z = this.clone()
              for (Z.negative = 0; !Z.isZero(); ) {
                var ee = Z.modn(B).toString(v)
                ;(Z = Z.idivn(B)), Z.isZero() ? (N = ee + N) : (N = p[w - ee.length] + ee + N)
              }
              for (this.isZero() && (N = '0' + N); N.length % C !== 0; ) N = '0' + N
              return this.negative !== 0 && (N = '-' + N), N
            }
            r(!1, 'Base should be between 2 and 36')
          }),
            (s.prototype.toNumber = function () {
              var v = this.words[0]
              return (
                this.length === 2
                  ? (v += this.words[1] * 67108864)
                  : this.length === 3 && this.words[2] === 1
                    ? (v += 4503599627370496 + this.words[1] * 67108864)
                    : this.length > 2 && r(!1, 'Number can only safely store up to 53 bits'),
                this.negative !== 0 ? -v : v
              )
            }),
            (s.prototype.toJSON = function () {
              return this.toString(16)
            }),
            (s.prototype.toBuffer = function (v, C) {
              return r(typeof c < 'u'), this.toArrayLike(c, v, C)
            }),
            (s.prototype.toArray = function (v, C) {
              return this.toArrayLike(Array, v, C)
            }),
            (s.prototype.toArrayLike = function (v, C, N) {
              var T = this.byteLength(),
                S = N || Math.max(1, T)
              r(T <= S, 'byte array longer than desired length'),
                r(S > 0, 'Requested array length <= 0'),
                this.strip()
              var k = C === 'le',
                F = new v(S),
                P,
                w,
                B = this.clone()
              if (k) {
                for (w = 0; !B.isZero(); w++) (P = B.andln(255)), B.iushrn(8), (F[w] = P)
                for (; w < S; w++) F[w] = 0
              } else {
                for (w = 0; w < S - T; w++) F[w] = 0
                for (w = 0; !B.isZero(); w++) (P = B.andln(255)), B.iushrn(8), (F[S - w - 1] = P)
              }
              return F
            }),
            Math.clz32
              ? (s.prototype._countBits = function (v) {
                  return 32 - Math.clz32(v)
                })
              : (s.prototype._countBits = function (v) {
                  var C = v,
                    N = 0
                  return (
                    C >= 4096 && ((N += 13), (C >>>= 13)),
                    C >= 64 && ((N += 7), (C >>>= 7)),
                    C >= 8 && ((N += 4), (C >>>= 4)),
                    C >= 2 && ((N += 2), (C >>>= 2)),
                    N + C
                  )
                }),
            (s.prototype._zeroBits = function (v) {
              if (v === 0) return 26
              var C = v,
                N = 0
              return (
                (C & 8191) === 0 && ((N += 13), (C >>>= 13)),
                (C & 127) === 0 && ((N += 7), (C >>>= 7)),
                (C & 15) === 0 && ((N += 4), (C >>>= 4)),
                (C & 3) === 0 && ((N += 2), (C >>>= 2)),
                (C & 1) === 0 && N++,
                N
              )
            }),
            (s.prototype.bitLength = function () {
              var v = this.words[this.length - 1],
                C = this._countBits(v)
              return (this.length - 1) * 26 + C
            })
          function y(L) {
            for (var v = new Array(L.bitLength()), C = 0; C < v.length; C++) {
              var N = (C / 26) | 0,
                T = C % 26
              v[C] = (L.words[N] & (1 << T)) >>> T
            }
            return v
          }
          ;(s.prototype.zeroBits = function () {
            if (this.isZero()) return 0
            for (var v = 0, C = 0; C < this.length; C++) {
              var N = this._zeroBits(this.words[C])
              if (((v += N), N !== 26)) break
            }
            return v
          }),
            (s.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8)
            }),
            (s.prototype.toTwos = function (v) {
              return this.negative !== 0 ? this.abs().inotn(v).iaddn(1) : this.clone()
            }),
            (s.prototype.fromTwos = function (v) {
              return this.testn(v - 1) ? this.notn(v).iaddn(1).ineg() : this.clone()
            }),
            (s.prototype.isNeg = function () {
              return this.negative !== 0
            }),
            (s.prototype.neg = function () {
              return this.clone().ineg()
            }),
            (s.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this
            }),
            (s.prototype.iuor = function (v) {
              for (; this.length < v.length; ) this.words[this.length++] = 0
              for (var C = 0; C < v.length; C++) this.words[C] = this.words[C] | v.words[C]
              return this.strip()
            }),
            (s.prototype.ior = function (v) {
              return r((this.negative | v.negative) === 0), this.iuor(v)
            }),
            (s.prototype.or = function (v) {
              return this.length > v.length ? this.clone().ior(v) : v.clone().ior(this)
            }),
            (s.prototype.uor = function (v) {
              return this.length > v.length ? this.clone().iuor(v) : v.clone().iuor(this)
            }),
            (s.prototype.iuand = function (v) {
              var C
              this.length > v.length ? (C = v) : (C = this)
              for (var N = 0; N < C.length; N++) this.words[N] = this.words[N] & v.words[N]
              return (this.length = C.length), this.strip()
            }),
            (s.prototype.iand = function (v) {
              return r((this.negative | v.negative) === 0), this.iuand(v)
            }),
            (s.prototype.and = function (v) {
              return this.length > v.length ? this.clone().iand(v) : v.clone().iand(this)
            }),
            (s.prototype.uand = function (v) {
              return this.length > v.length ? this.clone().iuand(v) : v.clone().iuand(this)
            }),
            (s.prototype.iuxor = function (v) {
              var C, N
              this.length > v.length ? ((C = this), (N = v)) : ((C = v), (N = this))
              for (var T = 0; T < N.length; T++) this.words[T] = C.words[T] ^ N.words[T]
              if (this !== C) for (; T < C.length; T++) this.words[T] = C.words[T]
              return (this.length = C.length), this.strip()
            }),
            (s.prototype.ixor = function (v) {
              return r((this.negative | v.negative) === 0), this.iuxor(v)
            }),
            (s.prototype.xor = function (v) {
              return this.length > v.length ? this.clone().ixor(v) : v.clone().ixor(this)
            }),
            (s.prototype.uxor = function (v) {
              return this.length > v.length ? this.clone().iuxor(v) : v.clone().iuxor(this)
            }),
            (s.prototype.inotn = function (v) {
              r(typeof v == 'number' && v >= 0)
              var C = Math.ceil(v / 26) | 0,
                N = v % 26
              this._expand(C), N > 0 && C--
              for (var T = 0; T < C; T++) this.words[T] = ~this.words[T] & 67108863
              return (
                N > 0 && (this.words[T] = ~this.words[T] & (67108863 >> (26 - N))), this.strip()
              )
            }),
            (s.prototype.notn = function (v) {
              return this.clone().inotn(v)
            }),
            (s.prototype.setn = function (v, C) {
              r(typeof v == 'number' && v >= 0)
              var N = (v / 26) | 0,
                T = v % 26
              return (
                this._expand(N + 1),
                C
                  ? (this.words[N] = this.words[N] | (1 << T))
                  : (this.words[N] = this.words[N] & ~(1 << T)),
                this.strip()
              )
            }),
            (s.prototype.iadd = function (v) {
              var C
              if (this.negative !== 0 && v.negative === 0)
                return (
                  (this.negative = 0), (C = this.isub(v)), (this.negative ^= 1), this._normSign()
                )
              if (this.negative === 0 && v.negative !== 0)
                return (v.negative = 0), (C = this.isub(v)), (v.negative = 1), C._normSign()
              var N, T
              this.length > v.length ? ((N = this), (T = v)) : ((N = v), (T = this))
              for (var S = 0, k = 0; k < T.length; k++)
                (C = (N.words[k] | 0) + (T.words[k] | 0) + S),
                  (this.words[k] = C & 67108863),
                  (S = C >>> 26)
              for (; S !== 0 && k < N.length; k++)
                (C = (N.words[k] | 0) + S), (this.words[k] = C & 67108863), (S = C >>> 26)
              if (((this.length = N.length), S !== 0)) (this.words[this.length] = S), this.length++
              else if (N !== this) for (; k < N.length; k++) this.words[k] = N.words[k]
              return this
            }),
            (s.prototype.add = function (v) {
              var C
              return v.negative !== 0 && this.negative === 0
                ? ((v.negative = 0), (C = this.sub(v)), (v.negative ^= 1), C)
                : v.negative === 0 && this.negative !== 0
                  ? ((this.negative = 0), (C = v.sub(this)), (this.negative = 1), C)
                  : this.length > v.length
                    ? this.clone().iadd(v)
                    : v.clone().iadd(this)
            }),
            (s.prototype.isub = function (v) {
              if (v.negative !== 0) {
                v.negative = 0
                var C = this.iadd(v)
                return (v.negative = 1), C._normSign()
              } else if (this.negative !== 0)
                return (this.negative = 0), this.iadd(v), (this.negative = 1), this._normSign()
              var N = this.cmp(v)
              if (N === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
              var T, S
              N > 0 ? ((T = this), (S = v)) : ((T = v), (S = this))
              for (var k = 0, F = 0; F < S.length; F++)
                (C = (T.words[F] | 0) - (S.words[F] | 0) + k),
                  (k = C >> 26),
                  (this.words[F] = C & 67108863)
              for (; k !== 0 && F < T.length; F++)
                (C = (T.words[F] | 0) + k), (k = C >> 26), (this.words[F] = C & 67108863)
              if (k === 0 && F < T.length && T !== this)
                for (; F < T.length; F++) this.words[F] = T.words[F]
              return (
                (this.length = Math.max(this.length, F)),
                T !== this && (this.negative = 1),
                this.strip()
              )
            }),
            (s.prototype.sub = function (v) {
              return this.clone().isub(v)
            })
          function A(L, v, C) {
            C.negative = v.negative ^ L.negative
            var N = (L.length + v.length) | 0
            ;(C.length = N), (N = (N - 1) | 0)
            var T = L.words[0] | 0,
              S = v.words[0] | 0,
              k = T * S,
              F = k & 67108863,
              P = (k / 67108864) | 0
            C.words[0] = F
            for (var w = 1; w < N; w++) {
              for (
                var B = P >>> 26,
                  Z = P & 67108863,
                  ee = Math.min(w, v.length - 1),
                  Y = Math.max(0, w - L.length + 1);
                Y <= ee;
                Y++
              ) {
                var se = (w - Y) | 0
                ;(T = L.words[se] | 0),
                  (S = v.words[Y] | 0),
                  (k = T * S + Z),
                  (B += (k / 67108864) | 0),
                  (Z = k & 67108863)
              }
              ;(C.words[w] = Z | 0), (P = B | 0)
            }
            return P !== 0 ? (C.words[w] = P | 0) : C.length--, C.strip()
          }
          var E = function (v, C, N) {
            var T = v.words,
              S = C.words,
              k = N.words,
              F = 0,
              P,
              w,
              B,
              Z = T[0] | 0,
              ee = Z & 8191,
              Y = Z >>> 13,
              se = T[1] | 0,
              ce = se & 8191,
              we = se >>> 13,
              _e = T[2] | 0,
              ye = _e & 8191,
              Ce = _e >>> 13,
              kt = T[3] | 0,
              tt = kt & 8191,
              Ke = kt >>> 13,
              jn = T[4] | 0,
              ut = jn & 8191,
              lt = jn >>> 13,
              qr = T[5] | 0,
              It = qr & 8191,
              Ot = qr >>> 13,
              yi = T[6] | 0,
              xt = yi & 8191,
              zt = yi >>> 13,
              ms = T[7] | 0,
              Je = ms & 8191,
              Rt = ms >>> 13,
              Ki = T[8] | 0,
              qt = Ki & 8191,
              Zt = Ki >>> 13,
              _u = T[9] | 0,
              dn = _u & 8191,
              Tn = _u >>> 13,
              Bp = S[0] | 0,
              rn = Bp & 8191,
              mt = Bp >>> 13,
              Lp = S[1] | 0,
              Ut = Lp & 8191,
              bt = Lp >>> 13,
              $p = S[2] | 0,
              xn = $p & 8191,
              Nn = $p >>> 13,
              Zo = S[3] | 0,
              fn = Zo & 8191,
              Ht = Zo >>> 13,
              Xo = S[4] | 0,
              sn = Xo & 8191,
              In = Xo >>> 13,
              Od = S[5] | 0,
              vn = Od & 8191,
              mn = Od >>> 13,
              za = S[6] | 0,
              On = za & 8191,
              wn = za >>> 13,
              Rd = S[7] | 0,
              En = Rd & 8191,
              An = Rd >>> 13,
              Fp = S[8] | 0,
              Bt = Fp & 8191,
              st = Fp >>> 13,
              dr = S[9] | 0,
              Xt = dr & 8191,
              bn = dr >>> 13
            ;(N.negative = v.negative ^ C.negative),
              (N.length = 19),
              (P = Math.imul(ee, rn)),
              (w = Math.imul(ee, mt)),
              (w = (w + Math.imul(Y, rn)) | 0),
              (B = Math.imul(Y, mt))
            var Dd = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Dd >>> 26)) | 0),
              (Dd &= 67108863),
              (P = Math.imul(ce, rn)),
              (w = Math.imul(ce, mt)),
              (w = (w + Math.imul(we, rn)) | 0),
              (B = Math.imul(we, mt)),
              (P = (P + Math.imul(ee, Ut)) | 0),
              (w = (w + Math.imul(ee, bt)) | 0),
              (w = (w + Math.imul(Y, Ut)) | 0),
              (B = (B + Math.imul(Y, bt)) | 0)
            var Pd = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Pd >>> 26)) | 0),
              (Pd &= 67108863),
              (P = Math.imul(ye, rn)),
              (w = Math.imul(ye, mt)),
              (w = (w + Math.imul(Ce, rn)) | 0),
              (B = Math.imul(Ce, mt)),
              (P = (P + Math.imul(ce, Ut)) | 0),
              (w = (w + Math.imul(ce, bt)) | 0),
              (w = (w + Math.imul(we, Ut)) | 0),
              (B = (B + Math.imul(we, bt)) | 0),
              (P = (P + Math.imul(ee, xn)) | 0),
              (w = (w + Math.imul(ee, Nn)) | 0),
              (w = (w + Math.imul(Y, xn)) | 0),
              (B = (B + Math.imul(Y, Nn)) | 0)
            var Cu = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Cu >>> 26)) | 0),
              (Cu &= 67108863),
              (P = Math.imul(tt, rn)),
              (w = Math.imul(tt, mt)),
              (w = (w + Math.imul(Ke, rn)) | 0),
              (B = Math.imul(Ke, mt)),
              (P = (P + Math.imul(ye, Ut)) | 0),
              (w = (w + Math.imul(ye, bt)) | 0),
              (w = (w + Math.imul(Ce, Ut)) | 0),
              (B = (B + Math.imul(Ce, bt)) | 0),
              (P = (P + Math.imul(ce, xn)) | 0),
              (w = (w + Math.imul(ce, Nn)) | 0),
              (w = (w + Math.imul(we, xn)) | 0),
              (B = (B + Math.imul(we, Nn)) | 0),
              (P = (P + Math.imul(ee, fn)) | 0),
              (w = (w + Math.imul(ee, Ht)) | 0),
              (w = (w + Math.imul(Y, fn)) | 0),
              (B = (B + Math.imul(Y, Ht)) | 0)
            var Zs = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Zs >>> 26)) | 0),
              (Zs &= 67108863),
              (P = Math.imul(ut, rn)),
              (w = Math.imul(ut, mt)),
              (w = (w + Math.imul(lt, rn)) | 0),
              (B = Math.imul(lt, mt)),
              (P = (P + Math.imul(tt, Ut)) | 0),
              (w = (w + Math.imul(tt, bt)) | 0),
              (w = (w + Math.imul(Ke, Ut)) | 0),
              (B = (B + Math.imul(Ke, bt)) | 0),
              (P = (P + Math.imul(ye, xn)) | 0),
              (w = (w + Math.imul(ye, Nn)) | 0),
              (w = (w + Math.imul(Ce, xn)) | 0),
              (B = (B + Math.imul(Ce, Nn)) | 0),
              (P = (P + Math.imul(ce, fn)) | 0),
              (w = (w + Math.imul(ce, Ht)) | 0),
              (w = (w + Math.imul(we, fn)) | 0),
              (B = (B + Math.imul(we, Ht)) | 0),
              (P = (P + Math.imul(ee, sn)) | 0),
              (w = (w + Math.imul(ee, In)) | 0),
              (w = (w + Math.imul(Y, sn)) | 0),
              (B = (B + Math.imul(Y, In)) | 0)
            var Jo = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Jo >>> 26)) | 0),
              (Jo &= 67108863),
              (P = Math.imul(It, rn)),
              (w = Math.imul(It, mt)),
              (w = (w + Math.imul(Ot, rn)) | 0),
              (B = Math.imul(Ot, mt)),
              (P = (P + Math.imul(ut, Ut)) | 0),
              (w = (w + Math.imul(ut, bt)) | 0),
              (w = (w + Math.imul(lt, Ut)) | 0),
              (B = (B + Math.imul(lt, bt)) | 0),
              (P = (P + Math.imul(tt, xn)) | 0),
              (w = (w + Math.imul(tt, Nn)) | 0),
              (w = (w + Math.imul(Ke, xn)) | 0),
              (B = (B + Math.imul(Ke, Nn)) | 0),
              (P = (P + Math.imul(ye, fn)) | 0),
              (w = (w + Math.imul(ye, Ht)) | 0),
              (w = (w + Math.imul(Ce, fn)) | 0),
              (B = (B + Math.imul(Ce, Ht)) | 0),
              (P = (P + Math.imul(ce, sn)) | 0),
              (w = (w + Math.imul(ce, In)) | 0),
              (w = (w + Math.imul(we, sn)) | 0),
              (B = (B + Math.imul(we, In)) | 0),
              (P = (P + Math.imul(ee, vn)) | 0),
              (w = (w + Math.imul(ee, mn)) | 0),
              (w = (w + Math.imul(Y, vn)) | 0),
              (B = (B + Math.imul(Y, mn)) | 0)
            var Wi = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Wi >>> 26)) | 0),
              (Wi &= 67108863),
              (P = Math.imul(xt, rn)),
              (w = Math.imul(xt, mt)),
              (w = (w + Math.imul(zt, rn)) | 0),
              (B = Math.imul(zt, mt)),
              (P = (P + Math.imul(It, Ut)) | 0),
              (w = (w + Math.imul(It, bt)) | 0),
              (w = (w + Math.imul(Ot, Ut)) | 0),
              (B = (B + Math.imul(Ot, bt)) | 0),
              (P = (P + Math.imul(ut, xn)) | 0),
              (w = (w + Math.imul(ut, Nn)) | 0),
              (w = (w + Math.imul(lt, xn)) | 0),
              (B = (B + Math.imul(lt, Nn)) | 0),
              (P = (P + Math.imul(tt, fn)) | 0),
              (w = (w + Math.imul(tt, Ht)) | 0),
              (w = (w + Math.imul(Ke, fn)) | 0),
              (B = (B + Math.imul(Ke, Ht)) | 0),
              (P = (P + Math.imul(ye, sn)) | 0),
              (w = (w + Math.imul(ye, In)) | 0),
              (w = (w + Math.imul(Ce, sn)) | 0),
              (B = (B + Math.imul(Ce, In)) | 0),
              (P = (P + Math.imul(ce, vn)) | 0),
              (w = (w + Math.imul(ce, mn)) | 0),
              (w = (w + Math.imul(we, vn)) | 0),
              (B = (B + Math.imul(we, mn)) | 0),
              (P = (P + Math.imul(ee, On)) | 0),
              (w = (w + Math.imul(ee, wn)) | 0),
              (w = (w + Math.imul(Y, On)) | 0),
              (B = (B + Math.imul(Y, wn)) | 0)
            var bs = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (bs >>> 26)) | 0),
              (bs &= 67108863),
              (P = Math.imul(Je, rn)),
              (w = Math.imul(Je, mt)),
              (w = (w + Math.imul(Rt, rn)) | 0),
              (B = Math.imul(Rt, mt)),
              (P = (P + Math.imul(xt, Ut)) | 0),
              (w = (w + Math.imul(xt, bt)) | 0),
              (w = (w + Math.imul(zt, Ut)) | 0),
              (B = (B + Math.imul(zt, bt)) | 0),
              (P = (P + Math.imul(It, xn)) | 0),
              (w = (w + Math.imul(It, Nn)) | 0),
              (w = (w + Math.imul(Ot, xn)) | 0),
              (B = (B + Math.imul(Ot, Nn)) | 0),
              (P = (P + Math.imul(ut, fn)) | 0),
              (w = (w + Math.imul(ut, Ht)) | 0),
              (w = (w + Math.imul(lt, fn)) | 0),
              (B = (B + Math.imul(lt, Ht)) | 0),
              (P = (P + Math.imul(tt, sn)) | 0),
              (w = (w + Math.imul(tt, In)) | 0),
              (w = (w + Math.imul(Ke, sn)) | 0),
              (B = (B + Math.imul(Ke, In)) | 0),
              (P = (P + Math.imul(ye, vn)) | 0),
              (w = (w + Math.imul(ye, mn)) | 0),
              (w = (w + Math.imul(Ce, vn)) | 0),
              (B = (B + Math.imul(Ce, mn)) | 0),
              (P = (P + Math.imul(ce, On)) | 0),
              (w = (w + Math.imul(ce, wn)) | 0),
              (w = (w + Math.imul(we, On)) | 0),
              (B = (B + Math.imul(we, wn)) | 0),
              (P = (P + Math.imul(ee, En)) | 0),
              (w = (w + Math.imul(ee, An)) | 0),
              (w = (w + Math.imul(Y, En)) | 0),
              (B = (B + Math.imul(Y, An)) | 0)
            var Xs = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Xs >>> 26)) | 0),
              (Xs &= 67108863),
              (P = Math.imul(qt, rn)),
              (w = Math.imul(qt, mt)),
              (w = (w + Math.imul(Zt, rn)) | 0),
              (B = Math.imul(Zt, mt)),
              (P = (P + Math.imul(Je, Ut)) | 0),
              (w = (w + Math.imul(Je, bt)) | 0),
              (w = (w + Math.imul(Rt, Ut)) | 0),
              (B = (B + Math.imul(Rt, bt)) | 0),
              (P = (P + Math.imul(xt, xn)) | 0),
              (w = (w + Math.imul(xt, Nn)) | 0),
              (w = (w + Math.imul(zt, xn)) | 0),
              (B = (B + Math.imul(zt, Nn)) | 0),
              (P = (P + Math.imul(It, fn)) | 0),
              (w = (w + Math.imul(It, Ht)) | 0),
              (w = (w + Math.imul(Ot, fn)) | 0),
              (B = (B + Math.imul(Ot, Ht)) | 0),
              (P = (P + Math.imul(ut, sn)) | 0),
              (w = (w + Math.imul(ut, In)) | 0),
              (w = (w + Math.imul(lt, sn)) | 0),
              (B = (B + Math.imul(lt, In)) | 0),
              (P = (P + Math.imul(tt, vn)) | 0),
              (w = (w + Math.imul(tt, mn)) | 0),
              (w = (w + Math.imul(Ke, vn)) | 0),
              (B = (B + Math.imul(Ke, mn)) | 0),
              (P = (P + Math.imul(ye, On)) | 0),
              (w = (w + Math.imul(ye, wn)) | 0),
              (w = (w + Math.imul(Ce, On)) | 0),
              (B = (B + Math.imul(Ce, wn)) | 0),
              (P = (P + Math.imul(ce, En)) | 0),
              (w = (w + Math.imul(ce, An)) | 0),
              (w = (w + Math.imul(we, En)) | 0),
              (B = (B + Math.imul(we, An)) | 0),
              (P = (P + Math.imul(ee, Bt)) | 0),
              (w = (w + Math.imul(ee, st)) | 0),
              (w = (w + Math.imul(Y, Bt)) | 0),
              (B = (B + Math.imul(Y, st)) | 0)
            var ys = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (ys >>> 26)) | 0),
              (ys &= 67108863),
              (P = Math.imul(dn, rn)),
              (w = Math.imul(dn, mt)),
              (w = (w + Math.imul(Tn, rn)) | 0),
              (B = Math.imul(Tn, mt)),
              (P = (P + Math.imul(qt, Ut)) | 0),
              (w = (w + Math.imul(qt, bt)) | 0),
              (w = (w + Math.imul(Zt, Ut)) | 0),
              (B = (B + Math.imul(Zt, bt)) | 0),
              (P = (P + Math.imul(Je, xn)) | 0),
              (w = (w + Math.imul(Je, Nn)) | 0),
              (w = (w + Math.imul(Rt, xn)) | 0),
              (B = (B + Math.imul(Rt, Nn)) | 0),
              (P = (P + Math.imul(xt, fn)) | 0),
              (w = (w + Math.imul(xt, Ht)) | 0),
              (w = (w + Math.imul(zt, fn)) | 0),
              (B = (B + Math.imul(zt, Ht)) | 0),
              (P = (P + Math.imul(It, sn)) | 0),
              (w = (w + Math.imul(It, In)) | 0),
              (w = (w + Math.imul(Ot, sn)) | 0),
              (B = (B + Math.imul(Ot, In)) | 0),
              (P = (P + Math.imul(ut, vn)) | 0),
              (w = (w + Math.imul(ut, mn)) | 0),
              (w = (w + Math.imul(lt, vn)) | 0),
              (B = (B + Math.imul(lt, mn)) | 0),
              (P = (P + Math.imul(tt, On)) | 0),
              (w = (w + Math.imul(tt, wn)) | 0),
              (w = (w + Math.imul(Ke, On)) | 0),
              (B = (B + Math.imul(Ke, wn)) | 0),
              (P = (P + Math.imul(ye, En)) | 0),
              (w = (w + Math.imul(ye, An)) | 0),
              (w = (w + Math.imul(Ce, En)) | 0),
              (B = (B + Math.imul(Ce, An)) | 0),
              (P = (P + Math.imul(ce, Bt)) | 0),
              (w = (w + Math.imul(ce, st)) | 0),
              (w = (w + Math.imul(we, Bt)) | 0),
              (B = (B + Math.imul(we, st)) | 0),
              (P = (P + Math.imul(ee, Xt)) | 0),
              (w = (w + Math.imul(ee, bn)) | 0),
              (w = (w + Math.imul(Y, Xt)) | 0),
              (B = (B + Math.imul(Y, bn)) | 0)
            var Rn = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Rn >>> 26)) | 0),
              (Rn &= 67108863),
              (P = Math.imul(dn, Ut)),
              (w = Math.imul(dn, bt)),
              (w = (w + Math.imul(Tn, Ut)) | 0),
              (B = Math.imul(Tn, bt)),
              (P = (P + Math.imul(qt, xn)) | 0),
              (w = (w + Math.imul(qt, Nn)) | 0),
              (w = (w + Math.imul(Zt, xn)) | 0),
              (B = (B + Math.imul(Zt, Nn)) | 0),
              (P = (P + Math.imul(Je, fn)) | 0),
              (w = (w + Math.imul(Je, Ht)) | 0),
              (w = (w + Math.imul(Rt, fn)) | 0),
              (B = (B + Math.imul(Rt, Ht)) | 0),
              (P = (P + Math.imul(xt, sn)) | 0),
              (w = (w + Math.imul(xt, In)) | 0),
              (w = (w + Math.imul(zt, sn)) | 0),
              (B = (B + Math.imul(zt, In)) | 0),
              (P = (P + Math.imul(It, vn)) | 0),
              (w = (w + Math.imul(It, mn)) | 0),
              (w = (w + Math.imul(Ot, vn)) | 0),
              (B = (B + Math.imul(Ot, mn)) | 0),
              (P = (P + Math.imul(ut, On)) | 0),
              (w = (w + Math.imul(ut, wn)) | 0),
              (w = (w + Math.imul(lt, On)) | 0),
              (B = (B + Math.imul(lt, wn)) | 0),
              (P = (P + Math.imul(tt, En)) | 0),
              (w = (w + Math.imul(tt, An)) | 0),
              (w = (w + Math.imul(Ke, En)) | 0),
              (B = (B + Math.imul(Ke, An)) | 0),
              (P = (P + Math.imul(ye, Bt)) | 0),
              (w = (w + Math.imul(ye, st)) | 0),
              (w = (w + Math.imul(Ce, Bt)) | 0),
              (B = (B + Math.imul(Ce, st)) | 0),
              (P = (P + Math.imul(ce, Xt)) | 0),
              (w = (w + Math.imul(ce, bn)) | 0),
              (w = (w + Math.imul(we, Xt)) | 0),
              (B = (B + Math.imul(we, bn)) | 0)
            var Su = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Su >>> 26)) | 0),
              (Su &= 67108863),
              (P = Math.imul(dn, xn)),
              (w = Math.imul(dn, Nn)),
              (w = (w + Math.imul(Tn, xn)) | 0),
              (B = Math.imul(Tn, Nn)),
              (P = (P + Math.imul(qt, fn)) | 0),
              (w = (w + Math.imul(qt, Ht)) | 0),
              (w = (w + Math.imul(Zt, fn)) | 0),
              (B = (B + Math.imul(Zt, Ht)) | 0),
              (P = (P + Math.imul(Je, sn)) | 0),
              (w = (w + Math.imul(Je, In)) | 0),
              (w = (w + Math.imul(Rt, sn)) | 0),
              (B = (B + Math.imul(Rt, In)) | 0),
              (P = (P + Math.imul(xt, vn)) | 0),
              (w = (w + Math.imul(xt, mn)) | 0),
              (w = (w + Math.imul(zt, vn)) | 0),
              (B = (B + Math.imul(zt, mn)) | 0),
              (P = (P + Math.imul(It, On)) | 0),
              (w = (w + Math.imul(It, wn)) | 0),
              (w = (w + Math.imul(Ot, On)) | 0),
              (B = (B + Math.imul(Ot, wn)) | 0),
              (P = (P + Math.imul(ut, En)) | 0),
              (w = (w + Math.imul(ut, An)) | 0),
              (w = (w + Math.imul(lt, En)) | 0),
              (B = (B + Math.imul(lt, An)) | 0),
              (P = (P + Math.imul(tt, Bt)) | 0),
              (w = (w + Math.imul(tt, st)) | 0),
              (w = (w + Math.imul(Ke, Bt)) | 0),
              (B = (B + Math.imul(Ke, st)) | 0),
              (P = (P + Math.imul(ye, Xt)) | 0),
              (w = (w + Math.imul(ye, bn)) | 0),
              (w = (w + Math.imul(Ce, Xt)) | 0),
              (B = (B + Math.imul(Ce, bn)) | 0)
            var Tu = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Tu >>> 26)) | 0),
              (Tu &= 67108863),
              (P = Math.imul(dn, fn)),
              (w = Math.imul(dn, Ht)),
              (w = (w + Math.imul(Tn, fn)) | 0),
              (B = Math.imul(Tn, Ht)),
              (P = (P + Math.imul(qt, sn)) | 0),
              (w = (w + Math.imul(qt, In)) | 0),
              (w = (w + Math.imul(Zt, sn)) | 0),
              (B = (B + Math.imul(Zt, In)) | 0),
              (P = (P + Math.imul(Je, vn)) | 0),
              (w = (w + Math.imul(Je, mn)) | 0),
              (w = (w + Math.imul(Rt, vn)) | 0),
              (B = (B + Math.imul(Rt, mn)) | 0),
              (P = (P + Math.imul(xt, On)) | 0),
              (w = (w + Math.imul(xt, wn)) | 0),
              (w = (w + Math.imul(zt, On)) | 0),
              (B = (B + Math.imul(zt, wn)) | 0),
              (P = (P + Math.imul(It, En)) | 0),
              (w = (w + Math.imul(It, An)) | 0),
              (w = (w + Math.imul(Ot, En)) | 0),
              (B = (B + Math.imul(Ot, An)) | 0),
              (P = (P + Math.imul(ut, Bt)) | 0),
              (w = (w + Math.imul(ut, st)) | 0),
              (w = (w + Math.imul(lt, Bt)) | 0),
              (B = (B + Math.imul(lt, st)) | 0),
              (P = (P + Math.imul(tt, Xt)) | 0),
              (w = (w + Math.imul(tt, bn)) | 0),
              (w = (w + Math.imul(Ke, Xt)) | 0),
              (B = (B + Math.imul(Ke, bn)) | 0)
            var Qi = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Qi >>> 26)) | 0),
              (Qi &= 67108863),
              (P = Math.imul(dn, sn)),
              (w = Math.imul(dn, In)),
              (w = (w + Math.imul(Tn, sn)) | 0),
              (B = Math.imul(Tn, In)),
              (P = (P + Math.imul(qt, vn)) | 0),
              (w = (w + Math.imul(qt, mn)) | 0),
              (w = (w + Math.imul(Zt, vn)) | 0),
              (B = (B + Math.imul(Zt, mn)) | 0),
              (P = (P + Math.imul(Je, On)) | 0),
              (w = (w + Math.imul(Je, wn)) | 0),
              (w = (w + Math.imul(Rt, On)) | 0),
              (B = (B + Math.imul(Rt, wn)) | 0),
              (P = (P + Math.imul(xt, En)) | 0),
              (w = (w + Math.imul(xt, An)) | 0),
              (w = (w + Math.imul(zt, En)) | 0),
              (B = (B + Math.imul(zt, An)) | 0),
              (P = (P + Math.imul(It, Bt)) | 0),
              (w = (w + Math.imul(It, st)) | 0),
              (w = (w + Math.imul(Ot, Bt)) | 0),
              (B = (B + Math.imul(Ot, st)) | 0),
              (P = (P + Math.imul(ut, Xt)) | 0),
              (w = (w + Math.imul(ut, bn)) | 0),
              (w = (w + Math.imul(lt, Xt)) | 0),
              (B = (B + Math.imul(lt, bn)) | 0)
            var vs = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (vs >>> 26)) | 0),
              (vs &= 67108863),
              (P = Math.imul(dn, vn)),
              (w = Math.imul(dn, mn)),
              (w = (w + Math.imul(Tn, vn)) | 0),
              (B = Math.imul(Tn, mn)),
              (P = (P + Math.imul(qt, On)) | 0),
              (w = (w + Math.imul(qt, wn)) | 0),
              (w = (w + Math.imul(Zt, On)) | 0),
              (B = (B + Math.imul(Zt, wn)) | 0),
              (P = (P + Math.imul(Je, En)) | 0),
              (w = (w + Math.imul(Je, An)) | 0),
              (w = (w + Math.imul(Rt, En)) | 0),
              (B = (B + Math.imul(Rt, An)) | 0),
              (P = (P + Math.imul(xt, Bt)) | 0),
              (w = (w + Math.imul(xt, st)) | 0),
              (w = (w + Math.imul(zt, Bt)) | 0),
              (B = (B + Math.imul(zt, st)) | 0),
              (P = (P + Math.imul(It, Xt)) | 0),
              (w = (w + Math.imul(It, bn)) | 0),
              (w = (w + Math.imul(Ot, Xt)) | 0),
              (B = (B + Math.imul(Ot, bn)) | 0)
            var ii = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (ii >>> 26)) | 0),
              (ii &= 67108863),
              (P = Math.imul(dn, On)),
              (w = Math.imul(dn, wn)),
              (w = (w + Math.imul(Tn, On)) | 0),
              (B = Math.imul(Tn, wn)),
              (P = (P + Math.imul(qt, En)) | 0),
              (w = (w + Math.imul(qt, An)) | 0),
              (w = (w + Math.imul(Zt, En)) | 0),
              (B = (B + Math.imul(Zt, An)) | 0),
              (P = (P + Math.imul(Je, Bt)) | 0),
              (w = (w + Math.imul(Je, st)) | 0),
              (w = (w + Math.imul(Rt, Bt)) | 0),
              (B = (B + Math.imul(Rt, st)) | 0),
              (P = (P + Math.imul(xt, Xt)) | 0),
              (w = (w + Math.imul(xt, bn)) | 0),
              (w = (w + Math.imul(zt, Xt)) | 0),
              (B = (B + Math.imul(zt, bn)) | 0)
            var Md = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Md >>> 26)) | 0),
              (Md &= 67108863),
              (P = Math.imul(dn, En)),
              (w = Math.imul(dn, An)),
              (w = (w + Math.imul(Tn, En)) | 0),
              (B = Math.imul(Tn, An)),
              (P = (P + Math.imul(qt, Bt)) | 0),
              (w = (w + Math.imul(qt, st)) | 0),
              (w = (w + Math.imul(Zt, Bt)) | 0),
              (B = (B + Math.imul(Zt, st)) | 0),
              (P = (P + Math.imul(Je, Xt)) | 0),
              (w = (w + Math.imul(Je, bn)) | 0),
              (w = (w + Math.imul(Rt, Xt)) | 0),
              (B = (B + Math.imul(Rt, bn)) | 0)
            var xu = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (xu >>> 26)) | 0),
              (xu &= 67108863),
              (P = Math.imul(dn, Bt)),
              (w = Math.imul(dn, st)),
              (w = (w + Math.imul(Tn, Bt)) | 0),
              (B = Math.imul(Tn, st)),
              (P = (P + Math.imul(qt, Xt)) | 0),
              (w = (w + Math.imul(qt, bn)) | 0),
              (w = (w + Math.imul(Zt, Xt)) | 0),
              (B = (B + Math.imul(Zt, bn)) | 0)
            var Nu = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            ;(F = (((B + (w >>> 13)) | 0) + (Nu >>> 26)) | 0),
              (Nu &= 67108863),
              (P = Math.imul(dn, Xt)),
              (w = Math.imul(dn, bn)),
              (w = (w + Math.imul(Tn, Xt)) | 0),
              (B = Math.imul(Tn, bn))
            var kd = (((F + P) | 0) + ((w & 8191) << 13)) | 0
            return (
              (F = (((B + (w >>> 13)) | 0) + (kd >>> 26)) | 0),
              (kd &= 67108863),
              (k[0] = Dd),
              (k[1] = Pd),
              (k[2] = Cu),
              (k[3] = Zs),
              (k[4] = Jo),
              (k[5] = Wi),
              (k[6] = bs),
              (k[7] = Xs),
              (k[8] = ys),
              (k[9] = Rn),
              (k[10] = Su),
              (k[11] = Tu),
              (k[12] = Qi),
              (k[13] = vs),
              (k[14] = ii),
              (k[15] = Md),
              (k[16] = xu),
              (k[17] = Nu),
              (k[18] = kd),
              F !== 0 && ((k[19] = F), N.length++),
              N
            )
          }
          Math.imul || (E = A)
          function x(L, v, C) {
            ;(C.negative = v.negative ^ L.negative), (C.length = L.length + v.length)
            for (var N = 0, T = 0, S = 0; S < C.length - 1; S++) {
              var k = T
              T = 0
              for (
                var F = N & 67108863,
                  P = Math.min(S, v.length - 1),
                  w = Math.max(0, S - L.length + 1);
                w <= P;
                w++
              ) {
                var B = S - w,
                  Z = L.words[B] | 0,
                  ee = v.words[w] | 0,
                  Y = Z * ee,
                  se = Y & 67108863
                ;(k = (k + ((Y / 67108864) | 0)) | 0),
                  (se = (se + F) | 0),
                  (F = se & 67108863),
                  (k = (k + (se >>> 26)) | 0),
                  (T += k >>> 26),
                  (k &= 67108863)
              }
              ;(C.words[S] = F), (N = k), (k = T)
            }
            return N !== 0 ? (C.words[S] = N) : C.length--, C.strip()
          }
          function O(L, v, C) {
            var N = new I()
            return N.mulp(L, v, C)
          }
          s.prototype.mulTo = function (v, C) {
            var N,
              T = this.length + v.length
            return (
              this.length === 10 && v.length === 10
                ? (N = E(this, v, C))
                : T < 63
                  ? (N = A(this, v, C))
                  : T < 1024
                    ? (N = x(this, v, C))
                    : (N = O(this, v, C)),
              N
            )
          }
          function I(L, v) {
            ;(this.x = L), (this.y = v)
          }
          ;(I.prototype.makeRBT = function (v) {
            for (var C = new Array(v), N = s.prototype._countBits(v) - 1, T = 0; T < v; T++)
              C[T] = this.revBin(T, N, v)
            return C
          }),
            (I.prototype.revBin = function (v, C, N) {
              if (v === 0 || v === N - 1) return v
              for (var T = 0, S = 0; S < C; S++) (T |= (v & 1) << (C - S - 1)), (v >>= 1)
              return T
            }),
            (I.prototype.permute = function (v, C, N, T, S, k) {
              for (var F = 0; F < k; F++) (T[F] = C[v[F]]), (S[F] = N[v[F]])
            }),
            (I.prototype.transform = function (v, C, N, T, S, k) {
              this.permute(k, v, C, N, T, S)
              for (var F = 1; F < S; F <<= 1)
                for (
                  var P = F << 1,
                    w = Math.cos((2 * Math.PI) / P),
                    B = Math.sin((2 * Math.PI) / P),
                    Z = 0;
                  Z < S;
                  Z += P
                )
                  for (var ee = w, Y = B, se = 0; se < F; se++) {
                    var ce = N[Z + se],
                      we = T[Z + se],
                      _e = N[Z + se + F],
                      ye = T[Z + se + F],
                      Ce = ee * _e - Y * ye
                    ;(ye = ee * ye + Y * _e),
                      (_e = Ce),
                      (N[Z + se] = ce + _e),
                      (T[Z + se] = we + ye),
                      (N[Z + se + F] = ce - _e),
                      (T[Z + se + F] = we - ye),
                      se !== P && ((Ce = w * ee - B * Y), (Y = w * Y + B * ee), (ee = Ce))
                  }
            }),
            (I.prototype.guessLen13b = function (v, C) {
              var N = Math.max(C, v) | 1,
                T = N & 1,
                S = 0
              for (N = (N / 2) | 0; N; N = N >>> 1) S++
              return 1 << (S + 1 + T)
            }),
            (I.prototype.conjugate = function (v, C, N) {
              if (!(N <= 1))
                for (var T = 0; T < N / 2; T++) {
                  var S = v[T]
                  ;(v[T] = v[N - T - 1]),
                    (v[N - T - 1] = S),
                    (S = C[T]),
                    (C[T] = -C[N - T - 1]),
                    (C[N - T - 1] = -S)
                }
            }),
            (I.prototype.normalize13b = function (v, C) {
              for (var N = 0, T = 0; T < C / 2; T++) {
                var S = Math.round(v[2 * T + 1] / C) * 8192 + Math.round(v[2 * T] / C) + N
                ;(v[T] = S & 67108863), S < 67108864 ? (N = 0) : (N = (S / 67108864) | 0)
              }
              return v
            }),
            (I.prototype.convert13b = function (v, C, N, T) {
              for (var S = 0, k = 0; k < C; k++)
                (S = S + (v[k] | 0)),
                  (N[2 * k] = S & 8191),
                  (S = S >>> 13),
                  (N[2 * k + 1] = S & 8191),
                  (S = S >>> 13)
              for (k = 2 * C; k < T; ++k) N[k] = 0
              r(S === 0), r((S & -8192) === 0)
            }),
            (I.prototype.stub = function (v) {
              for (var C = new Array(v), N = 0; N < v; N++) C[N] = 0
              return C
            }),
            (I.prototype.mulp = function (v, C, N) {
              var T = 2 * this.guessLen13b(v.length, C.length),
                S = this.makeRBT(T),
                k = this.stub(T),
                F = new Array(T),
                P = new Array(T),
                w = new Array(T),
                B = new Array(T),
                Z = new Array(T),
                ee = new Array(T),
                Y = N.words
              ;(Y.length = T),
                this.convert13b(v.words, v.length, F, T),
                this.convert13b(C.words, C.length, B, T),
                this.transform(F, k, P, w, T, S),
                this.transform(B, k, Z, ee, T, S)
              for (var se = 0; se < T; se++) {
                var ce = P[se] * Z[se] - w[se] * ee[se]
                ;(w[se] = P[se] * ee[se] + w[se] * Z[se]), (P[se] = ce)
              }
              return (
                this.conjugate(P, w, T),
                this.transform(P, w, Y, k, T, S),
                this.conjugate(Y, k, T),
                this.normalize13b(Y, T),
                (N.negative = v.negative ^ C.negative),
                (N.length = v.length + C.length),
                N.strip()
              )
            }),
            (s.prototype.mul = function (v) {
              var C = new s(null)
              return (C.words = new Array(this.length + v.length)), this.mulTo(v, C)
            }),
            (s.prototype.mulf = function (v) {
              var C = new s(null)
              return (C.words = new Array(this.length + v.length)), O(this, v, C)
            }),
            (s.prototype.imul = function (v) {
              return this.clone().mulTo(v, this)
            }),
            (s.prototype.imuln = function (v) {
              r(typeof v == 'number'), r(v < 67108864)
              for (var C = 0, N = 0; N < this.length; N++) {
                var T = (this.words[N] | 0) * v,
                  S = (T & 67108863) + (C & 67108863)
                ;(C >>= 26),
                  (C += (T / 67108864) | 0),
                  (C += S >>> 26),
                  (this.words[N] = S & 67108863)
              }
              return C !== 0 && ((this.words[N] = C), this.length++), this
            }),
            (s.prototype.muln = function (v) {
              return this.clone().imuln(v)
            }),
            (s.prototype.sqr = function () {
              return this.mul(this)
            }),
            (s.prototype.isqr = function () {
              return this.imul(this.clone())
            }),
            (s.prototype.pow = function (v) {
              var C = y(v)
              if (C.length === 0) return new s(1)
              for (var N = this, T = 0; T < C.length && C[T] === 0; T++, N = N.sqr());
              if (++T < C.length)
                for (var S = N.sqr(); T < C.length; T++, S = S.sqr()) C[T] !== 0 && (N = N.mul(S))
              return N
            }),
            (s.prototype.iushln = function (v) {
              r(typeof v == 'number' && v >= 0)
              var C = v % 26,
                N = (v - C) / 26,
                T = (67108863 >>> (26 - C)) << (26 - C),
                S
              if (C !== 0) {
                var k = 0
                for (S = 0; S < this.length; S++) {
                  var F = this.words[S] & T,
                    P = ((this.words[S] | 0) - F) << C
                  ;(this.words[S] = P | k), (k = F >>> (26 - C))
                }
                k && ((this.words[S] = k), this.length++)
              }
              if (N !== 0) {
                for (S = this.length - 1; S >= 0; S--) this.words[S + N] = this.words[S]
                for (S = 0; S < N; S++) this.words[S] = 0
                this.length += N
              }
              return this.strip()
            }),
            (s.prototype.ishln = function (v) {
              return r(this.negative === 0), this.iushln(v)
            }),
            (s.prototype.iushrn = function (v, C, N) {
              r(typeof v == 'number' && v >= 0)
              var T
              C ? (T = (C - (C % 26)) / 26) : (T = 0)
              var S = v % 26,
                k = Math.min((v - S) / 26, this.length),
                F = 67108863 ^ ((67108863 >>> S) << S),
                P = N
              if (((T -= k), (T = Math.max(0, T)), P)) {
                for (var w = 0; w < k; w++) P.words[w] = this.words[w]
                P.length = k
              }
              if (k !== 0)
                if (this.length > k)
                  for (this.length -= k, w = 0; w < this.length; w++)
                    this.words[w] = this.words[w + k]
                else (this.words[0] = 0), (this.length = 1)
              var B = 0
              for (w = this.length - 1; w >= 0 && (B !== 0 || w >= T); w--) {
                var Z = this.words[w] | 0
                ;(this.words[w] = (B << (26 - S)) | (Z >>> S)), (B = Z & F)
              }
              return (
                P && B !== 0 && (P.words[P.length++] = B),
                this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              )
            }),
            (s.prototype.ishrn = function (v, C, N) {
              return r(this.negative === 0), this.iushrn(v, C, N)
            }),
            (s.prototype.shln = function (v) {
              return this.clone().ishln(v)
            }),
            (s.prototype.ushln = function (v) {
              return this.clone().iushln(v)
            }),
            (s.prototype.shrn = function (v) {
              return this.clone().ishrn(v)
            }),
            (s.prototype.ushrn = function (v) {
              return this.clone().iushrn(v)
            }),
            (s.prototype.testn = function (v) {
              r(typeof v == 'number' && v >= 0)
              var C = v % 26,
                N = (v - C) / 26,
                T = 1 << C
              if (this.length <= N) return !1
              var S = this.words[N]
              return !!(S & T)
            }),
            (s.prototype.imaskn = function (v) {
              r(typeof v == 'number' && v >= 0)
              var C = v % 26,
                N = (v - C) / 26
              if (
                (r(this.negative === 0, 'imaskn works only with positive numbers'),
                this.length <= N)
              )
                return this
              if ((C !== 0 && N++, (this.length = Math.min(N, this.length)), C !== 0)) {
                var T = 67108863 ^ ((67108863 >>> C) << C)
                this.words[this.length - 1] &= T
              }
              return this.strip()
            }),
            (s.prototype.maskn = function (v) {
              return this.clone().imaskn(v)
            }),
            (s.prototype.iaddn = function (v) {
              return (
                r(typeof v == 'number'),
                r(v < 67108864),
                v < 0
                  ? this.isubn(-v)
                  : this.negative !== 0
                    ? this.length === 1 && (this.words[0] | 0) < v
                      ? ((this.words[0] = v - (this.words[0] | 0)), (this.negative = 0), this)
                      : ((this.negative = 0), this.isubn(v), (this.negative = 1), this)
                    : this._iaddn(v)
              )
            }),
            (s.prototype._iaddn = function (v) {
              this.words[0] += v
              for (var C = 0; C < this.length && this.words[C] >= 67108864; C++)
                (this.words[C] -= 67108864),
                  C === this.length - 1 ? (this.words[C + 1] = 1) : this.words[C + 1]++
              return (this.length = Math.max(this.length, C + 1)), this
            }),
            (s.prototype.isubn = function (v) {
              if ((r(typeof v == 'number'), r(v < 67108864), v < 0)) return this.iaddn(-v)
              if (this.negative !== 0)
                return (this.negative = 0), this.iaddn(v), (this.negative = 1), this
              if (((this.words[0] -= v), this.length === 1 && this.words[0] < 0))
                (this.words[0] = -this.words[0]), (this.negative = 1)
              else
                for (var C = 0; C < this.length && this.words[C] < 0; C++)
                  (this.words[C] += 67108864), (this.words[C + 1] -= 1)
              return this.strip()
            }),
            (s.prototype.addn = function (v) {
              return this.clone().iaddn(v)
            }),
            (s.prototype.subn = function (v) {
              return this.clone().isubn(v)
            }),
            (s.prototype.iabs = function () {
              return (this.negative = 0), this
            }),
            (s.prototype.abs = function () {
              return this.clone().iabs()
            }),
            (s.prototype._ishlnsubmul = function (v, C, N) {
              var T = v.length + N,
                S
              this._expand(T)
              var k,
                F = 0
              for (S = 0; S < v.length; S++) {
                k = (this.words[S + N] | 0) + F
                var P = (v.words[S] | 0) * C
                ;(k -= P & 67108863),
                  (F = (k >> 26) - ((P / 67108864) | 0)),
                  (this.words[S + N] = k & 67108863)
              }
              for (; S < this.length - N; S++)
                (k = (this.words[S + N] | 0) + F), (F = k >> 26), (this.words[S + N] = k & 67108863)
              if (F === 0) return this.strip()
              for (r(F === -1), F = 0, S = 0; S < this.length; S++)
                (k = -(this.words[S] | 0) + F), (F = k >> 26), (this.words[S] = k & 67108863)
              return (this.negative = 1), this.strip()
            }),
            (s.prototype._wordDiv = function (v, C) {
              var N = this.length - v.length,
                T = this.clone(),
                S = v,
                k = S.words[S.length - 1] | 0,
                F = this._countBits(k)
              ;(N = 26 - F),
                N !== 0 && ((S = S.ushln(N)), T.iushln(N), (k = S.words[S.length - 1] | 0))
              var P = T.length - S.length,
                w
              if (C !== 'mod') {
                ;(w = new s(null)), (w.length = P + 1), (w.words = new Array(w.length))
                for (var B = 0; B < w.length; B++) w.words[B] = 0
              }
              var Z = T.clone()._ishlnsubmul(S, 1, P)
              Z.negative === 0 && ((T = Z), w && (w.words[P] = 1))
              for (var ee = P - 1; ee >= 0; ee--) {
                var Y = (T.words[S.length + ee] | 0) * 67108864 + (T.words[S.length + ee - 1] | 0)
                for (
                  Y = Math.min((Y / k) | 0, 67108863), T._ishlnsubmul(S, Y, ee);
                  T.negative !== 0;

                )
                  Y--, (T.negative = 0), T._ishlnsubmul(S, 1, ee), T.isZero() || (T.negative ^= 1)
                w && (w.words[ee] = Y)
              }
              return (
                w && w.strip(),
                T.strip(),
                C !== 'div' && N !== 0 && T.iushrn(N),
                { div: w || null, mod: T }
              )
            }),
            (s.prototype.divmod = function (v, C, N) {
              if ((r(!v.isZero()), this.isZero())) return { div: new s(0), mod: new s(0) }
              var T, S, k
              return this.negative !== 0 && v.negative === 0
                ? ((k = this.neg().divmod(v, C)),
                  C !== 'mod' && (T = k.div.neg()),
                  C !== 'div' && ((S = k.mod.neg()), N && S.negative !== 0 && S.iadd(v)),
                  { div: T, mod: S })
                : this.negative === 0 && v.negative !== 0
                  ? ((k = this.divmod(v.neg(), C)),
                    C !== 'mod' && (T = k.div.neg()),
                    { div: T, mod: k.mod })
                  : (this.negative & v.negative) !== 0
                    ? ((k = this.neg().divmod(v.neg(), C)),
                      C !== 'div' && ((S = k.mod.neg()), N && S.negative !== 0 && S.isub(v)),
                      { div: k.div, mod: S })
                    : v.length > this.length || this.cmp(v) < 0
                      ? { div: new s(0), mod: this }
                      : v.length === 1
                        ? C === 'div'
                          ? { div: this.divn(v.words[0]), mod: null }
                          : C === 'mod'
                            ? { div: null, mod: new s(this.modn(v.words[0])) }
                            : { div: this.divn(v.words[0]), mod: new s(this.modn(v.words[0])) }
                        : this._wordDiv(v, C)
            }),
            (s.prototype.div = function (v) {
              return this.divmod(v, 'div', !1).div
            }),
            (s.prototype.mod = function (v) {
              return this.divmod(v, 'mod', !1).mod
            }),
            (s.prototype.umod = function (v) {
              return this.divmod(v, 'mod', !0).mod
            }),
            (s.prototype.divRound = function (v) {
              var C = this.divmod(v)
              if (C.mod.isZero()) return C.div
              var N = C.div.negative !== 0 ? C.mod.isub(v) : C.mod,
                T = v.ushrn(1),
                S = v.andln(1),
                k = N.cmp(T)
              return k < 0 || (S === 1 && k === 0)
                ? C.div
                : C.div.negative !== 0
                  ? C.div.isubn(1)
                  : C.div.iaddn(1)
            }),
            (s.prototype.modn = function (v) {
              r(v <= 67108863)
              for (var C = (1 << 26) % v, N = 0, T = this.length - 1; T >= 0; T--)
                N = (C * N + (this.words[T] | 0)) % v
              return N
            }),
            (s.prototype.idivn = function (v) {
              r(v <= 67108863)
              for (var C = 0, N = this.length - 1; N >= 0; N--) {
                var T = (this.words[N] | 0) + C * 67108864
                ;(this.words[N] = (T / v) | 0), (C = T % v)
              }
              return this.strip()
            }),
            (s.prototype.divn = function (v) {
              return this.clone().idivn(v)
            }),
            (s.prototype.egcd = function (v) {
              r(v.negative === 0), r(!v.isZero())
              var C = this,
                N = v.clone()
              C.negative !== 0 ? (C = C.umod(v)) : (C = C.clone())
              for (
                var T = new s(1), S = new s(0), k = new s(0), F = new s(1), P = 0;
                C.isEven() && N.isEven();

              )
                C.iushrn(1), N.iushrn(1), ++P
              for (var w = N.clone(), B = C.clone(); !C.isZero(); ) {
                for (var Z = 0, ee = 1; (C.words[0] & ee) === 0 && Z < 26; ++Z, ee <<= 1);
                if (Z > 0)
                  for (C.iushrn(Z); Z-- > 0; )
                    (T.isOdd() || S.isOdd()) && (T.iadd(w), S.isub(B)), T.iushrn(1), S.iushrn(1)
                for (var Y = 0, se = 1; (N.words[0] & se) === 0 && Y < 26; ++Y, se <<= 1);
                if (Y > 0)
                  for (N.iushrn(Y); Y-- > 0; )
                    (k.isOdd() || F.isOdd()) && (k.iadd(w), F.isub(B)), k.iushrn(1), F.iushrn(1)
                C.cmp(N) >= 0
                  ? (C.isub(N), T.isub(k), S.isub(F))
                  : (N.isub(C), k.isub(T), F.isub(S))
              }
              return { a: k, b: F, gcd: N.iushln(P) }
            }),
            (s.prototype._invmp = function (v) {
              r(v.negative === 0), r(!v.isZero())
              var C = this,
                N = v.clone()
              C.negative !== 0 ? (C = C.umod(v)) : (C = C.clone())
              for (
                var T = new s(1), S = new s(0), k = N.clone();
                C.cmpn(1) > 0 && N.cmpn(1) > 0;

              ) {
                for (var F = 0, P = 1; (C.words[0] & P) === 0 && F < 26; ++F, P <<= 1);
                if (F > 0) for (C.iushrn(F); F-- > 0; ) T.isOdd() && T.iadd(k), T.iushrn(1)
                for (var w = 0, B = 1; (N.words[0] & B) === 0 && w < 26; ++w, B <<= 1);
                if (w > 0) for (N.iushrn(w); w-- > 0; ) S.isOdd() && S.iadd(k), S.iushrn(1)
                C.cmp(N) >= 0 ? (C.isub(N), T.isub(S)) : (N.isub(C), S.isub(T))
              }
              var Z
              return C.cmpn(1) === 0 ? (Z = T) : (Z = S), Z.cmpn(0) < 0 && Z.iadd(v), Z
            }),
            (s.prototype.gcd = function (v) {
              if (this.isZero()) return v.abs()
              if (v.isZero()) return this.abs()
              var C = this.clone(),
                N = v.clone()
              ;(C.negative = 0), (N.negative = 0)
              for (var T = 0; C.isEven() && N.isEven(); T++) C.iushrn(1), N.iushrn(1)
              do {
                for (; C.isEven(); ) C.iushrn(1)
                for (; N.isEven(); ) N.iushrn(1)
                var S = C.cmp(N)
                if (S < 0) {
                  var k = C
                  ;(C = N), (N = k)
                } else if (S === 0 || N.cmpn(1) === 0) break
                C.isub(N)
              } while (!0)
              return N.iushln(T)
            }),
            (s.prototype.invm = function (v) {
              return this.egcd(v).a.umod(v)
            }),
            (s.prototype.isEven = function () {
              return (this.words[0] & 1) === 0
            }),
            (s.prototype.isOdd = function () {
              return (this.words[0] & 1) === 1
            }),
            (s.prototype.andln = function (v) {
              return this.words[0] & v
            }),
            (s.prototype.bincn = function (v) {
              r(typeof v == 'number')
              var C = v % 26,
                N = (v - C) / 26,
                T = 1 << C
              if (this.length <= N) return this._expand(N + 1), (this.words[N] |= T), this
              for (var S = T, k = N; S !== 0 && k < this.length; k++) {
                var F = this.words[k] | 0
                ;(F += S), (S = F >>> 26), (F &= 67108863), (this.words[k] = F)
              }
              return S !== 0 && ((this.words[k] = S), this.length++), this
            }),
            (s.prototype.isZero = function () {
              return this.length === 1 && this.words[0] === 0
            }),
            (s.prototype.cmpn = function (v) {
              var C = v < 0
              if (this.negative !== 0 && !C) return -1
              if (this.negative === 0 && C) return 1
              this.strip()
              var N
              if (this.length > 1) N = 1
              else {
                C && (v = -v), r(v <= 67108863, 'Number is too big')
                var T = this.words[0] | 0
                N = T === v ? 0 : T < v ? -1 : 1
              }
              return this.negative !== 0 ? -N | 0 : N
            }),
            (s.prototype.cmp = function (v) {
              if (this.negative !== 0 && v.negative === 0) return -1
              if (this.negative === 0 && v.negative !== 0) return 1
              var C = this.ucmp(v)
              return this.negative !== 0 ? -C | 0 : C
            }),
            (s.prototype.ucmp = function (v) {
              if (this.length > v.length) return 1
              if (this.length < v.length) return -1
              for (var C = 0, N = this.length - 1; N >= 0; N--) {
                var T = this.words[N] | 0,
                  S = v.words[N] | 0
                if (T !== S) {
                  T < S ? (C = -1) : T > S && (C = 1)
                  break
                }
              }
              return C
            }),
            (s.prototype.gtn = function (v) {
              return this.cmpn(v) === 1
            }),
            (s.prototype.gt = function (v) {
              return this.cmp(v) === 1
            }),
            (s.prototype.gten = function (v) {
              return this.cmpn(v) >= 0
            }),
            (s.prototype.gte = function (v) {
              return this.cmp(v) >= 0
            }),
            (s.prototype.ltn = function (v) {
              return this.cmpn(v) === -1
            }),
            (s.prototype.lt = function (v) {
              return this.cmp(v) === -1
            }),
            (s.prototype.lten = function (v) {
              return this.cmpn(v) <= 0
            }),
            (s.prototype.lte = function (v) {
              return this.cmp(v) <= 0
            }),
            (s.prototype.eqn = function (v) {
              return this.cmpn(v) === 0
            }),
            (s.prototype.eq = function (v) {
              return this.cmp(v) === 0
            }),
            (s.red = function (v) {
              return new j(v)
            }),
            (s.prototype.toRed = function (v) {
              return (
                r(!this.red, 'Already a number in reduction context'),
                r(this.negative === 0, 'red works only with positives'),
                v.convertTo(this)._forceRed(v)
              )
            }),
            (s.prototype.fromRed = function () {
              return (
                r(this.red, 'fromRed works only with numbers in reduction context'),
                this.red.convertFrom(this)
              )
            }),
            (s.prototype._forceRed = function (v) {
              return (this.red = v), this
            }),
            (s.prototype.forceRed = function (v) {
              return r(!this.red, 'Already a number in reduction context'), this._forceRed(v)
            }),
            (s.prototype.redAdd = function (v) {
              return r(this.red, 'redAdd works only with red numbers'), this.red.add(this, v)
            }),
            (s.prototype.redIAdd = function (v) {
              return r(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, v)
            }),
            (s.prototype.redSub = function (v) {
              return r(this.red, 'redSub works only with red numbers'), this.red.sub(this, v)
            }),
            (s.prototype.redISub = function (v) {
              return r(this.red, 'redISub works only with red numbers'), this.red.isub(this, v)
            }),
            (s.prototype.redShl = function (v) {
              return r(this.red, 'redShl works only with red numbers'), this.red.shl(this, v)
            }),
            (s.prototype.redMul = function (v) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, v),
                this.red.mul(this, v)
              )
            }),
            (s.prototype.redIMul = function (v) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, v),
                this.red.imul(this, v)
              )
            }),
            (s.prototype.redSqr = function () {
              return (
                r(this.red, 'redSqr works only with red numbers'),
                this.red._verify1(this),
                this.red.sqr(this)
              )
            }),
            (s.prototype.redISqr = function () {
              return (
                r(this.red, 'redISqr works only with red numbers'),
                this.red._verify1(this),
                this.red.isqr(this)
              )
            }),
            (s.prototype.redSqrt = function () {
              return (
                r(this.red, 'redSqrt works only with red numbers'),
                this.red._verify1(this),
                this.red.sqrt(this)
              )
            }),
            (s.prototype.redInvm = function () {
              return (
                r(this.red, 'redInvm works only with red numbers'),
                this.red._verify1(this),
                this.red.invm(this)
              )
            }),
            (s.prototype.redNeg = function () {
              return (
                r(this.red, 'redNeg works only with red numbers'),
                this.red._verify1(this),
                this.red.neg(this)
              )
            }),
            (s.prototype.redPow = function (v) {
              return (
                r(this.red && !v.red, 'redPow(normalNum)'),
                this.red._verify1(this),
                this.red.pow(this, v)
              )
            })
          var M = { k256: null, p224: null, p192: null, p25519: null }
          function $(L, v) {
            ;(this.name = L),
              (this.p = new s(v, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new s(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp())
          }
          ;($.prototype._tmp = function () {
            var v = new s(null)
            return (v.words = new Array(Math.ceil(this.n / 13))), v
          }),
            ($.prototype.ireduce = function (v) {
              var C = v,
                N
              do
                this.split(C, this.tmp),
                  (C = this.imulK(C)),
                  (C = C.iadd(this.tmp)),
                  (N = C.bitLength())
              while (N > this.n)
              var T = N < this.n ? -1 : C.ucmp(this.p)
              return (
                T === 0
                  ? ((C.words[0] = 0), (C.length = 1))
                  : T > 0
                    ? C.isub(this.p)
                    : C.strip !== void 0
                      ? C.strip()
                      : C._strip(),
                C
              )
            }),
            ($.prototype.split = function (v, C) {
              v.iushrn(this.n, 0, C)
            }),
            ($.prototype.imulK = function (v) {
              return v.imul(this.k)
            })
          function D() {
            $.call(
              this,
              'k256',
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
            )
          }
          i(D, $),
            (D.prototype.split = function (v, C) {
              for (var N = 4194303, T = Math.min(v.length, 9), S = 0; S < T; S++)
                C.words[S] = v.words[S]
              if (((C.length = T), v.length <= 9)) {
                ;(v.words[0] = 0), (v.length = 1)
                return
              }
              var k = v.words[9]
              for (C.words[C.length++] = k & N, S = 10; S < v.length; S++) {
                var F = v.words[S] | 0
                ;(v.words[S - 10] = ((F & N) << 4) | (k >>> 22)), (k = F)
              }
              ;(k >>>= 22),
                (v.words[S - 10] = k),
                k === 0 && v.length > 10 ? (v.length -= 10) : (v.length -= 9)
            }),
            (D.prototype.imulK = function (v) {
              ;(v.words[v.length] = 0), (v.words[v.length + 1] = 0), (v.length += 2)
              for (var C = 0, N = 0; N < v.length; N++) {
                var T = v.words[N] | 0
                ;(C += T * 977), (v.words[N] = C & 67108863), (C = T * 64 + ((C / 67108864) | 0))
              }
              return (
                v.words[v.length - 1] === 0 &&
                  (v.length--, v.words[v.length - 1] === 0 && v.length--),
                v
              )
            })
          function R() {
            $.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001')
          }
          i(R, $)
          function z() {
            $.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff')
          }
          i(z, $)
          function G() {
            $.call(
              this,
              '25519',
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
            )
          }
          i(G, $),
            (G.prototype.imulK = function (v) {
              for (var C = 0, N = 0; N < v.length; N++) {
                var T = (v.words[N] | 0) * 19 + C,
                  S = T & 67108863
                ;(T >>>= 26), (v.words[N] = S), (C = T)
              }
              return C !== 0 && (v.words[v.length++] = C), v
            }),
            (s._prime = function (v) {
              if (M[v]) return M[v]
              var C
              if (v === 'k256') C = new D()
              else if (v === 'p224') C = new R()
              else if (v === 'p192') C = new z()
              else if (v === 'p25519') C = new G()
              else throw new Error('Unknown prime ' + v)
              return (M[v] = C), C
            })
          function j(L) {
            if (typeof L == 'string') {
              var v = s._prime(L)
              ;(this.m = v.p), (this.prime = v)
            } else r(L.gtn(1), 'modulus must be greater than 1'), (this.m = L), (this.prime = null)
          }
          ;(j.prototype._verify1 = function (v) {
            r(v.negative === 0, 'red works only with positives'),
              r(v.red, 'red works only with red numbers')
          }),
            (j.prototype._verify2 = function (v, C) {
              r((v.negative | C.negative) === 0, 'red works only with positives'),
                r(v.red && v.red === C.red, 'red works only with red numbers')
            }),
            (j.prototype.imod = function (v) {
              return this.prime
                ? this.prime.ireduce(v)._forceRed(this)
                : v.umod(this.m)._forceRed(this)
            }),
            (j.prototype.neg = function (v) {
              return v.isZero() ? v.clone() : this.m.sub(v)._forceRed(this)
            }),
            (j.prototype.add = function (v, C) {
              this._verify2(v, C)
              var N = v.add(C)
              return N.cmp(this.m) >= 0 && N.isub(this.m), N._forceRed(this)
            }),
            (j.prototype.iadd = function (v, C) {
              this._verify2(v, C)
              var N = v.iadd(C)
              return N.cmp(this.m) >= 0 && N.isub(this.m), N
            }),
            (j.prototype.sub = function (v, C) {
              this._verify2(v, C)
              var N = v.sub(C)
              return N.cmpn(0) < 0 && N.iadd(this.m), N._forceRed(this)
            }),
            (j.prototype.isub = function (v, C) {
              this._verify2(v, C)
              var N = v.isub(C)
              return N.cmpn(0) < 0 && N.iadd(this.m), N
            }),
            (j.prototype.shl = function (v, C) {
              return this._verify1(v), this.imod(v.ushln(C))
            }),
            (j.prototype.imul = function (v, C) {
              return this._verify2(v, C), this.imod(v.imul(C))
            }),
            (j.prototype.mul = function (v, C) {
              return this._verify2(v, C), this.imod(v.mul(C))
            }),
            (j.prototype.isqr = function (v) {
              return this.imul(v, v.clone())
            }),
            (j.prototype.sqr = function (v) {
              return this.mul(v, v)
            }),
            (j.prototype.sqrt = function (v) {
              if (v.isZero()) return v.clone()
              var C = this.m.andln(3)
              if ((r(C % 2 === 1), C === 3)) {
                var N = this.m.add(new s(1)).iushrn(2)
                return this.pow(v, N)
              }
              for (var T = this.m.subn(1), S = 0; !T.isZero() && T.andln(1) === 0; )
                S++, T.iushrn(1)
              r(!T.isZero())
              var k = new s(1).toRed(this),
                F = k.redNeg(),
                P = this.m.subn(1).iushrn(1),
                w = this.m.bitLength()
              for (w = new s(2 * w * w).toRed(this); this.pow(w, P).cmp(F) !== 0; ) w.redIAdd(F)
              for (
                var B = this.pow(w, T),
                  Z = this.pow(v, T.addn(1).iushrn(1)),
                  ee = this.pow(v, T),
                  Y = S;
                ee.cmp(k) !== 0;

              ) {
                for (var se = ee, ce = 0; se.cmp(k) !== 0; ce++) se = se.redSqr()
                r(ce < Y)
                var we = this.pow(B, new s(1).iushln(Y - ce - 1))
                ;(Z = Z.redMul(we)), (B = we.redSqr()), (ee = ee.redMul(B)), (Y = ce)
              }
              return Z
            }),
            (j.prototype.invm = function (v) {
              var C = v._invmp(this.m)
              return C.negative !== 0 ? ((C.negative = 0), this.imod(C).redNeg()) : this.imod(C)
            }),
            (j.prototype.pow = function (v, C) {
              if (C.isZero()) return new s(1).toRed(this)
              if (C.cmpn(1) === 0) return v.clone()
              var N = 4,
                T = new Array(1 << N)
              ;(T[0] = new s(1).toRed(this)), (T[1] = v)
              for (var S = 2; S < T.length; S++) T[S] = this.mul(T[S - 1], v)
              var k = T[0],
                F = 0,
                P = 0,
                w = C.bitLength() % 26
              for (w === 0 && (w = 26), S = C.length - 1; S >= 0; S--) {
                for (var B = C.words[S], Z = w - 1; Z >= 0; Z--) {
                  var ee = (B >> Z) & 1
                  if ((k !== T[0] && (k = this.sqr(k)), ee === 0 && F === 0)) {
                    P = 0
                    continue
                  }
                  ;(F <<= 1),
                    (F |= ee),
                    P++,
                    !(P !== N && (S !== 0 || Z !== 0)) &&
                      ((k = this.mul(k, T[F])), (P = 0), (F = 0))
                }
                w = 26
              }
              return k
            }),
            (j.prototype.convertTo = function (v) {
              var C = v.umod(this.m)
              return C === v ? C.clone() : C
            }),
            (j.prototype.convertFrom = function (v) {
              var C = v.clone()
              return (C.red = null), C
            }),
            (s.mont = function (v) {
              return new V(v)
            })
          function V(L) {
            j.call(this, L),
              (this.shift = this.m.bitLength()),
              this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new s(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv))
          }
          i(V, j),
            (V.prototype.convertTo = function (v) {
              return this.imod(v.ushln(this.shift))
            }),
            (V.prototype.convertFrom = function (v) {
              var C = this.imod(v.mul(this.rinv))
              return (C.red = null), C
            }),
            (V.prototype.imul = function (v, C) {
              if (v.isZero() || C.isZero()) return (v.words[0] = 0), (v.length = 1), v
              var N = v.imul(C),
                T = N.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                S = N.isub(T).iushrn(this.shift),
                k = S
              return (
                S.cmp(this.m) >= 0 ? (k = S.isub(this.m)) : S.cmpn(0) < 0 && (k = S.iadd(this.m)),
                k._forceRed(this)
              )
            }),
            (V.prototype.mul = function (v, C) {
              if (v.isZero() || C.isZero()) return new s(0)._forceRed(this)
              var N = v.mul(C),
                T = N.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                S = N.isub(T).iushrn(this.shift),
                k = S
              return (
                S.cmp(this.m) >= 0 ? (k = S.isub(this.m)) : S.cmpn(0) < 0 && (k = S.iadd(this.m)),
                k._forceRed(this)
              )
            }),
            (V.prototype.invm = function (v) {
              var C = this.imod(v._invmp(this.m).mul(this.r2))
              return C._forceRed(this)
            })
        })(t, b$)
      })(Tg)),
    Tg.exports
  )
}
var $v, zS
function wu() {
  if (zS) return $v
  ;(zS = 1), ($v = t)
  function t(e, n) {
    if (!e) throw new Error(n || 'Assertion failed')
  }
  return (
    (t.equal = function (n, r, i) {
      if (n != r) throw new Error(i || 'Assertion failed: ' + n + ' != ' + r)
    }),
    $v
  )
}
var Fv = {},
  qS
function lx() {
  return (
    qS ||
      ((qS = 1),
      (function (t) {
        var e = t
        function n(s, c) {
          if (Array.isArray(s)) return s.slice()
          if (!s) return []
          var u = []
          if (typeof s != 'string') {
            for (var f = 0; f < s.length; f++) u[f] = s[f] | 0
            return u
          }
          if (c === 'hex') {
            ;(s = s.replace(/[^a-z0-9]+/gi, '')), s.length % 2 !== 0 && (s = '0' + s)
            for (var f = 0; f < s.length; f += 2) u.push(parseInt(s[f] + s[f + 1], 16))
          } else
            for (var f = 0; f < s.length; f++) {
              var d = s.charCodeAt(f),
                p = d >> 8,
                g = d & 255
              p ? u.push(p, g) : u.push(g)
            }
          return u
        }
        e.toArray = n
        function r(s) {
          return s.length === 1 ? '0' + s : s
        }
        e.zero2 = r
        function i(s) {
          for (var c = '', u = 0; u < s.length; u++) c += r(s[u].toString(16))
          return c
        }
        ;(e.toHex = i),
          (e.encode = function (c, u) {
            return u === 'hex' ? i(c) : c
          })
      })(Fv)),
    Fv
  )
}
var HS
function Hi() {
  return (
    HS ||
      ((HS = 1),
      (function (t) {
        var e = t,
          n = Fa(),
          r = wu(),
          i = lx()
        ;(e.assert = r),
          (e.toArray = i.toArray),
          (e.zero2 = i.zero2),
          (e.toHex = i.toHex),
          (e.encode = i.encode)
        function s(p, g, m) {
          var y = new Array(Math.max(p.bitLength(), m) + 1),
            A
          for (A = 0; A < y.length; A += 1) y[A] = 0
          var E = 1 << (g + 1),
            x = p.clone()
          for (A = 0; A < y.length; A++) {
            var O,
              I = x.andln(E - 1)
            x.isOdd() ? (I > (E >> 1) - 1 ? (O = (E >> 1) - I) : (O = I), x.isubn(O)) : (O = 0),
              (y[A] = O),
              x.iushrn(1)
          }
          return y
        }
        e.getNAF = s
        function c(p, g) {
          var m = [[], []]
          ;(p = p.clone()), (g = g.clone())
          for (var y = 0, A = 0, E; p.cmpn(-y) > 0 || g.cmpn(-A) > 0; ) {
            var x = (p.andln(3) + y) & 3,
              O = (g.andln(3) + A) & 3
            x === 3 && (x = -1), O === 3 && (O = -1)
            var I
            ;(x & 1) === 0
              ? (I = 0)
              : ((E = (p.andln(7) + y) & 7), (E === 3 || E === 5) && O === 2 ? (I = -x) : (I = x)),
              m[0].push(I)
            var M
            ;(O & 1) === 0
              ? (M = 0)
              : ((E = (g.andln(7) + A) & 7), (E === 3 || E === 5) && x === 2 ? (M = -O) : (M = O)),
              m[1].push(M),
              2 * y === I + 1 && (y = 1 - y),
              2 * A === M + 1 && (A = 1 - A),
              p.iushrn(1),
              g.iushrn(1)
          }
          return m
        }
        e.getJSF = c
        function u(p, g, m) {
          var y = '_' + g
          p.prototype[g] = function () {
            return this[y] !== void 0 ? this[y] : (this[y] = m.call(this))
          }
        }
        e.cachedProperty = u
        function f(p) {
          return typeof p == 'string' ? e.toArray(p, 'hex') : p
        }
        e.parseBytes = f
        function d(p) {
          return new n(p, 'hex', 'le')
        }
        e.intFromLE = d
      })(Lv)),
    Lv
  )
}
var ng = { exports: {} },
  GS
function dx() {
  if (GS) return ng.exports
  GS = 1
  var t
  ng.exports = function (i) {
    return t || (t = new e(null)), t.generate(i)
  }
  function e(r) {
    this.rand = r
  }
  if (
    ((ng.exports.Rand = e),
    (e.prototype.generate = function (i) {
      return this._rand(i)
    }),
    (e.prototype._rand = function (i) {
      if (this.rand.getBytes) return this.rand.getBytes(i)
      for (var s = new Uint8Array(i), c = 0; c < s.length; c++) s[c] = this.rand.getByte()
      return s
    }),
    typeof self == 'object')
  )
    self.crypto && self.crypto.getRandomValues
      ? (e.prototype._rand = function (i) {
          var s = new Uint8Array(i)
          return self.crypto.getRandomValues(s), s
        })
      : self.msCrypto && self.msCrypto.getRandomValues
        ? (e.prototype._rand = function (i) {
            var s = new Uint8Array(i)
            return self.msCrypto.getRandomValues(s), s
          })
        : typeof window == 'object' &&
          (e.prototype._rand = function () {
            throw new Error('Not implemented yet')
          })
  else
    try {
      var n = ux
      if (typeof n.randomBytes != 'function') throw new Error('Not supported')
      e.prototype._rand = function (i) {
        return n.randomBytes(i)
      }
    } catch {}
  return ng.exports
}
var jv = {},
  zv,
  VS
function Pm() {
  if (VS) return zv
  VS = 1
  var t = Fa(),
    e = Hi(),
    n = e.getNAF,
    r = e.getJSF,
    i = e.assert
  function s(u, f) {
    ;(this.type = u),
      (this.p = new t(f.p, 16)),
      (this.red = f.prime ? t.red(f.prime) : t.mont(this.p)),
      (this.zero = new t(0).toRed(this.red)),
      (this.one = new t(1).toRed(this.red)),
      (this.two = new t(2).toRed(this.red)),
      (this.n = f.n && new t(f.n, 16)),
      (this.g = f.g && this.pointFromJSON(f.g, f.gRed)),
      (this._wnafT1 = new Array(4)),
      (this._wnafT2 = new Array(4)),
      (this._wnafT3 = new Array(4)),
      (this._wnafT4 = new Array(4)),
      (this._bitLength = this.n ? this.n.bitLength() : 0)
    var d = this.n && this.p.div(this.n)
    !d || d.cmpn(100) > 0
      ? (this.redN = null)
      : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)))
  }
  ;(zv = s),
    (s.prototype.point = function () {
      throw new Error('Not implemented')
    }),
    (s.prototype.validate = function () {
      throw new Error('Not implemented')
    }),
    (s.prototype._fixedNafMul = function (f, d) {
      i(f.precomputed)
      var p = f._getDoubles(),
        g = n(d, 1, this._bitLength),
        m = (1 << (p.step + 1)) - (p.step % 2 === 0 ? 2 : 1)
      m /= 3
      var y = [],
        A,
        E
      for (A = 0; A < g.length; A += p.step) {
        E = 0
        for (var x = A + p.step - 1; x >= A; x--) E = (E << 1) + g[x]
        y.push(E)
      }
      for (
        var O = this.jpoint(null, null, null), I = this.jpoint(null, null, null), M = m;
        M > 0;
        M--
      ) {
        for (A = 0; A < y.length; A++)
          (E = y[A]),
            E === M
              ? (I = I.mixedAdd(p.points[A]))
              : E === -M && (I = I.mixedAdd(p.points[A].neg()))
        O = O.add(I)
      }
      return O.toP()
    }),
    (s.prototype._wnafMul = function (f, d) {
      var p = 4,
        g = f._getNAFPoints(p)
      p = g.wnd
      for (
        var m = g.points,
          y = n(d, p, this._bitLength),
          A = this.jpoint(null, null, null),
          E = y.length - 1;
        E >= 0;
        E--
      ) {
        for (var x = 0; E >= 0 && y[E] === 0; E--) x++
        if ((E >= 0 && x++, (A = A.dblp(x)), E < 0)) break
        var O = y[E]
        i(O !== 0),
          f.type === 'affine'
            ? O > 0
              ? (A = A.mixedAdd(m[(O - 1) >> 1]))
              : (A = A.mixedAdd(m[(-O - 1) >> 1].neg()))
            : O > 0
              ? (A = A.add(m[(O - 1) >> 1]))
              : (A = A.add(m[(-O - 1) >> 1].neg()))
      }
      return f.type === 'affine' ? A.toP() : A
    }),
    (s.prototype._wnafMulAdd = function (f, d, p, g, m) {
      var y = this._wnafT1,
        A = this._wnafT2,
        E = this._wnafT3,
        x = 0,
        O,
        I,
        M
      for (O = 0; O < g; O++) {
        M = d[O]
        var $ = M._getNAFPoints(f)
        ;(y[O] = $.wnd), (A[O] = $.points)
      }
      for (O = g - 1; O >= 1; O -= 2) {
        var D = O - 1,
          R = O
        if (y[D] !== 1 || y[R] !== 1) {
          ;(E[D] = n(p[D], y[D], this._bitLength)),
            (E[R] = n(p[R], y[R], this._bitLength)),
            (x = Math.max(E[D].length, x)),
            (x = Math.max(E[R].length, x))
          continue
        }
        var z = [d[D], null, null, d[R]]
        d[D].y.cmp(d[R].y) === 0
          ? ((z[1] = d[D].add(d[R])), (z[2] = d[D].toJ().mixedAdd(d[R].neg())))
          : d[D].y.cmp(d[R].y.redNeg()) === 0
            ? ((z[1] = d[D].toJ().mixedAdd(d[R])), (z[2] = d[D].add(d[R].neg())))
            : ((z[1] = d[D].toJ().mixedAdd(d[R])), (z[2] = d[D].toJ().mixedAdd(d[R].neg())))
        var G = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
          j = r(p[D], p[R])
        for (
          x = Math.max(j[0].length, x), E[D] = new Array(x), E[R] = new Array(x), I = 0;
          I < x;
          I++
        ) {
          var V = j[0][I] | 0,
            L = j[1][I] | 0
          ;(E[D][I] = G[(V + 1) * 3 + (L + 1)]), (E[R][I] = 0), (A[D] = z)
        }
      }
      var v = this.jpoint(null, null, null),
        C = this._wnafT4
      for (O = x; O >= 0; O--) {
        for (var N = 0; O >= 0; ) {
          var T = !0
          for (I = 0; I < g; I++) (C[I] = E[I][O] | 0), C[I] !== 0 && (T = !1)
          if (!T) break
          N++, O--
        }
        if ((O >= 0 && N++, (v = v.dblp(N)), O < 0)) break
        for (I = 0; I < g; I++) {
          var S = C[I]
          S !== 0 &&
            (S > 0 ? (M = A[I][(S - 1) >> 1]) : S < 0 && (M = A[I][(-S - 1) >> 1].neg()),
            M.type === 'affine' ? (v = v.mixedAdd(M)) : (v = v.add(M)))
        }
      }
      for (O = 0; O < g; O++) A[O] = null
      return m ? v : v.toP()
    })
  function c(u, f) {
    ;(this.curve = u), (this.type = f), (this.precomputed = null)
  }
  return (
    (s.BasePoint = c),
    (c.prototype.eq = function () {
      throw new Error('Not implemented')
    }),
    (c.prototype.validate = function () {
      return this.curve.validate(this)
    }),
    (s.prototype.decodePoint = function (f, d) {
      f = e.toArray(f, d)
      var p = this.p.byteLength()
      if ((f[0] === 4 || f[0] === 6 || f[0] === 7) && f.length - 1 === 2 * p) {
        f[0] === 6 ? i(f[f.length - 1] % 2 === 0) : f[0] === 7 && i(f[f.length - 1] % 2 === 1)
        var g = this.point(f.slice(1, 1 + p), f.slice(1 + p, 1 + 2 * p))
        return g
      } else if ((f[0] === 2 || f[0] === 3) && f.length - 1 === p)
        return this.pointFromX(f.slice(1, 1 + p), f[0] === 3)
      throw new Error('Unknown point format')
    }),
    (c.prototype.encodeCompressed = function (f) {
      return this.encode(f, !0)
    }),
    (c.prototype._encode = function (f) {
      var d = this.curve.p.byteLength(),
        p = this.getX().toArray('be', d)
      return f
        ? [this.getY().isEven() ? 2 : 3].concat(p)
        : [4].concat(p, this.getY().toArray('be', d))
    }),
    (c.prototype.encode = function (f, d) {
      return e.encode(this._encode(d), f)
    }),
    (c.prototype.precompute = function (f) {
      if (this.precomputed) return this
      var d = { doubles: null, naf: null, beta: null }
      return (
        (d.naf = this._getNAFPoints(8)),
        (d.doubles = this._getDoubles(4, f)),
        (d.beta = this._getBeta()),
        (this.precomputed = d),
        this
      )
    }),
    (c.prototype._hasDoubles = function (f) {
      if (!this.precomputed) return !1
      var d = this.precomputed.doubles
      return d ? d.points.length >= Math.ceil((f.bitLength() + 1) / d.step) : !1
    }),
    (c.prototype._getDoubles = function (f, d) {
      if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles
      for (var p = [this], g = this, m = 0; m < d; m += f) {
        for (var y = 0; y < f; y++) g = g.dbl()
        p.push(g)
      }
      return { step: f, points: p }
    }),
    (c.prototype._getNAFPoints = function (f) {
      if (this.precomputed && this.precomputed.naf) return this.precomputed.naf
      for (var d = [this], p = (1 << f) - 1, g = p === 1 ? null : this.dbl(), m = 1; m < p; m++)
        d[m] = d[m - 1].add(g)
      return { wnd: f, points: d }
    }),
    (c.prototype._getBeta = function () {
      return null
    }),
    (c.prototype.dblp = function (f) {
      for (var d = this, p = 0; p < f; p++) d = d.dbl()
      return d
    }),
    zv
  )
}
var rg = { exports: {} },
  KS
function Mm() {
  return (
    KS ||
      ((KS = 1),
      typeof Object.create == 'function'
        ? (rg.exports = function (e, n) {
            n &&
              ((e.super_ = n),
              (e.prototype = Object.create(n.prototype, {
                constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 }
              })))
          })
        : (rg.exports = function (e, n) {
            if (n) {
              e.super_ = n
              var r = function () {}
              ;(r.prototype = n.prototype), (e.prototype = new r()), (e.prototype.constructor = e)
            }
          })),
    rg.exports
  )
}
var qv, WS
function y$() {
  if (WS) return qv
  WS = 1
  var t = Hi(),
    e = Fa(),
    n = Mm(),
    r = Pm(),
    i = t.assert
  function s(f) {
    r.call(this, 'short', f),
      (this.a = new e(f.a, 16).toRed(this.red)),
      (this.b = new e(f.b, 16).toRed(this.red)),
      (this.tinv = this.two.redInvm()),
      (this.zeroA = this.a.fromRed().cmpn(0) === 0),
      (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
      (this.endo = this._getEndomorphism(f)),
      (this._endoWnafT1 = new Array(4)),
      (this._endoWnafT2 = new Array(4))
  }
  n(s, r),
    (qv = s),
    (s.prototype._getEndomorphism = function (d) {
      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var p, g
        if (d.beta) p = new e(d.beta, 16).toRed(this.red)
        else {
          var m = this._getEndoRoots(this.p)
          ;(p = m[0].cmp(m[1]) < 0 ? m[0] : m[1]), (p = p.toRed(this.red))
        }
        if (d.lambda) g = new e(d.lambda, 16)
        else {
          var y = this._getEndoRoots(this.n)
          this.g.mul(y[0]).x.cmp(this.g.x.redMul(p)) === 0
            ? (g = y[0])
            : ((g = y[1]), i(this.g.mul(g).x.cmp(this.g.x.redMul(p)) === 0))
        }
        var A
        return (
          d.basis
            ? (A = d.basis.map(function (E) {
                return { a: new e(E.a, 16), b: new e(E.b, 16) }
              }))
            : (A = this._getEndoBasis(g)),
          { beta: p, lambda: g, basis: A }
        )
      }
    }),
    (s.prototype._getEndoRoots = function (d) {
      var p = d === this.p ? this.red : e.mont(d),
        g = new e(2).toRed(p).redInvm(),
        m = g.redNeg(),
        y = new e(3).toRed(p).redNeg().redSqrt().redMul(g),
        A = m.redAdd(y).fromRed(),
        E = m.redSub(y).fromRed()
      return [A, E]
    }),
    (s.prototype._getEndoBasis = function (d) {
      for (
        var p = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
          g = d,
          m = this.n.clone(),
          y = new e(1),
          A = new e(0),
          E = new e(0),
          x = new e(1),
          O,
          I,
          M,
          $,
          D,
          R,
          z,
          G = 0,
          j,
          V;
        g.cmpn(0) !== 0;

      ) {
        var L = m.div(g)
        ;(j = m.sub(L.mul(g))), (V = E.sub(L.mul(y)))
        var v = x.sub(L.mul(A))
        if (!M && j.cmp(p) < 0) (O = z.neg()), (I = y), (M = j.neg()), ($ = V)
        else if (M && ++G === 2) break
        ;(z = j), (m = g), (g = j), (E = y), (y = V), (x = A), (A = v)
      }
      ;(D = j.neg()), (R = V)
      var C = M.sqr().add($.sqr()),
        N = D.sqr().add(R.sqr())
      return (
        N.cmp(C) >= 0 && ((D = O), (R = I)),
        M.negative && ((M = M.neg()), ($ = $.neg())),
        D.negative && ((D = D.neg()), (R = R.neg())),
        [
          { a: M, b: $ },
          { a: D, b: R }
        ]
      )
    }),
    (s.prototype._endoSplit = function (d) {
      var p = this.endo.basis,
        g = p[0],
        m = p[1],
        y = m.b.mul(d).divRound(this.n),
        A = g.b.neg().mul(d).divRound(this.n),
        E = y.mul(g.a),
        x = A.mul(m.a),
        O = y.mul(g.b),
        I = A.mul(m.b),
        M = d.sub(E).sub(x),
        $ = O.add(I).neg()
      return { k1: M, k2: $ }
    }),
    (s.prototype.pointFromX = function (d, p) {
      ;(d = new e(d, 16)), d.red || (d = d.toRed(this.red))
      var g = d.redSqr().redMul(d).redIAdd(d.redMul(this.a)).redIAdd(this.b),
        m = g.redSqrt()
      if (m.redSqr().redSub(g).cmp(this.zero) !== 0) throw new Error('invalid point')
      var y = m.fromRed().isOdd()
      return ((p && !y) || (!p && y)) && (m = m.redNeg()), this.point(d, m)
    }),
    (s.prototype.validate = function (d) {
      if (d.inf) return !0
      var p = d.x,
        g = d.y,
        m = this.a.redMul(p),
        y = p.redSqr().redMul(p).redIAdd(m).redIAdd(this.b)
      return g.redSqr().redISub(y).cmpn(0) === 0
    }),
    (s.prototype._endoWnafMulAdd = function (d, p, g) {
      for (var m = this._endoWnafT1, y = this._endoWnafT2, A = 0; A < d.length; A++) {
        var E = this._endoSplit(p[A]),
          x = d[A],
          O = x._getBeta()
        E.k1.negative && (E.k1.ineg(), (x = x.neg(!0))),
          E.k2.negative && (E.k2.ineg(), (O = O.neg(!0))),
          (m[A * 2] = x),
          (m[A * 2 + 1] = O),
          (y[A * 2] = E.k1),
          (y[A * 2 + 1] = E.k2)
      }
      for (var I = this._wnafMulAdd(1, m, y, A * 2, g), M = 0; M < A * 2; M++)
        (m[M] = null), (y[M] = null)
      return I
    })
  function c(f, d, p, g) {
    r.BasePoint.call(this, f, 'affine'),
      d === null && p === null
        ? ((this.x = null), (this.y = null), (this.inf = !0))
        : ((this.x = new e(d, 16)),
          (this.y = new e(p, 16)),
          g && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
          this.x.red || (this.x = this.x.toRed(this.curve.red)),
          this.y.red || (this.y = this.y.toRed(this.curve.red)),
          (this.inf = !1))
  }
  n(c, r.BasePoint),
    (s.prototype.point = function (d, p, g) {
      return new c(this, d, p, g)
    }),
    (s.prototype.pointFromJSON = function (d, p) {
      return c.fromJSON(this, d, p)
    }),
    (c.prototype._getBeta = function () {
      if (this.curve.endo) {
        var d = this.precomputed
        if (d && d.beta) return d.beta
        var p = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y)
        if (d) {
          var g = this.curve,
            m = function (y) {
              return g.point(y.x.redMul(g.endo.beta), y.y)
            }
          ;(d.beta = p),
            (p.precomputed = {
              beta: null,
              naf: d.naf && { wnd: d.naf.wnd, points: d.naf.points.map(m) },
              doubles: d.doubles && { step: d.doubles.step, points: d.doubles.points.map(m) }
            })
        }
        return p
      }
    }),
    (c.prototype.toJSON = function () {
      return this.precomputed
        ? [
            this.x,
            this.y,
            this.precomputed && {
              doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
              },
              naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
              }
            }
          ]
        : [this.x, this.y]
    }),
    (c.fromJSON = function (d, p, g) {
      typeof p == 'string' && (p = JSON.parse(p))
      var m = d.point(p[0], p[1], g)
      if (!p[2]) return m
      function y(E) {
        return d.point(E[0], E[1], g)
      }
      var A = p[2]
      return (
        (m.precomputed = {
          beta: null,
          doubles: A.doubles && {
            step: A.doubles.step,
            points: [m].concat(A.doubles.points.map(y))
          },
          naf: A.naf && { wnd: A.naf.wnd, points: [m].concat(A.naf.points.map(y)) }
        }),
        m
      )
    }),
    (c.prototype.inspect = function () {
      return this.isInfinity()
        ? '<EC Point Infinity>'
        : '<EC Point x: ' +
            this.x.fromRed().toString(16, 2) +
            ' y: ' +
            this.y.fromRed().toString(16, 2) +
            '>'
    }),
    (c.prototype.isInfinity = function () {
      return this.inf
    }),
    (c.prototype.add = function (d) {
      if (this.inf) return d
      if (d.inf) return this
      if (this.eq(d)) return this.dbl()
      if (this.neg().eq(d)) return this.curve.point(null, null)
      if (this.x.cmp(d.x) === 0) return this.curve.point(null, null)
      var p = this.y.redSub(d.y)
      p.cmpn(0) !== 0 && (p = p.redMul(this.x.redSub(d.x).redInvm()))
      var g = p.redSqr().redISub(this.x).redISub(d.x),
        m = p.redMul(this.x.redSub(g)).redISub(this.y)
      return this.curve.point(g, m)
    }),
    (c.prototype.dbl = function () {
      if (this.inf) return this
      var d = this.y.redAdd(this.y)
      if (d.cmpn(0) === 0) return this.curve.point(null, null)
      var p = this.curve.a,
        g = this.x.redSqr(),
        m = d.redInvm(),
        y = g.redAdd(g).redIAdd(g).redIAdd(p).redMul(m),
        A = y.redSqr().redISub(this.x.redAdd(this.x)),
        E = y.redMul(this.x.redSub(A)).redISub(this.y)
      return this.curve.point(A, E)
    }),
    (c.prototype.getX = function () {
      return this.x.fromRed()
    }),
    (c.prototype.getY = function () {
      return this.y.fromRed()
    }),
    (c.prototype.mul = function (d) {
      return (
        (d = new e(d, 16)),
        this.isInfinity()
          ? this
          : this._hasDoubles(d)
            ? this.curve._fixedNafMul(this, d)
            : this.curve.endo
              ? this.curve._endoWnafMulAdd([this], [d])
              : this.curve._wnafMul(this, d)
      )
    }),
    (c.prototype.mulAdd = function (d, p, g) {
      var m = [this, p],
        y = [d, g]
      return this.curve.endo ? this.curve._endoWnafMulAdd(m, y) : this.curve._wnafMulAdd(1, m, y, 2)
    }),
    (c.prototype.jmulAdd = function (d, p, g) {
      var m = [this, p],
        y = [d, g]
      return this.curve.endo
        ? this.curve._endoWnafMulAdd(m, y, !0)
        : this.curve._wnafMulAdd(1, m, y, 2, !0)
    }),
    (c.prototype.eq = function (d) {
      return (
        this === d ||
        (this.inf === d.inf && (this.inf || (this.x.cmp(d.x) === 0 && this.y.cmp(d.y) === 0)))
      )
    }),
    (c.prototype.neg = function (d) {
      if (this.inf) return this
      var p = this.curve.point(this.x, this.y.redNeg())
      if (d && this.precomputed) {
        var g = this.precomputed,
          m = function (y) {
            return y.neg()
          }
        p.precomputed = {
          naf: g.naf && { wnd: g.naf.wnd, points: g.naf.points.map(m) },
          doubles: g.doubles && { step: g.doubles.step, points: g.doubles.points.map(m) }
        }
      }
      return p
    }),
    (c.prototype.toJ = function () {
      if (this.inf) return this.curve.jpoint(null, null, null)
      var d = this.curve.jpoint(this.x, this.y, this.curve.one)
      return d
    })
  function u(f, d, p, g) {
    r.BasePoint.call(this, f, 'jacobian'),
      d === null && p === null && g === null
        ? ((this.x = this.curve.one), (this.y = this.curve.one), (this.z = new e(0)))
        : ((this.x = new e(d, 16)), (this.y = new e(p, 16)), (this.z = new e(g, 16))),
      this.x.red || (this.x = this.x.toRed(this.curve.red)),
      this.y.red || (this.y = this.y.toRed(this.curve.red)),
      this.z.red || (this.z = this.z.toRed(this.curve.red)),
      (this.zOne = this.z === this.curve.one)
  }
  return (
    n(u, r.BasePoint),
    (s.prototype.jpoint = function (d, p, g) {
      return new u(this, d, p, g)
    }),
    (u.prototype.toP = function () {
      if (this.isInfinity()) return this.curve.point(null, null)
      var d = this.z.redInvm(),
        p = d.redSqr(),
        g = this.x.redMul(p),
        m = this.y.redMul(p).redMul(d)
      return this.curve.point(g, m)
    }),
    (u.prototype.neg = function () {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
    }),
    (u.prototype.add = function (d) {
      if (this.isInfinity()) return d
      if (d.isInfinity()) return this
      var p = d.z.redSqr(),
        g = this.z.redSqr(),
        m = this.x.redMul(p),
        y = d.x.redMul(g),
        A = this.y.redMul(p.redMul(d.z)),
        E = d.y.redMul(g.redMul(this.z)),
        x = m.redSub(y),
        O = A.redSub(E)
      if (x.cmpn(0) === 0) return O.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl()
      var I = x.redSqr(),
        M = I.redMul(x),
        $ = m.redMul(I),
        D = O.redSqr().redIAdd(M).redISub($).redISub($),
        R = O.redMul($.redISub(D)).redISub(A.redMul(M)),
        z = this.z.redMul(d.z).redMul(x)
      return this.curve.jpoint(D, R, z)
    }),
    (u.prototype.mixedAdd = function (d) {
      if (this.isInfinity()) return d.toJ()
      if (d.isInfinity()) return this
      var p = this.z.redSqr(),
        g = this.x,
        m = d.x.redMul(p),
        y = this.y,
        A = d.y.redMul(p).redMul(this.z),
        E = g.redSub(m),
        x = y.redSub(A)
      if (E.cmpn(0) === 0) return x.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl()
      var O = E.redSqr(),
        I = O.redMul(E),
        M = g.redMul(O),
        $ = x.redSqr().redIAdd(I).redISub(M).redISub(M),
        D = x.redMul(M.redISub($)).redISub(y.redMul(I)),
        R = this.z.redMul(E)
      return this.curve.jpoint($, D, R)
    }),
    (u.prototype.dblp = function (d) {
      if (d === 0) return this
      if (this.isInfinity()) return this
      if (!d) return this.dbl()
      var p
      if (this.curve.zeroA || this.curve.threeA) {
        var g = this
        for (p = 0; p < d; p++) g = g.dbl()
        return g
      }
      var m = this.curve.a,
        y = this.curve.tinv,
        A = this.x,
        E = this.y,
        x = this.z,
        O = x.redSqr().redSqr(),
        I = E.redAdd(E)
      for (p = 0; p < d; p++) {
        var M = A.redSqr(),
          $ = I.redSqr(),
          D = $.redSqr(),
          R = M.redAdd(M).redIAdd(M).redIAdd(m.redMul(O)),
          z = A.redMul($),
          G = R.redSqr().redISub(z.redAdd(z)),
          j = z.redISub(G),
          V = R.redMul(j)
        V = V.redIAdd(V).redISub(D)
        var L = I.redMul(x)
        p + 1 < d && (O = O.redMul(D)), (A = G), (x = L), (I = V)
      }
      return this.curve.jpoint(A, I.redMul(y), x)
    }),
    (u.prototype.dbl = function () {
      return this.isInfinity()
        ? this
        : this.curve.zeroA
          ? this._zeroDbl()
          : this.curve.threeA
            ? this._threeDbl()
            : this._dbl()
    }),
    (u.prototype._zeroDbl = function () {
      var d, p, g
      if (this.zOne) {
        var m = this.x.redSqr(),
          y = this.y.redSqr(),
          A = y.redSqr(),
          E = this.x.redAdd(y).redSqr().redISub(m).redISub(A)
        E = E.redIAdd(E)
        var x = m.redAdd(m).redIAdd(m),
          O = x.redSqr().redISub(E).redISub(E),
          I = A.redIAdd(A)
        ;(I = I.redIAdd(I)),
          (I = I.redIAdd(I)),
          (d = O),
          (p = x.redMul(E.redISub(O)).redISub(I)),
          (g = this.y.redAdd(this.y))
      } else {
        var M = this.x.redSqr(),
          $ = this.y.redSqr(),
          D = $.redSqr(),
          R = this.x.redAdd($).redSqr().redISub(M).redISub(D)
        R = R.redIAdd(R)
        var z = M.redAdd(M).redIAdd(M),
          G = z.redSqr(),
          j = D.redIAdd(D)
        ;(j = j.redIAdd(j)),
          (j = j.redIAdd(j)),
          (d = G.redISub(R).redISub(R)),
          (p = z.redMul(R.redISub(d)).redISub(j)),
          (g = this.y.redMul(this.z)),
          (g = g.redIAdd(g))
      }
      return this.curve.jpoint(d, p, g)
    }),
    (u.prototype._threeDbl = function () {
      var d, p, g
      if (this.zOne) {
        var m = this.x.redSqr(),
          y = this.y.redSqr(),
          A = y.redSqr(),
          E = this.x.redAdd(y).redSqr().redISub(m).redISub(A)
        E = E.redIAdd(E)
        var x = m.redAdd(m).redIAdd(m).redIAdd(this.curve.a),
          O = x.redSqr().redISub(E).redISub(E)
        d = O
        var I = A.redIAdd(A)
        ;(I = I.redIAdd(I)),
          (I = I.redIAdd(I)),
          (p = x.redMul(E.redISub(O)).redISub(I)),
          (g = this.y.redAdd(this.y))
      } else {
        var M = this.z.redSqr(),
          $ = this.y.redSqr(),
          D = this.x.redMul($),
          R = this.x.redSub(M).redMul(this.x.redAdd(M))
        R = R.redAdd(R).redIAdd(R)
        var z = D.redIAdd(D)
        z = z.redIAdd(z)
        var G = z.redAdd(z)
        ;(d = R.redSqr().redISub(G)), (g = this.y.redAdd(this.z).redSqr().redISub($).redISub(M))
        var j = $.redSqr()
        ;(j = j.redIAdd(j)),
          (j = j.redIAdd(j)),
          (j = j.redIAdd(j)),
          (p = R.redMul(z.redISub(d)).redISub(j))
      }
      return this.curve.jpoint(d, p, g)
    }),
    (u.prototype._dbl = function () {
      var d = this.curve.a,
        p = this.x,
        g = this.y,
        m = this.z,
        y = m.redSqr().redSqr(),
        A = p.redSqr(),
        E = g.redSqr(),
        x = A.redAdd(A).redIAdd(A).redIAdd(d.redMul(y)),
        O = p.redAdd(p)
      O = O.redIAdd(O)
      var I = O.redMul(E),
        M = x.redSqr().redISub(I.redAdd(I)),
        $ = I.redISub(M),
        D = E.redSqr()
      ;(D = D.redIAdd(D)), (D = D.redIAdd(D)), (D = D.redIAdd(D))
      var R = x.redMul($).redISub(D),
        z = g.redAdd(g).redMul(m)
      return this.curve.jpoint(M, R, z)
    }),
    (u.prototype.trpl = function () {
      if (!this.curve.zeroA) return this.dbl().add(this)
      var d = this.x.redSqr(),
        p = this.y.redSqr(),
        g = this.z.redSqr(),
        m = p.redSqr(),
        y = d.redAdd(d).redIAdd(d),
        A = y.redSqr(),
        E = this.x.redAdd(p).redSqr().redISub(d).redISub(m)
      ;(E = E.redIAdd(E)), (E = E.redAdd(E).redIAdd(E)), (E = E.redISub(A))
      var x = E.redSqr(),
        O = m.redIAdd(m)
      ;(O = O.redIAdd(O)), (O = O.redIAdd(O)), (O = O.redIAdd(O))
      var I = y.redIAdd(E).redSqr().redISub(A).redISub(x).redISub(O),
        M = p.redMul(I)
      ;(M = M.redIAdd(M)), (M = M.redIAdd(M))
      var $ = this.x.redMul(x).redISub(M)
      ;($ = $.redIAdd($)), ($ = $.redIAdd($))
      var D = this.y.redMul(I.redMul(O.redISub(I)).redISub(E.redMul(x)))
      ;(D = D.redIAdd(D)), (D = D.redIAdd(D)), (D = D.redIAdd(D))
      var R = this.z.redAdd(E).redSqr().redISub(g).redISub(x)
      return this.curve.jpoint($, D, R)
    }),
    (u.prototype.mul = function (d, p) {
      return (d = new e(d, p)), this.curve._wnafMul(this, d)
    }),
    (u.prototype.eq = function (d) {
      if (d.type === 'affine') return this.eq(d.toJ())
      if (this === d) return !0
      var p = this.z.redSqr(),
        g = d.z.redSqr()
      if (this.x.redMul(g).redISub(d.x.redMul(p)).cmpn(0) !== 0) return !1
      var m = p.redMul(this.z),
        y = g.redMul(d.z)
      return this.y.redMul(y).redISub(d.y.redMul(m)).cmpn(0) === 0
    }),
    (u.prototype.eqXToP = function (d) {
      var p = this.z.redSqr(),
        g = d.toRed(this.curve.red).redMul(p)
      if (this.x.cmp(g) === 0) return !0
      for (var m = d.clone(), y = this.curve.redN.redMul(p); ; ) {
        if ((m.iadd(this.curve.n), m.cmp(this.curve.p) >= 0)) return !1
        if ((g.redIAdd(y), this.x.cmp(g) === 0)) return !0
      }
    }),
    (u.prototype.inspect = function () {
      return this.isInfinity()
        ? '<EC JPoint Infinity>'
        : '<EC JPoint x: ' +
            this.x.toString(16, 2) +
            ' y: ' +
            this.y.toString(16, 2) +
            ' z: ' +
            this.z.toString(16, 2) +
            '>'
    }),
    (u.prototype.isInfinity = function () {
      return this.z.cmpn(0) === 0
    }),
    qv
  )
}
var Hv, QS
function v$() {
  if (QS) return Hv
  QS = 1
  var t = Fa(),
    e = Mm(),
    n = Pm(),
    r = Hi()
  function i(c) {
    n.call(this, 'mont', c),
      (this.a = new t(c.a, 16).toRed(this.red)),
      (this.b = new t(c.b, 16).toRed(this.red)),
      (this.i4 = new t(4).toRed(this.red).redInvm()),
      (this.two = new t(2).toRed(this.red)),
      (this.a24 = this.i4.redMul(this.a.redAdd(this.two)))
  }
  e(i, n),
    (Hv = i),
    (i.prototype.validate = function (u) {
      var f = u.normalize().x,
        d = f.redSqr(),
        p = d.redMul(f).redAdd(d.redMul(this.a)).redAdd(f),
        g = p.redSqrt()
      return g.redSqr().cmp(p) === 0
    })
  function s(c, u, f) {
    n.BasePoint.call(this, c, 'projective'),
      u === null && f === null
        ? ((this.x = this.curve.one), (this.z = this.curve.zero))
        : ((this.x = new t(u, 16)),
          (this.z = new t(f, 16)),
          this.x.red || (this.x = this.x.toRed(this.curve.red)),
          this.z.red || (this.z = this.z.toRed(this.curve.red)))
  }
  return (
    e(s, n.BasePoint),
    (i.prototype.decodePoint = function (u, f) {
      return this.point(r.toArray(u, f), 1)
    }),
    (i.prototype.point = function (u, f) {
      return new s(this, u, f)
    }),
    (i.prototype.pointFromJSON = function (u) {
      return s.fromJSON(this, u)
    }),
    (s.prototype.precompute = function () {}),
    (s.prototype._encode = function () {
      return this.getX().toArray('be', this.curve.p.byteLength())
    }),
    (s.fromJSON = function (u, f) {
      return new s(u, f[0], f[1] || u.one)
    }),
    (s.prototype.inspect = function () {
      return this.isInfinity()
        ? '<EC Point Infinity>'
        : '<EC Point x: ' +
            this.x.fromRed().toString(16, 2) +
            ' z: ' +
            this.z.fromRed().toString(16, 2) +
            '>'
    }),
    (s.prototype.isInfinity = function () {
      return this.z.cmpn(0) === 0
    }),
    (s.prototype.dbl = function () {
      var u = this.x.redAdd(this.z),
        f = u.redSqr(),
        d = this.x.redSub(this.z),
        p = d.redSqr(),
        g = f.redSub(p),
        m = f.redMul(p),
        y = g.redMul(p.redAdd(this.curve.a24.redMul(g)))
      return this.curve.point(m, y)
    }),
    (s.prototype.add = function () {
      throw new Error('Not supported on Montgomery curve')
    }),
    (s.prototype.diffAdd = function (u, f) {
      var d = this.x.redAdd(this.z),
        p = this.x.redSub(this.z),
        g = u.x.redAdd(u.z),
        m = u.x.redSub(u.z),
        y = m.redMul(d),
        A = g.redMul(p),
        E = f.z.redMul(y.redAdd(A).redSqr()),
        x = f.x.redMul(y.redISub(A).redSqr())
      return this.curve.point(E, x)
    }),
    (s.prototype.mul = function (u) {
      for (
        var f = u.clone(), d = this, p = this.curve.point(null, null), g = this, m = [];
        f.cmpn(0) !== 0;
        f.iushrn(1)
      )
        m.push(f.andln(1))
      for (var y = m.length - 1; y >= 0; y--)
        m[y] === 0 ? ((d = d.diffAdd(p, g)), (p = p.dbl())) : ((p = d.diffAdd(p, g)), (d = d.dbl()))
      return p
    }),
    (s.prototype.mulAdd = function () {
      throw new Error('Not supported on Montgomery curve')
    }),
    (s.prototype.jumlAdd = function () {
      throw new Error('Not supported on Montgomery curve')
    }),
    (s.prototype.eq = function (u) {
      return this.getX().cmp(u.getX()) === 0
    }),
    (s.prototype.normalize = function () {
      return (this.x = this.x.redMul(this.z.redInvm())), (this.z = this.curve.one), this
    }),
    (s.prototype.getX = function () {
      return this.normalize(), this.x.fromRed()
    }),
    Hv
  )
}
var Gv, YS
function w$() {
  if (YS) return Gv
  YS = 1
  var t = Hi(),
    e = Fa(),
    n = Mm(),
    r = Pm(),
    i = t.assert
  function s(u) {
    ;(this.twisted = (u.a | 0) !== 1),
      (this.mOneA = this.twisted && (u.a | 0) === -1),
      (this.extended = this.mOneA),
      r.call(this, 'edwards', u),
      (this.a = new e(u.a, 16).umod(this.red.m)),
      (this.a = this.a.toRed(this.red)),
      (this.c = new e(u.c, 16).toRed(this.red)),
      (this.c2 = this.c.redSqr()),
      (this.d = new e(u.d, 16).toRed(this.red)),
      (this.dd = this.d.redAdd(this.d)),
      i(!this.twisted || this.c.fromRed().cmpn(1) === 0),
      (this.oneC = (u.c | 0) === 1)
  }
  n(s, r),
    (Gv = s),
    (s.prototype._mulA = function (f) {
      return this.mOneA ? f.redNeg() : this.a.redMul(f)
    }),
    (s.prototype._mulC = function (f) {
      return this.oneC ? f : this.c.redMul(f)
    }),
    (s.prototype.jpoint = function (f, d, p, g) {
      return this.point(f, d, p, g)
    }),
    (s.prototype.pointFromX = function (f, d) {
      ;(f = new e(f, 16)), f.red || (f = f.toRed(this.red))
      var p = f.redSqr(),
        g = this.c2.redSub(this.a.redMul(p)),
        m = this.one.redSub(this.c2.redMul(this.d).redMul(p)),
        y = g.redMul(m.redInvm()),
        A = y.redSqrt()
      if (A.redSqr().redSub(y).cmp(this.zero) !== 0) throw new Error('invalid point')
      var E = A.fromRed().isOdd()
      return ((d && !E) || (!d && E)) && (A = A.redNeg()), this.point(f, A)
    }),
    (s.prototype.pointFromY = function (f, d) {
      ;(f = new e(f, 16)), f.red || (f = f.toRed(this.red))
      var p = f.redSqr(),
        g = p.redSub(this.c2),
        m = p.redMul(this.d).redMul(this.c2).redSub(this.a),
        y = g.redMul(m.redInvm())
      if (y.cmp(this.zero) === 0) {
        if (d) throw new Error('invalid point')
        return this.point(this.zero, f)
      }
      var A = y.redSqrt()
      if (A.redSqr().redSub(y).cmp(this.zero) !== 0) throw new Error('invalid point')
      return A.fromRed().isOdd() !== d && (A = A.redNeg()), this.point(A, f)
    }),
    (s.prototype.validate = function (f) {
      if (f.isInfinity()) return !0
      f.normalize()
      var d = f.x.redSqr(),
        p = f.y.redSqr(),
        g = d.redMul(this.a).redAdd(p),
        m = this.c2.redMul(this.one.redAdd(this.d.redMul(d).redMul(p)))
      return g.cmp(m) === 0
    })
  function c(u, f, d, p, g) {
    r.BasePoint.call(this, u, 'projective'),
      f === null && d === null && p === null
        ? ((this.x = this.curve.zero),
          (this.y = this.curve.one),
          (this.z = this.curve.one),
          (this.t = this.curve.zero),
          (this.zOne = !0))
        : ((this.x = new e(f, 16)),
          (this.y = new e(d, 16)),
          (this.z = p ? new e(p, 16) : this.curve.one),
          (this.t = g && new e(g, 16)),
          this.x.red || (this.x = this.x.toRed(this.curve.red)),
          this.y.red || (this.y = this.y.toRed(this.curve.red)),
          this.z.red || (this.z = this.z.toRed(this.curve.red)),
          this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)),
          (this.zOne = this.z === this.curve.one),
          this.curve.extended &&
            !this.t &&
            ((this.t = this.x.redMul(this.y)),
            this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
  }
  return (
    n(c, r.BasePoint),
    (s.prototype.pointFromJSON = function (f) {
      return c.fromJSON(this, f)
    }),
    (s.prototype.point = function (f, d, p, g) {
      return new c(this, f, d, p, g)
    }),
    (c.fromJSON = function (f, d) {
      return new c(f, d[0], d[1], d[2])
    }),
    (c.prototype.inspect = function () {
      return this.isInfinity()
        ? '<EC Point Infinity>'
        : '<EC Point x: ' +
            this.x.fromRed().toString(16, 2) +
            ' y: ' +
            this.y.fromRed().toString(16, 2) +
            ' z: ' +
            this.z.fromRed().toString(16, 2) +
            '>'
    }),
    (c.prototype.isInfinity = function () {
      return (
        this.x.cmpn(0) === 0 &&
        (this.y.cmp(this.z) === 0 || (this.zOne && this.y.cmp(this.curve.c) === 0))
      )
    }),
    (c.prototype._extDbl = function () {
      var f = this.x.redSqr(),
        d = this.y.redSqr(),
        p = this.z.redSqr()
      p = p.redIAdd(p)
      var g = this.curve._mulA(f),
        m = this.x.redAdd(this.y).redSqr().redISub(f).redISub(d),
        y = g.redAdd(d),
        A = y.redSub(p),
        E = g.redSub(d),
        x = m.redMul(A),
        O = y.redMul(E),
        I = m.redMul(E),
        M = A.redMul(y)
      return this.curve.point(x, O, M, I)
    }),
    (c.prototype._projDbl = function () {
      var f = this.x.redAdd(this.y).redSqr(),
        d = this.x.redSqr(),
        p = this.y.redSqr(),
        g,
        m,
        y,
        A,
        E,
        x
      if (this.curve.twisted) {
        A = this.curve._mulA(d)
        var O = A.redAdd(p)
        this.zOne
          ? ((g = f.redSub(d).redSub(p).redMul(O.redSub(this.curve.two))),
            (m = O.redMul(A.redSub(p))),
            (y = O.redSqr().redSub(O).redSub(O)))
          : ((E = this.z.redSqr()),
            (x = O.redSub(E).redISub(E)),
            (g = f.redSub(d).redISub(p).redMul(x)),
            (m = O.redMul(A.redSub(p))),
            (y = O.redMul(x)))
      } else
        (A = d.redAdd(p)),
          (E = this.curve._mulC(this.z).redSqr()),
          (x = A.redSub(E).redSub(E)),
          (g = this.curve._mulC(f.redISub(A)).redMul(x)),
          (m = this.curve._mulC(A).redMul(d.redISub(p))),
          (y = A.redMul(x))
      return this.curve.point(g, m, y)
    }),
    (c.prototype.dbl = function () {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
    }),
    (c.prototype._extAdd = function (f) {
      var d = this.y.redSub(this.x).redMul(f.y.redSub(f.x)),
        p = this.y.redAdd(this.x).redMul(f.y.redAdd(f.x)),
        g = this.t.redMul(this.curve.dd).redMul(f.t),
        m = this.z.redMul(f.z.redAdd(f.z)),
        y = p.redSub(d),
        A = m.redSub(g),
        E = m.redAdd(g),
        x = p.redAdd(d),
        O = y.redMul(A),
        I = E.redMul(x),
        M = y.redMul(x),
        $ = A.redMul(E)
      return this.curve.point(O, I, $, M)
    }),
    (c.prototype._projAdd = function (f) {
      var d = this.z.redMul(f.z),
        p = d.redSqr(),
        g = this.x.redMul(f.x),
        m = this.y.redMul(f.y),
        y = this.curve.d.redMul(g).redMul(m),
        A = p.redSub(y),
        E = p.redAdd(y),
        x = this.x.redAdd(this.y).redMul(f.x.redAdd(f.y)).redISub(g).redISub(m),
        O = d.redMul(A).redMul(x),
        I,
        M
      return (
        this.curve.twisted
          ? ((I = d.redMul(E).redMul(m.redSub(this.curve._mulA(g)))), (M = A.redMul(E)))
          : ((I = d.redMul(E).redMul(m.redSub(g))), (M = this.curve._mulC(A).redMul(E))),
        this.curve.point(O, I, M)
      )
    }),
    (c.prototype.add = function (f) {
      return this.isInfinity()
        ? f
        : f.isInfinity()
          ? this
          : this.curve.extended
            ? this._extAdd(f)
            : this._projAdd(f)
    }),
    (c.prototype.mul = function (f) {
      return this._hasDoubles(f) ? this.curve._fixedNafMul(this, f) : this.curve._wnafMul(this, f)
    }),
    (c.prototype.mulAdd = function (f, d, p) {
      return this.curve._wnafMulAdd(1, [this, d], [f, p], 2, !1)
    }),
    (c.prototype.jmulAdd = function (f, d, p) {
      return this.curve._wnafMulAdd(1, [this, d], [f, p], 2, !0)
    }),
    (c.prototype.normalize = function () {
      if (this.zOne) return this
      var f = this.z.redInvm()
      return (
        (this.x = this.x.redMul(f)),
        (this.y = this.y.redMul(f)),
        this.t && (this.t = this.t.redMul(f)),
        (this.z = this.curve.one),
        (this.zOne = !0),
        this
      )
    }),
    (c.prototype.neg = function () {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
    }),
    (c.prototype.getX = function () {
      return this.normalize(), this.x.fromRed()
    }),
    (c.prototype.getY = function () {
      return this.normalize(), this.y.fromRed()
    }),
    (c.prototype.eq = function (f) {
      return this === f || (this.getX().cmp(f.getX()) === 0 && this.getY().cmp(f.getY()) === 0)
    }),
    (c.prototype.eqXToP = function (f) {
      var d = f.toRed(this.curve.red).redMul(this.z)
      if (this.x.cmp(d) === 0) return !0
      for (var p = f.clone(), g = this.curve.redN.redMul(this.z); ; ) {
        if ((p.iadd(this.curve.n), p.cmp(this.curve.p) >= 0)) return !1
        if ((d.redIAdd(g), this.x.cmp(d) === 0)) return !0
      }
    }),
    (c.prototype.toP = c.prototype.normalize),
    (c.prototype.mixedAdd = c.prototype.add),
    Gv
  )
}
var ZS
function fx() {
  return (
    ZS ||
      ((ZS = 1),
      (function (t) {
        var e = t
        ;(e.base = Pm()), (e.short = y$()), (e.mont = v$()), (e.edwards = w$())
      })(jv)),
    jv
  )
}
var Vv = {},
  Kv = {},
  Kt = {},
  XS
function Ws() {
  if (XS) return Kt
  XS = 1
  var t = wu(),
    e = Mm()
  Kt.inherits = e
  function n(v, C) {
    return (v.charCodeAt(C) & 64512) !== 55296 || C < 0 || C + 1 >= v.length
      ? !1
      : (v.charCodeAt(C + 1) & 64512) === 56320
  }
  function r(v, C) {
    if (Array.isArray(v)) return v.slice()
    if (!v) return []
    var N = []
    if (typeof v == 'string')
      if (C) {
        if (C === 'hex')
          for (
            v = v.replace(/[^a-z0-9]+/gi, ''), v.length % 2 !== 0 && (v = '0' + v), S = 0;
            S < v.length;
            S += 2
          )
            N.push(parseInt(v[S] + v[S + 1], 16))
      } else
        for (var T = 0, S = 0; S < v.length; S++) {
          var k = v.charCodeAt(S)
          k < 128
            ? (N[T++] = k)
            : k < 2048
              ? ((N[T++] = (k >> 6) | 192), (N[T++] = (k & 63) | 128))
              : n(v, S)
                ? ((k = 65536 + ((k & 1023) << 10) + (v.charCodeAt(++S) & 1023)),
                  (N[T++] = (k >> 18) | 240),
                  (N[T++] = ((k >> 12) & 63) | 128),
                  (N[T++] = ((k >> 6) & 63) | 128),
                  (N[T++] = (k & 63) | 128))
                : ((N[T++] = (k >> 12) | 224),
                  (N[T++] = ((k >> 6) & 63) | 128),
                  (N[T++] = (k & 63) | 128))
        }
    else for (S = 0; S < v.length; S++) N[S] = v[S] | 0
    return N
  }
  Kt.toArray = r
  function i(v) {
    for (var C = '', N = 0; N < v.length; N++) C += u(v[N].toString(16))
    return C
  }
  Kt.toHex = i
  function s(v) {
    var C = (v >>> 24) | ((v >>> 8) & 65280) | ((v << 8) & 16711680) | ((v & 255) << 24)
    return C >>> 0
  }
  Kt.htonl = s
  function c(v, C) {
    for (var N = '', T = 0; T < v.length; T++) {
      var S = v[T]
      C === 'little' && (S = s(S)), (N += f(S.toString(16)))
    }
    return N
  }
  Kt.toHex32 = c
  function u(v) {
    return v.length === 1 ? '0' + v : v
  }
  Kt.zero2 = u
  function f(v) {
    return v.length === 7
      ? '0' + v
      : v.length === 6
        ? '00' + v
        : v.length === 5
          ? '000' + v
          : v.length === 4
            ? '0000' + v
            : v.length === 3
              ? '00000' + v
              : v.length === 2
                ? '000000' + v
                : v.length === 1
                  ? '0000000' + v
                  : v
  }
  Kt.zero8 = f
  function d(v, C, N, T) {
    var S = N - C
    t(S % 4 === 0)
    for (var k = new Array(S / 4), F = 0, P = C; F < k.length; F++, P += 4) {
      var w
      T === 'big'
        ? (w = (v[P] << 24) | (v[P + 1] << 16) | (v[P + 2] << 8) | v[P + 3])
        : (w = (v[P + 3] << 24) | (v[P + 2] << 16) | (v[P + 1] << 8) | v[P]),
        (k[F] = w >>> 0)
    }
    return k
  }
  Kt.join32 = d
  function p(v, C) {
    for (var N = new Array(v.length * 4), T = 0, S = 0; T < v.length; T++, S += 4) {
      var k = v[T]
      C === 'big'
        ? ((N[S] = k >>> 24),
          (N[S + 1] = (k >>> 16) & 255),
          (N[S + 2] = (k >>> 8) & 255),
          (N[S + 3] = k & 255))
        : ((N[S + 3] = k >>> 24),
          (N[S + 2] = (k >>> 16) & 255),
          (N[S + 1] = (k >>> 8) & 255),
          (N[S] = k & 255))
    }
    return N
  }
  Kt.split32 = p
  function g(v, C) {
    return (v >>> C) | (v << (32 - C))
  }
  Kt.rotr32 = g
  function m(v, C) {
    return (v << C) | (v >>> (32 - C))
  }
  Kt.rotl32 = m
  function y(v, C) {
    return (v + C) >>> 0
  }
  Kt.sum32 = y
  function A(v, C, N) {
    return (v + C + N) >>> 0
  }
  Kt.sum32_3 = A
  function E(v, C, N, T) {
    return (v + C + N + T) >>> 0
  }
  Kt.sum32_4 = E
  function x(v, C, N, T, S) {
    return (v + C + N + T + S) >>> 0
  }
  Kt.sum32_5 = x
  function O(v, C, N, T) {
    var S = v[C],
      k = v[C + 1],
      F = (T + k) >>> 0,
      P = (F < T ? 1 : 0) + N + S
    ;(v[C] = P >>> 0), (v[C + 1] = F)
  }
  Kt.sum64 = O
  function I(v, C, N, T) {
    var S = (C + T) >>> 0,
      k = (S < C ? 1 : 0) + v + N
    return k >>> 0
  }
  Kt.sum64_hi = I
  function M(v, C, N, T) {
    var S = C + T
    return S >>> 0
  }
  Kt.sum64_lo = M
  function $(v, C, N, T, S, k, F, P) {
    var w = 0,
      B = C
    ;(B = (B + T) >>> 0),
      (w += B < C ? 1 : 0),
      (B = (B + k) >>> 0),
      (w += B < k ? 1 : 0),
      (B = (B + P) >>> 0),
      (w += B < P ? 1 : 0)
    var Z = v + N + S + F + w
    return Z >>> 0
  }
  Kt.sum64_4_hi = $
  function D(v, C, N, T, S, k, F, P) {
    var w = C + T + k + P
    return w >>> 0
  }
  Kt.sum64_4_lo = D
  function R(v, C, N, T, S, k, F, P, w, B) {
    var Z = 0,
      ee = C
    ;(ee = (ee + T) >>> 0),
      (Z += ee < C ? 1 : 0),
      (ee = (ee + k) >>> 0),
      (Z += ee < k ? 1 : 0),
      (ee = (ee + P) >>> 0),
      (Z += ee < P ? 1 : 0),
      (ee = (ee + B) >>> 0),
      (Z += ee < B ? 1 : 0)
    var Y = v + N + S + F + w + Z
    return Y >>> 0
  }
  Kt.sum64_5_hi = R
  function z(v, C, N, T, S, k, F, P, w, B) {
    var Z = C + T + k + P + B
    return Z >>> 0
  }
  Kt.sum64_5_lo = z
  function G(v, C, N) {
    var T = (C << (32 - N)) | (v >>> N)
    return T >>> 0
  }
  Kt.rotr64_hi = G
  function j(v, C, N) {
    var T = (v << (32 - N)) | (C >>> N)
    return T >>> 0
  }
  Kt.rotr64_lo = j
  function V(v, C, N) {
    return v >>> N
  }
  Kt.shr64_hi = V
  function L(v, C, N) {
    var T = (v << (32 - N)) | (C >>> N)
    return T >>> 0
  }
  return (Kt.shr64_lo = L), Kt
}
var Wv = {},
  JS
function vp() {
  if (JS) return Wv
  JS = 1
  var t = Ws(),
    e = wu()
  function n() {
    ;(this.pending = null),
      (this.pendingTotal = 0),
      (this.blockSize = this.constructor.blockSize),
      (this.outSize = this.constructor.outSize),
      (this.hmacStrength = this.constructor.hmacStrength),
      (this.padLength = this.constructor.padLength / 8),
      (this.endian = 'big'),
      (this._delta8 = this.blockSize / 8),
      (this._delta32 = this.blockSize / 32)
  }
  return (
    (Wv.BlockHash = n),
    (n.prototype.update = function (i, s) {
      if (
        ((i = t.toArray(i, s)),
        this.pending ? (this.pending = this.pending.concat(i)) : (this.pending = i),
        (this.pendingTotal += i.length),
        this.pending.length >= this._delta8)
      ) {
        i = this.pending
        var c = i.length % this._delta8
        ;(this.pending = i.slice(i.length - c, i.length)),
          this.pending.length === 0 && (this.pending = null),
          (i = t.join32(i, 0, i.length - c, this.endian))
        for (var u = 0; u < i.length; u += this._delta32) this._update(i, u, u + this._delta32)
      }
      return this
    }),
    (n.prototype.digest = function (i) {
      return this.update(this._pad()), e(this.pending === null), this._digest(i)
    }),
    (n.prototype._pad = function () {
      var i = this.pendingTotal,
        s = this._delta8,
        c = s - ((i + this.padLength) % s),
        u = new Array(c + this.padLength)
      u[0] = 128
      for (var f = 1; f < c; f++) u[f] = 0
      if (((i <<= 3), this.endian === 'big')) {
        for (var d = 8; d < this.padLength; d++) u[f++] = 0
        ;(u[f++] = 0),
          (u[f++] = 0),
          (u[f++] = 0),
          (u[f++] = 0),
          (u[f++] = (i >>> 24) & 255),
          (u[f++] = (i >>> 16) & 255),
          (u[f++] = (i >>> 8) & 255),
          (u[f++] = i & 255)
      } else
        for (
          u[f++] = i & 255,
            u[f++] = (i >>> 8) & 255,
            u[f++] = (i >>> 16) & 255,
            u[f++] = (i >>> 24) & 255,
            u[f++] = 0,
            u[f++] = 0,
            u[f++] = 0,
            u[f++] = 0,
            d = 8;
          d < this.padLength;
          d++
        )
          u[f++] = 0
      return u
    }),
    Wv
  )
}
var Ec = {},
  xs = {},
  e5
function hx() {
  if (e5) return xs
  e5 = 1
  var t = Ws(),
    e = t.rotr32
  function n(p, g, m, y) {
    if (p === 0) return r(g, m, y)
    if (p === 1 || p === 3) return s(g, m, y)
    if (p === 2) return i(g, m, y)
  }
  xs.ft_1 = n
  function r(p, g, m) {
    return (p & g) ^ (~p & m)
  }
  xs.ch32 = r
  function i(p, g, m) {
    return (p & g) ^ (p & m) ^ (g & m)
  }
  xs.maj32 = i
  function s(p, g, m) {
    return p ^ g ^ m
  }
  xs.p32 = s
  function c(p) {
    return e(p, 2) ^ e(p, 13) ^ e(p, 22)
  }
  xs.s0_256 = c
  function u(p) {
    return e(p, 6) ^ e(p, 11) ^ e(p, 25)
  }
  xs.s1_256 = u
  function f(p) {
    return e(p, 7) ^ e(p, 18) ^ (p >>> 3)
  }
  xs.g0_256 = f
  function d(p) {
    return e(p, 17) ^ e(p, 19) ^ (p >>> 10)
  }
  return (xs.g1_256 = d), xs
}
var Qv, t5
function E$() {
  if (t5) return Qv
  t5 = 1
  var t = Ws(),
    e = vp(),
    n = hx(),
    r = t.rotl32,
    i = t.sum32,
    s = t.sum32_5,
    c = n.ft_1,
    u = e.BlockHash,
    f = [1518500249, 1859775393, 2400959708, 3395469782]
  function d() {
    if (!(this instanceof d)) return new d()
    u.call(this),
      (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
      (this.W = new Array(80))
  }
  return (
    t.inherits(d, u),
    (Qv = d),
    (d.blockSize = 512),
    (d.outSize = 160),
    (d.hmacStrength = 80),
    (d.padLength = 64),
    (d.prototype._update = function (g, m) {
      for (var y = this.W, A = 0; A < 16; A++) y[A] = g[m + A]
      for (; A < y.length; A++) y[A] = r(y[A - 3] ^ y[A - 8] ^ y[A - 14] ^ y[A - 16], 1)
      var E = this.h[0],
        x = this.h[1],
        O = this.h[2],
        I = this.h[3],
        M = this.h[4]
      for (A = 0; A < y.length; A++) {
        var $ = ~~(A / 20),
          D = s(r(E, 5), c($, x, O, I), M, y[A], f[$])
        ;(M = I), (I = O), (O = r(x, 30)), (x = E), (E = D)
      }
      ;(this.h[0] = i(this.h[0], E)),
        (this.h[1] = i(this.h[1], x)),
        (this.h[2] = i(this.h[2], O)),
        (this.h[3] = i(this.h[3], I)),
        (this.h[4] = i(this.h[4], M))
    }),
    (d.prototype._digest = function (g) {
      return g === 'hex' ? t.toHex32(this.h, 'big') : t.split32(this.h, 'big')
    }),
    Qv
  )
}
var Yv, n5
function px() {
  if (n5) return Yv
  n5 = 1
  var t = Ws(),
    e = vp(),
    n = hx(),
    r = wu(),
    i = t.sum32,
    s = t.sum32_4,
    c = t.sum32_5,
    u = n.ch32,
    f = n.maj32,
    d = n.s0_256,
    p = n.s1_256,
    g = n.g0_256,
    m = n.g1_256,
    y = e.BlockHash,
    A = [
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
      3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
      3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
      666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
      2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
      1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298
    ]
  function E() {
    if (!(this instanceof E)) return new E()
    y.call(this),
      (this.h = [
        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,
        1541459225
      ]),
      (this.k = A),
      (this.W = new Array(64))
  }
  return (
    t.inherits(E, y),
    (Yv = E),
    (E.blockSize = 512),
    (E.outSize = 256),
    (E.hmacStrength = 192),
    (E.padLength = 64),
    (E.prototype._update = function (O, I) {
      for (var M = this.W, $ = 0; $ < 16; $++) M[$] = O[I + $]
      for (; $ < M.length; $++) M[$] = s(m(M[$ - 2]), M[$ - 7], g(M[$ - 15]), M[$ - 16])
      var D = this.h[0],
        R = this.h[1],
        z = this.h[2],
        G = this.h[3],
        j = this.h[4],
        V = this.h[5],
        L = this.h[6],
        v = this.h[7]
      for (r(this.k.length === M.length), $ = 0; $ < M.length; $++) {
        var C = c(v, p(j), u(j, V, L), this.k[$], M[$]),
          N = i(d(D), f(D, R, z))
        ;(v = L), (L = V), (V = j), (j = i(G, C)), (G = z), (z = R), (R = D), (D = i(C, N))
      }
      ;(this.h[0] = i(this.h[0], D)),
        (this.h[1] = i(this.h[1], R)),
        (this.h[2] = i(this.h[2], z)),
        (this.h[3] = i(this.h[3], G)),
        (this.h[4] = i(this.h[4], j)),
        (this.h[5] = i(this.h[5], V)),
        (this.h[6] = i(this.h[6], L)),
        (this.h[7] = i(this.h[7], v))
    }),
    (E.prototype._digest = function (O) {
      return O === 'hex' ? t.toHex32(this.h, 'big') : t.split32(this.h, 'big')
    }),
    Yv
  )
}
var Zv, r5
function A$() {
  if (r5) return Zv
  r5 = 1
  var t = Ws(),
    e = px()
  function n() {
    if (!(this instanceof n)) return new n()
    e.call(this),
      (this.h = [
        3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428
      ])
  }
  return (
    t.inherits(n, e),
    (Zv = n),
    (n.blockSize = 512),
    (n.outSize = 224),
    (n.hmacStrength = 192),
    (n.padLength = 64),
    (n.prototype._digest = function (i) {
      return i === 'hex'
        ? t.toHex32(this.h.slice(0, 7), 'big')
        : t.split32(this.h.slice(0, 7), 'big')
    }),
    Zv
  )
}
var Xv, i5
function gx() {
  if (i5) return Xv
  i5 = 1
  var t = Ws(),
    e = vp(),
    n = wu(),
    r = t.rotr64_hi,
    i = t.rotr64_lo,
    s = t.shr64_hi,
    c = t.shr64_lo,
    u = t.sum64,
    f = t.sum64_hi,
    d = t.sum64_lo,
    p = t.sum64_4_hi,
    g = t.sum64_4_lo,
    m = t.sum64_5_hi,
    y = t.sum64_5_lo,
    A = e.BlockHash,
    E = [
      1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548,
      961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560,
      3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
      1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868,
      3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933,
      770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
      2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956,
      3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936,
      666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
      1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627,
      2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008,
      3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
      430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280,
      958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899,
      1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
      2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427,
      3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992,
      116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
      685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676,
      1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591
    ]
  function x() {
    if (!(this instanceof x)) return new x()
    A.call(this),
      (this.h = [
        1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762,
        1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547,
        1541459225, 327033209
      ]),
      (this.k = E),
      (this.W = new Array(160))
  }
  t.inherits(x, A),
    (Xv = x),
    (x.blockSize = 1024),
    (x.outSize = 512),
    (x.hmacStrength = 192),
    (x.padLength = 128),
    (x.prototype._prepareBlock = function (N, T) {
      for (var S = this.W, k = 0; k < 32; k++) S[k] = N[T + k]
      for (; k < S.length; k += 2) {
        var F = L(S[k - 4], S[k - 3]),
          P = v(S[k - 4], S[k - 3]),
          w = S[k - 14],
          B = S[k - 13],
          Z = j(S[k - 30], S[k - 29]),
          ee = V(S[k - 30], S[k - 29]),
          Y = S[k - 32],
          se = S[k - 31]
        ;(S[k] = p(F, P, w, B, Z, ee, Y, se)), (S[k + 1] = g(F, P, w, B, Z, ee, Y, se))
      }
    }),
    (x.prototype._update = function (N, T) {
      this._prepareBlock(N, T)
      var S = this.W,
        k = this.h[0],
        F = this.h[1],
        P = this.h[2],
        w = this.h[3],
        B = this.h[4],
        Z = this.h[5],
        ee = this.h[6],
        Y = this.h[7],
        se = this.h[8],
        ce = this.h[9],
        we = this.h[10],
        _e = this.h[11],
        ye = this.h[12],
        Ce = this.h[13],
        kt = this.h[14],
        tt = this.h[15]
      n(this.k.length === S.length)
      for (var Ke = 0; Ke < S.length; Ke += 2) {
        var jn = kt,
          ut = tt,
          lt = z(se, ce),
          qr = G(se, ce),
          It = O(se, ce, we, _e, ye),
          Ot = I(se, ce, we, _e, ye, Ce),
          yi = this.k[Ke],
          xt = this.k[Ke + 1],
          zt = S[Ke],
          ms = S[Ke + 1],
          Je = m(jn, ut, lt, qr, It, Ot, yi, xt, zt, ms),
          Rt = y(jn, ut, lt, qr, It, Ot, yi, xt, zt, ms)
        ;(jn = D(k, F)), (ut = R(k, F)), (lt = M(k, F, P, w, B)), (qr = $(k, F, P, w, B, Z))
        var Ki = f(jn, ut, lt, qr),
          qt = d(jn, ut, lt, qr)
        ;(kt = ye),
          (tt = Ce),
          (ye = we),
          (Ce = _e),
          (we = se),
          (_e = ce),
          (se = f(ee, Y, Je, Rt)),
          (ce = d(Y, Y, Je, Rt)),
          (ee = B),
          (Y = Z),
          (B = P),
          (Z = w),
          (P = k),
          (w = F),
          (k = f(Je, Rt, Ki, qt)),
          (F = d(Je, Rt, Ki, qt))
      }
      u(this.h, 0, k, F),
        u(this.h, 2, P, w),
        u(this.h, 4, B, Z),
        u(this.h, 6, ee, Y),
        u(this.h, 8, se, ce),
        u(this.h, 10, we, _e),
        u(this.h, 12, ye, Ce),
        u(this.h, 14, kt, tt)
    }),
    (x.prototype._digest = function (N) {
      return N === 'hex' ? t.toHex32(this.h, 'big') : t.split32(this.h, 'big')
    })
  function O(C, N, T, S, k) {
    var F = (C & T) ^ (~C & k)
    return F < 0 && (F += 4294967296), F
  }
  function I(C, N, T, S, k, F) {
    var P = (N & S) ^ (~N & F)
    return P < 0 && (P += 4294967296), P
  }
  function M(C, N, T, S, k) {
    var F = (C & T) ^ (C & k) ^ (T & k)
    return F < 0 && (F += 4294967296), F
  }
  function $(C, N, T, S, k, F) {
    var P = (N & S) ^ (N & F) ^ (S & F)
    return P < 0 && (P += 4294967296), P
  }
  function D(C, N) {
    var T = r(C, N, 28),
      S = r(N, C, 2),
      k = r(N, C, 7),
      F = T ^ S ^ k
    return F < 0 && (F += 4294967296), F
  }
  function R(C, N) {
    var T = i(C, N, 28),
      S = i(N, C, 2),
      k = i(N, C, 7),
      F = T ^ S ^ k
    return F < 0 && (F += 4294967296), F
  }
  function z(C, N) {
    var T = r(C, N, 14),
      S = r(C, N, 18),
      k = r(N, C, 9),
      F = T ^ S ^ k
    return F < 0 && (F += 4294967296), F
  }
  function G(C, N) {
    var T = i(C, N, 14),
      S = i(C, N, 18),
      k = i(N, C, 9),
      F = T ^ S ^ k
    return F < 0 && (F += 4294967296), F
  }
  function j(C, N) {
    var T = r(C, N, 1),
      S = r(C, N, 8),
      k = s(C, N, 7),
      F = T ^ S ^ k
    return F < 0 && (F += 4294967296), F
  }
  function V(C, N) {
    var T = i(C, N, 1),
      S = i(C, N, 8),
      k = c(C, N, 7),
      F = T ^ S ^ k
    return F < 0 && (F += 4294967296), F
  }
  function L(C, N) {
    var T = r(C, N, 19),
      S = r(N, C, 29),
      k = s(C, N, 6),
      F = T ^ S ^ k
    return F < 0 && (F += 4294967296), F
  }
  function v(C, N) {
    var T = i(C, N, 19),
      S = i(N, C, 29),
      k = c(C, N, 6),
      F = T ^ S ^ k
    return F < 0 && (F += 4294967296), F
  }
  return Xv
}
var Jv, s5
function _$() {
  if (s5) return Jv
  s5 = 1
  var t = Ws(),
    e = gx()
  function n() {
    if (!(this instanceof n)) return new n()
    e.call(this),
      (this.h = [
        3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697,
        1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813,
        3204075428
      ])
  }
  return (
    t.inherits(n, e),
    (Jv = n),
    (n.blockSize = 1024),
    (n.outSize = 384),
    (n.hmacStrength = 192),
    (n.padLength = 128),
    (n.prototype._digest = function (i) {
      return i === 'hex'
        ? t.toHex32(this.h.slice(0, 12), 'big')
        : t.split32(this.h.slice(0, 12), 'big')
    }),
    Jv
  )
}
var a5
function C$() {
  return (
    a5 ||
      ((a5 = 1),
      (Ec.sha1 = E$()),
      (Ec.sha224 = A$()),
      (Ec.sha256 = px()),
      (Ec.sha384 = _$()),
      (Ec.sha512 = gx())),
    Ec
  )
}
var e1 = {},
  o5
function S$() {
  if (o5) return e1
  o5 = 1
  var t = Ws(),
    e = vp(),
    n = t.rotl32,
    r = t.sum32,
    i = t.sum32_3,
    s = t.sum32_4,
    c = e.BlockHash
  function u() {
    if (!(this instanceof u)) return new u()
    c.call(this),
      (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
      (this.endian = 'little')
  }
  t.inherits(u, c),
    (e1.ripemd160 = u),
    (u.blockSize = 512),
    (u.outSize = 160),
    (u.hmacStrength = 192),
    (u.padLength = 64),
    (u.prototype._update = function (x, O) {
      for (
        var I = this.h[0],
          M = this.h[1],
          $ = this.h[2],
          D = this.h[3],
          R = this.h[4],
          z = I,
          G = M,
          j = $,
          V = D,
          L = R,
          v = 0;
        v < 80;
        v++
      ) {
        var C = r(n(s(I, f(v, M, $, D), x[g[v] + O], d(v)), y[v]), R)
        ;(I = R),
          (R = D),
          (D = n($, 10)),
          ($ = M),
          (M = C),
          (C = r(n(s(z, f(79 - v, G, j, V), x[m[v] + O], p(v)), A[v]), L)),
          (z = L),
          (L = V),
          (V = n(j, 10)),
          (j = G),
          (G = C)
      }
      ;(C = i(this.h[1], $, V)),
        (this.h[1] = i(this.h[2], D, L)),
        (this.h[2] = i(this.h[3], R, z)),
        (this.h[3] = i(this.h[4], I, G)),
        (this.h[4] = i(this.h[0], M, j)),
        (this.h[0] = C)
    }),
    (u.prototype._digest = function (x) {
      return x === 'hex' ? t.toHex32(this.h, 'little') : t.split32(this.h, 'little')
    })
  function f(E, x, O, I) {
    return E <= 15
      ? x ^ O ^ I
      : E <= 31
        ? (x & O) | (~x & I)
        : E <= 47
          ? (x | ~O) ^ I
          : E <= 63
            ? (x & I) | (O & ~I)
            : x ^ (O | ~I)
  }
  function d(E) {
    return E <= 15
      ? 0
      : E <= 31
        ? 1518500249
        : E <= 47
          ? 1859775393
          : E <= 63
            ? 2400959708
            : 2840853838
  }
  function p(E) {
    return E <= 15
      ? 1352829926
      : E <= 31
        ? 1548603684
        : E <= 47
          ? 1836072691
          : E <= 63
            ? 2053994217
            : 0
  }
  var g = [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5,
      2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4,
      13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
    ],
    m = [
      5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8,
      12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15,
      0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
    ],
    y = [
      11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15,
      9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14,
      15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
    ],
    A = [
      8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12,
      7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14,
      14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
    ]
  return e1
}
var t1, c5
function T$() {
  if (c5) return t1
  c5 = 1
  var t = Ws(),
    e = wu()
  function n(r, i, s) {
    if (!(this instanceof n)) return new n(r, i, s)
    ;(this.Hash = r),
      (this.blockSize = r.blockSize / 8),
      (this.outSize = r.outSize / 8),
      (this.inner = null),
      (this.outer = null),
      this._init(t.toArray(i, s))
  }
  return (
    (t1 = n),
    (n.prototype._init = function (i) {
      i.length > this.blockSize && (i = new this.Hash().update(i).digest()),
        e(i.length <= this.blockSize)
      for (var s = i.length; s < this.blockSize; s++) i.push(0)
      for (s = 0; s < i.length; s++) i[s] ^= 54
      for (this.inner = new this.Hash().update(i), s = 0; s < i.length; s++) i[s] ^= 106
      this.outer = new this.Hash().update(i)
    }),
    (n.prototype.update = function (i, s) {
      return this.inner.update(i, s), this
    }),
    (n.prototype.digest = function (i) {
      return this.outer.update(this.inner.digest()), this.outer.digest(i)
    }),
    t1
  )
}
var u5
function ZE() {
  return (
    u5 ||
      ((u5 = 1),
      (function (t) {
        var e = t
        ;(e.utils = Ws()),
          (e.common = vp()),
          (e.sha = C$()),
          (e.ripemd = S$()),
          (e.hmac = T$()),
          (e.sha1 = e.sha.sha1),
          (e.sha256 = e.sha.sha256),
          (e.sha224 = e.sha.sha224),
          (e.sha384 = e.sha.sha384),
          (e.sha512 = e.sha.sha512),
          (e.ripemd160 = e.ripemd.ripemd160)
      })(Kv)),
    Kv
  )
}
var n1, l5
function x$() {
  return (
    l5 ||
      ((l5 = 1),
      (n1 = {
        doubles: {
          step: 4,
          points: [
            [
              'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
              'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
            ],
            [
              '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
              '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
            ],
            [
              '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
              'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
            ],
            [
              '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
              '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
            ],
            [
              '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
              '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
            ],
            [
              '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
              '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
            ],
            [
              'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
              '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
            ],
            [
              '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
              'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
            ],
            [
              'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
              '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
            ],
            [
              'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
              'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
            ],
            [
              'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
              '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
            ],
            [
              '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
              '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
            ],
            [
              '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
              '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
            ],
            [
              '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
              '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
            ],
            [
              '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
              '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
            ],
            [
              '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
              '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
            ],
            [
              '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
              '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
            ],
            [
              '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
              '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
            ],
            [
              '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
              'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
            ],
            [
              'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
              '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
            ],
            [
              'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
              '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
            ],
            [
              '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
              '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
            ],
            [
              '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
              '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
            ],
            [
              'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
              '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
            ],
            [
              '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
              'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
            ],
            [
              'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
              '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
            ],
            [
              'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
              'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
            ],
            [
              'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
              '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
            ],
            [
              'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
              'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
            ],
            [
              'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
              '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
            ],
            [
              '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
              'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
            ],
            [
              '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
              '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
            ],
            [
              'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
              '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
            ],
            [
              '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
              'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
            ],
            [
              'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
              '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
            ],
            [
              'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
              '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
            ],
            [
              'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
              'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
            ],
            [
              '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
              '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
            ],
            [
              '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
              '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
            ],
            [
              '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
              'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
            ],
            [
              '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
              '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
            ],
            [
              'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
              '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
            ],
            [
              '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
              '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
            ],
            [
              '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
              'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
            ],
            [
              '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
              '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
            ],
            [
              'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
              '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
            ],
            [
              '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
              'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
            ],
            [
              'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
              'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
            ],
            [
              'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
              '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
            ],
            [
              '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
              'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
            ],
            [
              '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
              'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
            ],
            [
              'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
              '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
            ],
            [
              'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
              '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
            ],
            [
              'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
              '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
            ],
            [
              '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
              'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
            ],
            [
              '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
              '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
            ],
            [
              'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
              'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
            ],
            [
              '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
              'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
            ],
            [
              '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
              '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
            ],
            [
              '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
              '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
            ],
            [
              'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
              'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
            ],
            [
              '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
              '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
            ],
            [
              '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
              '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
            ],
            [
              'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
              '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
            ],
            [
              'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
              'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
            ]
          ]
        },
        naf: {
          wnd: 7,
          points: [
            [
              'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
              '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
            ],
            [
              '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
              'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
            ],
            [
              '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
              '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
            ],
            [
              'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
              'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
            ],
            [
              '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
              'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
            ],
            [
              'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
              'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
            ],
            [
              'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
              '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
            ],
            [
              'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
              '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
            ],
            [
              '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
              '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
            ],
            [
              '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
              '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
            ],
            [
              '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
              '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
            ],
            [
              '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
              '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
            ],
            [
              'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
              'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
            ],
            [
              'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
              '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
            ],
            [
              '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
              'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
            ],
            [
              '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
              'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
            ],
            [
              '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
              '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
            ],
            [
              '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
              '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
            ],
            [
              '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
              '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
            ],
            [
              '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
              'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
            ],
            [
              'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
              'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
            ],
            [
              '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
              '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
            ],
            [
              '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
              '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
            ],
            [
              'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
              'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
            ],
            [
              '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
              '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
            ],
            [
              'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
              'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
            ],
            [
              'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
              'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
            ],
            [
              '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
              '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
            ],
            [
              '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
              '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
            ],
            [
              '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
              '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
            ],
            [
              'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
              '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
            ],
            [
              '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
              '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
            ],
            [
              'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
              '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
            ],
            [
              '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
              'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
            ],
            [
              '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
              'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
            ],
            [
              'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
              'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
            ],
            [
              '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
              '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
            ],
            [
              '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
              'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
            ],
            [
              'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
              'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
            ],
            [
              '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
              '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
            ],
            [
              '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
              'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
            ],
            [
              '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
              '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
            ],
            [
              '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
              'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
            ],
            [
              'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
              '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
            ],
            [
              '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
              '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
            ],
            [
              '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
              'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
            ],
            [
              '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
              'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
            ],
            [
              'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
              'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
            ],
            [
              'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
              'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
            ],
            [
              '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
              '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
            ],
            [
              '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
              '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
            ],
            [
              'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
              '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
            ],
            [
              'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
              'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
            ],
            [
              '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
              '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
            ],
            [
              '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
              '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
            ],
            [
              'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
              '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
            ],
            [
              '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
              '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
            ],
            [
              'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
              'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
            ],
            [
              '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
              'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
            ],
            [
              '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
              '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
            ],
            [
              'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
              '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
            ],
            [
              'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
              '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
            ],
            [
              '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
              '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
            ],
            [
              '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
              '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
            ],
            [
              '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
              'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
            ],
            [
              '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
              'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
            ],
            [
              '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
              '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
            ],
            [
              '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
              '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
            ],
            [
              '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
              '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
            ],
            [
              '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
              'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
            ],
            [
              'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
              'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
            ],
            [
              '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
              'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
            ],
            [
              'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
              '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
            ],
            [
              'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
              '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
            ],
            [
              'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
              '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
            ],
            [
              'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
              '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
            ],
            [
              '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
              'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
            ],
            [
              '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
              '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
            ],
            [
              '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
              'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
            ],
            [
              'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
              'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
            ],
            [
              'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
              '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
            ],
            [
              'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
              'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
            ],
            [
              'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
              '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
            ],
            [
              '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
              '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
            ],
            [
              'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
              '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
            ],
            [
              'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
              '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
            ],
            [
              '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
              '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
            ],
            [
              '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
              'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
            ],
            [
              'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
              '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
            ],
            [
              'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
              '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
            ],
            [
              'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
              '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
            ],
            [
              '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
              '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
            ],
            [
              'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
              'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
            ],
            [
              '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
              'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
            ],
            [
              'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
              'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
            ],
            [
              'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
              '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
            ],
            [
              '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
              'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
            ],
            [
              'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
              '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
            ],
            [
              'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
              '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
            ],
            [
              'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
              '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
            ],
            [
              '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
              'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
            ],
            [
              '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
              'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
            ],
            [
              'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
              '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
            ],
            [
              '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
              'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
            ],
            [
              '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
              '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
            ],
            [
              '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
              'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
            ],
            [
              'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
              'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
            ],
            [
              '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
              'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
            ],
            [
              '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
              '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
            ],
            [
              '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
              'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
            ],
            [
              '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
              '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
            ],
            [
              'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
              'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
            ],
            [
              '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
              '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
            ],
            [
              'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
              '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
            ],
            [
              '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
              '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
            ],
            [
              'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
              'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
            ],
            [
              'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
              '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
            ],
            [
              'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
              'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
            ],
            [
              '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
              'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
            ],
            [
              '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
              '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
            ],
            [
              '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
              'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
            ],
            [
              '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
              '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
            ],
            [
              '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
              '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
            ],
            [
              '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
              'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
            ],
            [
              '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
              '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
            ],
            [
              '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
              '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
            ],
            [
              '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
              '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
            ]
          ]
        }
      })),
    n1
  )
}
var d5
function XE() {
  return (
    d5 ||
      ((d5 = 1),
      (function (t) {
        var e = t,
          n = ZE(),
          r = fx(),
          i = Hi(),
          s = i.assert
        function c(d) {
          d.type === 'short'
            ? (this.curve = new r.short(d))
            : d.type === 'edwards'
              ? (this.curve = new r.edwards(d))
              : (this.curve = new r.mont(d)),
            (this.g = this.curve.g),
            (this.n = this.curve.n),
            (this.hash = d.hash),
            s(this.g.validate(), 'Invalid curve'),
            s(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O')
        }
        e.PresetCurve = c
        function u(d, p) {
          Object.defineProperty(e, d, {
            configurable: !0,
            enumerable: !0,
            get: function () {
              var g = new c(p)
              return Object.defineProperty(e, d, { configurable: !0, enumerable: !0, value: g }), g
            }
          })
        }
        u('p192', {
          type: 'short',
          prime: 'p192',
          p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
          a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
          b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
          n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
          hash: n.sha256,
          gRed: !1,
          g: [
            '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
            '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
          ]
        }),
          u('p224', {
            type: 'short',
            prime: 'p224',
            p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
            a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
            b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
            n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
            hash: n.sha256,
            gRed: !1,
            g: [
              'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
              'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
            ]
          }),
          u('p256', {
            type: 'short',
            prime: null,
            p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
            a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
            b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
            n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
            hash: n.sha256,
            gRed: !1,
            g: [
              '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
              '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
            ]
          }),
          u('p384', {
            type: 'short',
            prime: null,
            p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff',
            a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc',
            b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
            n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
            hash: n.sha384,
            gRed: !1,
            g: [
              'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7',
              '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
            ]
          }),
          u('p521', {
            type: 'short',
            prime: null,
            p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff',
            a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc',
            b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
            n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
            hash: n.sha512,
            gRed: !1,
            g: [
              '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
              '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650'
            ]
          }),
          u('curve25519', {
            type: 'mont',
            prime: 'p25519',
            p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
            a: '76d06',
            b: '1',
            n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
            hash: n.sha256,
            gRed: !1,
            g: ['9']
          }),
          u('ed25519', {
            type: 'edwards',
            prime: 'p25519',
            p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
            a: '-1',
            c: '1',
            d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
            n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
            hash: n.sha256,
            gRed: !1,
            g: [
              '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
              '6666666666666666666666666666666666666666666666666666666666666658'
            ]
          })
        var f
        try {
          f = x$()
        } catch {
          f = void 0
        }
        u('secp256k1', {
          type: 'short',
          prime: 'k256',
          p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
          a: '0',
          b: '7',
          n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
          h: '1',
          hash: n.sha256,
          beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
          lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
          basis: [
            { a: '3086d221a7d46bcde86c90e49284eb15', b: '-e4437ed6010e88286f547fa90abfe4c3' },
            { a: '114ca50f7a8e2f3f657c1108d9d44cfd8', b: '3086d221a7d46bcde86c90e49284eb15' }
          ],
          gRed: !1,
          g: [
            '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
            '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
            f
          ]
        })
      })(Vv)),
    Vv
  )
}
var r1, f5
function N$() {
  if (f5) return r1
  f5 = 1
  var t = ZE(),
    e = lx(),
    n = wu()
  function r(i) {
    if (!(this instanceof r)) return new r(i)
    ;(this.hash = i.hash),
      (this.predResist = !!i.predResist),
      (this.outLen = this.hash.outSize),
      (this.minEntropy = i.minEntropy || this.hash.hmacStrength),
      (this._reseed = null),
      (this.reseedInterval = null),
      (this.K = null),
      (this.V = null)
    var s = e.toArray(i.entropy, i.entropyEnc || 'hex'),
      c = e.toArray(i.nonce, i.nonceEnc || 'hex'),
      u = e.toArray(i.pers, i.persEnc || 'hex')
    n(
      s.length >= this.minEntropy / 8,
      'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'
    ),
      this._init(s, c, u)
  }
  return (
    (r1 = r),
    (r.prototype._init = function (s, c, u) {
      var f = s.concat(c).concat(u)
      ;(this.K = new Array(this.outLen / 8)), (this.V = new Array(this.outLen / 8))
      for (var d = 0; d < this.V.length; d++) (this.K[d] = 0), (this.V[d] = 1)
      this._update(f), (this._reseed = 1), (this.reseedInterval = 281474976710656)
    }),
    (r.prototype._hmac = function () {
      return new t.hmac(this.hash, this.K)
    }),
    (r.prototype._update = function (s) {
      var c = this._hmac().update(this.V).update([0])
      s && (c = c.update(s)),
        (this.K = c.digest()),
        (this.V = this._hmac().update(this.V).digest()),
        s &&
          ((this.K = this._hmac().update(this.V).update([1]).update(s).digest()),
          (this.V = this._hmac().update(this.V).digest()))
    }),
    (r.prototype.reseed = function (s, c, u, f) {
      typeof c != 'string' && ((f = u), (u = c), (c = null)),
        (s = e.toArray(s, c)),
        (u = e.toArray(u, f)),
        n(
          s.length >= this.minEntropy / 8,
          'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'
        ),
        this._update(s.concat(u || [])),
        (this._reseed = 1)
    }),
    (r.prototype.generate = function (s, c, u, f) {
      if (this._reseed > this.reseedInterval) throw new Error('Reseed is required')
      typeof c != 'string' && ((f = u), (u = c), (c = null)),
        u && ((u = e.toArray(u, f || 'hex')), this._update(u))
      for (var d = []; d.length < s; )
        (this.V = this._hmac().update(this.V).digest()), (d = d.concat(this.V))
      var p = d.slice(0, s)
      return this._update(u), this._reseed++, e.encode(p, c)
    }),
    r1
  )
}
var i1, h5
function I$() {
  if (h5) return i1
  h5 = 1
  var t = Fa(),
    e = Hi(),
    n = e.assert
  function r(i, s) {
    ;(this.ec = i),
      (this.priv = null),
      (this.pub = null),
      s.priv && this._importPrivate(s.priv, s.privEnc),
      s.pub && this._importPublic(s.pub, s.pubEnc)
  }
  return (
    (i1 = r),
    (r.fromPublic = function (s, c, u) {
      return c instanceof r ? c : new r(s, { pub: c, pubEnc: u })
    }),
    (r.fromPrivate = function (s, c, u) {
      return c instanceof r ? c : new r(s, { priv: c, privEnc: u })
    }),
    (r.prototype.validate = function () {
      var s = this.getPublic()
      return s.isInfinity()
        ? { result: !1, reason: 'Invalid public key' }
        : s.validate()
          ? s.mul(this.ec.curve.n).isInfinity()
            ? { result: !0, reason: null }
            : { result: !1, reason: 'Public key * N != O' }
          : { result: !1, reason: 'Public key is not a point' }
    }),
    (r.prototype.getPublic = function (s, c) {
      return (
        typeof s == 'string' && ((c = s), (s = null)),
        this.pub || (this.pub = this.ec.g.mul(this.priv)),
        c ? this.pub.encode(c, s) : this.pub
      )
    }),
    (r.prototype.getPrivate = function (s) {
      return s === 'hex' ? this.priv.toString(16, 2) : this.priv
    }),
    (r.prototype._importPrivate = function (s, c) {
      ;(this.priv = new t(s, c || 16)), (this.priv = this.priv.umod(this.ec.curve.n))
    }),
    (r.prototype._importPublic = function (s, c) {
      if (s.x || s.y) {
        this.ec.curve.type === 'mont'
          ? n(s.x, 'Need x coordinate')
          : (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') &&
            n(s.x && s.y, 'Need both x and y coordinate'),
          (this.pub = this.ec.curve.point(s.x, s.y))
        return
      }
      this.pub = this.ec.curve.decodePoint(s, c)
    }),
    (r.prototype.derive = function (s) {
      return s.validate() || n(s.validate(), 'public point not validated'), s.mul(this.priv).getX()
    }),
    (r.prototype.sign = function (s, c, u) {
      return this.ec.sign(s, this, c, u)
    }),
    (r.prototype.verify = function (s, c, u) {
      return this.ec.verify(s, c, this, void 0, u)
    }),
    (r.prototype.inspect = function () {
      return (
        '<Key priv: ' +
        (this.priv && this.priv.toString(16, 2)) +
        ' pub: ' +
        (this.pub && this.pub.inspect()) +
        ' >'
      )
    }),
    i1
  )
}
var s1, p5
function O$() {
  if (p5) return s1
  p5 = 1
  var t = Fa(),
    e = Hi(),
    n = e.assert
  function r(f, d) {
    if (f instanceof r) return f
    this._importDER(f, d) ||
      (n(f.r && f.s, 'Signature without r or s'),
      (this.r = new t(f.r, 16)),
      (this.s = new t(f.s, 16)),
      f.recoveryParam === void 0
        ? (this.recoveryParam = null)
        : (this.recoveryParam = f.recoveryParam))
  }
  s1 = r
  function i() {
    this.place = 0
  }
  function s(f, d) {
    var p = f[d.place++]
    if (!(p & 128)) return p
    var g = p & 15
    if (g === 0 || g > 4 || f[d.place] === 0) return !1
    for (var m = 0, y = 0, A = d.place; y < g; y++, A++) (m <<= 8), (m |= f[A]), (m >>>= 0)
    return m <= 127 ? !1 : ((d.place = A), m)
  }
  function c(f) {
    for (var d = 0, p = f.length - 1; !f[d] && !(f[d + 1] & 128) && d < p; ) d++
    return d === 0 ? f : f.slice(d)
  }
  r.prototype._importDER = function (d, p) {
    d = e.toArray(d, p)
    var g = new i()
    if (d[g.place++] !== 48) return !1
    var m = s(d, g)
    if (m === !1 || m + g.place !== d.length || d[g.place++] !== 2) return !1
    var y = s(d, g)
    if (y === !1 || (d[g.place] & 128) !== 0) return !1
    var A = d.slice(g.place, y + g.place)
    if (((g.place += y), d[g.place++] !== 2)) return !1
    var E = s(d, g)
    if (E === !1 || d.length !== E + g.place || (d[g.place] & 128) !== 0) return !1
    var x = d.slice(g.place, E + g.place)
    if (A[0] === 0)
      if (A[1] & 128) A = A.slice(1)
      else return !1
    if (x[0] === 0)
      if (x[1] & 128) x = x.slice(1)
      else return !1
    return (this.r = new t(A)), (this.s = new t(x)), (this.recoveryParam = null), !0
  }
  function u(f, d) {
    if (d < 128) {
      f.push(d)
      return
    }
    var p = 1 + ((Math.log(d) / Math.LN2) >>> 3)
    for (f.push(p | 128); --p; ) f.push((d >>> (p << 3)) & 255)
    f.push(d)
  }
  return (
    (r.prototype.toDER = function (d) {
      var p = this.r.toArray(),
        g = this.s.toArray()
      for (
        p[0] & 128 && (p = [0].concat(p)), g[0] & 128 && (g = [0].concat(g)), p = c(p), g = c(g);
        !g[0] && !(g[1] & 128);

      )
        g = g.slice(1)
      var m = [2]
      u(m, p.length), (m = m.concat(p)), m.push(2), u(m, g.length)
      var y = m.concat(g),
        A = [48]
      return u(A, y.length), (A = A.concat(y)), e.encode(A, d)
    }),
    s1
  )
}
var a1, g5
function R$() {
  if (g5) return a1
  g5 = 1
  var t = Fa(),
    e = N$(),
    n = Hi(),
    r = XE(),
    i = dx(),
    s = n.assert,
    c = I$(),
    u = O$()
  function f(d) {
    if (!(this instanceof f)) return new f(d)
    typeof d == 'string' &&
      (s(Object.prototype.hasOwnProperty.call(r, d), 'Unknown curve ' + d), (d = r[d])),
      d instanceof r.PresetCurve && (d = { curve: d }),
      (this.curve = d.curve.curve),
      (this.n = this.curve.n),
      (this.nh = this.n.ushrn(1)),
      (this.g = this.curve.g),
      (this.g = d.curve.g),
      this.g.precompute(d.curve.n.bitLength() + 1),
      (this.hash = d.hash || d.curve.hash)
  }
  return (
    (a1 = f),
    (f.prototype.keyPair = function (p) {
      return new c(this, p)
    }),
    (f.prototype.keyFromPrivate = function (p, g) {
      return c.fromPrivate(this, p, g)
    }),
    (f.prototype.keyFromPublic = function (p, g) {
      return c.fromPublic(this, p, g)
    }),
    (f.prototype.genKeyPair = function (p) {
      p || (p = {})
      for (
        var g = new e({
            hash: this.hash,
            pers: p.pers,
            persEnc: p.persEnc || 'utf8',
            entropy: p.entropy || i(this.hash.hmacStrength),
            entropyEnc: (p.entropy && p.entropyEnc) || 'utf8',
            nonce: this.n.toArray()
          }),
          m = this.n.byteLength(),
          y = this.n.sub(new t(2));
        ;

      ) {
        var A = new t(g.generate(m))
        if (!(A.cmp(y) > 0)) return A.iaddn(1), this.keyFromPrivate(A)
      }
    }),
    (f.prototype._truncateToN = function (p, g, m) {
      var y
      if (t.isBN(p) || typeof p == 'number') (p = new t(p, 16)), (y = p.byteLength())
      else if (typeof p == 'object') (y = p.length), (p = new t(p, 16))
      else {
        var A = p.toString()
        ;(y = (A.length + 1) >>> 1), (p = new t(A, 16))
      }
      typeof m != 'number' && (m = y * 8)
      var E = m - this.n.bitLength()
      return E > 0 && (p = p.ushrn(E)), !g && p.cmp(this.n) >= 0 ? p.sub(this.n) : p
    }),
    (f.prototype.sign = function (p, g, m, y) {
      if (
        (typeof m == 'object' && ((y = m), (m = null)),
        y || (y = {}),
        typeof p != 'string' && typeof p != 'number' && !t.isBN(p))
      ) {
        s(
          typeof p == 'object' && p && typeof p.length == 'number',
          'Expected message to be an array-like, a hex string, or a BN instance'
        ),
          s(p.length >>> 0 === p.length)
        for (var A = 0; A < p.length; A++) s((p[A] & 255) === p[A])
      }
      ;(g = this.keyFromPrivate(g, m)),
        (p = this._truncateToN(p, !1, y.msgBitLength)),
        s(!p.isNeg(), 'Can not sign a negative message')
      var E = this.n.byteLength(),
        x = g.getPrivate().toArray('be', E),
        O = p.toArray('be', E)
      s(new t(O).eq(p), 'Can not sign message')
      for (
        var I = new e({
            hash: this.hash,
            entropy: x,
            nonce: O,
            pers: y.pers,
            persEnc: y.persEnc || 'utf8'
          }),
          M = this.n.sub(new t(1)),
          $ = 0;
        ;
        $++
      ) {
        var D = y.k ? y.k($) : new t(I.generate(this.n.byteLength()))
        if (((D = this._truncateToN(D, !0)), !(D.cmpn(1) <= 0 || D.cmp(M) >= 0))) {
          var R = this.g.mul(D)
          if (!R.isInfinity()) {
            var z = R.getX(),
              G = z.umod(this.n)
            if (G.cmpn(0) !== 0) {
              var j = D.invm(this.n).mul(G.mul(g.getPrivate()).iadd(p))
              if (((j = j.umod(this.n)), j.cmpn(0) !== 0)) {
                var V = (R.getY().isOdd() ? 1 : 0) | (z.cmp(G) !== 0 ? 2 : 0)
                return (
                  y.canonical && j.cmp(this.nh) > 0 && ((j = this.n.sub(j)), (V ^= 1)),
                  new u({ r: G, s: j, recoveryParam: V })
                )
              }
            }
          }
        }
      }
    }),
    (f.prototype.verify = function (p, g, m, y, A) {
      A || (A = {}),
        (p = this._truncateToN(p, !1, A.msgBitLength)),
        (m = this.keyFromPublic(m, y)),
        (g = new u(g, 'hex'))
      var E = g.r,
        x = g.s
      if (E.cmpn(1) < 0 || E.cmp(this.n) >= 0 || x.cmpn(1) < 0 || x.cmp(this.n) >= 0) return !1
      var O = x.invm(this.n),
        I = O.mul(p).umod(this.n),
        M = O.mul(E).umod(this.n),
        $
      return this.curve._maxwellTrick
        ? (($ = this.g.jmulAdd(I, m.getPublic(), M)), $.isInfinity() ? !1 : $.eqXToP(E))
        : (($ = this.g.mulAdd(I, m.getPublic(), M)),
          $.isInfinity() ? !1 : $.getX().umod(this.n).cmp(E) === 0)
    }),
    (f.prototype.recoverPubKey = function (d, p, g, m) {
      s((3 & g) === g, 'The recovery param is more than two bits'), (p = new u(p, m))
      var y = this.n,
        A = new t(d),
        E = p.r,
        x = p.s,
        O = g & 1,
        I = g >> 1
      if (E.cmp(this.curve.p.umod(this.curve.n)) >= 0 && I)
        throw new Error('Unable to find sencond key candinate')
      I ? (E = this.curve.pointFromX(E.add(this.curve.n), O)) : (E = this.curve.pointFromX(E, O))
      var M = p.r.invm(y),
        $ = y.sub(A).mul(M).umod(y),
        D = x.mul(M).umod(y)
      return this.g.mulAdd($, E, D)
    }),
    (f.prototype.getKeyRecoveryParam = function (d, p, g, m) {
      if (((p = new u(p, m)), p.recoveryParam !== null)) return p.recoveryParam
      for (var y = 0; y < 4; y++) {
        var A
        try {
          A = this.recoverPubKey(d, p, y)
        } catch {
          continue
        }
        if (A.eq(g)) return y
      }
      throw new Error('Unable to find valid recovery factor')
    }),
    a1
  )
}
var o1, m5
function D$() {
  if (m5) return o1
  m5 = 1
  var t = Hi(),
    e = t.assert,
    n = t.parseBytes,
    r = t.cachedProperty
  function i(s, c) {
    ;(this.eddsa = s),
      (this._secret = n(c.secret)),
      s.isPoint(c.pub) ? (this._pub = c.pub) : (this._pubBytes = n(c.pub))
  }
  return (
    (i.fromPublic = function (c, u) {
      return u instanceof i ? u : new i(c, { pub: u })
    }),
    (i.fromSecret = function (c, u) {
      return u instanceof i ? u : new i(c, { secret: u })
    }),
    (i.prototype.secret = function () {
      return this._secret
    }),
    r(i, 'pubBytes', function () {
      return this.eddsa.encodePoint(this.pub())
    }),
    r(i, 'pub', function () {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
    }),
    r(i, 'privBytes', function () {
      var c = this.eddsa,
        u = this.hash(),
        f = c.encodingLength - 1,
        d = u.slice(0, c.encodingLength)
      return (d[0] &= 248), (d[f] &= 127), (d[f] |= 64), d
    }),
    r(i, 'priv', function () {
      return this.eddsa.decodeInt(this.privBytes())
    }),
    r(i, 'hash', function () {
      return this.eddsa.hash().update(this.secret()).digest()
    }),
    r(i, 'messagePrefix', function () {
      return this.hash().slice(this.eddsa.encodingLength)
    }),
    (i.prototype.sign = function (c) {
      return e(this._secret, 'KeyPair can only verify'), this.eddsa.sign(c, this)
    }),
    (i.prototype.verify = function (c, u) {
      return this.eddsa.verify(c, u, this)
    }),
    (i.prototype.getSecret = function (c) {
      return e(this._secret, 'KeyPair is public only'), t.encode(this.secret(), c)
    }),
    (i.prototype.getPublic = function (c) {
      return t.encode(this.pubBytes(), c)
    }),
    (o1 = i),
    o1
  )
}
var c1, b5
function P$() {
  if (b5) return c1
  b5 = 1
  var t = Fa(),
    e = Hi(),
    n = e.assert,
    r = e.cachedProperty,
    i = e.parseBytes
  function s(c, u) {
    ;(this.eddsa = c),
      typeof u != 'object' && (u = i(u)),
      Array.isArray(u) &&
        (n(u.length === c.encodingLength * 2, 'Signature has invalid size'),
        (u = { R: u.slice(0, c.encodingLength), S: u.slice(c.encodingLength) })),
      n(u.R && u.S, 'Signature without R or S'),
      c.isPoint(u.R) && (this._R = u.R),
      u.S instanceof t && (this._S = u.S),
      (this._Rencoded = Array.isArray(u.R) ? u.R : u.Rencoded),
      (this._Sencoded = Array.isArray(u.S) ? u.S : u.Sencoded)
  }
  return (
    r(s, 'S', function () {
      return this.eddsa.decodeInt(this.Sencoded())
    }),
    r(s, 'R', function () {
      return this.eddsa.decodePoint(this.Rencoded())
    }),
    r(s, 'Rencoded', function () {
      return this.eddsa.encodePoint(this.R())
    }),
    r(s, 'Sencoded', function () {
      return this.eddsa.encodeInt(this.S())
    }),
    (s.prototype.toBytes = function () {
      return this.Rencoded().concat(this.Sencoded())
    }),
    (s.prototype.toHex = function () {
      return e.encode(this.toBytes(), 'hex').toUpperCase()
    }),
    (c1 = s),
    c1
  )
}
var u1, y5
function M$() {
  if (y5) return u1
  y5 = 1
  var t = ZE(),
    e = XE(),
    n = Hi(),
    r = n.assert,
    i = n.parseBytes,
    s = D$(),
    c = P$()
  function u(f) {
    if ((r(f === 'ed25519', 'only tested with ed25519 so far'), !(this instanceof u)))
      return new u(f)
    ;(f = e[f].curve),
      (this.curve = f),
      (this.g = f.g),
      this.g.precompute(f.n.bitLength() + 1),
      (this.pointClass = f.point().constructor),
      (this.encodingLength = Math.ceil(f.n.bitLength() / 8)),
      (this.hash = t.sha512)
  }
  return (
    (u1 = u),
    (u.prototype.sign = function (d, p) {
      d = i(d)
      var g = this.keyFromSecret(p),
        m = this.hashInt(g.messagePrefix(), d),
        y = this.g.mul(m),
        A = this.encodePoint(y),
        E = this.hashInt(A, g.pubBytes(), d).mul(g.priv()),
        x = m.add(E).umod(this.curve.n)
      return this.makeSignature({ R: y, S: x, Rencoded: A })
    }),
    (u.prototype.verify = function (d, p, g) {
      if (((d = i(d)), (p = this.makeSignature(p)), p.S().gte(p.eddsa.curve.n) || p.S().isNeg()))
        return !1
      var m = this.keyFromPublic(g),
        y = this.hashInt(p.Rencoded(), m.pubBytes(), d),
        A = this.g.mul(p.S()),
        E = p.R().add(m.pub().mul(y))
      return E.eq(A)
    }),
    (u.prototype.hashInt = function () {
      for (var d = this.hash(), p = 0; p < arguments.length; p++) d.update(arguments[p])
      return n.intFromLE(d.digest()).umod(this.curve.n)
    }),
    (u.prototype.keyFromPublic = function (d) {
      return s.fromPublic(this, d)
    }),
    (u.prototype.keyFromSecret = function (d) {
      return s.fromSecret(this, d)
    }),
    (u.prototype.makeSignature = function (d) {
      return d instanceof c ? d : new c(this, d)
    }),
    (u.prototype.encodePoint = function (d) {
      var p = d.getY().toArray('le', this.encodingLength)
      return (p[this.encodingLength - 1] |= d.getX().isOdd() ? 128 : 0), p
    }),
    (u.prototype.decodePoint = function (d) {
      d = n.parseBytes(d)
      var p = d.length - 1,
        g = d.slice(0, p).concat(d[p] & -129),
        m = (d[p] & 128) !== 0,
        y = n.intFromLE(g)
      return this.curve.pointFromY(y, m)
    }),
    (u.prototype.encodeInt = function (d) {
      return d.toArray('le', this.encodingLength)
    }),
    (u.prototype.decodeInt = function (d) {
      return n.intFromLE(d)
    }),
    (u.prototype.isPoint = function (d) {
      return d instanceof this.pointClass
    }),
    u1
  )
}
var v5
function k$() {
  return (
    v5 ||
      ((v5 = 1),
      (function (t) {
        var e = t
        ;(e.version = p$.version),
          (e.utils = Hi()),
          (e.rand = dx()),
          (e.curve = fx()),
          (e.curves = XE()),
          (e.ec = R$()),
          (e.eddsa = M$())
      })(Bv)),
    Bv
  )
}
var U$ = k$()
const B$ = {
  waku: {
    publish: 'waku_publish',
    batchPublish: 'waku_batchPublish',
    subscribe: 'waku_subscribe',
    batchSubscribe: 'waku_batchSubscribe',
    subscription: 'waku_subscription',
    unsubscribe: 'waku_unsubscribe',
    batchUnsubscribe: 'waku_batchUnsubscribe',
    batchFetchMessages: 'waku_batchFetchMessages'
  },
  irn: {
    publish: 'irn_publish',
    batchPublish: 'irn_batchPublish',
    subscribe: 'irn_subscribe',
    batchSubscribe: 'irn_batchSubscribe',
    subscription: 'irn_subscription',
    unsubscribe: 'irn_unsubscribe',
    batchUnsubscribe: 'irn_batchUnsubscribe',
    batchFetchMessages: 'irn_batchFetchMessages'
  },
  iridium: {
    publish: 'iridium_publish',
    batchPublish: 'iridium_batchPublish',
    subscribe: 'iridium_subscribe',
    batchSubscribe: 'iridium_batchSubscribe',
    subscription: 'iridium_subscription',
    unsubscribe: 'iridium_unsubscribe',
    batchUnsubscribe: 'iridium_batchUnsubscribe',
    batchFetchMessages: 'iridium_batchFetchMessages'
  }
}
var L$ = {}
const $$ = ':'
function Ml(t) {
  const [e, n] = t.split($$)
  return { namespace: e, reference: n }
}
function mx(t, e) {
  return t.includes(':') ? [t] : e.chains || []
}
const F$ = 'ReactNative',
  mi = { reactNative: 'react-native', node: 'node', browser: 'browser', unknown: 'unknown' },
  j$ = 'js'
function Qg() {
  return typeof process < 'u' && typeof process.versions < 'u' && typeof process.versions.node < 'u'
}
function Yo() {
  return !Jc.getDocument() && !!Jc.getNavigator() && navigator.product === F$
}
function z$() {
  return (
    Yo() &&
    typeof global < 'u' &&
    typeof (global == null ? void 0 : global.Platform) < 'u' &&
    (global == null ? void 0 : global.Platform.OS) === 'android'
  )
}
function q$() {
  return (
    Yo() &&
    typeof global < 'u' &&
    typeof (global == null ? void 0 : global.Platform) < 'u' &&
    (global == null ? void 0 : global.Platform.OS) === 'ios'
  )
}
function wp() {
  return !Qg() && !!Jc.getNavigator() && !!Jc.getDocument()
}
function Ep() {
  return Yo() ? mi.reactNative : Qg() ? mi.node : wp() ? mi.browser : mi.unknown
}
function w5() {
  var t
  try {
    return Yo() &&
      typeof global < 'u' &&
      typeof (global == null ? void 0 : global.Application) < 'u'
      ? (t = global.Application) == null
        ? void 0
        : t.applicationId
      : void 0
  } catch {
    return
  }
}
function H$(t, e) {
  const n = new URLSearchParams(t)
  for (const r of Object.keys(e).sort())
    if (e.hasOwnProperty(r)) {
      const i = e[r]
      i !== void 0 && n.set(r, i)
    }
  return n.toString()
}
function bx() {
  return PU.getWindowMetadata() || { name: '', description: '', url: '', icons: [''] }
}
function G$() {
  if (
    Ep() === mi.reactNative &&
    typeof global < 'u' &&
    typeof (global == null ? void 0 : global.Platform) < 'u'
  ) {
    const { OS: n, Version: r } = global.Platform
    return [n, r].join('-')
  }
  const t = TU()
  if (t === null) return 'unknown'
  const e = t.os ? t.os.replace(' ', '').toLowerCase() : 'unknown'
  return t.type === 'browser' ? [e, t.name, t.version].join('-') : [e, t.version].join('-')
}
function V$() {
  var t
  const e = Ep()
  return e === mi.browser
    ? [e, ((t = Jc.getLocation()) == null ? void 0 : t.host) || 'unknown'].join(':')
    : e
}
function yx(t, e, n) {
  const r = G$(),
    i = V$()
  return [[t, e].join('-'), [j$, n].join('-'), r, i].join('/')
}
function K$({
  protocol: t,
  version: e,
  relayUrl: n,
  sdkVersion: r,
  auth: i,
  projectId: s,
  useOnCloseEvent: c,
  bundleId: u,
  packageName: f
}) {
  const d = n.split('?'),
    p = yx(t, e, r),
    g = {
      auth: i,
      ua: p,
      projectId: s,
      useOnCloseEvent: c,
      packageName: f || void 0,
      bundleId: u || void 0
    },
    m = H$(d[1] || '', g)
  return d[0] + '?' + m
}
function Rc(t, e) {
  return t.filter(n => e.includes(n)).length === t.length
}
function _w(t) {
  return Object.fromEntries(t.entries())
}
function Cw(t) {
  return new Map(Object.entries(t))
}
function Sc(t = ge.FIVE_MINUTES, e) {
  const n = ge.toMiliseconds(t || ge.FIVE_MINUTES)
  let r, i, s, c
  return {
    resolve: u => {
      s && r && (clearTimeout(s), r(u), (c = Promise.resolve(u)))
    },
    reject: u => {
      s && i && (clearTimeout(s), i(u))
    },
    done: () =>
      new Promise((u, f) => {
        if (c) return u(c)
        ;(s = setTimeout(() => {
          const d = new Error(e)
          ;(c = Promise.reject(d)), f(d)
        }, n)),
          (r = u),
          (i = f)
      })
  }
}
function Mo(t, e, n) {
  return new Promise(async (r, i) => {
    const s = setTimeout(() => i(new Error(n)), e)
    try {
      const c = await t
      r(c)
    } catch (c) {
      i(c)
    }
    clearTimeout(s)
  })
}
function vx(t, e) {
  if (typeof e == 'string' && e.startsWith(`${t}:`)) return e
  if (t.toLowerCase() === 'topic') {
    if (typeof e != 'string')
      throw new Error('Value must be "string" for expirer target type: topic')
    return `topic:${e}`
  } else if (t.toLowerCase() === 'id') {
    if (typeof e != 'number') throw new Error('Value must be "number" for expirer target type: id')
    return `id:${e}`
  }
  throw new Error(`Unknown expirer target type: ${t}`)
}
function W$(t) {
  return vx('topic', t)
}
function Q$(t) {
  return vx('id', t)
}
function wx(t) {
  const [e, n] = t.split(':'),
    r = { id: void 0, topic: void 0 }
  if (e === 'topic' && typeof n == 'string') r.topic = n
  else if (e === 'id' && Number.isInteger(Number(n))) r.id = Number(n)
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n}`)
  return r
}
function Zn(t, e) {
  return ge.fromMiliseconds(Date.now() + ge.toMiliseconds(t))
}
function Eo(t) {
  return Date.now() >= ge.toMiliseconds(t)
}
function Pt(t, e) {
  return `${t}${e ? `:${e}` : ''}`
}
function xg(t = [], e = []) {
  return [...new Set([...t, ...e])]
}
async function Y$({ id: t, topic: e, wcDeepLink: n }) {
  var r
  try {
    if (!n) return
    const i = typeof n == 'string' ? JSON.parse(n) : n,
      s = i == null ? void 0 : i.href
    if (typeof s != 'string') return
    const c = Z$(s, t, e),
      u = Ep()
    if (u === mi.browser) {
      if (!((r = Jc.getDocument()) != null && r.hasFocus())) {
        console.warn('Document does not have focus, skipping deeplink.')
        return
      }
      X$(c)
    } else
      u === mi.reactNative &&
        typeof (global == null ? void 0 : global.Linking) < 'u' &&
        (await global.Linking.openURL(c))
  } catch (i) {
    console.error(i)
  }
}
function Z$(t, e, n) {
  const r = `requestId=${e}&sessionTopic=${n}`
  t.endsWith('/') && (t = t.slice(0, -1))
  let i = `${t}`
  if (t.startsWith('https://t.me')) {
    const s = t.includes('?') ? '&startapp=' : '?startapp='
    i = `${i}${s}${nF(r, !0)}`
  } else i = `${i}/wc?${r}`
  return i
}
function X$(t) {
  let e = '_self'
  tF()
    ? (e = '_top')
    : (eF() || t.startsWith('https://') || t.startsWith('http://')) && (e = '_blank'),
    window.open(t, e, 'noreferrer noopener')
}
async function J$(t, e) {
  let n = ''
  try {
    if (wp() && ((n = localStorage.getItem(e)), n)) return n
    n = await t.getItem(e)
  } catch (r) {
    console.error(r)
  }
  return n
}
function E5(t, e) {
  if (!t.includes(e)) return null
  const n = t.split(/([&,?,=])/),
    r = n.indexOf(e)
  return n[r + 2]
}
function A5() {
  return typeof crypto < 'u' && crypto != null && crypto.randomUUID
    ? crypto.randomUUID()
    : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, t => {
        const e = (Math.random() * 16) | 0
        return (t === 'x' ? e : (e & 3) | 8).toString(16)
      })
}
function JE() {
  return typeof process < 'u' && L$.IS_VITEST === 'true'
}
function eF() {
  return (
    typeof window < 'u' &&
    (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto)
  )
}
function tF() {
  try {
    return window.self !== window.top
  } catch {
    return !1
  }
}
function nF(t, e = !1) {
  const n = Buffer.from(t).toString('base64')
  return e ? n.replace(/[=]/g, '') : n
}
function Ex(t) {
  return Buffer.from(t, 'base64').toString('utf-8')
}
function rF(t) {
  return new Promise(e => setTimeout(e, t))
}
function Eh(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error('positive integer expected, got ' + t)
}
function iF(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function km(t, ...e) {
  if (!iF(t)) throw new Error('Uint8Array expected')
  if (e.length > 0 && !e.includes(t.length))
    throw new Error('Uint8Array expected of length ' + e + ', got length=' + t.length)
}
function e2(t) {
  if (typeof t != 'function' || typeof t.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor')
  Eh(t.outputLen), Eh(t.blockLen)
}
function td(t, e = !0) {
  if (t.destroyed) throw new Error('Hash instance has been destroyed')
  if (e && t.finished) throw new Error('Hash#digest() has already been called')
}
function Ax(t, e) {
  km(t)
  const n = e.outputLen
  if (t.length < n) throw new Error('digestInto() expects output buffer of length at least ' + n)
}
const ig = BigInt(2 ** 32 - 1),
  _5 = BigInt(32)
function sF(t, e = !1) {
  return e
    ? { h: Number(t & ig), l: Number((t >> _5) & ig) }
    : { h: Number((t >> _5) & ig) | 0, l: Number(t & ig) | 0 }
}
function aF(t, e = !1) {
  let n = new Uint32Array(t.length),
    r = new Uint32Array(t.length)
  for (let i = 0; i < t.length; i++) {
    const { h: s, l: c } = sF(t[i], e)
    ;[n[i], r[i]] = [s, c]
  }
  return [n, r]
}
const oF = (t, e, n) => (t << n) | (e >>> (32 - n)),
  cF = (t, e, n) => (e << n) | (t >>> (32 - n)),
  uF = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
  lF = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n)),
  ul = typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0
function dF(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4))
}
function l1(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength)
}
function Ns(t, e) {
  return (t << (32 - e)) | (t >>> e)
}
const C5 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68
function fF(t) {
  return ((t << 24) & 4278190080) | ((t << 8) & 16711680) | ((t >>> 8) & 65280) | ((t >>> 24) & 255)
}
function S5(t) {
  for (let e = 0; e < t.length; e++) t[e] = fF(t[e])
}
function hF(t) {
  if (typeof t != 'string') throw new Error('utf8ToBytes expected string, got ' + typeof t)
  return new Uint8Array(new TextEncoder().encode(t))
}
function nd(t) {
  return typeof t == 'string' && (t = hF(t)), km(t), t
}
let t2 = class {
  clone() {
    return this._cloneInto()
  }
}
function _x(t) {
  const e = r => t().update(nd(r)).digest(),
    n = t()
  return (e.outputLen = n.outputLen), (e.blockLen = n.blockLen), (e.create = () => t()), e
}
function Ap(t = 32) {
  if (ul && typeof ul.getRandomValues == 'function') return ul.getRandomValues(new Uint8Array(t))
  if (ul && typeof ul.randomBytes == 'function') return ul.randomBytes(t)
  throw new Error('crypto.getRandomValues must be defined')
}
const Cx = [],
  Sx = [],
  Tx = [],
  pF = BigInt(0),
  Ff = BigInt(1),
  gF = BigInt(2),
  mF = BigInt(7),
  bF = BigInt(256),
  yF = BigInt(113)
for (let t = 0, e = Ff, n = 1, r = 0; t < 24; t++) {
  ;([n, r] = [r, (2 * n + 3 * r) % 5]),
    Cx.push(2 * (5 * r + n)),
    Sx.push((((t + 1) * (t + 2)) / 2) % 64)
  let i = pF
  for (let s = 0; s < 7; s++)
    (e = ((e << Ff) ^ ((e >> mF) * yF)) % bF), e & gF && (i ^= Ff << ((Ff << BigInt(s)) - Ff))
  Tx.push(i)
}
const [vF, wF] = aF(Tx, !0),
  T5 = (t, e, n) => (n > 32 ? uF(t, e, n) : oF(t, e, n)),
  x5 = (t, e, n) => (n > 32 ? lF(t, e, n) : cF(t, e, n))
function EF(t, e = 24) {
  const n = new Uint32Array(10)
  for (let r = 24 - e; r < 24; r++) {
    for (let c = 0; c < 10; c++) n[c] = t[c] ^ t[c + 10] ^ t[c + 20] ^ t[c + 30] ^ t[c + 40]
    for (let c = 0; c < 10; c += 2) {
      const u = (c + 8) % 10,
        f = (c + 2) % 10,
        d = n[f],
        p = n[f + 1],
        g = T5(d, p, 1) ^ n[u],
        m = x5(d, p, 1) ^ n[u + 1]
      for (let y = 0; y < 50; y += 10) (t[c + y] ^= g), (t[c + y + 1] ^= m)
    }
    let i = t[2],
      s = t[3]
    for (let c = 0; c < 24; c++) {
      const u = Sx[c],
        f = T5(i, s, u),
        d = x5(i, s, u),
        p = Cx[c]
      ;(i = t[p]), (s = t[p + 1]), (t[p] = f), (t[p + 1] = d)
    }
    for (let c = 0; c < 50; c += 10) {
      for (let u = 0; u < 10; u++) n[u] = t[c + u]
      for (let u = 0; u < 10; u++) t[c + u] ^= ~n[(u + 2) % 10] & n[(u + 4) % 10]
    }
    ;(t[0] ^= vF[r]), (t[1] ^= wF[r])
  }
  n.fill(0)
}
let AF = class xx extends t2 {
  constructor(e, n, r, i = !1, s = 24) {
    if (
      (super(),
      (this.blockLen = e),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = i),
      (this.rounds = s),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      Eh(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error('Sha3 supports only keccak-f1600 function')
    ;(this.state = new Uint8Array(200)), (this.state32 = dF(this.state))
  }
  keccak() {
    C5 || S5(this.state32),
      EF(this.state32, this.rounds),
      C5 || S5(this.state32),
      (this.posOut = 0),
      (this.pos = 0)
  }
  update(e) {
    td(this)
    const { blockLen: n, state: r } = this
    e = nd(e)
    const i = e.length
    for (let s = 0; s < i; ) {
      const c = Math.min(n - this.pos, i - s)
      for (let u = 0; u < c; u++) r[this.pos++] ^= e[s++]
      this.pos === n && this.keccak()
    }
    return this
  }
  finish() {
    if (this.finished) return
    this.finished = !0
    const { state: e, suffix: n, pos: r, blockLen: i } = this
    ;(e[r] ^= n), (n & 128) !== 0 && r === i - 1 && this.keccak(), (e[i - 1] ^= 128), this.keccak()
  }
  writeInto(e) {
    td(this, !1), km(e), this.finish()
    const n = this.state,
      { blockLen: r } = this
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= r && this.keccak()
      const c = Math.min(r - this.posOut, s - i)
      e.set(n.subarray(this.posOut, this.posOut + c), i), (this.posOut += c), (i += c)
    }
    return e
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error('XOF is not possible for this instance')
    return this.writeInto(e)
  }
  xof(e) {
    return Eh(e), this.xofInto(new Uint8Array(e))
  }
  digestInto(e) {
    if ((Ax(e, this), this.finished)) throw new Error('digest() was already called')
    return this.writeInto(e), this.destroy(), e
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen))
  }
  destroy() {
    ;(this.destroyed = !0), this.state.fill(0)
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: i, rounds: s, enableXOF: c } = this
    return (
      e || (e = new xx(n, r, i, c, s)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = s),
      (e.suffix = r),
      (e.outputLen = i),
      (e.enableXOF = c),
      (e.destroyed = this.destroyed),
      e
    )
  }
}
const _F = (t, e, n) => _x(() => new AF(e, t, n)),
  CF = _F(1, 136, 256 / 8),
  SF = 'https://rpc.walletconnect.org/v1'
function Nx(t) {
  const e = `Ethereum Signed Message:
${t.length}`,
    n = new TextEncoder().encode(e + t)
  return '0x' + Buffer.from(CF(n)).toString('hex')
}
async function TF(t, e, n, r, i, s) {
  switch (n.t) {
    case 'eip191':
      return await xF(t, e, n.s)
    case 'eip1271':
      return await NF(t, e, n.s, r, i, s)
    default:
      throw new Error(
        `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n.t}`
      )
  }
}
async function xF(t, e, n) {
  return (await oL({ hash: Nx(e), signature: n })).toLowerCase() === t.toLowerCase()
}
async function NF(t, e, n, r, i, s) {
  const c = Ml(r)
  if (!c.namespace || !c.reference)
    throw new Error(
      `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`
    )
  try {
    const u = '0x1626ba7e',
      f = '0000000000000000000000000000000000000000000000000000000000000040',
      d = '0000000000000000000000000000000000000000000000000000000000000041',
      p = n.substring(2),
      g = Nx(e).substring(2),
      m = u + g + f + d + p,
      y = await fetch(`${s || SF}/?chainId=${r}&projectId=${i}`, {
        method: 'POST',
        body: JSON.stringify({
          id: IF(),
          jsonrpc: '2.0',
          method: 'eth_call',
          params: [{ to: t, data: m }, 'latest']
        })
      }),
      { result: A } = await y.json()
    return A ? A.slice(0, u.length).toLowerCase() === u.toLowerCase() : !1
  } catch (u) {
    return console.error('isValidEip1271Signature: ', u), !1
  }
}
function IF() {
  return Date.now() + Math.floor(Math.random() * 1e3)
}
function OF(t) {
  const e = atob(t),
    n = new Uint8Array(e.length)
  for (let c = 0; c < e.length; c++) n[c] = e.charCodeAt(c)
  const r = n[0]
  if (r === 0) throw new Error('No signatures found')
  const i = 1 + r * 64
  if (n.length < i) throw new Error('Transaction data too short for claimed signature count')
  if (n.length < 100) throw new Error('Transaction too short')
  const s = Buffer.from(t, 'base64').slice(1, 65)
  return rx.encode(s)
}
var RF = Object.defineProperty,
  DF = Object.defineProperties,
  PF = Object.getOwnPropertyDescriptors,
  N5 = Object.getOwnPropertySymbols,
  MF = Object.prototype.hasOwnProperty,
  kF = Object.prototype.propertyIsEnumerable,
  I5 = (t, e, n) =>
    e in t ? RF(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  UF = (t, e) => {
    for (var n in e || (e = {})) MF.call(e, n) && I5(t, n, e[n])
    if (N5) for (var n of N5(e)) kF.call(e, n) && I5(t, n, e[n])
    return t
  },
  BF = (t, e) => DF(t, PF(e))
const LF = 'did:pkh:',
  n2 = t => (t == null ? void 0 : t.split(':')),
  $F = t => {
    const e = t && n2(t)
    if (e) return t.includes(LF) ? e[3] : e[1]
  },
  Sw = t => {
    const e = t && n2(t)
    if (e) return e[2] + ':' + e[3]
  },
  Yg = t => {
    const e = t && n2(t)
    if (e) return e.pop()
  }
async function O5(t) {
  const { cacao: e, projectId: n } = t,
    { s: r, p: i } = e,
    s = Ix(i, i.iss),
    c = Yg(i.iss)
  return await TF(c, s, r, Sw(i.iss), n)
}
const Ix = (t, e) => {
  const n = `${t.domain} wants you to sign in with your Ethereum account:`,
    r = Yg(e)
  if (!t.aud && !t.uri)
    throw new Error('Either `aud` or `uri` is required to construct the message')
  let i = t.statement || void 0
  const s = `URI: ${t.aud || t.uri}`,
    c = `Version: ${t.version}`,
    u = `Chain ID: ${$F(e)}`,
    f = `Nonce: ${t.nonce}`,
    d = `Issued At: ${t.iat}`,
    p = t.exp ? `Expiration Time: ${t.exp}` : void 0,
    g = t.nbf ? `Not Before: ${t.nbf}` : void 0,
    m = t.requestId ? `Request ID: ${t.requestId}` : void 0,
    y = t.resources
      ? `Resources:${t.resources
          .map(
            E => `
- ${E}`
          )
          .join('')}`
      : void 0,
    A = Ng(t.resources)
  if (A) {
    const E = Ah(A)
    i = WF(i, E)
  }
  return [n, r, '', i, '', s, c, u, f, d, p, g, m, y].filter(E => E != null).join(`
`)
}
function FF(t) {
  return Buffer.from(JSON.stringify(t)).toString('base64')
}
function jF(t) {
  return JSON.parse(Buffer.from(t, 'base64').toString('utf-8'))
}
function tu(t) {
  if (!t) throw new Error('No recap provided, value is undefined')
  if (!t.att) throw new Error('No `att` property found')
  const e = Object.keys(t.att)
  if (!(e != null && e.length)) throw new Error('No resources found in `att` property')
  e.forEach(n => {
    const r = t.att[n]
    if (Array.isArray(r)) throw new Error(`Resource must be an object: ${n}`)
    if (typeof r != 'object') throw new Error(`Resource must be an object: ${n}`)
    if (!Object.keys(r).length) throw new Error(`Resource object is empty: ${n}`)
    Object.keys(r).forEach(i => {
      const s = r[i]
      if (!Array.isArray(s))
        throw new Error(`Ability limits ${i} must be an array of objects, found: ${s}`)
      if (!s.length) throw new Error(`Value of ${i} is empty array, must be an array with objects`)
      s.forEach(c => {
        if (typeof c != 'object')
          throw new Error(`Ability limits (${i}) must be an array of objects, found: ${c}`)
      })
    })
  })
}
function zF(t, e, n, r = {}) {
  return n == null || n.sort((i, s) => i.localeCompare(s)), { att: { [t]: qF(e, n, r) } }
}
function qF(t, e, n = {}) {
  e = e == null ? void 0 : e.sort((i, s) => i.localeCompare(s))
  const r = e.map(i => ({ [`${t}/${i}`]: [n] }))
  return Object.assign({}, ...r)
}
function Ox(t) {
  return tu(t), `urn:recap:${FF(t).replace(/=/g, '')}`
}
function Ah(t) {
  const e = jF(t.replace('urn:recap:', ''))
  return tu(e), e
}
function HF(t, e, n) {
  const r = zF(t, e, n)
  return Ox(r)
}
function GF(t) {
  return t && t.includes('urn:recap:')
}
function VF(t, e) {
  const n = Ah(t),
    r = Ah(e),
    i = KF(n, r)
  return Ox(i)
}
function KF(t, e) {
  tu(t), tu(e)
  const n = Object.keys(t.att)
      .concat(Object.keys(e.att))
      .sort((i, s) => i.localeCompare(s)),
    r = { att: {} }
  return (
    n.forEach(i => {
      var s, c
      Object.keys(((s = t.att) == null ? void 0 : s[i]) || {})
        .concat(Object.keys(((c = e.att) == null ? void 0 : c[i]) || {}))
        .sort((u, f) => u.localeCompare(f))
        .forEach(u => {
          var f, d
          r.att[i] = BF(UF({}, r.att[i]), {
            [u]:
              ((f = t.att[i]) == null ? void 0 : f[u]) || ((d = e.att[i]) == null ? void 0 : d[u])
          })
        })
    }),
    r
  )
}
function WF(t = '', e) {
  tu(e)
  const n = 'I further authorize the stated URI to perform the following actions on my behalf: '
  if (t.includes(n)) return t
  const r = []
  let i = 0
  Object.keys(e.att).forEach(u => {
    const f = Object.keys(e.att[u]).map(g => ({
      ability: g.split('/')[0],
      action: g.split('/')[1]
    }))
    f.sort((g, m) => g.action.localeCompare(m.action))
    const d = {}
    f.forEach(g => {
      d[g.ability] || (d[g.ability] = []), d[g.ability].push(g.action)
    })
    const p = Object.keys(d).map(g => (i++, `(${i}) '${g}': '${d[g].join("', '")}' for '${u}'.`))
    r.push(p.join(', ').replace('.,', '.'))
  })
  const s = r.join(' '),
    c = `${n}${s}`
  return `${t ? t + ' ' : ''}${c}`
}
function R5(t) {
  var e
  const n = Ah(t)
  tu(n)
  const r = (e = n.att) == null ? void 0 : e.eip155
  return r ? Object.keys(r).map(i => i.split('/')[1]) : []
}
function D5(t) {
  const e = Ah(t)
  tu(e)
  const n = []
  return (
    Object.values(e.att).forEach(r => {
      Object.values(r).forEach(i => {
        var s
        ;(s = i == null ? void 0 : i[0]) != null && s.chains && n.push(i[0].chains)
      })
    }),
    [...new Set(n.flat())]
  )
}
function Ng(t) {
  if (!t) return
  const e = t == null ? void 0 : t[t.length - 1]
  return GF(e) ? e : void 0
}
function d1(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error('positive integer expected, got ' + t)
}
function Rx(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function pi(t, ...e) {
  if (!Rx(t)) throw new Error('Uint8Array expected')
  if (e.length > 0 && !e.includes(t.length))
    throw new Error('Uint8Array expected of length ' + e + ', got length=' + t.length)
}
function P5(t, e = !0) {
  if (t.destroyed) throw new Error('Hash instance has been destroyed')
  if (e && t.finished) throw new Error('Hash#digest() has already been called')
}
function QF(t, e) {
  pi(t)
  const n = e.outputLen
  if (t.length < n) throw new Error('digestInto() expects output buffer of length at least ' + n)
}
function M5(t) {
  if (typeof t != 'boolean') throw new Error(`boolean expected, not ${t}`)
}
const $o = t => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),
  YF = t => new DataView(t.buffer, t.byteOffset, t.byteLength),
  ZF = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68
if (!ZF) throw new Error('Non little-endian hardware is not supported')
function XF(t) {
  if (typeof t != 'string') throw new Error('string expected')
  return new Uint8Array(new TextEncoder().encode(t))
}
function Tw(t) {
  if (typeof t == 'string') t = XF(t)
  else if (Rx(t)) t = xw(t)
  else throw new Error('Uint8Array expected, got ' + typeof t)
  return t
}
function JF(t, e) {
  if (e == null || typeof e != 'object') throw new Error('options must be defined')
  return Object.assign(t, e)
}
function ej(t, e) {
  if (t.length !== e.length) return !1
  let n = 0
  for (let r = 0; r < t.length; r++) n |= t[r] ^ e[r]
  return n === 0
}
const tj = (t, e) => {
  function n(r, ...i) {
    if ((pi(r), t.nonceLength !== void 0)) {
      const d = i[0]
      if (!d) throw new Error('nonce / iv required')
      t.varSizeNonce ? pi(d) : pi(d, t.nonceLength)
    }
    const s = t.tagLength
    s && i[1] !== void 0 && pi(i[1])
    const c = e(r, ...i),
      u = (d, p) => {
        if (p !== void 0) {
          if (d !== 2) throw new Error('cipher output not supported')
          pi(p)
        }
      }
    let f = !1
    return {
      encrypt(d, p) {
        if (f) throw new Error('cannot encrypt() twice with same key + nonce')
        return (f = !0), pi(d), u(c.encrypt.length, p), c.encrypt(d, p)
      },
      decrypt(d, p) {
        if ((pi(d), s && d.length < s))
          throw new Error('invalid ciphertext length: smaller than tagLength=' + s)
        return u(c.decrypt.length, p), c.decrypt(d, p)
      }
    }
  }
  return Object.assign(n, t), n
}
function k5(t, e, n = !0) {
  if (e === void 0) return new Uint8Array(t)
  if (e.length !== t) throw new Error('invalid output length, expected ' + t + ', got: ' + e.length)
  if (n && !nj(e)) throw new Error('invalid output, must be aligned')
  return e
}
function U5(t, e, n, r) {
  if (typeof t.setBigUint64 == 'function') return t.setBigUint64(e, n, r)
  const i = BigInt(32),
    s = BigInt(4294967295),
    c = Number((n >> i) & s),
    u = Number(n & s)
  t.setUint32(e + 4, c, r), t.setUint32(e + 0, u, r)
}
function nj(t) {
  return t.byteOffset % 4 === 0
}
function xw(t) {
  return Uint8Array.from(t)
}
function rd(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0)
}
const Dx = t => Uint8Array.from(t.split('').map(e => e.charCodeAt(0))),
  rj = Dx('expand 16-byte k'),
  ij = Dx('expand 32-byte k'),
  sj = $o(rj),
  aj = $o(ij)
function _t(t, e) {
  return (t << e) | (t >>> (32 - e))
}
function Nw(t) {
  return t.byteOffset % 4 === 0
}
const sg = 64,
  oj = 16,
  Px = 2 ** 32 - 1,
  B5 = new Uint32Array()
function cj(t, e, n, r, i, s, c, u) {
  const f = i.length,
    d = new Uint8Array(sg),
    p = $o(d),
    g = Nw(i) && Nw(s),
    m = g ? $o(i) : B5,
    y = g ? $o(s) : B5
  for (let A = 0; A < f; c++) {
    if ((t(e, n, r, p, c, u), c >= Px)) throw new Error('arx: counter overflow')
    const E = Math.min(sg, f - A)
    if (g && E === sg) {
      const x = A / 4
      if (A % 4 !== 0) throw new Error('arx: invalid block position')
      for (let O = 0, I; O < oj; O++) (I = x + O), (y[I] = m[I] ^ p[O])
      A += sg
      continue
    }
    for (let x = 0, O; x < E; x++) (O = A + x), (s[O] = i[O] ^ d[x])
    A += E
  }
}
function uj(t, e) {
  const {
    allowShortKeys: n,
    extendNonceFn: r,
    counterLength: i,
    counterRight: s,
    rounds: c
  } = JF({ allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 }, e)
  if (typeof t != 'function') throw new Error('core must be a function')
  return (
    d1(i),
    d1(c),
    M5(s),
    M5(n),
    (u, f, d, p, g = 0) => {
      pi(u), pi(f), pi(d)
      const m = d.length
      if ((p === void 0 && (p = new Uint8Array(m)), pi(p), d1(g), g < 0 || g >= Px))
        throw new Error('arx: counter overflow')
      if (p.length < m) throw new Error(`arx: output (${p.length}) is shorter than data (${m})`)
      const y = []
      let A = u.length,
        E,
        x
      if (A === 32) y.push((E = xw(u))), (x = aj)
      else if (A === 16 && n) (E = new Uint8Array(32)), E.set(u), E.set(u, 16), (x = sj), y.push(E)
      else throw new Error(`arx: invalid 32-byte key, got length=${A}`)
      Nw(f) || y.push((f = xw(f)))
      const O = $o(E)
      if (r) {
        if (f.length !== 24) throw new Error('arx: extended nonce must be 24 bytes')
        r(x, O, $o(f.subarray(0, 16)), O), (f = f.subarray(16))
      }
      const I = 16 - i
      if (I !== f.length) throw new Error(`arx: nonce must be ${I} or 16 bytes`)
      if (I !== 12) {
        const $ = new Uint8Array(12)
        $.set(f, s ? 0 : 12 - f.length), (f = $), y.push(f)
      }
      const M = $o(f)
      return cj(t, x, O, M, d, p, g, c), rd(...y), p
    }
  )
}
const gr = (t, e) => (t[e++] & 255) | ((t[e++] & 255) << 8)
let lj = class {
  constructor(e) {
    ;(this.blockLen = 16),
      (this.outputLen = 16),
      (this.buffer = new Uint8Array(16)),
      (this.r = new Uint16Array(10)),
      (this.h = new Uint16Array(10)),
      (this.pad = new Uint16Array(8)),
      (this.pos = 0),
      (this.finished = !1),
      (e = Tw(e)),
      pi(e, 32)
    const n = gr(e, 0),
      r = gr(e, 2),
      i = gr(e, 4),
      s = gr(e, 6),
      c = gr(e, 8),
      u = gr(e, 10),
      f = gr(e, 12),
      d = gr(e, 14)
    ;(this.r[0] = n & 8191),
      (this.r[1] = ((n >>> 13) | (r << 3)) & 8191),
      (this.r[2] = ((r >>> 10) | (i << 6)) & 7939),
      (this.r[3] = ((i >>> 7) | (s << 9)) & 8191),
      (this.r[4] = ((s >>> 4) | (c << 12)) & 255),
      (this.r[5] = (c >>> 1) & 8190),
      (this.r[6] = ((c >>> 14) | (u << 2)) & 8191),
      (this.r[7] = ((u >>> 11) | (f << 5)) & 8065),
      (this.r[8] = ((f >>> 8) | (d << 8)) & 8191),
      (this.r[9] = (d >>> 5) & 127)
    for (let p = 0; p < 8; p++) this.pad[p] = gr(e, 16 + 2 * p)
  }
  process(e, n, r = !1) {
    const i = r ? 0 : 2048,
      { h: s, r: c } = this,
      u = c[0],
      f = c[1],
      d = c[2],
      p = c[3],
      g = c[4],
      m = c[5],
      y = c[6],
      A = c[7],
      E = c[8],
      x = c[9],
      O = gr(e, n + 0),
      I = gr(e, n + 2),
      M = gr(e, n + 4),
      $ = gr(e, n + 6),
      D = gr(e, n + 8),
      R = gr(e, n + 10),
      z = gr(e, n + 12),
      G = gr(e, n + 14)
    let j = s[0] + (O & 8191),
      V = s[1] + (((O >>> 13) | (I << 3)) & 8191),
      L = s[2] + (((I >>> 10) | (M << 6)) & 8191),
      v = s[3] + (((M >>> 7) | ($ << 9)) & 8191),
      C = s[4] + ((($ >>> 4) | (D << 12)) & 8191),
      N = s[5] + ((D >>> 1) & 8191),
      T = s[6] + (((D >>> 14) | (R << 2)) & 8191),
      S = s[7] + (((R >>> 11) | (z << 5)) & 8191),
      k = s[8] + (((z >>> 8) | (G << 8)) & 8191),
      F = s[9] + ((G >>> 5) | i),
      P = 0,
      w = P + j * u + V * (5 * x) + L * (5 * E) + v * (5 * A) + C * (5 * y)
    ;(P = w >>> 13),
      (w &= 8191),
      (w += N * (5 * m) + T * (5 * g) + S * (5 * p) + k * (5 * d) + F * (5 * f)),
      (P += w >>> 13),
      (w &= 8191)
    let B = P + j * f + V * u + L * (5 * x) + v * (5 * E) + C * (5 * A)
    ;(P = B >>> 13),
      (B &= 8191),
      (B += N * (5 * y) + T * (5 * m) + S * (5 * g) + k * (5 * p) + F * (5 * d)),
      (P += B >>> 13),
      (B &= 8191)
    let Z = P + j * d + V * f + L * u + v * (5 * x) + C * (5 * E)
    ;(P = Z >>> 13),
      (Z &= 8191),
      (Z += N * (5 * A) + T * (5 * y) + S * (5 * m) + k * (5 * g) + F * (5 * p)),
      (P += Z >>> 13),
      (Z &= 8191)
    let ee = P + j * p + V * d + L * f + v * u + C * (5 * x)
    ;(P = ee >>> 13),
      (ee &= 8191),
      (ee += N * (5 * E) + T * (5 * A) + S * (5 * y) + k * (5 * m) + F * (5 * g)),
      (P += ee >>> 13),
      (ee &= 8191)
    let Y = P + j * g + V * p + L * d + v * f + C * u
    ;(P = Y >>> 13),
      (Y &= 8191),
      (Y += N * (5 * x) + T * (5 * E) + S * (5 * A) + k * (5 * y) + F * (5 * m)),
      (P += Y >>> 13),
      (Y &= 8191)
    let se = P + j * m + V * g + L * p + v * d + C * f
    ;(P = se >>> 13),
      (se &= 8191),
      (se += N * u + T * (5 * x) + S * (5 * E) + k * (5 * A) + F * (5 * y)),
      (P += se >>> 13),
      (se &= 8191)
    let ce = P + j * y + V * m + L * g + v * p + C * d
    ;(P = ce >>> 13),
      (ce &= 8191),
      (ce += N * f + T * u + S * (5 * x) + k * (5 * E) + F * (5 * A)),
      (P += ce >>> 13),
      (ce &= 8191)
    let we = P + j * A + V * y + L * m + v * g + C * p
    ;(P = we >>> 13),
      (we &= 8191),
      (we += N * d + T * f + S * u + k * (5 * x) + F * (5 * E)),
      (P += we >>> 13),
      (we &= 8191)
    let _e = P + j * E + V * A + L * y + v * m + C * g
    ;(P = _e >>> 13),
      (_e &= 8191),
      (_e += N * p + T * d + S * f + k * u + F * (5 * x)),
      (P += _e >>> 13),
      (_e &= 8191)
    let ye = P + j * x + V * E + L * A + v * y + C * m
    ;(P = ye >>> 13),
      (ye &= 8191),
      (ye += N * g + T * p + S * d + k * f + F * u),
      (P += ye >>> 13),
      (ye &= 8191),
      (P = ((P << 2) + P) | 0),
      (P = (P + w) | 0),
      (w = P & 8191),
      (P = P >>> 13),
      (B += P),
      (s[0] = w),
      (s[1] = B),
      (s[2] = Z),
      (s[3] = ee),
      (s[4] = Y),
      (s[5] = se),
      (s[6] = ce),
      (s[7] = we),
      (s[8] = _e),
      (s[9] = ye)
  }
  finalize() {
    const { h: e, pad: n } = this,
      r = new Uint16Array(10)
    let i = e[1] >>> 13
    e[1] &= 8191
    for (let u = 2; u < 10; u++) (e[u] += i), (i = e[u] >>> 13), (e[u] &= 8191)
    ;(e[0] += i * 5),
      (i = e[0] >>> 13),
      (e[0] &= 8191),
      (e[1] += i),
      (i = e[1] >>> 13),
      (e[1] &= 8191),
      (e[2] += i),
      (r[0] = e[0] + 5),
      (i = r[0] >>> 13),
      (r[0] &= 8191)
    for (let u = 1; u < 10; u++) (r[u] = e[u] + i), (i = r[u] >>> 13), (r[u] &= 8191)
    r[9] -= 8192
    let s = (i ^ 1) - 1
    for (let u = 0; u < 10; u++) r[u] &= s
    s = ~s
    for (let u = 0; u < 10; u++) e[u] = (e[u] & s) | r[u]
    ;(e[0] = (e[0] | (e[1] << 13)) & 65535),
      (e[1] = ((e[1] >>> 3) | (e[2] << 10)) & 65535),
      (e[2] = ((e[2] >>> 6) | (e[3] << 7)) & 65535),
      (e[3] = ((e[3] >>> 9) | (e[4] << 4)) & 65535),
      (e[4] = ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14)) & 65535),
      (e[5] = ((e[6] >>> 2) | (e[7] << 11)) & 65535),
      (e[6] = ((e[7] >>> 5) | (e[8] << 8)) & 65535),
      (e[7] = ((e[8] >>> 8) | (e[9] << 5)) & 65535)
    let c = e[0] + n[0]
    e[0] = c & 65535
    for (let u = 1; u < 8; u++) (c = (((e[u] + n[u]) | 0) + (c >>> 16)) | 0), (e[u] = c & 65535)
    rd(r)
  }
  update(e) {
    P5(this)
    const { buffer: n, blockLen: r } = this
    e = Tw(e)
    const i = e.length
    for (let s = 0; s < i; ) {
      const c = Math.min(r - this.pos, i - s)
      if (c === r) {
        for (; r <= i - s; s += r) this.process(e, s)
        continue
      }
      n.set(e.subarray(s, s + c), this.pos),
        (this.pos += c),
        (s += c),
        this.pos === r && (this.process(n, 0, !1), (this.pos = 0))
    }
    return this
  }
  destroy() {
    rd(this.h, this.r, this.buffer, this.pad)
  }
  digestInto(e) {
    P5(this), QF(e, this), (this.finished = !0)
    const { buffer: n, h: r } = this
    let { pos: i } = this
    if (i) {
      for (n[i++] = 1; i < 16; i++) n[i] = 0
      this.process(n, 0, !0)
    }
    this.finalize()
    let s = 0
    for (let c = 0; c < 8; c++) (e[s++] = r[c] >>> 0), (e[s++] = r[c] >>> 8)
    return e
  }
  digest() {
    const { buffer: e, outputLen: n } = this
    this.digestInto(e)
    const r = e.slice(0, n)
    return this.destroy(), r
  }
}
function dj(t) {
  const e = (r, i) => t(i).update(Tw(r)).digest(),
    n = t(new Uint8Array(32))
  return (e.outputLen = n.outputLen), (e.blockLen = n.blockLen), (e.create = r => t(r)), e
}
const fj = dj(t => new lj(t))
function hj(t, e, n, r, i, s = 20) {
  let c = t[0],
    u = t[1],
    f = t[2],
    d = t[3],
    p = e[0],
    g = e[1],
    m = e[2],
    y = e[3],
    A = e[4],
    E = e[5],
    x = e[6],
    O = e[7],
    I = i,
    M = n[0],
    $ = n[1],
    D = n[2],
    R = c,
    z = u,
    G = f,
    j = d,
    V = p,
    L = g,
    v = m,
    C = y,
    N = A,
    T = E,
    S = x,
    k = O,
    F = I,
    P = M,
    w = $,
    B = D
  for (let ee = 0; ee < s; ee += 2)
    (R = (R + V) | 0),
      (F = _t(F ^ R, 16)),
      (N = (N + F) | 0),
      (V = _t(V ^ N, 12)),
      (R = (R + V) | 0),
      (F = _t(F ^ R, 8)),
      (N = (N + F) | 0),
      (V = _t(V ^ N, 7)),
      (z = (z + L) | 0),
      (P = _t(P ^ z, 16)),
      (T = (T + P) | 0),
      (L = _t(L ^ T, 12)),
      (z = (z + L) | 0),
      (P = _t(P ^ z, 8)),
      (T = (T + P) | 0),
      (L = _t(L ^ T, 7)),
      (G = (G + v) | 0),
      (w = _t(w ^ G, 16)),
      (S = (S + w) | 0),
      (v = _t(v ^ S, 12)),
      (G = (G + v) | 0),
      (w = _t(w ^ G, 8)),
      (S = (S + w) | 0),
      (v = _t(v ^ S, 7)),
      (j = (j + C) | 0),
      (B = _t(B ^ j, 16)),
      (k = (k + B) | 0),
      (C = _t(C ^ k, 12)),
      (j = (j + C) | 0),
      (B = _t(B ^ j, 8)),
      (k = (k + B) | 0),
      (C = _t(C ^ k, 7)),
      (R = (R + L) | 0),
      (B = _t(B ^ R, 16)),
      (S = (S + B) | 0),
      (L = _t(L ^ S, 12)),
      (R = (R + L) | 0),
      (B = _t(B ^ R, 8)),
      (S = (S + B) | 0),
      (L = _t(L ^ S, 7)),
      (z = (z + v) | 0),
      (F = _t(F ^ z, 16)),
      (k = (k + F) | 0),
      (v = _t(v ^ k, 12)),
      (z = (z + v) | 0),
      (F = _t(F ^ z, 8)),
      (k = (k + F) | 0),
      (v = _t(v ^ k, 7)),
      (G = (G + C) | 0),
      (P = _t(P ^ G, 16)),
      (N = (N + P) | 0),
      (C = _t(C ^ N, 12)),
      (G = (G + C) | 0),
      (P = _t(P ^ G, 8)),
      (N = (N + P) | 0),
      (C = _t(C ^ N, 7)),
      (j = (j + V) | 0),
      (w = _t(w ^ j, 16)),
      (T = (T + w) | 0),
      (V = _t(V ^ T, 12)),
      (j = (j + V) | 0),
      (w = _t(w ^ j, 8)),
      (T = (T + w) | 0),
      (V = _t(V ^ T, 7))
  let Z = 0
  ;(r[Z++] = (c + R) | 0),
    (r[Z++] = (u + z) | 0),
    (r[Z++] = (f + G) | 0),
    (r[Z++] = (d + j) | 0),
    (r[Z++] = (p + V) | 0),
    (r[Z++] = (g + L) | 0),
    (r[Z++] = (m + v) | 0),
    (r[Z++] = (y + C) | 0),
    (r[Z++] = (A + N) | 0),
    (r[Z++] = (E + T) | 0),
    (r[Z++] = (x + S) | 0),
    (r[Z++] = (O + k) | 0),
    (r[Z++] = (I + F) | 0),
    (r[Z++] = (M + P) | 0),
    (r[Z++] = ($ + w) | 0),
    (r[Z++] = (D + B) | 0)
}
const pj = uj(hj, { counterRight: !1, counterLength: 4, allowShortKeys: !1 }),
  gj = new Uint8Array(16),
  L5 = (t, e) => {
    t.update(e)
    const n = e.length % 16
    n && t.update(gj.subarray(n))
  },
  mj = new Uint8Array(32)
function $5(t, e, n, r, i) {
  const s = t(e, n, mj),
    c = fj.create(s)
  i && L5(c, i), L5(c, r)
  const u = new Uint8Array(16),
    f = YF(u)
  U5(f, 0, BigInt(i ? i.length : 0), !0), U5(f, 8, BigInt(r.length), !0), c.update(u)
  const d = c.digest()
  return rd(s, u), d
}
const bj = t => (e, n, r) => ({
    encrypt(i, s) {
      const c = i.length
      ;(s = k5(c + 16, s, !1)), s.set(i)
      const u = s.subarray(0, -16)
      t(e, n, u, u, 1)
      const f = $5(t, e, n, u, r)
      return s.set(f, c), rd(f), s
    },
    decrypt(i, s) {
      s = k5(i.length - 16, s, !1)
      const c = i.subarray(0, -16),
        u = i.subarray(-16),
        f = $5(t, e, n, c, r)
      if (!ej(u, f)) throw new Error('invalid tag')
      return s.set(i.subarray(0, -16)), t(e, n, s, s, 1), rd(f), s
    }
  }),
  Mx = tj({ blockSize: 64, nonceLength: 12, tagLength: 16 }, bj(pj))
let kx = class extends t2 {
  constructor(e, n) {
    super(), (this.finished = !1), (this.destroyed = !1), e2(e)
    const r = nd(n)
    if (((this.iHash = e.create()), typeof this.iHash.update != 'function'))
      throw new Error('Expected instance of class which extends utils.Hash')
    ;(this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen)
    const i = this.blockLen,
      s = new Uint8Array(i)
    s.set(r.length > i ? e.create().update(r).digest() : r)
    for (let c = 0; c < s.length; c++) s[c] ^= 54
    this.iHash.update(s), (this.oHash = e.create())
    for (let c = 0; c < s.length; c++) s[c] ^= 106
    this.oHash.update(s), s.fill(0)
  }
  update(e) {
    return td(this), this.iHash.update(e), this
  }
  digestInto(e) {
    td(this),
      km(e, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(e),
      this.oHash.update(e),
      this.oHash.digestInto(e),
      this.destroy()
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen)
    return this.digestInto(e), e
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}))
    const { oHash: n, iHash: r, finished: i, destroyed: s, blockLen: c, outputLen: u } = this
    return (
      (e = e),
      (e.finished = i),
      (e.destroyed = s),
      (e.blockLen = c),
      (e.outputLen = u),
      (e.oHash = n._cloneInto(e.oHash)),
      (e.iHash = r._cloneInto(e.iHash)),
      e
    )
  }
  destroy() {
    ;(this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy()
  }
}
const r2 = (t, e, n) => new kx(t, e).update(n).digest()
r2.create = (t, e) => new kx(t, e)
function yj(t, e, n) {
  return e2(t), n === void 0 && (n = new Uint8Array(t.outputLen)), r2(t, nd(n), nd(e))
}
const f1 = new Uint8Array([0]),
  F5 = new Uint8Array()
function vj(t, e, n, r = 32) {
  if ((e2(t), Eh(r), r > 255 * t.outputLen)) throw new Error('Length should be <= 255*HashLen')
  const i = Math.ceil(r / t.outputLen)
  n === void 0 && (n = F5)
  const s = new Uint8Array(i * t.outputLen),
    c = r2.create(t, e),
    u = c._cloneInto(),
    f = new Uint8Array(c.outputLen)
  for (let d = 0; d < i; d++)
    (f1[0] = d + 1),
      u
        .update(d === 0 ? F5 : f)
        .update(n)
        .update(f1)
        .digestInto(f),
      s.set(f, t.outputLen * d),
      c._cloneInto(u)
  return c.destroy(), u.destroy(), f.fill(0), f1.fill(0), s.slice(0, r)
}
const wj = (t, e, n, r, i) => vj(t, yj(t, e, n), r, i)
function Ej(t, e, n, r) {
  if (typeof t.setBigUint64 == 'function') return t.setBigUint64(e, n, r)
  const i = BigInt(32),
    s = BigInt(4294967295),
    c = Number((n >> i) & s),
    u = Number(n & s),
    f = r ? 4 : 0,
    d = r ? 0 : 4
  t.setUint32(e + f, c, r), t.setUint32(e + d, u, r)
}
function Aj(t, e, n) {
  return (t & e) ^ (~t & n)
}
function _j(t, e, n) {
  return (t & e) ^ (t & n) ^ (e & n)
}
class Cj extends t2 {
  constructor(e, n, r, i) {
    super(),
      (this.blockLen = e),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(e)),
      (this.view = l1(this.buffer))
  }
  update(e) {
    td(this)
    const { view: n, buffer: r, blockLen: i } = this
    e = nd(e)
    const s = e.length
    for (let c = 0; c < s; ) {
      const u = Math.min(i - this.pos, s - c)
      if (u === i) {
        const f = l1(e)
        for (; i <= s - c; c += i) this.process(f, c)
        continue
      }
      r.set(e.subarray(c, c + u), this.pos),
        (this.pos += u),
        (c += u),
        this.pos === i && (this.process(n, 0), (this.pos = 0))
    }
    return (this.length += e.length), this.roundClean(), this
  }
  digestInto(e) {
    td(this), Ax(e, this), (this.finished = !0)
    const { buffer: n, view: r, blockLen: i, isLE: s } = this
    let { pos: c } = this
    ;(n[c++] = 128),
      this.buffer.subarray(c).fill(0),
      this.padOffset > i - c && (this.process(r, 0), (c = 0))
    for (let g = c; g < i; g++) n[g] = 0
    Ej(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0)
    const u = l1(e),
      f = this.outputLen
    if (f % 4) throw new Error('_sha2: outputLen should be aligned to 32bit')
    const d = f / 4,
      p = this.get()
    if (d > p.length) throw new Error('_sha2: outputLen bigger than state')
    for (let g = 0; g < d; g++) u.setUint32(4 * g, p[g], s)
  }
  digest() {
    const { buffer: e, outputLen: n } = this
    this.digestInto(e)
    const r = e.slice(0, n)
    return this.destroy(), r
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get())
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: c, pos: u } = this
    return (
      (e.length = i), (e.pos = u), (e.finished = s), (e.destroyed = c), i % n && e.buffer.set(r), e
    )
  }
}
const Sj = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298
  ]),
  mo = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225
  ]),
  bo = new Uint32Array(64)
let Tj = class extends Cj {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = mo[0] | 0),
      (this.B = mo[1] | 0),
      (this.C = mo[2] | 0),
      (this.D = mo[3] | 0),
      (this.E = mo[4] | 0),
      (this.F = mo[5] | 0),
      (this.G = mo[6] | 0),
      (this.H = mo[7] | 0)
  }
  get() {
    const { A: e, B: n, C: r, D: i, E: s, F: c, G: u, H: f } = this
    return [e, n, r, i, s, c, u, f]
  }
  set(e, n, r, i, s, c, u, f) {
    ;(this.A = e | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = i | 0),
      (this.E = s | 0),
      (this.F = c | 0),
      (this.G = u | 0),
      (this.H = f | 0)
  }
  process(e, n) {
    for (let g = 0; g < 16; g++, n += 4) bo[g] = e.getUint32(n, !1)
    for (let g = 16; g < 64; g++) {
      const m = bo[g - 15],
        y = bo[g - 2],
        A = Ns(m, 7) ^ Ns(m, 18) ^ (m >>> 3),
        E = Ns(y, 17) ^ Ns(y, 19) ^ (y >>> 10)
      bo[g] = (E + bo[g - 7] + A + bo[g - 16]) | 0
    }
    let { A: r, B: i, C: s, D: c, E: u, F: f, G: d, H: p } = this
    for (let g = 0; g < 64; g++) {
      const m = Ns(u, 6) ^ Ns(u, 11) ^ Ns(u, 25),
        y = (p + m + Aj(u, f, d) + Sj[g] + bo[g]) | 0,
        A = ((Ns(r, 2) ^ Ns(r, 13) ^ Ns(r, 22)) + _j(r, i, s)) | 0
      ;(p = d), (d = f), (f = u), (u = (c + y) | 0), (c = s), (s = i), (i = r), (r = (y + A) | 0)
    }
    ;(r = (r + this.A) | 0),
      (i = (i + this.B) | 0),
      (s = (s + this.C) | 0),
      (c = (c + this.D) | 0),
      (u = (u + this.E) | 0),
      (f = (f + this.F) | 0),
      (d = (d + this.G) | 0),
      (p = (p + this.H) | 0),
      this.set(r, i, s, c, u, f, d, p)
  }
  roundClean() {
    bo.fill(0)
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
  }
}
const Um = _x(() => new Tj())
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Ux = BigInt(0)
function i2(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function Bx(t) {
  if (!i2(t)) throw new Error('Uint8Array expected')
}
const xj = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, '0'))
function Nj(t) {
  Bx(t)
  let e = ''
  for (let n = 0; n < t.length; n++) e += xj[t[n]]
  return e
}
function Ij(t) {
  if (typeof t != 'string') throw new Error('hex string expected, got ' + typeof t)
  return t === '' ? Ux : BigInt('0x' + t)
}
const ya = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }
function j5(t) {
  if (t >= ya._0 && t <= ya._9) return t - ya._0
  if (t >= ya.A && t <= ya.F) return t - (ya.A - 10)
  if (t >= ya.a && t <= ya.f) return t - (ya.a - 10)
}
function Lx(t) {
  if (typeof t != 'string') throw new Error('hex string expected, got ' + typeof t)
  const e = t.length,
    n = e / 2
  if (e % 2) throw new Error('hex string expected, got unpadded hex of length ' + e)
  const r = new Uint8Array(n)
  for (let i = 0, s = 0; i < n; i++, s += 2) {
    const c = j5(t.charCodeAt(s)),
      u = j5(t.charCodeAt(s + 1))
    if (c === void 0 || u === void 0) {
      const f = t[s] + t[s + 1]
      throw new Error('hex string expected, got non-hex character "' + f + '" at index ' + s)
    }
    r[i] = c * 16 + u
  }
  return r
}
function z5(t) {
  return Bx(t), Ij(Nj(Uint8Array.from(t).reverse()))
}
function Oj(t, e) {
  return Lx(t.toString(16).padStart(e * 2, '0'))
}
function Rj(t, e) {
  return Oj(t, e).reverse()
}
function q5(t, e, n) {
  let r
  if (typeof e == 'string')
    try {
      r = Lx(e)
    } catch (s) {
      throw new Error(t + ' must be hex string or Uint8Array, cause: ' + s)
    }
  else if (i2(e)) r = Uint8Array.from(e)
  else throw new Error(t + ' must be hex string or Uint8Array')
  const i = r.length
  if (typeof n == 'number' && i !== n)
    throw new Error(t + ' of length ' + n + ' expected, got ' + i)
  return r
}
const h1 = t => typeof t == 'bigint' && Ux <= t
function Dj(t, e, n) {
  return h1(t) && h1(e) && h1(n) && e <= t && t < n
}
function H5(t, e, n, r) {
  if (!Dj(e, n, r))
    throw new Error('expected valid ' + t + ': ' + n + ' <= n < ' + r + ', got ' + e)
}
const Pj = {
  bigint: t => typeof t == 'bigint',
  function: t => typeof t == 'function',
  boolean: t => typeof t == 'boolean',
  string: t => typeof t == 'string',
  stringOrUint8Array: t => typeof t == 'string' || i2(t),
  isSafeInteger: t => Number.isSafeInteger(t),
  array: t => Array.isArray(t),
  field: (t, e) => e.Fp.isValid(t),
  hash: t => typeof t == 'function' && Number.isSafeInteger(t.outputLen)
}
function Mj(t, e, n = {}) {
  const r = (i, s, c) => {
    const u = Pj[s]
    if (typeof u != 'function') throw new Error('invalid validator function')
    const f = t[i]
    if (!(c && f === void 0) && !u(f, t))
      throw new Error('param ' + String(i) + ' is invalid. Expected ' + s + ', got ' + f)
  }
  for (const [i, s] of Object.entries(e)) r(i, s, !1)
  for (const [i, s] of Object.entries(n)) r(i, s, !0)
  return t
}
const Rl = BigInt(0),
  ag = BigInt(1)
function $x(t, e) {
  const n = t % e
  return n >= Rl ? n : e + n
}
function kj(t, e, n) {
  if (e < Rl) throw new Error('invalid exponent, negatives unsupported')
  if (n <= Rl) throw new Error('invalid modulus')
  if (n === ag) return Rl
  let r = ag
  for (; e > Rl; ) e & ag && (r = (r * t) % n), (t = (t * t) % n), (e >>= ag)
  return r
}
function is(t, e, n) {
  let r = t
  for (; e-- > Rl; ) (r *= r), (r %= n)
  return r
}
BigInt(0), BigInt(1), BigInt(0), BigInt(1), BigInt(2), BigInt(8)
const ll = BigInt(0),
  p1 = BigInt(1)
function Uj(t) {
  return (
    Mj(
      t,
      { a: 'bigint' },
      {
        montgomeryBits: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
        adjustScalarBytes: 'function',
        domain: 'function',
        powPminus2: 'function',
        Gu: 'bigint'
      }
    ),
    Object.freeze({ ...t })
  )
}
function Bj(t) {
  const e = Uj(t),
    { P: n } = e,
    r = I => $x(I, n),
    i = e.montgomeryBits,
    s = Math.ceil(i / 8),
    c = e.nByteLength,
    u = e.adjustScalarBytes || (I => I),
    f = e.powPminus2 || (I => kj(I, n - BigInt(2), n))
  function d(I, M, $) {
    const D = r(I * (M - $))
    return (M = r(M - D)), ($ = r($ + D)), [M, $]
  }
  const p = (e.a - BigInt(2)) / BigInt(4)
  function g(I, M) {
    H5('u', I, ll, n), H5('scalar', M, ll, n)
    const $ = M,
      D = I
    let R = p1,
      z = ll,
      G = I,
      j = p1,
      V = ll,
      L
    for (let C = BigInt(i - 1); C >= ll; C--) {
      const N = ($ >> C) & p1
      ;(V ^= N),
        (L = d(V, R, G)),
        (R = L[0]),
        (G = L[1]),
        (L = d(V, z, j)),
        (z = L[0]),
        (j = L[1]),
        (V = N)
      const T = R + z,
        S = r(T * T),
        k = R - z,
        F = r(k * k),
        P = S - F,
        w = G + j,
        B = G - j,
        Z = r(B * T),
        ee = r(w * k),
        Y = Z + ee,
        se = Z - ee
      ;(G = r(Y * Y)), (j = r(D * r(se * se))), (R = r(S * F)), (z = r(P * (S + r(p * P))))
    }
    ;(L = d(V, R, G)), (R = L[0]), (G = L[1]), (L = d(V, z, j)), (z = L[0]), (j = L[1])
    const v = f(z)
    return r(R * v)
  }
  function m(I) {
    return Rj(r(I), s)
  }
  function y(I) {
    const M = q5('u coordinate', I, s)
    return c === 32 && (M[31] &= 127), z5(M)
  }
  function A(I) {
    const M = q5('scalar', I),
      $ = M.length
    if ($ !== s && $ !== c) {
      let D = '' + s + ' or ' + c
      throw new Error('invalid scalar, expected ' + D + ' bytes, got ' + $)
    }
    return z5(u(M))
  }
  function E(I, M) {
    const $ = y(M),
      D = A(I),
      R = g($, D)
    if (R === ll) throw new Error('invalid private or public key received')
    return m(R)
  }
  const x = m(e.Gu)
  function O(I) {
    return E(I, x)
  }
  return {
    scalarMult: E,
    scalarMultBase: O,
    getSharedSecret: (I, M) => E(I, M),
    getPublicKey: I => O(I),
    utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) },
    GuBytes: x
  }
}
const Iw = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949')
BigInt(0)
const Lj = BigInt(1),
  G5 = BigInt(2),
  $j = BigInt(3),
  Fj = BigInt(5)
BigInt(8)
function jj(t) {
  const e = BigInt(10),
    n = BigInt(20),
    r = BigInt(40),
    i = BigInt(80),
    s = Iw,
    c = (((t * t) % s) * t) % s,
    u = (is(c, G5, s) * c) % s,
    f = (is(u, Lj, s) * t) % s,
    d = (is(f, Fj, s) * f) % s,
    p = (is(d, e, s) * d) % s,
    g = (is(p, n, s) * p) % s,
    m = (is(g, r, s) * g) % s,
    y = (is(m, i, s) * m) % s,
    A = (is(y, i, s) * m) % s,
    E = (is(A, e, s) * d) % s
  return { pow_p_5_8: (is(E, G5, s) * t) % s, b2: c }
}
function zj(t) {
  return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t
}
const Ow = Bj({
    P: Iw,
    a: BigInt(486662),
    montgomeryBits: 255,
    nByteLength: 32,
    Gu: BigInt(9),
    powPminus2: t => {
      const e = Iw,
        { pow_p_5_8: n, b2: r } = jj(t)
      return $x(is(n, $j, e) * r, e)
    },
    adjustScalarBytes: zj,
    randomBytes: Ap
  }),
  Fx = 'base10',
  Or = 'base16',
  ko = 'base64pad',
  jf = 'base64url',
  _p = 'utf8',
  jx = 0,
  Oa = 1,
  Cp = 2,
  qj = 0,
  V5 = 1,
  ch = 12,
  s2 = 32
function Hj() {
  const t = Ow.utils.randomPrivateKey(),
    e = Ow.getPublicKey(t)
  return { privateKey: $r(t, Or), publicKey: $r(e, Or) }
}
function Rw() {
  const t = Ap(s2)
  return $r(t, Or)
}
function Gj(t, e) {
  const n = Ow.getSharedSecret(Fi(t, Or), Fi(e, Or)),
    r = wj(Um, n, void 0, void 0, s2)
  return $r(r, Or)
}
function Ig(t) {
  const e = Um(Fi(t, Or))
  return $r(e, Or)
}
function Fs(t) {
  const e = Um(Fi(t, _p))
  return $r(e, Or)
}
function zx(t) {
  return Fi(`${t}`, Fx)
}
function nu(t) {
  return Number($r(t, Fx))
}
function Vj(t) {
  const e = zx(typeof t.type < 'u' ? t.type : jx)
  if (nu(e) === Oa && typeof t.senderPublicKey > 'u')
    throw new Error('Missing sender public key for type 1 envelope')
  const n = typeof t.senderPublicKey < 'u' ? Fi(t.senderPublicKey, Or) : void 0,
    r = typeof t.iv < 'u' ? Fi(t.iv, Or) : Ap(ch),
    i = Fi(t.symKey, Or),
    s = Mx(i, r).encrypt(Fi(t.message, _p))
  return qx({ type: e, sealed: s, iv: r, senderPublicKey: n, encoding: t.encoding })
}
function Kj(t) {
  const e = Fi(t.symKey, Or),
    { sealed: n, iv: r } = _h(t),
    i = Mx(e, r).decrypt(n)
  if (i === null) throw new Error('Failed to decrypt')
  return $r(i, _p)
}
function Wj(t, e) {
  const n = zx(Cp),
    r = Ap(ch),
    i = Fi(t, _p)
  return qx({ type: n, sealed: i, iv: r, encoding: e })
}
function Qj(t, e) {
  const { sealed: n } = _h({ encoded: t, encoding: e })
  return $r(n, _p)
}
function qx(t) {
  const { encoding: e = ko } = t
  if (nu(t.type) === Cp) return $r(kv([t.type, t.sealed]), e)
  if (nu(t.type) === Oa) {
    if (typeof t.senderPublicKey > 'u')
      throw new Error('Missing sender public key for type 1 envelope')
    return $r(kv([t.type, t.senderPublicKey, t.iv, t.sealed]), e)
  }
  return $r(kv([t.type, t.iv, t.sealed]), e)
}
function _h(t) {
  const { encoded: e, encoding: n = ko } = t,
    r = Fi(e, n),
    i = r.slice(qj, V5),
    s = V5
  if (nu(i) === Oa) {
    const d = s + s2,
      p = d + ch,
      g = r.slice(s, d),
      m = r.slice(d, p),
      y = r.slice(p)
    return { type: i, sealed: y, iv: m, senderPublicKey: g }
  }
  if (nu(i) === Cp) {
    const d = r.slice(s),
      p = Ap(ch)
    return { type: i, sealed: d, iv: p }
  }
  const c = s + ch,
    u = r.slice(s, c),
    f = r.slice(c)
  return { type: i, sealed: f, iv: u }
}
function Yj(t, e) {
  const n = _h({ encoded: t, encoding: e == null ? void 0 : e.encoding })
  return Hx({
    type: nu(n.type),
    senderPublicKey: typeof n.senderPublicKey < 'u' ? $r(n.senderPublicKey, Or) : void 0,
    receiverPublicKey: e == null ? void 0 : e.receiverPublicKey
  })
}
function Hx(t) {
  const e = (t == null ? void 0 : t.type) || jx
  if (e === Oa) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > 'u')
      throw new Error('missing sender public key')
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > 'u')
      throw new Error('missing receiver public key')
  }
  return {
    type: e,
    senderPublicKey: t == null ? void 0 : t.senderPublicKey,
    receiverPublicKey: t == null ? void 0 : t.receiverPublicKey
  }
}
function K5(t) {
  return (
    t.type === Oa && typeof t.senderPublicKey == 'string' && typeof t.receiverPublicKey == 'string'
  )
}
function W5(t) {
  return t.type === Cp
}
function Zj(t) {
  return new U$.ec('p256').keyFromPublic(
    {
      x: Buffer.from(t.x, 'base64').toString('hex'),
      y: Buffer.from(t.y, 'base64').toString('hex')
    },
    'hex'
  )
}
function Xj(t) {
  let e = t.replace(/-/g, '+').replace(/_/g, '/')
  const n = e.length % 4
  return n > 0 && (e += '='.repeat(4 - n)), e
}
function Jj(t) {
  return Buffer.from(Xj(t), 'base64')
}
function ez(t, e) {
  const [n, r, i] = t.split('.'),
    s = Jj(i)
  if (s.length !== 64) throw new Error('Invalid signature length')
  const c = s.slice(0, 32).toString('hex'),
    u = s.slice(32, 64).toString('hex'),
    f = `${n}.${r}`,
    d = Um(f),
    p = Zj(e),
    g = $r(d, Or)
  if (!p.verify(g, { r: c, s: u })) throw new Error('Invalid signature')
  return mw(t).payload
}
const tz = 'irn'
function Zg(t) {
  return (t == null ? void 0 : t.relay) || { protocol: tz }
}
function th(t) {
  const e = B$[t]
  if (typeof e > 'u') throw new Error(`Relay Protocol not supported: ${t}`)
  return e
}
function nz(t, e = '-') {
  const n = {},
    r = 'relay' + e
  return (
    Object.keys(t).forEach(i => {
      if (i.startsWith(r)) {
        const s = i.replace(r, ''),
          c = t[i]
        n[s] = c
      }
    }),
    n
  )
}
function Q5(t) {
  if (!t.includes('wc:')) {
    const d = Ex(t)
    d != null && d.includes('wc:') && (t = d)
  }
  ;(t = t.includes('wc://') ? t.replace('wc://', '') : t),
    (t = t.includes('wc:') ? t.replace('wc:', '') : t)
  const e = t.indexOf(':'),
    n = t.indexOf('?') !== -1 ? t.indexOf('?') : void 0,
    r = t.substring(0, e),
    i = t.substring(e + 1, n).split('@'),
    s = typeof n < 'u' ? t.substring(n) : '',
    c = new URLSearchParams(s),
    u = {}
  c.forEach((d, p) => {
    u[p] = d
  })
  const f = typeof u.methods == 'string' ? u.methods.split(',') : void 0
  return {
    protocol: r,
    topic: rz(i[0]),
    version: parseInt(i[1], 10),
    symKey: u.symKey,
    relay: nz(u),
    methods: f,
    expiryTimestamp: u.expiryTimestamp ? parseInt(u.expiryTimestamp, 10) : void 0
  }
}
function rz(t) {
  return t.startsWith('//') ? t.substring(2) : t
}
function iz(t, e = '-') {
  const n = 'relay',
    r = {}
  return (
    Object.keys(t).forEach(i => {
      const s = i,
        c = n + e + s
      t[s] && (r[c] = t[s])
    }),
    r
  )
}
function Y5(t) {
  const e = new URLSearchParams(),
    n = iz(t.relay)
  Object.keys(n)
    .sort()
    .forEach(i => {
      e.set(i, n[i])
    }),
    e.set('symKey', t.symKey),
    t.expiryTimestamp && e.set('expiryTimestamp', t.expiryTimestamp.toString()),
    t.methods && e.set('methods', t.methods.join(','))
  const r = e.toString()
  return `${t.protocol}:${t.topic}@${t.version}?${r}`
}
function og(t, e, n) {
  return `${t}?wc_ev=${n}&topic=${e}`
}
function _d(t) {
  const e = []
  return (
    t.forEach(n => {
      const [r, i] = n.split(':')
      e.push(`${r}:${i}`)
    }),
    e
  )
}
function sz(t) {
  const e = []
  return (
    Object.values(t).forEach(n => {
      e.push(..._d(n.accounts))
    }),
    e
  )
}
function az(t, e) {
  const n = []
  return (
    Object.values(t).forEach(r => {
      _d(r.accounts).includes(e) && n.push(...r.methods)
    }),
    n
  )
}
function oz(t, e) {
  const n = []
  return (
    Object.values(t).forEach(r => {
      _d(r.accounts).includes(e) && n.push(...r.events)
    }),
    n
  )
}
function a2(t) {
  return t.includes(':')
}
function nh(t) {
  return a2(t) ? t.split(':')[0] : t
}
function cz(t) {
  const e = {}
  return (
    t == null ||
      t.forEach(n => {
        var r
        const [i, s] = n.split(':')
        e[i] || (e[i] = { accounts: [], chains: [], events: [], methods: [] }),
          e[i].accounts.push(n),
          (r = e[i].chains) == null || r.push(`${i}:${s}`)
      }),
    e
  )
}
function Z5(t, e) {
  e = e.map(r => r.replace('did:pkh:', ''))
  const n = cz(e)
  for (const [r, i] of Object.entries(n))
    i.methods ? (i.methods = xg(i.methods, t)) : (i.methods = t),
      (i.events = ['chainChanged', 'accountsChanged'])
  return n
}
const uz = {
    INVALID_METHOD: { message: 'Invalid method.', code: 1001 },
    INVALID_EVENT: { message: 'Invalid event.', code: 1002 },
    INVALID_UPDATE_REQUEST: { message: 'Invalid update request.', code: 1003 },
    INVALID_EXTEND_REQUEST: { message: 'Invalid extend request.', code: 1004 },
    INVALID_SESSION_SETTLE_REQUEST: { message: 'Invalid session settle request.', code: 1005 },
    UNAUTHORIZED_METHOD: { message: 'Unauthorized method.', code: 3001 },
    UNAUTHORIZED_EVENT: { message: 'Unauthorized event.', code: 3002 },
    UNAUTHORIZED_UPDATE_REQUEST: { message: 'Unauthorized update request.', code: 3003 },
    UNAUTHORIZED_EXTEND_REQUEST: { message: 'Unauthorized extend request.', code: 3004 },
    USER_REJECTED: { message: 'User rejected.', code: 5e3 },
    USER_REJECTED_CHAINS: { message: 'User rejected chains.', code: 5001 },
    USER_REJECTED_METHODS: { message: 'User rejected methods.', code: 5002 },
    USER_REJECTED_EVENTS: { message: 'User rejected events.', code: 5003 },
    UNSUPPORTED_CHAINS: { message: 'Unsupported chains.', code: 5100 },
    UNSUPPORTED_METHODS: { message: 'Unsupported methods.', code: 5101 },
    UNSUPPORTED_EVENTS: { message: 'Unsupported events.', code: 5102 },
    UNSUPPORTED_ACCOUNTS: { message: 'Unsupported accounts.', code: 5103 },
    UNSUPPORTED_NAMESPACE_KEY: { message: 'Unsupported namespace key.', code: 5104 },
    USER_DISCONNECTED: { message: 'User disconnected.', code: 6e3 },
    SESSION_SETTLEMENT_FAILED: { message: 'Session settlement failed.', code: 7e3 },
    WC_METHOD_UNSUPPORTED: { message: 'Unsupported wc_ method.', code: 10001 }
  },
  lz = {
    NOT_INITIALIZED: { message: 'Not initialized.', code: 1 },
    NO_MATCHING_KEY: { message: 'No matching key.', code: 2 },
    RESTORE_WILL_OVERRIDE: { message: 'Restore will override.', code: 3 },
    RESUBSCRIBED: { message: 'Resubscribed.', code: 4 },
    MISSING_OR_INVALID: { message: 'Missing or invalid.', code: 5 },
    EXPIRED: { message: 'Expired.', code: 6 },
    UNKNOWN_TYPE: { message: 'Unknown type.', code: 7 },
    MISMATCHED_TOPIC: { message: 'Mismatched topic.', code: 8 },
    NON_CONFORMING_NAMESPACES: { message: 'Non conforming namespaces.', code: 9 }
  }
function me(t, e) {
  const { message: n, code: r } = lz[t]
  return { message: e ? `${n} ${e}` : n, code: r }
}
function Qt(t, e) {
  const { message: n, code: r } = uz[t]
  return { message: e ? `${n} ${e}` : n, code: r }
}
function ru(t, e) {
  return !!Array.isArray(t)
}
function Ch(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length
}
function vr(t) {
  return typeof t > 'u'
}
function Vn(t, e) {
  return e && vr(t) ? !0 : typeof t == 'string' && !!t.trim().length
}
function o2(t, e) {
  return e && vr(t) ? !0 : typeof t == 'number' && !isNaN(t)
}
function dz(t, e) {
  const { requiredNamespaces: n } = e,
    r = Object.keys(t.namespaces),
    i = Object.keys(n)
  let s = !0
  return Rc(i, r)
    ? (r.forEach(c => {
        const { accounts: u, methods: f, events: d } = t.namespaces[c],
          p = _d(u),
          g = n[c]
        ;(!Rc(mx(c, g), p) || !Rc(g.methods, f) || !Rc(g.events, d)) && (s = !1)
      }),
      s)
    : !1
}
function Xg(t) {
  return Vn(t, !1) && t.includes(':') ? t.split(':').length === 2 : !1
}
function fz(t) {
  if (Vn(t, !1) && t.includes(':')) {
    const e = t.split(':')
    if (e.length === 3) {
      const n = e[0] + ':' + e[1]
      return !!e[2] && Xg(n)
    }
  }
  return !1
}
function hz(t) {
  function e(n) {
    try {
      return typeof new URL(n) < 'u'
    } catch {
      return !1
    }
  }
  try {
    if (Vn(t, !1)) {
      if (e(t)) return !0
      const n = Ex(t)
      return e(n)
    }
  } catch {}
  return !1
}
function pz(t) {
  var e
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey
}
function gz(t) {
  return t == null ? void 0 : t.topic
}
function mz(t, e) {
  let n = null
  return (
    Vn(t == null ? void 0 : t.publicKey, !1) ||
      (n = me('MISSING_OR_INVALID', `${e} controller public key should be a string`)),
    n
  )
}
function X5(t) {
  let e = !0
  return ru(t) ? t.length && (e = t.every(n => Vn(n, !1))) : (e = !1), e
}
function bz(t, e, n) {
  let r = null
  return (
    ru(e) && e.length
      ? e.forEach(i => {
          r ||
            Xg(i) ||
            (r = Qt(
              'UNSUPPORTED_CHAINS',
              `${n}, chain ${i} should be a string and conform to "namespace:chainId" format`
            ))
        })
      : Xg(t) ||
        (r = Qt(
          'UNSUPPORTED_CHAINS',
          `${n}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`
        )),
    r
  )
}
function yz(t, e, n) {
  let r = null
  return (
    Object.entries(t).forEach(([i, s]) => {
      if (r) return
      const c = bz(i, mx(i, s), `${e} ${n}`)
      c && (r = c)
    }),
    r
  )
}
function vz(t, e) {
  let n = null
  return (
    ru(t)
      ? t.forEach(r => {
          n ||
            fz(r) ||
            (n = Qt(
              'UNSUPPORTED_ACCOUNTS',
              `${e}, account ${r} should be a string and conform to "namespace:chainId:address" format`
            ))
        })
      : (n = Qt(
          'UNSUPPORTED_ACCOUNTS',
          `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`
        )),
    n
  )
}
function wz(t, e) {
  let n = null
  return (
    Object.values(t).forEach(r => {
      if (n) return
      const i = vz(r == null ? void 0 : r.accounts, `${e} namespace`)
      i && (n = i)
    }),
    n
  )
}
function Ez(t, e) {
  let n = null
  return (
    X5(t == null ? void 0 : t.methods)
      ? X5(t == null ? void 0 : t.events) ||
        (n = Qt(
          'UNSUPPORTED_EVENTS',
          `${e}, events should be an array of strings or empty array for no events`
        ))
      : (n = Qt(
          'UNSUPPORTED_METHODS',
          `${e}, methods should be an array of strings or empty array for no methods`
        )),
    n
  )
}
function Gx(t, e) {
  let n = null
  return (
    Object.values(t).forEach(r => {
      if (n) return
      const i = Ez(r, `${e}, namespace`)
      i && (n = i)
    }),
    n
  )
}
function Az(t, e, n) {
  let r = null
  if (t && Ch(t)) {
    const i = Gx(t, e)
    i && (r = i)
    const s = yz(t, e, n)
    s && (r = s)
  } else r = me('MISSING_OR_INVALID', `${e}, ${n} should be an object with data`)
  return r
}
function g1(t, e) {
  let n = null
  if (t && Ch(t)) {
    const r = Gx(t, e)
    r && (n = r)
    const i = wz(t, e)
    i && (n = i)
  } else n = me('MISSING_OR_INVALID', `${e}, namespaces should be an object with data`)
  return n
}
function Vx(t) {
  return Vn(t.protocol, !0)
}
function _z(t, e) {
  let n = !1
  return (
    t
      ? t &&
        ru(t) &&
        t.length &&
        t.forEach(r => {
          n = Vx(r)
        })
      : (n = !0),
    n
  )
}
function Cz(t) {
  return typeof t == 'number'
}
function Zr(t) {
  return typeof t < 'u' && typeof t !== null
}
function Sz(t) {
  return !(
    !t ||
    typeof t != 'object' ||
    !t.code ||
    !o2(t.code, !1) ||
    !t.message ||
    !Vn(t.message, !1)
  )
}
function Tz(t) {
  return !(vr(t) || !Vn(t.method, !1))
}
function xz(t) {
  return !(vr(t) || (vr(t.result) && vr(t.error)) || !o2(t.id, !1) || !Vn(t.jsonrpc, !1))
}
function Nz(t) {
  return !(vr(t) || !Vn(t.name, !1))
}
function J5(t, e) {
  return !(!Xg(e) || !sz(t).includes(e))
}
function Iz(t, e, n) {
  return Vn(n, !1) ? az(t, e).includes(n) : !1
}
function Oz(t, e, n) {
  return Vn(n, !1) ? oz(t, e).includes(n) : !1
}
function e6(t, e, n) {
  let r = null
  const i = Rz(t),
    s = Dz(e),
    c = Object.keys(i),
    u = Object.keys(s),
    f = t6(Object.keys(t)),
    d = t6(Object.keys(e)),
    p = f.filter(g => !d.includes(g))
  return (
    p.length &&
      (r = me(
        'NON_CONFORMING_NAMESPACES',
        `${n} namespaces keys don't satisfy requiredNamespaces.
      Required: ${p.toString()}
      Received: ${Object.keys(e).toString()}`
      )),
    Rc(c, u) ||
      (r = me(
        'NON_CONFORMING_NAMESPACES',
        `${n} namespaces chains don't satisfy required namespaces.
      Required: ${c.toString()}
      Approved: ${u.toString()}`
      )),
    Object.keys(e).forEach(g => {
      if (!g.includes(':') || r) return
      const m = _d(e[g].accounts)
      m.includes(g) ||
        (r = me(
          'NON_CONFORMING_NAMESPACES',
          `${n} namespaces accounts don't satisfy namespace accounts for ${g}
        Required: ${g}
        Approved: ${m.toString()}`
        ))
    }),
    c.forEach(g => {
      r ||
        (Rc(i[g].methods, s[g].methods)
          ? Rc(i[g].events, s[g].events) ||
            (r = me(
              'NON_CONFORMING_NAMESPACES',
              `${n} namespaces events don't satisfy namespace events for ${g}`
            ))
          : (r = me(
              'NON_CONFORMING_NAMESPACES',
              `${n} namespaces methods don't satisfy namespace methods for ${g}`
            )))
    }),
    r
  )
}
function Rz(t) {
  const e = {}
  return (
    Object.keys(t).forEach(n => {
      var r
      n.includes(':')
        ? (e[n] = t[n])
        : (r = t[n].chains) == null ||
          r.forEach(i => {
            e[i] = { methods: t[n].methods, events: t[n].events }
          })
    }),
    e
  )
}
function t6(t) {
  return [...new Set(t.map(e => (e.includes(':') ? e.split(':')[0] : e)))]
}
function Dz(t) {
  const e = {}
  return (
    Object.keys(t).forEach(n => {
      if (n.includes(':')) e[n] = t[n]
      else {
        const r = _d(t[n].accounts)
        r == null ||
          r.forEach(i => {
            e[i] = {
              accounts: t[n].accounts.filter(s => s.includes(`${i}:`)),
              methods: t[n].methods,
              events: t[n].events
            }
          })
      }
    }),
    e
  )
}
function Pz(t, e) {
  return o2(t, !1) && t <= e.max && t >= e.min
}
function n6() {
  const t = Ep()
  return new Promise(e => {
    switch (t) {
      case mi.browser:
        e(Mz())
        break
      case mi.reactNative:
        e(kz())
        break
      case mi.node:
        e(Uz())
        break
      default:
        e(!0)
    }
  })
}
function Mz() {
  return wp() && (navigator == null ? void 0 : navigator.onLine)
}
async function kz() {
  if (Yo() && typeof global < 'u' && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch())
    return t == null ? void 0 : t.isConnected
  }
  return !0
}
function Uz() {
  return !0
}
function Bz(t) {
  switch (Ep()) {
    case mi.browser:
      Lz(t)
      break
    case mi.reactNative:
      $z(t)
      break
  }
}
function Lz(t) {
  !Yo() &&
    wp() &&
    (window.addEventListener('online', () => t(!0)),
    window.addEventListener('offline', () => t(!1)))
}
function $z(t) {
  Yo() &&
    typeof global < 'u' &&
    global != null &&
    global.NetInfo &&
    (global == null || global.NetInfo.addEventListener(e => t(e == null ? void 0 : e.isConnected)))
}
const m1 = {}
class zf {
  static get(e) {
    return m1[e]
  }
  static set(e, n) {
    m1[e] = n
  }
  static delete(e) {
    delete m1[e]
  }
}
const Fz = 'PARSE_ERROR',
  jz = 'INVALID_REQUEST',
  zz = 'METHOD_NOT_FOUND',
  qz = 'INVALID_PARAMS',
  Kx = 'INTERNAL_ERROR',
  c2 = 'SERVER_ERROR',
  Hz = [-32700, -32600, -32601, -32602, -32603],
  uh = {
    [Fz]: { code: -32700, message: 'Parse error' },
    [jz]: { code: -32600, message: 'Invalid Request' },
    [zz]: { code: -32601, message: 'Method not found' },
    [qz]: { code: -32602, message: 'Invalid params' },
    [Kx]: { code: -32603, message: 'Internal error' },
    [c2]: { code: -32e3, message: 'Server error' }
  },
  Wx = c2
function Gz(t) {
  return Hz.includes(t)
}
function r6(t) {
  return Object.keys(uh).includes(t) ? uh[t] : uh[Wx]
}
function Vz(t) {
  const e = Object.values(uh).find(n => n.code === t)
  return e || uh[Wx]
}
function Qx(t, e, n) {
  return t.message.includes('getaddrinfo ENOTFOUND') || t.message.includes('connect ECONNREFUSED')
    ? new Error(`Unavailable ${n} RPC url at ${e}`)
    : t
}
var b1 = {},
  va = {},
  i6
function Kz() {
  if (i6) return va
  ;(i6 = 1),
    Object.defineProperty(va, '__esModule', { value: !0 }),
    (va.isBrowserCryptoAvailable = va.getSubtleCrypto = va.getBrowerCrypto = void 0)
  function t() {
    return ($s == null ? void 0 : $s.crypto) || ($s == null ? void 0 : $s.msCrypto) || {}
  }
  va.getBrowerCrypto = t
  function e() {
    const r = t()
    return r.subtle || r.webkitSubtle
  }
  va.getSubtleCrypto = e
  function n() {
    return !!t() && !!e()
  }
  return (va.isBrowserCryptoAvailable = n), va
}
var wa = {},
  s6
function Wz() {
  if (s6) return wa
  ;(s6 = 1),
    Object.defineProperty(wa, '__esModule', { value: !0 }),
    (wa.isBrowser = wa.isNode = wa.isReactNative = void 0)
  function t() {
    return typeof document > 'u' && typeof navigator < 'u' && navigator.product === 'ReactNative'
  }
  wa.isReactNative = t
  function e() {
    return (
      typeof process < 'u' && typeof process.versions < 'u' && typeof process.versions.node < 'u'
    )
  }
  wa.isNode = e
  function n() {
    return !t() && !e()
  }
  return (wa.isBrowser = n), wa
}
var a6
function Qz() {
  return (
    a6 ||
      ((a6 = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 })
        const e = fp
        e.__exportStar(Kz(), t), e.__exportStar(Wz(), t)
      })(b1)),
    b1
  )
}
var Yz = Qz()
function Ps(t = 3) {
  const e = Date.now() * Math.pow(10, t),
    n = Math.floor(Math.random() * Math.pow(10, t))
  return e + n
}
function Dc(t = 6) {
  return BigInt(Ps(t))
}
function Uo(t, e, n) {
  return { id: n || Ps(), jsonrpc: '2.0', method: t, params: e }
}
function Bm(t, e) {
  return { id: t, jsonrpc: '2.0', result: e }
}
function Lm(t, e, n) {
  return { id: t, jsonrpc: '2.0', error: Zz(e) }
}
function Zz(t, e) {
  return typeof t > 'u'
    ? r6(Kx)
    : (typeof t == 'string' && (t = Object.assign(Object.assign({}, r6(c2)), { message: t })),
      Gz(t.code) && (t = Vz(t.code)),
      t)
}
let Xz = class {},
  Jz = class extends Xz {
    constructor() {
      super()
    }
  },
  eq = class extends Jz {
    constructor(e) {
      super()
    }
  }
const tq = '^https?:',
  nq = '^wss?:'
function rq(t) {
  const e = t.match(new RegExp(/^\w+:/, 'gi'))
  if (!(!e || !e.length)) return e[0]
}
function Yx(t, e) {
  const n = rq(t)
  return typeof n > 'u' ? !1 : new RegExp(e).test(n)
}
function o6(t) {
  return Yx(t, tq)
}
function c6(t) {
  return Yx(t, nq)
}
function iq(t) {
  return new RegExp('wss?://localhost(:d{2,5})?').test(t)
}
function Zx(t) {
  return typeof t == 'object' && 'id' in t && 'jsonrpc' in t && t.jsonrpc === '2.0'
}
function u2(t) {
  return Zx(t) && 'method' in t
}
function $m(t) {
  return Zx(t) && (Ms(t) || Li(t))
}
function Ms(t) {
  return 'result' in t
}
function Li(t) {
  return 'error' in t
}
let Gi = class extends eq {
  constructor(e) {
    super(e),
      (this.events = new zi.EventEmitter()),
      (this.hasRegisteredEventListeners = !1),
      (this.connection = this.setConnection(e)),
      this.connection.connected && this.registerEventListeners()
  }
  async connect(e = this.connection) {
    await this.open(e)
  }
  async disconnect() {
    await this.close()
  }
  on(e, n) {
    this.events.on(e, n)
  }
  once(e, n) {
    this.events.once(e, n)
  }
  off(e, n) {
    this.events.off(e, n)
  }
  removeListener(e, n) {
    this.events.removeListener(e, n)
  }
  async request(e, n) {
    return this.requestStrict(Uo(e.method, e.params || [], e.id || Dc().toString()), n)
  }
  async requestStrict(e, n) {
    return new Promise(async (r, i) => {
      if (!this.connection.connected)
        try {
          await this.open()
        } catch (s) {
          i(s)
        }
      this.events.on(`${e.id}`, s => {
        Li(s) ? i(s.error) : r(s.result)
      })
      try {
        await this.connection.send(e, n)
      } catch (s) {
        i(s)
      }
    })
  }
  setConnection(e = this.connection) {
    return e
  }
  onPayload(e) {
    this.events.emit('payload', e),
      $m(e)
        ? this.events.emit(`${e.id}`, e)
        : this.events.emit('message', { type: e.method, data: e.params })
  }
  onClose(e) {
    e &&
      e.code === 3e3 &&
      this.events.emit(
        'error',
        new Error(
          `WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ''}`
        )
      ),
      this.events.emit('disconnect')
  }
  async open(e = this.connection) {
    ;(this.connection === e && this.connection.connected) ||
      (this.connection.connected && this.close(),
      typeof e == 'string' && (await this.connection.open(e), (e = this.connection)),
      (this.connection = this.setConnection(e)),
      await this.connection.open(),
      this.registerEventListeners(),
      this.events.emit('connect'))
  }
  async close() {
    await this.connection.close()
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners ||
      (this.connection.on('payload', e => this.onPayload(e)),
      this.connection.on('close', e => this.onClose(e)),
      this.connection.on('error', e => this.events.emit('error', e)),
      this.connection.on('register_error', e => this.onClose()),
      (this.hasRegisteredEventListeners = !0))
  }
}
const sq = () =>
    typeof WebSocket < 'u'
      ? WebSocket
      : typeof global < 'u' && typeof global.WebSocket < 'u'
        ? global.WebSocket
        : typeof window < 'u' && typeof window.WebSocket < 'u'
          ? window.WebSocket
          : typeof self < 'u' && typeof self.WebSocket < 'u'
            ? self.WebSocket
            : require('ws'),
  aq = () =>
    typeof WebSocket < 'u' ||
    (typeof global < 'u' && typeof global.WebSocket < 'u') ||
    (typeof window < 'u' && typeof window.WebSocket < 'u') ||
    (typeof self < 'u' && typeof self.WebSocket < 'u'),
  u6 = t => t.split('?')[0],
  l6 = 10,
  oq = sq()
let cq = class {
  constructor(e) {
    if (((this.url = e), (this.events = new zi.EventEmitter()), (this.registering = !1), !c6(e)))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`)
    this.url = e
  }
  get connected() {
    return typeof this.socket < 'u'
  }
  get connecting() {
    return this.registering
  }
  on(e, n) {
    this.events.on(e, n)
  }
  once(e, n) {
    this.events.once(e, n)
  }
  off(e, n) {
    this.events.off(e, n)
  }
  removeListener(e, n) {
    this.events.removeListener(e, n)
  }
  async open(e = this.url) {
    await this.register(e)
  }
  async close() {
    return new Promise((e, n) => {
      if (typeof this.socket > 'u') {
        n(new Error('Connection already closed'))
        return
      }
      ;(this.socket.onclose = r => {
        this.onClose(r), e()
      }),
        this.socket.close()
    })
  }
  async send(e) {
    typeof this.socket > 'u' && (this.socket = await this.register())
    try {
      this.socket.send(ka(e))
    } catch (n) {
      this.onError(e.id, n)
    }
  }
  register(e = this.url) {
    if (!c6(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`)
    if (this.registering) {
      const n = this.events.getMaxListeners()
      return (
        (this.events.listenerCount('register_error') >= n ||
          this.events.listenerCount('open') >= n) &&
          this.events.setMaxListeners(n + 1),
        new Promise((r, i) => {
          this.events.once('register_error', s => {
            this.resetMaxListeners(), i(s)
          }),
            this.events.once('open', () => {
              if ((this.resetMaxListeners(), typeof this.socket > 'u'))
                return i(new Error('WebSocket connection is missing or invalid'))
              r(this.socket)
            })
        })
      )
    }
    return (
      (this.url = e),
      (this.registering = !0),
      new Promise((n, r) => {
        const i = Yz.isReactNative() ? void 0 : { rejectUnauthorized: !iq(e) },
          s = new oq(e, [], i)
        aq()
          ? (s.onerror = c => {
              const u = c
              r(this.emitError(u.error))
            })
          : s.on('error', c => {
              r(this.emitError(c))
            }),
          (s.onopen = () => {
            this.onOpen(s), n(s)
          })
      })
    )
  }
  onOpen(e) {
    ;(e.onmessage = n => this.onPayload(n)),
      (e.onclose = n => this.onClose(n)),
      (this.socket = e),
      (this.registering = !1),
      this.events.emit('open')
  }
  onClose(e) {
    ;(this.socket = void 0), (this.registering = !1), this.events.emit('close', e)
  }
  onPayload(e) {
    if (typeof e.data > 'u') return
    const n = typeof e.data == 'string' ? Xc(e.data) : e.data
    this.events.emit('payload', n)
  }
  onError(e, n) {
    const r = this.parseError(n),
      i = r.message || r.toString(),
      s = Lm(e, i)
    this.events.emit('payload', s)
  }
  parseError(e, n = this.url) {
    return Qx(e, u6(n), 'WS')
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > l6 && this.events.setMaxListeners(l6)
  }
  emitError(e) {
    const n = this.parseError(
      new Error(
        (e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${u6(this.url)}`
      )
    )
    return this.events.emit('register_error', n), n
  }
}
const Xx = 'wc',
  Jx = 2,
  Dw = 'core',
  zs = `${Xx}@2:${Dw}:`,
  uq = { logger: 'error' },
  lq = { database: ':memory:' },
  dq = 'crypto',
  d6 = 'client_ed25519_seed',
  fq = ge.ONE_DAY,
  hq = 'keychain',
  pq = '0.3',
  gq = 'messages',
  mq = '0.3',
  f6 = ge.SIX_HOURS,
  bq = 'publisher',
  eN = 'irn',
  yq = 'error',
  tN = 'wss://relay.walletconnect.org',
  vq = 'relayer',
  or = {
    message: 'relayer_message',
    message_ack: 'relayer_message_ack',
    connect: 'relayer_connect',
    disconnect: 'relayer_disconnect',
    error: 'relayer_error',
    connection_stalled: 'relayer_connection_stalled',
    transport_closed: 'relayer_transport_closed',
    publish: 'relayer_publish'
  },
  wq = '_subscription',
  Ri = { payload: 'payload', connect: 'connect', disconnect: 'disconnect', error: 'error' },
  Eq = 0.1,
  Pw = '2.19.1',
  hn = { link_mode: 'link_mode', relay: 'relay' },
  Og = { inbound: 'inbound', outbound: 'outbound' },
  Aq = '0.3',
  _q = 'WALLETCONNECT_CLIENT_ID',
  h6 = 'WALLETCONNECT_LINK_MODE_APPS',
  hi = {
    created: 'subscription_created',
    deleted: 'subscription_deleted',
    expired: 'subscription_expired',
    disabled: 'subscription_disabled',
    sync: 'subscription_sync',
    resubscribed: 'subscription_resubscribed'
  },
  Cq = 'subscription',
  Sq = '0.3',
  Tq = 'pairing',
  xq = '0.3',
  qf = {
    wc_pairingDelete: {
      req: { ttl: ge.ONE_DAY, prompt: !1, tag: 1e3 },
      res: { ttl: ge.ONE_DAY, prompt: !1, tag: 1001 }
    },
    wc_pairingPing: {
      req: { ttl: ge.THIRTY_SECONDS, prompt: !1, tag: 1002 },
      res: { ttl: ge.THIRTY_SECONDS, prompt: !1, tag: 1003 }
    },
    unregistered_method: {
      req: { ttl: ge.ONE_DAY, prompt: !1, tag: 0 },
      res: { ttl: ge.ONE_DAY, prompt: !1, tag: 0 }
    }
  },
  Ic = {
    create: 'pairing_create',
    expire: 'pairing_expire',
    delete: 'pairing_delete',
    ping: 'pairing_ping'
  },
  ts = {
    created: 'history_created',
    updated: 'history_updated',
    deleted: 'history_deleted',
    sync: 'history_sync'
  },
  Nq = 'history',
  Iq = '0.3',
  Oq = 'expirer',
  Ui = {
    created: 'expirer_created',
    deleted: 'expirer_deleted',
    expired: 'expirer_expired',
    sync: 'expirer_sync'
  },
  Rq = '0.3',
  Dq = 'verify-api',
  Pq = 'https://verify.walletconnect.com',
  nN = 'https://verify.walletconnect.org',
  lh = nN,
  Mq = `${lh}/v3`,
  kq = [Pq, nN],
  Uq = 'echo',
  Bq = 'https://echo.walletconnect.com',
  Ds = {
    pairing_started: 'pairing_started',
    pairing_uri_validation_success: 'pairing_uri_validation_success',
    pairing_uri_not_expired: 'pairing_uri_not_expired',
    store_new_pairing: 'store_new_pairing',
    subscribing_pairing_topic: 'subscribing_pairing_topic',
    subscribe_pairing_topic_success: 'subscribe_pairing_topic_success',
    existing_pairing: 'existing_pairing',
    pairing_not_expired: 'pairing_not_expired',
    emit_inactive_pairing: 'emit_inactive_pairing',
    emit_session_proposal: 'emit_session_proposal',
    subscribing_to_pairing_topic: 'subscribing_to_pairing_topic'
  },
  Ca = {
    no_wss_connection: 'no_wss_connection',
    no_internet_connection: 'no_internet_connection',
    malformed_pairing_uri: 'malformed_pairing_uri',
    active_pairing_already_exists: 'active_pairing_already_exists',
    subscribe_pairing_topic_failure: 'subscribe_pairing_topic_failure',
    pairing_expired: 'pairing_expired',
    proposal_expired: 'proposal_expired',
    proposal_listener_not_found: 'proposal_listener_not_found'
  },
  ns = {
    session_approve_started: 'session_approve_started',
    proposal_not_expired: 'proposal_not_expired',
    session_namespaces_validation_success: 'session_namespaces_validation_success',
    create_session_topic: 'create_session_topic',
    subscribing_session_topic: 'subscribing_session_topic',
    subscribe_session_topic_success: 'subscribe_session_topic_success',
    publishing_session_approve: 'publishing_session_approve',
    session_approve_publish_success: 'session_approve_publish_success',
    store_session: 'store_session',
    publishing_session_settle: 'publishing_session_settle',
    session_settle_publish_success: 'session_settle_publish_success'
  },
  Ac = {
    no_internet_connection: 'no_internet_connection',
    no_wss_connection: 'no_wss_connection',
    proposal_expired: 'proposal_expired',
    subscribe_session_topic_failure: 'subscribe_session_topic_failure',
    session_approve_publish_failure: 'session_approve_publish_failure',
    session_settle_publish_failure: 'session_settle_publish_failure',
    session_approve_namespace_validation_failure: 'session_approve_namespace_validation_failure',
    proposal_not_found: 'proposal_not_found'
  },
  _c = {
    authenticated_session_approve_started: 'authenticated_session_approve_started',
    create_authenticated_session_topic: 'create_authenticated_session_topic',
    cacaos_verified: 'cacaos_verified',
    store_authenticated_session: 'store_authenticated_session',
    subscribing_authenticated_session_topic: 'subscribing_authenticated_session_topic',
    subscribe_authenticated_session_topic_success: 'subscribe_authenticated_session_topic_success',
    publishing_authenticated_session_approve: 'publishing_authenticated_session_approve'
  },
  Hf = {
    no_internet_connection: 'no_internet_connection',
    invalid_cacao: 'invalid_cacao',
    subscribe_authenticated_session_topic_failure: 'subscribe_authenticated_session_topic_failure',
    authenticated_session_approve_publish_failure: 'authenticated_session_approve_publish_failure',
    authenticated_session_pending_request_not_found:
      'authenticated_session_pending_request_not_found'
  },
  Lq = 0.1,
  $q = 'event-client',
  Fq = 86400,
  jq = 'https://pulse.walletconnect.org/batch'
function zq(t, e) {
  if (t.length >= 255) throw new TypeError('Alphabet too long')
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i),
      c = s.charCodeAt(0)
    if (n[c] !== 255) throw new TypeError(s + ' is ambiguous')
    n[c] = i
  }
  var u = t.length,
    f = t.charAt(0),
    d = Math.log(u) / Math.log(256),
    p = Math.log(256) / Math.log(u)
  function g(A) {
    if (
      (A instanceof Uint8Array ||
        (ArrayBuffer.isView(A)
          ? (A = new Uint8Array(A.buffer, A.byteOffset, A.byteLength))
          : Array.isArray(A) && (A = Uint8Array.from(A))),
      !(A instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (A.length === 0) return ''
    for (var E = 0, x = 0, O = 0, I = A.length; O !== I && A[O] === 0; ) O++, E++
    for (var M = ((I - O) * p + 1) >>> 0, $ = new Uint8Array(M); O !== I; ) {
      for (var D = A[O], R = 0, z = M - 1; (D !== 0 || R < x) && z !== -1; z--, R++)
        (D += (256 * $[z]) >>> 0), ($[z] = D % u >>> 0), (D = (D / u) >>> 0)
      if (D !== 0) throw new Error('Non-zero carry')
      ;(x = R), O++
    }
    for (var G = M - x; G !== M && $[G] === 0; ) G++
    for (var j = f.repeat(E); G < M; ++G) j += t.charAt($[G])
    return j
  }
  function m(A) {
    if (typeof A != 'string') throw new TypeError('Expected String')
    if (A.length === 0) return new Uint8Array()
    var E = 0
    if (A[E] !== ' ') {
      for (var x = 0, O = 0; A[E] === f; ) x++, E++
      for (var I = ((A.length - E) * d + 1) >>> 0, M = new Uint8Array(I); A[E]; ) {
        var $ = n[A.charCodeAt(E)]
        if ($ === 255) return
        for (var D = 0, R = I - 1; ($ !== 0 || D < O) && R !== -1; R--, D++)
          ($ += (u * M[R]) >>> 0), (M[R] = $ % 256 >>> 0), ($ = ($ / 256) >>> 0)
        if ($ !== 0) throw new Error('Non-zero carry')
        ;(O = D), E++
      }
      if (A[E] !== ' ') {
        for (var z = I - O; z !== I && M[z] === 0; ) z++
        for (var G = new Uint8Array(x + (I - z)), j = x; z !== I; ) G[j++] = M[z++]
        return G
      }
    }
  }
  function y(A) {
    var E = m(A)
    if (E) return E
    throw new Error(`Non-${e} character`)
  }
  return { encode: g, decodeUnsafe: m, decode: y }
}
var qq = zq,
  Hq = qq
const rN = t => {
    if (t instanceof Uint8Array && t.constructor.name === 'Uint8Array') return t
    if (t instanceof ArrayBuffer) return new Uint8Array(t)
    if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
    throw new Error('Unknown type, must be binary type')
  },
  Gq = t => new TextEncoder().encode(t),
  Vq = t => new TextDecoder().decode(t)
class Kq {
  constructor(e, n, r) {
    ;(this.name = e), (this.prefix = n), (this.baseEncode = r)
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
    throw Error('Unknown type, must be binary type')
  }
}
class Wq {
  constructor(e, n, r) {
    if (((this.name = e), (this.prefix = n), n.codePointAt(0) === void 0))
      throw new Error('Invalid prefix character')
    ;(this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = r)
  }
  decode(e) {
    if (typeof e == 'string') {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(
          `Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`
        )
      return this.baseDecode(e.slice(this.prefix.length))
    } else throw Error('Can only multibase decode strings')
  }
  or(e) {
    return iN(this, e)
  }
}
class Qq {
  constructor(e) {
    this.decoders = e
  }
  or(e) {
    return iN(this, e)
  }
  decode(e) {
    const n = e[0],
      r = this.decoders[n]
    if (r) return r.decode(e)
    throw RangeError(
      `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
    )
  }
}
const iN = (t, e) =>
  new Qq({ ...(t.decoders || { [t.prefix]: t }), ...(e.decoders || { [e.prefix]: e }) })
class Yq {
  constructor(e, n, r, i) {
    ;(this.name = e),
      (this.prefix = n),
      (this.baseEncode = r),
      (this.baseDecode = i),
      (this.encoder = new Kq(e, n, r)),
      (this.decoder = new Wq(e, n, i))
  }
  encode(e) {
    return this.encoder.encode(e)
  }
  decode(e) {
    return this.decoder.decode(e)
  }
}
const Fm = ({ name: t, prefix: e, encode: n, decode: r }) => new Yq(t, e, n, r),
  Sp = ({ prefix: t, name: e, alphabet: n }) => {
    const { encode: r, decode: i } = Hq(n, e)
    return Fm({ prefix: t, name: e, encode: r, decode: s => rN(i(s)) })
  },
  Zq = (t, e, n, r) => {
    const i = {}
    for (let p = 0; p < e.length; ++p) i[e[p]] = p
    let s = t.length
    for (; t[s - 1] === '='; ) --s
    const c = new Uint8Array(((s * n) / 8) | 0)
    let u = 0,
      f = 0,
      d = 0
    for (let p = 0; p < s; ++p) {
      const g = i[t[p]]
      if (g === void 0) throw new SyntaxError(`Non-${r} character`)
      ;(f = (f << n) | g), (u += n), u >= 8 && ((u -= 8), (c[d++] = 255 & (f >> u)))
    }
    if (u >= n || 255 & (f << (8 - u))) throw new SyntaxError('Unexpected end of data')
    return c
  },
  Xq = (t, e, n) => {
    const r = e[e.length - 1] === '=',
      i = (1 << n) - 1
    let s = '',
      c = 0,
      u = 0
    for (let f = 0; f < t.length; ++f)
      for (u = (u << 8) | t[f], c += 8; c > n; ) (c -= n), (s += e[i & (u >> c)])
    if ((c && (s += e[i & (u << (n - c))]), r)) for (; (s.length * n) & 7; ) s += '='
    return s
  },
  _r = ({ name: t, prefix: e, bitsPerChar: n, alphabet: r }) =>
    Fm({
      prefix: e,
      name: t,
      encode(i) {
        return Xq(i, r, n)
      },
      decode(i) {
        return Zq(i, r, n, t)
      }
    }),
  Jq = Fm({ prefix: '\0', name: 'identity', encode: t => Vq(t), decode: t => Gq(t) })
var eH = Object.freeze({ __proto__: null, identity: Jq })
const tH = _r({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 })
var nH = Object.freeze({ __proto__: null, base2: tH })
const rH = _r({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 })
var iH = Object.freeze({ __proto__: null, base8: rH })
const sH = Sp({ prefix: '9', name: 'base10', alphabet: '0123456789' })
var aH = Object.freeze({ __proto__: null, base10: sH })
const oH = _r({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 }),
  cH = _r({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 })
var uH = Object.freeze({ __proto__: null, base16: oH, base16upper: cH })
const lH = _r({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
  }),
  dH = _r({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
  }),
  fH = _r({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
  }),
  hH = _r({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
  }),
  pH = _r({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
  }),
  gH = _r({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
  }),
  mH = _r({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
  }),
  bH = _r({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
  }),
  yH = _r({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
  })
var vH = Object.freeze({
  __proto__: null,
  base32: lH,
  base32upper: dH,
  base32pad: fH,
  base32padupper: hH,
  base32hex: pH,
  base32hexupper: gH,
  base32hexpad: mH,
  base32hexpadupper: bH,
  base32z: yH
})
const wH = Sp({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' }),
  EH = Sp({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' })
var AH = Object.freeze({ __proto__: null, base36: wH, base36upper: EH })
const _H = Sp({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
  }),
  CH = Sp({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
  })
var SH = Object.freeze({ __proto__: null, base58btc: _H, base58flickr: CH })
const TH = _r({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
  }),
  xH = _r({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
  }),
  NH = _r({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
  }),
  IH = _r({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
  })
var OH = Object.freeze({
  __proto__: null,
  base64: TH,
  base64pad: xH,
  base64url: NH,
  base64urlpad: IH
})
const sN = Array.from(
    '🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂'
  ),
  RH = sN.reduce((t, e, n) => ((t[n] = e), t), []),
  DH = sN.reduce((t, e, n) => ((t[e.codePointAt(0)] = n), t), [])
function PH(t) {
  return t.reduce((e, n) => ((e += RH[n]), e), '')
}
function MH(t) {
  const e = []
  for (const n of t) {
    const r = DH[n.codePointAt(0)]
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`)
    e.push(r)
  }
  return new Uint8Array(e)
}
const kH = Fm({ prefix: '🚀', name: 'base256emoji', encode: PH, decode: MH })
var UH = Object.freeze({ __proto__: null, base256emoji: kH }),
  BH = aN,
  p6 = 128,
  LH = -128,
  $H = Math.pow(2, 31)
function aN(t, e, n) {
  ;(e = e || []), (n = n || 0)
  for (var r = n; t >= $H; ) (e[n++] = (t & 255) | p6), (t /= 128)
  for (; t & LH; ) (e[n++] = (t & 255) | p6), (t >>>= 7)
  return (e[n] = t | 0), (aN.bytes = n - r + 1), e
}
var FH = Mw,
  jH = 128,
  g6 = 127
function Mw(t, r) {
  var n = 0,
    r = r || 0,
    i = 0,
    s = r,
    c,
    u = t.length
  do {
    if (s >= u) throw ((Mw.bytes = 0), new RangeError('Could not decode varint'))
    ;(c = t[s++]), (n += i < 28 ? (c & g6) << i : (c & g6) * Math.pow(2, i)), (i += 7)
  } while (c >= jH)
  return (Mw.bytes = s - r), n
}
var zH = Math.pow(2, 7),
  qH = Math.pow(2, 14),
  HH = Math.pow(2, 21),
  GH = Math.pow(2, 28),
  VH = Math.pow(2, 35),
  KH = Math.pow(2, 42),
  WH = Math.pow(2, 49),
  QH = Math.pow(2, 56),
  YH = Math.pow(2, 63),
  ZH = function (t) {
    return t < zH
      ? 1
      : t < qH
        ? 2
        : t < HH
          ? 3
          : t < GH
            ? 4
            : t < VH
              ? 5
              : t < KH
                ? 6
                : t < WH
                  ? 7
                  : t < QH
                    ? 8
                    : t < YH
                      ? 9
                      : 10
  },
  XH = { encode: BH, decode: FH, encodingLength: ZH },
  oN = XH
const m6 = (t, e, n = 0) => (oN.encode(t, e, n), e),
  b6 = t => oN.encodingLength(t),
  kw = (t, e) => {
    const n = e.byteLength,
      r = b6(t),
      i = r + b6(n),
      s = new Uint8Array(i + n)
    return m6(t, s, 0), m6(n, s, r), s.set(e, i), new JH(t, n, e, s)
  }
class JH {
  constructor(e, n, r, i) {
    ;(this.code = e), (this.size = n), (this.digest = r), (this.bytes = i)
  }
}
const cN = ({ name: t, code: e, encode: n }) => new eG(t, e, n)
class eG {
  constructor(e, n, r) {
    ;(this.name = e), (this.code = n), (this.encode = r)
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const n = this.encode(e)
      return n instanceof Uint8Array ? kw(this.code, n) : n.then(r => kw(this.code, r))
    } else throw Error('Unknown type, must be binary type')
  }
}
const uN = t => async e => new Uint8Array(await crypto.subtle.digest(t, e)),
  tG = cN({ name: 'sha2-256', code: 18, encode: uN('SHA-256') }),
  nG = cN({ name: 'sha2-512', code: 19, encode: uN('SHA-512') })
var rG = Object.freeze({ __proto__: null, sha256: tG, sha512: nG })
const lN = 0,
  iG = 'identity',
  dN = rN,
  sG = t => kw(lN, dN(t)),
  aG = { code: lN, name: iG, encode: dN, digest: sG }
var oG = Object.freeze({ __proto__: null, identity: aG })
new TextEncoder(), new TextDecoder()
const y6 = { ...eH, ...nH, ...iH, ...aH, ...uH, ...vH, ...AH, ...SH, ...OH, ...UH }
;({ ...rG, ...oG })
function cG(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? globalThis.Buffer.allocUnsafe(t)
    : new Uint8Array(t)
}
function fN(t, e, n, r) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: n }, decoder: { decode: r } }
}
const v6 = fN(
    'utf8',
    'u',
    t => 'u' + new TextDecoder('utf8').decode(t),
    t => new TextEncoder().encode(t.substring(1))
  ),
  y1 = fN(
    'ascii',
    'a',
    t => {
      let e = 'a'
      for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n])
      return e
    },
    t => {
      t = t.substring(1)
      const e = cG(t.length)
      for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n)
      return e
    }
  ),
  uG = { utf8: v6, 'utf-8': v6, hex: y6.base16, latin1: y1, ascii: y1, binary: y1, ...y6 }
function lG(t, e = 'utf8') {
  const n = uG[e]
  if (!n) throw new Error(`Unsupported encoding "${e}"`)
  return (e === 'utf8' || e === 'utf-8') &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t, 'utf8')
    : n.decoder.decode(`${n.prefix}${t}`)
}
var dG = Object.defineProperty,
  fG = (t, e, n) =>
    e in t ? dG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Is = (t, e, n) => fG(t, typeof e != 'symbol' ? e + '' : e, n)
class hG {
  constructor(e, n) {
    ;(this.core = e),
      (this.logger = n),
      Is(this, 'keychain', new Map()),
      Is(this, 'name', hq),
      Is(this, 'version', pq),
      Is(this, 'initialized', !1),
      Is(this, 'storagePrefix', zs),
      Is(this, 'init', async () => {
        if (!this.initialized) {
          const r = await this.getKeyChain()
          typeof r < 'u' && (this.keychain = r), (this.initialized = !0)
        }
      }),
      Is(this, 'has', r => (this.isInitialized(), this.keychain.has(r))),
      Is(this, 'set', async (r, i) => {
        this.isInitialized(), this.keychain.set(r, i), await this.persist()
      }),
      Is(this, 'get', r => {
        this.isInitialized()
        const i = this.keychain.get(r)
        if (typeof i > 'u') {
          const { message: s } = me('NO_MATCHING_KEY', `${this.name}: ${r}`)
          throw new Error(s)
        }
        return i
      }),
      Is(this, 'del', async r => {
        this.isInitialized(), this.keychain.delete(r), await this.persist()
      }),
      (this.core = e),
      (this.logger = Pr(n, this.name))
  }
  get context() {
    return ni(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, _w(e))
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey)
    return typeof e < 'u' ? Cw(e) : void 0
  }
  async persist() {
    await this.setKeyChain(this.keychain)
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = me('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
}
var pG = Object.defineProperty,
  gG = (t, e, n) =>
    e in t ? pG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  mr = (t, e, n) => gG(t, typeof e != 'symbol' ? e + '' : e, n)
class mG {
  constructor(e, n, r) {
    ;(this.core = e),
      (this.logger = n),
      mr(this, 'name', dq),
      mr(this, 'keychain'),
      mr(this, 'randomSessionIdentifier', Rw()),
      mr(this, 'initialized', !1),
      mr(this, 'init', async () => {
        this.initialized || (await this.keychain.init(), (this.initialized = !0))
      }),
      mr(this, 'hasKeys', i => (this.isInitialized(), this.keychain.has(i))),
      mr(this, 'getClientId', async () => {
        this.isInitialized()
        const i = await this.getClientSeed(),
          s = _S(i)
        return xT(s.publicKey)
      }),
      mr(this, 'generateKeyPair', () => {
        this.isInitialized()
        const i = Hj()
        return this.setPrivateKey(i.publicKey, i.privateKey)
      }),
      mr(this, 'signJWT', async i => {
        this.isInitialized()
        const s = await this.getClientSeed(),
          c = _S(s),
          u = this.randomSessionIdentifier
        return await bU(u, i, fq, c)
      }),
      mr(this, 'generateSharedKey', (i, s, c) => {
        this.isInitialized()
        const u = this.getPrivateKey(i),
          f = Gj(u, s)
        return this.setSymKey(f, c)
      }),
      mr(this, 'setSymKey', async (i, s) => {
        this.isInitialized()
        const c = s || Ig(i)
        return await this.keychain.set(c, i), c
      }),
      mr(this, 'deleteKeyPair', async i => {
        this.isInitialized(), await this.keychain.del(i)
      }),
      mr(this, 'deleteSymKey', async i => {
        this.isInitialized(), await this.keychain.del(i)
      }),
      mr(this, 'encode', async (i, s, c) => {
        this.isInitialized()
        const u = Hx(c),
          f = ka(s)
        if (W5(u)) return Wj(f, c == null ? void 0 : c.encoding)
        if (K5(u)) {
          const m = u.senderPublicKey,
            y = u.receiverPublicKey
          i = await this.generateSharedKey(m, y)
        }
        const d = this.getSymKey(i),
          { type: p, senderPublicKey: g } = u
        return Vj({
          type: p,
          symKey: d,
          message: f,
          senderPublicKey: g,
          encoding: c == null ? void 0 : c.encoding
        })
      }),
      mr(this, 'decode', async (i, s, c) => {
        this.isInitialized()
        const u = Yj(s, c)
        if (W5(u)) {
          const f = Qj(s, c == null ? void 0 : c.encoding)
          return Xc(f)
        }
        if (K5(u)) {
          const f = u.receiverPublicKey,
            d = u.senderPublicKey
          i = await this.generateSharedKey(f, d)
        }
        try {
          const f = this.getSymKey(i),
            d = Kj({ symKey: f, encoded: s, encoding: c == null ? void 0 : c.encoding })
          return Xc(d)
        } catch (f) {
          this.logger.error(
            `Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`
          ),
            this.logger.error(f)
        }
      }),
      mr(this, 'getPayloadType', (i, s = ko) => {
        const c = _h({ encoded: i, encoding: s })
        return nu(c.type)
      }),
      mr(this, 'getPayloadSenderPublicKey', (i, s = ko) => {
        const c = _h({ encoded: i, encoding: s })
        return c.senderPublicKey ? $r(c.senderPublicKey, Or) : void 0
      }),
      (this.core = e),
      (this.logger = Pr(n, this.name)),
      (this.keychain = r || new hG(this.core, this.logger))
  }
  get context() {
    return ni(this.logger)
  }
  async setPrivateKey(e, n) {
    return await this.keychain.set(e, n), e
  }
  getPrivateKey(e) {
    return this.keychain.get(e)
  }
  async getClientSeed() {
    let e = ''
    try {
      e = this.keychain.get(d6)
    } catch {
      ;(e = Rw()), await this.keychain.set(d6, e)
    }
    return lG(e, 'base16')
  }
  getSymKey(e) {
    return this.keychain.get(e)
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = me('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
}
var bG = Object.defineProperty,
  yG = Object.defineProperties,
  vG = Object.getOwnPropertyDescriptors,
  w6 = Object.getOwnPropertySymbols,
  wG = Object.prototype.hasOwnProperty,
  EG = Object.prototype.propertyIsEnumerable,
  Uw = (t, e, n) =>
    e in t ? bG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  AG = (t, e) => {
    for (var n in e || (e = {})) wG.call(e, n) && Uw(t, n, e[n])
    if (w6) for (var n of w6(e)) EG.call(e, n) && Uw(t, n, e[n])
    return t
  },
  _G = (t, e) => yG(t, vG(e)),
  di = (t, e, n) => Uw(t, typeof e != 'symbol' ? e + '' : e, n)
class CG extends gP {
  constructor(e, n) {
    super(e, n),
      (this.logger = e),
      (this.core = n),
      di(this, 'messages', new Map()),
      di(this, 'messagesWithoutClientAck', new Map()),
      di(this, 'name', gq),
      di(this, 'version', mq),
      di(this, 'initialized', !1),
      di(this, 'storagePrefix', zs),
      di(this, 'init', async () => {
        if (!this.initialized) {
          this.logger.trace('Initialized')
          try {
            const r = await this.getRelayerMessages()
            typeof r < 'u' && (this.messages = r)
            const i = await this.getRelayerMessagesWithoutClientAck()
            typeof i < 'u' && (this.messagesWithoutClientAck = i),
              this.logger.debug(`Successfully Restored records for ${this.name}`),
              this.logger.trace({ type: 'method', method: 'restore', size: this.messages.size })
          } catch (r) {
            this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(r)
          } finally {
            this.initialized = !0
          }
        }
      }),
      di(this, 'set', async (r, i, s) => {
        this.isInitialized()
        const c = Fs(i)
        let u = this.messages.get(r)
        if ((typeof u > 'u' && (u = {}), typeof u[c] < 'u')) return c
        if (((u[c] = i), this.messages.set(r, u), s === Og.inbound)) {
          const f = this.messagesWithoutClientAck.get(r) || {}
          this.messagesWithoutClientAck.set(r, _G(AG({}, f), { [c]: i }))
        }
        return await this.persist(), c
      }),
      di(this, 'get', r => {
        this.isInitialized()
        let i = this.messages.get(r)
        return typeof i > 'u' && (i = {}), i
      }),
      di(this, 'getWithoutAck', r => {
        this.isInitialized()
        const i = {}
        for (const s of r) {
          const c = this.messagesWithoutClientAck.get(s) || {}
          i[s] = Object.values(c)
        }
        return i
      }),
      di(this, 'has', (r, i) => {
        this.isInitialized()
        const s = this.get(r),
          c = Fs(i)
        return typeof s[c] < 'u'
      }),
      di(this, 'ack', async (r, i) => {
        this.isInitialized()
        const s = this.messagesWithoutClientAck.get(r)
        if (typeof s > 'u') return
        const c = Fs(i)
        delete s[c],
          Object.keys(s).length === 0
            ? this.messagesWithoutClientAck.delete(r)
            : this.messagesWithoutClientAck.set(r, s),
          await this.persist()
      }),
      di(this, 'del', async r => {
        this.isInitialized(),
          this.messages.delete(r),
          this.messagesWithoutClientAck.delete(r),
          await this.persist()
      }),
      (this.logger = Pr(e, this.name)),
      (this.core = n)
  }
  get context() {
    return ni(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
  }
  get storageKeyWithoutClientAck() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      '//' +
      this.name +
      '_withoutClientAck'
    )
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, _w(e))
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, _w(e))
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey)
    return typeof e < 'u' ? Cw(e) : void 0
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck)
    return typeof e < 'u' ? Cw(e) : void 0
  }
  async persist() {
    await this.setRelayerMessages(this.messages),
      await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = me('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
}
var SG = Object.defineProperty,
  TG = Object.defineProperties,
  xG = Object.getOwnPropertyDescriptors,
  E6 = Object.getOwnPropertySymbols,
  NG = Object.prototype.hasOwnProperty,
  IG = Object.prototype.propertyIsEnumerable,
  Bw = (t, e, n) =>
    e in t ? SG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  cg = (t, e) => {
    for (var n in e || (e = {})) NG.call(e, n) && Bw(t, n, e[n])
    if (E6) for (var n of E6(e)) IG.call(e, n) && Bw(t, n, e[n])
    return t
  },
  v1 = (t, e) => TG(t, xG(e)),
  rs = (t, e, n) => Bw(t, typeof e != 'symbol' ? e + '' : e, n)
class OG extends mP {
  constructor(e, n) {
    super(e, n),
      (this.relayer = e),
      (this.logger = n),
      rs(this, 'events', new zi.EventEmitter()),
      rs(this, 'name', bq),
      rs(this, 'queue', new Map()),
      rs(this, 'publishTimeout', ge.toMiliseconds(ge.ONE_MINUTE)),
      rs(this, 'initialPublishTimeout', ge.toMiliseconds(ge.ONE_SECOND * 15)),
      rs(this, 'needsTransportRestart', !1),
      rs(this, 'publish', async (r, i, s) => {
        var c
        this.logger.debug('Publishing Payload'),
          this.logger.trace({
            type: 'method',
            method: 'publish',
            params: { topic: r, message: i, opts: s }
          })
        const u = (s == null ? void 0 : s.ttl) || f6,
          f = Zg(s),
          d = (s == null ? void 0 : s.prompt) || !1,
          p = (s == null ? void 0 : s.tag) || 0,
          g = (s == null ? void 0 : s.id) || Dc().toString(),
          m = {
            topic: r,
            message: i,
            opts: {
              ttl: u,
              relay: f,
              prompt: d,
              tag: p,
              id: g,
              attestation: s == null ? void 0 : s.attestation,
              tvf: s == null ? void 0 : s.tvf
            }
          },
          y = `Failed to publish payload, please try again. id:${g} tag:${p}`
        try {
          const A = new Promise(async E => {
            const x = ({ id: I }) => {
              m.opts.id === I &&
                (this.removeRequestFromQueue(I),
                this.relayer.events.removeListener(or.publish, x),
                E(m))
            }
            this.relayer.events.on(or.publish, x)
            const O = Mo(
              new Promise((I, M) => {
                this.rpcPublish({
                  topic: r,
                  message: i,
                  ttl: u,
                  prompt: d,
                  tag: p,
                  id: g,
                  attestation: s == null ? void 0 : s.attestation,
                  tvf: s == null ? void 0 : s.tvf
                })
                  .then(I)
                  .catch($ => {
                    this.logger.warn($, $ == null ? void 0 : $.message), M($)
                  })
              }),
              this.initialPublishTimeout,
              `Failed initial publish, retrying.... id:${g} tag:${p}`
            )
            try {
              await O, this.events.removeListener(or.publish, x)
            } catch (I) {
              this.queue.set(g, v1(cg({}, m), { attempt: 1 })),
                this.logger.warn(I, I == null ? void 0 : I.message)
            }
          })
          this.logger.trace({
            type: 'method',
            method: 'publish',
            params: { id: g, topic: r, message: i, opts: s }
          }),
            await Mo(A, this.publishTimeout, y)
        } catch (A) {
          if (
            (this.logger.debug('Failed to Publish Payload'),
            this.logger.error(A),
            (c = s == null ? void 0 : s.internal) != null && c.throwOnFailedPublish)
          )
            throw A
        } finally {
          this.queue.delete(g)
        }
      }),
      rs(this, 'on', (r, i) => {
        this.events.on(r, i)
      }),
      rs(this, 'once', (r, i) => {
        this.events.once(r, i)
      }),
      rs(this, 'off', (r, i) => {
        this.events.off(r, i)
      }),
      rs(this, 'removeListener', (r, i) => {
        this.events.removeListener(r, i)
      }),
      (this.relayer = e),
      (this.logger = Pr(n, this.name)),
      this.registerEventListeners()
  }
  get context() {
    return ni(this.logger)
  }
  async rpcPublish(e) {
    var n, r, i, s
    const {
        topic: c,
        message: u,
        ttl: f = f6,
        prompt: d,
        tag: p,
        id: g,
        attestation: m,
        tvf: y
      } = e,
      A = {
        method: th(Zg().protocol).publish,
        params: cg({ topic: c, message: u, ttl: f, prompt: d, tag: p, attestation: m }, y),
        id: g
      }
    vr((n = A.params) == null ? void 0 : n.prompt) && ((r = A.params) == null || delete r.prompt),
      vr((i = A.params) == null ? void 0 : i.tag) && ((s = A.params) == null || delete s.tag),
      this.logger.debug('Outgoing Relay Payload'),
      this.logger.trace({ type: 'message', direction: 'outgoing', request: A })
    const E = await this.relayer.request(A)
    return (
      this.relayer.events.emit(or.publish, e),
      this.logger.debug('Successfully Published Payload'),
      E
    )
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e)
  }
  checkQueue() {
    this.queue.forEach(async (e, n) => {
      const r = e.attempt + 1
      this.queue.set(n, v1(cg({}, e), { attempt: r }))
      const { topic: i, message: s, opts: c, attestation: u } = e
      this.logger.warn(
        {},
        `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${r}`
      ),
        await this.rpcPublish(
          v1(cg({}, e), {
            topic: i,
            message: s,
            ttl: c.ttl,
            prompt: c.prompt,
            tag: c.tag,
            id: c.id,
            attestation: u,
            tvf: c.tvf
          })
        ),
        this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`)
    })
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(bd.pulse, () => {
      if (this.needsTransportRestart) {
        ;(this.needsTransportRestart = !1), this.relayer.events.emit(or.connection_stalled)
        return
      }
      this.checkQueue()
    }),
      this.relayer.on(or.message_ack, e => {
        this.removeRequestFromQueue(e.id.toString())
      })
  }
}
var RG = Object.defineProperty,
  DG = (t, e, n) =>
    e in t ? RG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  dl = (t, e, n) => DG(t, typeof e != 'symbol' ? e + '' : e, n)
class PG {
  constructor() {
    dl(this, 'map', new Map()),
      dl(this, 'set', (e, n) => {
        const r = this.get(e)
        this.exists(e, n) || this.map.set(e, [...r, n])
      }),
      dl(this, 'get', e => this.map.get(e) || []),
      dl(this, 'exists', (e, n) => this.get(e).includes(n)),
      dl(this, 'delete', (e, n) => {
        if (typeof n > 'u') {
          this.map.delete(e)
          return
        }
        if (!this.map.has(e)) return
        const r = this.get(e)
        if (!this.exists(e, n)) return
        const i = r.filter(s => s !== n)
        if (!i.length) {
          this.map.delete(e)
          return
        }
        this.map.set(e, i)
      }),
      dl(this, 'clear', () => {
        this.map.clear()
      })
  }
  get topics() {
    return Array.from(this.map.keys())
  }
}
var MG = Object.defineProperty,
  kG = Object.defineProperties,
  UG = Object.getOwnPropertyDescriptors,
  A6 = Object.getOwnPropertySymbols,
  BG = Object.prototype.hasOwnProperty,
  LG = Object.prototype.propertyIsEnumerable,
  Lw = (t, e, n) =>
    e in t ? MG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Gf = (t, e) => {
    for (var n in e || (e = {})) BG.call(e, n) && Lw(t, n, e[n])
    if (A6) for (var n of A6(e)) LG.call(e, n) && Lw(t, n, e[n])
    return t
  },
  w1 = (t, e) => kG(t, UG(e)),
  tn = (t, e, n) => Lw(t, typeof e != 'symbol' ? e + '' : e, n)
class $G extends vP {
  constructor(e, n) {
    super(e, n),
      (this.relayer = e),
      (this.logger = n),
      tn(this, 'subscriptions', new Map()),
      tn(this, 'topicMap', new PG()),
      tn(this, 'events', new zi.EventEmitter()),
      tn(this, 'name', Cq),
      tn(this, 'version', Sq),
      tn(this, 'pending', new Map()),
      tn(this, 'cached', []),
      tn(this, 'initialized', !1),
      tn(this, 'storagePrefix', zs),
      tn(this, 'subscribeTimeout', ge.toMiliseconds(ge.ONE_MINUTE)),
      tn(this, 'initialSubscribeTimeout', ge.toMiliseconds(ge.ONE_SECOND * 15)),
      tn(this, 'clientId'),
      tn(this, 'batchSubscribeTopicsLimit', 500),
      tn(this, 'init', async () => {
        this.initialized ||
          (this.logger.trace('Initialized'), this.registerEventListeners(), await this.restore()),
          (this.initialized = !0)
      }),
      tn(this, 'subscribe', async (r, i) => {
        this.isInitialized(),
          this.logger.debug('Subscribing Topic'),
          this.logger.trace({ type: 'method', method: 'subscribe', params: { topic: r, opts: i } })
        try {
          const s = Zg(i),
            c = { topic: r, relay: s, transportType: i == null ? void 0 : i.transportType }
          this.pending.set(r, c)
          const u = await this.rpcSubscribe(r, s, i)
          return (
            typeof u == 'string' &&
              (this.onSubscribe(u, c),
              this.logger.debug('Successfully Subscribed Topic'),
              this.logger.trace({
                type: 'method',
                method: 'subscribe',
                params: { topic: r, opts: i }
              })),
            u
          )
        } catch (s) {
          throw (this.logger.debug('Failed to Subscribe Topic'), this.logger.error(s), s)
        }
      }),
      tn(this, 'unsubscribe', async (r, i) => {
        this.isInitialized(),
          typeof (i == null ? void 0 : i.id) < 'u'
            ? await this.unsubscribeById(r, i.id, i)
            : await this.unsubscribeByTopic(r, i)
      }),
      tn(
        this,
        'isSubscribed',
        r =>
          new Promise(i => {
            i(this.topicMap.topics.includes(r))
          })
      ),
      tn(
        this,
        'isKnownTopic',
        r =>
          new Promise(i => {
            i(
              this.topicMap.topics.includes(r) ||
                this.pending.has(r) ||
                this.cached.some(s => s.topic === r)
            )
          })
      ),
      tn(this, 'on', (r, i) => {
        this.events.on(r, i)
      }),
      tn(this, 'once', (r, i) => {
        this.events.once(r, i)
      }),
      tn(this, 'off', (r, i) => {
        this.events.off(r, i)
      }),
      tn(this, 'removeListener', (r, i) => {
        this.events.removeListener(r, i)
      }),
      tn(this, 'start', async () => {
        await this.onConnect()
      }),
      tn(this, 'stop', async () => {
        await this.onDisconnect()
      }),
      tn(this, 'restart', async () => {
        await this.restore(), await this.onRestart()
      }),
      tn(this, 'checkPending', async () => {
        if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return
        const r = []
        this.pending.forEach(i => {
          r.push(i)
        }),
          await this.batchSubscribe(r)
      }),
      tn(this, 'registerEventListeners', () => {
        this.relayer.core.heartbeat.on(bd.pulse, async () => {
          await this.checkPending()
        }),
          this.events.on(hi.created, async r => {
            const i = hi.created
            this.logger.info(`Emitting ${i}`),
              this.logger.debug({ type: 'event', event: i, data: r }),
              await this.persist()
          }),
          this.events.on(hi.deleted, async r => {
            const i = hi.deleted
            this.logger.info(`Emitting ${i}`),
              this.logger.debug({ type: 'event', event: i, data: r }),
              await this.persist()
          })
      }),
      (this.relayer = e),
      (this.logger = Pr(n, this.name)),
      (this.clientId = '')
  }
  get context() {
    return ni(this.logger)
  }
  get storageKey() {
    return (
      this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + '//' + this.name
    )
  }
  get length() {
    return this.subscriptions.size
  }
  get ids() {
    return Array.from(this.subscriptions.keys())
  }
  get values() {
    return Array.from(this.subscriptions.values())
  }
  get topics() {
    return this.topicMap.topics
  }
  get hasAnyTopics() {
    return (
      this.topicMap.topics.length > 0 ||
      this.pending.size > 0 ||
      this.cached.length > 0 ||
      this.subscriptions.size > 0
    )
  }
  hasSubscription(e, n) {
    let r = !1
    try {
      r = this.getSubscription(e).topic === n
    } catch {}
    return r
  }
  reset() {
    ;(this.cached = []), (this.initialized = !0)
  }
  onDisable() {
    ;(this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear()
  }
  async unsubscribeByTopic(e, n) {
    const r = this.topicMap.get(e)
    await Promise.all(r.map(async i => await this.unsubscribeById(e, i, n)))
  }
  async unsubscribeById(e, n, r) {
    this.logger.debug('Unsubscribing Topic'),
      this.logger.trace({
        type: 'method',
        method: 'unsubscribe',
        params: { topic: e, id: n, opts: r }
      })
    try {
      const i = Zg(r)
      await this.restartToComplete({ topic: e, id: n, relay: i }),
        await this.rpcUnsubscribe(e, n, i)
      const s = Qt('USER_DISCONNECTED', `${this.name}, ${e}`)
      await this.onUnsubscribe(e, n, s),
        this.logger.debug('Successfully Unsubscribed Topic'),
        this.logger.trace({
          type: 'method',
          method: 'unsubscribe',
          params: { topic: e, id: n, opts: r }
        })
    } catch (i) {
      throw (this.logger.debug('Failed to Unsubscribe Topic'), this.logger.error(i), i)
    }
  }
  async rpcSubscribe(e, n, r) {
    var i
    ;(!r || (r == null ? void 0 : r.transportType) === hn.relay) &&
      (await this.restartToComplete({ topic: e, id: e, relay: n }))
    const s = { method: th(n.protocol).subscribe, params: { topic: e } }
    this.logger.debug('Outgoing Relay Payload'),
      this.logger.trace({ type: 'payload', direction: 'outgoing', request: s })
    const c = (i = r == null ? void 0 : r.internal) == null ? void 0 : i.throwOnFailedPublish
    try {
      const u = await this.getSubscriptionId(e)
      if ((r == null ? void 0 : r.transportType) === hn.link_mode)
        return (
          setTimeout(() => {
            ;(this.relayer.connected || this.relayer.connecting) &&
              this.relayer.request(s).catch(p => this.logger.warn(p))
          }, ge.toMiliseconds(ge.ONE_SECOND)),
          u
        )
      const f = new Promise(async p => {
          const g = m => {
            m.topic === e && (this.events.removeListener(hi.created, g), p(m.id))
          }
          this.events.on(hi.created, g)
          try {
            const m = await Mo(
              new Promise((y, A) => {
                this.relayer
                  .request(s)
                  .catch(E => {
                    this.logger.warn(E, E == null ? void 0 : E.message), A(E)
                  })
                  .then(y)
              }),
              this.initialSubscribeTimeout,
              `Subscribing to ${e} failed, please try again`
            )
            this.events.removeListener(hi.created, g), p(m)
          } catch {}
        }),
        d = await Mo(f, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`)
      if (!d && c) throw new Error(`Subscribing to ${e} failed, please try again`)
      return d ? u : null
    } catch (u) {
      if (
        (this.logger.debug('Outgoing Relay Subscribe Payload stalled'),
        this.relayer.events.emit(or.connection_stalled),
        c)
      )
        throw u
    }
    return null
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return
    const n = e[0].relay,
      r = { method: th(n.protocol).batchSubscribe, params: { topics: e.map(i => i.topic) } }
    this.logger.debug('Outgoing Relay Payload'),
      this.logger.trace({ type: 'payload', direction: 'outgoing', request: r })
    try {
      await await Mo(
        new Promise(i => {
          this.relayer
            .request(r)
            .catch(s => this.logger.warn(s))
            .then(i)
        }),
        this.subscribeTimeout,
        'rpcBatchSubscribe failed, please try again'
      )
    } catch {
      this.relayer.events.emit(or.connection_stalled)
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return
    const n = e[0].relay,
      r = { method: th(n.protocol).batchFetchMessages, params: { topics: e.map(s => s.topic) } }
    this.logger.debug('Outgoing Relay Payload'),
      this.logger.trace({ type: 'payload', direction: 'outgoing', request: r })
    let i
    try {
      i = await await Mo(
        new Promise((s, c) => {
          this.relayer
            .request(r)
            .catch(u => {
              this.logger.warn(u), c(u)
            })
            .then(s)
        }),
        this.subscribeTimeout,
        'rpcBatchFetchMessages failed, please try again'
      )
    } catch {
      this.relayer.events.emit(or.connection_stalled)
    }
    return i
  }
  rpcUnsubscribe(e, n, r) {
    const i = { method: th(r.protocol).unsubscribe, params: { topic: e, id: n } }
    return (
      this.logger.debug('Outgoing Relay Payload'),
      this.logger.trace({ type: 'payload', direction: 'outgoing', request: i }),
      this.relayer.request(i)
    )
  }
  onSubscribe(e, n) {
    this.setSubscription(e, w1(Gf({}, n), { id: e })), this.pending.delete(n.topic)
  }
  onBatchSubscribe(e) {
    e.length &&
      e.forEach(n => {
        this.setSubscription(n.id, Gf({}, n)), this.pending.delete(n.topic)
      })
  }
  async onUnsubscribe(e, n, r) {
    this.events.removeAllListeners(n),
      this.hasSubscription(n, e) && this.deleteSubscription(n, r),
      await this.relayer.messages.del(e)
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e)
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey)
  }
  setSubscription(e, n) {
    this.logger.debug('Setting subscription'),
      this.logger.trace({ type: 'method', method: 'setSubscription', id: e, subscription: n }),
      this.addSubscription(e, n)
  }
  addSubscription(e, n) {
    this.subscriptions.set(e, Gf({}, n)),
      this.topicMap.set(n.topic, e),
      this.events.emit(hi.created, n)
  }
  getSubscription(e) {
    this.logger.debug('Getting subscription'),
      this.logger.trace({ type: 'method', method: 'getSubscription', id: e })
    const n = this.subscriptions.get(e)
    if (!n) {
      const { message: r } = me('NO_MATCHING_KEY', `${this.name}: ${e}`)
      throw new Error(r)
    }
    return n
  }
  deleteSubscription(e, n) {
    this.logger.debug('Deleting subscription'),
      this.logger.trace({ type: 'method', method: 'deleteSubscription', id: e, reason: n })
    const r = this.getSubscription(e)
    this.subscriptions.delete(e),
      this.topicMap.delete(r.topic, e),
      this.events.emit(hi.deleted, w1(Gf({}, r), { reason: n }))
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(hi.sync)
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached],
        n = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit)
      for (let r = 0; r < n; r++) {
        const i = e.splice(0, this.batchSubscribeTopicsLimit)
        await this.batchSubscribe(i)
      }
    }
    this.events.emit(hi.resubscribed)
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions()
      if (typeof e > 'u' || !e.length) return
      if (this.subscriptions.size) {
        const { message: n } = me('RESTORE_WILL_OVERRIDE', this.name)
        throw (
          (this.logger.error(n),
          this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),
          new Error(n))
        )
      }
      ;(this.cached = e),
        this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),
        this.logger.trace({ type: 'method', method: 'restore', subscriptions: this.values })
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e)
    }
  }
  async batchSubscribe(e) {
    e.length &&
      (await this.rpcBatchSubscribe(e),
      this.onBatchSubscribe(
        await Promise.all(
          e.map(async n => w1(Gf({}, n), { id: await this.getSubscriptionId(n.topic) }))
        )
      ))
  }
  async batchFetchMessages(e) {
    if (!e.length) return
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`)
    const n = await this.rpcBatchFetchMessages(e)
    n &&
      n.messages &&
      (await rF(ge.toMiliseconds(ge.ONE_SECOND)),
      await this.relayer.handleBatchMessageEvents(n.messages))
  }
  async onConnect() {
    await this.restart(), this.reset()
  }
  onDisconnect() {
    this.onDisable()
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = me('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected &&
      !this.relayer.connecting &&
      (this.cached.push(e), await this.relayer.transportOpen())
  }
  async getClientId() {
    return (
      this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId
    )
  }
  async getSubscriptionId(e) {
    return Fs(e + (await this.getClientId()))
  }
}
var FG = Object.defineProperty,
  _6 = Object.getOwnPropertySymbols,
  jG = Object.prototype.hasOwnProperty,
  zG = Object.prototype.propertyIsEnumerable,
  $w = (t, e, n) =>
    e in t ? FG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  C6 = (t, e) => {
    for (var n in e || (e = {})) jG.call(e, n) && $w(t, n, e[n])
    if (_6) for (var n of _6(e)) zG.call(e, n) && $w(t, n, e[n])
    return t
  },
  Ct = (t, e, n) => $w(t, typeof e != 'symbol' ? e + '' : e, n)
class qG extends bP {
  constructor(e) {
    super(e),
      Ct(this, 'protocol', 'wc'),
      Ct(this, 'version', 2),
      Ct(this, 'core'),
      Ct(this, 'logger'),
      Ct(this, 'events', new zi.EventEmitter()),
      Ct(this, 'provider'),
      Ct(this, 'messages'),
      Ct(this, 'subscriber'),
      Ct(this, 'publisher'),
      Ct(this, 'name', vq),
      Ct(this, 'transportExplicitlyClosed', !1),
      Ct(this, 'initialized', !1),
      Ct(this, 'connectionAttemptInProgress', !1),
      Ct(this, 'relayUrl'),
      Ct(this, 'projectId'),
      Ct(this, 'packageName'),
      Ct(this, 'bundleId'),
      Ct(this, 'hasExperiencedNetworkDisruption', !1),
      Ct(this, 'pingTimeout'),
      Ct(this, 'heartBeatTimeout', ge.toMiliseconds(ge.THIRTY_SECONDS + ge.FIVE_SECONDS)),
      Ct(this, 'reconnectTimeout'),
      Ct(this, 'connectPromise'),
      Ct(this, 'reconnectInProgress', !1),
      Ct(this, 'requestsInFlight', []),
      Ct(this, 'connectTimeout', ge.toMiliseconds(ge.ONE_SECOND * 15)),
      Ct(this, 'request', async n => {
        var r, i
        this.logger.debug('Publishing Request Payload')
        const s = n.id || Dc().toString()
        await this.toEstablishConnection()
        try {
          this.logger.trace(
            { id: s, method: n.method, topic: (r = n.params) == null ? void 0 : r.topic },
            'relayer.request - publishing...'
          )
          const c = `${s}:${((i = n.params) == null ? void 0 : i.tag) || ''}`
          this.requestsInFlight.push(c)
          const u = await this.provider.request(n)
          return (this.requestsInFlight = this.requestsInFlight.filter(f => f !== c)), u
        } catch (c) {
          throw (this.logger.debug(`Failed to Publish Request: ${s}`), c)
        }
      }),
      Ct(this, 'resetPingTimeout', () => {
        Qg() &&
          (clearTimeout(this.pingTimeout),
          (this.pingTimeout = setTimeout(() => {
            var n, r, i, s
            try {
              this.logger.debug({}, 'pingTimeout: Connection stalled, terminating...'),
                (s =
                  (i =
                    (r = (n = this.provider) == null ? void 0 : n.connection) == null
                      ? void 0
                      : r.socket) == null
                    ? void 0
                    : i.terminate) == null || s.call(i)
            } catch (c) {
              this.logger.warn(c, c == null ? void 0 : c.message)
            }
          }, this.heartBeatTimeout)))
      }),
      Ct(this, 'onPayloadHandler', n => {
        this.onProviderPayload(n), this.resetPingTimeout()
      }),
      Ct(this, 'onConnectHandler', () => {
        this.logger.warn({}, 'Relayer connected 🛜'),
          this.startPingTimeout(),
          this.events.emit(or.connect)
      }),
      Ct(this, 'onDisconnectHandler', () => {
        this.logger.warn({}, 'Relayer disconnected 🛑'),
          (this.requestsInFlight = []),
          this.onProviderDisconnect()
      }),
      Ct(this, 'onProviderErrorHandler', n => {
        this.logger.fatal(`Fatal socket error: ${n.message}`),
          this.events.emit(or.error, n),
          this.logger.fatal('Fatal socket error received, closing transport'),
          this.transportClose()
      }),
      Ct(this, 'registerProviderListeners', () => {
        this.provider.on(Ri.payload, this.onPayloadHandler),
          this.provider.on(Ri.connect, this.onConnectHandler),
          this.provider.on(Ri.disconnect, this.onDisconnectHandler),
          this.provider.on(Ri.error, this.onProviderErrorHandler)
      }),
      (this.core = e.core),
      (this.logger =
        typeof e.logger < 'u' && typeof e.logger != 'string'
          ? Pr(e.logger, this.name)
          : pp(yd({ level: e.logger || yq }))),
      (this.messages = new CG(this.logger, e.core)),
      (this.subscriber = new $G(this, this.logger)),
      (this.publisher = new OG(this, this.logger)),
      (this.relayUrl = (e == null ? void 0 : e.relayUrl) || tN),
      (this.projectId = e.projectId),
      z$() ? (this.packageName = w5()) : q$() && (this.bundleId = w5()),
      (this.provider = {})
  }
  async init() {
    if (
      (this.logger.trace('Initialized'),
      this.registerEventListeners(),
      await Promise.all([this.messages.init(), this.subscriber.init()]),
      (this.initialized = !0),
      this.subscriber.hasAnyTopics)
    )
      try {
        await this.transportOpen()
      } catch (e) {
        this.logger.warn(e, e == null ? void 0 : e.message)
      }
  }
  get context() {
    return ni(this.logger)
  }
  get connected() {
    var e, n, r
    return (
      ((r =
        (n = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : n.socket) ==
      null
        ? void 0
        : r.readyState) === 1 || !1
    )
  }
  get connecting() {
    var e, n, r
    return (
      ((r =
        (n = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : n.socket) ==
      null
        ? void 0
        : r.readyState) === 0 ||
      this.connectPromise !== void 0 ||
      !1
    )
  }
  async publish(e, n, r) {
    this.isInitialized(),
      await this.publisher.publish(e, n, r),
      await this.recordMessageEvent(
        { topic: e, message: n, publishedAt: Date.now(), transportType: hn.relay },
        Og.outbound
      )
  }
  async subscribe(e, n) {
    var r, i, s
    this.isInitialized(),
      (!(n != null && n.transportType) || (n == null ? void 0 : n.transportType) === 'relay') &&
        (await this.toEstablishConnection())
    const c =
      typeof ((r = n == null ? void 0 : n.internal) == null ? void 0 : r.throwOnFailedPublish) > 'u'
        ? !0
        : (i = n == null ? void 0 : n.internal) == null
          ? void 0
          : i.throwOnFailedPublish
    let u = ((s = this.subscriber.topicMap.get(e)) == null ? void 0 : s[0]) || '',
      f
    const d = p => {
      p.topic === e && (this.subscriber.off(hi.created, d), f())
    }
    return (
      await Promise.all([
        new Promise(p => {
          ;(f = p), this.subscriber.on(hi.created, d)
        }),
        new Promise(async (p, g) => {
          ;(u =
            (await this.subscriber
              .subscribe(e, C6({ internal: { throwOnFailedPublish: c } }, n))
              .catch(m => {
                c && g(m)
              })) || u),
            p()
        })
      ]),
      u
    )
  }
  async unsubscribe(e, n) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, n)
  }
  on(e, n) {
    this.events.on(e, n)
  }
  once(e, n) {
    this.events.once(e, n)
  }
  off(e, n) {
    this.events.off(e, n)
  }
  removeListener(e, n) {
    this.events.removeListener(e, n)
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected)
      ? await Mo(this.provider.disconnect(), 2e3, 'provider.disconnect()').catch(() =>
          this.onProviderDisconnect()
        )
      : this.onProviderDisconnect()
  }
  async transportClose() {
    ;(this.transportExplicitlyClosed = !0), await this.transportDisconnect()
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn(
        'Starting WS connection skipped because the client has no topics to work with.'
      )
      return
    }
    if (
      (this.connectPromise
        ? (this.logger.debug({}, 'Waiting for existing connection attempt to resolve...'),
          await this.connectPromise,
          this.logger.debug({}, 'Existing connection attempt resolved'))
        : ((this.connectPromise = new Promise(async (n, r) => {
            await this.connect(e)
              .then(n)
              .catch(r)
              .finally(() => {
                this.connectPromise = void 0
              })
          })),
          await this.connectPromise),
      !this.connected)
    )
      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`)
  }
  async restartTransport(e) {
    this.logger.debug({}, 'Restarting transport...'),
      !this.connectionAttemptInProgress &&
        ((this.relayUrl = e || this.relayUrl),
        await this.confirmOnlineStateOrThrow(),
        await this.transportClose(),
        await this.transportOpen())
  }
  async confirmOnlineStateOrThrow() {
    if (!(await n6()))
      throw new Error('No internet connection detected. Please restart your network and try again.')
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace('Batch message events is empty. Ignoring...')
      return
    }
    const n = e.sort((r, i) => r.publishedAt - i.publishedAt)
    this.logger.debug(`Batch of ${n.length} message events sorted`)
    for (const r of n)
      try {
        await this.onMessageEvent(r)
      } catch (i) {
        this.logger.warn(
          i,
          'Error while processing batch message event: ' + (i == null ? void 0 : i.message)
        )
      }
    this.logger.trace(`Batch of ${n.length} message events processed`)
  }
  async onLinkMessageEvent(e, n) {
    const { topic: r } = e
    if (!n.sessionExists) {
      const i = Zn(ge.FIVE_MINUTES),
        s = { topic: r, expiry: i, relay: { protocol: 'irn' }, active: !1 }
      await this.core.pairing.pairings.set(r, s)
    }
    this.events.emit(or.message, e), await this.recordMessageEvent(e, Og.inbound)
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(),
      e && e !== this.relayUrl && ((this.relayUrl = e), await this.transportDisconnect()),
      (this.connectionAttemptInProgress = !0),
      (this.transportExplicitlyClosed = !1)
    let n = 1
    for (; n < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${n}...`),
          await this.createProvider(),
          await new Promise(async (r, i) => {
            const s = () => {
              i(new Error('Connection interrupted while trying to subscribe'))
            }
            this.provider.once(Ri.disconnect, s),
              await Mo(
                new Promise((c, u) => {
                  this.provider.connect().then(c).catch(u)
                }),
                this.connectTimeout,
                `Socket stalled when trying to connect to ${this.relayUrl}`
              )
                .catch(c => {
                  i(c)
                })
                .finally(() => {
                  this.provider.off(Ri.disconnect, s), clearTimeout(this.reconnectTimeout)
                }),
              await new Promise(async (c, u) => {
                const f = () => {
                  u(new Error('Connection interrupted while trying to subscribe'))
                }
                this.provider.once(Ri.disconnect, f),
                  await this.subscriber
                    .start()
                    .then(c)
                    .catch(u)
                    .finally(() => {
                      this.provider.off(Ri.disconnect, f)
                    })
              }),
              (this.hasExperiencedNetworkDisruption = !1),
              r()
          })
      } catch (r) {
        await this.subscriber.stop()
        const i = r
        this.logger.warn({}, i.message), (this.hasExperiencedNetworkDisruption = !0)
      } finally {
        this.connectionAttemptInProgress = !1
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${n}`)
        break
      }
      await new Promise(r => setTimeout(r, ge.toMiliseconds(n * 1))), n++
    }
  }
  startPingTimeout() {
    var e, n, r, i, s
    if (Qg())
      try {
        ;(n = (e = this.provider) == null ? void 0 : e.connection) != null &&
          n.socket &&
          ((s =
            (i = (r = this.provider) == null ? void 0 : r.connection) == null
              ? void 0
              : i.socket) == null ||
            s.on('ping', () => {
              this.resetPingTimeout()
            })),
          this.resetPingTimeout()
      } catch (c) {
        this.logger.warn(c, c == null ? void 0 : c.message)
      }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners()
    const e = await this.core.crypto.signJWT(this.relayUrl)
    ;(this.provider = new Gi(
      new cq(
        K$({
          sdkVersion: Pw,
          protocol: this.protocol,
          version: this.version,
          relayUrl: this.relayUrl,
          projectId: this.projectId,
          auth: e,
          useOnCloseEvent: !0,
          bundleId: this.bundleId,
          packageName: this.packageName
        })
      )
    )),
      this.registerProviderListeners()
  }
  async recordMessageEvent(e, n) {
    const { topic: r, message: i } = e
    await this.messages.set(r, i, n)
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: n, message: r } = e
    if (!r || r.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${r}`), !0
    if (!(await this.subscriber.isKnownTopic(n)))
      return this.logger.warn(`Ignoring message for unknown topic ${n}`), !0
    const i = this.messages.has(n, r)
    return i && this.logger.warn(`Ignoring duplicate message: ${r}`), i
  }
  async onProviderPayload(e) {
    if (
      (this.logger.debug('Incoming Relay Payload'),
      this.logger.trace({ type: 'payload', direction: 'incoming', payload: e }),
      u2(e))
    ) {
      if (!e.method.endsWith(wq)) return
      const n = e.params,
        { topic: r, message: i, publishedAt: s, attestation: c } = n.data,
        u = { topic: r, message: i, publishedAt: s, transportType: hn.relay, attestation: c }
      this.logger.debug('Emitting Relayer Payload'),
        this.logger.trace(C6({ type: 'event', event: n.id }, u)),
        this.events.emit(n.id, u),
        await this.acknowledgePayload(e),
        await this.onMessageEvent(u)
    } else $m(e) && this.events.emit(or.message_ack, e)
  }
  async onMessageEvent(e) {
    ;(await this.shouldIgnoreMessageEvent(e)) ||
      (await this.recordMessageEvent(e, Og.inbound), this.events.emit(or.message, e))
  }
  async acknowledgePayload(e) {
    const n = Bm(e.id, !0)
    await this.provider.connection.send(n)
  }
  unregisterProviderListeners() {
    this.provider.off(Ri.payload, this.onPayloadHandler),
      this.provider.off(Ri.connect, this.onConnectHandler),
      this.provider.off(Ri.disconnect, this.onDisconnectHandler),
      this.provider.off(Ri.error, this.onProviderErrorHandler),
      clearTimeout(this.pingTimeout)
  }
  async registerEventListeners() {
    let e = await n6()
    Bz(async n => {
      e !== n &&
        ((e = n),
        n
          ? await this.transportOpen().catch(r =>
              this.logger.error(r, r == null ? void 0 : r.message)
            )
          : ((this.hasExperiencedNetworkDisruption = !0),
            await this.transportDisconnect(),
            (this.transportExplicitlyClosed = !1)))
    })
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout),
      this.events.emit(or.disconnect),
      (this.connectionAttemptInProgress = !1),
      !this.reconnectInProgress &&
        ((this.reconnectInProgress = !0),
        await this.subscriber.stop(),
        this.subscriber.hasAnyTopics &&
          (this.transportExplicitlyClosed ||
            (this.reconnectTimeout = setTimeout(async () => {
              await this.transportOpen().catch(e =>
                this.logger.error(e, e == null ? void 0 : e.message)
              ),
                (this.reconnectTimeout = void 0),
                (this.reconnectInProgress = !1)
            }, ge.toMiliseconds(Eq)))))
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = me('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (await this.connect())
  }
}
function HG() {}
function S6(t) {
  if (!t || typeof t != 'object') return !1
  const e = Object.getPrototypeOf(t)
  return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null
    ? Object.prototype.toString.call(t) === '[object Object]'
    : !1
}
function T6(t) {
  return Object.getOwnPropertySymbols(t).filter(e =>
    Object.prototype.propertyIsEnumerable.call(t, e)
  )
}
function x6(t) {
  return t == null
    ? t === void 0
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(t)
}
const GG = '[object RegExp]',
  VG = '[object String]',
  KG = '[object Number]',
  WG = '[object Boolean]',
  N6 = '[object Arguments]',
  QG = '[object Symbol]',
  YG = '[object Date]',
  ZG = '[object Map]',
  XG = '[object Set]',
  JG = '[object Array]',
  eV = '[object Function]',
  tV = '[object ArrayBuffer]',
  E1 = '[object Object]',
  nV = '[object Error]',
  rV = '[object DataView]',
  iV = '[object Uint8Array]',
  sV = '[object Uint8ClampedArray]',
  aV = '[object Uint16Array]',
  oV = '[object Uint32Array]',
  cV = '[object BigUint64Array]',
  uV = '[object Int8Array]',
  lV = '[object Int16Array]',
  dV = '[object Int32Array]',
  fV = '[object BigInt64Array]',
  hV = '[object Float32Array]',
  pV = '[object Float64Array]'
function gV(t, e) {
  return t === e || (Number.isNaN(t) && Number.isNaN(e))
}
function mV(t, e, n) {
  return rh(t, e, void 0, void 0, void 0, void 0, n)
}
function rh(t, e, n, r, i, s, c) {
  const u = c(t, e, n, r, i, s)
  if (u !== void 0) return u
  if (typeof t == typeof e)
    switch (typeof t) {
      case 'bigint':
      case 'string':
      case 'boolean':
      case 'symbol':
      case 'undefined':
        return t === e
      case 'number':
        return t === e || Object.is(t, e)
      case 'function':
        return t === e
      case 'object':
        return dh(t, e, s, c)
    }
  return dh(t, e, s, c)
}
function dh(t, e, n, r) {
  if (Object.is(t, e)) return !0
  let i = x6(t),
    s = x6(e)
  if ((i === N6 && (i = E1), s === N6 && (s = E1), i !== s)) return !1
  switch (i) {
    case VG:
      return t.toString() === e.toString()
    case KG: {
      const f = t.valueOf(),
        d = e.valueOf()
      return gV(f, d)
    }
    case WG:
    case YG:
    case QG:
      return Object.is(t.valueOf(), e.valueOf())
    case GG:
      return t.source === e.source && t.flags === e.flags
    case eV:
      return t === e
  }
  n = n ?? new Map()
  const c = n.get(t),
    u = n.get(e)
  if (c != null && u != null) return c === e
  n.set(t, e), n.set(e, t)
  try {
    switch (i) {
      case ZG: {
        if (t.size !== e.size) return !1
        for (const [f, d] of t.entries())
          if (!e.has(f) || !rh(d, e.get(f), f, t, e, n, r)) return !1
        return !0
      }
      case XG: {
        if (t.size !== e.size) return !1
        const f = Array.from(t.values()),
          d = Array.from(e.values())
        for (let p = 0; p < f.length; p++) {
          const g = f[p],
            m = d.findIndex(y => rh(g, y, void 0, t, e, n, r))
          if (m === -1) return !1
          d.splice(m, 1)
        }
        return !0
      }
      case JG:
      case iV:
      case sV:
      case aV:
      case oV:
      case cV:
      case uV:
      case lV:
      case dV:
      case fV:
      case hV:
      case pV: {
        if (
          (typeof Buffer < 'u' && Buffer.isBuffer(t) !== Buffer.isBuffer(e)) ||
          t.length !== e.length
        )
          return !1
        for (let f = 0; f < t.length; f++) if (!rh(t[f], e[f], f, t, e, n, r)) return !1
        return !0
      }
      case tV:
        return t.byteLength !== e.byteLength ? !1 : dh(new Uint8Array(t), new Uint8Array(e), n, r)
      case rV:
        return t.byteLength !== e.byteLength || t.byteOffset !== e.byteOffset
          ? !1
          : dh(new Uint8Array(t), new Uint8Array(e), n, r)
      case nV:
        return t.name === e.name && t.message === e.message
      case E1: {
        if (!(dh(t.constructor, e.constructor, n, r) || (S6(t) && S6(e)))) return !1
        const f = [...Object.keys(t), ...T6(t)],
          d = [...Object.keys(e), ...T6(e)]
        if (f.length !== d.length) return !1
        for (let p = 0; p < f.length; p++) {
          const g = f[p],
            m = t[g]
          if (!Object.hasOwn(e, g)) return !1
          const y = e[g]
          if (!rh(m, y, g, t, e, n, r)) return !1
        }
        return !0
      }
      default:
        return !1
    }
  } finally {
    n.delete(t), n.delete(e)
  }
}
function bV(t, e) {
  return mV(t, e, HG)
}
var yV = Object.defineProperty,
  I6 = Object.getOwnPropertySymbols,
  vV = Object.prototype.hasOwnProperty,
  wV = Object.prototype.propertyIsEnumerable,
  Fw = (t, e, n) =>
    e in t ? yV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  O6 = (t, e) => {
    for (var n in e || (e = {})) vV.call(e, n) && Fw(t, n, e[n])
    if (I6) for (var n of I6(e)) wV.call(e, n) && Fw(t, n, e[n])
    return t
  },
  Kr = (t, e, n) => Fw(t, typeof e != 'symbol' ? e + '' : e, n)
class Eu extends yP {
  constructor(e, n, r, i = zs, s = void 0) {
    super(e, n, r, i),
      (this.core = e),
      (this.logger = n),
      (this.name = r),
      Kr(this, 'map', new Map()),
      Kr(this, 'version', Aq),
      Kr(this, 'cached', []),
      Kr(this, 'initialized', !1),
      Kr(this, 'getKey'),
      Kr(this, 'storagePrefix', zs),
      Kr(this, 'recentlyDeleted', []),
      Kr(this, 'recentlyDeletedLimit', 200),
      Kr(this, 'init', async () => {
        this.initialized ||
          (this.logger.trace('Initialized'),
          await this.restore(),
          this.cached.forEach(c => {
            this.getKey && c !== null && !vr(c)
              ? this.map.set(this.getKey(c), c)
              : pz(c)
                ? this.map.set(c.id, c)
                : gz(c) && this.map.set(c.topic, c)
          }),
          (this.cached = []),
          (this.initialized = !0))
      }),
      Kr(this, 'set', async (c, u) => {
        this.isInitialized(),
          this.map.has(c)
            ? await this.update(c, u)
            : (this.logger.debug('Setting value'),
              this.logger.trace({ type: 'method', method: 'set', key: c, value: u }),
              this.map.set(c, u),
              await this.persist())
      }),
      Kr(
        this,
        'get',
        c => (
          this.isInitialized(),
          this.logger.debug('Getting value'),
          this.logger.trace({ type: 'method', method: 'get', key: c }),
          this.getData(c)
        )
      ),
      Kr(
        this,
        'getAll',
        c => (
          this.isInitialized(),
          c ? this.values.filter(u => Object.keys(c).every(f => bV(u[f], c[f]))) : this.values
        )
      ),
      Kr(this, 'update', async (c, u) => {
        this.isInitialized(),
          this.logger.debug('Updating value'),
          this.logger.trace({ type: 'method', method: 'update', key: c, update: u })
        const f = O6(O6({}, this.getData(c)), u)
        this.map.set(c, f), await this.persist()
      }),
      Kr(this, 'delete', async (c, u) => {
        this.isInitialized(),
          this.map.has(c) &&
            (this.logger.debug('Deleting value'),
            this.logger.trace({ type: 'method', method: 'delete', key: c, reason: u }),
            this.map.delete(c),
            this.addToRecentlyDeleted(c),
            await this.persist())
      }),
      (this.logger = Pr(n, this.name)),
      (this.storagePrefix = i),
      (this.getKey = s)
  }
  get context() {
    return ni(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
  }
  get length() {
    return this.map.size
  }
  get keys() {
    return Array.from(this.map.keys())
  }
  get values() {
    return Array.from(this.map.values())
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e),
      this.recentlyDeleted.length >= this.recentlyDeletedLimit &&
        this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2)
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e)
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey)
  }
  getData(e) {
    const n = this.map.get(e)
    if (!n) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i } = me(
          'MISSING_OR_INVALID',
          `Record was recently deleted - ${this.name}: ${e}`
        )
        throw (this.logger.error(i), new Error(i))
      }
      const { message: r } = me('NO_MATCHING_KEY', `${this.name}: ${e}`)
      throw (this.logger.error(r), new Error(r))
    }
    return n
  }
  async persist() {
    await this.setDataStore(this.values)
  }
  async restore() {
    try {
      const e = await this.getDataStore()
      if (typeof e > 'u' || !e.length) return
      if (this.map.size) {
        const { message: n } = me('RESTORE_WILL_OVERRIDE', this.name)
        throw (this.logger.error(n), new Error(n))
      }
      ;(this.cached = e),
        this.logger.debug(`Successfully Restored value for ${this.name}`),
        this.logger.trace({ type: 'method', method: 'restore', value: this.values })
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e)
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = me('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
}
var EV = Object.defineProperty,
  AV = (t, e, n) =>
    e in t ? EV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  ft = (t, e, n) => AV(t, typeof e != 'symbol' ? e + '' : e, n)
class _V {
  constructor(e, n) {
    ;(this.core = e),
      (this.logger = n),
      ft(this, 'name', Tq),
      ft(this, 'version', xq),
      ft(this, 'events', new $E()),
      ft(this, 'pairings'),
      ft(this, 'initialized', !1),
      ft(this, 'storagePrefix', zs),
      ft(this, 'ignoredPayloadTypes', [Oa]),
      ft(this, 'registeredMethods', []),
      ft(this, 'init', async () => {
        this.initialized ||
          (await this.pairings.init(),
          await this.cleanup(),
          this.registerRelayerEvents(),
          this.registerExpirerEvents(),
          (this.initialized = !0),
          this.logger.trace('Initialized'))
      }),
      ft(this, 'register', ({ methods: r }) => {
        this.isInitialized(),
          (this.registeredMethods = [...new Set([...this.registeredMethods, ...r])])
      }),
      ft(this, 'create', async r => {
        this.isInitialized()
        const i = Rw(),
          s = await this.core.crypto.setSymKey(i),
          c = Zn(ge.FIVE_MINUTES),
          u = { protocol: eN },
          f = {
            topic: s,
            expiry: c,
            relay: u,
            active: !1,
            methods: r == null ? void 0 : r.methods
          },
          d = Y5({
            protocol: this.core.protocol,
            version: this.core.version,
            topic: s,
            symKey: i,
            relay: u,
            expiryTimestamp: c,
            methods: r == null ? void 0 : r.methods
          })
        return (
          this.events.emit(Ic.create, f),
          this.core.expirer.set(s, c),
          await this.pairings.set(s, f),
          await this.core.relayer.subscribe(s, {
            transportType: r == null ? void 0 : r.transportType
          }),
          { topic: s, uri: d }
        )
      }),
      ft(this, 'pair', async r => {
        this.isInitialized()
        const i = this.core.eventClient.createEvent({
          properties: { topic: r == null ? void 0 : r.uri, trace: [Ds.pairing_started] }
        })
        this.isValidPair(r, i)
        const { topic: s, symKey: c, relay: u, expiryTimestamp: f, methods: d } = Q5(r.uri)
        ;(i.props.properties.topic = s),
          i.addTrace(Ds.pairing_uri_validation_success),
          i.addTrace(Ds.pairing_uri_not_expired)
        let p
        if (this.pairings.keys.includes(s)) {
          if (((p = this.pairings.get(s)), i.addTrace(Ds.existing_pairing), p.active))
            throw (
              (i.setError(Ca.active_pairing_already_exists),
              new Error(
                `Pairing already exists: ${s}. Please try again with a new connection URI.`
              ))
            )
          i.addTrace(Ds.pairing_not_expired)
        }
        const g = f || Zn(ge.FIVE_MINUTES),
          m = { topic: s, relay: u, expiry: g, active: !1, methods: d }
        this.core.expirer.set(s, g),
          await this.pairings.set(s, m),
          i.addTrace(Ds.store_new_pairing),
          r.activatePairing && (await this.activate({ topic: s })),
          this.events.emit(Ic.create, m),
          i.addTrace(Ds.emit_inactive_pairing),
          this.core.crypto.keychain.has(s) || (await this.core.crypto.setSymKey(c, s)),
          i.addTrace(Ds.subscribing_pairing_topic)
        try {
          await this.core.relayer.confirmOnlineStateOrThrow()
        } catch {
          i.setError(Ca.no_internet_connection)
        }
        try {
          await this.core.relayer.subscribe(s, { relay: u })
        } catch (y) {
          throw (i.setError(Ca.subscribe_pairing_topic_failure), y)
        }
        return i.addTrace(Ds.subscribe_pairing_topic_success), m
      }),
      ft(this, 'activate', async ({ topic: r }) => {
        this.isInitialized()
        const i = Zn(ge.FIVE_MINUTES)
        this.core.expirer.set(r, i), await this.pairings.update(r, { active: !0, expiry: i })
      }),
      ft(this, 'ping', async r => {
        this.isInitialized(),
          await this.isValidPing(r),
          this.logger.warn('ping() is deprecated and will be removed in the next major release.')
        const { topic: i } = r
        if (this.pairings.keys.includes(i)) {
          const s = await this.sendRequest(i, 'wc_pairingPing', {}),
            { done: c, resolve: u, reject: f } = Sc()
          this.events.once(Pt('pairing_ping', s), ({ error: d }) => {
            d ? f(d) : u()
          }),
            await c()
        }
      }),
      ft(this, 'updateExpiry', async ({ topic: r, expiry: i }) => {
        this.isInitialized(), await this.pairings.update(r, { expiry: i })
      }),
      ft(this, 'updateMetadata', async ({ topic: r, metadata: i }) => {
        this.isInitialized(), await this.pairings.update(r, { peerMetadata: i })
      }),
      ft(this, 'getPairings', () => (this.isInitialized(), this.pairings.values)),
      ft(this, 'disconnect', async r => {
        this.isInitialized(), await this.isValidDisconnect(r)
        const { topic: i } = r
        this.pairings.keys.includes(i) &&
          (await this.sendRequest(i, 'wc_pairingDelete', Qt('USER_DISCONNECTED')),
          await this.deletePairing(i))
      }),
      ft(this, 'formatUriFromPairing', r => {
        this.isInitialized()
        const { topic: i, relay: s, expiry: c, methods: u } = r,
          f = this.core.crypto.keychain.get(i)
        return Y5({
          protocol: this.core.protocol,
          version: this.core.version,
          topic: i,
          symKey: f,
          relay: s,
          expiryTimestamp: c,
          methods: u
        })
      }),
      ft(this, 'sendRequest', async (r, i, s) => {
        const c = Uo(i, s),
          u = await this.core.crypto.encode(r, c),
          f = qf[i].req
        return this.core.history.set(r, c), this.core.relayer.publish(r, u, f), c.id
      }),
      ft(this, 'sendResult', async (r, i, s) => {
        const c = Bm(r, s),
          u = await this.core.crypto.encode(i, c),
          f = (await this.core.history.get(i, r)).request.method,
          d = qf[f].res
        await this.core.relayer.publish(i, u, d), await this.core.history.resolve(c)
      }),
      ft(this, 'sendError', async (r, i, s) => {
        const c = Lm(r, s),
          u = await this.core.crypto.encode(i, c),
          f = (await this.core.history.get(i, r)).request.method,
          d = qf[f] ? qf[f].res : qf.unregistered_method.res
        await this.core.relayer.publish(i, u, d), await this.core.history.resolve(c)
      }),
      ft(this, 'deletePairing', async (r, i) => {
        await this.core.relayer.unsubscribe(r),
          await Promise.all([
            this.pairings.delete(r, Qt('USER_DISCONNECTED')),
            this.core.crypto.deleteSymKey(r),
            i ? Promise.resolve() : this.core.expirer.del(r)
          ])
      }),
      ft(this, 'cleanup', async () => {
        const r = this.pairings.getAll().filter(i => Eo(i.expiry))
        await Promise.all(r.map(i => this.deletePairing(i.topic)))
      }),
      ft(this, 'onRelayEventRequest', async r => {
        const { topic: i, payload: s } = r
        switch (s.method) {
          case 'wc_pairingPing':
            return await this.onPairingPingRequest(i, s)
          case 'wc_pairingDelete':
            return await this.onPairingDeleteRequest(i, s)
          default:
            return await this.onUnknownRpcMethodRequest(i, s)
        }
      }),
      ft(this, 'onRelayEventResponse', async r => {
        const { topic: i, payload: s } = r,
          c = (await this.core.history.get(i, s.id)).request.method
        switch (c) {
          case 'wc_pairingPing':
            return this.onPairingPingResponse(i, s)
          default:
            return this.onUnknownRpcMethodResponse(c)
        }
      }),
      ft(this, 'onPairingPingRequest', async (r, i) => {
        const { id: s } = i
        try {
          this.isValidPing({ topic: r }),
            await this.sendResult(s, r, !0),
            this.events.emit(Ic.ping, { id: s, topic: r })
        } catch (c) {
          await this.sendError(s, r, c), this.logger.error(c)
        }
      }),
      ft(this, 'onPairingPingResponse', (r, i) => {
        const { id: s } = i
        setTimeout(() => {
          Ms(i)
            ? this.events.emit(Pt('pairing_ping', s), {})
            : Li(i) && this.events.emit(Pt('pairing_ping', s), { error: i.error })
        }, 500)
      }),
      ft(this, 'onPairingDeleteRequest', async (r, i) => {
        const { id: s } = i
        try {
          this.isValidDisconnect({ topic: r }),
            await this.deletePairing(r),
            this.events.emit(Ic.delete, { id: s, topic: r })
        } catch (c) {
          await this.sendError(s, r, c), this.logger.error(c)
        }
      }),
      ft(this, 'onUnknownRpcMethodRequest', async (r, i) => {
        const { id: s, method: c } = i
        try {
          if (this.registeredMethods.includes(c)) return
          const u = Qt('WC_METHOD_UNSUPPORTED', c)
          await this.sendError(s, r, u), this.logger.error(u)
        } catch (u) {
          await this.sendError(s, r, u), this.logger.error(u)
        }
      }),
      ft(this, 'onUnknownRpcMethodResponse', r => {
        this.registeredMethods.includes(r) || this.logger.error(Qt('WC_METHOD_UNSUPPORTED', r))
      }),
      ft(this, 'isValidPair', (r, i) => {
        var s
        if (!Zr(r)) {
          const { message: u } = me('MISSING_OR_INVALID', `pair() params: ${r}`)
          throw (i.setError(Ca.malformed_pairing_uri), new Error(u))
        }
        if (!hz(r.uri)) {
          const { message: u } = me('MISSING_OR_INVALID', `pair() uri: ${r.uri}`)
          throw (i.setError(Ca.malformed_pairing_uri), new Error(u))
        }
        const c = Q5(r == null ? void 0 : r.uri)
        if (!((s = c == null ? void 0 : c.relay) != null && s.protocol)) {
          const { message: u } = me('MISSING_OR_INVALID', 'pair() uri#relay-protocol')
          throw (i.setError(Ca.malformed_pairing_uri), new Error(u))
        }
        if (!(c != null && c.symKey)) {
          const { message: u } = me('MISSING_OR_INVALID', 'pair() uri#symKey')
          throw (i.setError(Ca.malformed_pairing_uri), new Error(u))
        }
        if (
          c != null &&
          c.expiryTimestamp &&
          ge.toMiliseconds(c == null ? void 0 : c.expiryTimestamp) < Date.now()
        ) {
          i.setError(Ca.pairing_expired)
          const { message: u } = me(
            'EXPIRED',
            'pair() URI has expired. Please try again with a new connection URI.'
          )
          throw new Error(u)
        }
      }),
      ft(this, 'isValidPing', async r => {
        if (!Zr(r)) {
          const { message: s } = me('MISSING_OR_INVALID', `ping() params: ${r}`)
          throw new Error(s)
        }
        const { topic: i } = r
        await this.isValidPairingTopic(i)
      }),
      ft(this, 'isValidDisconnect', async r => {
        if (!Zr(r)) {
          const { message: s } = me('MISSING_OR_INVALID', `disconnect() params: ${r}`)
          throw new Error(s)
        }
        const { topic: i } = r
        await this.isValidPairingTopic(i)
      }),
      ft(this, 'isValidPairingTopic', async r => {
        if (!Vn(r, !1)) {
          const { message: i } = me('MISSING_OR_INVALID', `pairing topic should be a string: ${r}`)
          throw new Error(i)
        }
        if (!this.pairings.keys.includes(r)) {
          const { message: i } = me('NO_MATCHING_KEY', `pairing topic doesn't exist: ${r}`)
          throw new Error(i)
        }
        if (Eo(this.pairings.get(r).expiry)) {
          await this.deletePairing(r)
          const { message: i } = me('EXPIRED', `pairing topic: ${r}`)
          throw new Error(i)
        }
      }),
      (this.core = e),
      (this.logger = Pr(n, this.name)),
      (this.pairings = new Eu(this.core, this.logger, this.name, this.storagePrefix))
  }
  get context() {
    return ni(this.logger)
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = me('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(or.message, async e => {
      const { topic: n, message: r, transportType: i } = e
      if (
        this.pairings.keys.includes(n) &&
        i !== hn.link_mode &&
        !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(r))
      )
        try {
          const s = await this.core.crypto.decode(n, r)
          u2(s)
            ? (this.core.history.set(n, s),
              await this.onRelayEventRequest({ topic: n, payload: s }))
            : $m(s) &&
              (await this.core.history.resolve(s),
              await this.onRelayEventResponse({ topic: n, payload: s }),
              this.core.history.delete(n, s.id)),
            await this.core.relayer.messages.ack(n, r)
        } catch (s) {
          this.logger.error(s)
        }
    })
  }
  registerExpirerEvents() {
    this.core.expirer.on(Ui.expired, async e => {
      const { topic: n } = wx(e.target)
      n &&
        this.pairings.keys.includes(n) &&
        (await this.deletePairing(n, !0), this.events.emit(Ic.expire, { topic: n }))
    })
  }
}
var CV = Object.defineProperty,
  SV = (t, e, n) =>
    e in t ? CV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  br = (t, e, n) => SV(t, typeof e != 'symbol' ? e + '' : e, n)
class TV extends pP {
  constructor(e, n) {
    super(e, n),
      (this.core = e),
      (this.logger = n),
      br(this, 'records', new Map()),
      br(this, 'events', new zi.EventEmitter()),
      br(this, 'name', Nq),
      br(this, 'version', Iq),
      br(this, 'cached', []),
      br(this, 'initialized', !1),
      br(this, 'storagePrefix', zs),
      br(this, 'init', async () => {
        this.initialized ||
          (this.logger.trace('Initialized'),
          await this.restore(),
          this.cached.forEach(r => this.records.set(r.id, r)),
          (this.cached = []),
          this.registerEventListeners(),
          (this.initialized = !0))
      }),
      br(this, 'set', (r, i, s) => {
        if (
          (this.isInitialized(),
          this.logger.debug('Setting JSON-RPC request history record'),
          this.logger.trace({ type: 'method', method: 'set', topic: r, request: i, chainId: s }),
          this.records.has(i.id))
        )
          return
        const c = {
          id: i.id,
          topic: r,
          request: { method: i.method, params: i.params || null },
          chainId: s,
          expiry: Zn(ge.THIRTY_DAYS)
        }
        this.records.set(c.id, c), this.persist(), this.events.emit(ts.created, c)
      }),
      br(this, 'resolve', async r => {
        if (
          (this.isInitialized(),
          this.logger.debug('Updating JSON-RPC response history record'),
          this.logger.trace({ type: 'method', method: 'update', response: r }),
          !this.records.has(r.id))
        )
          return
        const i = await this.getRecord(r.id)
        typeof i.response > 'u' &&
          ((i.response = Li(r) ? { error: r.error } : { result: r.result }),
          this.records.set(i.id, i),
          this.persist(),
          this.events.emit(ts.updated, i))
      }),
      br(
        this,
        'get',
        async (r, i) => (
          this.isInitialized(),
          this.logger.debug('Getting record'),
          this.logger.trace({ type: 'method', method: 'get', topic: r, id: i }),
          await this.getRecord(i)
        )
      ),
      br(this, 'delete', (r, i) => {
        this.isInitialized(),
          this.logger.debug('Deleting record'),
          this.logger.trace({ type: 'method', method: 'delete', id: i }),
          this.values.forEach(s => {
            if (s.topic === r) {
              if (typeof i < 'u' && s.id !== i) return
              this.records.delete(s.id), this.events.emit(ts.deleted, s)
            }
          }),
          this.persist()
      }),
      br(
        this,
        'exists',
        async (r, i) => (
          this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === r : !1
        )
      ),
      br(this, 'on', (r, i) => {
        this.events.on(r, i)
      }),
      br(this, 'once', (r, i) => {
        this.events.once(r, i)
      }),
      br(this, 'off', (r, i) => {
        this.events.off(r, i)
      }),
      br(this, 'removeListener', (r, i) => {
        this.events.removeListener(r, i)
      }),
      (this.logger = Pr(n, this.name))
  }
  get context() {
    return ni(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
  }
  get size() {
    return this.records.size
  }
  get keys() {
    return Array.from(this.records.keys())
  }
  get values() {
    return Array.from(this.records.values())
  }
  get pending() {
    const e = []
    return (
      this.values.forEach(n => {
        if (typeof n.response < 'u') return
        const r = {
          topic: n.topic,
          request: Uo(n.request.method, n.request.params, n.id),
          chainId: n.chainId
        }
        return e.push(r)
      }),
      e
    )
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e)
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey)
  }
  getRecord(e) {
    this.isInitialized()
    const n = this.records.get(e)
    if (!n) {
      const { message: r } = me('NO_MATCHING_KEY', `${this.name}: ${e}`)
      throw new Error(r)
    }
    return n
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(ts.sync)
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords()
      if (typeof e > 'u' || !e.length) return
      if (this.records.size) {
        const { message: n } = me('RESTORE_WILL_OVERRIDE', this.name)
        throw (this.logger.error(n), new Error(n))
      }
      ;(this.cached = e),
        this.logger.debug(`Successfully Restored records for ${this.name}`),
        this.logger.trace({ type: 'method', method: 'restore', records: this.values })
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e)
    }
  }
  registerEventListeners() {
    this.events.on(ts.created, e => {
      const n = ts.created
      this.logger.info(`Emitting ${n}`), this.logger.debug({ type: 'event', event: n, record: e })
    }),
      this.events.on(ts.updated, e => {
        const n = ts.updated
        this.logger.info(`Emitting ${n}`), this.logger.debug({ type: 'event', event: n, record: e })
      }),
      this.events.on(ts.deleted, e => {
        const n = ts.deleted
        this.logger.info(`Emitting ${n}`), this.logger.debug({ type: 'event', event: n, record: e })
      }),
      this.core.heartbeat.on(bd.pulse, () => {
        this.cleanup()
      })
  }
  cleanup() {
    try {
      this.isInitialized()
      let e = !1
      this.records.forEach(n => {
        ge.toMiliseconds(n.expiry || 0) - Date.now() <= 0 &&
          (this.logger.info(`Deleting expired history log: ${n.id}`),
          this.records.delete(n.id),
          this.events.emit(ts.deleted, n, !1),
          (e = !0))
      }),
        e && this.persist()
    } catch (e) {
      this.logger.warn(e)
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = me('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
}
var xV = Object.defineProperty,
  NV = (t, e, n) =>
    e in t ? xV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Tr = (t, e, n) => NV(t, typeof e != 'symbol' ? e + '' : e, n)
class IV extends wP {
  constructor(e, n) {
    super(e, n),
      (this.core = e),
      (this.logger = n),
      Tr(this, 'expirations', new Map()),
      Tr(this, 'events', new zi.EventEmitter()),
      Tr(this, 'name', Oq),
      Tr(this, 'version', Rq),
      Tr(this, 'cached', []),
      Tr(this, 'initialized', !1),
      Tr(this, 'storagePrefix', zs),
      Tr(this, 'init', async () => {
        this.initialized ||
          (this.logger.trace('Initialized'),
          await this.restore(),
          this.cached.forEach(r => this.expirations.set(r.target, r)),
          (this.cached = []),
          this.registerEventListeners(),
          (this.initialized = !0))
      }),
      Tr(this, 'has', r => {
        try {
          const i = this.formatTarget(r)
          return typeof this.getExpiration(i) < 'u'
        } catch {
          return !1
        }
      }),
      Tr(this, 'set', (r, i) => {
        this.isInitialized()
        const s = this.formatTarget(r),
          c = { target: s, expiry: i }
        this.expirations.set(s, c),
          this.checkExpiry(s, c),
          this.events.emit(Ui.created, { target: s, expiration: c })
      }),
      Tr(this, 'get', r => {
        this.isInitialized()
        const i = this.formatTarget(r)
        return this.getExpiration(i)
      }),
      Tr(this, 'del', r => {
        if ((this.isInitialized(), this.has(r))) {
          const i = this.formatTarget(r),
            s = this.getExpiration(i)
          this.expirations.delete(i), this.events.emit(Ui.deleted, { target: i, expiration: s })
        }
      }),
      Tr(this, 'on', (r, i) => {
        this.events.on(r, i)
      }),
      Tr(this, 'once', (r, i) => {
        this.events.once(r, i)
      }),
      Tr(this, 'off', (r, i) => {
        this.events.off(r, i)
      }),
      Tr(this, 'removeListener', (r, i) => {
        this.events.removeListener(r, i)
      }),
      (this.logger = Pr(n, this.name))
  }
  get context() {
    return ni(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
  }
  get length() {
    return this.expirations.size
  }
  get keys() {
    return Array.from(this.expirations.keys())
  }
  get values() {
    return Array.from(this.expirations.values())
  }
  formatTarget(e) {
    if (typeof e == 'string') return W$(e)
    if (typeof e == 'number') return Q$(e)
    const { message: n } = me('UNKNOWN_TYPE', `Target type: ${typeof e}`)
    throw new Error(n)
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e)
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey)
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(Ui.sync)
  }
  async restore() {
    try {
      const e = await this.getExpirations()
      if (typeof e > 'u' || !e.length) return
      if (this.expirations.size) {
        const { message: n } = me('RESTORE_WILL_OVERRIDE', this.name)
        throw (this.logger.error(n), new Error(n))
      }
      ;(this.cached = e),
        this.logger.debug(`Successfully Restored expirations for ${this.name}`),
        this.logger.trace({ type: 'method', method: 'restore', expirations: this.values })
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e)
    }
  }
  getExpiration(e) {
    const n = this.expirations.get(e)
    if (!n) {
      const { message: r } = me('NO_MATCHING_KEY', `${this.name}: ${e}`)
      throw (this.logger.warn(r), new Error(r))
    }
    return n
  }
  checkExpiry(e, n) {
    const { expiry: r } = n
    ge.toMiliseconds(r) - Date.now() <= 0 && this.expire(e, n)
  }
  expire(e, n) {
    this.expirations.delete(e), this.events.emit(Ui.expired, { target: e, expiration: n })
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, n) => this.checkExpiry(n, e))
  }
  registerEventListeners() {
    this.core.heartbeat.on(bd.pulse, () => this.checkExpirations()),
      this.events.on(Ui.created, e => {
        const n = Ui.created
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: 'event', event: n, data: e }),
          this.persist()
      }),
      this.events.on(Ui.expired, e => {
        const n = Ui.expired
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: 'event', event: n, data: e }),
          this.persist()
      }),
      this.events.on(Ui.deleted, e => {
        const n = Ui.deleted
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: 'event', event: n, data: e }),
          this.persist()
      })
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = me('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
}
var OV = Object.defineProperty,
  RV = (t, e, n) =>
    e in t ? OV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Gn = (t, e, n) => RV(t, typeof e != 'symbol' ? e + '' : e, n)
class DV extends EP {
  constructor(e, n, r) {
    super(e, n, r),
      (this.core = e),
      (this.logger = n),
      (this.store = r),
      Gn(this, 'name', Dq),
      Gn(this, 'abortController'),
      Gn(this, 'isDevEnv'),
      Gn(this, 'verifyUrlV3', Mq),
      Gn(this, 'storagePrefix', zs),
      Gn(this, 'version', Jx),
      Gn(this, 'publicKey'),
      Gn(this, 'fetchPromise'),
      Gn(this, 'init', async () => {
        var i
        this.isDevEnv ||
          ((this.publicKey = await this.store.getItem(this.storeKey)),
          this.publicKey &&
            ge.toMiliseconds((i = this.publicKey) == null ? void 0 : i.expiresAt) < Date.now() &&
            (this.logger.debug('verify v2 public key expired'), await this.removePublicKey()))
      }),
      Gn(this, 'register', async i => {
        if (!wp() || this.isDevEnv) return
        const s = window.location.origin,
          { id: c, decryptedId: u } = i,
          f = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${s}&id=${c}&decryptedId=${u}`
        try {
          const d = Jc.getDocument(),
            p = this.startAbortTimer(ge.ONE_SECOND * 5),
            g = await new Promise((m, y) => {
              const A = () => {
                window.removeEventListener('message', x),
                  d.body.removeChild(E),
                  y('attestation aborted')
              }
              this.abortController.signal.addEventListener('abort', A)
              const E = d.createElement('iframe')
              ;(E.src = f),
                (E.style.display = 'none'),
                E.addEventListener('error', A, { signal: this.abortController.signal })
              const x = O => {
                if (O.data && typeof O.data == 'string')
                  try {
                    const I = JSON.parse(O.data)
                    if (I.type === 'verify_attestation') {
                      if (mw(I.attestation).payload.id !== c) return
                      clearInterval(p),
                        d.body.removeChild(E),
                        this.abortController.signal.removeEventListener('abort', A),
                        window.removeEventListener('message', x),
                        m(I.attestation === null ? '' : I.attestation)
                    }
                  } catch (I) {
                    this.logger.warn(I)
                  }
              }
              d.body.appendChild(E),
                window.addEventListener('message', x, { signal: this.abortController.signal })
            })
          return this.logger.debug('jwt attestation', g), g
        } catch (d) {
          this.logger.warn(d)
        }
        return ''
      }),
      Gn(this, 'resolve', async i => {
        if (this.isDevEnv) return ''
        const { attestationId: s, hash: c, encryptedId: u } = i
        if (s === '') {
          this.logger.debug('resolve: attestationId is empty, skipping')
          return
        }
        if (s) {
          if (mw(s).payload.id !== u) return
          const d = await this.isValidJwtAttestation(s)
          if (d) {
            if (!d.isVerified) {
              this.logger.warn('resolve: jwt attestation: origin url not verified')
              return
            }
            return d
          }
        }
        if (!c) return
        const f = this.getVerifyUrl(i == null ? void 0 : i.verifyUrl)
        return this.fetchAttestation(c, f)
      }),
      Gn(this, 'fetchAttestation', async (i, s) => {
        this.logger.debug(`resolving attestation: ${i} from url: ${s}`)
        const c = this.startAbortTimer(ge.ONE_SECOND * 5),
          u = await fetch(`${s}/attestation/${i}?v2Supported=true`, {
            signal: this.abortController.signal
          })
        return clearTimeout(c), u.status === 200 ? await u.json() : void 0
      }),
      Gn(this, 'getVerifyUrl', i => {
        let s = i || lh
        return (
          kq.includes(s) ||
            (this.logger.info(
              `verify url: ${s}, not included in trusted list, assigning default: ${lh}`
            ),
            (s = lh)),
          s
        )
      }),
      Gn(this, 'fetchPublicKey', async () => {
        try {
          this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`)
          const i = this.startAbortTimer(ge.FIVE_SECONDS),
            s = await fetch(`${this.verifyUrlV3}/public-key`, {
              signal: this.abortController.signal
            })
          return clearTimeout(i), await s.json()
        } catch (i) {
          this.logger.warn(i)
        }
      }),
      Gn(this, 'persistPublicKey', async i => {
        this.logger.debug('persisting public key to local storage', i),
          await this.store.setItem(this.storeKey, i),
          (this.publicKey = i)
      }),
      Gn(this, 'removePublicKey', async () => {
        this.logger.debug('removing verify v2 public key from storage'),
          await this.store.removeItem(this.storeKey),
          (this.publicKey = void 0)
      }),
      Gn(this, 'isValidJwtAttestation', async i => {
        const s = await this.getPublicKey()
        try {
          if (s) return this.validateAttestation(i, s)
        } catch (u) {
          this.logger.error(u), this.logger.warn('error validating attestation')
        }
        const c = await this.fetchAndPersistPublicKey()
        try {
          if (c) return this.validateAttestation(i, c)
        } catch (u) {
          this.logger.error(u), this.logger.warn('error validating attestation')
        }
      }),
      Gn(this, 'getPublicKey', async () =>
        this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()
      ),
      Gn(this, 'fetchAndPersistPublicKey', async () => {
        if (this.fetchPromise) return await this.fetchPromise, this.publicKey
        this.fetchPromise = new Promise(async s => {
          const c = await this.fetchPublicKey()
          c && (await this.persistPublicKey(c), s(c))
        })
        const i = await this.fetchPromise
        return (this.fetchPromise = void 0), i
      }),
      Gn(this, 'validateAttestation', (i, s) => {
        const c = ez(i, s.publicKey),
          u = { hasExpired: ge.toMiliseconds(c.exp) < Date.now(), payload: c }
        if (u.hasExpired)
          throw (
            (this.logger.warn('resolve: jwt attestation expired'),
            new Error('JWT attestation expired'))
          )
        return {
          origin: u.payload.origin,
          isScam: u.payload.isScam,
          isVerified: u.payload.isVerified
        }
      }),
      (this.logger = Pr(n, this.name)),
      (this.abortController = new AbortController()),
      (this.isDevEnv = JE()),
      this.init()
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + '//verify:public:key'
  }
  get context() {
    return ni(this.logger)
  }
  startAbortTimer(e) {
    return (
      (this.abortController = new AbortController()),
      setTimeout(() => this.abortController.abort(), ge.toMiliseconds(e))
    )
  }
}
var PV = Object.defineProperty,
  MV = (t, e, n) =>
    e in t ? PV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  R6 = (t, e, n) => MV(t, typeof e != 'symbol' ? e + '' : e, n)
class kV extends AP {
  constructor(e, n) {
    super(e, n),
      (this.projectId = e),
      (this.logger = n),
      R6(this, 'context', Uq),
      R6(this, 'registerDeviceToken', async r => {
        const { clientId: i, token: s, notificationType: c, enableEncrypted: u = !1 } = r,
          f = `${Bq}/${this.projectId}/clients`
        await fetch(f, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ client_id: i, type: c, token: s, always_raw: u })
        })
      }),
      (this.logger = Pr(n, this.context))
  }
}
var UV = Object.defineProperty,
  D6 = Object.getOwnPropertySymbols,
  BV = Object.prototype.hasOwnProperty,
  LV = Object.prototype.propertyIsEnumerable,
  jw = (t, e, n) =>
    e in t ? UV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Vf = (t, e) => {
    for (var n in e || (e = {})) BV.call(e, n) && jw(t, n, e[n])
    if (D6) for (var n of D6(e)) LV.call(e, n) && jw(t, n, e[n])
    return t
  },
  ir = (t, e, n) => jw(t, typeof e != 'symbol' ? e + '' : e, n)
class $V extends _P {
  constructor(e, n, r = !0) {
    super(e, n, r),
      (this.core = e),
      (this.logger = n),
      ir(this, 'context', $q),
      ir(this, 'storagePrefix', zs),
      ir(this, 'storageVersion', Lq),
      ir(this, 'events', new Map()),
      ir(this, 'shouldPersist', !1),
      ir(this, 'init', async () => {
        if (!JE())
          try {
            const i = {
              eventId: A5(),
              timestamp: Date.now(),
              domain: this.getAppDomain(),
              props: {
                event: 'INIT',
                type: '',
                properties: {
                  client_id: await this.core.crypto.getClientId(),
                  user_agent: yx(this.core.relayer.protocol, this.core.relayer.version, Pw)
                }
              }
            }
            await this.sendEvent([i])
          } catch (i) {
            this.logger.warn(i)
          }
      }),
      ir(this, 'createEvent', i => {
        const {
            event: s = 'ERROR',
            type: c = '',
            properties: { topic: u, trace: f }
          } = i,
          d = A5(),
          p = this.core.projectId || '',
          g = Date.now(),
          m = Vf(
            {
              eventId: d,
              timestamp: g,
              props: { event: s, type: c, properties: { topic: u, trace: f } },
              bundleId: p,
              domain: this.getAppDomain()
            },
            this.setMethods(d)
          )
        return this.telemetryEnabled && (this.events.set(d, m), (this.shouldPersist = !0)), m
      }),
      ir(this, 'getEvent', i => {
        const { eventId: s, topic: c } = i
        if (s) return this.events.get(s)
        const u = Array.from(this.events.values()).find(f => f.props.properties.topic === c)
        if (u) return Vf(Vf({}, u), this.setMethods(u.eventId))
      }),
      ir(this, 'deleteEvent', i => {
        const { eventId: s } = i
        this.events.delete(s), (this.shouldPersist = !0)
      }),
      ir(this, 'setEventListeners', () => {
        this.core.heartbeat.on(bd.pulse, async () => {
          this.shouldPersist && (await this.persist()),
            this.events.forEach(i => {
              ge.fromMiliseconds(Date.now()) - ge.fromMiliseconds(i.timestamp) > Fq &&
                (this.events.delete(i.eventId), (this.shouldPersist = !0))
            })
        })
      }),
      ir(this, 'setMethods', i => ({
        addTrace: s => this.addTrace(i, s),
        setError: s => this.setError(i, s)
      })),
      ir(this, 'addTrace', (i, s) => {
        const c = this.events.get(i)
        c && (c.props.properties.trace.push(s), this.events.set(i, c), (this.shouldPersist = !0))
      }),
      ir(this, 'setError', (i, s) => {
        const c = this.events.get(i)
        c &&
          ((c.props.type = s),
          (c.timestamp = Date.now()),
          this.events.set(i, c),
          (this.shouldPersist = !0))
      }),
      ir(this, 'persist', async () => {
        await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())),
          (this.shouldPersist = !1)
      }),
      ir(this, 'restore', async () => {
        try {
          const i = (await this.core.storage.getItem(this.storageKey)) || []
          if (!i.length) return
          i.forEach(s => {
            this.events.set(s.eventId, Vf(Vf({}, s), this.setMethods(s.eventId)))
          })
        } catch (i) {
          this.logger.warn(i)
        }
      }),
      ir(this, 'submit', async () => {
        if (!this.telemetryEnabled || this.events.size === 0) return
        const i = []
        for (const [s, c] of this.events) c.props.type && i.push(c)
        if (i.length !== 0)
          try {
            if ((await this.sendEvent(i)).ok)
              for (const s of i) this.events.delete(s.eventId), (this.shouldPersist = !0)
          } catch (s) {
            this.logger.warn(s)
          }
      }),
      ir(this, 'sendEvent', async i => {
        const s = this.getAppDomain() ? '' : '&sp=desktop'
        return await fetch(`${jq}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Pw}${s}`, {
          method: 'POST',
          body: JSON.stringify(i)
        })
      }),
      ir(this, 'getAppDomain', () => bx().url),
      (this.logger = Pr(n, this.context)),
      (this.telemetryEnabled = r),
      r
        ? this.restore().then(async () => {
            await this.submit(), this.setEventListeners()
          })
        : this.persist()
  }
  get storageKey() {
    return (
      this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + '//' + this.context
    )
  }
}
var FV = Object.defineProperty,
  P6 = Object.getOwnPropertySymbols,
  jV = Object.prototype.hasOwnProperty,
  zV = Object.prototype.propertyIsEnumerable,
  zw = (t, e, n) =>
    e in t ? FV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  M6 = (t, e) => {
    for (var n in e || (e = {})) jV.call(e, n) && zw(t, n, e[n])
    if (P6) for (var n of P6(e)) zV.call(e, n) && zw(t, n, e[n])
    return t
  },
  cn = (t, e, n) => zw(t, typeof e != 'symbol' ? e + '' : e, n)
let qV = class hN extends lP {
  constructor(e) {
    var n
    super(e),
      cn(this, 'protocol', Xx),
      cn(this, 'version', Jx),
      cn(this, 'name', Dw),
      cn(this, 'relayUrl'),
      cn(this, 'projectId'),
      cn(this, 'customStoragePrefix'),
      cn(this, 'events', new zi.EventEmitter()),
      cn(this, 'logger'),
      cn(this, 'heartbeat'),
      cn(this, 'relayer'),
      cn(this, 'crypto'),
      cn(this, 'storage'),
      cn(this, 'history'),
      cn(this, 'expirer'),
      cn(this, 'pairing'),
      cn(this, 'verify'),
      cn(this, 'echoClient'),
      cn(this, 'linkModeSupportedApps'),
      cn(this, 'eventClient'),
      cn(this, 'initialized', !1),
      cn(this, 'logChunkController'),
      cn(this, 'on', (c, u) => this.events.on(c, u)),
      cn(this, 'once', (c, u) => this.events.once(c, u)),
      cn(this, 'off', (c, u) => this.events.off(c, u)),
      cn(this, 'removeListener', (c, u) => this.events.removeListener(c, u)),
      cn(this, 'dispatchEnvelope', ({ topic: c, message: u, sessionExists: f }) => {
        if (!c || !u) return
        const d = { topic: c, message: u, publishedAt: Date.now(), transportType: hn.link_mode }
        this.relayer.onLinkMessageEvent(d, { sessionExists: f })
      }),
      (this.projectId = e == null ? void 0 : e.projectId),
      (this.relayUrl = (e == null ? void 0 : e.relayUrl) || tN),
      (this.customStoragePrefix =
        e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : '')
    const r = yd({
        level:
          typeof (e == null ? void 0 : e.logger) == 'string' && e.logger ? e.logger : uq.logger,
        name: Dw
      }),
      { logger: i, chunkLoggerController: s } = jE({
        opts: r,
        maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes,
        loggerOverride: e == null ? void 0 : e.logger
      })
    ;(this.logChunkController = s),
      (n = this.logChunkController) != null &&
        n.downloadLogsBlobInBrowser &&
        (window.downloadLogsBlobInBrowser = async () => {
          var c, u
          ;(c = this.logChunkController) != null &&
            c.downloadLogsBlobInBrowser &&
            ((u = this.logChunkController) == null ||
              u.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }))
        }),
      (this.logger = Pr(i, this.name)),
      (this.heartbeat = new uD()),
      (this.crypto = new mG(this, this.logger, e == null ? void 0 : e.keychain)),
      (this.history = new TV(this, this.logger)),
      (this.expirer = new IV(this, this.logger)),
      (this.storage =
        e != null && e.storage
          ? e.storage
          : new GD(M6(M6({}, lq), e == null ? void 0 : e.storageOptions))),
      (this.relayer = new qG({
        core: this,
        logger: this.logger,
        relayUrl: this.relayUrl,
        projectId: this.projectId
      })),
      (this.pairing = new _V(this, this.logger)),
      (this.verify = new DV(this, this.logger, this.storage)),
      (this.echoClient = new kV(this.projectId || '', this.logger)),
      (this.linkModeSupportedApps = []),
      (this.eventClient = new $V(this, this.logger, e == null ? void 0 : e.telemetryEnabled))
  }
  static async init(e) {
    const n = new hN(e)
    await n.initialize()
    const r = await n.crypto.getClientId()
    return await n.storage.setItem(_q, r), n
  }
  get context() {
    return ni(this.logger)
  }
  async start() {
    this.initialized || (await this.initialize())
  }
  async getLogsBlob() {
    var e
    return (e = this.logChunkController) == null
      ? void 0
      : e.logsToBlob({ clientId: await this.crypto.getClientId() })
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) ||
      (this.linkModeSupportedApps.push(e),
      await this.storage.setItem(h6, this.linkModeSupportedApps))
  }
  async initialize() {
    this.logger.trace('Initialized')
    try {
      await this.crypto.init(),
        await this.history.init(),
        await this.expirer.init(),
        await this.relayer.init(),
        await this.heartbeat.init(),
        await this.pairing.init(),
        (this.linkModeSupportedApps = (await this.storage.getItem(h6)) || []),
        (this.initialized = !0),
        this.logger.info('Core Initialization Success')
    } catch (e) {
      throw (
        (this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e),
        this.logger.error(e.message),
        e)
      )
    }
  }
}
const HV = qV,
  pN = 'wc',
  gN = 2,
  mN = 'client',
  l2 = `${pN}@${gN}:${mN}:`,
  A1 = { name: mN, logger: 'error' },
  k6 = 'WALLETCONNECT_DEEPLINK_CHOICE',
  GV = 'proposal',
  U6 = 'Proposal expired',
  VV = 'session',
  fl = ge.SEVEN_DAYS,
  KV = 'engine',
  sr = {
    wc_sessionPropose: {
      req: { ttl: ge.FIVE_MINUTES, prompt: !0, tag: 1100 },
      res: { ttl: ge.FIVE_MINUTES, prompt: !1, tag: 1101 },
      reject: { ttl: ge.FIVE_MINUTES, prompt: !1, tag: 1120 },
      autoReject: { ttl: ge.FIVE_MINUTES, prompt: !1, tag: 1121 }
    },
    wc_sessionSettle: {
      req: { ttl: ge.FIVE_MINUTES, prompt: !1, tag: 1102 },
      res: { ttl: ge.FIVE_MINUTES, prompt: !1, tag: 1103 }
    },
    wc_sessionUpdate: {
      req: { ttl: ge.ONE_DAY, prompt: !1, tag: 1104 },
      res: { ttl: ge.ONE_DAY, prompt: !1, tag: 1105 }
    },
    wc_sessionExtend: {
      req: { ttl: ge.ONE_DAY, prompt: !1, tag: 1106 },
      res: { ttl: ge.ONE_DAY, prompt: !1, tag: 1107 }
    },
    wc_sessionRequest: {
      req: { ttl: ge.FIVE_MINUTES, prompt: !0, tag: 1108 },
      res: { ttl: ge.FIVE_MINUTES, prompt: !1, tag: 1109 }
    },
    wc_sessionEvent: {
      req: { ttl: ge.FIVE_MINUTES, prompt: !0, tag: 1110 },
      res: { ttl: ge.FIVE_MINUTES, prompt: !1, tag: 1111 }
    },
    wc_sessionDelete: {
      req: { ttl: ge.ONE_DAY, prompt: !1, tag: 1112 },
      res: { ttl: ge.ONE_DAY, prompt: !1, tag: 1113 }
    },
    wc_sessionPing: {
      req: { ttl: ge.ONE_DAY, prompt: !1, tag: 1114 },
      res: { ttl: ge.ONE_DAY, prompt: !1, tag: 1115 }
    },
    wc_sessionAuthenticate: {
      req: { ttl: ge.ONE_HOUR, prompt: !0, tag: 1116 },
      res: { ttl: ge.ONE_HOUR, prompt: !1, tag: 1117 },
      reject: { ttl: ge.FIVE_MINUTES, prompt: !1, tag: 1118 },
      autoReject: { ttl: ge.FIVE_MINUTES, prompt: !1, tag: 1119 }
    }
  },
  _1 = { min: ge.FIVE_MINUTES, max: ge.SEVEN_DAYS },
  Os = { idle: 'IDLE', active: 'ACTIVE' },
  B6 = {
    eth_sendTransaction: { key: '' },
    eth_sendRawTransaction: { key: '' },
    wallet_sendCalls: { key: '' },
    solana_signTransaction: { key: 'signature' },
    solana_signAllTransactions: { key: 'transactions' },
    solana_signAndSendTransaction: { key: 'signature' }
  },
  WV = 'request',
  QV = ['wc_sessionPropose', 'wc_sessionRequest', 'wc_authRequest', 'wc_sessionAuthenticate'],
  YV = 'wc',
  ZV = 'auth',
  XV = 'authKeys',
  JV = 'pairingTopics',
  eK = 'requests',
  jm = `${YV}@${1.5}:${ZV}:`,
  Rg = `${jm}:PUB_KEY`
var tK = Object.defineProperty,
  nK = Object.defineProperties,
  rK = Object.getOwnPropertyDescriptors,
  L6 = Object.getOwnPropertySymbols,
  iK = Object.prototype.hasOwnProperty,
  sK = Object.prototype.propertyIsEnumerable,
  qw = (t, e, n) =>
    e in t ? tK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  nn = (t, e) => {
    for (var n in e || (e = {})) iK.call(e, n) && qw(t, n, e[n])
    if (L6) for (var n of L6(e)) sK.call(e, n) && qw(t, n, e[n])
    return t
  },
  Ur = (t, e) => nK(t, rK(e)),
  de = (t, e, n) => qw(t, typeof e != 'symbol' ? e + '' : e, n)
class aK extends xP {
  constructor(e) {
    super(e),
      de(this, 'name', KV),
      de(this, 'events', new $E()),
      de(this, 'initialized', !1),
      de(this, 'requestQueue', { state: Os.idle, queue: [] }),
      de(this, 'sessionRequestQueue', { state: Os.idle, queue: [] }),
      de(this, 'requestQueueDelay', ge.ONE_SECOND),
      de(this, 'expectedPairingMethodMap', new Map()),
      de(this, 'recentlyDeletedMap', new Map()),
      de(this, 'recentlyDeletedLimit', 200),
      de(this, 'relayMessageCache', []),
      de(this, 'pendingSessions', new Map()),
      de(this, 'init', async () => {
        this.initialized ||
          (await this.cleanup(),
          this.registerRelayerEvents(),
          this.registerExpirerEvents(),
          this.registerPairingEvents(),
          await this.registerLinkModeListeners(),
          this.client.core.pairing.register({ methods: Object.keys(sr) }),
          (this.initialized = !0),
          setTimeout(async () => {
            await this.processPendingMessageEvents(),
              (this.sessionRequestQueue.queue = this.getPendingSessionRequests()),
              this.processSessionRequestQueue()
          }, ge.toMiliseconds(this.requestQueueDelay)))
      }),
      de(this, 'connect', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow()
        const r = Ur(nn({}, n), {
          requiredNamespaces: n.requiredNamespaces || {},
          optionalNamespaces: n.optionalNamespaces || {}
        })
        await this.isValidConnect(r)
        const {
          pairingTopic: i,
          requiredNamespaces: s,
          optionalNamespaces: c,
          sessionProperties: u,
          scopedProperties: f,
          relays: d
        } = r
        let p = i,
          g,
          m = !1
        try {
          if (p) {
            const R = this.client.core.pairing.pairings.get(p)
            this.client.logger.warn(
              'connect() with existing pairing topic is deprecated and will be removed in the next major release.'
            ),
              (m = R.active)
          }
        } catch (R) {
          throw (this.client.logger.error(`connect() -> pairing.get(${p}) failed`), R)
        }
        if (!p || !m) {
          const { topic: R, uri: z } = await this.client.core.pairing.create()
          ;(p = R), (g = z)
        }
        if (!p) {
          const { message: R } = me('NO_MATCHING_KEY', `connect() pairing topic: ${p}`)
          throw new Error(R)
        }
        const y = await this.client.core.crypto.generateKeyPair(),
          A = sr.wc_sessionPropose.req.ttl || ge.FIVE_MINUTES,
          E = Zn(A),
          x = Ur(
            nn(
              nn(
                {
                  requiredNamespaces: s,
                  optionalNamespaces: c,
                  relays: d ?? [{ protocol: eN }],
                  proposer: { publicKey: y, metadata: this.client.metadata },
                  expiryTimestamp: E,
                  pairingTopic: p
                },
                u && { sessionProperties: u }
              ),
              f && { scopedProperties: f }
            ),
            { id: Ps() }
          ),
          O = Pt('session_connect', x.id),
          { reject: I, resolve: M, done: $ } = Sc(A, U6),
          D = ({ id: R }) => {
            R === x.id &&
              (this.client.events.off('proposal_expire', D),
              this.pendingSessions.delete(x.id),
              this.events.emit(O, { error: { message: U6, code: 0 } }))
          }
        return (
          this.client.events.on('proposal_expire', D),
          this.events.once(O, ({ error: R, session: z }) => {
            this.client.events.off('proposal_expire', D), R ? I(R) : z && M(z)
          }),
          await this.sendRequest({
            topic: p,
            method: 'wc_sessionPropose',
            params: x,
            throwOnFailedPublish: !0,
            clientRpcId: x.id
          }),
          await this.setProposal(x.id, x),
          { uri: g, approval: $ }
        )
      }),
      de(this, 'pair', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow()
        try {
          return await this.client.core.pairing.pair(n)
        } catch (r) {
          throw (this.client.logger.error('pair() failed'), r)
        }
      }),
      de(this, 'approve', async n => {
        var r, i, s
        const c = this.client.core.eventClient.createEvent({
          properties: {
            topic: (r = n == null ? void 0 : n.id) == null ? void 0 : r.toString(),
            trace: [ns.session_approve_started]
          }
        })
        try {
          this.isInitialized(), await this.confirmOnlineStateOrThrow()
        } catch (j) {
          throw (c.setError(Ac.no_internet_connection), j)
        }
        try {
          await this.isValidProposalId(n == null ? void 0 : n.id)
        } catch (j) {
          throw (
            (this.client.logger.error(
              `approve() -> proposal.get(${n == null ? void 0 : n.id}) failed`
            ),
            c.setError(Ac.proposal_not_found),
            j)
          )
        }
        try {
          await this.isValidApprove(n)
        } catch (j) {
          throw (
            (this.client.logger.error('approve() -> isValidApprove() failed'),
            c.setError(Ac.session_approve_namespace_validation_failure),
            j)
          )
        }
        const {
            id: u,
            relayProtocol: f,
            namespaces: d,
            sessionProperties: p,
            scopedProperties: g,
            sessionConfig: m
          } = n,
          y = this.client.proposal.get(u)
        this.client.core.eventClient.deleteEvent({ eventId: c.eventId })
        const { pairingTopic: A, proposer: E, requiredNamespaces: x, optionalNamespaces: O } = y
        let I = (i = this.client.core.eventClient) == null ? void 0 : i.getEvent({ topic: A })
        I ||
          (I =
            (s = this.client.core.eventClient) == null
              ? void 0
              : s.createEvent({
                  type: ns.session_approve_started,
                  properties: {
                    topic: A,
                    trace: [ns.session_approve_started, ns.session_namespaces_validation_success]
                  }
                }))
        const M = await this.client.core.crypto.generateKeyPair(),
          $ = E.publicKey,
          D = await this.client.core.crypto.generateSharedKey(M, $),
          R = nn(
            nn(
              nn(
                {
                  relay: { protocol: f ?? 'irn' },
                  namespaces: d,
                  controller: { publicKey: M, metadata: this.client.metadata },
                  expiry: Zn(fl)
                },
                p && { sessionProperties: p }
              ),
              g && { scopedProperties: g }
            ),
            m && { sessionConfig: m }
          ),
          z = hn.relay
        I.addTrace(ns.subscribing_session_topic)
        try {
          await this.client.core.relayer.subscribe(D, { transportType: z })
        } catch (j) {
          throw (I.setError(Ac.subscribe_session_topic_failure), j)
        }
        I.addTrace(ns.subscribe_session_topic_success)
        const G = Ur(nn({}, R), {
          topic: D,
          requiredNamespaces: x,
          optionalNamespaces: O,
          pairingTopic: A,
          acknowledged: !1,
          self: R.controller,
          peer: { publicKey: E.publicKey, metadata: E.metadata },
          controller: M,
          transportType: hn.relay
        })
        await this.client.session.set(D, G), I.addTrace(ns.store_session)
        try {
          I.addTrace(ns.publishing_session_settle),
            await this.sendRequest({
              topic: D,
              method: 'wc_sessionSettle',
              params: R,
              throwOnFailedPublish: !0
            }).catch(j => {
              throw (I == null || I.setError(Ac.session_settle_publish_failure), j)
            }),
            I.addTrace(ns.session_settle_publish_success),
            I.addTrace(ns.publishing_session_approve),
            await this.sendResult({
              id: u,
              topic: A,
              result: { relay: { protocol: f ?? 'irn' }, responderPublicKey: M },
              throwOnFailedPublish: !0
            }).catch(j => {
              throw (I == null || I.setError(Ac.session_approve_publish_failure), j)
            }),
            I.addTrace(ns.session_approve_publish_success)
        } catch (j) {
          throw (
            (this.client.logger.error(j),
            this.client.session.delete(D, Qt('USER_DISCONNECTED')),
            await this.client.core.relayer.unsubscribe(D),
            j)
          )
        }
        return (
          this.client.core.eventClient.deleteEvent({ eventId: I.eventId }),
          await this.client.core.pairing.updateMetadata({ topic: A, metadata: E.metadata }),
          await this.client.proposal.delete(u, Qt('USER_DISCONNECTED')),
          await this.client.core.pairing.activate({ topic: A }),
          await this.setExpiry(D, Zn(fl)),
          { topic: D, acknowledged: () => Promise.resolve(this.client.session.get(D)) }
        )
      }),
      de(this, 'reject', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow()
        try {
          await this.isValidReject(n)
        } catch (c) {
          throw (this.client.logger.error('reject() -> isValidReject() failed'), c)
        }
        const { id: r, reason: i } = n
        let s
        try {
          s = this.client.proposal.get(r).pairingTopic
        } catch (c) {
          throw (this.client.logger.error(`reject() -> proposal.get(${r}) failed`), c)
        }
        s &&
          (await this.sendError({
            id: r,
            topic: s,
            error: i,
            rpcOpts: sr.wc_sessionPropose.reject
          }),
          await this.client.proposal.delete(r, Qt('USER_DISCONNECTED')))
      }),
      de(this, 'update', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow()
        try {
          await this.isValidUpdate(n)
        } catch (g) {
          throw (this.client.logger.error('update() -> isValidUpdate() failed'), g)
        }
        const { topic: r, namespaces: i } = n,
          { done: s, resolve: c, reject: u } = Sc(),
          f = Ps(),
          d = Dc().toString(),
          p = this.client.session.get(r).namespaces
        return (
          this.events.once(Pt('session_update', f), ({ error: g }) => {
            g ? u(g) : c()
          }),
          await this.client.session.update(r, { namespaces: i }),
          await this.sendRequest({
            topic: r,
            method: 'wc_sessionUpdate',
            params: { namespaces: i },
            throwOnFailedPublish: !0,
            clientRpcId: f,
            relayRpcId: d
          }).catch(g => {
            this.client.logger.error(g), this.client.session.update(r, { namespaces: p }), u(g)
          }),
          { acknowledged: s }
        )
      }),
      de(this, 'extend', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow()
        try {
          await this.isValidExtend(n)
        } catch (f) {
          throw (this.client.logger.error('extend() -> isValidExtend() failed'), f)
        }
        const { topic: r } = n,
          i = Ps(),
          { done: s, resolve: c, reject: u } = Sc()
        return (
          this.events.once(Pt('session_extend', i), ({ error: f }) => {
            f ? u(f) : c()
          }),
          await this.setExpiry(r, Zn(fl)),
          this.sendRequest({
            topic: r,
            method: 'wc_sessionExtend',
            params: {},
            clientRpcId: i,
            throwOnFailedPublish: !0
          }).catch(f => {
            u(f)
          }),
          { acknowledged: s }
        )
      }),
      de(this, 'request', async n => {
        this.isInitialized()
        try {
          await this.isValidRequest(n)
        } catch (O) {
          throw (this.client.logger.error('request() -> isValidRequest() failed'), O)
        }
        const { chainId: r, request: i, topic: s, expiry: c = sr.wc_sessionRequest.req.ttl } = n,
          u = this.client.session.get(s)
        ;(u == null ? void 0 : u.transportType) === hn.relay &&
          (await this.confirmOnlineStateOrThrow())
        const f = Ps(),
          d = Dc().toString(),
          { done: p, resolve: g, reject: m } = Sc(c, 'Request expired. Please try again.')
        this.events.once(Pt('session_request', f), ({ error: O, result: I }) => {
          O ? m(O) : g(I)
        })
        const y = 'wc_sessionRequest',
          A = this.getAppLinkIfEnabled(u.peer.metadata, u.transportType)
        if (A)
          return (
            await this.sendRequest({
              clientRpcId: f,
              relayRpcId: d,
              topic: s,
              method: y,
              params: { request: Ur(nn({}, i), { expiryTimestamp: Zn(c) }), chainId: r },
              expiry: c,
              throwOnFailedPublish: !0,
              appLink: A
            }).catch(O => m(O)),
            this.client.events.emit('session_request_sent', {
              topic: s,
              request: i,
              chainId: r,
              id: f
            }),
            await p()
          )
        const E = { request: Ur(nn({}, i), { expiryTimestamp: Zn(c) }), chainId: r },
          x = this.shouldSetTVF(y, E)
        return await Promise.all([
          new Promise(async O => {
            await this.sendRequest(
              nn(
                {
                  clientRpcId: f,
                  relayRpcId: d,
                  topic: s,
                  method: y,
                  params: E,
                  expiry: c,
                  throwOnFailedPublish: !0
                },
                x && { tvf: this.getTVFParams(f, E) }
              )
            ).catch(I => m(I)),
              this.client.events.emit('session_request_sent', {
                topic: s,
                request: i,
                chainId: r,
                id: f
              }),
              O()
          }),
          new Promise(async O => {
            var I
            if (!((I = u.sessionConfig) != null && I.disableDeepLink)) {
              const M = await J$(this.client.core.storage, k6)
              await Y$({ id: f, topic: s, wcDeepLink: M })
            }
            O()
          }),
          p()
        ]).then(O => O[2])
      }),
      de(this, 'respond', async n => {
        this.isInitialized(), await this.isValidRespond(n)
        const { topic: r, response: i } = n,
          { id: s } = i,
          c = this.client.session.get(r)
        c.transportType === hn.relay && (await this.confirmOnlineStateOrThrow())
        const u = this.getAppLinkIfEnabled(c.peer.metadata, c.transportType)
        Ms(i)
          ? await this.sendResult({
              id: s,
              topic: r,
              result: i.result,
              throwOnFailedPublish: !0,
              appLink: u
            })
          : Li(i) && (await this.sendError({ id: s, topic: r, error: i.error, appLink: u })),
          this.cleanupAfterResponse(n)
      }),
      de(this, 'ping', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow()
        try {
          await this.isValidPing(n)
        } catch (i) {
          throw (this.client.logger.error('ping() -> isValidPing() failed'), i)
        }
        const { topic: r } = n
        if (this.client.session.keys.includes(r)) {
          const i = Ps(),
            s = Dc().toString(),
            { done: c, resolve: u, reject: f } = Sc()
          this.events.once(Pt('session_ping', i), ({ error: d }) => {
            d ? f(d) : u()
          }),
            await Promise.all([
              this.sendRequest({
                topic: r,
                method: 'wc_sessionPing',
                params: {},
                throwOnFailedPublish: !0,
                clientRpcId: i,
                relayRpcId: s
              }),
              c()
            ])
        } else
          this.client.core.pairing.pairings.keys.includes(r) &&
            (this.client.logger.warn(
              'ping() on pairing topic is deprecated and will be removed in the next major release.'
            ),
            await this.client.core.pairing.ping({ topic: r }))
      }),
      de(this, 'emit', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(n)
        const { topic: r, event: i, chainId: s } = n,
          c = Dc().toString(),
          u = Ps()
        await this.sendRequest({
          topic: r,
          method: 'wc_sessionEvent',
          params: { event: i, chainId: s },
          throwOnFailedPublish: !0,
          relayRpcId: c,
          clientRpcId: u
        })
      }),
      de(this, 'disconnect', async n => {
        this.isInitialized(),
          await this.confirmOnlineStateOrThrow(),
          await this.isValidDisconnect(n)
        const { topic: r } = n
        if (this.client.session.keys.includes(r))
          await this.sendRequest({
            topic: r,
            method: 'wc_sessionDelete',
            params: Qt('USER_DISCONNECTED'),
            throwOnFailedPublish: !0
          }),
            await this.deleteSession({ topic: r, emitEvent: !1 })
        else if (this.client.core.pairing.pairings.keys.includes(r))
          await this.client.core.pairing.disconnect({ topic: r })
        else {
          const { message: i } = me('MISMATCHED_TOPIC', `Session or pairing topic not found: ${r}`)
          throw new Error(i)
        }
      }),
      de(
        this,
        'find',
        n => (this.isInitialized(), this.client.session.getAll().filter(r => dz(r, n)))
      ),
      de(this, 'getPendingSessionRequests', () => this.client.pendingRequest.getAll()),
      de(this, 'authenticate', async (n, r) => {
        var i
        this.isInitialized(), this.isValidAuthenticate(n)
        const s =
            r &&
            this.client.core.linkModeSupportedApps.includes(r) &&
            ((i = this.client.metadata.redirect) == null ? void 0 : i.linkMode),
          c = s ? hn.link_mode : hn.relay
        c === hn.relay && (await this.confirmOnlineStateOrThrow())
        const {
            chains: u,
            statement: f = '',
            uri: d,
            domain: p,
            nonce: g,
            type: m,
            exp: y,
            nbf: A,
            methods: E = [],
            expiry: x
          } = n,
          O = [...(n.resources || [])],
          { topic: I, uri: M } = await this.client.core.pairing.create({
            methods: ['wc_sessionAuthenticate'],
            transportType: c
          })
        this.client.logger.info({ message: 'Generated new pairing', pairing: { topic: I, uri: M } })
        const $ = await this.client.core.crypto.generateKeyPair(),
          D = Ig($)
        if (
          (await Promise.all([
            this.client.auth.authKeys.set(Rg, { responseTopic: D, publicKey: $ }),
            this.client.auth.pairingTopics.set(D, { topic: D, pairingTopic: I })
          ]),
          await this.client.core.relayer.subscribe(D, { transportType: c }),
          this.client.logger.info(`sending request to new pairing topic: ${I}`),
          E.length > 0)
        ) {
          const { namespace: P } = Ml(u[0])
          let w = HF(P, 'request', E)
          Ng(O) && (w = VF(w, O.pop())), O.push(w)
        }
        const R =
            x && x > sr.wc_sessionAuthenticate.req.ttl ? x : sr.wc_sessionAuthenticate.req.ttl,
          z = {
            authPayload: {
              type: m ?? 'caip122',
              chains: u,
              statement: f,
              aud: d,
              domain: p,
              version: '1',
              nonce: g,
              iat: new Date().toISOString(),
              exp: y,
              nbf: A,
              resources: O
            },
            requester: { publicKey: $, metadata: this.client.metadata },
            expiryTimestamp: Zn(R)
          },
          G = {
            eip155: {
              chains: u,
              methods: [...new Set(['personal_sign', ...E])],
              events: ['chainChanged', 'accountsChanged']
            }
          },
          j = {
            requiredNamespaces: {},
            optionalNamespaces: G,
            relays: [{ protocol: 'irn' }],
            pairingTopic: I,
            proposer: { publicKey: $, metadata: this.client.metadata },
            expiryTimestamp: Zn(sr.wc_sessionPropose.req.ttl),
            id: Ps()
          },
          { done: V, resolve: L, reject: v } = Sc(R, 'Request expired'),
          C = Ps(),
          N = Pt('session_connect', j.id),
          T = Pt('session_request', C),
          S = async ({ error: P, session: w }) => {
            this.events.off(T, k), P ? v(P) : w && L({ session: w })
          },
          k = async P => {
            var w, B, Z
            if (
              (await this.deletePendingAuthRequest(C, { message: 'fulfilled', code: 0 }), P.error)
            ) {
              const ye = Qt('WC_METHOD_UNSUPPORTED', 'wc_sessionAuthenticate')
              return P.error.code === ye.code ? void 0 : (this.events.off(N, S), v(P.error.message))
            }
            await this.deleteProposal(j.id), this.events.off(N, S)
            const { cacaos: ee, responder: Y } = P.result,
              se = [],
              ce = []
            for (const ye of ee) {
              ;(await O5({ cacao: ye, projectId: this.client.core.projectId })) ||
                (this.client.logger.error(ye, 'Signature verification failed'),
                v(Qt('SESSION_SETTLEMENT_FAILED', 'Signature verification failed')))
              const { p: Ce } = ye,
                kt = Ng(Ce.resources),
                tt = [Sw(Ce.iss)],
                Ke = Yg(Ce.iss)
              if (kt) {
                const jn = R5(kt),
                  ut = D5(kt)
                se.push(...jn), tt.push(...ut)
              }
              for (const jn of tt) ce.push(`${jn}:${Ke}`)
            }
            const we = await this.client.core.crypto.generateSharedKey($, Y.publicKey)
            let _e
            se.length > 0 &&
              ((_e = {
                topic: we,
                acknowledged: !0,
                self: { publicKey: $, metadata: this.client.metadata },
                peer: Y,
                controller: Y.publicKey,
                expiry: Zn(fl),
                requiredNamespaces: {},
                optionalNamespaces: {},
                relay: { protocol: 'irn' },
                pairingTopic: I,
                namespaces: Z5([...new Set(se)], [...new Set(ce)]),
                transportType: c
              }),
              await this.client.core.relayer.subscribe(we, { transportType: c }),
              await this.client.session.set(we, _e),
              I &&
                (await this.client.core.pairing.updateMetadata({ topic: I, metadata: Y.metadata })),
              (_e = this.client.session.get(we))),
              (w = this.client.metadata.redirect) != null &&
                w.linkMode &&
                (B = Y.metadata.redirect) != null &&
                B.linkMode &&
                (Z = Y.metadata.redirect) != null &&
                Z.universal &&
                r &&
                (this.client.core.addLinkModeSupportedApp(Y.metadata.redirect.universal),
                this.client.session.update(we, { transportType: hn.link_mode })),
              L({ auths: ee, session: _e })
          }
        this.events.once(N, S), this.events.once(T, k)
        let F
        try {
          if (s) {
            const P = Uo('wc_sessionAuthenticate', z, C)
            this.client.core.history.set(I, P)
            const w = await this.client.core.crypto.encode('', P, { type: Cp, encoding: jf })
            F = og(r, I, w)
          } else
            await Promise.all([
              this.sendRequest({
                topic: I,
                method: 'wc_sessionAuthenticate',
                params: z,
                expiry: n.expiry,
                throwOnFailedPublish: !0,
                clientRpcId: C
              }),
              this.sendRequest({
                topic: I,
                method: 'wc_sessionPropose',
                params: j,
                expiry: sr.wc_sessionPropose.req.ttl,
                throwOnFailedPublish: !0,
                clientRpcId: j.id
              })
            ])
        } catch (P) {
          throw (this.events.off(N, S), this.events.off(T, k), P)
        }
        return (
          await this.setProposal(j.id, j),
          await this.setAuthRequest(C, {
            request: Ur(nn({}, z), { verifyContext: {} }),
            pairingTopic: I,
            transportType: c
          }),
          { uri: F ?? M, response: V }
        )
      }),
      de(this, 'approveSessionAuthenticate', async n => {
        const { id: r, auths: i } = n,
          s = this.client.core.eventClient.createEvent({
            properties: { topic: r.toString(), trace: [_c.authenticated_session_approve_started] }
          })
        try {
          this.isInitialized()
        } catch (x) {
          throw (s.setError(Hf.no_internet_connection), x)
        }
        const c = this.getPendingAuthRequest(r)
        if (!c)
          throw (
            (s.setError(Hf.authenticated_session_pending_request_not_found),
            new Error(`Could not find pending auth request with id ${r}`))
          )
        const u = c.transportType || hn.relay
        u === hn.relay && (await this.confirmOnlineStateOrThrow())
        const f = c.requester.publicKey,
          d = await this.client.core.crypto.generateKeyPair(),
          p = Ig(f),
          g = { type: Oa, receiverPublicKey: f, senderPublicKey: d },
          m = [],
          y = []
        for (const x of i) {
          if (!(await O5({ cacao: x, projectId: this.client.core.projectId }))) {
            s.setError(Hf.invalid_cacao)
            const D = Qt('SESSION_SETTLEMENT_FAILED', 'Signature verification failed')
            throw (
              (await this.sendError({ id: r, topic: p, error: D, encodeOpts: g }),
              new Error(D.message))
            )
          }
          s.addTrace(_c.cacaos_verified)
          const { p: O } = x,
            I = Ng(O.resources),
            M = [Sw(O.iss)],
            $ = Yg(O.iss)
          if (I) {
            const D = R5(I),
              R = D5(I)
            m.push(...D), M.push(...R)
          }
          for (const D of M) y.push(`${D}:${$}`)
        }
        const A = await this.client.core.crypto.generateSharedKey(d, f)
        s.addTrace(_c.create_authenticated_session_topic)
        let E
        if ((m == null ? void 0 : m.length) > 0) {
          ;(E = {
            topic: A,
            acknowledged: !0,
            self: { publicKey: d, metadata: this.client.metadata },
            peer: { publicKey: f, metadata: c.requester.metadata },
            controller: f,
            expiry: Zn(fl),
            authentication: i,
            requiredNamespaces: {},
            optionalNamespaces: {},
            relay: { protocol: 'irn' },
            pairingTopic: c.pairingTopic,
            namespaces: Z5([...new Set(m)], [...new Set(y)]),
            transportType: u
          }),
            s.addTrace(_c.subscribing_authenticated_session_topic)
          try {
            await this.client.core.relayer.subscribe(A, { transportType: u })
          } catch (x) {
            throw (s.setError(Hf.subscribe_authenticated_session_topic_failure), x)
          }
          s.addTrace(_c.subscribe_authenticated_session_topic_success),
            await this.client.session.set(A, E),
            s.addTrace(_c.store_authenticated_session),
            await this.client.core.pairing.updateMetadata({
              topic: c.pairingTopic,
              metadata: c.requester.metadata
            })
        }
        s.addTrace(_c.publishing_authenticated_session_approve)
        try {
          await this.sendResult({
            topic: p,
            id: r,
            result: { cacaos: i, responder: { publicKey: d, metadata: this.client.metadata } },
            encodeOpts: g,
            throwOnFailedPublish: !0,
            appLink: this.getAppLinkIfEnabled(c.requester.metadata, u)
          })
        } catch (x) {
          throw (s.setError(Hf.authenticated_session_approve_publish_failure), x)
        }
        return (
          await this.client.auth.requests.delete(r, { message: 'fulfilled', code: 0 }),
          await this.client.core.pairing.activate({ topic: c.pairingTopic }),
          this.client.core.eventClient.deleteEvent({ eventId: s.eventId }),
          { session: E }
        )
      }),
      de(this, 'rejectSessionAuthenticate', async n => {
        this.isInitialized()
        const { id: r, reason: i } = n,
          s = this.getPendingAuthRequest(r)
        if (!s) throw new Error(`Could not find pending auth request with id ${r}`)
        s.transportType === hn.relay && (await this.confirmOnlineStateOrThrow())
        const c = s.requester.publicKey,
          u = await this.client.core.crypto.generateKeyPair(),
          f = Ig(c),
          d = { type: Oa, receiverPublicKey: c, senderPublicKey: u }
        await this.sendError({
          id: r,
          topic: f,
          error: i,
          encodeOpts: d,
          rpcOpts: sr.wc_sessionAuthenticate.reject,
          appLink: this.getAppLinkIfEnabled(s.requester.metadata, s.transportType)
        }),
          await this.client.auth.requests.delete(r, { message: 'rejected', code: 0 }),
          await this.client.proposal.delete(r, Qt('USER_DISCONNECTED'))
      }),
      de(this, 'formatAuthMessage', n => {
        this.isInitialized()
        const { request: r, iss: i } = n
        return Ix(r, i)
      }),
      de(this, 'processRelayMessageCache', () => {
        setTimeout(async () => {
          if (this.relayMessageCache.length !== 0)
            for (; this.relayMessageCache.length > 0; )
              try {
                const n = this.relayMessageCache.shift()
                n && (await this.onRelayMessage(n))
              } catch (n) {
                this.client.logger.error(n)
              }
        }, 50)
      }),
      de(this, 'cleanupDuplicatePairings', async n => {
        if (n.pairingTopic)
          try {
            const r = this.client.core.pairing.pairings.get(n.pairingTopic),
              i = this.client.core.pairing.pairings.getAll().filter(s => {
                var c, u
                return (
                  ((c = s.peerMetadata) == null ? void 0 : c.url) &&
                  ((u = s.peerMetadata) == null ? void 0 : u.url) === n.peer.metadata.url &&
                  s.topic &&
                  s.topic !== r.topic
                )
              })
            if (i.length === 0) return
            this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`),
              await Promise.all(
                i.map(s => this.client.core.pairing.disconnect({ topic: s.topic }))
              ),
              this.client.logger.info('Duplicate pairings clean up finished')
          } catch (r) {
            this.client.logger.error(r)
          }
      }),
      de(this, 'deleteSession', async n => {
        var r
        const { topic: i, expirerHasDeleted: s = !1, emitEvent: c = !0, id: u = 0 } = n,
          { self: f } = this.client.session.get(i)
        await this.client.core.relayer.unsubscribe(i),
          await this.client.session.delete(i, Qt('USER_DISCONNECTED')),
          this.addToRecentlyDeleted(i, 'session'),
          this.client.core.crypto.keychain.has(f.publicKey) &&
            (await this.client.core.crypto.deleteKeyPair(f.publicKey)),
          this.client.core.crypto.keychain.has(i) &&
            (await this.client.core.crypto.deleteSymKey(i)),
          s || this.client.core.expirer.del(i),
          this.client.core.storage.removeItem(k6).catch(d => this.client.logger.warn(d)),
          this.getPendingSessionRequests().forEach(d => {
            d.topic === i && this.deletePendingSessionRequest(d.id, Qt('USER_DISCONNECTED'))
          }),
          i === ((r = this.sessionRequestQueue.queue[0]) == null ? void 0 : r.topic) &&
            (this.sessionRequestQueue.state = Os.idle),
          c && this.client.events.emit('session_delete', { id: u, topic: i })
      }),
      de(this, 'deleteProposal', async (n, r) => {
        if (r)
          try {
            const i = this.client.proposal.get(n),
              s = this.client.core.eventClient.getEvent({ topic: i.pairingTopic })
            s == null || s.setError(Ac.proposal_expired)
          } catch {}
        await Promise.all([
          this.client.proposal.delete(n, Qt('USER_DISCONNECTED')),
          r ? Promise.resolve() : this.client.core.expirer.del(n)
        ]),
          this.addToRecentlyDeleted(n, 'proposal')
      }),
      de(this, 'deletePendingSessionRequest', async (n, r, i = !1) => {
        await Promise.all([
          this.client.pendingRequest.delete(n, r),
          i ? Promise.resolve() : this.client.core.expirer.del(n)
        ]),
          this.addToRecentlyDeleted(n, 'request'),
          (this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(s => s.id !== n)),
          i &&
            ((this.sessionRequestQueue.state = Os.idle),
            this.client.events.emit('session_request_expire', { id: n }))
      }),
      de(this, 'deletePendingAuthRequest', async (n, r, i = !1) => {
        await Promise.all([
          this.client.auth.requests.delete(n, r),
          i ? Promise.resolve() : this.client.core.expirer.del(n)
        ])
      }),
      de(this, 'setExpiry', async (n, r) => {
        this.client.session.keys.includes(n) &&
          (this.client.core.expirer.set(n, r), await this.client.session.update(n, { expiry: r }))
      }),
      de(this, 'setProposal', async (n, r) => {
        this.client.core.expirer.set(n, Zn(sr.wc_sessionPropose.req.ttl)),
          await this.client.proposal.set(n, r)
      }),
      de(this, 'setAuthRequest', async (n, r) => {
        const { request: i, pairingTopic: s, transportType: c = hn.relay } = r
        this.client.core.expirer.set(n, i.expiryTimestamp),
          await this.client.auth.requests.set(n, {
            authPayload: i.authPayload,
            requester: i.requester,
            expiryTimestamp: i.expiryTimestamp,
            id: n,
            pairingTopic: s,
            verifyContext: i.verifyContext,
            transportType: c
          })
      }),
      de(this, 'setPendingSessionRequest', async n => {
        const { id: r, topic: i, params: s, verifyContext: c } = n,
          u = s.request.expiryTimestamp || Zn(sr.wc_sessionRequest.req.ttl)
        this.client.core.expirer.set(r, u),
          await this.client.pendingRequest.set(r, { id: r, topic: i, params: s, verifyContext: c })
      }),
      de(this, 'sendRequest', async n => {
        const {
            topic: r,
            method: i,
            params: s,
            expiry: c,
            relayRpcId: u,
            clientRpcId: f,
            throwOnFailedPublish: d,
            appLink: p,
            tvf: g
          } = n,
          m = Uo(i, s, f)
        let y
        const A = !!p
        try {
          const O = A ? jf : ko
          y = await this.client.core.crypto.encode(r, m, { encoding: O })
        } catch (O) {
          throw (
            (await this.cleanup(),
            this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${r} failed`),
            O)
          )
        }
        let E
        if (QV.includes(i)) {
          const O = Fs(JSON.stringify(m)),
            I = Fs(y)
          E = await this.client.core.verify.register({ id: I, decryptedId: O })
        }
        const x = sr[i].req
        if (
          ((x.attestation = E),
          c && (x.ttl = c),
          u && (x.id = u),
          this.client.core.history.set(r, m),
          A)
        ) {
          const O = og(p, r, y)
          await global.Linking.openURL(O, this.client.name)
        } else {
          const O = sr[i].req
          c && (O.ttl = c),
            u && (O.id = u),
            (O.tvf = Ur(nn({}, g), { correlationId: m.id })),
            d
              ? ((O.internal = Ur(nn({}, O.internal), { throwOnFailedPublish: !0 })),
                await this.client.core.relayer.publish(r, y, O))
              : this.client.core.relayer.publish(r, y, O).catch(I => this.client.logger.error(I))
        }
        return m.id
      }),
      de(this, 'sendResult', async n => {
        const {
            id: r,
            topic: i,
            result: s,
            throwOnFailedPublish: c,
            encodeOpts: u,
            appLink: f
          } = n,
          d = Bm(r, s)
        let p
        const g = f && typeof (global == null ? void 0 : global.Linking) < 'u'
        try {
          const A = g ? jf : ko
          p = await this.client.core.crypto.encode(i, d, Ur(nn({}, u || {}), { encoding: A }))
        } catch (A) {
          throw (
            (await this.cleanup(),
            this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`),
            A)
          )
        }
        let m, y
        try {
          m = await this.client.core.history.get(i, r)
          const A = m.request
          try {
            this.shouldSetTVF(A.method, A.params) && (y = this.getTVFParams(r, A.params, s))
          } catch (E) {
            this.client.logger.warn('sendResult() -> getTVFParams() failed', E)
          }
        } catch (A) {
          throw (this.client.logger.error(`sendResult() -> history.get(${i}, ${r}) failed`), A)
        }
        if (g) {
          const A = og(f, i, p)
          await global.Linking.openURL(A, this.client.name)
        } else {
          const A = m.request.method,
            E = sr[A].res
          ;(E.tvf = Ur(nn({}, y), { correlationId: r })),
            c
              ? ((E.internal = Ur(nn({}, E.internal), { throwOnFailedPublish: !0 })),
                await this.client.core.relayer.publish(i, p, E))
              : this.client.core.relayer.publish(i, p, E).catch(x => this.client.logger.error(x))
        }
        await this.client.core.history.resolve(d)
      }),
      de(this, 'sendError', async n => {
        const { id: r, topic: i, error: s, encodeOpts: c, rpcOpts: u, appLink: f } = n,
          d = Lm(r, s)
        let p
        const g = f && typeof (global == null ? void 0 : global.Linking) < 'u'
        try {
          const y = g ? jf : ko
          p = await this.client.core.crypto.encode(i, d, Ur(nn({}, c || {}), { encoding: y }))
        } catch (y) {
          throw (
            (await this.cleanup(),
            this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`),
            y)
          )
        }
        let m
        try {
          m = await this.client.core.history.get(i, r)
        } catch (y) {
          throw (this.client.logger.error(`sendError() -> history.get(${i}, ${r}) failed`), y)
        }
        if (g) {
          const y = og(f, i, p)
          await global.Linking.openURL(y, this.client.name)
        } else {
          const y = m.request.method,
            A = u || sr[y].res
          this.client.core.relayer.publish(i, p, A)
        }
        await this.client.core.history.resolve(d)
      }),
      de(this, 'cleanup', async () => {
        const n = [],
          r = []
        this.client.session.getAll().forEach(i => {
          let s = !1
          Eo(i.expiry) && (s = !0),
            this.client.core.crypto.keychain.has(i.topic) || (s = !0),
            s && n.push(i.topic)
        }),
          this.client.proposal.getAll().forEach(i => {
            Eo(i.expiryTimestamp) && r.push(i.id)
          }),
          await Promise.all([
            ...n.map(i => this.deleteSession({ topic: i })),
            ...r.map(i => this.deleteProposal(i))
          ])
      }),
      de(this, 'onProviderMessageEvent', async n => {
        !this.initialized || this.relayMessageCache.length > 0
          ? this.relayMessageCache.push(n)
          : await this.onRelayMessage(n)
      }),
      de(this, 'onRelayEventRequest', async n => {
        this.requestQueue.queue.push(n), await this.processRequestsQueue()
      }),
      de(this, 'processRequestsQueue', async () => {
        if (this.requestQueue.state === Os.active) {
          this.client.logger.info('Request queue already active, skipping...')
          return
        }
        for (
          this.client.logger.info(
            `Request queue starting with ${this.requestQueue.queue.length} requests`
          );
          this.requestQueue.queue.length > 0;

        ) {
          this.requestQueue.state = Os.active
          const n = this.requestQueue.queue.shift()
          if (n)
            try {
              await this.processRequest(n)
            } catch (r) {
              this.client.logger.warn(r)
            }
        }
        this.requestQueue.state = Os.idle
      }),
      de(this, 'processRequest', async n => {
        const { topic: r, payload: i, attestation: s, transportType: c, encryptedId: u } = n,
          f = i.method
        if (!this.shouldIgnorePairingRequest({ topic: r, requestMethod: f }))
          switch (f) {
            case 'wc_sessionPropose':
              return await this.onSessionProposeRequest({
                topic: r,
                payload: i,
                attestation: s,
                encryptedId: u
              })
            case 'wc_sessionSettle':
              return await this.onSessionSettleRequest(r, i)
            case 'wc_sessionUpdate':
              return await this.onSessionUpdateRequest(r, i)
            case 'wc_sessionExtend':
              return await this.onSessionExtendRequest(r, i)
            case 'wc_sessionPing':
              return await this.onSessionPingRequest(r, i)
            case 'wc_sessionDelete':
              return await this.onSessionDeleteRequest(r, i)
            case 'wc_sessionRequest':
              return await this.onSessionRequest({
                topic: r,
                payload: i,
                attestation: s,
                encryptedId: u,
                transportType: c
              })
            case 'wc_sessionEvent':
              return await this.onSessionEventRequest(r, i)
            case 'wc_sessionAuthenticate':
              return await this.onSessionAuthenticateRequest({
                topic: r,
                payload: i,
                attestation: s,
                encryptedId: u,
                transportType: c
              })
            default:
              return this.client.logger.info(`Unsupported request method ${f}`)
          }
      }),
      de(this, 'onRelayEventResponse', async n => {
        const { topic: r, payload: i, transportType: s } = n,
          c = (await this.client.core.history.get(r, i.id)).request.method
        switch (c) {
          case 'wc_sessionPropose':
            return this.onSessionProposeResponse(r, i, s)
          case 'wc_sessionSettle':
            return this.onSessionSettleResponse(r, i)
          case 'wc_sessionUpdate':
            return this.onSessionUpdateResponse(r, i)
          case 'wc_sessionExtend':
            return this.onSessionExtendResponse(r, i)
          case 'wc_sessionPing':
            return this.onSessionPingResponse(r, i)
          case 'wc_sessionRequest':
            return this.onSessionRequestResponse(r, i)
          case 'wc_sessionAuthenticate':
            return this.onSessionAuthenticateResponse(r, i)
          default:
            return this.client.logger.info(`Unsupported response method ${c}`)
        }
      }),
      de(this, 'onRelayEventUnknownPayload', n => {
        const { topic: r } = n,
          { message: i } = me(
            'MISSING_OR_INVALID',
            `Decoded payload on topic ${r} is not identifiable as a JSON-RPC request or a response.`
          )
        throw new Error(i)
      }),
      de(this, 'shouldIgnorePairingRequest', n => {
        const { topic: r, requestMethod: i } = n,
          s = this.expectedPairingMethodMap.get(r)
        return !s || s.includes(i)
          ? !1
          : !!(
              s.includes('wc_sessionAuthenticate') &&
              this.client.events.listenerCount('session_authenticate') > 0
            )
      }),
      de(this, 'onSessionProposeRequest', async n => {
        const { topic: r, payload: i, attestation: s, encryptedId: c } = n,
          { params: u, id: f } = i
        try {
          const d = this.client.core.eventClient.getEvent({ topic: r })
          this.client.events.listenerCount('session_proposal') === 0 &&
            (console.warn('No listener for session_proposal event'),
            d == null || d.setError(Ca.proposal_listener_not_found)),
            this.isValidConnect(nn({}, i.params))
          const p = u.expiryTimestamp || Zn(sr.wc_sessionPropose.req.ttl),
            g = nn({ id: f, pairingTopic: r, expiryTimestamp: p }, u)
          await this.setProposal(f, g)
          const m = await this.getVerifyContext({
            attestationId: s,
            hash: Fs(JSON.stringify(i)),
            encryptedId: c,
            metadata: g.proposer.metadata
          })
          d == null || d.addTrace(Ds.emit_session_proposal),
            this.client.events.emit('session_proposal', { id: f, params: g, verifyContext: m })
        } catch (d) {
          await this.sendError({
            id: f,
            topic: r,
            error: d,
            rpcOpts: sr.wc_sessionPropose.autoReject
          }),
            this.client.logger.error(d)
        }
      }),
      de(this, 'onSessionProposeResponse', async (n, r, i) => {
        const { id: s } = r
        if (Ms(r)) {
          const { result: c } = r
          this.client.logger.trace({
            type: 'method',
            method: 'onSessionProposeResponse',
            result: c
          })
          const u = this.client.proposal.get(s)
          this.client.logger.trace({
            type: 'method',
            method: 'onSessionProposeResponse',
            proposal: u
          })
          const f = u.proposer.publicKey
          this.client.logger.trace({
            type: 'method',
            method: 'onSessionProposeResponse',
            selfPublicKey: f
          })
          const d = c.responderPublicKey
          this.client.logger.trace({
            type: 'method',
            method: 'onSessionProposeResponse',
            peerPublicKey: d
          })
          const p = await this.client.core.crypto.generateSharedKey(f, d)
          this.pendingSessions.set(s, {
            sessionTopic: p,
            pairingTopic: n,
            proposalId: s,
            publicKey: f
          })
          const g = await this.client.core.relayer.subscribe(p, { transportType: i })
          this.client.logger.trace({
            type: 'method',
            method: 'onSessionProposeResponse',
            subscriptionId: g
          }),
            await this.client.core.pairing.activate({ topic: n })
        } else if (Li(r)) {
          await this.client.proposal.delete(s, Qt('USER_DISCONNECTED'))
          const c = Pt('session_connect', s)
          if (this.events.listenerCount(c) === 0)
            throw new Error(`emitting ${c} without any listeners, 954`)
          this.events.emit(c, { error: r.error })
        }
      }),
      de(this, 'onSessionSettleRequest', async (n, r) => {
        const { id: i, params: s } = r
        try {
          this.isValidSessionSettleRequest(s)
          const {
              relay: c,
              controller: u,
              expiry: f,
              namespaces: d,
              sessionProperties: p,
              scopedProperties: g,
              sessionConfig: m
            } = r.params,
            y = [...this.pendingSessions.values()].find(x => x.sessionTopic === n)
          if (!y) return this.client.logger.error(`Pending session not found for topic ${n}`)
          const A = this.client.proposal.get(y.proposalId),
            E = Ur(
              nn(
                nn(
                  nn(
                    {
                      topic: n,
                      relay: c,
                      expiry: f,
                      namespaces: d,
                      acknowledged: !0,
                      pairingTopic: y.pairingTopic,
                      requiredNamespaces: A.requiredNamespaces,
                      optionalNamespaces: A.optionalNamespaces,
                      controller: u.publicKey,
                      self: { publicKey: y.publicKey, metadata: this.client.metadata },
                      peer: { publicKey: u.publicKey, metadata: u.metadata }
                    },
                    p && { sessionProperties: p }
                  ),
                  g && { scopedProperties: g }
                ),
                m && { sessionConfig: m }
              ),
              { transportType: hn.relay }
            )
          await this.client.session.set(E.topic, E),
            await this.setExpiry(E.topic, E.expiry),
            await this.client.core.pairing.updateMetadata({
              topic: y.pairingTopic,
              metadata: E.peer.metadata
            }),
            this.client.events.emit('session_connect', { session: E }),
            this.events.emit(Pt('session_connect', y.proposalId), { session: E }),
            this.pendingSessions.delete(y.proposalId),
            this.deleteProposal(y.proposalId, !1),
            this.cleanupDuplicatePairings(E),
            await this.sendResult({ id: r.id, topic: n, result: !0, throwOnFailedPublish: !0 })
        } catch (c) {
          await this.sendError({ id: i, topic: n, error: c }), this.client.logger.error(c)
        }
      }),
      de(this, 'onSessionSettleResponse', async (n, r) => {
        const { id: i } = r
        Ms(r)
          ? (await this.client.session.update(n, { acknowledged: !0 }),
            this.events.emit(Pt('session_approve', i), {}))
          : Li(r) &&
            (await this.client.session.delete(n, Qt('USER_DISCONNECTED')),
            this.events.emit(Pt('session_approve', i), { error: r.error }))
      }),
      de(this, 'onSessionUpdateRequest', async (n, r) => {
        const { params: i, id: s } = r
        try {
          const c = `${n}_session_update`,
            u = zf.get(c)
          if (u && this.isRequestOutOfSync(u, s)) {
            this.client.logger.warn(`Discarding out of sync request - ${s}`),
              this.sendError({ id: s, topic: n, error: Qt('INVALID_UPDATE_REQUEST') })
            return
          }
          this.isValidUpdate(nn({ topic: n }, i))
          try {
            zf.set(c, s),
              await this.client.session.update(n, { namespaces: i.namespaces }),
              await this.sendResult({ id: s, topic: n, result: !0, throwOnFailedPublish: !0 })
          } catch (f) {
            throw (zf.delete(c), f)
          }
          this.client.events.emit('session_update', { id: s, topic: n, params: i })
        } catch (c) {
          await this.sendError({ id: s, topic: n, error: c }), this.client.logger.error(c)
        }
      }),
      de(
        this,
        'isRequestOutOfSync',
        (n, r) => r.toString().slice(0, -3) < n.toString().slice(0, -3)
      ),
      de(this, 'onSessionUpdateResponse', (n, r) => {
        const { id: i } = r,
          s = Pt('session_update', i)
        if (this.events.listenerCount(s) === 0)
          throw new Error(`emitting ${s} without any listeners`)
        Ms(r)
          ? this.events.emit(Pt('session_update', i), {})
          : Li(r) && this.events.emit(Pt('session_update', i), { error: r.error })
      }),
      de(this, 'onSessionExtendRequest', async (n, r) => {
        const { id: i } = r
        try {
          this.isValidExtend({ topic: n }),
            await this.setExpiry(n, Zn(fl)),
            await this.sendResult({ id: i, topic: n, result: !0, throwOnFailedPublish: !0 }),
            this.client.events.emit('session_extend', { id: i, topic: n })
        } catch (s) {
          await this.sendError({ id: i, topic: n, error: s }), this.client.logger.error(s)
        }
      }),
      de(this, 'onSessionExtendResponse', (n, r) => {
        const { id: i } = r,
          s = Pt('session_extend', i)
        if (this.events.listenerCount(s) === 0)
          throw new Error(`emitting ${s} without any listeners`)
        Ms(r)
          ? this.events.emit(Pt('session_extend', i), {})
          : Li(r) && this.events.emit(Pt('session_extend', i), { error: r.error })
      }),
      de(this, 'onSessionPingRequest', async (n, r) => {
        const { id: i } = r
        try {
          this.isValidPing({ topic: n }),
            await this.sendResult({ id: i, topic: n, result: !0, throwOnFailedPublish: !0 }),
            this.client.events.emit('session_ping', { id: i, topic: n })
        } catch (s) {
          await this.sendError({ id: i, topic: n, error: s }), this.client.logger.error(s)
        }
      }),
      de(this, 'onSessionPingResponse', (n, r) => {
        const { id: i } = r,
          s = Pt('session_ping', i)
        setTimeout(() => {
          if (this.events.listenerCount(s) === 0)
            throw new Error(`emitting ${s} without any listeners 2176`)
          Ms(r)
            ? this.events.emit(Pt('session_ping', i), {})
            : Li(r) && this.events.emit(Pt('session_ping', i), { error: r.error })
        }, 500)
      }),
      de(this, 'onSessionDeleteRequest', async (n, r) => {
        const { id: i } = r
        try {
          this.isValidDisconnect({ topic: n, reason: r.params }),
            Promise.all([
              new Promise(s => {
                this.client.core.relayer.once(or.publish, async () => {
                  s(await this.deleteSession({ topic: n, id: i }))
                })
              }),
              this.sendResult({ id: i, topic: n, result: !0, throwOnFailedPublish: !0 }),
              this.cleanupPendingSentRequestsForTopic({ topic: n, error: Qt('USER_DISCONNECTED') })
            ]).catch(s => this.client.logger.error(s))
        } catch (s) {
          this.client.logger.error(s)
        }
      }),
      de(this, 'onSessionRequest', async n => {
        var r, i, s
        const { topic: c, payload: u, attestation: f, encryptedId: d, transportType: p } = n,
          { id: g, params: m } = u
        try {
          await this.isValidRequest(nn({ topic: c }, m))
          const y = this.client.session.get(c),
            A = await this.getVerifyContext({
              attestationId: f,
              hash: Fs(JSON.stringify(Uo('wc_sessionRequest', m, g))),
              encryptedId: d,
              metadata: y.peer.metadata,
              transportType: p
            }),
            E = { id: g, topic: c, params: m, verifyContext: A }
          await this.setPendingSessionRequest(E),
            p === hn.link_mode &&
              (r = y.peer.metadata.redirect) != null &&
              r.universal &&
              this.client.core.addLinkModeSupportedApp(
                (i = y.peer.metadata.redirect) == null ? void 0 : i.universal
              ),
            (s = this.client.signConfig) != null && s.disableRequestQueue
              ? this.emitSessionRequest(E)
              : (this.addSessionRequestToSessionRequestQueue(E), this.processSessionRequestQueue())
        } catch (y) {
          await this.sendError({ id: g, topic: c, error: y }), this.client.logger.error(y)
        }
      }),
      de(this, 'onSessionRequestResponse', (n, r) => {
        const { id: i } = r,
          s = Pt('session_request', i)
        if (this.events.listenerCount(s) === 0)
          throw new Error(`emitting ${s} without any listeners`)
        Ms(r)
          ? this.events.emit(Pt('session_request', i), { result: r.result })
          : Li(r) && this.events.emit(Pt('session_request', i), { error: r.error })
      }),
      de(this, 'onSessionEventRequest', async (n, r) => {
        const { id: i, params: s } = r
        try {
          const c = `${n}_session_event_${s.event.name}`,
            u = zf.get(c)
          if (u && this.isRequestOutOfSync(u, i)) {
            this.client.logger.info(`Discarding out of sync request - ${i}`)
            return
          }
          this.isValidEmit(nn({ topic: n }, s)),
            this.client.events.emit('session_event', { id: i, topic: n, params: s }),
            zf.set(c, i)
        } catch (c) {
          await this.sendError({ id: i, topic: n, error: c }), this.client.logger.error(c)
        }
      }),
      de(this, 'onSessionAuthenticateResponse', (n, r) => {
        const { id: i } = r
        this.client.logger.trace({
          type: 'method',
          method: 'onSessionAuthenticateResponse',
          topic: n,
          payload: r
        }),
          Ms(r)
            ? this.events.emit(Pt('session_request', i), { result: r.result })
            : Li(r) && this.events.emit(Pt('session_request', i), { error: r.error })
      }),
      de(this, 'onSessionAuthenticateRequest', async n => {
        var r
        const { topic: i, payload: s, attestation: c, encryptedId: u, transportType: f } = n
        try {
          const { requester: d, authPayload: p, expiryTimestamp: g } = s.params,
            m = await this.getVerifyContext({
              attestationId: c,
              hash: Fs(JSON.stringify(s)),
              encryptedId: u,
              metadata: d.metadata,
              transportType: f
            }),
            y = {
              requester: d,
              pairingTopic: i,
              id: s.id,
              authPayload: p,
              verifyContext: m,
              expiryTimestamp: g
            }
          await this.setAuthRequest(s.id, { request: y, pairingTopic: i, transportType: f }),
            f === hn.link_mode &&
              (r = d.metadata.redirect) != null &&
              r.universal &&
              this.client.core.addLinkModeSupportedApp(d.metadata.redirect.universal),
            this.client.events.emit('session_authenticate', {
              topic: i,
              params: s.params,
              id: s.id,
              verifyContext: m
            })
        } catch (d) {
          this.client.logger.error(d)
          const p = s.params.requester.publicKey,
            g = await this.client.core.crypto.generateKeyPair(),
            m = this.getAppLinkIfEnabled(s.params.requester.metadata, f),
            y = { type: Oa, receiverPublicKey: p, senderPublicKey: g }
          await this.sendError({
            id: s.id,
            topic: i,
            error: d,
            encodeOpts: y,
            rpcOpts: sr.wc_sessionAuthenticate.autoReject,
            appLink: m
          })
        }
      }),
      de(this, 'addSessionRequestToSessionRequestQueue', n => {
        this.sessionRequestQueue.queue.push(n)
      }),
      de(this, 'cleanupAfterResponse', n => {
        this.deletePendingSessionRequest(n.response.id, { message: 'fulfilled', code: 0 }),
          setTimeout(() => {
            ;(this.sessionRequestQueue.state = Os.idle), this.processSessionRequestQueue()
          }, ge.toMiliseconds(this.requestQueueDelay))
      }),
      de(this, 'cleanupPendingSentRequestsForTopic', ({ topic: n, error: r }) => {
        const i = this.client.core.history.pending
        i.length > 0 &&
          i
            .filter(s => s.topic === n && s.request.method === 'wc_sessionRequest')
            .forEach(s => {
              const c = s.request.id,
                u = Pt('session_request', c)
              if (this.events.listenerCount(u) === 0)
                throw new Error(`emitting ${u} without any listeners`)
              this.events.emit(Pt('session_request', s.request.id), { error: r })
            })
      }),
      de(this, 'processSessionRequestQueue', () => {
        if (this.sessionRequestQueue.state === Os.active) {
          this.client.logger.info('session request queue is already active.')
          return
        }
        const n = this.sessionRequestQueue.queue[0]
        if (!n) {
          this.client.logger.info('session request queue is empty.')
          return
        }
        try {
          ;(this.sessionRequestQueue.state = Os.active), this.emitSessionRequest(n)
        } catch (r) {
          this.client.logger.error(r)
        }
      }),
      de(this, 'emitSessionRequest', n => {
        this.client.events.emit('session_request', n)
      }),
      de(this, 'onPairingCreated', n => {
        if ((n.methods && this.expectedPairingMethodMap.set(n.topic, n.methods), n.active)) return
        const r = this.client.proposal.getAll().find(i => i.pairingTopic === n.topic)
        r &&
          this.onSessionProposeRequest({
            topic: n.topic,
            payload: Uo(
              'wc_sessionPropose',
              Ur(nn({}, r), {
                requiredNamespaces: r.requiredNamespaces,
                optionalNamespaces: r.optionalNamespaces,
                relays: r.relays,
                proposer: r.proposer,
                sessionProperties: r.sessionProperties,
                scopedProperties: r.scopedProperties
              }),
              r.id
            )
          })
      }),
      de(this, 'isValidConnect', async n => {
        if (!Zr(n)) {
          const { message: d } = me('MISSING_OR_INVALID', `connect() params: ${JSON.stringify(n)}`)
          throw new Error(d)
        }
        const {
          pairingTopic: r,
          requiredNamespaces: i,
          optionalNamespaces: s,
          sessionProperties: c,
          scopedProperties: u,
          relays: f
        } = n
        if ((vr(r) || (await this.isValidPairingTopic(r)), !_z(f))) {
          const { message: d } = me('MISSING_OR_INVALID', `connect() relays: ${f}`)
          throw new Error(d)
        }
        if (
          (!vr(i) && Ch(i) !== 0 && this.validateNamespaces(i, 'requiredNamespaces'),
          !vr(s) && Ch(s) !== 0 && this.validateNamespaces(s, 'optionalNamespaces'),
          vr(c) || this.validateSessionProps(c, 'sessionProperties'),
          !vr(u))
        ) {
          this.validateSessionProps(u, 'scopedProperties')
          const d = Object.keys(i || {}).concat(Object.keys(s || {}))
          if (!Object.keys(u).every(p => d.includes(p)))
            throw new Error(
              `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(u)}, required/optional namespaces: ${JSON.stringify(d)}`
            )
        }
      }),
      de(this, 'validateNamespaces', (n, r) => {
        const i = Az(n, 'connect()', r)
        if (i) throw new Error(i.message)
      }),
      de(this, 'isValidApprove', async n => {
        if (!Zr(n)) throw new Error(me('MISSING_OR_INVALID', `approve() params: ${n}`).message)
        const {
          id: r,
          namespaces: i,
          relayProtocol: s,
          sessionProperties: c,
          scopedProperties: u
        } = n
        this.checkRecentlyDeleted(r), await this.isValidProposalId(r)
        const f = this.client.proposal.get(r),
          d = g1(i, 'approve()')
        if (d) throw new Error(d.message)
        const p = e6(f.requiredNamespaces, i, 'approve()')
        if (p) throw new Error(p.message)
        if (!Vn(s, !0)) {
          const { message: g } = me('MISSING_OR_INVALID', `approve() relayProtocol: ${s}`)
          throw new Error(g)
        }
        if ((vr(c) || this.validateSessionProps(c, 'sessionProperties'), !vr(u))) {
          this.validateSessionProps(u, 'scopedProperties')
          const g = new Set(Object.keys(i))
          if (!Object.keys(u).every(m => g.has(m)))
            throw new Error(
              `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(u)}, approved namespaces: ${Array.from(g).join(', ')}`
            )
        }
      }),
      de(this, 'isValidReject', async n => {
        if (!Zr(n)) {
          const { message: s } = me('MISSING_OR_INVALID', `reject() params: ${n}`)
          throw new Error(s)
        }
        const { id: r, reason: i } = n
        if ((this.checkRecentlyDeleted(r), await this.isValidProposalId(r), !Sz(i))) {
          const { message: s } = me('MISSING_OR_INVALID', `reject() reason: ${JSON.stringify(i)}`)
          throw new Error(s)
        }
      }),
      de(this, 'isValidSessionSettleRequest', n => {
        if (!Zr(n)) {
          const { message: d } = me('MISSING_OR_INVALID', `onSessionSettleRequest() params: ${n}`)
          throw new Error(d)
        }
        const { relay: r, controller: i, namespaces: s, expiry: c } = n
        if (!Vx(r)) {
          const { message: d } = me(
            'MISSING_OR_INVALID',
            'onSessionSettleRequest() relay protocol should be a string'
          )
          throw new Error(d)
        }
        const u = mz(i, 'onSessionSettleRequest()')
        if (u) throw new Error(u.message)
        const f = g1(s, 'onSessionSettleRequest()')
        if (f) throw new Error(f.message)
        if (Eo(c)) {
          const { message: d } = me('EXPIRED', 'onSessionSettleRequest()')
          throw new Error(d)
        }
      }),
      de(this, 'isValidUpdate', async n => {
        if (!Zr(n)) {
          const { message: f } = me('MISSING_OR_INVALID', `update() params: ${n}`)
          throw new Error(f)
        }
        const { topic: r, namespaces: i } = n
        this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r)
        const s = this.client.session.get(r),
          c = g1(i, 'update()')
        if (c) throw new Error(c.message)
        const u = e6(s.requiredNamespaces, i, 'update()')
        if (u) throw new Error(u.message)
      }),
      de(this, 'isValidExtend', async n => {
        if (!Zr(n)) {
          const { message: i } = me('MISSING_OR_INVALID', `extend() params: ${n}`)
          throw new Error(i)
        }
        const { topic: r } = n
        this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r)
      }),
      de(this, 'isValidRequest', async n => {
        if (!Zr(n)) {
          const { message: f } = me('MISSING_OR_INVALID', `request() params: ${n}`)
          throw new Error(f)
        }
        const { topic: r, request: i, chainId: s, expiry: c } = n
        this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r)
        const { namespaces: u } = this.client.session.get(r)
        if (!J5(u, s)) {
          const { message: f } = me('MISSING_OR_INVALID', `request() chainId: ${s}`)
          throw new Error(f)
        }
        if (!Tz(i)) {
          const { message: f } = me('MISSING_OR_INVALID', `request() ${JSON.stringify(i)}`)
          throw new Error(f)
        }
        if (!Iz(u, s, i.method)) {
          const { message: f } = me('MISSING_OR_INVALID', `request() method: ${i.method}`)
          throw new Error(f)
        }
        if (c && !Pz(c, _1)) {
          const { message: f } = me(
            'MISSING_OR_INVALID',
            `request() expiry: ${c}. Expiry must be a number (in seconds) between ${_1.min} and ${_1.max}`
          )
          throw new Error(f)
        }
      }),
      de(this, 'isValidRespond', async n => {
        var r
        if (!Zr(n)) {
          const { message: c } = me('MISSING_OR_INVALID', `respond() params: ${n}`)
          throw new Error(c)
        }
        const { topic: i, response: s } = n
        try {
          await this.isValidSessionTopic(i)
        } catch (c) {
          throw (
            ((r = n == null ? void 0 : n.response) != null && r.id && this.cleanupAfterResponse(n),
            c)
          )
        }
        if (!xz(s)) {
          const { message: c } = me(
            'MISSING_OR_INVALID',
            `respond() response: ${JSON.stringify(s)}`
          )
          throw new Error(c)
        }
      }),
      de(this, 'isValidPing', async n => {
        if (!Zr(n)) {
          const { message: i } = me('MISSING_OR_INVALID', `ping() params: ${n}`)
          throw new Error(i)
        }
        const { topic: r } = n
        await this.isValidSessionOrPairingTopic(r)
      }),
      de(this, 'isValidEmit', async n => {
        if (!Zr(n)) {
          const { message: u } = me('MISSING_OR_INVALID', `emit() params: ${n}`)
          throw new Error(u)
        }
        const { topic: r, event: i, chainId: s } = n
        await this.isValidSessionTopic(r)
        const { namespaces: c } = this.client.session.get(r)
        if (!J5(c, s)) {
          const { message: u } = me('MISSING_OR_INVALID', `emit() chainId: ${s}`)
          throw new Error(u)
        }
        if (!Nz(i)) {
          const { message: u } = me('MISSING_OR_INVALID', `emit() event: ${JSON.stringify(i)}`)
          throw new Error(u)
        }
        if (!Oz(c, s, i.name)) {
          const { message: u } = me('MISSING_OR_INVALID', `emit() event: ${JSON.stringify(i)}`)
          throw new Error(u)
        }
      }),
      de(this, 'isValidDisconnect', async n => {
        if (!Zr(n)) {
          const { message: i } = me('MISSING_OR_INVALID', `disconnect() params: ${n}`)
          throw new Error(i)
        }
        const { topic: r } = n
        await this.isValidSessionOrPairingTopic(r)
      }),
      de(this, 'isValidAuthenticate', n => {
        const { chains: r, uri: i, domain: s, nonce: c } = n
        if (!Array.isArray(r) || r.length === 0)
          throw new Error('chains is required and must be a non-empty array')
        if (!Vn(i, !1)) throw new Error('uri is required parameter')
        if (!Vn(s, !1)) throw new Error('domain is required parameter')
        if (!Vn(c, !1)) throw new Error('nonce is required parameter')
        if ([...new Set(r.map(f => Ml(f).namespace))].length > 1)
          throw new Error(
            'Multi-namespace requests are not supported. Please request single namespace only.'
          )
        const { namespace: u } = Ml(r[0])
        if (u !== 'eip155')
          throw new Error(
            'Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.'
          )
      }),
      de(this, 'getVerifyContext', async n => {
        const { attestationId: r, hash: i, encryptedId: s, metadata: c, transportType: u } = n,
          f = {
            verified: { verifyUrl: c.verifyUrl || lh, validation: 'UNKNOWN', origin: c.url || '' }
          }
        try {
          if (u === hn.link_mode) {
            const p = this.getAppLinkIfEnabled(c, u)
            return (
              (f.verified.validation =
                p && new URL(p).origin === new URL(c.url).origin ? 'VALID' : 'INVALID'),
              f
            )
          }
          const d = await this.client.core.verify.resolve({
            attestationId: r,
            hash: i,
            encryptedId: s,
            verifyUrl: c.verifyUrl
          })
          d &&
            ((f.verified.origin = d.origin),
            (f.verified.isScam = d.isScam),
            (f.verified.validation = d.origin === new URL(c.url).origin ? 'VALID' : 'INVALID'))
        } catch (d) {
          this.client.logger.warn(d)
        }
        return this.client.logger.debug(`Verify context: ${JSON.stringify(f)}`), f
      }),
      de(this, 'validateSessionProps', (n, r) => {
        Object.values(n).forEach((i, s) => {
          if (i == null) {
            const { message: c } = me(
              'MISSING_OR_INVALID',
              `${r} must contain an existing value for each key. Received: ${i} for key ${Object.keys(n)[s]}`
            )
            throw new Error(c)
          }
        })
      }),
      de(this, 'getPendingAuthRequest', n => {
        const r = this.client.auth.requests.get(n)
        return typeof r == 'object' ? r : void 0
      }),
      de(this, 'addToRecentlyDeleted', (n, r) => {
        if (
          (this.recentlyDeletedMap.set(n, r),
          this.recentlyDeletedMap.size >= this.recentlyDeletedLimit)
        ) {
          let i = 0
          const s = this.recentlyDeletedLimit / 2
          for (const c of this.recentlyDeletedMap.keys()) {
            if (i++ >= s) break
            this.recentlyDeletedMap.delete(c)
          }
        }
      }),
      de(this, 'checkRecentlyDeleted', n => {
        const r = this.recentlyDeletedMap.get(n)
        if (r) {
          const { message: i } = me(
            'MISSING_OR_INVALID',
            `Record was recently deleted - ${r}: ${n}`
          )
          throw new Error(i)
        }
      }),
      de(this, 'isLinkModeEnabled', (n, r) => {
        var i, s, c, u, f, d, p, g, m
        return !n || r !== hn.link_mode
          ? !1
          : ((s = (i = this.client.metadata) == null ? void 0 : i.redirect) == null
              ? void 0
              : s.linkMode) === !0 &&
              ((u = (c = this.client.metadata) == null ? void 0 : c.redirect) == null
                ? void 0
                : u.universal) !== void 0 &&
              ((d = (f = this.client.metadata) == null ? void 0 : f.redirect) == null
                ? void 0
                : d.universal) !== '' &&
              ((p = n == null ? void 0 : n.redirect) == null ? void 0 : p.universal) !== void 0 &&
              ((g = n == null ? void 0 : n.redirect) == null ? void 0 : g.universal) !== '' &&
              ((m = n == null ? void 0 : n.redirect) == null ? void 0 : m.linkMode) === !0 &&
              this.client.core.linkModeSupportedApps.includes(n.redirect.universal) &&
              typeof (global == null ? void 0 : global.Linking) < 'u'
      }),
      de(this, 'getAppLinkIfEnabled', (n, r) => {
        var i
        return this.isLinkModeEnabled(n, r)
          ? (i = n == null ? void 0 : n.redirect) == null
            ? void 0
            : i.universal
          : void 0
      }),
      de(this, 'handleLinkModeMessage', ({ url: n }) => {
        if (!n || !n.includes('wc_ev') || !n.includes('topic')) return
        const r = E5(n, 'topic') || '',
          i = decodeURIComponent(E5(n, 'wc_ev') || ''),
          s = this.client.session.keys.includes(r)
        s && this.client.session.update(r, { transportType: hn.link_mode }),
          this.client.core.dispatchEnvelope({ topic: r, message: i, sessionExists: s })
      }),
      de(this, 'registerLinkModeListeners', async () => {
        var n
        if (JE() || (Yo() && (n = this.client.metadata.redirect) != null && n.linkMode)) {
          const r = global == null ? void 0 : global.Linking
          if (typeof r < 'u') {
            r.addEventListener('url', this.handleLinkModeMessage, this.client.name)
            const i = await r.getInitialURL()
            i &&
              setTimeout(() => {
                this.handleLinkModeMessage({ url: i })
              }, 50)
          }
        }
      }),
      de(this, 'shouldSetTVF', (n, r) => {
        if (!r || n !== 'wc_sessionRequest') return !1
        const { request: i } = r
        return Object.keys(B6).includes(i.method)
      }),
      de(this, 'getTVFParams', (n, r, i) => {
        var s, c
        try {
          const u = r.request.method,
            f = this.extractTxHashesFromResult(u, i)
          return Ur(
            nn(
              { correlationId: n, rpcMethods: [u], chainId: r.chainId },
              this.isValidContractData(r.request.params) && {
                contractAddresses: [
                  (c = (s = r.request.params) == null ? void 0 : s[0]) == null ? void 0 : c.to
                ]
              }
            ),
            { txHashes: f }
          )
        } catch (u) {
          this.client.logger.warn('Error getting TVF params', u)
        }
        return {}
      }),
      de(this, 'isValidContractData', n => {
        var r
        if (!n) return !1
        try {
          const i =
            (n == null ? void 0 : n.data) ||
            ((r = n == null ? void 0 : n[0]) == null ? void 0 : r.data)
          if (!i.startsWith('0x')) return !1
          const s = i.slice(2)
          return /^[0-9a-fA-F]*$/.test(s) ? s.length % 2 === 0 : !1
        } catch {}
        return !1
      }),
      de(this, 'extractTxHashesFromResult', (n, r) => {
        try {
          const i = B6[n]
          if (typeof r == 'string') return [r]
          const s = r[i.key]
          if (ru(s)) return n === 'solana_signAllTransactions' ? s.map(c => OF(c)) : s
          if (typeof s == 'string') return [s]
        } catch (i) {
          this.client.logger.warn('Error extracting tx hashes from result', i)
        }
        return []
      })
  }
  async processPendingMessageEvents() {
    try {
      const e = this.client.session.keys,
        n = this.client.core.relayer.messages.getWithoutAck(e)
      for (const [r, i] of Object.entries(n))
        for (const s of i)
          try {
            await this.onProviderMessageEvent({ topic: r, message: s, publishedAt: Date.now() })
          } catch {
            this.client.logger.warn(
              `Error processing pending message event for topic: ${r}, message: ${s}`
            )
          }
    } catch (e) {
      this.client.logger.warn('processPendingMessageEvents failed', e)
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = me('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow()
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(or.message, e => {
      this.onProviderMessageEvent(e)
    })
  }
  async onRelayMessage(e) {
    const { topic: n, message: r, attestation: i, transportType: s } = e,
      { publicKey: c } = this.client.auth.authKeys.keys.includes(Rg)
        ? this.client.auth.authKeys.get(Rg)
        : { publicKey: void 0 }
    try {
      const u = await this.client.core.crypto.decode(n, r, {
        receiverPublicKey: c,
        encoding: s === hn.link_mode ? jf : ko
      })
      u2(u)
        ? (this.client.core.history.set(n, u),
          await this.onRelayEventRequest({
            topic: n,
            payload: u,
            attestation: i,
            transportType: s,
            encryptedId: Fs(r)
          }))
        : $m(u)
          ? (await this.client.core.history.resolve(u),
            await this.onRelayEventResponse({ topic: n, payload: u, transportType: s }),
            this.client.core.history.delete(n, u.id))
          : await this.onRelayEventUnknownPayload({ topic: n, payload: u, transportType: s }),
        await this.client.core.relayer.messages.ack(n, r)
    } catch (u) {
      this.client.logger.error(u)
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(Ui.expired, async e => {
      const { topic: n, id: r } = wx(e.target)
      if (r && this.client.pendingRequest.keys.includes(r))
        return await this.deletePendingSessionRequest(r, me('EXPIRED'), !0)
      if (r && this.client.auth.requests.keys.includes(r))
        return await this.deletePendingAuthRequest(r, me('EXPIRED'), !0)
      n
        ? this.client.session.keys.includes(n) &&
          (await this.deleteSession({ topic: n, expirerHasDeleted: !0 }),
          this.client.events.emit('session_expire', { topic: n }))
        : r &&
          (await this.deleteProposal(r, !0), this.client.events.emit('proposal_expire', { id: r }))
    })
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(Ic.create, e => this.onPairingCreated(e)),
      this.client.core.pairing.events.on(Ic.delete, e => {
        this.addToRecentlyDeleted(e.topic, 'pairing')
      })
  }
  isValidPairingTopic(e) {
    if (!Vn(e, !1)) {
      const { message: n } = me('MISSING_OR_INVALID', `pairing topic should be a string: ${e}`)
      throw new Error(n)
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: n } = me('NO_MATCHING_KEY', `pairing topic doesn't exist: ${e}`)
      throw new Error(n)
    }
    if (Eo(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: n } = me('EXPIRED', `pairing topic: ${e}`)
      throw new Error(n)
    }
  }
  async isValidSessionTopic(e) {
    if (!Vn(e, !1)) {
      const { message: n } = me('MISSING_OR_INVALID', `session topic should be a string: ${e}`)
      throw new Error(n)
    }
    if ((this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e))) {
      const { message: n } = me('NO_MATCHING_KEY', `session topic doesn't exist: ${e}`)
      throw new Error(n)
    }
    if (Eo(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e })
      const { message: n } = me('EXPIRED', `session topic: ${e}`)
      throw new Error(n)
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: n } = me(
        'MISSING_OR_INVALID',
        `session topic does not exist in keychain: ${e}`
      )
      throw (await this.deleteSession({ topic: e }), new Error(n))
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if ((this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)))
      await this.isValidSessionTopic(e)
    else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e)
    else if (Vn(e, !1)) {
      const { message: n } = me('NO_MATCHING_KEY', `session or pairing topic doesn't exist: ${e}`)
      throw new Error(n)
    } else {
      const { message: n } = me(
        'MISSING_OR_INVALID',
        `session or pairing topic should be a string: ${e}`
      )
      throw new Error(n)
    }
  }
  async isValidProposalId(e) {
    if (!Cz(e)) {
      const { message: n } = me('MISSING_OR_INVALID', `proposal id should be a number: ${e}`)
      throw new Error(n)
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: n } = me('NO_MATCHING_KEY', `proposal id doesn't exist: ${e}`)
      throw new Error(n)
    }
    if (Eo(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e)
      const { message: n } = me('EXPIRED', `proposal id: ${e}`)
      throw new Error(n)
    }
  }
}
class oK extends Eu {
  constructor(e, n) {
    super(e, n, GV, l2), (this.core = e), (this.logger = n)
  }
}
let cK = class extends Eu {
  constructor(e, n) {
    super(e, n, VV, l2), (this.core = e), (this.logger = n)
  }
}
class uK extends Eu {
  constructor(e, n) {
    super(e, n, WV, l2, r => r.id), (this.core = e), (this.logger = n)
  }
}
class lK extends Eu {
  constructor(e, n) {
    super(e, n, XV, jm, () => Rg), (this.core = e), (this.logger = n)
  }
}
class dK extends Eu {
  constructor(e, n) {
    super(e, n, JV, jm), (this.core = e), (this.logger = n)
  }
}
class fK extends Eu {
  constructor(e, n) {
    super(e, n, eK, jm, r => r.id), (this.core = e), (this.logger = n)
  }
}
var hK = Object.defineProperty,
  pK = (t, e, n) =>
    e in t ? hK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  C1 = (t, e, n) => pK(t, typeof e != 'symbol' ? e + '' : e, n)
class gK {
  constructor(e, n) {
    ;(this.core = e),
      (this.logger = n),
      C1(this, 'authKeys'),
      C1(this, 'pairingTopics'),
      C1(this, 'requests'),
      (this.authKeys = new lK(this.core, this.logger)),
      (this.pairingTopics = new dK(this.core, this.logger)),
      (this.requests = new fK(this.core, this.logger))
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init()
  }
}
var mK = Object.defineProperty,
  bK = (t, e, n) =>
    e in t ? mK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  ht = (t, e, n) => bK(t, typeof e != 'symbol' ? e + '' : e, n)
let yK = class bN extends TP {
  constructor(e) {
    super(e),
      ht(this, 'protocol', pN),
      ht(this, 'version', gN),
      ht(this, 'name', A1.name),
      ht(this, 'metadata'),
      ht(this, 'core'),
      ht(this, 'logger'),
      ht(this, 'events', new zi.EventEmitter()),
      ht(this, 'engine'),
      ht(this, 'session'),
      ht(this, 'proposal'),
      ht(this, 'pendingRequest'),
      ht(this, 'auth'),
      ht(this, 'signConfig'),
      ht(this, 'on', (r, i) => this.events.on(r, i)),
      ht(this, 'once', (r, i) => this.events.once(r, i)),
      ht(this, 'off', (r, i) => this.events.off(r, i)),
      ht(this, 'removeListener', (r, i) => this.events.removeListener(r, i)),
      ht(this, 'removeAllListeners', r => this.events.removeAllListeners(r)),
      ht(this, 'connect', async r => {
        try {
          return await this.engine.connect(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'pair', async r => {
        try {
          return await this.engine.pair(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'approve', async r => {
        try {
          return await this.engine.approve(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'reject', async r => {
        try {
          return await this.engine.reject(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'update', async r => {
        try {
          return await this.engine.update(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'extend', async r => {
        try {
          return await this.engine.extend(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'request', async r => {
        try {
          return await this.engine.request(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'respond', async r => {
        try {
          return await this.engine.respond(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'ping', async r => {
        try {
          return await this.engine.ping(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'emit', async r => {
        try {
          return await this.engine.emit(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'disconnect', async r => {
        try {
          return await this.engine.disconnect(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'find', r => {
        try {
          return this.engine.find(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'getPendingSessionRequests', () => {
        try {
          return this.engine.getPendingSessionRequests()
        } catch (r) {
          throw (this.logger.error(r.message), r)
        }
      }),
      ht(this, 'authenticate', async (r, i) => {
        try {
          return await this.engine.authenticate(r, i)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      ht(this, 'formatAuthMessage', r => {
        try {
          return this.engine.formatAuthMessage(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'approveSessionAuthenticate', async r => {
        try {
          return await this.engine.approveSessionAuthenticate(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      ht(this, 'rejectSessionAuthenticate', async r => {
        try {
          return await this.engine.rejectSessionAuthenticate(r)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      (this.name = (e == null ? void 0 : e.name) || A1.name),
      (this.metadata = (e == null ? void 0 : e.metadata) || bx()),
      (this.signConfig = e == null ? void 0 : e.signConfig)
    const n =
      typeof (e == null ? void 0 : e.logger) < 'u' &&
      typeof (e == null ? void 0 : e.logger) != 'string'
        ? e.logger
        : pp(yd({ level: (e == null ? void 0 : e.logger) || A1.logger }))
    ;(this.core = (e == null ? void 0 : e.core) || new HV(e)),
      (this.logger = Pr(n, this.name)),
      (this.session = new cK(this.core, this.logger)),
      (this.proposal = new oK(this.core, this.logger)),
      (this.pendingRequest = new uK(this.core, this.logger)),
      (this.engine = new aK(this)),
      (this.auth = new gK(this.core, this.logger))
  }
  static async init(e) {
    const n = new bN(e)
    return await n.initialize(), n
  }
  get context() {
    return ni(this.logger)
  }
  get pairing() {
    return this.core.pairing.pairings
  }
  async initialize() {
    this.logger.trace('Initialized')
    try {
      await this.core.start(),
        await this.session.init(),
        await this.proposal.init(),
        await this.pendingRequest.init(),
        await this.auth.init(),
        await this.engine.init(),
        this.logger.info('SignClient Initialization Success'),
        setTimeout(() => {
          this.engine.processRelayMessageCache()
        }, ge.toMiliseconds(ge.ONE_SECOND))
    } catch (e) {
      throw (this.logger.info('SignClient Initialization Failure'), this.logger.error(e.message), e)
    }
  }
}
var ug = { exports: {} },
  $6
function vK() {
  return (
    $6 ||
      (($6 = 1),
      (function (t, e) {
        var n =
            (typeof globalThis < 'u' && globalThis) ||
            (typeof self < 'u' && self) ||
            (typeof $s < 'u' && $s),
          r = (function () {
            function s() {
              ;(this.fetch = !1), (this.DOMException = n.DOMException)
            }
            return (s.prototype = n), new s()
          })()
        ;(function (s) {
          ;(function (c) {
            var u =
                (typeof s < 'u' && s) ||
                (typeof self < 'u' && self) ||
                (typeof $s < 'u' && $s) ||
                {},
              f = {
                searchParams: 'URLSearchParams' in u,
                iterable: 'Symbol' in u && 'iterator' in Symbol,
                blob:
                  'FileReader' in u &&
                  'Blob' in u &&
                  (function () {
                    try {
                      return new Blob(), !0
                    } catch {
                      return !1
                    }
                  })(),
                formData: 'FormData' in u,
                arrayBuffer: 'ArrayBuffer' in u
              }
            function d(T) {
              return T && DataView.prototype.isPrototypeOf(T)
            }
            if (f.arrayBuffer)
              var p = [
                  '[object Int8Array]',
                  '[object Uint8Array]',
                  '[object Uint8ClampedArray]',
                  '[object Int16Array]',
                  '[object Uint16Array]',
                  '[object Int32Array]',
                  '[object Uint32Array]',
                  '[object Float32Array]',
                  '[object Float64Array]'
                ],
                g =
                  ArrayBuffer.isView ||
                  function (T) {
                    return T && p.indexOf(Object.prototype.toString.call(T)) > -1
                  }
            function m(T) {
              if (
                (typeof T != 'string' && (T = String(T)),
                /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(T) || T === '')
              )
                throw new TypeError('Invalid character in header field name: "' + T + '"')
              return T.toLowerCase()
            }
            function y(T) {
              return typeof T != 'string' && (T = String(T)), T
            }
            function A(T) {
              var S = {
                next: function () {
                  var k = T.shift()
                  return { done: k === void 0, value: k }
                }
              }
              return (
                f.iterable &&
                  (S[Symbol.iterator] = function () {
                    return S
                  }),
                S
              )
            }
            function E(T) {
              ;(this.map = {}),
                T instanceof E
                  ? T.forEach(function (S, k) {
                      this.append(k, S)
                    }, this)
                  : Array.isArray(T)
                    ? T.forEach(function (S) {
                        if (S.length != 2)
                          throw new TypeError(
                            'Headers constructor: expected name/value pair to be length 2, found' +
                              S.length
                          )
                        this.append(S[0], S[1])
                      }, this)
                    : T &&
                      Object.getOwnPropertyNames(T).forEach(function (S) {
                        this.append(S, T[S])
                      }, this)
            }
            ;(E.prototype.append = function (T, S) {
              ;(T = m(T)), (S = y(S))
              var k = this.map[T]
              this.map[T] = k ? k + ', ' + S : S
            }),
              (E.prototype.delete = function (T) {
                delete this.map[m(T)]
              }),
              (E.prototype.get = function (T) {
                return (T = m(T)), this.has(T) ? this.map[T] : null
              }),
              (E.prototype.has = function (T) {
                return this.map.hasOwnProperty(m(T))
              }),
              (E.prototype.set = function (T, S) {
                this.map[m(T)] = y(S)
              }),
              (E.prototype.forEach = function (T, S) {
                for (var k in this.map)
                  this.map.hasOwnProperty(k) && T.call(S, this.map[k], k, this)
              }),
              (E.prototype.keys = function () {
                var T = []
                return (
                  this.forEach(function (S, k) {
                    T.push(k)
                  }),
                  A(T)
                )
              }),
              (E.prototype.values = function () {
                var T = []
                return (
                  this.forEach(function (S) {
                    T.push(S)
                  }),
                  A(T)
                )
              }),
              (E.prototype.entries = function () {
                var T = []
                return (
                  this.forEach(function (S, k) {
                    T.push([k, S])
                  }),
                  A(T)
                )
              }),
              f.iterable && (E.prototype[Symbol.iterator] = E.prototype.entries)
            function x(T) {
              if (!T._noBody) {
                if (T.bodyUsed) return Promise.reject(new TypeError('Already read'))
                T.bodyUsed = !0
              }
            }
            function O(T) {
              return new Promise(function (S, k) {
                ;(T.onload = function () {
                  S(T.result)
                }),
                  (T.onerror = function () {
                    k(T.error)
                  })
              })
            }
            function I(T) {
              var S = new FileReader(),
                k = O(S)
              return S.readAsArrayBuffer(T), k
            }
            function M(T) {
              var S = new FileReader(),
                k = O(S),
                F = /charset=([A-Za-z0-9_-]+)/.exec(T.type),
                P = F ? F[1] : 'utf-8'
              return S.readAsText(T, P), k
            }
            function $(T) {
              for (var S = new Uint8Array(T), k = new Array(S.length), F = 0; F < S.length; F++)
                k[F] = String.fromCharCode(S[F])
              return k.join('')
            }
            function D(T) {
              if (T.slice) return T.slice(0)
              var S = new Uint8Array(T.byteLength)
              return S.set(new Uint8Array(T)), S.buffer
            }
            function R() {
              return (
                (this.bodyUsed = !1),
                (this._initBody = function (T) {
                  ;(this.bodyUsed = this.bodyUsed),
                    (this._bodyInit = T),
                    T
                      ? typeof T == 'string'
                        ? (this._bodyText = T)
                        : f.blob && Blob.prototype.isPrototypeOf(T)
                          ? (this._bodyBlob = T)
                          : f.formData && FormData.prototype.isPrototypeOf(T)
                            ? (this._bodyFormData = T)
                            : f.searchParams && URLSearchParams.prototype.isPrototypeOf(T)
                              ? (this._bodyText = T.toString())
                              : f.arrayBuffer && f.blob && d(T)
                                ? ((this._bodyArrayBuffer = D(T.buffer)),
                                  (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                                : f.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(T) || g(T))
                                  ? (this._bodyArrayBuffer = D(T))
                                  : (this._bodyText = T = Object.prototype.toString.call(T))
                      : ((this._noBody = !0), (this._bodyText = '')),
                    this.headers.get('content-type') ||
                      (typeof T == 'string'
                        ? this.headers.set('content-type', 'text/plain;charset=UTF-8')
                        : this._bodyBlob && this._bodyBlob.type
                          ? this.headers.set('content-type', this._bodyBlob.type)
                          : f.searchParams &&
                            URLSearchParams.prototype.isPrototypeOf(T) &&
                            this.headers.set(
                              'content-type',
                              'application/x-www-form-urlencoded;charset=UTF-8'
                            ))
                }),
                f.blob &&
                  (this.blob = function () {
                    var T = x(this)
                    if (T) return T
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob)
                    if (this._bodyArrayBuffer)
                      return Promise.resolve(new Blob([this._bodyArrayBuffer]))
                    if (this._bodyFormData) throw new Error('could not read FormData body as blob')
                    return Promise.resolve(new Blob([this._bodyText]))
                  }),
                (this.arrayBuffer = function () {
                  if (this._bodyArrayBuffer) {
                    var T = x(this)
                    return (
                      T ||
                      (ArrayBuffer.isView(this._bodyArrayBuffer)
                        ? Promise.resolve(
                            this._bodyArrayBuffer.buffer.slice(
                              this._bodyArrayBuffer.byteOffset,
                              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                            )
                          )
                        : Promise.resolve(this._bodyArrayBuffer))
                    )
                  } else {
                    if (f.blob) return this.blob().then(I)
                    throw new Error('could not read as ArrayBuffer')
                  }
                }),
                (this.text = function () {
                  var T = x(this)
                  if (T) return T
                  if (this._bodyBlob) return M(this._bodyBlob)
                  if (this._bodyArrayBuffer) return Promise.resolve($(this._bodyArrayBuffer))
                  if (this._bodyFormData) throw new Error('could not read FormData body as text')
                  return Promise.resolve(this._bodyText)
                }),
                f.formData &&
                  (this.formData = function () {
                    return this.text().then(V)
                  }),
                (this.json = function () {
                  return this.text().then(JSON.parse)
                }),
                this
              )
            }
            var z = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE']
            function G(T) {
              var S = T.toUpperCase()
              return z.indexOf(S) > -1 ? S : T
            }
            function j(T, S) {
              if (!(this instanceof j))
                throw new TypeError(
                  'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
                )
              S = S || {}
              var k = S.body
              if (T instanceof j) {
                if (T.bodyUsed) throw new TypeError('Already read')
                ;(this.url = T.url),
                  (this.credentials = T.credentials),
                  S.headers || (this.headers = new E(T.headers)),
                  (this.method = T.method),
                  (this.mode = T.mode),
                  (this.signal = T.signal),
                  !k && T._bodyInit != null && ((k = T._bodyInit), (T.bodyUsed = !0))
              } else this.url = String(T)
              if (
                ((this.credentials = S.credentials || this.credentials || 'same-origin'),
                (S.headers || !this.headers) && (this.headers = new E(S.headers)),
                (this.method = G(S.method || this.method || 'GET')),
                (this.mode = S.mode || this.mode || null),
                (this.signal =
                  S.signal ||
                  this.signal ||
                  (function () {
                    if ('AbortController' in u) {
                      var w = new AbortController()
                      return w.signal
                    }
                  })()),
                (this.referrer = null),
                (this.method === 'GET' || this.method === 'HEAD') && k)
              )
                throw new TypeError('Body not allowed for GET or HEAD requests')
              if (
                (this._initBody(k),
                (this.method === 'GET' || this.method === 'HEAD') &&
                  (S.cache === 'no-store' || S.cache === 'no-cache'))
              ) {
                var F = /([?&])_=[^&]*/
                if (F.test(this.url)) this.url = this.url.replace(F, '$1_=' + new Date().getTime())
                else {
                  var P = /\?/
                  this.url += (P.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()
                }
              }
            }
            j.prototype.clone = function () {
              return new j(this, { body: this._bodyInit })
            }
            function V(T) {
              var S = new FormData()
              return (
                T.trim()
                  .split('&')
                  .forEach(function (k) {
                    if (k) {
                      var F = k.split('='),
                        P = F.shift().replace(/\+/g, ' '),
                        w = F.join('=').replace(/\+/g, ' ')
                      S.append(decodeURIComponent(P), decodeURIComponent(w))
                    }
                  }),
                S
              )
            }
            function L(T) {
              var S = new E(),
                k = T.replace(/\r?\n[\t ]+/g, ' ')
              return (
                k
                  .split('\r')
                  .map(function (F) {
                    return F.indexOf(`
`) === 0
                      ? F.substr(1, F.length)
                      : F
                  })
                  .forEach(function (F) {
                    var P = F.split(':'),
                      w = P.shift().trim()
                    if (w) {
                      var B = P.join(':').trim()
                      try {
                        S.append(w, B)
                      } catch (Z) {
                        console.warn('Response ' + Z.message)
                      }
                    }
                  }),
                S
              )
            }
            R.call(j.prototype)
            function v(T, S) {
              if (!(this instanceof v))
                throw new TypeError(
                  'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
                )
              if (
                (S || (S = {}),
                (this.type = 'default'),
                (this.status = S.status === void 0 ? 200 : S.status),
                this.status < 200 || this.status > 599)
              )
                throw new RangeError(
                  "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
                )
              ;(this.ok = this.status >= 200 && this.status < 300),
                (this.statusText = S.statusText === void 0 ? '' : '' + S.statusText),
                (this.headers = new E(S.headers)),
                (this.url = S.url || ''),
                this._initBody(T)
            }
            R.call(v.prototype),
              (v.prototype.clone = function () {
                return new v(this._bodyInit, {
                  status: this.status,
                  statusText: this.statusText,
                  headers: new E(this.headers),
                  url: this.url
                })
              }),
              (v.error = function () {
                var T = new v(null, { status: 200, statusText: '' })
                return (T.ok = !1), (T.status = 0), (T.type = 'error'), T
              })
            var C = [301, 302, 303, 307, 308]
            ;(v.redirect = function (T, S) {
              if (C.indexOf(S) === -1) throw new RangeError('Invalid status code')
              return new v(null, { status: S, headers: { location: T } })
            }),
              (c.DOMException = u.DOMException)
            try {
              new c.DOMException()
            } catch {
              ;(c.DOMException = function (S, k) {
                ;(this.message = S), (this.name = k)
                var F = Error(S)
                this.stack = F.stack
              }),
                (c.DOMException.prototype = Object.create(Error.prototype)),
                (c.DOMException.prototype.constructor = c.DOMException)
            }
            function N(T, S) {
              return new Promise(function (k, F) {
                var P = new j(T, S)
                if (P.signal && P.signal.aborted)
                  return F(new c.DOMException('Aborted', 'AbortError'))
                var w = new XMLHttpRequest()
                function B() {
                  w.abort()
                }
                ;(w.onload = function () {
                  var Y = { statusText: w.statusText, headers: L(w.getAllResponseHeaders() || '') }
                  P.url.indexOf('file://') === 0 && (w.status < 200 || w.status > 599)
                    ? (Y.status = 200)
                    : (Y.status = w.status),
                    (Y.url = 'responseURL' in w ? w.responseURL : Y.headers.get('X-Request-URL'))
                  var se = 'response' in w ? w.response : w.responseText
                  setTimeout(function () {
                    k(new v(se, Y))
                  }, 0)
                }),
                  (w.onerror = function () {
                    setTimeout(function () {
                      F(new TypeError('Network request failed'))
                    }, 0)
                  }),
                  (w.ontimeout = function () {
                    setTimeout(function () {
                      F(new TypeError('Network request timed out'))
                    }, 0)
                  }),
                  (w.onabort = function () {
                    setTimeout(function () {
                      F(new c.DOMException('Aborted', 'AbortError'))
                    }, 0)
                  })
                function Z(Y) {
                  try {
                    return Y === '' && u.location.href ? u.location.href : Y
                  } catch {
                    return Y
                  }
                }
                if (
                  (w.open(P.method, Z(P.url), !0),
                  P.credentials === 'include'
                    ? (w.withCredentials = !0)
                    : P.credentials === 'omit' && (w.withCredentials = !1),
                  'responseType' in w &&
                    (f.blob
                      ? (w.responseType = 'blob')
                      : f.arrayBuffer && (w.responseType = 'arraybuffer')),
                  S &&
                    typeof S.headers == 'object' &&
                    !(S.headers instanceof E || (u.Headers && S.headers instanceof u.Headers)))
                ) {
                  var ee = []
                  Object.getOwnPropertyNames(S.headers).forEach(function (Y) {
                    ee.push(m(Y)), w.setRequestHeader(Y, y(S.headers[Y]))
                  }),
                    P.headers.forEach(function (Y, se) {
                      ee.indexOf(se) === -1 && w.setRequestHeader(se, Y)
                    })
                } else
                  P.headers.forEach(function (Y, se) {
                    w.setRequestHeader(se, Y)
                  })
                P.signal &&
                  (P.signal.addEventListener('abort', B),
                  (w.onreadystatechange = function () {
                    w.readyState === 4 && P.signal.removeEventListener('abort', B)
                  })),
                  w.send(typeof P._bodyInit > 'u' ? null : P._bodyInit)
              })
            }
            return (
              (N.polyfill = !0),
              u.fetch || ((u.fetch = N), (u.Headers = E), (u.Request = j), (u.Response = v)),
              (c.Headers = E),
              (c.Request = j),
              (c.Response = v),
              (c.fetch = N),
              Object.defineProperty(c, '__esModule', { value: !0 }),
              c
            )
          })({})
        })(r),
          (r.fetch.ponyfill = !0),
          delete r.fetch.polyfill
        var i = n.fetch ? n : r
        ;(e = i.fetch),
          (e.default = i.fetch),
          (e.fetch = i.fetch),
          (e.Headers = i.Headers),
          (e.Request = i.Request),
          (e.Response = i.Response),
          (t.exports = e)
      })(ug, ug.exports)),
    ug.exports
  )
}
var wK = vK()
const F6 = pd(wK)
var EK = Object.defineProperty,
  AK = Object.defineProperties,
  _K = Object.getOwnPropertyDescriptors,
  j6 = Object.getOwnPropertySymbols,
  CK = Object.prototype.hasOwnProperty,
  SK = Object.prototype.propertyIsEnumerable,
  z6 = (t, e, n) =>
    e in t ? EK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  q6 = (t, e) => {
    for (var n in e || (e = {})) CK.call(e, n) && z6(t, n, e[n])
    if (j6) for (var n of j6(e)) SK.call(e, n) && z6(t, n, e[n])
    return t
  },
  H6 = (t, e) => AK(t, _K(e))
const TK = { Accept: 'application/json', 'Content-Type': 'application/json' },
  xK = 'POST',
  G6 = { headers: TK, method: xK },
  V6 = 10
let ps = class {
  constructor(e, n = !1) {
    if (
      ((this.url = e),
      (this.disableProviderPing = n),
      (this.events = new zi.EventEmitter()),
      (this.isAvailable = !1),
      (this.registering = !1),
      !o6(e))
    )
      throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`)
    ;(this.url = e), (this.disableProviderPing = n)
  }
  get connected() {
    return this.isAvailable
  }
  get connecting() {
    return this.registering
  }
  on(e, n) {
    this.events.on(e, n)
  }
  once(e, n) {
    this.events.once(e, n)
  }
  off(e, n) {
    this.events.off(e, n)
  }
  removeListener(e, n) {
    this.events.removeListener(e, n)
  }
  async open(e = this.url) {
    await this.register(e)
  }
  async close() {
    if (!this.isAvailable) throw new Error('Connection already closed')
    this.onClose()
  }
  async send(e) {
    this.isAvailable || (await this.register())
    try {
      const n = ka(e),
        r = await (await F6(this.url, H6(q6({}, G6), { body: n }))).json()
      this.onPayload({ data: r })
    } catch (n) {
      this.onError(e.id, n)
    }
  }
  async register(e = this.url) {
    if (!o6(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`)
    if (this.registering) {
      const n = this.events.getMaxListeners()
      return (
        (this.events.listenerCount('register_error') >= n ||
          this.events.listenerCount('open') >= n) &&
          this.events.setMaxListeners(n + 1),
        new Promise((r, i) => {
          this.events.once('register_error', s => {
            this.resetMaxListeners(), i(s)
          }),
            this.events.once('open', () => {
              if ((this.resetMaxListeners(), typeof this.isAvailable > 'u'))
                return i(new Error('HTTP connection is missing or invalid'))
              r()
            })
        })
      )
    }
    ;(this.url = e), (this.registering = !0)
    try {
      if (!this.disableProviderPing) {
        const n = ka({ id: 1, jsonrpc: '2.0', method: 'test', params: [] })
        await F6(e, H6(q6({}, G6), { body: n }))
      }
      this.onOpen()
    } catch (n) {
      const r = this.parseError(n)
      throw (this.events.emit('register_error', r), this.onClose(), r)
    }
  }
  onOpen() {
    ;(this.isAvailable = !0), (this.registering = !1), this.events.emit('open')
  }
  onClose() {
    ;(this.isAvailable = !1), (this.registering = !1), this.events.emit('close')
  }
  onPayload(e) {
    if (typeof e.data > 'u') return
    const n = typeof e.data == 'string' ? Xc(e.data) : e.data
    this.events.emit('payload', n)
  }
  onError(e, n) {
    const r = this.parseError(n),
      i = r.message || r.toString(),
      s = Lm(e, i)
    this.events.emit('payload', s)
  }
  parseError(e, n = this.url) {
    return Qx(e, n, 'HTTP')
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > V6 && this.events.setMaxListeners(V6)
  }
}
const K6 = 'error',
  NK = 'wss://relay.walletconnect.org',
  IK = 'wc',
  OK = 'universal_provider',
  lg = `${IK}@2:${OK}:`,
  yN = 'https://rpc.walletconnect.org/v1/',
  xl = 'generic',
  RK = `${yN}bundler`,
  Vi = { DEFAULT_CHAIN_CHANGED: 'default_chain_changed' }
function DK() {}
function d2(t) {
  return t == null || (typeof t != 'object' && typeof t != 'function')
}
function f2(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView)
}
function PK(t) {
  if (d2(t)) return t
  if (
    Array.isArray(t) ||
    f2(t) ||
    t instanceof ArrayBuffer ||
    (typeof SharedArrayBuffer < 'u' && t instanceof SharedArrayBuffer)
  )
    return t.slice(0)
  const e = Object.getPrototypeOf(t),
    n = e.constructor
  if (t instanceof Date || t instanceof Map || t instanceof Set) return new n(t)
  if (t instanceof RegExp) {
    const r = new n(t)
    return (r.lastIndex = t.lastIndex), r
  }
  if (t instanceof DataView) return new n(t.buffer.slice(0))
  if (t instanceof Error) {
    const r = new n(t.message)
    return (r.stack = t.stack), (r.name = t.name), (r.cause = t.cause), r
  }
  if (typeof File < 'u' && t instanceof File)
    return new n([t], t.name, { type: t.type, lastModified: t.lastModified })
  if (typeof t == 'object') {
    const r = Object.create(e)
    return Object.assign(r, t)
  }
  return t
}
function W6(t) {
  return typeof t == 'object' && t !== null
}
function vN(t) {
  return Object.getOwnPropertySymbols(t).filter(e =>
    Object.prototype.propertyIsEnumerable.call(t, e)
  )
}
function wN(t) {
  return t == null
    ? t === void 0
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(t)
}
const MK = '[object RegExp]',
  EN = '[object String]',
  AN = '[object Number]',
  _N = '[object Boolean]',
  CN = '[object Arguments]',
  kK = '[object Symbol]',
  UK = '[object Date]',
  BK = '[object Map]',
  LK = '[object Set]',
  $K = '[object Array]',
  FK = '[object ArrayBuffer]',
  jK = '[object Object]',
  zK = '[object DataView]',
  qK = '[object Uint8Array]',
  HK = '[object Uint8ClampedArray]',
  GK = '[object Uint16Array]',
  VK = '[object Uint32Array]',
  KK = '[object Int8Array]',
  WK = '[object Int16Array]',
  QK = '[object Int32Array]',
  YK = '[object Float32Array]',
  ZK = '[object Float64Array]'
function XK(t, e) {
  return Dl(t, void 0, t, new Map(), e)
}
function Dl(t, e, n, r = new Map(), i = void 0) {
  const s = i == null ? void 0 : i(t, e, n, r)
  if (s != null) return s
  if (d2(t)) return t
  if (r.has(t)) return r.get(t)
  if (Array.isArray(t)) {
    const c = new Array(t.length)
    r.set(t, c)
    for (let u = 0; u < t.length; u++) c[u] = Dl(t[u], u, n, r, i)
    return (
      Object.hasOwn(t, 'index') && (c.index = t.index),
      Object.hasOwn(t, 'input') && (c.input = t.input),
      c
    )
  }
  if (t instanceof Date) return new Date(t.getTime())
  if (t instanceof RegExp) {
    const c = new RegExp(t.source, t.flags)
    return (c.lastIndex = t.lastIndex), c
  }
  if (t instanceof Map) {
    const c = new Map()
    r.set(t, c)
    for (const [u, f] of t) c.set(u, Dl(f, u, n, r, i))
    return c
  }
  if (t instanceof Set) {
    const c = new Set()
    r.set(t, c)
    for (const u of t) c.add(Dl(u, void 0, n, r, i))
    return c
  }
  if (typeof Buffer < 'u' && Buffer.isBuffer(t)) return t.subarray()
  if (f2(t)) {
    const c = new (Object.getPrototypeOf(t).constructor)(t.length)
    r.set(t, c)
    for (let u = 0; u < t.length; u++) c[u] = Dl(t[u], u, n, r, i)
    return c
  }
  if (
    t instanceof ArrayBuffer ||
    (typeof SharedArrayBuffer < 'u' && t instanceof SharedArrayBuffer)
  )
    return t.slice(0)
  if (t instanceof DataView) {
    const c = new DataView(t.buffer.slice(0), t.byteOffset, t.byteLength)
    return r.set(t, c), Oc(c, t, n, r, i), c
  }
  if (typeof File < 'u' && t instanceof File) {
    const c = new File([t], t.name, { type: t.type })
    return r.set(t, c), Oc(c, t, n, r, i), c
  }
  if (t instanceof Blob) {
    const c = new Blob([t], { type: t.type })
    return r.set(t, c), Oc(c, t, n, r, i), c
  }
  if (t instanceof Error) {
    const c = new t.constructor()
    return (
      r.set(t, c),
      (c.message = t.message),
      (c.name = t.name),
      (c.stack = t.stack),
      (c.cause = t.cause),
      Oc(c, t, n, r, i),
      c
    )
  }
  if (typeof t == 'object' && JK(t)) {
    const c = Object.create(Object.getPrototypeOf(t))
    return r.set(t, c), Oc(c, t, n, r, i), c
  }
  return t
}
function Oc(t, e, n = t, r, i) {
  const s = [...Object.keys(e), ...vN(e)]
  for (let c = 0; c < s.length; c++) {
    const u = s[c],
      f = Object.getOwnPropertyDescriptor(t, u)
    ;(f == null || f.writable) && (t[u] = Dl(e[u], u, n, r, i))
  }
}
function JK(t) {
  switch (wN(t)) {
    case CN:
    case $K:
    case FK:
    case zK:
    case _N:
    case UK:
    case YK:
    case ZK:
    case KK:
    case WK:
    case QK:
    case BK:
    case AN:
    case jK:
    case MK:
    case LK:
    case EN:
    case kK:
    case qK:
    case HK:
    case GK:
    case VK:
      return !0
    default:
      return !1
  }
}
function eW(t, e) {
  return XK(t, (n, r, i, s) => {
    if (typeof t == 'object')
      switch (Object.prototype.toString.call(t)) {
        case AN:
        case EN:
        case _N: {
          const c = new t.constructor(t == null ? void 0 : t.valueOf())
          return Oc(c, t), c
        }
        case CN: {
          const c = {}
          return Oc(c, t), (c.length = t.length), (c[Symbol.iterator] = t[Symbol.iterator]), c
        }
        default:
          return
      }
  })
}
function Q6(t) {
  return eW(t)
}
function Y6(t) {
  return t !== null && typeof t == 'object' && wN(t) === '[object Arguments]'
}
function tW(t) {
  return f2(t)
}
function nW(t) {
  var n
  if (typeof t != 'object' || t == null) return !1
  if (Object.getPrototypeOf(t) === null) return !0
  if (Object.prototype.toString.call(t) !== '[object Object]') {
    const r = t[Symbol.toStringTag]
    return r == null ||
      !((n = Object.getOwnPropertyDescriptor(t, Symbol.toStringTag)) != null && n.writable)
      ? !1
      : t.toString() === `[object ${r}]`
  }
  let e = t
  for (; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e)
  return Object.getPrototypeOf(t) === e
}
function rW(t, ...e) {
  const n = e.slice(0, -1),
    r = e[e.length - 1]
  let i = t
  for (let s = 0; s < n.length; s++) {
    const c = n[s]
    i = Hw(i, c, r, new Map())
  }
  return i
}
function Hw(t, e, n, r) {
  if ((d2(t) && (t = Object(t)), e == null || typeof e != 'object')) return t
  if (r.has(e)) return PK(r.get(e))
  if ((r.set(e, t), Array.isArray(e))) {
    e = e.slice()
    for (let s = 0; s < e.length; s++) e[s] = e[s] ?? void 0
  }
  const i = [...Object.keys(e), ...vN(e)]
  for (let s = 0; s < i.length; s++) {
    const c = i[s]
    let u = e[c],
      f = t[c]
    if (
      (Y6(u) && (u = { ...u }),
      Y6(f) && (f = { ...f }),
      typeof Buffer < 'u' && Buffer.isBuffer(u) && (u = Q6(u)),
      Array.isArray(u))
    )
      if (typeof f == 'object' && f != null) {
        const p = [],
          g = Reflect.ownKeys(f)
        for (let m = 0; m < g.length; m++) {
          const y = g[m]
          p[y] = f[y]
        }
        f = p
      } else f = []
    const d = n(f, u, c, t, e, r)
    d != null
      ? (t[c] = d)
      : Array.isArray(u) || (W6(f) && W6(u))
        ? (t[c] = Hw(f, u, n, r))
        : f == null && nW(u)
          ? (t[c] = Hw({}, u, n, r))
          : f == null && tW(u)
            ? (t[c] = Q6(u))
            : (f === void 0 || u !== void 0) && (t[c] = u)
  }
  return t
}
function iW(t, ...e) {
  return rW(t, ...e, DK)
}
var sW = Object.defineProperty,
  aW = Object.defineProperties,
  oW = Object.getOwnPropertyDescriptors,
  Z6 = Object.getOwnPropertySymbols,
  cW = Object.prototype.hasOwnProperty,
  uW = Object.prototype.propertyIsEnumerable,
  X6 = (t, e, n) =>
    e in t ? sW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  dg = (t, e) => {
    for (var n in e || (e = {})) cW.call(e, n) && X6(t, n, e[n])
    if (Z6) for (var n of Z6(e)) uW.call(e, n) && X6(t, n, e[n])
    return t
  },
  lW = (t, e) => aW(t, oW(e))
function bi(t, e, n) {
  var r
  const i = Ml(t)
  return (
    ((r = e.rpcMap) == null ? void 0 : r[i.reference]) ||
    `${yN}?chainId=${i.namespace}:${i.reference}&projectId=${n}`
  )
}
function Au(t) {
  return t.includes(':') ? t.split(':')[1] : t
}
function SN(t) {
  return t.map(e => `${e.split(':')[0]}:${e.split(':')[1]}`)
}
function dW(t, e) {
  const n = Object.keys(e.namespaces).filter(i => i.includes(t))
  if (!n.length) return []
  const r = []
  return (
    n.forEach(i => {
      const s = e.namespaces[i].accounts
      r.push(...s)
    }),
    r
  )
}
function S1(t = {}, e = {}) {
  const n = J6(t),
    r = J6(e)
  return iW(n, r)
}
function J6(t) {
  var e, n, r, i
  const s = {}
  if (!Ch(t)) return s
  for (const [c, u] of Object.entries(t)) {
    const f = a2(c) ? [c] : u.chains,
      d = u.methods || [],
      p = u.events || [],
      g = u.rpcMap || {},
      m = nh(c)
    s[m] = lW(dg(dg({}, s[m]), u), {
      chains: xg(f, (e = s[m]) == null ? void 0 : e.chains),
      methods: xg(d, (n = s[m]) == null ? void 0 : n.methods),
      events: xg(p, (r = s[m]) == null ? void 0 : r.events),
      rpcMap: dg(dg({}, g), (i = s[m]) == null ? void 0 : i.rpcMap)
    })
  }
  return s
}
function fW(t) {
  return t.includes(':') ? t.split(':')[2] : t
}
function e4(t) {
  const e = {}
  for (const [n, r] of Object.entries(t)) {
    const i = r.methods || [],
      s = r.events || [],
      c = r.accounts || [],
      u = a2(n) ? [n] : r.chains ? r.chains : SN(r.accounts)
    e[n] = { chains: u, methods: i, events: s, accounts: c }
  }
  return e
}
function T1(t) {
  return typeof t == 'number'
    ? t
    : t.includes('0x')
      ? parseInt(t, 16)
      : ((t = t.includes(':') ? t.split(':')[1] : t), isNaN(Number(t)) ? t : Number(t))
}
const TN = {},
  Tt = t => TN[t],
  x1 = (t, e) => {
    TN[t] = e
  }
var hW = Object.defineProperty,
  pW = (t, e, n) =>
    e in t ? hW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  hl = (t, e, n) => pW(t, typeof e != 'symbol' ? e + '' : e, n)
class gW {
  constructor(e) {
    hl(this, 'name', 'polkadot'),
      hl(this, 'client'),
      hl(this, 'httpProviders'),
      hl(this, 'events'),
      hl(this, 'namespace'),
      hl(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Tt('events')),
      (this.client = Tt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(Vi.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2]) || []
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        const i = Au(n)
        e[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || bi(e, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new Gi(new ps(r, Tt('disableProviderPing')))
  }
}
var mW = Object.defineProperty,
  bW = Object.defineProperties,
  yW = Object.getOwnPropertyDescriptors,
  t4 = Object.getOwnPropertySymbols,
  vW = Object.prototype.hasOwnProperty,
  wW = Object.prototype.propertyIsEnumerable,
  Gw = (t, e, n) =>
    e in t ? mW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  n4 = (t, e) => {
    for (var n in e || (e = {})) vW.call(e, n) && Gw(t, n, e[n])
    if (t4) for (var n of t4(e)) wW.call(e, n) && Gw(t, n, e[n])
    return t
  },
  r4 = (t, e) => bW(t, yW(e)),
  pl = (t, e, n) => Gw(t, typeof e != 'symbol' ? e + '' : e, n)
class EW {
  constructor(e) {
    pl(this, 'name', 'eip155'),
      pl(this, 'client'),
      pl(this, 'chainId'),
      pl(this, 'namespace'),
      pl(this, 'httpProviders'),
      pl(this, 'events'),
      (this.namespace = e.namespace),
      (this.events = Tt('events')),
      (this.client = Tt('client')),
      (this.httpProviders = this.createHttpProviders()),
      (this.chainId = parseInt(this.getDefaultChain()))
  }
  async request(e) {
    switch (e.request.method) {
      case 'eth_requestAccounts':
        return this.getAccounts()
      case 'eth_accounts':
        return this.getAccounts()
      case 'wallet_switchEthereumChain':
        return await this.handleSwitchChain(e)
      case 'eth_chainId':
        return parseInt(this.getDefaultChain())
      case 'wallet_getCapabilities':
        return await this.getCapabilities(e)
      case 'wallet_getCallsStatus':
        return await this.getCallStatus(e)
    }
    return this.namespace.methods.includes(e.request.method)
      ? await this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), n),
      (this.chainId = parseInt(e)),
      this.events.emit(Vi.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString()
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  createHttpProvider(e, n) {
    const r = n || bi(`${this.name}:${e}`, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new Gi(new ps(r, Tt('disableProviderPing')))
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        const i = parseInt(Au(n))
        e[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  getHttpProvider() {
    const e = this.chainId,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  async handleSwitchChain(e) {
    var n, r
    let i = e.request.params ? ((n = e.request.params[0]) == null ? void 0 : n.chainId) : '0x0'
    i = i.startsWith('0x') ? i : `0x${i}`
    const s = parseInt(i, 16)
    if (this.isChainApproved(s)) this.setDefaultChain(`${s}`)
    else if (this.namespace.methods.includes('wallet_switchEthereumChain'))
      await this.client.request({
        topic: e.topic,
        request: { method: e.request.method, params: [{ chainId: i }] },
        chainId: (r = this.namespace.chains) == null ? void 0 : r[0]
      }),
        this.setDefaultChain(`${s}`)
    else
      throw new Error(
        `Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`
      )
    return null
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`)
  }
  async getCapabilities(e) {
    var n, r, i
    const s = (r = (n = e.request) == null ? void 0 : n.params) == null ? void 0 : r[0]
    if (!s) throw new Error('Missing address parameter in `wallet_getCapabilities` request')
    const c = this.client.session.get(e.topic),
      u = ((i = c == null ? void 0 : c.sessionProperties) == null ? void 0 : i.capabilities) || {}
    if (u != null && u[s]) return u == null ? void 0 : u[s]
    const f = await this.client.request(e)
    try {
      await this.client.session.update(e.topic, {
        sessionProperties: r4(n4({}, c.sessionProperties || {}), {
          capabilities: r4(n4({}, u || {}), { [s]: f })
        })
      })
    } catch (d) {
      console.warn('Failed to update session with capabilities', d)
    }
    return f
  }
  async getCallStatus(e) {
    var n, r
    const i = this.client.session.get(e.topic),
      s = (n = i.sessionProperties) == null ? void 0 : n.bundler_name
    if (s) {
      const u = this.getBundlerUrl(e.chainId, s)
      try {
        return await this.getUserOperationReceipt(u, e)
      } catch (f) {
        console.warn('Failed to fetch call status from bundler', f, u)
      }
    }
    const c = (r = i.sessionProperties) == null ? void 0 : r.bundler_url
    if (c)
      try {
        return await this.getUserOperationReceipt(c, e)
      } catch (u) {
        console.warn('Failed to fetch call status from custom bundler', u, c)
      }
    if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e)
    throw new Error('Fetching call status not approved by the wallet.')
  }
  async getUserOperationReceipt(e, n) {
    var r
    const i = new URL(e),
      s = await fetch(i, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(
          Uo('eth_getUserOperationReceipt', [(r = n.request.params) == null ? void 0 : r[0]])
        )
      })
    if (!s.ok) throw new Error(`Failed to fetch user operation receipt - ${s.status}`)
    return await s.json()
  }
  getBundlerUrl(e, n) {
    return `${RK}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${n}`
  }
}
var AW = Object.defineProperty,
  _W = (t, e, n) =>
    e in t ? AW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  gl = (t, e, n) => _W(t, typeof e != 'symbol' ? e + '' : e, n)
class CW {
  constructor(e) {
    gl(this, 'name', 'solana'),
      gl(this, 'client'),
      gl(this, 'httpProviders'),
      gl(this, 'events'),
      gl(this, 'namespace'),
      gl(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Tt('events')),
      (this.client = Tt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(Vi.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        const i = Au(n)
        e[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || bi(e, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new Gi(new ps(r, Tt('disableProviderPing')))
  }
}
var SW = Object.defineProperty,
  TW = (t, e, n) =>
    e in t ? SW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  ml = (t, e, n) => TW(t, typeof e != 'symbol' ? e + '' : e, n)
class xW {
  constructor(e) {
    ml(this, 'name', 'cosmos'),
      ml(this, 'client'),
      ml(this, 'httpProviders'),
      ml(this, 'events'),
      ml(this, 'namespace'),
      ml(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Tt('events')),
      (this.client = Tt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(Vi.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        const i = Au(n)
        e[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || bi(e, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new Gi(new ps(r, Tt('disableProviderPing')))
  }
}
var NW = Object.defineProperty,
  IW = (t, e, n) =>
    e in t ? NW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  bl = (t, e, n) => IW(t, typeof e != 'symbol' ? e + '' : e, n)
class OW {
  constructor(e) {
    bl(this, 'name', 'algorand'),
      bl(this, 'client'),
      bl(this, 'httpProviders'),
      bl(this, 'events'),
      bl(this, 'namespace'),
      bl(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Tt('events')),
      (this.client = Tt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    if (!this.httpProviders[e]) {
      const r = n || bi(`${this.name}:${e}`, this.namespace, this.client.core.projectId)
      if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
      this.setHttpProvider(e, r)
    }
    ;(this.chainId = e), this.events.emit(Vi.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        e[n] = this.createHttpProvider(n, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || bi(e, this.namespace, this.client.core.projectId)
    return typeof r > 'u' ? void 0 : new Gi(new ps(r, Tt('disableProviderPing')))
  }
}
var RW = Object.defineProperty,
  DW = (t, e, n) =>
    e in t ? RW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  yl = (t, e, n) => DW(t, typeof e != 'symbol' ? e + '' : e, n)
class PW {
  constructor(e) {
    yl(this, 'name', 'cip34'),
      yl(this, 'client'),
      yl(this, 'httpProviders'),
      yl(this, 'events'),
      yl(this, 'namespace'),
      yl(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Tt('events')),
      (this.client = Tt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(Vi.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        const r = this.getCardanoRPCUrl(n),
          i = Au(n)
        e[i] = this.createHttpProvider(i, r)
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  getCardanoRPCUrl(e) {
    const n = this.namespace.rpcMap
    if (n) return n[e]
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || this.getCardanoRPCUrl(e)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new Gi(new ps(r, Tt('disableProviderPing')))
  }
}
var MW = Object.defineProperty,
  kW = (t, e, n) =>
    e in t ? MW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  vl = (t, e, n) => kW(t, typeof e != 'symbol' ? e + '' : e, n)
class UW {
  constructor(e) {
    vl(this, 'name', 'elrond'),
      vl(this, 'client'),
      vl(this, 'httpProviders'),
      vl(this, 'events'),
      vl(this, 'namespace'),
      vl(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Tt('events')),
      (this.client = Tt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(Vi.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        const i = Au(n)
        e[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || bi(e, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new Gi(new ps(r, Tt('disableProviderPing')))
  }
}
var BW = Object.defineProperty,
  LW = (t, e, n) =>
    e in t ? BW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  wl = (t, e, n) => LW(t, typeof e != 'symbol' ? e + '' : e, n)
class $W {
  constructor(e) {
    wl(this, 'name', 'multiversx'),
      wl(this, 'client'),
      wl(this, 'httpProviders'),
      wl(this, 'events'),
      wl(this, 'namespace'),
      wl(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Tt('events')),
      (this.client = Tt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(Vi.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        const i = Au(n)
        e[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || bi(e, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new Gi(new ps(r, Tt('disableProviderPing')))
  }
}
var FW = Object.defineProperty,
  jW = (t, e, n) =>
    e in t ? FW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  El = (t, e, n) => jW(t, typeof e != 'symbol' ? e + '' : e, n)
class zW {
  constructor(e) {
    El(this, 'name', 'near'),
      El(this, 'client'),
      El(this, 'httpProviders'),
      El(this, 'events'),
      El(this, 'namespace'),
      El(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Tt('events')),
      (this.client = Tt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    if (((this.chainId = e), !this.httpProviders[e])) {
      const r = n || bi(`${this.name}:${e}`, this.namespace)
      if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
      this.setHttpProvider(e, r)
    }
    this.events.emit(Vi.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2]) || []
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        e[n] = this.createHttpProvider(n, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || bi(e, this.namespace)
    return typeof r > 'u' ? void 0 : new Gi(new ps(r, Tt('disableProviderPing')))
  }
}
var qW = Object.defineProperty,
  HW = (t, e, n) =>
    e in t ? qW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Al = (t, e, n) => HW(t, typeof e != 'symbol' ? e + '' : e, n)
class GW {
  constructor(e) {
    Al(this, 'name', 'tezos'),
      Al(this, 'client'),
      Al(this, 'httpProviders'),
      Al(this, 'events'),
      Al(this, 'namespace'),
      Al(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Tt('events')),
      (this.client = Tt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    if (((this.chainId = e), !this.httpProviders[e])) {
      const r = n || bi(`${this.name}:${e}`, this.namespace)
      if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
      this.setHttpProvider(e, r)
    }
    this.events.emit(Vi.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2]) || []
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        e[n] = this.createHttpProvider(n)
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || bi(e, this.namespace)
    return typeof r > 'u' ? void 0 : new Gi(new ps(r))
  }
}
var VW = Object.defineProperty,
  KW = (t, e, n) =>
    e in t ? VW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  _l = (t, e, n) => KW(t, typeof e != 'symbol' ? e + '' : e, n)
class WW {
  constructor(e) {
    _l(this, 'name', xl),
      _l(this, 'client'),
      _l(this, 'httpProviders'),
      _l(this, 'events'),
      _l(this, 'namespace'),
      _l(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Tt('events')),
      (this.client = Tt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    ;(this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))]),
      (this.namespace.accounts = [
        ...new Set((this.namespace.accounts || []).concat(e.accounts || []))
      ]),
      (this.namespace.methods = [
        ...new Set((this.namespace.methods || []).concat(e.methods || []))
      ]),
      (this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))]),
      (this.httpProviders = this.createHttpProviders())
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider(e.chainId).request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(Vi.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    var e, n
    const r = {}
    return (
      (n = (e = this.namespace) == null ? void 0 : e.accounts) == null ||
        n.forEach(i => {
          const s = Ml(i)
          r[`${s.namespace}:${s.reference}`] = this.createHttpProvider(i)
        }),
      r
    )
  }
  getHttpProvider(e) {
    const n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || bi(e, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new Gi(new ps(r, Tt('disableProviderPing')))
  }
}
var QW = Object.defineProperty,
  YW = Object.defineProperties,
  ZW = Object.getOwnPropertyDescriptors,
  i4 = Object.getOwnPropertySymbols,
  XW = Object.prototype.hasOwnProperty,
  JW = Object.prototype.propertyIsEnumerable,
  Vw = (t, e, n) =>
    e in t ? QW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  fg = (t, e) => {
    for (var n in e || (e = {})) XW.call(e, n) && Vw(t, n, e[n])
    if (i4) for (var n of i4(e)) JW.call(e, n) && Vw(t, n, e[n])
    return t
  },
  N1 = (t, e) => YW(t, ZW(e)),
  Di = (t, e, n) => Vw(t, typeof e != 'symbol' ? e + '' : e, n)
let eQ = class xN {
  constructor(e) {
    Di(this, 'client'),
      Di(this, 'namespaces'),
      Di(this, 'optionalNamespaces'),
      Di(this, 'sessionProperties'),
      Di(this, 'scopedProperties'),
      Di(this, 'events', new $E()),
      Di(this, 'rpcProviders', {}),
      Di(this, 'session'),
      Di(this, 'providerOpts'),
      Di(this, 'logger'),
      Di(this, 'uri'),
      Di(this, 'disableProviderPing', !1),
      (this.providerOpts = e),
      (this.logger =
        typeof (e == null ? void 0 : e.logger) < 'u' &&
        typeof (e == null ? void 0 : e.logger) != 'string'
          ? e.logger
          : pp(yd({ level: (e == null ? void 0 : e.logger) || K6 }))),
      (this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || !1)
  }
  static async init(e) {
    const n = new xN(e)
    return await n.initialize(), n
  }
  async request(e, n, r) {
    const [i, s] = this.validateChain(n)
    if (!this.session) throw new Error('Please call connect() before request()')
    return await this.getProvider(i).request({
      request: fg({}, e),
      chainId: `${i}:${s}`,
      topic: this.session.topic,
      expiry: r
    })
  }
  sendAsync(e, n, r, i) {
    const s = new Date().getTime()
    this.request(e, r, i)
      .then(c => n(null, Bm(s, c)))
      .catch(c => n(c, void 0))
  }
  async enable() {
    if (!this.client) throw new Error('Sign Client not initialized')
    return (
      this.session ||
        (await this.connect({
          namespaces: this.namespaces,
          optionalNamespaces: this.optionalNamespaces,
          sessionProperties: this.sessionProperties,
          scopedProperties: this.scopedProperties
        })),
      await this.requestAccounts()
    )
  }
  async disconnect() {
    var e
    if (!this.session) throw new Error('Please call connect() before enable()')
    await this.client.disconnect({
      topic: (e = this.session) == null ? void 0 : e.topic,
      reason: Qt('USER_DISCONNECTED')
    }),
      await this.cleanup()
  }
  async connect(e) {
    if (!this.client) throw new Error('Sign Client not initialized')
    if ((this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing))
      return await this.pair(e.pairingTopic)
  }
  async authenticate(e, n) {
    if (!this.client) throw new Error('Sign Client not initialized')
    this.setNamespaces(e), await this.cleanupPendingPairings()
    const { uri: r, response: i } = await this.client.authenticate(e, n)
    r && ((this.uri = r), this.events.emit('display_uri', r))
    const s = await i()
    if (((this.session = s.session), this.session)) {
      const c = e4(this.session.namespaces)
      ;(this.namespaces = S1(this.namespaces, c)),
        await this.persist('namespaces', this.namespaces),
        this.onConnect()
    }
    return s
  }
  on(e, n) {
    this.events.on(e, n)
  }
  once(e, n) {
    this.events.once(e, n)
  }
  removeListener(e, n) {
    this.events.removeListener(e, n)
  }
  off(e, n) {
    this.events.off(e, n)
  }
  get isWalletConnect() {
    return !0
  }
  async pair(e) {
    const { uri: n, approval: r } = await this.client.connect({
      pairingTopic: e,
      requiredNamespaces: this.namespaces,
      optionalNamespaces: this.optionalNamespaces,
      sessionProperties: this.sessionProperties,
      scopedProperties: this.scopedProperties
    })
    n && ((this.uri = n), this.events.emit('display_uri', n))
    const i = await r()
    this.session = i
    const s = e4(i.namespaces)
    return (
      (this.namespaces = S1(this.namespaces, s)),
      await this.persist('namespaces', this.namespaces),
      await this.persist('optionalNamespaces', this.optionalNamespaces),
      this.onConnect(),
      this.session
    )
  }
  setDefaultChain(e, n) {
    try {
      if (!this.session) return
      const [r, i] = this.validateChain(e),
        s = this.getProvider(r)
      s.name === xl ? s.setDefaultChain(`${r}:${i}`, n) : s.setDefaultChain(i, n)
    } catch (r) {
      if (!/Please call connect/.test(r.message)) throw r
    }
  }
  async cleanupPendingPairings(e = {}) {
    this.logger.info('Cleaning up inactive pairings...')
    const n = this.client.pairing.getAll()
    if (ru(n)) {
      for (const r of n)
        e.deletePairings
          ? this.client.core.expirer.set(r.topic, 0)
          : await this.client.core.relayer.subscriber.unsubscribe(r.topic)
      this.logger.info(`Inactive pairings cleared: ${n.length}`)
    }
  }
  abortPairingAttempt() {
    this.logger.warn('abortPairingAttempt is deprecated. This is now a no-op.')
  }
  async checkStorage() {
    ;(this.namespaces = (await this.getFromStore('namespaces')) || {}),
      (this.optionalNamespaces = (await this.getFromStore('optionalNamespaces')) || {}),
      this.session && this.createProviders()
  }
  async initialize() {
    this.logger.trace('Initialized'),
      await this.createClient(),
      await this.checkStorage(),
      this.registerEventListeners()
  }
  async createClient() {
    var e, n
    if (
      ((this.client =
        this.providerOpts.client ||
        (await yK.init({
          core: this.providerOpts.core,
          logger: this.providerOpts.logger || K6,
          relayUrl: this.providerOpts.relayUrl || NK,
          projectId: this.providerOpts.projectId,
          metadata: this.providerOpts.metadata,
          storageOptions: this.providerOpts.storageOptions,
          storage: this.providerOpts.storage,
          name: this.providerOpts.name,
          customStoragePrefix: this.providerOpts.customStoragePrefix,
          telemetryEnabled: this.providerOpts.telemetryEnabled
        }))),
      this.providerOpts.session)
    )
      try {
        this.session = this.client.session.get(this.providerOpts.session.topic)
      } catch (r) {
        throw (
          (this.logger.error('Failed to get session', r),
          new Error(
            `The provided session: ${(n = (e = this.providerOpts) == null ? void 0 : e.session) == null ? void 0 : n.topic} doesn't exist in the Sign client`
          ))
        )
      }
    else {
      const r = this.client.session.getAll()
      this.session = r[0]
    }
    this.logger.trace('SignClient Initialized')
  }
  createProviders() {
    if (!this.client) throw new Error('Sign Client not initialized')
    if (!this.session)
      throw new Error('Session not initialized. Please call connect() before enable()')
    const e = [...new Set(Object.keys(this.session.namespaces).map(n => nh(n)))]
    x1('client', this.client),
      x1('events', this.events),
      x1('disableProviderPing', this.disableProviderPing),
      e.forEach(n => {
        if (!this.session) return
        const r = dW(n, this.session),
          i = SN(r),
          s = S1(this.namespaces, this.optionalNamespaces),
          c = N1(fg({}, s[n]), { accounts: r, chains: i })
        switch (n) {
          case 'eip155':
            this.rpcProviders[n] = new EW({ namespace: c })
            break
          case 'algorand':
            this.rpcProviders[n] = new OW({ namespace: c })
            break
          case 'solana':
            this.rpcProviders[n] = new CW({ namespace: c })
            break
          case 'cosmos':
            this.rpcProviders[n] = new xW({ namespace: c })
            break
          case 'polkadot':
            this.rpcProviders[n] = new gW({ namespace: c })
            break
          case 'cip34':
            this.rpcProviders[n] = new PW({ namespace: c })
            break
          case 'elrond':
            this.rpcProviders[n] = new UW({ namespace: c })
            break
          case 'multiversx':
            this.rpcProviders[n] = new $W({ namespace: c })
            break
          case 'near':
            this.rpcProviders[n] = new zW({ namespace: c })
            break
          case 'tezos':
            this.rpcProviders[n] = new GW({ namespace: c })
            break
          default:
            this.rpcProviders[xl]
              ? this.rpcProviders[xl].updateNamespace(c)
              : (this.rpcProviders[xl] = new WW({ namespace: c }))
        }
      })
  }
  registerEventListeners() {
    if (typeof this.client > 'u') throw new Error('Sign Client is not initialized')
    this.client.on('session_ping', e => {
      var n
      const { topic: r } = e
      r === ((n = this.session) == null ? void 0 : n.topic) && this.events.emit('session_ping', e)
    }),
      this.client.on('session_event', e => {
        var n
        const { params: r, topic: i } = e
        if (i !== ((n = this.session) == null ? void 0 : n.topic)) return
        const { event: s } = r
        if (s.name === 'accountsChanged') {
          const c = s.data
          c && ru(c) && this.events.emit('accountsChanged', c.map(fW))
        } else if (s.name === 'chainChanged') {
          const c = r.chainId,
            u = r.event.data,
            f = nh(c),
            d = T1(c) !== T1(u) ? `${f}:${T1(u)}` : c
          this.onChainChanged(d)
        } else this.events.emit(s.name, s.data)
        this.events.emit('session_event', e)
      }),
      this.client.on('session_update', ({ topic: e, params: n }) => {
        var r, i
        if (e !== ((r = this.session) == null ? void 0 : r.topic)) return
        const { namespaces: s } = n,
          c = (i = this.client) == null ? void 0 : i.session.get(e)
        ;(this.session = N1(fg({}, c), { namespaces: s })),
          this.onSessionUpdate(),
          this.events.emit('session_update', { topic: e, params: n })
      }),
      this.client.on('session_delete', async e => {
        var n
        e.topic === ((n = this.session) == null ? void 0 : n.topic) &&
          (await this.cleanup(),
          this.events.emit('session_delete', e),
          this.events.emit('disconnect', N1(fg({}, Qt('USER_DISCONNECTED')), { data: e.topic })))
      }),
      this.on(Vi.DEFAULT_CHAIN_CHANGED, e => {
        this.onChainChanged(e, !0)
      })
  }
  getProvider(e) {
    return this.rpcProviders[e] || this.rpcProviders[xl]
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach(e => {
      var n
      this.getProvider(e).updateNamespace((n = this.session) == null ? void 0 : n.namespaces[e])
    })
  }
  setNamespaces(e) {
    const { namespaces: n, optionalNamespaces: r, sessionProperties: i, scopedProperties: s } = e
    n && Object.keys(n).length && (this.namespaces = n),
      r && Object.keys(r).length && (this.optionalNamespaces = r),
      (this.sessionProperties = i),
      (this.scopedProperties = s)
  }
  validateChain(e) {
    const [n, r] = (e == null ? void 0 : e.split(':')) || ['', '']
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [n, r]
    if (
      n &&
      !Object.keys(this.namespaces || {})
        .map(c => nh(c))
        .includes(n)
    )
      throw new Error(
        `Namespace '${n}' is not configured. Please call connect() first with namespace config.`
      )
    if (n && r) return [n, r]
    const i = nh(Object.keys(this.namespaces)[0]),
      s = this.rpcProviders[i].getDefaultChain()
    return [i, s]
  }
  async requestAccounts() {
    const [e] = this.validateChain()
    return await this.getProvider(e).requestAccounts()
  }
  async onChainChanged(e, n = !1) {
    if (!this.namespaces) return
    const [r, i] = this.validateChain(e)
    i &&
      (n || this.getProvider(r).setDefaultChain(i),
      this.namespaces[r]
        ? (this.namespaces[r].defaultChain = i)
        : this.namespaces[`${r}:${i}`]
          ? (this.namespaces[`${r}:${i}`].defaultChain = i)
          : (this.namespaces[`${r}:${i}`] = { defaultChain: i }),
      this.events.emit('chainChanged', i),
      await this.persist('namespaces', this.namespaces))
  }
  onConnect() {
    this.createProviders(), this.events.emit('connect', { session: this.session })
  }
  async cleanup() {
    ;(this.namespaces = void 0),
      (this.optionalNamespaces = void 0),
      (this.sessionProperties = void 0),
      await this.deleteFromStore('namespaces'),
      await this.deleteFromStore('optionalNamespaces'),
      await this.deleteFromStore('sessionProperties'),
      (this.session = void 0),
      await this.cleanupPendingPairings({ deletePairings: !0 }),
      await this.cleanupStorage()
  }
  async persist(e, n) {
    var r
    const i = ((r = this.session) == null ? void 0 : r.topic) || ''
    await this.client.core.storage.setItem(`${lg}/${e}${i}`, n)
  }
  async getFromStore(e) {
    var n
    const r = ((n = this.session) == null ? void 0 : n.topic) || ''
    return await this.client.core.storage.getItem(`${lg}/${e}${r}`)
  }
  async deleteFromStore(e) {
    var n
    const r = ((n = this.session) == null ? void 0 : n.topic) || ''
    await this.client.core.storage.removeItem(`${lg}/${e}${r}`)
  }
  async cleanupStorage() {
    var e
    try {
      if (((e = this.client) == null ? void 0 : e.session.length) > 0) return
      const n = await this.client.core.storage.getKeys()
      for (const r of n) r.startsWith(lg) && (await this.client.core.storage.removeItem(r))
    } catch (n) {
      this.logger.warn('Failed to cleanup storage', n)
    }
  }
}
var id = {}
const tQ = 'https://secure.walletconnect.org/sdk',
  nQ =
    (typeof process < 'u' && typeof id < 'u' ? id.NEXT_PUBLIC_SECURE_SITE_SDK_URL : void 0) || tQ,
  rQ =
    (typeof process < 'u' && typeof id < 'u' ? id.NEXT_PUBLIC_DEFAULT_LOG_LEVEL : void 0) ||
    'error',
  iQ =
    (typeof process < 'u' && typeof id < 'u' ? id.NEXT_PUBLIC_SECURE_SITE_SDK_VERSION : void 0) ||
    '4',
  Re = {
    APP_EVENT_KEY: '@w3m-app/',
    FRAME_EVENT_KEY: '@w3m-frame/',
    RPC_METHOD_KEY: 'RPC_',
    STORAGE_KEY: '@appkit-wallet/',
    SESSION_TOKEN_KEY: 'SESSION_TOKEN_KEY',
    EMAIL_LOGIN_USED_KEY: 'EMAIL_LOGIN_USED_KEY',
    LAST_USED_CHAIN_KEY: 'LAST_USED_CHAIN_KEY',
    LAST_EMAIL_LOGIN_TIME: 'LAST_EMAIL_LOGIN_TIME',
    EMAIL: 'EMAIL',
    PREFERRED_ACCOUNT_TYPE: 'PREFERRED_ACCOUNT_TYPE',
    SMART_ACCOUNT_ENABLED: 'SMART_ACCOUNT_ENABLED',
    SMART_ACCOUNT_ENABLED_NETWORKS: 'SMART_ACCOUNT_ENABLED_NETWORKS',
    SOCIAL_USERNAME: 'SOCIAL_USERNAME',
    APP_SWITCH_NETWORK: '@w3m-app/SWITCH_NETWORK',
    APP_CONNECT_EMAIL: '@w3m-app/CONNECT_EMAIL',
    APP_CONNECT_DEVICE: '@w3m-app/CONNECT_DEVICE',
    APP_CONNECT_OTP: '@w3m-app/CONNECT_OTP',
    APP_CONNECT_SOCIAL: '@w3m-app/CONNECT_SOCIAL',
    APP_GET_SOCIAL_REDIRECT_URI: '@w3m-app/GET_SOCIAL_REDIRECT_URI',
    APP_GET_USER: '@w3m-app/GET_USER',
    APP_SIGN_OUT: '@w3m-app/SIGN_OUT',
    APP_IS_CONNECTED: '@w3m-app/IS_CONNECTED',
    APP_GET_CHAIN_ID: '@w3m-app/GET_CHAIN_ID',
    APP_RPC_REQUEST: '@w3m-app/RPC_REQUEST',
    APP_UPDATE_EMAIL: '@w3m-app/UPDATE_EMAIL',
    APP_UPDATE_EMAIL_PRIMARY_OTP: '@w3m-app/UPDATE_EMAIL_PRIMARY_OTP',
    APP_UPDATE_EMAIL_SECONDARY_OTP: '@w3m-app/UPDATE_EMAIL_SECONDARY_OTP',
    APP_AWAIT_UPDATE_EMAIL: '@w3m-app/AWAIT_UPDATE_EMAIL',
    APP_SYNC_THEME: '@w3m-app/SYNC_THEME',
    APP_SYNC_DAPP_DATA: '@w3m-app/SYNC_DAPP_DATA',
    APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS: '@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS',
    APP_INIT_SMART_ACCOUNT: '@w3m-app/INIT_SMART_ACCOUNT',
    APP_SET_PREFERRED_ACCOUNT: '@w3m-app/SET_PREFERRED_ACCOUNT',
    APP_CONNECT_FARCASTER: '@w3m-app/CONNECT_FARCASTER',
    APP_GET_FARCASTER_URI: '@w3m-app/GET_FARCASTER_URI',
    APP_RELOAD: '@w3m-app/RELOAD',
    FRAME_SWITCH_NETWORK_ERROR: '@w3m-frame/SWITCH_NETWORK_ERROR',
    FRAME_SWITCH_NETWORK_SUCCESS: '@w3m-frame/SWITCH_NETWORK_SUCCESS',
    FRAME_CONNECT_EMAIL_ERROR: '@w3m-frame/CONNECT_EMAIL_ERROR',
    FRAME_CONNECT_EMAIL_SUCCESS: '@w3m-frame/CONNECT_EMAIL_SUCCESS',
    FRAME_CONNECT_DEVICE_ERROR: '@w3m-frame/CONNECT_DEVICE_ERROR',
    FRAME_CONNECT_DEVICE_SUCCESS: '@w3m-frame/CONNECT_DEVICE_SUCCESS',
    FRAME_CONNECT_OTP_SUCCESS: '@w3m-frame/CONNECT_OTP_SUCCESS',
    FRAME_CONNECT_OTP_ERROR: '@w3m-frame/CONNECT_OTP_ERROR',
    FRAME_CONNECT_SOCIAL_SUCCESS: '@w3m-frame/CONNECT_SOCIAL_SUCCESS',
    FRAME_CONNECT_SOCIAL_ERROR: '@w3m-frame/CONNECT_SOCIAL_ERROR',
    FRAME_CONNECT_FARCASTER_SUCCESS: '@w3m-frame/CONNECT_FARCASTER_SUCCESS',
    FRAME_CONNECT_FARCASTER_ERROR: '@w3m-frame/CONNECT_FARCASTER_ERROR',
    FRAME_GET_FARCASTER_URI_SUCCESS: '@w3m-frame/GET_FARCASTER_URI_SUCCESS',
    FRAME_GET_FARCASTER_URI_ERROR: '@w3m-frame/GET_FARCASTER_URI_ERROR',
    FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS: '@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS',
    FRAME_GET_SOCIAL_REDIRECT_URI_ERROR: '@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR',
    FRAME_GET_USER_SUCCESS: '@w3m-frame/GET_USER_SUCCESS',
    FRAME_GET_USER_ERROR: '@w3m-frame/GET_USER_ERROR',
    FRAME_SIGN_OUT_SUCCESS: '@w3m-frame/SIGN_OUT_SUCCESS',
    FRAME_SIGN_OUT_ERROR: '@w3m-frame/SIGN_OUT_ERROR',
    FRAME_IS_CONNECTED_SUCCESS: '@w3m-frame/IS_CONNECTED_SUCCESS',
    FRAME_IS_CONNECTED_ERROR: '@w3m-frame/IS_CONNECTED_ERROR',
    FRAME_GET_CHAIN_ID_SUCCESS: '@w3m-frame/GET_CHAIN_ID_SUCCESS',
    FRAME_GET_CHAIN_ID_ERROR: '@w3m-frame/GET_CHAIN_ID_ERROR',
    FRAME_RPC_REQUEST_SUCCESS: '@w3m-frame/RPC_REQUEST_SUCCESS',
    FRAME_RPC_REQUEST_ERROR: '@w3m-frame/RPC_REQUEST_ERROR',
    FRAME_SESSION_UPDATE: '@w3m-frame/SESSION_UPDATE',
    FRAME_UPDATE_EMAIL_SUCCESS: '@w3m-frame/UPDATE_EMAIL_SUCCESS',
    FRAME_UPDATE_EMAIL_ERROR: '@w3m-frame/UPDATE_EMAIL_ERROR',
    FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: '@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS',
    FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: '@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR',
    FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: '@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS',
    FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: '@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR',
    FRAME_SYNC_THEME_SUCCESS: '@w3m-frame/SYNC_THEME_SUCCESS',
    FRAME_SYNC_THEME_ERROR: '@w3m-frame/SYNC_THEME_ERROR',
    FRAME_SYNC_DAPP_DATA_SUCCESS: '@w3m-frame/SYNC_DAPP_DATA_SUCCESS',
    FRAME_SYNC_DAPP_DATA_ERROR: '@w3m-frame/SYNC_DAPP_DATA_ERROR',
    FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS:
      '@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS',
    FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR:
      '@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR',
    FRAME_INIT_SMART_ACCOUNT_SUCCESS: '@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS',
    FRAME_INIT_SMART_ACCOUNT_ERROR: '@w3m-frame/INIT_SMART_ACCOUNT_ERROR',
    FRAME_SET_PREFERRED_ACCOUNT_SUCCESS: '@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS',
    FRAME_SET_PREFERRED_ACCOUNT_ERROR: '@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR',
    FRAME_READY: '@w3m-frame/READY',
    FRAME_RELOAD_SUCCESS: '@w3m-frame/RELOAD_SUCCESS',
    FRAME_RELOAD_ERROR: '@w3m-frame/RELOAD_ERROR',
    RPC_RESPONSE_TYPE_ERROR: 'RPC_RESPONSE_ERROR',
    RPC_RESPONSE_TYPE_TX: 'RPC_RESPONSE_TRANSACTION_HASH',
    RPC_RESPONSE_TYPE_OBJECT: 'RPC_RESPONSE_OBJECT'
  },
  yn = {
    SAFE_RPC_METHODS: [
      'eth_accounts',
      'eth_blockNumber',
      'eth_call',
      'eth_chainId',
      'eth_estimateGas',
      'eth_feeHistory',
      'eth_gasPrice',
      'eth_getAccount',
      'eth_getBalance',
      'eth_getBlockByHash',
      'eth_getBlockByNumber',
      'eth_getBlockReceipts',
      'eth_getBlockTransactionCountByHash',
      'eth_getBlockTransactionCountByNumber',
      'eth_getCode',
      'eth_getFilterChanges',
      'eth_getFilterLogs',
      'eth_getLogs',
      'eth_getProof',
      'eth_getStorageAt',
      'eth_getTransactionByBlockHashAndIndex',
      'eth_getTransactionByBlockNumberAndIndex',
      'eth_getTransactionByHash',
      'eth_getTransactionCount',
      'eth_getTransactionReceipt',
      'eth_getUncleCountByBlockHash',
      'eth_getUncleCountByBlockNumber',
      'eth_maxPriorityFeePerGas',
      'eth_newBlockFilter',
      'eth_newFilter',
      'eth_newPendingTransactionFilter',
      'eth_sendRawTransaction',
      'eth_syncing',
      'eth_uninstallFilter',
      'wallet_getCapabilities',
      'wallet_getCallsStatus',
      'eth_getUserOperationReceipt',
      'eth_estimateUserOperationGas',
      'eth_getUserOperationByHash',
      'eth_supportedEntryPoints',
      'wallet_getAssets'
    ],
    NOT_SAFE_RPC_METHODS: [
      'personal_sign',
      'eth_signTypedData_v4',
      'eth_sendTransaction',
      'solana_signMessage',
      'solana_signTransaction',
      'solana_signAllTransactions',
      'solana_signAndSendTransaction',
      'wallet_sendCalls',
      'wallet_grantPermissions',
      'wallet_revokePermissions',
      'eth_sendUserOperation'
    ],
    GET_CHAIN_ID: 'eth_chainId',
    RPC_METHOD_NOT_ALLOWED_MESSAGE: 'Requested RPC call is not allowed',
    RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: 'Action not allowed',
    ACCOUNT_TYPES: { EOA: 'eoa', SMART_ACCOUNT: 'smartAccount' }
  },
  sQ = {
    handleSolanaDeeplinkRedirect(t) {
      if (Q.state.activeChain === he.CHAIN.SOLANA) {
        const e = window.location.href,
          n = encodeURIComponent(e)
        if (t === 'Phantom' && !('phantom' in window)) {
          const r = e.startsWith('https') ? 'https' : 'http',
            i = e.split('/')[2],
            s = encodeURIComponent(`${r}://${i}`)
          window.location.href = `https://phantom.app/ul/browse/${n}?ref=${s}`
        }
        t === 'Coinbase Wallet' &&
          !('coinbaseSolana' in window) &&
          (window.location.href = `https://go.cb-w.com/dapp?cb_url=${n}`)
      }
    }
  },
  aQ = {
    getFeatureValue(t, e) {
      const n = e == null ? void 0 : e[t]
      return n === void 0 ? Fn.DEFAULT_FEATURES[t] : n
    },
    filterSocialsByPlatform(t) {
      if (!t || !t.length) return t
      if ($e.isTelegram()) {
        if ($e.isIos()) return t.filter(e => e !== 'google')
        if ($e.isMac()) return t.filter(e => e !== 'x')
        if ($e.isAndroid()) return t.filter(e => !['facebook', 'x'].includes(e))
      }
      return t
    }
  },
  ze = gn({
    features: Fn.DEFAULT_FEATURES,
    projectId: '',
    sdkType: 'appkit',
    sdkVersion: 'html-wagmi-undefined',
    defaultAccountTypes: Fn.DEFAULT_ACCOUNT_TYPES
  }),
  be = {
    state: ze,
    subscribeKey(t, e) {
      return zr(ze, t, e)
    },
    setOptions(t) {
      Object.assign(ze, t)
    },
    setFeatures(t) {
      if (!t) return
      ze.features || (ze.features = Fn.DEFAULT_FEATURES)
      const e = { ...ze.features, ...t }
      ;(ze.features = e),
        ze.features.socials &&
          (ze.features.socials = aQ.filterSocialsByPlatform(ze.features.socials))
    },
    setProjectId(t) {
      ze.projectId = t
    },
    setAllWallets(t) {
      ze.allWallets = t
    },
    setIncludeWalletIds(t) {
      ze.includeWalletIds = t
    },
    setExcludeWalletIds(t) {
      ze.excludeWalletIds = t
    },
    setFeaturedWalletIds(t) {
      ze.featuredWalletIds = t
    },
    setTokens(t) {
      ze.tokens = t
    },
    setTermsConditionsUrl(t) {
      ze.termsConditionsUrl = t
    },
    setPrivacyPolicyUrl(t) {
      ze.privacyPolicyUrl = t
    },
    setCustomWallets(t) {
      ze.customWallets = t
    },
    setIsSiweEnabled(t) {
      ze.isSiweEnabled = t
    },
    setIsUniversalProvider(t) {
      ze.isUniversalProvider = t
    },
    setSdkVersion(t) {
      ze.sdkVersion = t
    },
    setMetadata(t) {
      ze.metadata = t
    },
    setDisableAppend(t) {
      ze.disableAppend = t
    },
    setEIP6963Enabled(t) {
      ze.enableEIP6963 = t
    },
    setDebug(t) {
      ze.debug = t
    },
    setEnableWalletConnect(t) {
      ze.enableWalletConnect = t
    },
    setEnableWalletGuide(t) {
      ze.enableWalletGuide = t
    },
    setEnableAuthLogger(t) {
      ze.enableAuthLogger = t
    },
    setEnableWallets(t) {
      ze.enableWallets = t
    },
    setHasMultipleAddresses(t) {
      ze.hasMultipleAddresses = t
    },
    setSIWX(t) {
      ze.siwx = t
    },
    setConnectMethodsOrder(t) {
      ze.features = { ...ze.features, connectMethodsOrder: t }
    },
    setWalletFeaturesOrder(t) {
      ze.features = { ...ze.features, walletFeaturesOrder: t }
    },
    setSocialsOrder(t) {
      ze.features = { ...ze.features, socials: t }
    },
    setCollapseWallets(t) {
      ze.features = { ...ze.features, collapseWallets: t }
    },
    setEnableEmbedded(t) {
      ze.enableEmbedded = t
    },
    setAllowUnsupportedChain(t) {
      ze.allowUnsupportedChain = t
    },
    setManualWCControl(t) {
      ze.manualWCControl = t
    },
    setDefaultAccountTypes(t = {}) {
      Object.entries(t).forEach(([e, n]) => {
        n && (ze.defaultAccountTypes[e] = n)
      })
    },
    getSnapshot() {
      return Yc(ze)
    }
  },
  Dt = gn({ view: 'Connect', history: ['Connect'], transactionStack: [] }),
  ct = {
    state: Dt,
    subscribeKey(t, e) {
      return zr(Dt, t, e)
    },
    pushTransactionStack(t) {
      Dt.transactionStack.push(t)
    },
    popTransactionStack(t) {
      var n, r
      const e = Dt.transactionStack.pop()
      if (e)
        if (t) this.goBack(), (n = e == null ? void 0 : e.onCancel) == null || n.call(e)
        else {
          if (e.goBack) this.goBack()
          else if (e.replace) {
            const s = Dt.history.indexOf('ConnectingSiwe')
            s > 0 ? this.goBackToIndex(s - 1) : (Kn.close(), (Dt.history = []))
          } else e.view && this.reset(e.view)
          ;(r = e == null ? void 0 : e.onSuccess) == null || r.call(e)
        }
    },
    push(t, e) {
      t !== Dt.view && ((Dt.view = t), Dt.history.push(t), (Dt.data = e))
    },
    reset(t, e) {
      ;(Dt.view = t), (Dt.history = [t]), (Dt.data = e)
    },
    replace(t, e) {
      Dt.history.at(-1) === t ||
        ((Dt.view = t), (Dt.history[Dt.history.length - 1] = t), (Dt.data = e))
    },
    goBack() {
      var e
      const t = !Q.state.activeCaipAddress && this.state.view === 'ConnectingFarcaster'
      if (Dt.history.length > 1 && !Dt.history.includes('UnsupportedChain')) {
        Dt.history.pop()
        const [n] = Dt.history.slice(-1)
        n && (Dt.view = n)
      } else Kn.close()
      ;(e = Dt.data) != null && e.wallet && (Dt.data.wallet = void 0),
        setTimeout(() => {
          var n, r, i
          if (t) {
            Oe.setFarcasterUrl(void 0, Q.state.activeChain)
            const s = Ge.getAuthConnector()
            ;(n = s == null ? void 0 : s.provider) == null || n.reload()
            const c = Yc(be.state)
            ;(i = (r = s == null ? void 0 : s.provider) == null ? void 0 : r.syncDappData) ==
              null ||
              i.call(r, {
                metadata: c.metadata,
                sdkVersion: c.sdkVersion,
                projectId: c.projectId,
                sdkType: c.sdkType
              })
          }
        }, 100)
    },
    goBackToIndex(t) {
      if (Dt.history.length > 1) {
        Dt.history = Dt.history.slice(0, t + 1)
        const [e] = Dt.history.slice(-1)
        e && (Dt.view = e)
      }
    }
  },
  Ea = gn({ themeMode: 'dark', themeVariables: {}, w3mThemeVariables: void 0 }),
  Ir = {
    state: Ea,
    subscribe(t) {
      return Rr(Ea, () => t(Ea))
    },
    setThemeMode(t) {
      Ea.themeMode = t
      try {
        const e = Ge.getAuthConnector()
        if (e) {
          const n = Ir.getSnapshot().themeVariables
          e.provider.syncTheme({ themeMode: t, themeVariables: n, w3mThemeVariables: Ia(n, t) })
        }
      } catch {
        console.info('Unable to sync theme to auth connector')
      }
    },
    setThemeVariables(t) {
      Ea.themeVariables = { ...Ea.themeVariables, ...t }
      try {
        const e = Ge.getAuthConnector()
        if (e) {
          const n = Ir.getSnapshot().themeVariables
          e.provider.syncTheme({
            themeVariables: n,
            w3mThemeVariables: Ia(Ea.themeVariables, Ea.themeMode)
          })
        }
      } catch {
        console.info('Unable to sync theme to auth connector')
      }
    },
    getSnapshot() {
      return Yc(Ea)
    }
  },
  NN = { eip155: void 0, solana: void 0, polkadot: void 0, bip122: void 0 },
  Nt = gn({
    allConnectors: [],
    connectors: [],
    activeConnector: void 0,
    filterByNamespace: void 0,
    activeConnectorIds: { ...NN }
  }),
  Ge = {
    state: Nt,
    subscribe(t) {
      return Rr(Nt, () => {
        t(Nt)
      })
    },
    subscribeKey(t, e) {
      return zr(Nt, t, e)
    },
    initialize(t) {
      t.forEach(e => {
        const n = Ne.getConnectedConnectorId(e)
        n && this.setConnectorId(n, e)
      })
    },
    setActiveConnector(t) {
      t && (Nt.activeConnector = Zc(t))
    },
    setConnectors(t) {
      t
        .filter(
          n =>
            !Nt.allConnectors.some(
              r =>
                r.id === n.id &&
                this.getConnectorName(r.name) === this.getConnectorName(n.name) &&
                r.chain === n.chain
            )
        )
        .forEach(n => {
          n.type !== 'MULTI_CHAIN' && Nt.allConnectors.push(Zc(n))
        }),
        (Nt.connectors = this.mergeMultiChainConnectors(Nt.allConnectors))
    },
    removeAdapter(t) {
      ;(Nt.allConnectors = Nt.allConnectors.filter(e => e.chain !== t)),
        (Nt.connectors = this.mergeMultiChainConnectors(Nt.allConnectors))
    },
    mergeMultiChainConnectors(t) {
      const e = this.generateConnectorMapByName(t),
        n = []
      return (
        e.forEach(r => {
          const i = r[0],
            s = (i == null ? void 0 : i.id) === he.CONNECTOR_ID.AUTH
          r.length > 1 && i
            ? n.push({
                name: i.name,
                imageUrl: i.imageUrl,
                imageId: i.imageId,
                connectors: [...r],
                type: s ? 'AUTH' : 'MULTI_CHAIN',
                chain: 'eip155',
                id: (i == null ? void 0 : i.id) || ''
              })
            : i && n.push(i)
        }),
        n
      )
    },
    generateConnectorMapByName(t) {
      const e = new Map()
      return (
        t.forEach(n => {
          const { name: r } = n,
            i = this.getConnectorName(r)
          if (!i) return
          const s = e.get(i) || []
          s.find(u => u.chain === n.chain) || s.push(n), e.set(i, s)
        }),
        e
      )
    },
    getConnectorName(t) {
      return t && ({ 'Trust Wallet': 'Trust' }[t] || t)
    },
    getUniqueConnectorsByName(t) {
      const e = []
      return (
        t.forEach(n => {
          e.find(r => r.chain === n.chain) || e.push(n)
        }),
        e
      )
    },
    addConnector(t) {
      var e, n, r
      if (t.id === he.CONNECTOR_ID.AUTH) {
        const i = t,
          s = Yc(be.state),
          c = Ir.getSnapshot().themeMode,
          u = Ir.getSnapshot().themeVariables
        ;(n = (e = i == null ? void 0 : i.provider) == null ? void 0 : e.syncDappData) == null ||
          n.call(e, {
            metadata: s.metadata,
            sdkVersion: s.sdkVersion,
            projectId: s.projectId,
            sdkType: s.sdkType
          }),
          (r = i == null ? void 0 : i.provider) == null ||
            r.syncTheme({ themeMode: c, themeVariables: u, w3mThemeVariables: Ia(u, c) }),
          this.setConnectors([t])
      } else this.setConnectors([t])
    },
    getAuthConnector(t) {
      var r
      const e = t || Q.state.activeChain,
        n = Nt.connectors.find(i => i.id === he.CONNECTOR_ID.AUTH)
      if (n)
        return (r = n == null ? void 0 : n.connectors) != null && r.length
          ? n.connectors.find(s => s.chain === e)
          : n
    },
    getAnnouncedConnectorRdns() {
      return Nt.connectors
        .filter(t => t.type === 'ANNOUNCED')
        .map(t => {
          var e
          return (e = t.info) == null ? void 0 : e.rdns
        })
    },
    getConnectorById(t) {
      return Nt.allConnectors.find(e => e.id === t)
    },
    getConnector(t, e) {
      return Nt.allConnectors.find(n => {
        var r
        return n.explorerId === t || ((r = n.info) == null ? void 0 : r.rdns) === e
      })
    },
    syncIfAuthConnector(t) {
      var s, c
      if (t.id !== 'ID_AUTH') return
      const e = t,
        n = Yc(be.state),
        r = Ir.getSnapshot().themeMode,
        i = Ir.getSnapshot().themeVariables
      ;(c = (s = e == null ? void 0 : e.provider) == null ? void 0 : s.syncDappData) == null ||
        c.call(s, {
          metadata: n.metadata,
          sdkVersion: n.sdkVersion,
          sdkType: n.sdkType,
          projectId: n.projectId
        }),
        e.provider.syncTheme({ themeMode: r, themeVariables: i, w3mThemeVariables: Ia(i, r) })
    },
    getConnectorsByNamespace(t) {
      const e = Nt.allConnectors.filter(n => n.chain === t)
      return this.mergeMultiChainConnectors(e)
    },
    selectWalletConnector(t) {
      const e = Ge.getConnector(t.id, t.rdns)
      Q.state.activeChain === he.CHAIN.SOLANA &&
        sQ.handleSolanaDeeplinkRedirect((e == null ? void 0 : e.name) || t.name || ''),
        e
          ? ct.push('ConnectingExternal', { connector: e })
          : ct.push('ConnectingWalletConnect', { wallet: t })
    },
    getConnectors(t) {
      return t ? this.getConnectorsByNamespace(t) : this.mergeMultiChainConnectors(Nt.allConnectors)
    },
    setFilterByNamespace(t) {
      ;(Nt.filterByNamespace = t), (Nt.connectors = this.getConnectors(t))
    },
    clearNamespaceFilter() {
      ;(Nt.filterByNamespace = void 0), (Nt.connectors = this.getConnectors())
    },
    setConnectorId(t, e) {
      t &&
        ((Nt.activeConnectorIds = { ...Nt.activeConnectorIds, [e]: t }),
        Ne.setConnectedConnectorId(e, t))
    },
    removeConnectorId(t) {
      ;(Nt.activeConnectorIds = { ...Nt.activeConnectorIds, [t]: void 0 }),
        Ne.deleteConnectedConnectorId(t)
    },
    getConnectorId(t) {
      if (t) return Nt.activeConnectorIds[t]
    },
    isConnected(t) {
      return t ? !!Nt.activeConnectorIds[t] : Object.values(Nt.activeConnectorIds).some(e => !!e)
    },
    resetConnectorIds() {
      Nt.activeConnectorIds = { ...NN }
    }
  },
  yo = gn({ message: '', variant: 'info', open: !1 }),
  Vc = {
    state: yo,
    subscribeKey(t, e) {
      return zr(yo, t, e)
    },
    open(t, e) {
      const { debug: n } = be.state,
        { shortMessage: r, longMessage: i } = t
      n && ((yo.message = r), (yo.variant = e), (yo.open = !0)),
        i && console.error(typeof i == 'function' ? i() : i)
    },
    close() {
      ;(yo.open = !1), (yo.message = ''), (yo.variant = 'info')
    }
  },
  oQ = $e.getAnalyticsUrl(),
  cQ = new xm({ baseUrl: oQ, clientId: null }),
  uQ = ['MODAL_CREATED'],
  Aa = gn({
    timestamp: Date.now(),
    reportedErrors: {},
    data: { type: 'track', event: 'MODAL_CREATED' }
  }),
  Ft = {
    state: Aa,
    subscribe(t) {
      return Rr(Aa, () => t(Aa))
    },
    getSdkProperties() {
      const { projectId: t, sdkType: e, sdkVersion: n } = be.state
      return { projectId: t, st: e, sv: n || 'html-wagmi-4.2.2' }
    },
    async _sendAnalyticsEvent(t) {
      try {
        const e = Oe.state.address
        if (uQ.includes(t.data.event) || typeof window > 'u') return
        await cQ.post({
          path: '/e',
          params: Ft.getSdkProperties(),
          body: {
            eventId: $e.getUUID(),
            url: window.location.href,
            domain: window.location.hostname,
            timestamp: t.timestamp,
            props: { ...t.data, address: e }
          }
        }),
          (Aa.reportedErrors.FORBIDDEN = !1)
      } catch (e) {
        e instanceof Error &&
          e.cause instanceof Response &&
          e.cause.status === he.HTTP_STATUS_CODES.FORBIDDEN &&
          !Aa.reportedErrors.FORBIDDEN &&
          (Vc.open(
            {
              shortMessage: 'Invalid App Configuration',
              longMessage: `Origin ${eh() ? window.origin : 'uknown'} not found on Allowlist - update configuration on cloud.reown.com`
            },
            'error'
          ),
          (Aa.reportedErrors.FORBIDDEN = !0))
      }
    },
    sendEvent(t) {
      var e
      ;(Aa.timestamp = Date.now()),
        (Aa.data = t),
        (e = be.state.features) != null && e.analytics && Ft._sendAnalyticsEvent(Aa)
    }
  },
  Tc = Object.freeze({ message: '', variant: 'success', svg: void 0, open: !1, autoClose: !0 }),
  Yn = gn({ ...Tc }),
  $t = {
    state: Yn,
    subscribeKey(t, e) {
      return zr(Yn, t, e)
    },
    showLoading(t, e = {}) {
      this._showMessage({ message: t, variant: 'loading', ...e })
    },
    showSuccess(t) {
      this._showMessage({ message: t, variant: 'success' })
    },
    showSvg(t, e) {
      this._showMessage({ message: t, svg: e })
    },
    showError(t) {
      const e = $e.parseError(t)
      this._showMessage({ message: e, variant: 'error' })
    },
    hide() {
      ;(Yn.message = Tc.message),
        (Yn.variant = Tc.variant),
        (Yn.svg = Tc.svg),
        (Yn.open = Tc.open),
        (Yn.autoClose = Tc.autoClose)
    },
    _showMessage({ message: t, svg: e, variant: n = 'success', autoClose: r = Tc.autoClose }) {
      Yn.open
        ? ((Yn.open = !1),
          setTimeout(() => {
            ;(Yn.message = t), (Yn.variant = n), (Yn.svg = e), (Yn.open = !0), (Yn.autoClose = r)
          }, 150))
        : ((Yn.message = t), (Yn.variant = n), (Yn.svg = e), (Yn.open = !0), (Yn.autoClose = r))
    }
  },
  fh = {
    getSIWX() {
      return be.state.siwx
    },
    async initializeIfEnabled() {
      var s
      const t = be.state.siwx,
        e = Q.getActiveCaipAddress()
      if (!(t && e)) return
      const [n, r, i] = e.split(':')
      if (Q.checkIfSupportedNetwork(n))
        try {
          if ((await t.getSessions(`${n}:${r}`, i)).length) return
          await Kn.open({ view: 'SIWXSignMessage' })
        } catch (c) {
          console.error('SIWXUtil:initializeIfEnabled', c),
            Ft.sendEvent({
              type: 'track',
              event: 'SIWX_AUTH_ERROR',
              properties: this.getSIWXEventProperties()
            }),
            await ((s = ot._getClient()) == null ? void 0 : s.disconnect().catch(console.error)),
            ct.reset('Connect'),
            $t.showError('A problem occurred while trying initialize authentication')
        }
    },
    async requestSignMessage() {
      const t = be.state.siwx,
        e = $e.getPlainAddress(Q.getActiveCaipAddress()),
        n = Q.getActiveCaipNetwork(),
        r = ot._getClient()
      if (!t) throw new Error('SIWX is not enabled')
      if (!e) throw new Error('No ActiveCaipAddress found')
      if (!n) throw new Error('No ActiveCaipNetwork or client found')
      if (!r) throw new Error('No ConnectionController client found')
      try {
        const i = await t.createMessage({ chainId: n.caipNetworkId, accountAddress: e }),
          s = i.toString()
        Ge.getConnectorId(n.chainNamespace) === he.CONNECTOR_ID.AUTH &&
          ct.pushTransactionStack({ view: null, goBack: !1, replace: !0 })
        const u = await r.signMessage(s)
        await t.addSession({ data: i, message: s, signature: u }),
          Kn.close(),
          Ft.sendEvent({
            type: 'track',
            event: 'SIWX_AUTH_SUCCESS',
            properties: this.getSIWXEventProperties()
          })
      } catch (i) {
        const s = this.getSIWXEventProperties()
        ;(!Kn.state.open || ct.state.view === 'ApproveTransaction') &&
          (await Kn.open({ view: 'SIWXSignMessage' })),
          s.isSmartAccount
            ? $t.showError('This application might not support Smart Accounts')
            : $t.showError('Signature declined'),
          Ft.sendEvent({ type: 'track', event: 'SIWX_AUTH_ERROR', properties: s }),
          console.error('SWIXUtil:requestSignMessage', i)
      }
    },
    async cancelSignMessage() {
      var t
      try {
        const e = this.getSIWX()
        ;((t = e == null ? void 0 : e.getRequired) == null ? void 0 : t.call(e))
          ? await ot.disconnect()
          : Kn.close(),
          ct.reset('Connect'),
          Ft.sendEvent({
            event: 'CLICK_CANCEL_SIWX',
            type: 'track',
            properties: this.getSIWXEventProperties()
          })
      } catch (e) {
        console.error('SIWXUtil:cancelSignMessage', e)
      }
    },
    async getSessions() {
      const t = be.state.siwx,
        e = $e.getPlainAddress(Q.getActiveCaipAddress()),
        n = Q.getActiveCaipNetwork()
      return t && e && n ? t.getSessions(n.caipNetworkId, e) : []
    },
    async isSIWXCloseDisabled() {
      var e
      const t = this.getSIWX()
      if (t) {
        const n = ct.state.view === 'ApproveTransaction',
          r = ct.state.view === 'SIWXSignMessage'
        if (n || r)
          return (
            ((e = t.getRequired) == null ? void 0 : e.call(t)) &&
            (await this.getSessions()).length === 0
          )
      }
      return !1
    },
    async universalProviderAuthenticate({ universalProvider: t, chains: e, methods: n }) {
      var u, f, d
      const r = fh.getSIWX(),
        i = new Set(e.map(p => p.split(':')[0]))
      if (!r || i.size !== 1 || !i.has('eip155')) return !1
      const s = await r.createMessage({
          chainId: ((u = Q.getActiveCaipNetwork()) == null ? void 0 : u.caipNetworkId) || '',
          accountAddress: ''
        }),
        c = await t.authenticate({
          nonce: s.nonce,
          domain: s.domain,
          uri: s.uri,
          exp: s.expirationTime,
          iat: s.issuedAt,
          nbf: s.notBefore,
          requestId: s.requestId,
          version: s.version,
          resources: s.resources,
          statement: s.statement,
          chainId: s.chainId,
          methods: n,
          chains: [s.chainId, ...e.filter(p => p !== s.chainId)]
        })
      if (
        ($t.showLoading('Authenticating...', { autoClose: !1 }),
        Oe.setConnectedWalletInfo(
          {
            ...c.session.peer.metadata,
            name: c.session.peer.metadata.name,
            icon: (f = c.session.peer.metadata.icons) == null ? void 0 : f[0],
            type: 'WALLET_CONNECT'
          },
          Array.from(i)[0]
        ),
        (d = c == null ? void 0 : c.auths) != null && d.length)
      ) {
        const p = c.auths.map(g => {
          const m = t.client.formatAuthMessage({ request: g.p, iss: g.p.iss })
          return {
            data: {
              ...g.p,
              accountAddress: g.p.iss.split(':').slice(-1).join(''),
              chainId: g.p.iss.split(':').slice(2, 4).join(':'),
              uri: g.p.aud,
              version: g.p.version || s.version,
              expirationTime: g.p.exp,
              issuedAt: g.p.iat,
              notBefore: g.p.nbf
            },
            message: m,
            signature: g.s.s,
            cacao: g
          }
        })
        try {
          await r.setSessions(p),
            Ft.sendEvent({
              type: 'track',
              event: 'SIWX_AUTH_SUCCESS',
              properties: fh.getSIWXEventProperties()
            })
        } catch (g) {
          throw (
            (console.error('SIWX:universalProviderAuth - failed to set sessions', g),
            Ft.sendEvent({
              type: 'track',
              event: 'SIWX_AUTH_ERROR',
              properties: fh.getSIWXEventProperties()
            }),
            await t.disconnect().catch(console.error),
            g)
          )
        } finally {
          $t.hide()
        }
      }
      return !0
    },
    getSIWXEventProperties() {
      var t
      return {
        network: ((t = Q.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId) || '',
        isSmartAccount: Oe.state.preferredAccountType === yn.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    },
    async clearSessions() {
      const t = this.getSIWX()
      t && (await t.setSessions([]))
    }
  },
  un = gn({
    transactions: [],
    coinbaseTransactions: {},
    transactionsByYear: {},
    lastNetworkInView: void 0,
    loading: !1,
    empty: !1,
    next: void 0
  }),
  lQ = {
    state: un,
    subscribe(t) {
      return Rr(un, () => t(un))
    },
    setLastNetworkInView(t) {
      un.lastNetworkInView = t
    },
    async fetchTransactions(t, e) {
      var n
      if (!t) throw new Error("Transactions can't be fetched without an accountAddress")
      un.loading = !0
      try {
        const r = await Me.fetchTransactions({
            account: t,
            cursor: un.next,
            onramp: e,
            cache: e === 'coinbase' ? 'no-cache' : void 0,
            chainId: (n = Q.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
          }),
          i = this.filterSpamTransactions(r.data),
          s = this.filterByConnectedChain(i),
          c = [...un.transactions, ...s]
        ;(un.loading = !1),
          e === 'coinbase'
            ? (un.coinbaseTransactions = this.groupTransactionsByYearAndMonth(
                un.coinbaseTransactions,
                r.data
              ))
            : ((un.transactions = c),
              (un.transactionsByYear = this.groupTransactionsByYearAndMonth(
                un.transactionsByYear,
                s
              ))),
          (un.empty = c.length === 0),
          (un.next = r.next ? r.next : void 0)
      } catch {
        Ft.sendEvent({
          type: 'track',
          event: 'ERROR_FETCH_TRANSACTIONS',
          properties: {
            address: t,
            projectId: be.state.projectId,
            cursor: un.next,
            isSmartAccount: Oe.state.preferredAccountType === yn.ACCOUNT_TYPES.SMART_ACCOUNT
          }
        }),
          $t.showError('Failed to fetch transactions'),
          (un.loading = !1),
          (un.empty = !0),
          (un.next = void 0)
      }
    },
    groupTransactionsByYearAndMonth(t = {}, e = []) {
      const n = t
      return (
        e.forEach(r => {
          const i = new Date(r.metadata.minedAt).getFullYear(),
            s = new Date(r.metadata.minedAt).getMonth(),
            c = n[i] ?? {},
            f = (c[s] ?? []).filter(d => d.id !== r.id)
          n[i] = {
            ...c,
            [s]: [...f, r].sort(
              (d, p) =>
                new Date(p.metadata.minedAt).getTime() - new Date(d.metadata.minedAt).getTime()
            )
          }
        }),
        n
      )
    },
    filterSpamTransactions(t) {
      return t.filter(
        e =>
          !e.transfers.every(r => {
            var i
            return ((i = r.nft_info) == null ? void 0 : i.flags.is_spam) === !0
          })
      )
    },
    filterByConnectedChain(t) {
      var r
      const e = (r = Q.state.activeCaipNetwork) == null ? void 0 : r.caipNetworkId
      return t.filter(i => i.metadata.chain === e)
    },
    clearCursor() {
      un.next = void 0
    },
    resetTransactions() {
      ;(un.transactions = []),
        (un.transactionsByYear = {}),
        (un.lastNetworkInView = void 0),
        (un.loading = !1),
        (un.empty = !1),
        (un.next = void 0)
    }
  },
  ln = gn({ wcError: !1, buffering: !1, status: 'disconnected' })
let Cl
const ot = {
    state: ln,
    subscribeKey(t, e) {
      return zr(ln, t, e)
    },
    _getClient() {
      return ln._client
    },
    setClient(t) {
      ln._client = Zc(t)
    },
    async connectWalletConnect() {
      var t, e, n, r
      if ($e.isTelegram() || ($e.isSafari() && $e.isIos())) {
        if (Cl) {
          await Cl, (Cl = void 0)
          return
        }
        if (!$e.isPairingExpired(ln == null ? void 0 : ln.wcPairingExpiry)) {
          const i = ln.wcUri
          ln.wcUri = i
          return
        }
        ;(Cl =
          (e = (t = this._getClient()) == null ? void 0 : t.connectWalletConnect) == null
            ? void 0
            : e.call(t).catch(() => {})),
          (this.state.status = 'connecting'),
          await Cl,
          (Cl = void 0),
          (ln.wcPairingExpiry = void 0),
          (this.state.status = 'connected')
      } else
        await ((r = (n = this._getClient()) == null ? void 0 : n.connectWalletConnect) == null
          ? void 0
          : r.call(n))
    },
    async connectExternal(t, e, n = !0) {
      var r, i
      await ((i = (r = this._getClient()) == null ? void 0 : r.connectExternal) == null
        ? void 0
        : i.call(r, t)),
        n && Q.setActiveNamespace(e)
    },
    async reconnectExternal(t) {
      var n, r
      await ((r = (n = this._getClient()) == null ? void 0 : n.reconnectExternal) == null
        ? void 0
        : r.call(n, t))
      const e = t.chain || Q.state.activeChain
      e && Ge.setConnectorId(t.id, e)
    },
    async setPreferredAccountType(t) {
      var n
      Kn.setLoading(!0, Q.state.activeChain)
      const e = Ge.getAuthConnector()
      e &&
        (await (e == null ? void 0 : e.provider.setPreferredAccount(t)),
        await this.reconnectExternal(e),
        Kn.setLoading(!1, Q.state.activeChain),
        Ft.sendEvent({
          type: 'track',
          event: 'SET_PREFERRED_ACCOUNT_TYPE',
          properties: {
            accountType: t,
            network: ((n = Q.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId) || ''
          }
        }))
    },
    async signMessage(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.signMessage(t)
    },
    parseUnits(t, e) {
      var n
      return (n = this._getClient()) == null ? void 0 : n.parseUnits(t, e)
    },
    formatUnits(t, e) {
      var n
      return (n = this._getClient()) == null ? void 0 : n.formatUnits(t, e)
    },
    async sendTransaction(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.sendTransaction(t)
    },
    async getCapabilities(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.getCapabilities(t)
    },
    async grantPermissions(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.grantPermissions(t)
    },
    async walletGetAssets(t) {
      var e
      return ((e = this._getClient()) == null ? void 0 : e.walletGetAssets(t)) ?? {}
    },
    async estimateGas(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.estimateGas(t)
    },
    async writeContract(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.writeContract(t)
    },
    async getEnsAddress(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.getEnsAddress(t)
    },
    async getEnsAvatar(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.getEnsAvatar(t)
    },
    checkInstalled(t) {
      var e, n
      return (
        ((n = (e = this._getClient()) == null ? void 0 : e.checkInstalled) == null
          ? void 0
          : n.call(e, t)) || !1
      )
    },
    resetWcConnection() {
      ;(ln.wcUri = void 0),
        (ln.wcPairingExpiry = void 0),
        (ln.wcLinking = void 0),
        (ln.recentWallet = void 0),
        (ln.status = 'disconnected'),
        lQ.resetTransactions(),
        Ne.deleteWalletConnectDeepLink()
    },
    resetUri() {
      ;(ln.wcUri = void 0), (ln.wcPairingExpiry = void 0)
    },
    finalizeWcConnection() {
      var n, r
      const { wcLinking: t, recentWallet: e } = ot.state
      t && Ne.setWalletConnectDeepLink(t),
        e && Ne.setAppKitRecent(e),
        Ft.sendEvent({
          type: 'track',
          event: 'CONNECT_SUCCESS',
          properties: {
            method: t ? 'mobile' : 'qrcode',
            name:
              ((r = (n = ct.state.data) == null ? void 0 : n.wallet) == null ? void 0 : r.name) ||
              'Unknown'
          }
        })
    },
    setWcBasic(t) {
      ln.wcBasic = t
    },
    setUri(t) {
      ;(ln.wcUri = t), (ln.wcPairingExpiry = $e.getPairingExpiry())
    },
    setWcLinking(t) {
      ln.wcLinking = t
    },
    setWcError(t) {
      ;(ln.wcError = t), (ln.buffering = !1)
    },
    setRecentWallet(t) {
      ln.recentWallet = t
    },
    setBuffering(t) {
      ln.buffering = t
    },
    setStatus(t) {
      ln.status = t
    },
    async disconnect() {
      try {
        Kn.setLoading(!0), await fh.clearSessions(), await Q.disconnect(), Kn.setLoading(!1)
      } catch {
        throw new Error('Failed to disconnect')
      }
    }
  },
  Kf = gn({
    loading: !1,
    open: !1,
    selectedNetworkId: void 0,
    activeChain: void 0,
    initialized: !1
  }),
  Ra = {
    state: Kf,
    subscribe(t) {
      return Rr(Kf, () => t(Kf))
    },
    set(t) {
      Object.assign(Kf, { ...Kf, ...t })
    }
  }
function Yt(t, e, n) {
  const r = t[e.name]
  if (typeof r == 'function') return r
  const i = t[n]
  return typeof i == 'function' ? i : s => e(t, s)
}
function Go(t, { includeName: e = !1 } = {}) {
  if (t.type !== 'function' && t.type !== 'event' && t.type !== 'error') throw new AQ(t.type)
  return `${t.name}(${zm(t.inputs, { includeName: e })})`
}
function zm(t, { includeName: e = !1 } = {}) {
  return t ? t.map(n => dQ(n, { includeName: e })).join(e ? ', ' : ',') : ''
}
function dQ(t, { includeName: e }) {
  return t.type.startsWith('tuple')
    ? `(${zm(t.components, { includeName: e })})${t.type.slice(5)}`
    : t.type + (e && t.name ? ` ${t.name}` : '')
}
function Ua(t, { strict: e = !0 } = {}) {
  return !t || typeof t != 'string' ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith('0x')
}
function lr(t) {
  return Ua(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length
}
const IN = '2.24.1'
let Wf = {
    getDocsUrl: ({ docsBaseUrl: t, docsPath: e = '', docsSlug: n }) =>
      e ? `${t ?? 'https://viem.sh'}${e}${n ? `#${n}` : ''}` : void 0,
    version: `viem@${IN}`
  },
  fe = class Kw extends Error {
    constructor(e, n = {}) {
      var u
      const r = (() => {
          var f
          return n.cause instanceof Kw
            ? n.cause.details
            : (f = n.cause) != null && f.message
              ? n.cause.message
              : n.details
        })(),
        i = (n.cause instanceof Kw && n.cause.docsPath) || n.docsPath,
        s = (u = Wf.getDocsUrl) == null ? void 0 : u.call(Wf, { ...n, docsPath: i }),
        c = [
          e || 'An error occurred.',
          '',
          ...(n.metaMessages ? [...n.metaMessages, ''] : []),
          ...(s ? [`Docs: ${s}`] : []),
          ...(r ? [`Details: ${r}`] : []),
          ...(Wf.version ? [`Version: ${Wf.version}`] : [])
        ].join(`
`)
      super(c, n.cause ? { cause: n.cause } : void 0),
        Object.defineProperty(this, 'details', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'docsPath', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'metaMessages', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'shortMessage', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'version', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'name', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: 'BaseError'
        }),
        (this.details = r),
        (this.docsPath = i),
        (this.metaMessages = n.metaMessages),
        (this.name = n.name ?? this.name),
        (this.shortMessage = e),
        (this.version = IN)
    }
    walk(e) {
      return ON(this, e)
    }
  }
function ON(t, e) {
  return e != null && e(t)
    ? t
    : t && typeof t == 'object' && 'cause' in t && t.cause !== void 0
      ? ON(t.cause, e)
      : e
        ? null
        : t
}
class fQ extends fe {
  constructor({ docsPath: e }) {
    super(
      [
        'A constructor was not found on the ABI.',
        'Make sure you are using the correct ABI and that the constructor exists on it.'
      ].join(`
`),
      { docsPath: e, name: 'AbiConstructorNotFoundError' }
    )
  }
}
class s4 extends fe {
  constructor({ docsPath: e }) {
    super(
      [
        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',
        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.'
      ].join(`
`),
      { docsPath: e, name: 'AbiConstructorParamsNotFoundError' }
    )
  }
}
class RN extends fe {
  constructor({ data: e, params: n, size: r }) {
    super(
      [`Data size of ${r} bytes is too small for given parameters.`].join(`
`),
      {
        metaMessages: [`Params: (${zm(n, { includeName: !0 })})`, `Data:   ${e} (${r} bytes)`],
        name: 'AbiDecodingDataSizeTooSmallError'
      }
    ),
      Object.defineProperty(this, 'data', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'params', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'size', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.data = e),
      (this.params = n),
      (this.size = r)
  }
}
class qm extends fe {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: 'AbiDecodingZeroDataError'
    })
  }
}
class hQ extends fe {
  constructor({ expectedLength: e, givenLength: n, type: r }) {
    super(
      [
        `ABI encoding array length mismatch for type ${r}.`,
        `Expected length: ${e}`,
        `Given length: ${n}`
      ].join(`
`),
      { name: 'AbiEncodingArrayLengthMismatchError' }
    )
  }
}
class pQ extends fe {
  constructor({ expectedSize: e, value: n }) {
    super(`Size of bytes "${n}" (bytes${lr(n)}) does not match expected size (bytes${e}).`, {
      name: 'AbiEncodingBytesSizeMismatchError'
    })
  }
}
class gQ extends fe {
  constructor({ expectedLength: e, givenLength: n }) {
    super(
      [
        'ABI encoding params/values length mismatch.',
        `Expected length (params): ${e}`,
        `Given length (values): ${n}`
      ].join(`
`),
      { name: 'AbiEncodingLengthMismatchError' }
    )
  }
}
class DN extends fe {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Encoded error signature "${e}" not found on ABI.`,
        'Make sure you are using the correct ABI and that the error exists on it.',
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`
      ].join(`
`),
      { docsPath: n, name: 'AbiErrorSignatureNotFoundError' }
    ),
      Object.defineProperty(this, 'signature', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.signature = e)
  }
}
class mQ extends fe {
  constructor({ docsPath: e }) {
    super('Cannot extract event signature from empty topics.', {
      docsPath: e,
      name: 'AbiEventSignatureEmptyTopicsError'
    })
  }
}
class PN extends fe {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Encoded event signature "${e}" not found on ABI.`,
        'Make sure you are using the correct ABI and that the event exists on it.',
        `You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`
      ].join(`
`),
      { docsPath: n, name: 'AbiEventSignatureNotFoundError' }
    )
  }
}
class Jg extends fe {
  constructor(e, { docsPath: n } = {}) {
    super(
      [
        `Function ${e ? `"${e}" ` : ''}not found on ABI.`,
        'Make sure you are using the correct ABI and that the function exists on it.'
      ].join(`
`),
      { docsPath: n, name: 'AbiFunctionNotFoundError' }
    )
  }
}
class bQ extends fe {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Function "${e}" does not contain any \`outputs\` on ABI.`,
        'Cannot decode function result without knowing what the parameter types are.',
        'Make sure you are using the correct ABI and that the function exists on it.'
      ].join(`
`),
      { docsPath: n, name: 'AbiFunctionOutputsNotFoundError' }
    )
  }
}
class yQ extends fe {
  constructor(e, n) {
    super('Found ambiguous types in overloaded ABI items.', {
      metaMessages: [
        `\`${e.type}\` in \`${Go(e.abiItem)}\`, and`,
        `\`${n.type}\` in \`${Go(n.abiItem)}\``,
        '',
        'These types encode differently and cannot be distinguished at runtime.',
        'Remove one of the ambiguous items in the ABI.'
      ],
      name: 'AbiItemAmbiguityError'
    })
  }
}
class Ww extends fe {
  constructor({ abiItem: e, data: n, params: r, size: i }) {
    super(
      [`Data size of ${i} bytes is too small for non-indexed event parameters.`].join(`
`),
      {
        metaMessages: [`Params: (${zm(r, { includeName: !0 })})`, `Data:   ${n} (${i} bytes)`],
        name: 'DecodeLogDataMismatch'
      }
    ),
      Object.defineProperty(this, 'abiItem', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'data', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'params', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'size', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.abiItem = e),
      (this.data = n),
      (this.params = r),
      (this.size = i)
  }
}
class MN extends fe {
  constructor({ abiItem: e, param: n }) {
    super(
      [
        `Expected a topic for indexed event parameter${n.name ? ` "${n.name}"` : ''} on event "${Go(e, { includeName: !0 })}".`
      ].join(`
`),
      { name: 'DecodeLogTopicsMismatch' }
    ),
      Object.defineProperty(this, 'abiItem', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.abiItem = e)
  }
}
class vQ extends fe {
  constructor(e, { docsPath: n }) {
    super(
      [`Type "${e}" is not a valid encoding type.`, 'Please provide a valid ABI type.'].join(`
`),
      { docsPath: n, name: 'InvalidAbiEncodingType' }
    )
  }
}
class wQ extends fe {
  constructor(e, { docsPath: n }) {
    super(
      [`Type "${e}" is not a valid decoding type.`, 'Please provide a valid ABI type.'].join(`
`),
      { docsPath: n, name: 'InvalidAbiDecodingType' }
    )
  }
}
class EQ extends fe {
  constructor(e) {
    super(
      [`Value "${e}" is not a valid array.`].join(`
`),
      { name: 'InvalidArrayError' }
    )
  }
}
class AQ extends fe {
  constructor(e) {
    super(
      [`"${e}" is not a valid definition type.`, 'Valid types: "function", "event", "error"'].join(`
`),
      { name: 'InvalidDefinitionTypeError' }
    )
  }
}
class kN extends fe {
  constructor({ offset: e, position: n, size: r }) {
    super(
      `Slice ${n === 'start' ? 'starting' : 'ending'} at offset "${e}" is out-of-bounds (size: ${r}).`,
      { name: 'SliceOffsetOutOfBoundsError' }
    )
  }
}
class UN extends fe {
  constructor({ size: e, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${e}) exceeds padding size (${n}).`,
      { name: 'SizeExceedsPaddingSizeError' }
    )
  }
}
class a4 extends fe {
  constructor({ size: e, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} is expected to be ${n} ${r} long, but is ${e} ${r} long.`,
      { name: 'InvalidBytesLengthError' }
    )
  }
}
function Cd(t, { dir: e, size: n = 32 } = {}) {
  return typeof t == 'string' ? Fo(t, { dir: e, size: n }) : _Q(t, { dir: e, size: n })
}
function Fo(t, { dir: e, size: n = 32 } = {}) {
  if (n === null) return t
  const r = t.replace('0x', '')
  if (r.length > n * 2) throw new UN({ size: Math.ceil(r.length / 2), targetSize: n, type: 'hex' })
  return `0x${r[e === 'right' ? 'padEnd' : 'padStart'](n * 2, '0')}`
}
function _Q(t, { dir: e, size: n = 32 } = {}) {
  if (n === null) return t
  if (t.length > n) throw new UN({ size: t.length, targetSize: n, type: 'bytes' })
  const r = new Uint8Array(n)
  for (let i = 0; i < n; i++) {
    const s = e === 'right'
    r[s ? i : n - i - 1] = t[s ? i : t.length - i - 1]
  }
  return r
}
class BN extends fe {
  constructor({ max: e, min: n, signed: r, size: i, value: s }) {
    super(
      `Number "${s}" is not in safe ${i ? `${i * 8}-bit ${r ? 'signed' : 'unsigned'} ` : ''}integer range ${e ? `(${n} to ${e})` : `(above ${n})`}`,
      { name: 'IntegerOutOfRangeError' }
    )
  }
}
class CQ extends fe {
  constructor(e) {
    super(
      `Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,
      { name: 'InvalidBytesBooleanError' }
    )
  }
}
class SQ extends fe {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${e} bytes.`, { name: 'SizeOverflowError' })
  }
}
function Sd(t, { dir: e = 'left' } = {}) {
  let n = typeof t == 'string' ? t.replace('0x', '') : t,
    r = 0
  for (
    let i = 0;
    i < n.length - 1 && n[e === 'left' ? i : n.length - i - 1].toString() === '0';
    i++
  )
    r++
  return (
    (n = e === 'left' ? n.slice(r) : n.slice(0, n.length - r)),
    typeof t == 'string'
      ? (n.length === 1 && e === 'right' && (n = `${n}0`), `0x${n.length % 2 === 1 ? `0${n}` : n}`)
      : n
  )
}
function gs(t, { size: e }) {
  if (lr(t) > e) throw new SQ({ givenSize: lr(t), maxSize: e })
}
function sd(t, e = {}) {
  const { signed: n } = e
  e.size && gs(t, { size: e.size })
  const r = BigInt(t)
  if (!n) return r
  const i = (t.length - 2) / 2,
    s = (1n << (BigInt(i) * 8n - 1n)) - 1n
  return r <= s ? r : r - BigInt(`0x${'f'.padStart(i * 2, 'f')}`) - 1n
}
function iu(t, e = {}) {
  return Number(sd(t, e))
}
function LN(t, e = {}) {
  let n = qs(t)
  return (
    e.size && (gs(n, { size: e.size }), (n = Sd(n, { dir: 'right' }))), new TextDecoder().decode(n)
  )
}
const TQ = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, '0'))
function Ba(t, e = {}) {
  return typeof t == 'number' || typeof t == 'bigint'
    ? it(t, e)
    : typeof t == 'string'
      ? Hm(t, e)
      : typeof t == 'boolean'
        ? $N(t, e)
        : wr(t, e)
}
function $N(t, e = {}) {
  const n = `0x${Number(t)}`
  return typeof e.size == 'number' ? (gs(n, { size: e.size }), Cd(n, { size: e.size })) : n
}
function wr(t, e = {}) {
  let n = ''
  for (let i = 0; i < t.length; i++) n += TQ[t[i]]
  const r = `0x${n}`
  return typeof e.size == 'number'
    ? (gs(r, { size: e.size }), Cd(r, { dir: 'right', size: e.size }))
    : r
}
function it(t, e = {}) {
  const { signed: n, size: r } = e,
    i = BigInt(t)
  let s
  r
    ? n
      ? (s = (1n << (BigInt(r) * 8n - 1n)) - 1n)
      : (s = 2n ** (BigInt(r) * 8n) - 1n)
    : typeof t == 'number' && (s = BigInt(Number.MAX_SAFE_INTEGER))
  const c = typeof s == 'bigint' && n ? -s - 1n : 0
  if ((s && i > s) || i < c) {
    const f = typeof t == 'bigint' ? 'n' : ''
    throw new BN({
      max: s ? `${s}${f}` : void 0,
      min: `${c}${f}`,
      signed: n,
      size: r,
      value: `${t}${f}`
    })
  }
  const u = `0x${(n && i < 0 ? (1n << BigInt(r * 8)) + BigInt(i) : i).toString(16)}`
  return r ? Cd(u, { size: r }) : u
}
const xQ = new TextEncoder()
function Hm(t, e = {}) {
  const n = xQ.encode(t)
  return wr(n, e)
}
const NQ = new TextEncoder()
function Tp(t, e = {}) {
  return typeof t == 'number' || typeof t == 'bigint'
    ? OQ(t, e)
    : typeof t == 'boolean'
      ? IQ(t, e)
      : Ua(t)
        ? qs(t, e)
        : Kc(t, e)
}
function IQ(t, e = {}) {
  const n = new Uint8Array(1)
  return (
    (n[0] = Number(t)),
    typeof e.size == 'number' ? (gs(n, { size: e.size }), Cd(n, { size: e.size })) : n
  )
}
const _a = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 }
function o4(t) {
  if (t >= _a.zero && t <= _a.nine) return t - _a.zero
  if (t >= _a.A && t <= _a.F) return t - (_a.A - 10)
  if (t >= _a.a && t <= _a.f) return t - (_a.a - 10)
}
function qs(t, e = {}) {
  let n = t
  e.size && (gs(n, { size: e.size }), (n = Cd(n, { dir: 'right', size: e.size })))
  let r = n.slice(2)
  r.length % 2 && (r = `0${r}`)
  const i = r.length / 2,
    s = new Uint8Array(i)
  for (let c = 0, u = 0; c < i; c++) {
    const f = o4(r.charCodeAt(u++)),
      d = o4(r.charCodeAt(u++))
    if (f === void 0 || d === void 0)
      throw new fe(`Invalid byte sequence ("${r[u - 2]}${r[u - 1]}" in "${r}").`)
    s[c] = f * 16 + d
  }
  return s
}
function OQ(t, e) {
  const n = it(t, e)
  return qs(n)
}
function Kc(t, e = {}) {
  const n = NQ.encode(t)
  return typeof e.size == 'number'
    ? (gs(n, { size: e.size }), Cd(n, { dir: 'right', size: e.size }))
    : n
}
function Vo(t, e) {
  const n = e || 'hex',
    r = tx(Ua(t, { strict: !1 }) ? Tp(t) : t)
  return n === 'bytes' ? r : Ba(r)
}
const RQ = t => Vo(Tp(t))
function DQ(t) {
  return RQ(t)
}
function PQ(t) {
  let e = !0,
    n = '',
    r = 0,
    i = '',
    s = !1
  for (let c = 0; c < t.length; c++) {
    const u = t[c]
    if ((['(', ')', ','].includes(u) && (e = !0), u === '(' && r++, u === ')' && r--, !!e)) {
      if (r === 0) {
        if (u === ' ' && ['event', 'function', ''].includes(i)) i = ''
        else if (((i += u), u === ')')) {
          s = !0
          break
        }
        continue
      }
      if (u === ' ') {
        t[c - 1] !== ',' && n !== ',' && n !== ',(' && ((n = ''), (e = !1))
        continue
      }
      ;(i += u), (n += u)
    }
  }
  if (!s) throw new fe('Unable to normalize signature.')
  return i
}
const MQ = t => {
  const e = typeof t == 'string' ? t : kU(t)
  return PQ(e)
}
function FN(t) {
  return DQ(MQ(t))
}
const h2 = FN
class su extends fe {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        '- Address must be a hex value of 20 bytes (40 hex characters).',
        '- Address must match its checksum counterpart.'
      ],
      name: 'InvalidAddressError'
    })
  }
}
class Gm extends Map {
  constructor(e) {
    super(),
      Object.defineProperty(this, 'maxSize', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.maxSize = e)
  }
  get(e) {
    const n = super.get(e)
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n
  }
  set(e, n) {
    if ((super.set(e, n), this.maxSize && this.size > this.maxSize)) {
      const r = this.keys().next().value
      r && this.delete(r)
    }
    return this
  }
}
const I1 = new Gm(8192)
function Vm(t, e) {
  if (I1.has(`${t}.${e}`)) return I1.get(`${t}.${e}`)
  const n = e ? `${e}${t.toLowerCase()}` : t.substring(2).toLowerCase(),
    r = Vo(Kc(n), 'bytes'),
    i = (e ? n.substring(`${e}0x`.length) : n).split('')
  for (let c = 0; c < 40; c += 2)
    r[c >> 1] >> 4 >= 8 && i[c] && (i[c] = i[c].toUpperCase()),
      (r[c >> 1] & 15) >= 8 && i[c + 1] && (i[c + 1] = i[c + 1].toUpperCase())
  const s = `0x${i.join('')}`
  return I1.set(`${t}.${e}`, s), s
}
function Bo(t, e) {
  if (!Hs(t, { strict: !1 })) throw new su({ address: t })
  return Vm(t, e)
}
const kQ = /^0x[a-fA-F0-9]{40}$/,
  O1 = new Gm(8192)
function Hs(t, e) {
  const { strict: n = !0 } = e ?? {},
    r = `${t}.${n}`
  if (O1.has(r)) return O1.get(r)
  const i = kQ.test(t) ? (t.toLowerCase() === t ? !0 : n ? Vm(t) === t : !0) : !1
  return O1.set(r, i), i
}
function au(t) {
  return typeof t[0] == 'string' ? Km(t) : UQ(t)
}
function UQ(t) {
  let e = 0
  for (const i of t) e += i.length
  const n = new Uint8Array(e)
  let r = 0
  for (const i of t) n.set(i, r), (r += i.length)
  return n
}
function Km(t) {
  return `0x${t.reduce((e, n) => e + n.replace('0x', ''), '')}`
}
function em(t, e, n, { strict: r } = {}) {
  return Ua(t, { strict: !1 }) ? BQ(t, e, n, { strict: r }) : qN(t, e, n, { strict: r })
}
function jN(t, e) {
  if (typeof e == 'number' && e > 0 && e > lr(t) - 1)
    throw new kN({ offset: e, position: 'start', size: lr(t) })
}
function zN(t, e, n) {
  if (typeof e == 'number' && typeof n == 'number' && lr(t) !== n - e)
    throw new kN({ offset: n, position: 'end', size: lr(t) })
}
function qN(t, e, n, { strict: r } = {}) {
  jN(t, e)
  const i = t.slice(e, n)
  return r && zN(i, e, n), i
}
function BQ(t, e, n, { strict: r } = {}) {
  jN(t, e)
  const i = `0x${t.replace('0x', '').slice((e ?? 0) * 2, (n ?? t.length) * 2)}`
  return r && zN(i, e, n), i
}
const LQ =
  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/
function HN(t, e) {
  if (t.length !== e.length) throw new gQ({ expectedLength: t.length, givenLength: e.length })
  const n = $Q({ params: t, values: e }),
    r = g2(n)
  return r.length === 0 ? '0x' : r
}
function $Q({ params: t, values: e }) {
  const n = []
  for (let r = 0; r < t.length; r++) n.push(p2({ param: t[r], value: e[r] }))
  return n
}
function p2({ param: t, value: e }) {
  const n = m2(t.type)
  if (n) {
    const [r, i] = n
    return jQ(e, { length: r, param: { ...t, type: i } })
  }
  if (t.type === 'tuple') return VQ(e, { param: t })
  if (t.type === 'address') return FQ(e)
  if (t.type === 'bool') return qQ(e)
  if (t.type.startsWith('uint') || t.type.startsWith('int')) {
    const r = t.type.startsWith('int'),
      [, , i = '256'] = LQ.exec(t.type) ?? []
    return HQ(e, { signed: r, size: Number(i) })
  }
  if (t.type.startsWith('bytes')) return zQ(e, { param: t })
  if (t.type === 'string') return GQ(e)
  throw new vQ(t.type, { docsPath: '/docs/contract/encodeAbiParameters' })
}
function g2(t) {
  let e = 0
  for (let s = 0; s < t.length; s++) {
    const { dynamic: c, encoded: u } = t[s]
    c ? (e += 32) : (e += lr(u))
  }
  const n = [],
    r = []
  let i = 0
  for (let s = 0; s < t.length; s++) {
    const { dynamic: c, encoded: u } = t[s]
    c ? (n.push(it(e + i, { size: 32 })), r.push(u), (i += lr(u))) : n.push(u)
  }
  return au([...n, ...r])
}
function FQ(t) {
  if (!Hs(t)) throw new su({ address: t })
  return { dynamic: !1, encoded: Fo(t.toLowerCase()) }
}
function jQ(t, { length: e, param: n }) {
  const r = e === null
  if (!Array.isArray(t)) throw new EQ(t)
  if (!r && t.length !== e)
    throw new hQ({ expectedLength: e, givenLength: t.length, type: `${n.type}[${e}]` })
  let i = !1
  const s = []
  for (let c = 0; c < t.length; c++) {
    const u = p2({ param: n, value: t[c] })
    u.dynamic && (i = !0), s.push(u)
  }
  if (r || i) {
    const c = g2(s)
    if (r) {
      const u = it(s.length, { size: 32 })
      return { dynamic: !0, encoded: s.length > 0 ? au([u, c]) : u }
    }
    if (i) return { dynamic: !0, encoded: c }
  }
  return { dynamic: !1, encoded: au(s.map(({ encoded: c }) => c)) }
}
function zQ(t, { param: e }) {
  const [, n] = e.type.split('bytes'),
    r = lr(t)
  if (!n) {
    let i = t
    return (
      r % 32 !== 0 && (i = Fo(i, { dir: 'right', size: Math.ceil((t.length - 2) / 2 / 32) * 32 })),
      { dynamic: !0, encoded: au([Fo(it(r, { size: 32 })), i]) }
    )
  }
  if (r !== Number.parseInt(n)) throw new pQ({ expectedSize: Number.parseInt(n), value: t })
  return { dynamic: !1, encoded: Fo(t, { dir: 'right' }) }
}
function qQ(t) {
  if (typeof t != 'boolean')
    throw new fe(
      `Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`
    )
  return { dynamic: !1, encoded: Fo($N(t)) }
}
function HQ(t, { signed: e, size: n = 256 }) {
  if (typeof n == 'number') {
    const r = 2n ** (BigInt(n) - (e ? 1n : 0n)) - 1n,
      i = e ? -r - 1n : 0n
    if (t > r || t < i)
      throw new BN({
        max: r.toString(),
        min: i.toString(),
        signed: e,
        size: n / 8,
        value: t.toString()
      })
  }
  return { dynamic: !1, encoded: it(t, { size: 32, signed: e }) }
}
function GQ(t) {
  const e = Hm(t),
    n = Math.ceil(lr(e) / 32),
    r = []
  for (let i = 0; i < n; i++) r.push(Fo(em(e, i * 32, (i + 1) * 32), { dir: 'right' }))
  return { dynamic: !0, encoded: au([Fo(it(lr(e), { size: 32 })), ...r]) }
}
function VQ(t, { param: e }) {
  let n = !1
  const r = []
  for (let i = 0; i < e.components.length; i++) {
    const s = e.components[i],
      c = Array.isArray(t) ? i : s.name,
      u = p2({ param: s, value: t[c] })
    r.push(u), u.dynamic && (n = !0)
  }
  return { dynamic: n, encoded: n ? g2(r) : au(r.map(({ encoded: i }) => i)) }
}
function m2(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/)
  return e ? [e[2] ? Number(e[2]) : null, e[1]] : void 0
}
const b2 = t => em(FN(t), 0, 4)
function y2(t) {
  const { abi: e, args: n = [], name: r } = t,
    i = Ua(r, { strict: !1 }),
    s = e.filter(u =>
      i
        ? u.type === 'function'
          ? b2(u) === r
          : u.type === 'event'
            ? h2(u) === r
            : !1
        : 'name' in u && u.name === r
    )
  if (s.length === 0) return
  if (s.length === 1) return s[0]
  let c
  for (const u of s) {
    if (!('inputs' in u)) continue
    if (!n || n.length === 0) {
      if (!u.inputs || u.inputs.length === 0) return u
      continue
    }
    if (!u.inputs || u.inputs.length === 0 || u.inputs.length !== n.length) continue
    if (
      n.every((d, p) => {
        const g = 'inputs' in u && u.inputs[p]
        return g ? Qw(d, g) : !1
      })
    ) {
      if (c && 'inputs' in c && c.inputs) {
        const d = GN(u.inputs, c.inputs, n)
        if (d) throw new yQ({ abiItem: u, type: d[0] }, { abiItem: c, type: d[1] })
      }
      c = u
    }
  }
  return c || s[0]
}
function Qw(t, e) {
  const n = typeof t,
    r = e.type
  switch (r) {
    case 'address':
      return Hs(t, { strict: !1 })
    case 'bool':
      return n === 'boolean'
    case 'function':
      return n === 'string'
    case 'string':
      return n === 'string'
    default:
      return r === 'tuple' && 'components' in e
        ? Object.values(e.components).every((i, s) => Qw(Object.values(t)[s], i))
        : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(
              r
            )
          ? n === 'number' || n === 'bigint'
          : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r)
            ? n === 'string' || t instanceof Uint8Array
            : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r)
              ? Array.isArray(t) &&
                t.every(i => Qw(i, { ...e, type: r.replace(/(\[[0-9]{0,}\])$/, '') }))
              : !1
  }
}
function GN(t, e, n) {
  for (const r in t) {
    const i = t[r],
      s = e[r]
    if (i.type === 'tuple' && s.type === 'tuple' && 'components' in i && 'components' in s)
      return GN(i.components, s.components, n[r])
    const c = [i.type, s.type]
    if (
      c.includes('address') && c.includes('bytes20')
        ? !0
        : c.includes('address') && c.includes('string')
          ? Hs(n[r], { strict: !1 })
          : c.includes('address') && c.includes('bytes')
            ? Hs(n[r], { strict: !1 })
            : !1
    )
      return c
  }
}
function KQ(t, { method: e }) {
  var r, i
  const n = {}
  return (
    t.transport.type === 'fallback' &&
      ((i = (r = t.transport).onResponse) == null ||
        i.call(r, ({ method: s, response: c, status: u, transport: f }) => {
          u === 'success' && e === s && (n[c] = f.request)
        })),
    s => n[s] || t.request
  )
}
function Qs(t) {
  return typeof t == 'string' ? { address: t, type: 'json-rpc' } : t
}
const c4 = '/docs/contract/encodeFunctionData'
function WQ(t) {
  const { abi: e, args: n, functionName: r } = t
  let i = e[0]
  if (r) {
    const s = y2({ abi: e, args: n, name: r })
    if (!s) throw new Jg(r, { docsPath: c4 })
    i = s
  }
  if (i.type !== 'function') throw new Jg(void 0, { docsPath: c4 })
  return { abi: [i], functionName: b2(Go(i)) }
}
function Td(t) {
  const { args: e } = t,
    { abi: n, functionName: r } = (() => {
      var u
      return t.abi.length === 1 && (u = t.functionName) != null && u.startsWith('0x') ? t : WQ(t)
    })(),
    i = n[0],
    s = r,
    c = 'inputs' in i && i.inputs ? HN(i.inputs, e ?? []) : void 0
  return Km([s, c ?? '0x'])
}
const VN = {
    1: 'An `assert` condition failed.',
    17: 'Arithmetic operation resulted in underflow or overflow.',
    18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',
    33: 'Attempted to convert to an invalid type.',
    34: 'Attempted to access a storage byte array that is incorrectly encoded.',
    49: 'Performed `.pop()` on an empty array',
    50: 'Array index is out of bounds.',
    65: 'Allocated too much memory or created an array which is too large.',
    81: 'Attempted to call a zero-initialized variable of internal function type.'
  },
  QQ = { inputs: [{ name: 'message', type: 'string' }], name: 'Error', type: 'error' },
  YQ = { inputs: [{ name: 'reason', type: 'uint256' }], name: 'Panic', type: 'error' }
class u4 extends fe {
  constructor({ offset: e }) {
    super(`Offset \`${e}\` cannot be negative.`, { name: 'NegativeOffsetError' })
  }
}
class KN extends fe {
  constructor({ length: e, position: n }) {
    super(`Position \`${n}\` is out of bounds (\`0 < position < ${e}\`).`, {
      name: 'PositionOutOfBoundsError'
    })
  }
}
class ZQ extends fe {
  constructor({ count: e, limit: n }) {
    super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${e}\`).`, {
      name: 'RecursiveReadLimitExceededError'
    })
  }
}
const XQ = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new ZQ({ count: this.recursiveReadCount + 1, limit: this.recursiveReadLimit })
  },
  assertPosition(t) {
    if (t < 0 || t > this.bytes.length - 1) throw new KN({ length: this.bytes.length, position: t })
  },
  decrementPosition(t) {
    if (t < 0) throw new u4({ offset: t })
    const e = this.position - t
    this.assertPosition(e), (this.position = e)
  },
  getReadCount(t) {
    return this.positionReadCount.get(t || this.position) || 0
  },
  incrementPosition(t) {
    if (t < 0) throw new u4({ offset: t })
    const e = this.position + t
    this.assertPosition(e), (this.position = e)
  },
  inspectByte(t) {
    const e = t ?? this.position
    return this.assertPosition(e), this.bytes[e]
  },
  inspectBytes(t, e) {
    const n = e ?? this.position
    return this.assertPosition(n + t - 1), this.bytes.subarray(n, n + t)
  },
  inspectUint8(t) {
    const e = t ?? this.position
    return this.assertPosition(e), this.bytes[e]
  },
  inspectUint16(t) {
    const e = t ?? this.position
    return this.assertPosition(e + 1), this.dataView.getUint16(e)
  },
  inspectUint24(t) {
    const e = t ?? this.position
    return (
      this.assertPosition(e + 2), (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2)
    )
  },
  inspectUint32(t) {
    const e = t ?? this.position
    return this.assertPosition(e + 3), this.dataView.getUint32(e)
  },
  pushByte(t) {
    this.assertPosition(this.position), (this.bytes[this.position] = t), this.position++
  },
  pushBytes(t) {
    this.assertPosition(this.position + t.length - 1),
      this.bytes.set(t, this.position),
      (this.position += t.length)
  },
  pushUint8(t) {
    this.assertPosition(this.position), (this.bytes[this.position] = t), this.position++
  },
  pushUint16(t) {
    this.assertPosition(this.position + 1),
      this.dataView.setUint16(this.position, t),
      (this.position += 2)
  },
  pushUint24(t) {
    this.assertPosition(this.position + 2),
      this.dataView.setUint16(this.position, t >> 8),
      this.dataView.setUint8(this.position + 2, t & 255),
      (this.position += 3)
  },
  pushUint32(t) {
    this.assertPosition(this.position + 3),
      this.dataView.setUint32(this.position, t),
      (this.position += 4)
  },
  readByte() {
    this.assertReadLimit(), this._touch()
    const t = this.inspectByte()
    return this.position++, t
  },
  readBytes(t, e) {
    this.assertReadLimit(), this._touch()
    const n = this.inspectBytes(t)
    return (this.position += e ?? t), n
  },
  readUint8() {
    this.assertReadLimit(), this._touch()
    const t = this.inspectUint8()
    return (this.position += 1), t
  },
  readUint16() {
    this.assertReadLimit(), this._touch()
    const t = this.inspectUint16()
    return (this.position += 2), t
  },
  readUint24() {
    this.assertReadLimit(), this._touch()
    const t = this.inspectUint24()
    return (this.position += 3), t
  },
  readUint32() {
    this.assertReadLimit(), this._touch()
    const t = this.inspectUint32()
    return (this.position += 4), t
  },
  get remaining() {
    return this.bytes.length - this.position
  },
  setPosition(t) {
    const e = this.position
    return this.assertPosition(t), (this.position = t), () => (this.position = e)
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return
    const t = this.getReadCount()
    this.positionReadCount.set(this.position, t + 1), t > 0 && this.recursiveReadCount++
  }
}
function v2(t, { recursiveReadLimit: e = 8192 } = {}) {
  const n = Object.create(XQ)
  return (
    (n.bytes = t),
    (n.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength)),
    (n.positionReadCount = new Map()),
    (n.recursiveReadLimit = e),
    n
  )
}
function JQ(t, e = {}) {
  typeof e.size < 'u' && gs(t, { size: e.size })
  const n = wr(t, e)
  return sd(n, e)
}
function eY(t, e = {}) {
  let n = t
  if ((typeof e.size < 'u' && (gs(n, { size: e.size }), (n = Sd(n))), n.length > 1 || n[0] > 1))
    throw new CQ(n)
  return !!n[0]
}
function Da(t, e = {}) {
  typeof e.size < 'u' && gs(t, { size: e.size })
  const n = wr(t, e)
  return iu(n, e)
}
function tY(t, e = {}) {
  let n = t
  return (
    typeof e.size < 'u' && (gs(n, { size: e.size }), (n = Sd(n, { dir: 'right' }))),
    new TextDecoder().decode(n)
  )
}
function Wm(t, e) {
  const n = typeof e == 'string' ? qs(e) : e,
    r = v2(n)
  if (lr(n) === 0 && t.length > 0) throw new qm()
  if (lr(e) && lr(e) < 32)
    throw new RN({ data: typeof e == 'string' ? e : wr(e), params: t, size: lr(e) })
  let i = 0
  const s = []
  for (let c = 0; c < t.length; ++c) {
    const u = t[c]
    r.setPosition(i)
    const [f, d] = kl(r, u, { staticPosition: 0 })
    ;(i += d), s.push(f)
  }
  return s
}
function kl(t, e, { staticPosition: n }) {
  const r = m2(e.type)
  if (r) {
    const [i, s] = r
    return rY(t, { ...e, type: s }, { length: i, staticPosition: n })
  }
  if (e.type === 'tuple') return oY(t, e, { staticPosition: n })
  if (e.type === 'address') return nY(t)
  if (e.type === 'bool') return iY(t)
  if (e.type.startsWith('bytes')) return sY(t, e, { staticPosition: n })
  if (e.type.startsWith('uint') || e.type.startsWith('int')) return aY(t, e)
  if (e.type === 'string') return cY(t, { staticPosition: n })
  throw new wQ(e.type, { docsPath: '/docs/contract/decodeAbiParameters' })
}
const l4 = 32,
  Yw = 32
function nY(t) {
  const e = t.readBytes(32)
  return [Vm(wr(qN(e, -20))), 32]
}
function rY(t, e, { length: n, staticPosition: r }) {
  if (!n) {
    const c = Da(t.readBytes(Yw)),
      u = r + c,
      f = u + l4
    t.setPosition(u)
    const d = Da(t.readBytes(l4)),
      p = Sh(e)
    let g = 0
    const m = []
    for (let y = 0; y < d; ++y) {
      t.setPosition(f + (p ? y * 32 : g))
      const [A, E] = kl(t, e, { staticPosition: f })
      ;(g += E), m.push(A)
    }
    return t.setPosition(r + 32), [m, 32]
  }
  if (Sh(e)) {
    const c = Da(t.readBytes(Yw)),
      u = r + c,
      f = []
    for (let d = 0; d < n; ++d) {
      t.setPosition(u + d * 32)
      const [p] = kl(t, e, { staticPosition: u })
      f.push(p)
    }
    return t.setPosition(r + 32), [f, 32]
  }
  let i = 0
  const s = []
  for (let c = 0; c < n; ++c) {
    const [u, f] = kl(t, e, { staticPosition: r + i })
    ;(i += f), s.push(u)
  }
  return [s, i]
}
function iY(t) {
  return [eY(t.readBytes(32), { size: 32 }), 32]
}
function sY(t, e, { staticPosition: n }) {
  const [r, i] = e.type.split('bytes')
  if (!i) {
    const c = Da(t.readBytes(32))
    t.setPosition(n + c)
    const u = Da(t.readBytes(32))
    if (u === 0) return t.setPosition(n + 32), ['0x', 32]
    const f = t.readBytes(u)
    return t.setPosition(n + 32), [wr(f), 32]
  }
  return [wr(t.readBytes(Number.parseInt(i), 32)), 32]
}
function aY(t, e) {
  const n = e.type.startsWith('int'),
    r = Number.parseInt(e.type.split('int')[1] || '256'),
    i = t.readBytes(32)
  return [r > 48 ? JQ(i, { signed: n }) : Da(i, { signed: n }), 32]
}
function oY(t, e, { staticPosition: n }) {
  const r = e.components.length === 0 || e.components.some(({ name: c }) => !c),
    i = r ? [] : {}
  let s = 0
  if (Sh(e)) {
    const c = Da(t.readBytes(Yw)),
      u = n + c
    for (let f = 0; f < e.components.length; ++f) {
      const d = e.components[f]
      t.setPosition(u + s)
      const [p, g] = kl(t, d, { staticPosition: u })
      ;(s += g), (i[r ? f : d == null ? void 0 : d.name] = p)
    }
    return t.setPosition(n + 32), [i, 32]
  }
  for (let c = 0; c < e.components.length; ++c) {
    const u = e.components[c],
      [f, d] = kl(t, u, { staticPosition: n })
    ;(i[r ? c : u == null ? void 0 : u.name] = f), (s += d)
  }
  return [i, s]
}
function cY(t, { staticPosition: e }) {
  const n = Da(t.readBytes(32)),
    r = e + n
  t.setPosition(r)
  const i = Da(t.readBytes(32))
  if (i === 0) return t.setPosition(e + 32), ['', 32]
  const s = t.readBytes(i, 32),
    c = tY(Sd(s))
  return t.setPosition(e + 32), [c, 32]
}
function Sh(t) {
  var r
  const { type: e } = t
  if (e === 'string' || e === 'bytes' || e.endsWith('[]')) return !0
  if (e === 'tuple') return (r = t.components) == null ? void 0 : r.some(Sh)
  const n = m2(t.type)
  return !!(n && Sh({ ...t, type: n[1] }))
}
function uY(t) {
  const { abi: e, data: n } = t,
    r = em(n, 0, 4)
  if (r === '0x') throw new qm()
  const s = [...(e || []), QQ, YQ].find(c => c.type === 'error' && r === b2(Go(c)))
  if (!s) throw new DN(r, { docsPath: '/docs/contract/decodeErrorResult' })
  return {
    abiItem: s,
    args: 'inputs' in s && s.inputs && s.inputs.length > 0 ? Wm(s.inputs, em(n, 4)) : void 0,
    errorName: s.name
  }
}
const ji = (t, e, n) => JSON.stringify(t, (r, i) => (typeof i == 'bigint' ? i.toString() : i), n)
function WN({ abiItem: t, args: e, includeFunctionName: n = !0, includeName: r = !1 }) {
  if ('name' in t && 'inputs' in t && t.inputs)
    return `${n ? t.name : ''}(${t.inputs.map((i, s) => `${r && i.name ? `${i.name}: ` : ''}${typeof e[s] == 'object' ? ji(e[s]) : e[s]}`).join(', ')})`
}
const lY = { gwei: 9, wei: 18 },
  QN = { ether: -9, wei: 9 },
  dY = { ether: -18, gwei: -9 }
function xd(t, e) {
  let n = t.toString()
  const r = n.startsWith('-')
  r && (n = n.slice(1)), (n = n.padStart(e, '0'))
  let [i, s] = [n.slice(0, n.length - e), n.slice(n.length - e)]
  return (s = s.replace(/(0+)$/, '')), `${r ? '-' : ''}${i || '0'}${s ? `.${s}` : ''}`
}
function w2(t, e = 'wei') {
  return xd(t, lY[e])
}
function ti(t, e = 'wei') {
  return xd(t, QN[e])
}
class fY extends fe {
  constructor({ address: e }) {
    super(`State for account "${e}" is set multiple times.`, { name: 'AccountStateConflictError' })
  }
}
class hY extends fe {
  constructor() {
    super('state and stateDiff are set on the same account.', {
      name: 'StateAssignmentConflictError'
    })
  }
}
function d4(t) {
  return t.reduce(
    (e, { slot: n, value: r }) => `${e}        ${n}: ${r}
`,
    ''
  )
}
function pY(t) {
  return t
    .reduce(
      (e, { address: n, ...r }) => {
        let i = `${e}    ${n}:
`
        return (
          r.nonce &&
            (i += `      nonce: ${r.nonce}
`),
          r.balance &&
            (i += `      balance: ${r.balance}
`),
          r.code &&
            (i += `      code: ${r.code}
`),
          r.state &&
            ((i += `      state:
`),
            (i += d4(r.state))),
          r.stateDiff &&
            ((i += `      stateDiff:
`),
            (i += d4(r.stateDiff))),
          i
        )
      },
      `  State Override:
`
    )
    .slice(0, -1)
}
function xp(t) {
  const e = Object.entries(t)
      .map(([r, i]) => (i === void 0 || i === !1 ? null : [r, i]))
      .filter(Boolean),
    n = e.reduce((r, [i]) => Math.max(r, i.length), 0)
  return e.map(([r, i]) => `  ${`${r}:`.padEnd(n + 1)}  ${i}`).join(`
`)
}
class gY extends fe {
  constructor() {
    super(
      [
        'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',
        'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.'
      ].join(`
`),
      { name: 'FeeConflictError' }
    )
  }
}
class mY extends fe {
  constructor({ transaction: e }) {
    super('Cannot infer a transaction type from provided transaction.', {
      metaMessages: [
        'Provided Transaction:',
        '{',
        xp(e),
        '}',
        '',
        'To infer the type, either provide:',
        '- a `type` to the Transaction, or',
        '- an EIP-1559 Transaction with `maxFeePerGas`, or',
        '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',
        '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or',
        '- an EIP-7702 Transaction with `authorizationList`, or',
        '- a Legacy Transaction with `gasPrice`'
      ],
      name: 'InvalidSerializableTransactionError'
    })
  }
}
class bY extends fe {
  constructor(
    e,
    {
      account: n,
      docsPath: r,
      chain: i,
      data: s,
      gas: c,
      gasPrice: u,
      maxFeePerGas: f,
      maxPriorityFeePerGas: d,
      nonce: p,
      to: g,
      value: m
    }
  ) {
    var A
    const y = xp({
      chain: i && `${i == null ? void 0 : i.name} (id: ${i == null ? void 0 : i.id})`,
      from: n == null ? void 0 : n.address,
      to: g,
      value:
        typeof m < 'u' &&
        `${w2(m)} ${((A = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : A.symbol) || 'ETH'}`,
      data: s,
      gas: c,
      gasPrice: typeof u < 'u' && `${ti(u)} gwei`,
      maxFeePerGas: typeof f < 'u' && `${ti(f)} gwei`,
      maxPriorityFeePerGas: typeof d < 'u' && `${ti(d)} gwei`,
      nonce: p
    })
    super(e.shortMessage, {
      cause: e,
      docsPath: r,
      metaMessages: [
        ...(e.metaMessages ? [...e.metaMessages, ' '] : []),
        'Request Arguments:',
        y
      ].filter(Boolean),
      name: 'TransactionExecutionError'
    }),
      Object.defineProperty(this, 'cause', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.cause = e)
  }
}
class YN extends fe {
  constructor({ blockHash: e, blockNumber: n, blockTag: r, hash: i, index: s }) {
    let c = 'Transaction'
    r && s !== void 0 && (c = `Transaction at block time "${r}" at index "${s}"`),
      e && s !== void 0 && (c = `Transaction at block hash "${e}" at index "${s}"`),
      n && s !== void 0 && (c = `Transaction at block number "${n}" at index "${s}"`),
      i && (c = `Transaction with hash "${i}"`),
      super(`${c} could not be found.`, { name: 'TransactionNotFoundError' })
  }
}
class ZN extends fe {
  constructor({ hash: e }) {
    super(
      `Transaction receipt with hash "${e}" could not be found. The Transaction may not be processed on a block yet.`,
      { name: 'TransactionReceiptNotFoundError' }
    )
  }
}
class yY extends fe {
  constructor({ hash: e }) {
    super(`Timed out while waiting for transaction with hash "${e}" to be confirmed.`, {
      name: 'WaitForTransactionReceiptTimeoutError'
    })
  }
}
const vY = t => t,
  E2 = t => t
class wY extends fe {
  constructor(
    e,
    {
      account: n,
      docsPath: r,
      chain: i,
      data: s,
      gas: c,
      gasPrice: u,
      maxFeePerGas: f,
      maxPriorityFeePerGas: d,
      nonce: p,
      to: g,
      value: m,
      stateOverride: y
    }
  ) {
    var x
    const A = n ? Qs(n) : void 0
    let E = xp({
      from: A == null ? void 0 : A.address,
      to: g,
      value:
        typeof m < 'u' &&
        `${w2(m)} ${((x = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : x.symbol) || 'ETH'}`,
      data: s,
      gas: c,
      gasPrice: typeof u < 'u' && `${ti(u)} gwei`,
      maxFeePerGas: typeof f < 'u' && `${ti(f)} gwei`,
      maxPriorityFeePerGas: typeof d < 'u' && `${ti(d)} gwei`,
      nonce: p
    })
    y &&
      (E += `
${pY(y)}`),
      super(e.shortMessage, {
        cause: e,
        docsPath: r,
        metaMessages: [
          ...(e.metaMessages ? [...e.metaMessages, ' '] : []),
          'Raw Call Arguments:',
          E
        ].filter(Boolean),
        name: 'CallExecutionError'
      }),
      Object.defineProperty(this, 'cause', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.cause = e)
  }
}
class XN extends fe {
  constructor(e, { abi: n, args: r, contractAddress: i, docsPath: s, functionName: c, sender: u }) {
    const f = y2({ abi: n, args: r, name: c }),
      d = f ? WN({ abiItem: f, args: r, includeFunctionName: !1, includeName: !1 }) : void 0,
      p = f ? Go(f, { includeName: !0 }) : void 0,
      g = xp({
        address: i && vY(i),
        function: p,
        args:
          d &&
          d !== '()' &&
          `${[...Array((c == null ? void 0 : c.length) ?? 0).keys()].map(() => ' ').join('')}${d}`,
        sender: u
      })
    super(
      e.shortMessage || `An unknown error occurred while executing the contract function "${c}".`,
      {
        cause: e,
        docsPath: s,
        metaMessages: [
          ...(e.metaMessages ? [...e.metaMessages, ' '] : []),
          g && 'Contract Call:',
          g
        ].filter(Boolean),
        name: 'ContractFunctionExecutionError'
      }
    ),
      Object.defineProperty(this, 'abi', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'args', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'cause', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'contractAddress', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'formattedArgs', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'functionName', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'sender', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.abi = n),
      (this.args = r),
      (this.cause = e),
      (this.contractAddress = i),
      (this.functionName = c),
      (this.sender = u)
  }
}
class Zw extends fe {
  constructor({ abi: e, data: n, functionName: r, message: i }) {
    let s, c, u, f
    if (n && n !== '0x')
      try {
        c = uY({ abi: e, data: n })
        const { abiItem: p, errorName: g, args: m } = c
        if (g === 'Error') f = m[0]
        else if (g === 'Panic') {
          const [y] = m
          f = VN[y]
        } else {
          const y = p ? Go(p, { includeName: !0 }) : void 0,
            A =
              p && m
                ? WN({ abiItem: p, args: m, includeFunctionName: !1, includeName: !1 })
                : void 0
          u = [
            y ? `Error: ${y}` : '',
            A && A !== '()'
              ? `       ${[...Array((g == null ? void 0 : g.length) ?? 0).keys()].map(() => ' ').join('')}${A}`
              : ''
          ]
        }
      } catch (p) {
        s = p
      }
    else i && (f = i)
    let d
    s instanceof DN &&
      ((d = s.signature),
      (u = [
        `Unable to decode signature "${d}" as it was not found on the provided ABI.`,
        'Make sure you are using the correct ABI and that the error exists on it.',
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${d}.`
      ])),
      super(
        (f && f !== 'execution reverted') || d
          ? [
              `The contract function "${r}" reverted with the following ${d ? 'signature' : 'reason'}:`,
              f || d
            ].join(`
`)
          : `The contract function "${r}" reverted.`,
        { cause: s, metaMessages: u, name: 'ContractFunctionRevertedError' }
      ),
      Object.defineProperty(this, 'data', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'raw', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'reason', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'signature', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.data = c),
      (this.raw = n),
      (this.reason = f),
      (this.signature = d)
  }
}
class EY extends fe {
  constructor({ functionName: e }) {
    super(`The contract function "${e}" returned no data ("0x").`, {
      metaMessages: [
        'This could be due to any of the following:',
        `  - The contract does not have the function "${e}",`,
        '  - The parameters passed to the contract function may be invalid, or',
        '  - The address is not a contract.'
      ],
      name: 'ContractFunctionZeroDataError'
    })
  }
}
class AY extends fe {
  constructor({ factory: e }) {
    super(`Deployment for counterfactual contract call failed${e ? ` for factory "${e}".` : ''}`, {
      metaMessages: [
        'Please ensure:',
        '- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).',
        '- The `factoryData` is a valid encoded function call for contract deployment function on the factory.'
      ],
      name: 'CounterfactualDeploymentFailedError'
    })
  }
}
class A2 extends fe {
  constructor({ data: e, message: n }) {
    super(n || '', { name: 'RawContractError' }),
      Object.defineProperty(this, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 3
      }),
      Object.defineProperty(this, 'data', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.data = e)
  }
}
class hh extends fe {
  constructor({ body: e, cause: n, details: r, headers: i, status: s, url: c }) {
    super('HTTP request failed.', {
      cause: n,
      details: r,
      metaMessages: [s && `Status: ${s}`, `URL: ${E2(c)}`, e && `Request body: ${ji(e)}`].filter(
        Boolean
      ),
      name: 'HttpRequestError'
    }),
      Object.defineProperty(this, 'body', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'headers', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'status', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'url', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.body = e),
      (this.headers = i),
      (this.status = s),
      (this.url = c)
  }
}
class _2 extends fe {
  constructor({ body: e, error: n, url: r }) {
    super('RPC Request failed.', {
      cause: n,
      details: n.message,
      metaMessages: [`URL: ${E2(r)}`, `Request body: ${ji(e)}`],
      name: 'RpcRequestError'
    }),
      Object.defineProperty(this, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'data', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.code = n.code),
      (this.data = n.data)
  }
}
class f4 extends fe {
  constructor({ body: e, url: n }) {
    super('The request took too long to respond.', {
      details: 'The request timed out.',
      metaMessages: [`URL: ${E2(n)}`, `Request body: ${ji(e)}`],
      name: 'TimeoutError'
    })
  }
}
const _Y = -1
class ri extends fe {
  constructor(e, { code: n, docsPath: r, metaMessages: i, name: s, shortMessage: c }) {
    super(c, {
      cause: e,
      docsPath: r,
      metaMessages: i || (e == null ? void 0 : e.metaMessages),
      name: s || 'RpcError'
    }),
      Object.defineProperty(this, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.name = s || e.name),
      (this.code = e instanceof _2 ? e.code : (n ?? _Y))
  }
}
class Nd extends ri {
  constructor(e, n) {
    super(e, n),
      Object.defineProperty(this, 'data', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.data = n.data)
  }
}
class Th extends ri {
  constructor(e) {
    super(e, {
      code: Th.code,
      name: 'ParseRpcError',
      shortMessage:
        'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.'
    })
  }
}
Object.defineProperty(Th, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32700 })
class xh extends ri {
  constructor(e) {
    super(e, {
      code: xh.code,
      name: 'InvalidRequestRpcError',
      shortMessage: 'JSON is not a valid request object.'
    })
  }
}
Object.defineProperty(xh, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32600 })
class Nh extends ri {
  constructor(e, { method: n } = {}) {
    super(e, {
      code: Nh.code,
      name: 'MethodNotFoundRpcError',
      shortMessage: `The method${n ? ` "${n}"` : ''} does not exist / is not available.`
    })
  }
}
Object.defineProperty(Nh, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32601 })
class Ih extends ri {
  constructor(e) {
    super(e, {
      code: Ih.code,
      name: 'InvalidParamsRpcError',
      shortMessage: [
        'Invalid parameters were provided to the RPC method.',
        'Double check you have provided the correct parameters.'
      ].join(`
`)
    })
  }
}
Object.defineProperty(Ih, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32602 })
class ou extends ri {
  constructor(e) {
    super(e, {
      code: ou.code,
      name: 'InternalRpcError',
      shortMessage: 'An internal error was received.'
    })
  }
}
Object.defineProperty(ou, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32603 })
class Oh extends ri {
  constructor(e) {
    super(e, {
      code: Oh.code,
      name: 'InvalidInputRpcError',
      shortMessage: [
        'Missing or invalid parameters.',
        'Double check you have provided the correct parameters.'
      ].join(`
`)
    })
  }
}
Object.defineProperty(Oh, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32e3 })
class Rh extends ri {
  constructor(e) {
    super(e, {
      code: Rh.code,
      name: 'ResourceNotFoundRpcError',
      shortMessage: 'Requested resource not found.'
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ResourceNotFoundRpcError'
      })
  }
}
Object.defineProperty(Rh, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32001 })
class jo extends ri {
  constructor(e) {
    super(e, {
      code: jo.code,
      name: 'ResourceUnavailableRpcError',
      shortMessage: 'Requested resource not available.'
    })
  }
}
Object.defineProperty(jo, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32002 })
class ad extends ri {
  constructor(e) {
    super(e, {
      code: ad.code,
      name: 'TransactionRejectedRpcError',
      shortMessage: 'Transaction creation failed.'
    })
  }
}
Object.defineProperty(ad, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32003 })
class Pc extends ri {
  constructor(e, { method: n } = {}) {
    super(e, {
      code: Pc.code,
      name: 'MethodNotSupportedRpcError',
      shortMessage: `Method${n ? ` "${n}"` : ''} is not supported.`
    })
  }
}
Object.defineProperty(Pc, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32004 })
class od extends ri {
  constructor(e) {
    super(e, {
      code: od.code,
      name: 'LimitExceededRpcError',
      shortMessage: 'Request exceeds defined limit.'
    })
  }
}
Object.defineProperty(od, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32005 })
class Dh extends ri {
  constructor(e) {
    super(e, {
      code: Dh.code,
      name: 'JsonRpcVersionUnsupportedError',
      shortMessage: 'Version of JSON-RPC protocol is not supported.'
    })
  }
}
Object.defineProperty(Dh, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32006 })
class Xn extends Nd {
  constructor(e) {
    super(e, {
      code: Xn.code,
      name: 'UserRejectedRequestError',
      shortMessage: 'User rejected the request.'
    })
  }
}
Object.defineProperty(Xn, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 4001 })
class Ph extends Nd {
  constructor(e) {
    super(e, {
      code: Ph.code,
      name: 'UnauthorizedProviderError',
      shortMessage: 'The requested method and/or account has not been authorized by the user.'
    })
  }
}
Object.defineProperty(Ph, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 4100 })
class Mh extends Nd {
  constructor(e, { method: n } = {}) {
    super(e, {
      code: Mh.code,
      name: 'UnsupportedProviderMethodError',
      shortMessage: `The Provider does not support the requested method${n ? ` " ${n}"` : ''}.`
    })
  }
}
Object.defineProperty(Mh, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 4200 })
class kh extends Nd {
  constructor(e) {
    super(e, {
      code: kh.code,
      name: 'ProviderDisconnectedError',
      shortMessage: 'The Provider is disconnected from all chains.'
    })
  }
}
Object.defineProperty(kh, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 4900 })
class Uh extends Nd {
  constructor(e) {
    super(e, {
      code: Uh.code,
      name: 'ChainDisconnectedError',
      shortMessage: 'The Provider is not connected to the requested chain.'
    })
  }
}
Object.defineProperty(Uh, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 4901 })
class Gs extends Nd {
  constructor(e) {
    super(e, {
      code: Gs.code,
      name: 'SwitchChainError',
      shortMessage: 'An error occurred when attempting to switch chain.'
    })
  }
}
Object.defineProperty(Gs, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 4902 })
class CY extends ri {
  constructor(e) {
    super(e, { name: 'UnknownRpcError', shortMessage: 'An unknown RPC error occurred.' })
  }
}
const SY = 3
function tm(t, { abi: e, address: n, args: r, docsPath: i, functionName: s, sender: c }) {
  const u = t instanceof A2 ? t : t instanceof fe ? t.walk(A => 'data' in A) || t.walk() : {},
    { code: f, data: d, details: p, message: g, shortMessage: m } = u,
    y =
      t instanceof qm
        ? new EY({ functionName: s })
        : [SY, ou.code].includes(f) && (d || p || g || m)
          ? new Zw({
              abi: e,
              data: typeof d == 'object' ? d.data : d,
              functionName: s,
              message: u instanceof _2 ? p : (m ?? g)
            })
          : t
  return new XN(y, { abi: e, args: r, contractAddress: n, docsPath: i, functionName: s, sender: c })
}
function TY(t) {
  const e = Vo(`0x${t.substring(4)}`).substring(26)
  return Vm(`0x${e}`)
}
async function xY({ hash: t, signature: e }) {
  const n = Ua(t) ? t : Ba(t),
    { secp256k1: r } = await ei(async () => {
      const { secp256k1: c } = await import('./secp256k1-C-C-k1yE.js')
      return { secp256k1: c }
    }, [])
  return `0x${(() => {
    if (typeof e == 'object' && 'r' in e && 's' in e) {
      const { r: d, s: p, v: g, yParity: m } = e,
        y = Number(m ?? g),
        A = h4(y)
      return new r.Signature(sd(d), sd(p)).addRecoveryBit(A)
    }
    const c = Ua(e) ? e : Ba(e),
      u = iu(`0x${c.slice(130)}`),
      f = h4(u)
    return r.Signature.fromCompact(c.substring(2, 130)).addRecoveryBit(f)
  })()
    .recoverPublicKey(n.substring(2))
    .toHex(!1)}`
}
function h4(t) {
  if (t === 0 || t === 1) return t
  if (t === 27) return 0
  if (t === 28) return 1
  throw new Error('Invalid yParityOrV value')
}
async function NY({ hash: t, signature: e }) {
  return TY(await xY({ hash: t, signature: e }))
}
function IY(t, e = 'hex') {
  const n = JN(t),
    r = v2(new Uint8Array(n.length))
  return n.encode(r), e === 'hex' ? wr(r.bytes) : r.bytes
}
function JN(t) {
  return Array.isArray(t) ? OY(t.map(e => JN(e))) : RY(t)
}
function OY(t) {
  const e = t.reduce((i, s) => i + s.length, 0),
    n = e9(e)
  return {
    length: e <= 55 ? 1 + e : 1 + n + e,
    encode(i) {
      e <= 55
        ? i.pushByte(192 + e)
        : (i.pushByte(247 + n),
          n === 1
            ? i.pushUint8(e)
            : n === 2
              ? i.pushUint16(e)
              : n === 3
                ? i.pushUint24(e)
                : i.pushUint32(e))
      for (const { encode: s } of t) s(i)
    }
  }
}
function RY(t) {
  const e = typeof t == 'string' ? qs(t) : t,
    n = e9(e.length)
  return {
    length: e.length === 1 && e[0] < 128 ? 1 : e.length <= 55 ? 1 + e.length : 1 + n + e.length,
    encode(i) {
      e.length === 1 && e[0] < 128
        ? i.pushBytes(e)
        : e.length <= 55
          ? (i.pushByte(128 + e.length), i.pushBytes(e))
          : (i.pushByte(183 + n),
            n === 1
              ? i.pushUint8(e.length)
              : n === 2
                ? i.pushUint16(e.length)
                : n === 3
                  ? i.pushUint24(e.length)
                  : i.pushUint32(e.length),
            i.pushBytes(e))
    }
  }
}
function e9(t) {
  if (t < 2 ** 8) return 1
  if (t < 2 ** 16) return 2
  if (t < 2 ** 24) return 3
  if (t < 2 ** 32) return 4
  throw new fe('Length is too large.')
}
function DY(t) {
  const { chainId: e, nonce: n, to: r } = t,
    i = t.contractAddress ?? t.address,
    s = Vo(Km(['0x05', IY([e ? it(e) : '0x', i, n ? it(n) : '0x'])]))
  return r === 'bytes' ? qs(s) : s
}
async function t9(t) {
  const { authorization: e, signature: n } = t
  return NY({ hash: DY(e), signature: n ?? e })
}
class PY extends fe {
  constructor(
    e,
    {
      account: n,
      docsPath: r,
      chain: i,
      data: s,
      gas: c,
      gasPrice: u,
      maxFeePerGas: f,
      maxPriorityFeePerGas: d,
      nonce: p,
      to: g,
      value: m
    }
  ) {
    var A
    const y = xp({
      from: n == null ? void 0 : n.address,
      to: g,
      value:
        typeof m < 'u' &&
        `${w2(m)} ${((A = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : A.symbol) || 'ETH'}`,
      data: s,
      gas: c,
      gasPrice: typeof u < 'u' && `${ti(u)} gwei`,
      maxFeePerGas: typeof f < 'u' && `${ti(f)} gwei`,
      maxPriorityFeePerGas: typeof d < 'u' && `${ti(d)} gwei`,
      nonce: p
    })
    super(e.shortMessage, {
      cause: e,
      docsPath: r,
      metaMessages: [
        ...(e.metaMessages ? [...e.metaMessages, ' '] : []),
        'Estimate Gas Arguments:',
        y
      ].filter(Boolean),
      name: 'EstimateGasExecutionError'
    }),
      Object.defineProperty(this, 'cause', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.cause = e)
  }
}
class Mc extends fe {
  constructor({ cause: e, message: n } = {}) {
    var i
    const r =
      (i = n == null ? void 0 : n.replace('execution reverted: ', '')) == null
        ? void 0
        : i.replace('execution reverted', '')
    super(`Execution reverted ${r ? `with reason: ${r}` : 'for an unknown reason'}.`, {
      cause: e,
      name: 'ExecutionRevertedError'
    })
  }
}
Object.defineProperty(Mc, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 3 })
Object.defineProperty(Mc, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
})
class nm extends fe {
  constructor({ cause: e, maxFeePerGas: n } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${n ? ` = ${ti(n)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`,
      { cause: e, name: 'FeeCapTooHighError' }
    )
  }
}
Object.defineProperty(nm, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
})
class Xw extends fe {
  constructor({ cause: e, maxFeePerGas: n } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${n ? ` = ${ti(n)}` : ''} gwei) cannot be lower than the block base fee.`,
      { cause: e, name: 'FeeCapTooLowError' }
    )
  }
}
Object.defineProperty(Xw, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value:
    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
})
class Jw extends fe {
  constructor({ cause: e, nonce: n } = {}) {
    super(
      `Nonce provided for the transaction ${n ? `(${n}) ` : ''}is higher than the next one expected.`,
      { cause: e, name: 'NonceTooHighError' }
    )
  }
}
Object.defineProperty(Jw, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
})
class eE extends fe {
  constructor({ cause: e, nonce: n } = {}) {
    super(
      [
        `Nonce provided for the transaction ${n ? `(${n}) ` : ''}is lower than the current nonce of the account.`,
        'Try increasing the nonce or find the latest nonce with `getTransactionCount`.'
      ].join(`
`),
      { cause: e, name: 'NonceTooLowError' }
    )
  }
}
Object.defineProperty(eE, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
})
class tE extends fe {
  constructor({ cause: e, nonce: n } = {}) {
    super(
      `Nonce provided for the transaction ${n ? `(${n}) ` : ''}exceeds the maximum allowed nonce.`,
      { cause: e, name: 'NonceMaxValueError' }
    )
  }
}
Object.defineProperty(tE, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
})
class nE extends fe {
  constructor({ cause: e } = {}) {
    super(
      [
        'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.'
      ].join(`
`),
      {
        cause: e,
        metaMessages: [
          'This error could arise when the account does not have enough funds to:',
          ' - pay for the total gas fee,',
          ' - pay for the value to send.',
          ' ',
          'The cost of the transaction is calculated as `gas * gas fee + value`, where:',
          ' - `gas` is the amount of gas needed for transaction to execute,',
          ' - `gas fee` is the gas fee,',
          ' - `value` is the amount of ether to send to the recipient.'
        ],
        name: 'InsufficientFundsError'
      }
    )
  }
}
Object.defineProperty(nE, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
})
class rE extends fe {
  constructor({ cause: e, gas: n } = {}) {
    super(
      `The amount of gas ${n ? `(${n}) ` : ''}provided for the transaction exceeds the limit allowed for the block.`,
      { cause: e, name: 'IntrinsicGasTooHighError' }
    )
  }
}
Object.defineProperty(rE, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
})
class iE extends fe {
  constructor({ cause: e, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ''}provided for the transaction is too low.`, {
      cause: e,
      name: 'IntrinsicGasTooLowError'
    })
  }
}
Object.defineProperty(iE, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
})
class sE extends fe {
  constructor({ cause: e }) {
    super('The transaction type is not supported for this chain.', {
      cause: e,
      name: 'TransactionTypeNotSupportedError'
    })
  }
}
Object.defineProperty(sE, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
})
class rm extends fe {
  constructor({ cause: e, maxPriorityFeePerGas: n, maxFeePerGas: r } = {}) {
    super(
      [
        `The provided tip (\`maxPriorityFeePerGas\`${n ? ` = ${ti(n)} gwei` : ''}) cannot be higher than the fee cap (\`maxFeePerGas\`${r ? ` = ${ti(r)} gwei` : ''}).`
      ].join(`
`),
      { cause: e, name: 'TipAboveFeeCapError' }
    )
  }
}
Object.defineProperty(rm, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
})
class Qm extends fe {
  constructor({ cause: e }) {
    super(`An error occurred while executing: ${e == null ? void 0 : e.shortMessage}`, {
      cause: e,
      name: 'UnknownNodeError'
    })
  }
}
function C2(t, e) {
  const n = (t.details || '').toLowerCase(),
    r = t instanceof fe ? t.walk(i => (i == null ? void 0 : i.code) === Mc.code) : t
  return r instanceof fe
    ? new Mc({ cause: t, message: r.details })
    : Mc.nodeMessage.test(n)
      ? new Mc({ cause: t, message: t.details })
      : nm.nodeMessage.test(n)
        ? new nm({ cause: t, maxFeePerGas: e == null ? void 0 : e.maxFeePerGas })
        : Xw.nodeMessage.test(n)
          ? new Xw({ cause: t, maxFeePerGas: e == null ? void 0 : e.maxFeePerGas })
          : Jw.nodeMessage.test(n)
            ? new Jw({ cause: t, nonce: e == null ? void 0 : e.nonce })
            : eE.nodeMessage.test(n)
              ? new eE({ cause: t, nonce: e == null ? void 0 : e.nonce })
              : tE.nodeMessage.test(n)
                ? new tE({ cause: t, nonce: e == null ? void 0 : e.nonce })
                : nE.nodeMessage.test(n)
                  ? new nE({ cause: t })
                  : rE.nodeMessage.test(n)
                    ? new rE({ cause: t, gas: e == null ? void 0 : e.gas })
                    : iE.nodeMessage.test(n)
                      ? new iE({ cause: t, gas: e == null ? void 0 : e.gas })
                      : sE.nodeMessage.test(n)
                        ? new sE({ cause: t })
                        : rm.nodeMessage.test(n)
                          ? new rm({
                              cause: t,
                              maxFeePerGas: e == null ? void 0 : e.maxFeePerGas,
                              maxPriorityFeePerGas: e == null ? void 0 : e.maxPriorityFeePerGas
                            })
                          : new Qm({ cause: t })
}
function MY(t, { docsPath: e, ...n }) {
  const r = (() => {
    const i = C2(t, n)
    return i instanceof Qm ? t : i
  })()
  return new PY(r, { docsPath: e, ...n })
}
function S2(t, { format: e }) {
  if (!e) return {}
  const n = {}
  function r(s) {
    const c = Object.keys(s)
    for (const u of c)
      u in t && (n[u] = t[u]), s[u] && typeof s[u] == 'object' && !Array.isArray(s[u]) && r(s[u])
  }
  const i = e(t || {})
  return r(i), n
}
const kY = { legacy: '0x0', eip2930: '0x1', eip1559: '0x2', eip4844: '0x3', eip7702: '0x4' }
function T2(t) {
  const e = {}
  return (
    typeof t.authorizationList < 'u' && (e.authorizationList = UY(t.authorizationList)),
    typeof t.accessList < 'u' && (e.accessList = t.accessList),
    typeof t.blobVersionedHashes < 'u' && (e.blobVersionedHashes = t.blobVersionedHashes),
    typeof t.blobs < 'u' &&
      (typeof t.blobs[0] != 'string' ? (e.blobs = t.blobs.map(n => wr(n))) : (e.blobs = t.blobs)),
    typeof t.data < 'u' && (e.data = t.data),
    typeof t.from < 'u' && (e.from = t.from),
    typeof t.gas < 'u' && (e.gas = it(t.gas)),
    typeof t.gasPrice < 'u' && (e.gasPrice = it(t.gasPrice)),
    typeof t.maxFeePerBlobGas < 'u' && (e.maxFeePerBlobGas = it(t.maxFeePerBlobGas)),
    typeof t.maxFeePerGas < 'u' && (e.maxFeePerGas = it(t.maxFeePerGas)),
    typeof t.maxPriorityFeePerGas < 'u' && (e.maxPriorityFeePerGas = it(t.maxPriorityFeePerGas)),
    typeof t.nonce < 'u' && (e.nonce = it(t.nonce)),
    typeof t.to < 'u' && (e.to = t.to),
    typeof t.type < 'u' && (e.type = kY[t.type]),
    typeof t.value < 'u' && (e.value = it(t.value)),
    e
  )
}
function UY(t) {
  return t.map(e => ({
    address: e.address,
    r: e.r ? it(BigInt(e.r)) : e.r,
    s: e.s ? it(BigInt(e.s)) : e.s,
    chainId: it(e.chainId),
    nonce: it(e.nonce),
    ...(typeof e.yParity < 'u' ? { yParity: it(e.yParity) } : {}),
    ...(typeof e.v < 'u' && typeof e.yParity > 'u' ? { v: it(e.v) } : {})
  }))
}
function p4(t) {
  if (!(!t || t.length === 0))
    return t.reduce((e, { slot: n, value: r }) => {
      if (n.length !== 66) throw new a4({ size: n.length, targetSize: 66, type: 'hex' })
      if (r.length !== 66) throw new a4({ size: r.length, targetSize: 66, type: 'hex' })
      return (e[n] = r), e
    }, {})
}
function BY(t) {
  const { balance: e, nonce: n, state: r, stateDiff: i, code: s } = t,
    c = {}
  if (
    (s !== void 0 && (c.code = s),
    e !== void 0 && (c.balance = it(e)),
    n !== void 0 && (c.nonce = it(n)),
    r !== void 0 && (c.state = p4(r)),
    i !== void 0)
  ) {
    if (c.state) throw new hY()
    c.stateDiff = p4(i)
  }
  return c
}
function n9(t) {
  if (!t) return
  const e = {}
  for (const { address: n, ...r } of t) {
    if (!Hs(n, { strict: !1 })) throw new su({ address: n })
    if (e[n]) throw new fY({ address: n })
    e[n] = BY(r)
  }
  return e
}
const LY = 2n ** 256n - 1n
function Ym(t) {
  const { account: e, gasPrice: n, maxFeePerGas: r, maxPriorityFeePerGas: i, to: s } = t,
    c = e ? Qs(e) : void 0
  if (c && !Hs(c.address)) throw new su({ address: c.address })
  if (s && !Hs(s)) throw new su({ address: s })
  if (typeof n < 'u' && (typeof r < 'u' || typeof i < 'u')) throw new gY()
  if (r && r > LY) throw new nm({ maxFeePerGas: r })
  if (i && r && i > r) throw new rm({ maxFeePerGas: r, maxPriorityFeePerGas: i })
}
class $Y extends fe {
  constructor() {
    super('`baseFeeMultiplier` must be greater than 1.', { name: 'BaseFeeScalarError' })
  }
}
class x2 extends fe {
  constructor() {
    super('Chain does not support EIP-1559 fees.', { name: 'Eip1559FeesNotSupportedError' })
  }
}
class FY extends fe {
  constructor({ maxPriorityFeePerGas: e }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${ti(e)} gwei).`, {
      name: 'MaxFeePerGasTooLowError'
    })
  }
}
class r9 extends fe {
  constructor({ blockHash: e, blockNumber: n }) {
    let r = 'Block'
    e && (r = `Block at hash "${e}"`),
      n && (r = `Block at number "${n}"`),
      super(`${r} could not be found.`, { name: 'BlockNotFoundError' })
  }
}
const i9 = {
  '0x0': 'legacy',
  '0x1': 'eip2930',
  '0x2': 'eip1559',
  '0x3': 'eip4844',
  '0x4': 'eip7702'
}
function s9(t) {
  const e = {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    chainId: t.chainId ? iu(t.chainId) : void 0,
    gas: t.gas ? BigInt(t.gas) : void 0,
    gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
    maxFeePerBlobGas: t.maxFeePerBlobGas ? BigInt(t.maxFeePerBlobGas) : void 0,
    maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: t.maxPriorityFeePerGas ? BigInt(t.maxPriorityFeePerGas) : void 0,
    nonce: t.nonce ? iu(t.nonce) : void 0,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    type: t.type ? i9[t.type] : void 0,
    typeHex: t.type ? t.type : void 0,
    value: t.value ? BigInt(t.value) : void 0,
    v: t.v ? BigInt(t.v) : void 0
  }
  return (
    t.authorizationList && (e.authorizationList = jY(t.authorizationList)),
    (e.yParity = (() => {
      if (t.yParity) return Number(t.yParity)
      if (typeof e.v == 'bigint') {
        if (e.v === 0n || e.v === 27n) return 0
        if (e.v === 1n || e.v === 28n) return 1
        if (e.v >= 35n) return e.v % 2n === 0n ? 1 : 0
      }
    })()),
    e.type === 'legacy' &&
      (delete e.accessList,
      delete e.maxFeePerBlobGas,
      delete e.maxFeePerGas,
      delete e.maxPriorityFeePerGas,
      delete e.yParity),
    e.type === 'eip2930' &&
      (delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas),
    e.type === 'eip1559' && delete e.maxFeePerBlobGas,
    e
  )
}
function jY(t) {
  return t.map(e => ({
    address: e.address,
    chainId: Number(e.chainId),
    nonce: Number(e.nonce),
    r: e.r,
    s: e.s,
    yParity: Number(e.yParity)
  }))
}
function zY(t) {
  const e = (t.transactions ?? []).map(n => (typeof n == 'string' ? n : s9(n)))
  return {
    ...t,
    baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
    blobGasUsed: t.blobGasUsed ? BigInt(t.blobGasUsed) : void 0,
    difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
    excessBlobGas: t.excessBlobGas ? BigInt(t.excessBlobGas) : void 0,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
    hash: t.hash ? t.hash : null,
    logsBloom: t.logsBloom ? t.logsBloom : null,
    nonce: t.nonce ? t.nonce : null,
    number: t.number ? BigInt(t.number) : null,
    size: t.size ? BigInt(t.size) : void 0,
    timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
    transactions: e,
    totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null
  }
}
async function Bh(t, { blockHash: e, blockNumber: n, blockTag: r, includeTransactions: i } = {}) {
  var p, g, m
  const s = r ?? 'latest',
    c = i ?? !1,
    u = n !== void 0 ? it(n) : void 0
  let f = null
  if (
    (e
      ? (f = await t.request({ method: 'eth_getBlockByHash', params: [e, c] }, { dedupe: !0 }))
      : (f = await t.request(
          { method: 'eth_getBlockByNumber', params: [u || s, c] },
          { dedupe: !!u }
        )),
    !f)
  )
    throw new r9({ blockHash: e, blockNumber: n })
  return (
    ((m = (g = (p = t.chain) == null ? void 0 : p.formatters) == null ? void 0 : g.block) == null
      ? void 0
      : m.format) || zY
  )(f)
}
async function a9(t) {
  const e = await t.request({ method: 'eth_gasPrice' })
  return BigInt(e)
}
async function qY(t, e) {
  var s, c
  const { block: n, chain: r = t.chain, request: i } = e || {}
  try {
    const u =
      ((s = r == null ? void 0 : r.fees) == null ? void 0 : s.maxPriorityFeePerGas) ??
      ((c = r == null ? void 0 : r.fees) == null ? void 0 : c.defaultPriorityFee)
    if (typeof u == 'function') {
      const d = n || (await Yt(t, Bh, 'getBlock')({})),
        p = await u({ block: d, client: t, request: i })
      if (p === null) throw new Error()
      return p
    }
    if (typeof u < 'u') return u
    const f = await t.request({ method: 'eth_maxPriorityFeePerGas' })
    return sd(f)
  } catch {
    const [u, f] = await Promise.all([
      n ? Promise.resolve(n) : Yt(t, Bh, 'getBlock')({}),
      Yt(t, a9, 'getGasPrice')({})
    ])
    if (typeof u.baseFeePerGas != 'bigint') throw new x2()
    const d = f - u.baseFeePerGas
    return d < 0n ? 0n : d
  }
}
async function g4(t, e) {
  var m, y
  const { block: n, chain: r = t.chain, request: i, type: s = 'eip1559' } = e || {},
    c = await (async () => {
      var A, E
      return typeof ((A = r == null ? void 0 : r.fees) == null ? void 0 : A.baseFeeMultiplier) ==
        'function'
        ? r.fees.baseFeeMultiplier({ block: n, client: t, request: i })
        : (((E = r == null ? void 0 : r.fees) == null ? void 0 : E.baseFeeMultiplier) ?? 1.2)
    })()
  if (c < 1) throw new $Y()
  const f = 10 ** (((m = c.toString().split('.')[1]) == null ? void 0 : m.length) ?? 0),
    d = A => (A * BigInt(Math.ceil(c * f))) / BigInt(f),
    p = n || (await Yt(t, Bh, 'getBlock')({}))
  if (
    typeof ((y = r == null ? void 0 : r.fees) == null ? void 0 : y.estimateFeesPerGas) == 'function'
  ) {
    const A = await r.fees.estimateFeesPerGas({
      block: n,
      client: t,
      multiply: d,
      request: i,
      type: s
    })
    if (A !== null) return A
  }
  if (s === 'eip1559') {
    if (typeof p.baseFeePerGas != 'bigint') throw new x2()
    const A =
        typeof (i == null ? void 0 : i.maxPriorityFeePerGas) == 'bigint'
          ? i.maxPriorityFeePerGas
          : await qY(t, { block: p, chain: r, request: i }),
      E = d(p.baseFeePerGas)
    return { maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ?? E + A, maxPriorityFeePerGas: A }
  }
  return { gasPrice: (i == null ? void 0 : i.gasPrice) ?? d(await Yt(t, a9, 'getGasPrice')({})) }
}
async function HY(t, { address: e, blockTag: n = 'latest', blockNumber: r }) {
  const i = await t.request(
    { method: 'eth_getTransactionCount', params: [e, r ? it(r) : n] },
    { dedupe: !!r }
  )
  return iu(i)
}
function o9(t) {
  const { kzg: e } = t,
    n = t.to ?? (typeof t.blobs[0] == 'string' ? 'hex' : 'bytes'),
    r = typeof t.blobs[0] == 'string' ? t.blobs.map(s => qs(s)) : t.blobs,
    i = []
  for (const s of r) i.push(Uint8Array.from(e.blobToKzgCommitment(s)))
  return n === 'bytes' ? i : i.map(s => wr(s))
}
function c9(t) {
  const { kzg: e } = t,
    n = t.to ?? (typeof t.blobs[0] == 'string' ? 'hex' : 'bytes'),
    r = typeof t.blobs[0] == 'string' ? t.blobs.map(c => qs(c)) : t.blobs,
    i = typeof t.commitments[0] == 'string' ? t.commitments.map(c => qs(c)) : t.commitments,
    s = []
  for (let c = 0; c < r.length; c++) {
    const u = r[c],
      f = i[c]
    s.push(Uint8Array.from(e.computeBlobKzgProof(u, f)))
  }
  return n === 'bytes' ? s : s.map(c => wr(c))
}
function GY(t, e) {
  return pL(Ua(t, { strict: !1 }) ? Tp(t) : t)
}
function VY(t) {
  const { commitment: e, version: n = 1 } = t,
    r = t.to ?? (typeof e == 'string' ? 'hex' : 'bytes'),
    i = GY(e)
  return i.set([n], 0), r === 'bytes' ? i : wr(i)
}
function KY(t) {
  const { commitments: e, version: n } = t,
    r = t.to,
    i = []
  for (const s of e) i.push(VY({ commitment: s, to: r, version: n }))
  return i
}
const m4 = 6,
  u9 = 32,
  N2 = 4096,
  l9 = u9 * N2,
  b4 = l9 * m4 - 1 - 1 * N2 * m4
class WY extends fe {
  constructor({ maxSize: e, size: n }) {
    super('Blob size is too large.', {
      metaMessages: [`Max: ${e} bytes`, `Given: ${n} bytes`],
      name: 'BlobSizeTooLargeError'
    })
  }
}
class QY extends fe {
  constructor() {
    super('Blob data must not be empty.', { name: 'EmptyBlobError' })
  }
}
function YY(t) {
  const e = typeof t.data == 'string' ? qs(t.data) : t.data,
    n = lr(e)
  if (!n) throw new QY()
  if (n > b4) throw new WY({ maxSize: b4, size: n })
  const r = []
  let i = !0,
    s = 0
  for (; i; ) {
    const c = v2(new Uint8Array(l9))
    let u = 0
    for (; u < N2; ) {
      const f = e.slice(s, s + (u9 - 1))
      if ((c.pushByte(0), c.pushBytes(f), f.length < 31)) {
        c.pushByte(128), (i = !1)
        break
      }
      u++, (s += 31)
    }
    r.push(c)
  }
  return r.map(c => wr(c.bytes))
}
function ZY(t) {
  const { data: e, kzg: n, to: r } = t,
    i = t.blobs ?? YY({ data: e }),
    s = t.commitments ?? o9({ blobs: i, kzg: n, to: r }),
    c = t.proofs ?? c9({ blobs: i, commitments: s, kzg: n, to: r }),
    u = []
  for (let f = 0; f < i.length; f++) u.push({ blob: i[f], commitment: s[f], proof: c[f] })
  return u
}
function XY(t) {
  if (t.type) return t.type
  if (typeof t.authorizationList < 'u') return 'eip7702'
  if (
    typeof t.blobs < 'u' ||
    typeof t.blobVersionedHashes < 'u' ||
    typeof t.maxFeePerBlobGas < 'u' ||
    typeof t.sidecars < 'u'
  )
    return 'eip4844'
  if (typeof t.maxFeePerGas < 'u' || typeof t.maxPriorityFeePerGas < 'u') return 'eip1559'
  if (typeof t.gasPrice < 'u') return typeof t.accessList < 'u' ? 'eip2930' : 'legacy'
  throw new mY({ transaction: t })
}
async function d9(t) {
  const e = await t.request({ method: 'eth_chainId' }, { dedupe: !0 })
  return iu(e)
}
const f9 = ['blobVersionedHashes', 'chainId', 'fees', 'gas', 'nonce', 'type'],
  y4 = new Map()
async function I2(t, e) {
  const {
      account: n = t.account,
      blobs: r,
      chain: i,
      gas: s,
      kzg: c,
      nonce: u,
      nonceManager: f,
      parameters: d = f9,
      type: p
    } = e,
    g = n && Qs(n),
    m = { ...e, ...(g ? { from: g == null ? void 0 : g.address } : {}) }
  let y
  async function A() {
    return y || ((y = await Yt(t, Bh, 'getBlock')({ blockTag: 'latest' })), y)
  }
  let E
  async function x() {
    return (
      E ||
      (i ? i.id : typeof e.chainId < 'u' ? e.chainId : ((E = await Yt(t, d9, 'getChainId')({})), E))
    )
  }
  if (d.includes('nonce') && typeof u > 'u' && g)
    if (f) {
      const O = await x()
      m.nonce = await f.consume({ address: g.address, chainId: O, client: t })
    } else
      m.nonce = await Yt(t, HY, 'getTransactionCount')({ address: g.address, blockTag: 'pending' })
  if ((d.includes('blobVersionedHashes') || d.includes('sidecars')) && r && c) {
    const O = o9({ blobs: r, kzg: c })
    if (d.includes('blobVersionedHashes')) {
      const I = KY({ commitments: O, to: 'hex' })
      m.blobVersionedHashes = I
    }
    if (d.includes('sidecars')) {
      const I = c9({ blobs: r, commitments: O, kzg: c }),
        M = ZY({ blobs: r, commitments: O, proofs: I, to: 'hex' })
      m.sidecars = M
    }
  }
  if (
    (d.includes('chainId') && (m.chainId = await x()),
    (d.includes('fees') || d.includes('type')) && typeof p > 'u')
  )
    try {
      m.type = XY(m)
    } catch {
      let O = y4.get(t.uid)
      if (typeof O > 'u') {
        const I = await A()
        ;(O = typeof (I == null ? void 0 : I.baseFeePerGas) == 'bigint'), y4.set(t.uid, O)
      }
      m.type = O ? 'eip1559' : 'legacy'
    }
  if (d.includes('fees'))
    if (m.type !== 'legacy' && m.type !== 'eip2930') {
      if (typeof m.maxFeePerGas > 'u' || typeof m.maxPriorityFeePerGas > 'u') {
        const O = await A(),
          { maxFeePerGas: I, maxPriorityFeePerGas: M } = await g4(t, {
            block: O,
            chain: i,
            request: m
          })
        if (typeof e.maxPriorityFeePerGas > 'u' && e.maxFeePerGas && e.maxFeePerGas < M)
          throw new FY({ maxPriorityFeePerGas: M })
        ;(m.maxPriorityFeePerGas = M), (m.maxFeePerGas = I)
      }
    } else {
      if (typeof e.maxFeePerGas < 'u' || typeof e.maxPriorityFeePerGas < 'u') throw new x2()
      if (typeof e.gasPrice > 'u') {
        const O = await A(),
          { gasPrice: I } = await g4(t, { block: O, chain: i, request: m, type: 'legacy' })
        m.gasPrice = I
      }
    }
  return (
    d.includes('gas') &&
      typeof s > 'u' &&
      (m.gas = await Yt(
        t,
        p9,
        'estimateGas'
      )({ ...m, account: g && { address: g.address, type: 'json-rpc' } })),
    Ym(m),
    delete m.parameters,
    m
  )
}
async function h9(t, { address: e, blockNumber: n, blockTag: r = 'latest' }) {
  const i = n ? it(n) : void 0,
    s = await t.request({ method: 'eth_getBalance', params: [e, i || r] })
  return BigInt(s)
}
async function p9(t, e) {
  var i, s, c
  const { account: n = t.account } = e,
    r = n ? Qs(n) : void 0
  try {
    let N = function (S) {
      const { block: k, request: F, rpcStateOverride: P } = S
      return t.request({
        method: 'eth_estimateGas',
        params: P ? [F, k ?? 'latest', P] : k ? [F, k] : [F]
      })
    }
    const {
        accessList: u,
        authorizationList: f,
        blobs: d,
        blobVersionedHashes: p,
        blockNumber: g,
        blockTag: m,
        data: y,
        gas: A,
        gasPrice: E,
        maxFeePerBlobGas: x,
        maxFeePerGas: O,
        maxPriorityFeePerGas: I,
        nonce: M,
        value: $,
        stateOverride: D,
        ...R
      } = await I2(t, {
        ...e,
        parameters: (r == null ? void 0 : r.type) === 'local' ? void 0 : ['blobVersionedHashes']
      }),
      G = (g ? it(g) : void 0) || m,
      j = n9(D),
      V = await (async () => {
        if (R.to) return R.to
        if (f && f.length > 0)
          return await t9({ authorization: f[0] }).catch(() => {
            throw new fe('`to` is required. Could not infer from `authorizationList`')
          })
      })()
    Ym(e)
    const L =
        (c =
          (s = (i = t.chain) == null ? void 0 : i.formatters) == null
            ? void 0
            : s.transactionRequest) == null
          ? void 0
          : c.format,
      C = (L || T2)({
        ...S2(R, { format: L }),
        from: r == null ? void 0 : r.address,
        accessList: u,
        authorizationList: f,
        blobs: d,
        blobVersionedHashes: p,
        data: y,
        gas: A,
        gasPrice: E,
        maxFeePerBlobGas: x,
        maxFeePerGas: O,
        maxPriorityFeePerGas: I,
        nonce: M,
        to: V,
        value: $
      })
    let T = BigInt(await N({ block: G, request: C, rpcStateOverride: j }))
    if (f) {
      const S = await h9(t, { address: C.from }),
        k = await Promise.all(
          f.map(async F => {
            const { address: P } = F,
              w = await N({
                block: G,
                request: {
                  authorizationList: void 0,
                  data: y,
                  from: r == null ? void 0 : r.address,
                  to: P,
                  value: it(S)
                },
                rpcStateOverride: j
              }).catch(() => 100000n)
            return 2n * BigInt(w)
          })
        )
      T += k.reduce((F, P) => F + P, 0n)
    }
    return T
  } catch (u) {
    throw MY(u, { ...e, account: r, chain: t.chain })
  }
}
function JY(t, e) {
  if (!Hs(t, { strict: !1 })) throw new su({ address: t })
  if (!Hs(e, { strict: !1 })) throw new su({ address: e })
  return t.toLowerCase() === e.toLowerCase()
}
const v4 = '/docs/contract/decodeEventLog'
function eZ(t) {
  const { abi: e, data: n, strict: r, topics: i } = t,
    s = r ?? !0,
    [c, ...u] = i
  if (!c) throw new mQ({ docsPath: v4 })
  const f = e.length === 1 ? e[0] : e.find(E => E.type === 'event' && c === h2(Go(E)))
  if (!(f && 'name' in f) || f.type !== 'event') throw new PN(c, { docsPath: v4 })
  const { name: d, inputs: p } = f,
    g = p == null ? void 0 : p.some(E => !('name' in E && E.name))
  let m = g ? [] : {}
  const y = p.filter(E => 'indexed' in E && E.indexed)
  for (let E = 0; E < y.length; E++) {
    const x = y[E],
      O = u[E]
    if (!O) throw new MN({ abiItem: f, param: x })
    m[g ? E : x.name || E] = tZ({ param: x, value: O })
  }
  const A = p.filter(E => !('indexed' in E && E.indexed))
  if (A.length > 0) {
    if (n && n !== '0x')
      try {
        const E = Wm(A, n)
        if (E)
          if (g) m = [...m, ...E]
          else for (let x = 0; x < A.length; x++) m[A[x].name] = E[x]
      } catch (E) {
        if (s)
          throw E instanceof RN || E instanceof KN
            ? new Ww({ abiItem: f, data: n, params: A, size: lr(n) })
            : E
      }
    else if (s) throw new Ww({ abiItem: f, data: '0x', params: A, size: 0 })
  }
  return { eventName: d, args: Object.values(m).length > 0 ? m : void 0 }
}
function tZ({ param: t, value: e }) {
  return t.type === 'string' ||
    t.type === 'bytes' ||
    t.type === 'tuple' ||
    t.type.match(/^(.*)\[(\d+)?\]$/)
    ? e
    : (Wm([t], e) || [])[0]
}
function nZ(t) {
  const { abi: e, args: n, logs: r, strict: i = !0 } = t,
    s = (() => {
      if (t.eventName) return Array.isArray(t.eventName) ? t.eventName : [t.eventName]
    })()
  return r
    .map(c => {
      var u
      try {
        const f = e.find(p => p.type === 'event' && c.topics[0] === h2(p))
        if (!f) return null
        const d = eZ({ ...c, abi: [f], strict: i })
        return (s && !s.includes(d.eventName)) ||
          !rZ({ args: d.args, inputs: f.inputs, matchArgs: n })
          ? null
          : { ...d, ...c }
      } catch (f) {
        let d, p
        if (f instanceof PN) return null
        if (f instanceof Ww || f instanceof MN) {
          if (i) return null
          ;(d = f.abiItem.name),
            (p = (u = f.abiItem.inputs) == null ? void 0 : u.some(g => !('name' in g && g.name)))
        }
        return { ...c, args: p ? [] : {}, eventName: d }
      }
    })
    .filter(Boolean)
}
function rZ(t) {
  const { args: e, inputs: n, matchArgs: r } = t
  if (!r) return !0
  if (!e) return !1
  function i(s, c, u) {
    try {
      return s.type === 'address'
        ? JY(c, u)
        : s.type === 'string' || s.type === 'bytes'
          ? Vo(Tp(c)) === u
          : c === u
    } catch {
      return !1
    }
  }
  return Array.isArray(e) && Array.isArray(r)
    ? r.every((s, c) => {
        if (s == null) return !0
        const u = n[c]
        return u ? (Array.isArray(s) ? s : [s]).some(d => i(u, d, e[c])) : !1
      })
    : typeof e == 'object' && !Array.isArray(e) && typeof r == 'object' && !Array.isArray(r)
      ? Object.entries(r).every(([s, c]) => {
          if (c == null) return !0
          const u = n.find(d => d.name === s)
          return u ? (Array.isArray(c) ? c : [c]).some(d => i(u, d, e[s])) : !1
        })
      : !1
}
function g9(t, { args: e, eventName: n } = {}) {
  return {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    logIndex: t.logIndex ? Number(t.logIndex) : null,
    transactionHash: t.transactionHash ? t.transactionHash : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    ...(n ? { args: e, eventName: n } : {})
  }
}
const R1 = '/docs/contract/decodeFunctionResult'
function Np(t) {
  const { abi: e, args: n, functionName: r, data: i } = t
  let s = e[0]
  if (r) {
    const u = y2({ abi: e, args: n, name: r })
    if (!u) throw new Jg(r, { docsPath: R1 })
    s = u
  }
  if (s.type !== 'function') throw new Jg(void 0, { docsPath: R1 })
  if (!s.outputs) throw new bQ(s.name, { docsPath: R1 })
  const c = Wm(s.outputs, i)
  if (c && c.length > 1) return c
  if (c && c.length === 1) return c[0]
}
const aE = [
    {
      inputs: [
        {
          components: [
            { name: 'target', type: 'address' },
            { name: 'allowFailure', type: 'bool' },
            { name: 'callData', type: 'bytes' }
          ],
          name: 'calls',
          type: 'tuple[]'
        }
      ],
      name: 'aggregate3',
      outputs: [
        {
          components: [
            { name: 'success', type: 'bool' },
            { name: 'returnData', type: 'bytes' }
          ],
          name: 'returnData',
          type: 'tuple[]'
        }
      ],
      stateMutability: 'view',
      type: 'function'
    }
  ],
  m9 = [
    { inputs: [], name: 'ResolverNotFound', type: 'error' },
    { inputs: [], name: 'ResolverWildcardNotSupported', type: 'error' },
    { inputs: [], name: 'ResolverNotContract', type: 'error' },
    { inputs: [{ name: 'returnData', type: 'bytes' }], name: 'ResolverError', type: 'error' },
    {
      inputs: [
        {
          components: [
            { name: 'status', type: 'uint16' },
            { name: 'message', type: 'string' }
          ],
          name: 'errors',
          type: 'tuple[]'
        }
      ],
      name: 'HttpError',
      type: 'error'
    }
  ],
  b9 = [
    ...m9,
    {
      name: 'resolve',
      type: 'function',
      stateMutability: 'view',
      inputs: [
        { name: 'name', type: 'bytes' },
        { name: 'data', type: 'bytes' }
      ],
      outputs: [
        { name: '', type: 'bytes' },
        { name: 'address', type: 'address' }
      ]
    },
    {
      name: 'resolve',
      type: 'function',
      stateMutability: 'view',
      inputs: [
        { name: 'name', type: 'bytes' },
        { name: 'data', type: 'bytes' },
        { name: 'gateways', type: 'string[]' }
      ],
      outputs: [
        { name: '', type: 'bytes' },
        { name: 'address', type: 'address' }
      ]
    }
  ],
  iZ = [
    ...m9,
    {
      name: 'reverse',
      type: 'function',
      stateMutability: 'view',
      inputs: [{ type: 'bytes', name: 'reverseName' }],
      outputs: [
        { type: 'string', name: 'resolvedName' },
        { type: 'address', name: 'resolvedAddress' },
        { type: 'address', name: 'reverseResolver' },
        { type: 'address', name: 'resolver' }
      ]
    },
    {
      name: 'reverse',
      type: 'function',
      stateMutability: 'view',
      inputs: [
        { type: 'bytes', name: 'reverseName' },
        { type: 'string[]', name: 'gateways' }
      ],
      outputs: [
        { type: 'string', name: 'resolvedName' },
        { type: 'address', name: 'resolvedAddress' },
        { type: 'address', name: 'reverseResolver' },
        { type: 'address', name: 'resolver' }
      ]
    }
  ],
  w4 = [
    {
      name: 'text',
      type: 'function',
      stateMutability: 'view',
      inputs: [
        { name: 'name', type: 'bytes32' },
        { name: 'key', type: 'string' }
      ],
      outputs: [{ name: '', type: 'string' }]
    }
  ],
  E4 = [
    {
      name: 'addr',
      type: 'function',
      stateMutability: 'view',
      inputs: [{ name: 'name', type: 'bytes32' }],
      outputs: [{ name: '', type: 'address' }]
    },
    {
      name: 'addr',
      type: 'function',
      stateMutability: 'view',
      inputs: [
        { name: 'name', type: 'bytes32' },
        { name: 'coinType', type: 'uint256' }
      ],
      outputs: [{ name: '', type: 'bytes' }]
    }
  ],
  sZ = '0x82ad56cb',
  aZ =
    '0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe',
  oZ =
    '0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe'
class oE extends fe {
  constructor({ blockNumber: e, chain: n, contract: r }) {
    super(`Chain "${n.name}" does not support contract "${r.name}".`, {
      metaMessages: [
        'This could be due to any of the following:',
        ...(e && r.blockCreated && r.blockCreated > e
          ? [
              `- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${e}).`
            ]
          : [`- The chain does not have the contract "${r.name}" configured.`])
      ],
      name: 'ChainDoesNotSupportContract'
    })
  }
}
class cZ extends fe {
  constructor({ chain: e, currentChainId: n }) {
    super(
      `The current chain of the wallet (id: ${n}) does not match the target chain for the transaction (id: ${e.id} – ${e.name}).`,
      {
        metaMessages: [`Current Chain ID:  ${n}`, `Expected Chain ID: ${e.id} – ${e.name}`],
        name: 'ChainMismatchError'
      }
    )
  }
}
class uZ extends fe {
  constructor() {
    super(
      [
        'No chain was provided to the request.',
        'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.'
      ].join(`
`),
      { name: 'ChainNotFoundError' }
    )
  }
}
class y9 extends fe {
  constructor() {
    super('No chain was provided to the Client.', { name: 'ClientChainNotConfiguredError' })
  }
}
const D1 = '/docs/contract/encodeDeployData'
function v9(t) {
  const { abi: e, args: n, bytecode: r } = t
  if (!n || n.length === 0) return r
  const i = e.find(c => 'type' in c && c.type === 'constructor')
  if (!i) throw new fQ({ docsPath: D1 })
  if (!('inputs' in i)) throw new s4({ docsPath: D1 })
  if (!i.inputs || i.inputs.length === 0) throw new s4({ docsPath: D1 })
  const s = HN(i.inputs, n)
  return Km([r, s])
}
function Ip({ blockNumber: t, chain: e, contract: n }) {
  var i
  const r = (i = e == null ? void 0 : e.contracts) == null ? void 0 : i[n]
  if (!r) throw new oE({ chain: e, contract: { name: n } })
  if (t && r.blockCreated && r.blockCreated > t)
    throw new oE({ blockNumber: t, chain: e, contract: { name: n, blockCreated: r.blockCreated } })
  return r.address
}
function lZ(t, { docsPath: e, ...n }) {
  const r = (() => {
    const i = C2(t, n)
    return i instanceof Qm ? t : i
  })()
  return new wY(r, { docsPath: e, ...n })
}
function w9() {
  let t = () => {},
    e = () => {}
  return {
    promise: new Promise((r, i) => {
      ;(t = r), (e = i)
    }),
    resolve: t,
    reject: e
  }
}
const P1 = new Map()
function E9({ fn: t, id: e, shouldSplitBatch: n, wait: r = 0, sort: i }) {
  const s = async () => {
      const p = f()
      c()
      const g = p.map(({ args: m }) => m)
      g.length !== 0 &&
        t(g)
          .then(m => {
            i && Array.isArray(m) && m.sort(i)
            for (let y = 0; y < p.length; y++) {
              const { resolve: A } = p[y]
              A == null || A([m[y], m])
            }
          })
          .catch(m => {
            for (let y = 0; y < p.length; y++) {
              const { reject: A } = p[y]
              A == null || A(m)
            }
          })
    },
    c = () => P1.delete(e),
    u = () => f().map(({ args: p }) => p),
    f = () => P1.get(e) || [],
    d = p => P1.set(e, [...f(), p])
  return {
    flush: c,
    async schedule(p) {
      const { promise: g, resolve: m, reject: y } = w9()
      return (
        (n == null ? void 0 : n([...u(), p])) && s(),
        f().length > 0
          ? (d({ args: p, resolve: m, reject: y }), g)
          : (d({ args: p, resolve: m, reject: y }), setTimeout(s, r), g)
      )
    }
  }
}
async function A9(t, e) {
  var L, v, C, N
  const {
      account: n = t.account,
      batch: r = !!((L = t.batch) != null && L.multicall),
      blockNumber: i,
      blockTag: s = 'latest',
      accessList: c,
      blobs: u,
      code: f,
      data: d,
      factory: p,
      factoryData: g,
      gas: m,
      gasPrice: y,
      maxFeePerBlobGas: A,
      maxFeePerGas: E,
      maxPriorityFeePerGas: x,
      nonce: O,
      to: I,
      value: M,
      stateOverride: $,
      ...D
    } = e,
    R = n ? Qs(n) : void 0
  if (f && (p || g))
    throw new fe('Cannot provide both `code` & `factory`/`factoryData` as parameters.')
  if (f && I) throw new fe('Cannot provide both `code` & `to` as parameters.')
  const z = f && d,
    G = p && g && I && d,
    j = z || G,
    V = z ? hZ({ code: f, data: d }) : G ? pZ({ data: d, factory: p, factoryData: g, to: I }) : d
  try {
    Ym(e)
    const S = (i ? it(i) : void 0) || s,
      k = n9($),
      F =
        (N =
          (C = (v = t.chain) == null ? void 0 : v.formatters) == null
            ? void 0
            : C.transactionRequest) == null
          ? void 0
          : N.format,
      w = (F || T2)({
        ...S2(D, { format: F }),
        from: R == null ? void 0 : R.address,
        accessList: c,
        blobs: u,
        data: V,
        gas: m,
        gasPrice: y,
        maxFeePerBlobGas: A,
        maxFeePerGas: E,
        maxPriorityFeePerGas: x,
        nonce: O,
        to: j ? void 0 : I,
        value: M
      })
    if (r && dZ({ request: w }) && !k)
      try {
        return await fZ(t, { ...w, blockNumber: i, blockTag: s })
      } catch (Z) {
        if (!(Z instanceof y9) && !(Z instanceof oE)) throw Z
      }
    const B = await t.request({ method: 'eth_call', params: k ? [w, S, k] : [w, S] })
    return B === '0x' ? { data: void 0 } : { data: B }
  } catch (T) {
    const S = gZ(T),
      { offchainLookup: k, offchainLookupSignature: F } = await ei(async () => {
        const { offchainLookup: P, offchainLookupSignature: w } = await import('./ccip-3DDqDkWC.js')
        return { offchainLookup: P, offchainLookupSignature: w }
      }, [])
    if (t.ccipRead !== !1 && (S == null ? void 0 : S.slice(0, 10)) === F && I)
      return { data: await k(t, { data: S, to: I }) }
    throw j && (S == null ? void 0 : S.slice(0, 10)) === '0x101bb98d'
      ? new AY({ factory: p })
      : lZ(T, { ...e, account: R, chain: t.chain })
  }
}
function dZ({ request: t }) {
  const { data: e, to: n, ...r } = t
  return !(!e || e.startsWith(sZ) || !n || Object.values(r).filter(i => typeof i < 'u').length > 0)
}
async function fZ(t, e) {
  var E
  const { batchSize: n = 1024, wait: r = 0 } =
      typeof ((E = t.batch) == null ? void 0 : E.multicall) == 'object' ? t.batch.multicall : {},
    { blockNumber: i, blockTag: s = 'latest', data: c, multicallAddress: u, to: f } = e
  let d = u
  if (!d) {
    if (!t.chain) throw new y9()
    d = Ip({ blockNumber: i, chain: t.chain, contract: 'multicall3' })
  }
  const g = (i ? it(i) : void 0) || s,
    { schedule: m } = E9({
      id: `${t.uid}.${g}`,
      wait: r,
      shouldSplitBatch(x) {
        return x.reduce((I, { data: M }) => I + (M.length - 2), 0) > n * 2
      },
      fn: async x => {
        const O = x.map($ => ({ allowFailure: !0, callData: $.data, target: $.to })),
          I = Td({ abi: aE, args: [O], functionName: 'aggregate3' }),
          M = await t.request({ method: 'eth_call', params: [{ data: I, to: d }, g] })
        return Np({ abi: aE, args: [O], functionName: 'aggregate3', data: M || '0x' })
      }
    }),
    [{ returnData: y, success: A }] = await m({ data: c, to: f })
  if (!A) throw new A2({ data: y })
  return y === '0x' ? { data: void 0 } : { data: y }
}
function hZ(t) {
  const { code: e, data: n } = t
  return v9({ abi: jT(['constructor(bytes, bytes)']), bytecode: aZ, args: [e, n] })
}
function pZ(t) {
  const { data: e, factory: n, factoryData: r, to: i } = t
  return v9({
    abi: jT(['constructor(address, bytes, address, bytes)']),
    bytecode: oZ,
    args: [i, e, n, r]
  })
}
function gZ(t) {
  var n
  if (!(t instanceof fe)) return
  const e = t.walk()
  return typeof (e == null ? void 0 : e.data) == 'object'
    ? (n = e.data) == null
      ? void 0
      : n.data
    : e.data
}
async function cu(t, e) {
  const { abi: n, address: r, args: i, functionName: s, ...c } = e,
    u = Td({ abi: n, args: i, functionName: s })
  try {
    const { data: f } = await Yt(t, A9, 'call')({ ...c, data: u, to: r })
    return Np({ abi: n, args: i, functionName: s, data: f || '0x' })
  } catch (f) {
    throw tm(f, {
      abi: n,
      address: r,
      args: i,
      docsPath: '/docs/contract/readContract',
      functionName: s
    })
  }
}
const M1 = new Map(),
  A4 = new Map()
let mZ = 0
function im(t, e, n) {
  const r = ++mZ,
    i = () => M1.get(t) || [],
    s = () => {
      const p = i()
      M1.set(
        t,
        p.filter(g => g.id !== r)
      )
    },
    c = () => {
      const p = i()
      if (!p.some(m => m.id === r)) return
      const g = A4.get(t)
      p.length === 1 && g && g(), s()
    },
    u = i()
  if ((M1.set(t, [...u, { id: r, fns: e }]), u && u.length > 0)) return c
  const f = {}
  for (const p in e)
    f[p] = (...g) => {
      var y, A
      const m = i()
      if (m.length !== 0) for (const E of m) (A = (y = E.fns)[p]) == null || A.call(y, ...g)
    }
  const d = n(f)
  return typeof d == 'function' && A4.set(t, d), c
}
async function sm(t) {
  return new Promise(e => setTimeout(e, t))
}
function _9(t, { emitOnBegin: e, initialWaitTime: n, interval: r }) {
  let i = !0
  const s = () => (i = !1)
  return (
    (async () => {
      let u
      e && (u = await t({ unpoll: s }))
      const f = (await (n == null ? void 0 : n(u))) ?? r
      await sm(f)
      const d = async () => {
        i && (await t({ unpoll: s }), await sm(r), d())
      }
      d()
    })(),
    s
  )
}
const bZ = new Map(),
  yZ = new Map()
function vZ(t) {
  const e = (i, s) => ({ clear: () => s.delete(i), get: () => s.get(i), set: c => s.set(i, c) }),
    n = e(t, bZ),
    r = e(t, yZ)
  return {
    clear: () => {
      n.clear(), r.clear()
    },
    promise: n,
    response: r
  }
}
async function wZ(t, { cacheKey: e, cacheTime: n = Number.POSITIVE_INFINITY }) {
  const r = vZ(e),
    i = r.response.get()
  if (i && n > 0 && new Date().getTime() - i.created.getTime() < n) return i.data
  let s = r.promise.get()
  s || ((s = t()), r.promise.set(s))
  try {
    const c = await s
    return r.response.set({ created: new Date(), data: c }), c
  } finally {
    r.promise.clear()
  }
}
const EZ = t => `blockNumber.${t}`
async function AZ(t, { cacheTime: e = t.cacheTime } = {}) {
  const n = await wZ(() => t.request({ method: 'eth_blockNumber' }), {
    cacheKey: EZ(t.uid),
    cacheTime: e
  })
  return BigInt(n)
}
async function _Z(t, { filter: e }) {
  const n = 'strict' in e && e.strict,
    r = await e.request({ method: 'eth_getFilterChanges', params: [e.id] })
  if (typeof r[0] == 'string') return r
  const i = r.map(s => g9(s))
  return !('abi' in e) || !e.abi ? i : nZ({ abi: e.abi, logs: i, strict: n })
}
async function CZ(t, { filter: e }) {
  return e.request({ method: 'eth_uninstallFilter', params: [e.id] })
}
class O2 extends fe {
  constructor({ docsPath: e } = {}) {
    super(
      [
        'Could not find an Account to execute with this Action.',
        'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.'
      ].join(`
`),
      { docsPath: e, docsSlug: 'account', name: 'AccountNotFoundError' }
    )
  }
}
class k1 extends fe {
  constructor({ docsPath: e, metaMessages: n, type: r }) {
    super(`Account type "${r}" is not supported.`, {
      docsPath: e,
      metaMessages: n,
      name: 'AccountTypeNotSupportedError'
    })
  }
}
function SZ({ chain: t, currentChainId: e }) {
  if (!t) throw new uZ()
  if (e !== t.id) throw new cZ({ chain: t, currentChainId: e })
}
function TZ(t, { docsPath: e, ...n }) {
  const r = (() => {
    const i = C2(t, n)
    return i instanceof Qm ? t : i
  })()
  return new bY(r, { docsPath: e, ...n })
}
async function xZ(t, { serializedTransaction: e }) {
  return t.request({ method: 'eth_sendRawTransaction', params: [e] }, { retryCount: 0 })
}
const U1 = new Gm(128)
async function C9(t, e) {
  var O, I, M, $
  const {
    account: n = t.account,
    chain: r = t.chain,
    accessList: i,
    authorizationList: s,
    blobs: c,
    data: u,
    gas: f,
    gasPrice: d,
    maxFeePerBlobGas: p,
    maxFeePerGas: g,
    maxPriorityFeePerGas: m,
    nonce: y,
    value: A,
    ...E
  } = e
  if (typeof n > 'u') throw new O2({ docsPath: '/docs/actions/wallet/sendTransaction' })
  const x = n ? Qs(n) : null
  try {
    Ym(e)
    const D = await (async () => {
      if (e.to) return e.to
      if (e.to !== null && s && s.length > 0)
        return await t9({ authorization: s[0] }).catch(() => {
          throw new fe('`to` is required. Could not infer from `authorizationList`.')
        })
    })()
    if ((x == null ? void 0 : x.type) === 'json-rpc' || x === null) {
      let R
      r !== null && ((R = await Yt(t, d9, 'getChainId')({})), SZ({ currentChainId: R, chain: r }))
      const z =
          (M =
            (I = (O = t.chain) == null ? void 0 : O.formatters) == null
              ? void 0
              : I.transactionRequest) == null
            ? void 0
            : M.format,
        j = (z || T2)({
          ...S2(E, { format: z }),
          accessList: i,
          authorizationList: s,
          blobs: c,
          chainId: R,
          data: u,
          from: x == null ? void 0 : x.address,
          gas: f,
          gasPrice: d,
          maxFeePerBlobGas: p,
          maxFeePerGas: g,
          maxPriorityFeePerGas: m,
          nonce: y,
          to: D,
          value: A
        }),
        V = U1.get(t.uid),
        L = V ? 'wallet_sendTransaction' : 'eth_sendTransaction'
      try {
        return await t.request({ method: L, params: [j] }, { retryCount: 0 })
      } catch (v) {
        if (V === !1) throw v
        const C = v
        if (
          C.name === 'InvalidInputRpcError' ||
          C.name === 'InvalidParamsRpcError' ||
          C.name === 'MethodNotFoundRpcError' ||
          C.name === 'MethodNotSupportedRpcError'
        )
          return await t
            .request({ method: 'wallet_sendTransaction', params: [j] }, { retryCount: 0 })
            .then(N => (U1.set(t.uid, !0), N))
            .catch(N => {
              const T = N
              throw T.name === 'MethodNotFoundRpcError' || T.name === 'MethodNotSupportedRpcError'
                ? (U1.set(t.uid, !1), C)
                : T
            })
        throw C
      }
    }
    if ((x == null ? void 0 : x.type) === 'local') {
      const R = await Yt(
          t,
          I2,
          'prepareTransactionRequest'
        )({
          account: x,
          accessList: i,
          authorizationList: s,
          blobs: c,
          chain: r,
          data: u,
          gas: f,
          gasPrice: d,
          maxFeePerBlobGas: p,
          maxFeePerGas: g,
          maxPriorityFeePerGas: m,
          nonce: y,
          nonceManager: x.nonceManager,
          parameters: [...f9, 'sidecars'],
          value: A,
          ...E,
          to: D
        }),
        z = ($ = r == null ? void 0 : r.serializers) == null ? void 0 : $.transaction,
        G = await x.signTransaction(R, { serializer: z })
      return await Yt(t, xZ, 'sendRawTransaction')({ serializedTransaction: G })
    }
    throw (x == null ? void 0 : x.type) === 'smart'
      ? new k1({
          metaMessages: ['Consider using the `sendUserOperation` Action instead.'],
          docsPath: '/docs/actions/bundler/sendUserOperation',
          type: 'smart'
        })
      : new k1({
          docsPath: '/docs/actions/wallet/sendTransaction',
          type: x == null ? void 0 : x.type
        })
  } catch (D) {
    throw D instanceof k1 ? D : TZ(D, { ...e, account: x, chain: e.chain || void 0 })
  }
}
async function NZ(t, e) {
  const {
    abi: n,
    account: r = t.account,
    address: i,
    args: s,
    dataSuffix: c,
    functionName: u,
    ...f
  } = e
  if (typeof r > 'u') throw new O2({ docsPath: '/docs/contract/writeContract' })
  const d = r ? Qs(r) : null,
    p = Td({ abi: n, args: s, functionName: u })
  try {
    return await Yt(
      t,
      C9,
      'sendTransaction'
    )({ data: `${p}${c ? c.replace('0x', '') : ''}`, to: i, account: d, ...f })
  } catch (g) {
    throw tm(g, {
      abi: n,
      address: i,
      args: s,
      docsPath: '/docs/contract/writeContract',
      functionName: u,
      sender: d == null ? void 0 : d.address
    })
  }
}
const cE = 256
let hg = cE,
  pg
function S9(t = 11) {
  if (!pg || hg + t > cE * 2) {
    ;(pg = ''), (hg = 0)
    for (let e = 0; e < cE; e++) pg += ((256 + Math.random() * 256) | 0).toString(16).substring(1)
  }
  return pg.substring(hg, hg++ + t)
}
function T9(t) {
  const {
      batch: e,
      cacheTime: n = t.pollingInterval ?? 4e3,
      ccipRead: r,
      key: i = 'base',
      name: s = 'Base Client',
      pollingInterval: c = 4e3,
      type: u = 'base'
    } = t,
    f = t.chain,
    d = t.account ? Qs(t.account) : void 0,
    { config: p, request: g, value: m } = t.transport({ chain: f, pollingInterval: c }),
    y = { ...p, ...m },
    A = {
      account: d,
      batch: e,
      cacheTime: n,
      ccipRead: r,
      chain: f,
      key: i,
      name: s,
      pollingInterval: c,
      request: g,
      transport: y,
      type: u,
      uid: S9()
    }
  function E(x) {
    return O => {
      const I = O(x)
      for (const $ in A) delete I[$]
      const M = { ...x, ...I }
      return Object.assign(M, { extend: E(M) })
    }
  }
  return Object.assign(A, { extend: E(A) })
}
const gg = new Gm(8192)
function IZ(t, { enabled: e = !0, id: n }) {
  if (!e || !n) return t()
  if (gg.get(n)) return gg.get(n)
  const r = t().finally(() => gg.delete(n))
  return gg.set(n, r), r
}
function am(t, { delay: e = 100, retryCount: n = 2, shouldRetry: r = () => !0 } = {}) {
  return new Promise((i, s) => {
    const c = async ({ count: u = 0 } = {}) => {
      const f = async ({ error: d }) => {
        const p = typeof e == 'function' ? e({ count: u, error: d }) : e
        p && (await sm(p)), c({ count: u + 1 })
      }
      try {
        const d = await t()
        i(d)
      } catch (d) {
        if (u < n && (await r({ count: u, error: d }))) return f({ error: d })
        s(d)
      }
    }
    c()
  })
}
function OZ(t, e = {}) {
  return async (n, r = {}) => {
    var g
    const {
        dedupe: i = !1,
        methods: s,
        retryDelay: c = 150,
        retryCount: u = 3,
        uid: f
      } = { ...e, ...r },
      { method: d } = n
    if ((g = s == null ? void 0 : s.exclude) != null && g.includes(d))
      throw new Pc(new Error('method not supported'), { method: d })
    if (s != null && s.include && !s.include.includes(d))
      throw new Pc(new Error('method not supported'), { method: d })
    const p = i ? Hm(`${f}.${ji(n)}`) : void 0
    return IZ(
      () =>
        am(
          async () => {
            try {
              return await t(n)
            } catch (m) {
              const y = m
              switch (y.code) {
                case Th.code:
                  throw new Th(y)
                case xh.code:
                  throw new xh(y)
                case Nh.code:
                  throw new Nh(y, { method: n.method })
                case Ih.code:
                  throw new Ih(y)
                case ou.code:
                  throw new ou(y)
                case Oh.code:
                  throw new Oh(y)
                case Rh.code:
                  throw new Rh(y)
                case jo.code:
                  throw new jo(y)
                case ad.code:
                  throw new ad(y)
                case Pc.code:
                  throw new Pc(y, { method: n.method })
                case od.code:
                  throw new od(y)
                case Dh.code:
                  throw new Dh(y)
                case Xn.code:
                  throw new Xn(y)
                case Ph.code:
                  throw new Ph(y)
                case Mh.code:
                  throw new Mh(y)
                case kh.code:
                  throw new kh(y)
                case Uh.code:
                  throw new Uh(y)
                case Gs.code:
                  throw new Gs(y)
                case 5e3:
                  throw new Xn(y)
                default:
                  throw m instanceof fe ? m : new CY(y)
              }
            }
          },
          {
            delay: ({ count: m, error: y }) => {
              var A
              if (y && y instanceof hh) {
                const E =
                  (A = y == null ? void 0 : y.headers) == null ? void 0 : A.get('Retry-After')
                if (E != null && E.match(/\d/)) return Number.parseInt(E) * 1e3
              }
              return ~~(1 << m) * c
            },
            retryCount: u,
            shouldRetry: ({ error: m }) => RZ(m)
          }
        ),
      { enabled: i, id: p }
    )
  }
}
function RZ(t) {
  return 'code' in t && typeof t.code == 'number'
    ? t.code === -1 || t.code === od.code || t.code === ou.code
    : t instanceof hh && t.status
      ? t.status === 403 ||
        t.status === 408 ||
        t.status === 413 ||
        t.status === 429 ||
        t.status === 500 ||
        t.status === 502 ||
        t.status === 503 ||
        t.status === 504
      : !0
}
function R2(
  {
    key: t,
    methods: e,
    name: n,
    request: r,
    retryCount: i = 3,
    retryDelay: s = 150,
    timeout: c,
    type: u
  },
  f
) {
  const d = S9()
  return {
    config: {
      key: t,
      methods: e,
      name: n,
      request: r,
      retryCount: i,
      retryDelay: s,
      timeout: c,
      type: u
    },
    request: OZ(r, { methods: e, retryCount: i, retryDelay: s, uid: d }),
    value: f
  }
}
function DZ(t, e = {}) {
  const { key: n = 'custom', methods: r, name: i = 'Custom Provider', retryDelay: s } = e
  return ({ retryCount: c }) =>
    R2({
      key: n,
      methods: r,
      name: i,
      request: t.request.bind(t),
      retryCount: e.retryCount ?? c,
      retryDelay: s,
      type: 'custom'
    })
}
function PZ(t, e = {}) {
  const {
    key: n = 'fallback',
    name: r = 'Fallback',
    rank: i = !1,
    shouldThrow: s = MZ,
    retryCount: c,
    retryDelay: u
  } = e
  return ({ chain: f, pollingInterval: d = 4e3, timeout: p, ...g }) => {
    let m = t,
      y = () => {}
    const A = R2(
      {
        key: n,
        name: r,
        async request({ method: E, params: x }) {
          let O
          const I = async (M = 0) => {
            const $ = m[M]({ ...g, chain: f, retryCount: 0, timeout: p })
            try {
              const D = await $.request({ method: E, params: x })
              return y({ method: E, params: x, response: D, transport: $, status: 'success' }), D
            } catch (D) {
              if (
                (y({ error: D, method: E, params: x, transport: $, status: 'error' }),
                s(D) ||
                  M === m.length - 1 ||
                  (O ??
                    (O = m.slice(M + 1).some(R => {
                      const { include: z, exclude: G } = R({ chain: f }).config.methods || {}
                      return z ? z.includes(E) : G ? !G.includes(E) : !0
                    })),
                  !O))
              )
                throw D
              return I(M + 1)
            }
          }
          return I()
        },
        retryCount: c,
        retryDelay: u,
        type: 'fallback'
      },
      { onResponse: E => (y = E), transports: m.map(E => E({ chain: f, retryCount: 0 })) }
    )
    if (i) {
      const E = typeof i == 'object' ? i : {}
      kZ({
        chain: f,
        interval: E.interval ?? d,
        onTransports: x => (m = x),
        ping: E.ping,
        sampleCount: E.sampleCount,
        timeout: E.timeout,
        transports: m,
        weights: E.weights
      })
    }
    return A
  }
}
function MZ(t) {
  return !!(
    'code' in t &&
    typeof t.code == 'number' &&
    (t.code === ad.code || t.code === Xn.code || Mc.nodeMessage.test(t.message) || t.code === 5e3)
  )
}
function kZ({
  chain: t,
  interval: e = 4e3,
  onTransports: n,
  ping: r,
  sampleCount: i = 10,
  timeout: s = 1e3,
  transports: c,
  weights: u = {}
}) {
  const { stability: f = 0.7, latency: d = 0.3 } = u,
    p = [],
    g = async () => {
      const m = await Promise.all(
        c.map(async E => {
          const x = E({ chain: t, retryCount: 0, timeout: s }),
            O = Date.now()
          let I, M
          try {
            await (r ? r({ transport: x }) : x.request({ method: 'net_listening' })), (M = 1)
          } catch {
            M = 0
          } finally {
            I = Date.now()
          }
          return { latency: I - O, success: M }
        })
      )
      p.push(m), p.length > i && p.shift()
      const y = Math.max(...p.map(E => Math.max(...E.map(({ latency: x }) => x)))),
        A = c
          .map((E, x) => {
            const O = p.map(R => R[x].latency),
              M = 1 - O.reduce((R, z) => R + z, 0) / O.length / y,
              $ = p.map(R => R[x].success),
              D = $.reduce((R, z) => R + z, 0) / $.length
            return D === 0 ? [0, x] : [d * M + f * D, x]
          })
          .sort((E, x) => x[0] - E[0])
      n(A.map(([, E]) => c[E])), await sm(e), g()
    }
  g()
}
class UZ extends fe {
  constructor() {
    super(
      'No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.',
      { docsPath: '/docs/clients/intro', name: 'UrlRequiredError' }
    )
  }
}
function x9(t, { errorInstance: e = new Error('timed out'), timeout: n, signal: r }) {
  return new Promise((i, s) => {
    ;(async () => {
      let c
      try {
        const u = new AbortController()
        n > 0 &&
          (c = setTimeout(() => {
            r ? u.abort() : s(e)
          }, n)),
          i(await t({ signal: (u == null ? void 0 : u.signal) || null }))
      } catch (u) {
        ;(u == null ? void 0 : u.name) === 'AbortError' && s(e), s(u)
      } finally {
        clearTimeout(c)
      }
    })()
  })
}
function BZ() {
  return {
    current: 0,
    take() {
      return this.current++
    },
    reset() {
      this.current = 0
    }
  }
}
const _4 = BZ()
function LZ(t, e = {}) {
  return {
    async request(n) {
      var g
      const {
          body: r,
          onRequest: i = e.onRequest,
          onResponse: s = e.onResponse,
          timeout: c = e.timeout ?? 1e4
        } = n,
        u = { ...(e.fetchOptions ?? {}), ...(n.fetchOptions ?? {}) },
        { headers: f, method: d, signal: p } = u
      try {
        const m = await x9(
          async ({ signal: A }) => {
            const E = {
                ...u,
                body: Array.isArray(r)
                  ? ji(r.map(M => ({ jsonrpc: '2.0', id: M.id ?? _4.take(), ...M })))
                  : ji({ jsonrpc: '2.0', id: r.id ?? _4.take(), ...r }),
                headers: { 'Content-Type': 'application/json', ...f },
                method: d || 'POST',
                signal: p || (c > 0 ? A : null)
              },
              x = new Request(t, E),
              O = (await (i == null ? void 0 : i(x, E))) ?? { ...E, url: t }
            return await fetch(O.url ?? t, O)
          },
          { errorInstance: new f4({ body: r, url: t }), timeout: c, signal: !0 }
        )
        s && (await s(m))
        let y
        if ((g = m.headers.get('Content-Type')) != null && g.startsWith('application/json'))
          y = await m.json()
        else {
          y = await m.text()
          try {
            y = JSON.parse(y || '{}')
          } catch (A) {
            if (m.ok) throw A
            y = { error: y }
          }
        }
        if (!m.ok)
          throw new hh({
            body: r,
            details: ji(y.error) || m.statusText,
            headers: m.headers,
            status: m.status,
            url: t
          })
        return y
      } catch (m) {
        throw m instanceof hh || m instanceof f4 ? m : new hh({ body: r, cause: m, url: t })
      }
    }
  }
}
function B1(t, e = {}) {
  const {
    batch: n,
    fetchOptions: r,
    key: i = 'http',
    methods: s,
    name: c = 'HTTP JSON-RPC',
    onFetchRequest: u,
    onFetchResponse: f,
    retryDelay: d,
    raw: p
  } = e
  return ({ chain: g, retryCount: m, timeout: y }) => {
    const { batchSize: A = 1e3, wait: E = 0 } = typeof n == 'object' ? n : {},
      x = e.retryCount ?? m,
      O = y ?? e.timeout ?? 1e4,
      I = t || (g == null ? void 0 : g.rpcUrls.default.http[0])
    if (!I) throw new UZ()
    const M = LZ(I, { fetchOptions: r, onRequest: u, onResponse: f, timeout: O })
    return R2(
      {
        key: i,
        methods: s,
        name: c,
        async request({ method: $, params: D }) {
          const R = { method: $, params: D },
            { schedule: z } = E9({
              id: I,
              wait: E,
              shouldSplitBatch(L) {
                return L.length > A
              },
              fn: L => M.request({ body: L }),
              sort: (L, v) => L.id - v.id
            }),
            G = async L => (n ? z(L) : [await M.request({ body: L })]),
            [{ error: j, result: V }] = await G(R)
          if (p) return { error: j, result: V }
          if (j) throw new _2({ body: R, error: j, url: I })
          return V
        },
        retryCount: x,
        retryDelay: d,
        timeout: O,
        type: 'http'
      },
      { fetchOptions: r, url: I }
    )
  }
}
function D2(t, e) {
  var r, i, s, c, u, f
  if (!(t instanceof fe)) return !1
  const n = t.walk(d => d instanceof Zw)
  return n instanceof Zw
    ? !!(
        ((r = n.data) == null ? void 0 : r.errorName) === 'ResolverNotFound' ||
        ((i = n.data) == null ? void 0 : i.errorName) === 'ResolverWildcardNotSupported' ||
        ((s = n.data) == null ? void 0 : s.errorName) === 'ResolverNotContract' ||
        ((c = n.data) == null ? void 0 : c.errorName) === 'ResolverError' ||
        ((u = n.data) == null ? void 0 : u.errorName) === 'HttpError' ||
        ((f = n.reason) != null &&
          f.includes('Wildcard on non-extended resolvers is not supported')) ||
        (e === 'reverse' && n.reason === VN[50])
      )
    : !1
}
function N9(t) {
  if (t.length !== 66 || t.indexOf('[') !== 0 || t.indexOf(']') !== 65) return null
  const e = `0x${t.slice(1, 65)}`
  return Ua(e) ? e : null
}
function Dg(t) {
  let e = new Uint8Array(32).fill(0)
  if (!t) return wr(e)
  const n = t.split('.')
  for (let r = n.length - 1; r >= 0; r -= 1) {
    const i = N9(n[r]),
      s = i ? Tp(i) : Vo(Kc(n[r]), 'bytes')
    e = Vo(au([e, s]), 'bytes')
  }
  return wr(e)
}
function $Z(t) {
  return `[${t.slice(2)}]`
}
function FZ(t) {
  const e = new Uint8Array(32).fill(0)
  return t ? N9(t) || Vo(Kc(t)) : wr(e)
}
function P2(t) {
  const e = t.replace(/^\.|\.$/gm, '')
  if (e.length === 0) return new Uint8Array(1)
  const n = new Uint8Array(Kc(e).byteLength + 2)
  let r = 0
  const i = e.split('.')
  for (let s = 0; s < i.length; s++) {
    let c = Kc(i[s])
    c.byteLength > 255 && (c = Kc($Z(FZ(i[s])))),
      (n[r] = c.length),
      n.set(c, r + 1),
      (r += c.length + 1)
  }
  return n.byteLength !== r + 1 ? n.slice(0, r + 1) : n
}
async function jZ(
  t,
  {
    blockNumber: e,
    blockTag: n,
    coinType: r,
    name: i,
    gatewayUrls: s,
    strict: c,
    universalResolverAddress: u
  }
) {
  let f = u
  if (!f) {
    if (!t.chain)
      throw new Error('client chain not configured. universalResolverAddress is required.')
    f = Ip({ blockNumber: e, chain: t.chain, contract: 'ensUniversalResolver' })
  }
  try {
    const d = Td({
        abi: E4,
        functionName: 'addr',
        ...(r != null ? { args: [Dg(i), BigInt(r)] } : { args: [Dg(i)] })
      }),
      p = {
        address: f,
        abi: b9,
        functionName: 'resolve',
        args: [Ba(P2(i)), d],
        blockNumber: e,
        blockTag: n
      },
      g = Yt(t, cu, 'readContract'),
      m = s ? await g({ ...p, args: [...p.args, s] }) : await g(p)
    if (m[0] === '0x') return null
    const y = Np({
      abi: E4,
      args: r != null ? [Dg(i), BigInt(r)] : void 0,
      functionName: 'addr',
      data: m[0]
    })
    return y === '0x' || Sd(y) === '0x00' ? null : y
  } catch (d) {
    if (c) throw d
    if (D2(d, 'resolve')) return null
    throw d
  }
}
class zZ extends fe {
  constructor({ data: e }) {
    super('Unable to extract image from metadata. The metadata may be malformed or invalid.', {
      metaMessages: [
        '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',
        '',
        `Provided data: ${JSON.stringify(e)}`
      ],
      name: 'EnsAvatarInvalidMetadataError'
    })
  }
}
class Qf extends fe {
  constructor({ reason: e }) {
    super(`ENS NFT avatar URI is invalid. ${e}`, { name: 'EnsAvatarInvalidNftUriError' })
  }
}
class M2 extends fe {
  constructor({ uri: e }) {
    super(
      `Unable to resolve ENS avatar URI "${e}". The URI may be malformed, invalid, or does not respond with a valid image.`,
      { name: 'EnsAvatarUriResolutionError' }
    )
  }
}
class qZ extends fe {
  constructor({ namespace: e }) {
    super(`ENS NFT avatar namespace "${e}" is not supported. Must be "erc721" or "erc1155".`, {
      name: 'EnsAvatarUnsupportedNamespaceError'
    })
  }
}
const HZ =
    /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/,
  GZ =
    /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/,
  VZ = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/,
  KZ = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/
async function WZ(t) {
  try {
    const e = await fetch(t, { method: 'HEAD' })
    if (e.status === 200) {
      const n = e.headers.get('content-type')
      return n == null ? void 0 : n.startsWith('image/')
    }
    return !1
  } catch (e) {
    return (typeof e == 'object' && typeof e.response < 'u') || !globalThis.hasOwnProperty('Image')
      ? !1
      : new Promise(n => {
          const r = new Image()
          ;(r.onload = () => {
            n(!0)
          }),
            (r.onerror = () => {
              n(!1)
            }),
            (r.src = t)
        })
  }
}
function C4(t, e) {
  return t ? (t.endsWith('/') ? t.slice(0, -1) : t) : e
}
function I9({ uri: t, gatewayUrls: e }) {
  const n = VZ.test(t)
  if (n) return { uri: t, isOnChain: !0, isEncoded: n }
  const r = C4(e == null ? void 0 : e.ipfs, 'https://ipfs.io'),
    i = C4(e == null ? void 0 : e.arweave, 'https://arweave.net'),
    s = t.match(HZ),
    {
      protocol: c,
      subpath: u,
      target: f,
      subtarget: d = ''
    } = (s == null ? void 0 : s.groups) || {},
    p = c === 'ipns:/' || u === 'ipns/',
    g = c === 'ipfs:/' || u === 'ipfs/' || GZ.test(t)
  if (t.startsWith('http') && !p && !g) {
    let y = t
    return (
      e != null &&
        e.arweave &&
        (y = t.replace(/https:\/\/arweave.net/g, e == null ? void 0 : e.arweave)),
      { uri: y, isOnChain: !1, isEncoded: !1 }
    )
  }
  if ((p || g) && f)
    return { uri: `${r}/${p ? 'ipns' : 'ipfs'}/${f}${d}`, isOnChain: !1, isEncoded: !1 }
  if (c === 'ar:/' && f) return { uri: `${i}/${f}${d || ''}`, isOnChain: !1, isEncoded: !1 }
  let m = t.replace(KZ, '')
  if (
    (m.startsWith('<svg') && (m = `data:image/svg+xml;base64,${btoa(m)}`),
    m.startsWith('data:') || m.startsWith('{'))
  )
    return { uri: m, isOnChain: !0, isEncoded: !1 }
  throw new M2({ uri: t })
}
function O9(t) {
  if (typeof t != 'object' || (!('image' in t) && !('image_url' in t) && !('image_data' in t)))
    throw new zZ({ data: t })
  return t.image || t.image_url || t.image_data
}
async function QZ({ gatewayUrls: t, uri: e }) {
  try {
    const n = await fetch(e).then(i => i.json())
    return await k2({ gatewayUrls: t, uri: O9(n) })
  } catch {
    throw new M2({ uri: e })
  }
}
async function k2({ gatewayUrls: t, uri: e }) {
  const { uri: n, isOnChain: r } = I9({ uri: e, gatewayUrls: t })
  if (r || (await WZ(n))) return n
  throw new M2({ uri: e })
}
function YZ(t) {
  let e = t
  e.startsWith('did:nft:') && (e = e.replace('did:nft:', '').replace(/_/g, '/'))
  const [n, r, i] = e.split('/'),
    [s, c] = n.split(':'),
    [u, f] = r.split(':')
  if (!s || s.toLowerCase() !== 'eip155') throw new Qf({ reason: 'Only EIP-155 supported' })
  if (!c) throw new Qf({ reason: 'Chain ID not found' })
  if (!f) throw new Qf({ reason: 'Contract address not found' })
  if (!i) throw new Qf({ reason: 'Token ID not found' })
  if (!u) throw new Qf({ reason: 'ERC namespace not found' })
  return { chainID: Number.parseInt(c), namespace: u.toLowerCase(), contractAddress: f, tokenID: i }
}
async function ZZ(t, { nft: e }) {
  if (e.namespace === 'erc721')
    return cu(t, {
      address: e.contractAddress,
      abi: [
        {
          name: 'tokenURI',
          type: 'function',
          stateMutability: 'view',
          inputs: [{ name: 'tokenId', type: 'uint256' }],
          outputs: [{ name: '', type: 'string' }]
        }
      ],
      functionName: 'tokenURI',
      args: [BigInt(e.tokenID)]
    })
  if (e.namespace === 'erc1155')
    return cu(t, {
      address: e.contractAddress,
      abi: [
        {
          name: 'uri',
          type: 'function',
          stateMutability: 'view',
          inputs: [{ name: '_id', type: 'uint256' }],
          outputs: [{ name: '', type: 'string' }]
        }
      ],
      functionName: 'uri',
      args: [BigInt(e.tokenID)]
    })
  throw new qZ({ namespace: e.namespace })
}
async function XZ(t, { gatewayUrls: e, record: n }) {
  return /eip155:/i.test(n) ? JZ(t, { gatewayUrls: e, record: n }) : k2({ uri: n, gatewayUrls: e })
}
async function JZ(t, { gatewayUrls: e, record: n }) {
  const r = YZ(n),
    i = await ZZ(t, { nft: r }),
    { uri: s, isOnChain: c, isEncoded: u } = I9({ uri: i, gatewayUrls: e })
  if (c && (s.includes('data:application/json;base64,') || s.startsWith('{'))) {
    const d = u ? atob(s.replace('data:application/json;base64,', '')) : s,
      p = JSON.parse(d)
    return k2({ uri: O9(p), gatewayUrls: e })
  }
  let f = r.tokenID
  return (
    r.namespace === 'erc1155' && (f = f.replace('0x', '').padStart(64, '0')),
    QZ({ gatewayUrls: e, uri: s.replace(/(?:0x)?{id}/, f) })
  )
}
async function eX(
  t,
  {
    blockNumber: e,
    blockTag: n,
    name: r,
    key: i,
    gatewayUrls: s,
    strict: c,
    universalResolverAddress: u
  }
) {
  let f = u
  if (!f) {
    if (!t.chain)
      throw new Error('client chain not configured. universalResolverAddress is required.')
    f = Ip({ blockNumber: e, chain: t.chain, contract: 'ensUniversalResolver' })
  }
  try {
    const d = {
        address: f,
        abi: b9,
        functionName: 'resolve',
        args: [Ba(P2(r)), Td({ abi: w4, functionName: 'text', args: [Dg(r), i] })],
        blockNumber: e,
        blockTag: n
      },
      p = Yt(t, cu, 'readContract'),
      g = s ? await p({ ...d, args: [...d.args, s] }) : await p(d)
    if (g[0] === '0x') return null
    const m = Np({ abi: w4, functionName: 'text', data: g[0] })
    return m === '' ? null : m
  } catch (d) {
    if (c) throw d
    if (D2(d, 'resolve')) return null
    throw d
  }
}
async function tX(
  t,
  {
    blockNumber: e,
    blockTag: n,
    assetGatewayUrls: r,
    name: i,
    gatewayUrls: s,
    strict: c,
    universalResolverAddress: u
  }
) {
  const f = await Yt(
    t,
    eX,
    'getEnsText'
  )({
    blockNumber: e,
    blockTag: n,
    key: 'avatar',
    name: i,
    universalResolverAddress: u,
    gatewayUrls: s,
    strict: c
  })
  if (!f) return null
  try {
    return await XZ(t, { record: f, gatewayUrls: r })
  } catch {
    return null
  }
}
async function nX(
  t,
  {
    address: e,
    blockNumber: n,
    blockTag: r,
    gatewayUrls: i,
    strict: s,
    universalResolverAddress: c
  }
) {
  let u = c
  if (!u) {
    if (!t.chain)
      throw new Error('client chain not configured. universalResolverAddress is required.')
    u = Ip({ blockNumber: n, chain: t.chain, contract: 'ensUniversalResolver' })
  }
  const f = `${e.toLowerCase().substring(2)}.addr.reverse`
  try {
    const d = {
        address: u,
        abi: iZ,
        functionName: 'reverse',
        args: [Ba(P2(f))],
        blockNumber: n,
        blockTag: r
      },
      p = Yt(t, cu, 'readContract'),
      [g, m] = i ? await p({ ...d, args: [...d.args, i] }) : await p(d)
    return e.toLowerCase() !== m.toLowerCase() ? null : g
  } catch (d) {
    if (s) throw d
    if (D2(d, 'reverse')) return null
    throw d
  }
}
async function rX(t) {
  const e = KQ(t, { method: 'eth_newPendingTransactionFilter' }),
    n = await t.request({ method: 'eth_newPendingTransactionFilter' })
  return { id: n, request: e(n), type: 'transaction' }
}
function U2(t) {
  return { formatters: void 0, fees: void 0, serializers: void 0, ...t }
}
const iX = { '0x0': 'reverted', '0x1': 'success' }
function sX(t) {
  const e = {
    ...t,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    contractAddress: t.contractAddress ? t.contractAddress : null,
    cumulativeGasUsed: t.cumulativeGasUsed ? BigInt(t.cumulativeGasUsed) : null,
    effectiveGasPrice: t.effectiveGasPrice ? BigInt(t.effectiveGasPrice) : null,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : null,
    logs: t.logs ? t.logs.map(n => g9(n)) : null,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? iu(t.transactionIndex) : null,
    status: t.status ? iX[t.status] : null,
    type: t.type ? i9[t.type] || t.type : null
  }
  return (
    t.blobGasPrice && (e.blobGasPrice = BigInt(t.blobGasPrice)),
    t.blobGasUsed && (e.blobGasUsed = BigInt(t.blobGasUsed)),
    e
  )
}
class aX extends fe {
  constructor({ value: e }) {
    super(`Number \`${e}\` is not a valid decimal number.`, { name: 'InvalidDecimalNumberError' })
  }
}
function R9(t, e) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(t)) throw new aX({ value: t })
  let [n, r = '0'] = t.split('.')
  const i = n.startsWith('-')
  if ((i && (n = n.slice(1)), (r = r.replace(/(0+)$/, '')), e === 0))
    Math.round(+`.${r}`) === 1 && (n = `${BigInt(n) + 1n}`), (r = '')
  else if (r.length > e) {
    const [s, c, u] = [r.slice(0, e - 1), r.slice(e - 1, e), r.slice(e)],
      f = Math.round(+`${c}.${u}`)
    f > 9 ? (r = `${BigInt(s) + BigInt(1)}0`.padStart(s.length + 1, '0')) : (r = `${s}${f}`),
      r.length > e && ((r = r.slice(1)), (n = `${BigInt(n) + 1n}`)),
      (r = r.slice(0, e))
  } else r = r.padEnd(e, '0')
  return BigInt(`${i ? '-' : ''}${n}${r}`)
}
function oX(t, e = 'wei') {
  return R9(t, QN[e])
}
async function D9(t, { blockHash: e, blockNumber: n, blockTag: r, hash: i, index: s }) {
  var p, g, m
  const c = r || 'latest',
    u = n !== void 0 ? it(n) : void 0
  let f = null
  if (
    (i
      ? (f = await t.request({ method: 'eth_getTransactionByHash', params: [i] }, { dedupe: !0 }))
      : e
        ? (f = await t.request(
            { method: 'eth_getTransactionByBlockHashAndIndex', params: [e, it(s)] },
            { dedupe: !0 }
          ))
        : (f = await t.request(
            { method: 'eth_getTransactionByBlockNumberAndIndex', params: [u || c, it(s)] },
            { dedupe: !!u }
          )),
    !f)
  )
    throw new YN({ blockHash: e, blockNumber: n, blockTag: c, hash: i, index: s })
  return (
    ((m = (g = (p = t.chain) == null ? void 0 : p.formatters) == null ? void 0 : g.transaction) ==
    null
      ? void 0
      : m.format) || s9
  )(f)
}
async function S4(t, { hash: e }) {
  var i, s, c
  const n = await t.request({ method: 'eth_getTransactionReceipt', params: [e] }, { dedupe: !0 })
  if (!n) throw new ZN({ hash: e })
  return (
    ((c =
      (s = (i = t.chain) == null ? void 0 : i.formatters) == null
        ? void 0
        : s.transactionReceipt) == null
      ? void 0
      : c.format) || sX
  )(n)
}
async function cX(t, e) {
  var x
  const {
      allowFailure: n = !0,
      batchSize: r,
      blockNumber: i,
      blockTag: s,
      multicallAddress: c,
      stateOverride: u
    } = e,
    f = e.contracts,
    d =
      r ??
      ((typeof ((x = t.batch) == null ? void 0 : x.multicall) == 'object' &&
        t.batch.multicall.batchSize) ||
        1024)
  let p = c
  if (!p) {
    if (!t.chain) throw new Error('client chain not configured. multicallAddress is required.')
    p = Ip({ blockNumber: i, chain: t.chain, contract: 'multicall3' })
  }
  const g = [[]]
  let m = 0,
    y = 0
  for (let O = 0; O < f.length; O++) {
    const { abi: I, address: M, args: $, functionName: D } = f[O]
    try {
      const R = Td({ abi: I, args: $, functionName: D })
      ;(y += (R.length - 2) / 2),
        d > 0 && y > d && g[m].length > 0 && (m++, (y = (R.length - 2) / 2), (g[m] = [])),
        (g[m] = [...g[m], { allowFailure: !0, callData: R, target: M }])
    } catch (R) {
      const z = tm(R, {
        abi: I,
        address: M,
        args: $,
        docsPath: '/docs/contract/multicall',
        functionName: D
      })
      if (!n) throw z
      g[m] = [...g[m], { allowFailure: !0, callData: '0x', target: M }]
    }
  }
  const A = await Promise.allSettled(
      g.map(O =>
        Yt(
          t,
          cu,
          'readContract'
        )({
          abi: aE,
          address: p,
          args: [O],
          blockNumber: i,
          blockTag: s,
          functionName: 'aggregate3',
          stateOverride: u
        })
      )
    ),
    E = []
  for (let O = 0; O < A.length; O++) {
    const I = A[O]
    if (I.status === 'rejected') {
      if (!n) throw I.reason
      for (let $ = 0; $ < g[O].length; $++)
        E.push({ status: 'failure', error: I.reason, result: void 0 })
      continue
    }
    const M = I.value
    for (let $ = 0; $ < M.length; $++) {
      const { returnData: D, success: R } = M[$],
        { callData: z } = g[O][$],
        { abi: G, address: j, functionName: V, args: L } = f[E.length]
      try {
        if (z === '0x') throw new qm()
        if (!R) throw new A2({ data: D })
        const v = Np({ abi: G, args: L, data: D, functionName: V })
        E.push(n ? { result: v, status: 'success' } : v)
      } catch (v) {
        const C = tm(v, {
          abi: G,
          address: j,
          args: L,
          docsPath: '/docs/contract/multicall',
          functionName: V
        })
        if (!n) throw C
        E.push({ error: C, result: void 0, status: 'failure' })
      }
    }
  }
  if (E.length !== f.length) throw new fe('multicall results mismatch')
  return E
}
function uX(
  t,
  {
    emitOnBegin: e = !1,
    emitMissed: n = !1,
    onBlockNumber: r,
    onError: i,
    poll: s,
    pollingInterval: c = t.pollingInterval
  }
) {
  const u =
    typeof s < 'u'
      ? s
      : !(
          t.transport.type === 'webSocket' ||
          (t.transport.type === 'fallback' && t.transport.transports[0].config.type === 'webSocket')
        )
  let f
  return u
    ? (() => {
        const g = ji(['watchBlockNumber', t.uid, e, n, c])
        return im(g, { onBlockNumber: r, onError: i }, m =>
          _9(
            async () => {
              var y
              try {
                const A = await Yt(t, AZ, 'getBlockNumber')({ cacheTime: 0 })
                if (f) {
                  if (A === f) return
                  if (A - f > 1 && n)
                    for (let E = f + 1n; E < A; E++) m.onBlockNumber(E, f), (f = E)
                }
                ;(!f || A > f) && (m.onBlockNumber(A, f), (f = A))
              } catch (A) {
                ;(y = m.onError) == null || y.call(m, A)
              }
            },
            { emitOnBegin: e, interval: c }
          )
        )
      })()
    : (() => {
        const g = ji(['watchBlockNumber', t.uid, e, n])
        return im(g, { onBlockNumber: r, onError: i }, m => {
          let y = !0,
            A = () => (y = !1)
          return (
            (async () => {
              try {
                const E = (() => {
                    if (t.transport.type === 'fallback') {
                      const O = t.transport.transports.find(I => I.config.type === 'webSocket')
                      return O ? O.value : t.transport
                    }
                    return t.transport
                  })(),
                  { unsubscribe: x } = await E.subscribe({
                    params: ['newHeads'],
                    onData(O) {
                      var M
                      if (!y) return
                      const I = sd((M = O.result) == null ? void 0 : M.number)
                      m.onBlockNumber(I, f), (f = I)
                    },
                    onError(O) {
                      var I
                      ;(I = m.onError) == null || I.call(m, O)
                    }
                  })
                ;(A = x), y || A()
              } catch (E) {
                i == null || i(E)
              }
            })(),
            () => A()
          )
        })
      })()
}
async function lX(
  t,
  {
    confirmations: e = 1,
    hash: n,
    onReplaced: r,
    pollingInterval: i = t.pollingInterval,
    retryCount: s = 6,
    retryDelay: c = ({ count: f }) => ~~(1 << f) * 200,
    timeout: u = 18e4
  }
) {
  const f = ji(['waitForTransactionReceipt', t.uid, n])
  let d,
    p,
    g,
    m = !1
  const { promise: y, resolve: A, reject: E } = w9(),
    x = u ? setTimeout(() => E(new yY({ hash: n })), u) : void 0,
    O = im(f, { onReplaced: r, resolve: A, reject: E }, I => {
      const M = Yt(
        t,
        uX,
        'watchBlockNumber'
      )({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: i,
        async onBlockNumber($) {
          const D = z => {
            clearTimeout(x), M(), z(), O()
          }
          let R = $
          if (!m)
            try {
              if (g) {
                if (e > 1 && (!g.blockNumber || R - g.blockNumber + 1n < e)) return
                D(() => I.resolve(g))
                return
              }
              if (
                (d ||
                  ((m = !0),
                  await am(
                    async () => {
                      ;(d = await Yt(t, D9, 'getTransaction')({ hash: n })),
                        d.blockNumber && (R = d.blockNumber)
                    },
                    { delay: c, retryCount: s }
                  ),
                  (m = !1)),
                (g = await Yt(t, S4, 'getTransactionReceipt')({ hash: n })),
                e > 1 && (!g.blockNumber || R - g.blockNumber + 1n < e))
              )
                return
              D(() => I.resolve(g))
            } catch (z) {
              if (z instanceof YN || z instanceof ZN) {
                if (!d) {
                  m = !1
                  return
                }
                try {
                  ;(p = d), (m = !0)
                  const G = await am(
                    () => Yt(t, Bh, 'getBlock')({ blockNumber: R, includeTransactions: !0 }),
                    { delay: c, retryCount: s, shouldRetry: ({ error: L }) => L instanceof r9 }
                  )
                  m = !1
                  const j = G.transactions.find(
                    ({ from: L, nonce: v }) => L === p.from && v === p.nonce
                  )
                  if (
                    !j ||
                    ((g = await Yt(t, S4, 'getTransactionReceipt')({ hash: j.hash })),
                    e > 1 && (!g.blockNumber || R - g.blockNumber + 1n < e))
                  )
                    return
                  let V = 'replaced'
                  j.to === p.to && j.value === p.value && j.input === p.input
                    ? (V = 'repriced')
                    : j.from === j.to && j.value === 0n && (V = 'cancelled'),
                    D(() => {
                      var L
                      ;(L = I.onReplaced) == null ||
                        L.call(I, {
                          reason: V,
                          replacedTransaction: p,
                          transaction: j,
                          transactionReceipt: g
                        }),
                        I.resolve(g)
                    })
                } catch (G) {
                  D(() => I.reject(G))
                }
              } else D(() => I.reject(z))
            }
        }
      })
    })
  return y
}
function dX(
  t,
  { batch: e = !0, onError: n, onTransactions: r, poll: i, pollingInterval: s = t.pollingInterval }
) {
  return (typeof i < 'u' ? i : t.transport.type !== 'webSocket')
    ? (() => {
        const d = ji(['watchPendingTransactions', t.uid, e, s])
        return im(d, { onTransactions: r, onError: n }, p => {
          let g
          const m = _9(
            async () => {
              var y
              try {
                if (!g)
                  try {
                    g = await Yt(t, rX, 'createPendingTransactionFilter')({})
                    return
                  } catch (E) {
                    throw (m(), E)
                  }
                const A = await Yt(t, _Z, 'getFilterChanges')({ filter: g })
                if (A.length === 0) return
                if (e) p.onTransactions(A)
                else for (const E of A) p.onTransactions([E])
              } catch (A) {
                ;(y = p.onError) == null || y.call(p, A)
              }
            },
            { emitOnBegin: !0, interval: s }
          )
          return async () => {
            g && (await Yt(t, CZ, 'uninstallFilter')({ filter: g })), m()
          }
        })
      })()
    : (() => {
        let d = !0,
          p = () => (d = !1)
        return (
          (async () => {
            try {
              const { unsubscribe: g } = await t.transport.subscribe({
                params: ['newPendingTransactions'],
                onData(m) {
                  if (!d) return
                  const y = m.result
                  r([y])
                },
                onError(m) {
                  n == null || n(m)
                }
              })
              ;(p = g), d || p()
            } catch (g) {
              n == null || n(g)
            }
          })(),
          () => p()
        )
      })()
}
async function fX(t, { account: e = t.account, message: n }) {
  if (!e) throw new O2({ docsPath: '/docs/actions/wallet/signMessage' })
  const r = Qs(e)
  if (r.signMessage) return r.signMessage({ message: n })
  const i = typeof n == 'string' ? Hm(n) : n.raw instanceof Uint8Array ? Ba(n.raw) : n.raw
  return t.request({ method: 'personal_sign', params: [i, r.address] }, { retryCount: 0 })
}
const L1 = {
    createBalance(t, e) {
      const n = {
        name: t.metadata.name || '',
        symbol: t.metadata.symbol || '',
        decimals: t.metadata.decimals || 0,
        value: t.metadata.value || 0,
        price: t.metadata.price || 0,
        iconUrl: t.metadata.iconUrl || ''
      }
      return {
        name: n.name,
        symbol: n.symbol,
        chainId: e,
        address: t.address === 'native' ? void 0 : this.convertAddressToCAIP10Address(t.address, e),
        value: n.value,
        price: n.price,
        quantity: {
          decimals: n.decimals.toString(),
          numeric: this.convertHexToBalance({ hex: t.balance, decimals: n.decimals })
        },
        iconUrl: n.iconUrl
      }
    },
    convertHexToBalance({ hex: t, decimals: e }) {
      return xd(BigInt(t), e)
    },
    convertAddressToCAIP10Address(t, e) {
      return `${e}:${t}`
    },
    createCAIP2ChainId(t, e) {
      return `${e}:${parseInt(t, 16)}`
    },
    getChainIdHexFromCAIP2ChainId(t) {
      const e = t.split(':')
      if (e.length < 2 || !e[1]) return '0x0'
      const n = e[1],
        r = parseInt(n, 10)
      return isNaN(r) ? '0x0' : `0x${r.toString(16)}`
    },
    isWalletGetAssetsResponse(t) {
      return typeof t != 'object' || t === null
        ? !1
        : Object.values(t).every(e => Array.isArray(e) && e.every(n => this.isValidAsset(n)))
    },
    isValidAsset(t) {
      return (
        typeof t == 'object' &&
        t !== null &&
        typeof t.address == 'string' &&
        typeof t.balance == 'string' &&
        (t.type === 'ERC20' || t.type === 'NATIVE') &&
        typeof t.metadata == 'object' &&
        t.metadata !== null &&
        typeof t.metadata.name == 'string' &&
        typeof t.metadata.symbol == 'string' &&
        typeof t.metadata.decimals == 'number' &&
        typeof t.metadata.price == 'number' &&
        typeof t.metadata.iconUrl == 'string'
      )
    }
  },
  T4 = {
    async getMyTokensWithBalance(t) {
      const e = Oe.state.address,
        n = Q.state.activeCaipNetwork
      if (!e || !n) return []
      if (n.chainNamespace === 'eip155') {
        const i = await this.getEIP155Balances(e, n)
        if (i) return this.filterLowQualityTokens(i)
      }
      const r = await Me.getBalance(e, n.caipNetworkId, t)
      return this.filterLowQualityTokens(r.balances)
    },
    async getEIP155Balances(t, e) {
      var n, r
      try {
        const i = L1.getChainIdHexFromCAIP2ChainId(e.caipNetworkId),
          s = await ot.getCapabilities(t)
        if (
          !(
            (r = (n = s == null ? void 0 : s[i]) == null ? void 0 : n.assetDiscovery) != null &&
            r.supported
          )
        )
          return null
        const c = await ot.walletGetAssets({ account: t, chainFilter: [i] })
        return L1.isWalletGetAssetsResponse(c)
          ? (c[i] || []).map(f => L1.createBalance(f, e.caipNetworkId))
          : null
      } catch {
        return null
      }
    },
    filterLowQualityTokens(t) {
      return t.filter(e => e.quantity.decimals !== '0')
    },
    mapBalancesToSwapTokens(t) {
      return (
        (t == null
          ? void 0
          : t.map(e => ({
              ...e,
              address: e != null && e.address ? e.address : Q.getActiveNetworkTokenAddress(),
              decimals: parseInt(e.quantity.decimals, 10),
              logoUri: e.iconUrl,
              eip2612: !1
            }))) || []
      )
    }
  },
  vt = gn({ tokenBalances: [], loading: !1 }),
  x4 = {
    state: vt,
    subscribe(t) {
      return Rr(vt, () => t(vt))
    },
    subscribeKey(t, e) {
      return zr(vt, t, e)
    },
    setToken(t) {
      t && (vt.token = Zc(t))
    },
    setTokenAmount(t) {
      vt.sendTokenAmount = t
    },
    setReceiverAddress(t) {
      vt.receiverAddress = t
    },
    setReceiverProfileImageUrl(t) {
      vt.receiverProfileImageUrl = t
    },
    setReceiverProfileName(t) {
      vt.receiverProfileName = t
    },
    setGasPrice(t) {
      vt.gasPrice = t
    },
    setGasPriceInUsd(t) {
      vt.gasPriceInUSD = t
    },
    setNetworkBalanceInUsd(t) {
      vt.networkBalanceInUSD = t
    },
    setLoading(t) {
      vt.loading = t
    },
    sendToken() {
      var t
      switch ((t = Q.state.activeCaipNetwork) == null ? void 0 : t.chainNamespace) {
        case 'eip155':
          this.sendEvmToken()
          return
        case 'solana':
          this.sendSolanaToken()
          return
        default:
          throw new Error('Unsupported chain')
      }
    },
    sendEvmToken() {
      var t, e, n, r, i
      ;(t = this.state.token) != null &&
      t.address &&
      this.state.sendTokenAmount &&
      this.state.receiverAddress
        ? (Ft.sendEvent({
            type: 'track',
            event: 'SEND_INITIATED',
            properties: {
              isSmartAccount: Oe.state.preferredAccountType === yn.ACCOUNT_TYPES.SMART_ACCOUNT,
              token: this.state.token.address,
              amount: this.state.sendTokenAmount,
              network: ((e = Q.state.activeCaipNetwork) == null ? void 0 : e.caipNetworkId) || ''
            }
          }),
          this.sendERC20Token({
            receiverAddress: this.state.receiverAddress,
            tokenAddress: this.state.token.address,
            sendTokenAmount: this.state.sendTokenAmount,
            decimals: this.state.token.quantity.decimals
          }))
        : this.state.receiverAddress &&
          this.state.sendTokenAmount &&
          this.state.gasPrice &&
          (n = this.state.token) != null &&
          n.quantity.decimals &&
          (Ft.sendEvent({
            type: 'track',
            event: 'SEND_INITIATED',
            properties: {
              isSmartAccount: Oe.state.preferredAccountType === yn.ACCOUNT_TYPES.SMART_ACCOUNT,
              token: (r = this.state.token) == null ? void 0 : r.symbol,
              amount: this.state.sendTokenAmount,
              network: ((i = Q.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId) || ''
            }
          }),
          this.sendNativeToken({
            receiverAddress: this.state.receiverAddress,
            sendTokenAmount: this.state.sendTokenAmount,
            gasPrice: this.state.gasPrice,
            decimals: this.state.token.quantity.decimals
          }))
    },
    async fetchTokenBalance(t) {
      var s, c
      vt.loading = !0
      const e = (s = Q.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId,
        n = (c = Q.state.activeCaipNetwork) == null ? void 0 : c.chainNamespace,
        r = Q.state.activeCaipAddress,
        i = r ? $e.getPlainAddress(r) : void 0
      if (vt.lastRetry && !$e.isAllowedRetry(vt.lastRetry, 30 * Fn.ONE_SEC_MS))
        return (vt.loading = !1), []
      try {
        if (i && e && n) {
          const u = await T4.getMyTokensWithBalance()
          return (vt.tokenBalances = u), (vt.lastRetry = void 0), u
        }
      } catch (u) {
        ;(vt.lastRetry = Date.now()), t == null || t(u), $t.showError('Token Balance Unavailable')
      } finally {
        vt.loading = !1
      }
      return []
    },
    fetchNetworkBalance() {
      if (vt.tokenBalances.length === 0) return
      const t = T4.mapBalancesToSwapTokens(vt.tokenBalances)
      if (!t) return
      const e = t.find(n => n.address === Q.getActiveNetworkTokenAddress())
      e && (vt.networkBalanceInUSD = e ? Lt.multiply(e.quantity.numeric, e.price).toString() : '0')
    },
    isInsufficientNetworkTokenForGas(t, e) {
      const n = e || '0'
      return Lt.bigNumber(t).eq(0) ? !0 : Lt.bigNumber(Lt.bigNumber(n)).gt(t)
    },
    hasInsufficientGasFunds() {
      let t = !0
      return (
        Oe.state.preferredAccountType === yn.ACCOUNT_TYPES.SMART_ACCOUNT
          ? (t = !1)
          : vt.networkBalanceInUSD &&
            (t = this.isInsufficientNetworkTokenForGas(vt.networkBalanceInUSD, vt.gasPriceInUSD)),
        t
      )
    },
    async sendNativeToken(t) {
      var s, c, u, f
      ct.pushTransactionStack({ view: 'Account', goBack: !1 })
      const e = t.receiverAddress,
        n = Oe.state.address,
        r = ot.parseUnits(t.sendTokenAmount.toString(), Number(t.decimals)),
        i = '0x'
      try {
        await ot.sendTransaction({
          chainNamespace: 'eip155',
          to: e,
          address: n,
          data: i,
          value: r ?? BigInt(0),
          gasPrice: t.gasPrice
        }),
          $t.showSuccess('Transaction started'),
          Ft.sendEvent({
            type: 'track',
            event: 'SEND_SUCCESS',
            properties: {
              isSmartAccount: Oe.state.preferredAccountType === yn.ACCOUNT_TYPES.SMART_ACCOUNT,
              token: ((s = this.state.token) == null ? void 0 : s.symbol) || '',
              amount: t.sendTokenAmount,
              network: ((c = Q.state.activeCaipNetwork) == null ? void 0 : c.caipNetworkId) || ''
            }
          }),
          this.resetSend()
      } catch (d) {
        console.error('SendController:sendERC20Token - failed to send native token', d)
        const p = d instanceof Error ? d.message : 'Unknown error'
        Ft.sendEvent({
          type: 'track',
          event: 'SEND_ERROR',
          properties: {
            message: p,
            isSmartAccount: Oe.state.preferredAccountType === yn.ACCOUNT_TYPES.SMART_ACCOUNT,
            token: ((u = this.state.token) == null ? void 0 : u.symbol) || '',
            amount: t.sendTokenAmount,
            network: ((f = Q.state.activeCaipNetwork) == null ? void 0 : f.caipNetworkId) || ''
          }
        }),
          $t.showError('Something went wrong')
      }
    },
    async sendERC20Token(t) {
      var n, r
      ct.pushTransactionStack({ view: 'Account', goBack: !1 })
      const e = ot.parseUnits(t.sendTokenAmount.toString(), Number(t.decimals))
      try {
        if (Oe.state.address && t.sendTokenAmount && t.receiverAddress && t.tokenAddress) {
          const i = $e.getPlainAddress(t.tokenAddress)
          await ot.writeContract({
            fromAddress: Oe.state.address,
            tokenAddress: i,
            args: [t.receiverAddress, e ?? BigInt(0)],
            method: 'transfer',
            abi: I7.getERC20Abi(i),
            chainNamespace: 'eip155'
          }),
            $t.showSuccess('Transaction started'),
            this.resetSend()
        }
      } catch (i) {
        console.error('SendController:sendERC20Token - failed to send erc20 token', i)
        const s = i instanceof Error ? i.message : 'Unknown error'
        Ft.sendEvent({
          type: 'track',
          event: 'SEND_ERROR',
          properties: {
            message: s,
            isSmartAccount: Oe.state.preferredAccountType === yn.ACCOUNT_TYPES.SMART_ACCOUNT,
            token: ((n = this.state.token) == null ? void 0 : n.symbol) || '',
            amount: t.sendTokenAmount,
            network: ((r = Q.state.activeCaipNetwork) == null ? void 0 : r.caipNetworkId) || ''
          }
        }),
          $t.showError('Something went wrong')
      }
    },
    sendSolanaToken() {
      if (!this.state.sendTokenAmount || !this.state.receiverAddress) {
        $t.showError('Please enter a valid amount and receiver address')
        return
      }
      ct.pushTransactionStack({ view: 'Account', goBack: !1 }),
        ot
          .sendTransaction({
            chainNamespace: 'solana',
            to: this.state.receiverAddress,
            value: this.state.sendTokenAmount
          })
          .then(() => {
            this.resetSend(), Oe.fetchTokenBalance()
          })
          .catch(t => {
            $t.showError('Failed to send transaction. Please try again.'),
              console.error('SendController:sendToken - failed to send solana transaction', t)
          })
    },
    resetSend() {
      ;(vt.token = void 0),
        (vt.sendTokenAmount = void 0),
        (vt.receiverAddress = void 0),
        (vt.receiverProfileImageUrl = void 0),
        (vt.receiverProfileName = void 0),
        (vt.loading = !1),
        (vt.tokenBalances = [])
    }
  },
  $1 = {
    currentTab: 0,
    tokenBalance: [],
    smartAccountDeployed: !1,
    addressLabels: new Map(),
    allAccounts: [],
    user: void 0
  },
  mg = { caipNetwork: void 0, supportsAllNetworks: !0, smartAccountEnabledNetworks: [] },
  ve = gn({
    chains: m7(),
    activeCaipAddress: void 0,
    activeChain: void 0,
    activeCaipNetwork: void 0,
    noAdapters: !1,
    universalAdapter: { networkControllerClient: void 0, connectionControllerClient: void 0 },
    isSwitchingNamespace: !1
  }),
  Q = {
    state: ve,
    subscribe(t) {
      return Rr(ve, () => {
        t(ve)
      })
    },
    subscribeKey(t, e) {
      return zr(ve, t, e)
    },
    subscribeChainProp(t, e, n) {
      let r
      return Rr(ve.chains, () => {
        var s
        const i = n || ve.activeChain
        if (i) {
          const c = (s = ve.chains.get(i)) == null ? void 0 : s[t]
          r !== c && ((r = c), e(c))
        }
      })
    },
    initialize(t, e, n) {
      const { chainId: r, namespace: i } = Ne.getActiveNetworkProps(),
        s =
          e == null ? void 0 : e.find(d => d.id.toString() === (r == null ? void 0 : r.toString())),
        u = t.find(d => (d == null ? void 0 : d.namespace) === i) || (t == null ? void 0 : t[0]),
        f = new Set([...((e == null ? void 0 : e.map(d => d.chainNamespace)) ?? [])])
      ;((t == null ? void 0 : t.length) === 0 || !u) && (ve.noAdapters = !0),
        ve.noAdapters ||
          ((ve.activeChain = u == null ? void 0 : u.namespace),
          (ve.activeCaipNetwork = s),
          this.setChainNetworkData(u == null ? void 0 : u.namespace, { caipNetwork: s }),
          ve.activeChain && Ra.set({ activeChain: u == null ? void 0 : u.namespace })),
        f.forEach(d => {
          const p = e == null ? void 0 : e.filter(g => g.chainNamespace === d)
          Q.state.chains.set(d, {
            namespace: d,
            networkState: gn({ ...mg, caipNetwork: p == null ? void 0 : p[0] }),
            accountState: gn($1),
            caipNetworks: p ?? [],
            ...n
          }),
            this.setRequestedCaipNetworks(p ?? [], d)
        })
    },
    removeAdapter(t) {
      var e, n
      if (ve.activeChain === t) {
        const r = Array.from(ve.chains.entries()).find(([i]) => i !== t)
        if (r) {
          const i = (n = (e = r[1]) == null ? void 0 : e.caipNetworks) == null ? void 0 : n[0]
          i && this.setActiveCaipNetwork(i)
        }
      }
      ve.chains.delete(t)
    },
    addAdapter(t, { networkControllerClient: e, connectionControllerClient: n }, r) {
      ve.chains.set(t.namespace, {
        namespace: t.namespace,
        networkState: { ...mg, caipNetwork: r[0] },
        accountState: $1,
        caipNetworks: r,
        connectionControllerClient: n,
        networkControllerClient: e
      }),
        this.setRequestedCaipNetworks(
          (r == null ? void 0 : r.filter(i => i.chainNamespace === t.namespace)) ?? [],
          t.namespace
        )
    },
    addNetwork(t) {
      var n
      const e = ve.chains.get(t.chainNamespace)
      if (e) {
        const r = [...(e.caipNetworks || [])]
        ;((n = e.caipNetworks) != null && n.find(i => i.id === t.id)) || r.push(t),
          ve.chains.set(t.chainNamespace, { ...e, caipNetworks: r }),
          this.setRequestedCaipNetworks(r, t.chainNamespace)
      }
    },
    removeNetwork(t, e) {
      var r, i, s
      const n = ve.chains.get(t)
      if (n) {
        const c = ((r = ve.activeCaipNetwork) == null ? void 0 : r.id) === e,
          u = [...(((i = n.caipNetworks) == null ? void 0 : i.filter(f => f.id !== e)) || [])]
        c &&
          (s = n == null ? void 0 : n.caipNetworks) != null &&
          s[0] &&
          this.setActiveCaipNetwork(n.caipNetworks[0]),
          ve.chains.set(t, { ...n, caipNetworks: u }),
          this.setRequestedCaipNetworks(u || [], t)
      }
    },
    setAdapterNetworkState(t, e) {
      const n = ve.chains.get(t)
      n && ((n.networkState = { ...(n.networkState || mg), ...e }), ve.chains.set(t, n))
    },
    setChainAccountData(t, e, n = !0) {
      if (!t) throw new Error('Chain is required to update chain account data')
      const r = ve.chains.get(t)
      if (r) {
        const i = { ...(r.accountState || $1), ...e }
        ve.chains.set(t, { ...r, accountState: i }),
          (ve.chains.size === 1 || ve.activeChain === t) &&
            (e.caipAddress && (ve.activeCaipAddress = e.caipAddress), Oe.replaceState(i))
      }
    },
    setChainNetworkData(t, e) {
      if (!t) return
      const n = ve.chains.get(t)
      if (n) {
        const r = { ...(n.networkState || mg), ...e }
        ve.chains.set(t, { ...n, networkState: r })
      }
    },
    setAccountProp(t, e, n, r = !0) {
      this.setChainAccountData(n, { [t]: e }, r),
        t === 'status' && e === 'disconnected' && n && Ge.removeConnectorId(n)
    },
    setActiveNamespace(t) {
      var r, i
      ve.activeChain = t
      const e = t ? ve.chains.get(t) : void 0,
        n = (r = e == null ? void 0 : e.networkState) == null ? void 0 : r.caipNetwork
      n != null &&
        n.id &&
        t &&
        ((ve.activeCaipAddress =
          (i = e == null ? void 0 : e.accountState) == null ? void 0 : i.caipAddress),
        (ve.activeCaipNetwork = n),
        this.setChainNetworkData(t, { caipNetwork: n }),
        Ne.setActiveCaipNetworkId(n == null ? void 0 : n.caipNetworkId),
        Ra.set({ activeChain: t, selectedNetworkId: n == null ? void 0 : n.caipNetworkId }))
    },
    setActiveCaipNetwork(t) {
      var r, i, s
      if (!t) return
      ve.activeChain !== t.chainNamespace &&
        (this.setIsSwitchingNamespace(!0), Ge.setFilterByNamespace(t.chainNamespace))
      const e = ve.chains.get(t.chainNamespace)
      ;(ve.activeChain = t.chainNamespace),
        (ve.activeCaipNetwork = t),
        this.setChainNetworkData(t.chainNamespace, { caipNetwork: t }),
        (r = e == null ? void 0 : e.accountState) != null && r.address
          ? (ve.activeCaipAddress = `${t.chainNamespace}:${t.id}:${(i = e == null ? void 0 : e.accountState) == null ? void 0 : i.address}`)
          : (ve.activeCaipAddress = void 0),
        this.setAccountProp('caipAddress', ve.activeCaipAddress, t.chainNamespace),
        e && Oe.replaceState(e.accountState),
        x4.resetSend(),
        Ra.set({
          activeChain: ve.activeChain,
          selectedNetworkId: (s = ve.activeCaipNetwork) == null ? void 0 : s.caipNetworkId
        }),
        Ne.setActiveCaipNetworkId(t.caipNetworkId),
        !this.checkIfSupportedNetwork(t.chainNamespace) &&
          !be.state.allowUnsupportedChain &&
          !ot.state.wcBasic &&
          this.showUnsupportedChainUI()
    },
    addCaipNetwork(t) {
      var n
      if (!t) return
      const e = ve.chains.get(t.chainNamespace)
      e && ((n = e == null ? void 0 : e.caipNetworks) == null || n.push(t))
    },
    async switchActiveNamespace(t) {
      var i
      if (!t) return
      const e = t !== Q.state.activeChain,
        n = (i = Q.getNetworkData(t)) == null ? void 0 : i.caipNetwork,
        r = Q.getCaipNetworkByNamespace(t, n == null ? void 0 : n.id)
      e && r && (await Q.switchActiveNetwork(r))
    },
    async switchActiveNetwork(t) {
      var i
      const e = Q.state.chains.get(Q.state.activeChain)
      !(
        (i = e == null ? void 0 : e.caipNetworks) != null &&
        i.some(s => {
          var c
          return s.id === ((c = ve.activeCaipNetwork) == null ? void 0 : c.id)
        })
      ) && ct.goBack()
      const r = this.getNetworkControllerClient(t.chainNamespace)
      r &&
        (await r.switchCaipNetwork(t),
        Ft.sendEvent({
          type: 'track',
          event: 'SWITCH_NETWORK',
          properties: { network: t.caipNetworkId }
        }))
    },
    getNetworkControllerClient(t) {
      const e = t || ve.activeChain,
        n = ve.chains.get(e)
      if (!n) throw new Error('Chain adapter not found')
      if (!n.networkControllerClient) throw new Error('NetworkController client not set')
      return n.networkControllerClient
    },
    getConnectionControllerClient(t) {
      const e = t || ve.activeChain
      if (!e) throw new Error('Chain is required to get connection controller client')
      const n = ve.chains.get(e)
      if (!(n != null && n.connectionControllerClient))
        throw new Error('ConnectionController client not set')
      return n.connectionControllerClient
    },
    getAccountProp(t, e) {
      var i
      let n = ve.activeChain
      if ((e && (n = e), !n)) return
      const r = (i = ve.chains.get(n)) == null ? void 0 : i.accountState
      if (r) return r[t]
    },
    getNetworkProp(t, e) {
      var r
      const n = (r = ve.chains.get(e)) == null ? void 0 : r.networkState
      if (n) return n[t]
    },
    getRequestedCaipNetworks(t) {
      const e = ve.chains.get(t),
        { approvedCaipNetworkIds: n = [], requestedCaipNetworks: r = [] } =
          (e == null ? void 0 : e.networkState) || {}
      return $e.sortRequestedNetworks(n, r)
    },
    getAllRequestedCaipNetworks() {
      const t = []
      return (
        ve.chains.forEach(e => {
          const n = this.getRequestedCaipNetworks(e.namespace)
          t.push(...n)
        }),
        t
      )
    },
    setRequestedCaipNetworks(t, e) {
      this.setAdapterNetworkState(e, { requestedCaipNetworks: t })
    },
    getAllApprovedCaipNetworkIds() {
      const t = []
      return (
        ve.chains.forEach(e => {
          const n = this.getApprovedCaipNetworkIds(e.namespace)
          t.push(...n)
        }),
        t
      )
    },
    getActiveCaipNetwork() {
      return ve.activeCaipNetwork
    },
    getActiveCaipAddress() {
      return ve.activeCaipAddress
    },
    getApprovedCaipNetworkIds(t) {
      var r
      const e = ve.chains.get(t)
      return (
        ((r = e == null ? void 0 : e.networkState) == null ? void 0 : r.approvedCaipNetworkIds) ||
        []
      )
    },
    async setApprovedCaipNetworksData(t) {
      const e = this.getNetworkControllerClient(),
        n = await (e == null ? void 0 : e.getApprovedCaipNetworksData())
      this.setAdapterNetworkState(t, {
        approvedCaipNetworkIds: n == null ? void 0 : n.approvedCaipNetworkIds,
        supportsAllNetworks: n == null ? void 0 : n.supportsAllNetworks
      })
    },
    checkIfSupportedNetwork(t, e) {
      const n = e || ve.activeCaipNetwork,
        r = this.getRequestedCaipNetworks(t)
      return r.length
        ? r == null
          ? void 0
          : r.some(i => i.id === (n == null ? void 0 : n.id))
        : !0
    },
    checkIfSupportedChainId(t) {
      if (!ve.activeChain) return !0
      const e = this.getRequestedCaipNetworks(ve.activeChain)
      return e == null ? void 0 : e.some(n => n.id === t)
    },
    setSmartAccountEnabledNetworks(t, e) {
      this.setAdapterNetworkState(e, { smartAccountEnabledNetworks: t })
    },
    checkIfSmartAccountEnabled() {
      var r
      const t = yh.caipNetworkIdToNumber(
          (r = ve.activeCaipNetwork) == null ? void 0 : r.caipNetworkId
        ),
        e = ve.activeChain
      if (!e || !t) return !1
      const n = this.getNetworkProp('smartAccountEnabledNetworks', e)
      return !!(n != null && n.includes(Number(t)))
    },
    getActiveNetworkTokenAddress() {
      var r, i
      const t = ((r = ve.activeCaipNetwork) == null ? void 0 : r.chainNamespace) || 'eip155',
        e = ((i = ve.activeCaipNetwork) == null ? void 0 : i.id) || 1,
        n = Fn.NATIVE_TOKEN_ADDRESS[t]
      return `${t}:${e}:${n}`
    },
    showUnsupportedChainUI() {
      Kn.open({ view: 'UnsupportedChain' })
    },
    checkIfNamesSupported() {
      const t = ve.activeCaipNetwork
      return !!(
        t != null &&
        t.chainNamespace &&
        Fn.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(t.chainNamespace)
      )
    },
    resetNetwork(t) {
      this.setAdapterNetworkState(t, {
        approvedCaipNetworkIds: void 0,
        supportsAllNetworks: !0,
        smartAccountEnabledNetworks: []
      })
    },
    resetAccount(t) {
      const e = t
      if (!e) throw new Error('Chain is required to set account prop')
      ;(ve.activeCaipAddress = void 0),
        this.setChainAccountData(e, {
          smartAccountDeployed: !1,
          currentTab: 0,
          caipAddress: void 0,
          address: void 0,
          balance: void 0,
          balanceSymbol: void 0,
          profileName: void 0,
          profileImage: void 0,
          addressExplorerUrl: void 0,
          tokenBalance: [],
          connectedWalletInfo: void 0,
          preferredAccountType: void 0,
          socialProvider: void 0,
          socialWindow: void 0,
          farcasterUrl: void 0,
          allAccounts: [],
          user: void 0,
          status: 'disconnected'
        }),
        Ge.removeConnectorId(e)
    },
    async disconnect() {
      try {
        x4.resetSend()
        const t = await Promise.allSettled(
          Array.from(ve.chains.entries()).map(async ([n, r]) => {
            var i
            try {
              ;(i = r.connectionControllerClient) != null &&
                i.disconnect &&
                (await r.connectionControllerClient.disconnect()),
                this.resetAccount(n),
                this.resetNetwork(n)
            } catch (s) {
              throw new Error(`Failed to disconnect chain ${n}: ${s.message}`)
            }
          })
        )
        ot.resetWcConnection()
        const e = t.filter(n => n.status === 'rejected')
        if (e.length > 0) throw new Error(e.map(n => n.reason.message).join(', '))
        Ne.deleteConnectedSocialProvider(),
          ot.resetWcConnection(),
          Ge.resetConnectorIds(),
          Ft.sendEvent({ type: 'track', event: 'DISCONNECT_SUCCESS' })
      } catch (t) {
        console.error(t.message || 'Failed to disconnect chains'),
          Ft.sendEvent({
            type: 'track',
            event: 'DISCONNECT_ERROR',
            properties: { message: t.message || 'Failed to disconnect chains' }
          })
      }
    },
    setIsSwitchingNamespace(t) {
      ve.isSwitchingNamespace = t
    },
    getFirstCaipNetworkSupportsAuthConnector() {
      var n, r
      const t = []
      let e
      if (
        (ve.chains.forEach(i => {
          he.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(s => s === i.namespace) &&
            i.namespace &&
            t.push(i.namespace)
        }),
        t.length > 0)
      ) {
        const i = t[0]
        return (
          (e = i
            ? (r = (n = ve.chains.get(i)) == null ? void 0 : n.caipNetworks) == null
              ? void 0
              : r[0]
            : void 0),
          e
        )
      }
    },
    getAccountData(t) {
      var e
      return t ? ((e = Q.state.chains.get(t)) == null ? void 0 : e.accountState) : Oe.state
    },
    getNetworkData(t) {
      var n
      const e = t || ve.activeChain
      if (e) return (n = Q.state.chains.get(e)) == null ? void 0 : n.networkState
    },
    getCaipNetworkByNamespace(t, e) {
      var i, s, c
      if (!t) return
      const n = Q.state.chains.get(t),
        r = (i = n == null ? void 0 : n.caipNetworks) == null ? void 0 : i.find(u => u.id === e)
      return (
        r ||
        ((s = n == null ? void 0 : n.networkState) == null ? void 0 : s.caipNetwork) ||
        ((c = n == null ? void 0 : n.caipNetworks) == null ? void 0 : c[0])
      )
    },
    getRequestedCaipNetworkIds() {
      const t = Ge.state.filterByNamespace
      return (t ? [ve.chains.get(t)] : Array.from(ve.chains.values()))
        .flatMap(n => (n == null ? void 0 : n.caipNetworks) || [])
        .map(n => n.caipNetworkId)
    }
  },
  hX = {
    purchaseCurrencies: [
      {
        id: '2b92315d-eab7-5bef-84fa-089a131333f5',
        name: 'USD Coin',
        symbol: 'USDC',
        networks: [
          {
            name: 'ethereum-mainnet',
            display_name: 'Ethereum',
            chain_id: '1',
            contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
          },
          {
            name: 'polygon-mainnet',
            display_name: 'Polygon',
            chain_id: '137',
            contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
          }
        ]
      },
      {
        id: '2b92315d-eab7-5bef-84fa-089a131333f5',
        name: 'Ether',
        symbol: 'ETH',
        networks: [
          {
            name: 'ethereum-mainnet',
            display_name: 'Ethereum',
            chain_id: '1',
            contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
          },
          {
            name: 'polygon-mainnet',
            display_name: 'Polygon',
            chain_id: '137',
            contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
          }
        ]
      }
    ],
    paymentCurrencies: [
      {
        id: 'USD',
        payment_method_limits: [
          { id: 'card', min: '10.00', max: '7500.00' },
          { id: 'ach_bank_account', min: '10.00', max: '25000.00' }
        ]
      },
      {
        id: 'EUR',
        payment_method_limits: [
          { id: 'card', min: '10.00', max: '7500.00' },
          { id: 'ach_bank_account', min: '10.00', max: '25000.00' }
        ]
      }
    ]
  },
  P9 = $e.getBlockchainApiUrl(),
  fi = gn({
    clientId: null,
    api: new xm({ baseUrl: P9, clientId: null }),
    supportedChains: { http: [], ws: [] }
  }),
  Me = {
    state: fi,
    async get(t) {
      const { st: e, sv: n } = Me.getSdkProperties(),
        r = be.state.projectId,
        i = { ...(t.params || {}), st: e, sv: n, projectId: r }
      return fi.api.get({ ...t, params: i })
    },
    getSdkProperties() {
      const { sdkType: t, sdkVersion: e } = be.state
      return { st: t || 'unknown', sv: e || 'unknown' }
    },
    async isNetworkSupported(t) {
      if (!t) return !1
      try {
        fi.supportedChains.http.length || (await Me.getSupportedNetworks())
      } catch {
        return !1
      }
      return fi.supportedChains.http.includes(t)
    },
    async getSupportedNetworks() {
      const t = await Me.get({ path: 'v1/supported-chains' })
      return (fi.supportedChains = t), t
    },
    async fetchIdentity({ address: t, caipNetworkId: e }) {
      if (!(await Me.isNetworkSupported(e))) return { avatar: '', name: '' }
      const r = Ne.getIdentityFromCacheForAddress(t)
      if (r) return r
      const i = await Me.get({
        path: `/v1/identity/${t}`,
        params: {
          sender: Q.state.activeCaipAddress ? $e.getPlainAddress(Q.state.activeCaipAddress) : void 0
        }
      })
      return Ne.updateIdentityCache({ address: t, identity: i, timestamp: Date.now() }), i
    },
    async fetchTransactions({ account: t, cursor: e, onramp: n, signal: r, cache: i, chainId: s }) {
      var u
      return (await Me.isNetworkSupported(
        (u = Q.state.activeCaipNetwork) == null ? void 0 : u.caipNetworkId
      ))
        ? Me.get({
            path: `/v1/account/${t}/history`,
            params: { cursor: e, onramp: n, chainId: s },
            signal: r,
            cache: i
          })
        : { data: [], next: void 0 }
    },
    async fetchSwapQuote({ amount: t, userAddress: e, from: n, to: r, gasPrice: i }) {
      var c
      return (await Me.isNetworkSupported(
        (c = Q.state.activeCaipNetwork) == null ? void 0 : c.caipNetworkId
      ))
        ? Me.get({
            path: '/v1/convert/quotes',
            headers: { 'Content-Type': 'application/json' },
            params: { amount: t, userAddress: e, from: n, to: r, gasPrice: i }
          })
        : { quotes: [] }
    },
    async fetchSwapTokens({ chainId: t }) {
      var n
      return (await Me.isNetworkSupported(
        (n = Q.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? Me.get({ path: '/v1/convert/tokens', params: { chainId: t } })
        : { tokens: [] }
    },
    async fetchTokenPrice({ addresses: t }) {
      var n
      return (await Me.isNetworkSupported(
        (n = Q.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? fi.api.post({
            path: '/v1/fungible/price',
            body: { currency: 'usd', addresses: t, projectId: be.state.projectId },
            headers: { 'Content-Type': 'application/json' }
          })
        : { fungibles: [] }
    },
    async fetchSwapAllowance({ tokenAddress: t, userAddress: e }) {
      var r
      return (await Me.isNetworkSupported(
        (r = Q.state.activeCaipNetwork) == null ? void 0 : r.caipNetworkId
      ))
        ? Me.get({
            path: '/v1/convert/allowance',
            params: { tokenAddress: t, userAddress: e },
            headers: { 'Content-Type': 'application/json' }
          })
        : { allowance: '0' }
    },
    async fetchGasPrice({ chainId: t }) {
      var i
      const { st: e, sv: n } = Me.getSdkProperties()
      if (
        !(await Me.isNetworkSupported(
          (i = Q.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId
        ))
      )
        throw new Error('Network not supported for Gas Price')
      return Me.get({
        path: '/v1/convert/gas-price',
        headers: { 'Content-Type': 'application/json' },
        params: { chainId: t, st: e, sv: n }
      })
    },
    async generateSwapCalldata({ amount: t, from: e, to: n, userAddress: r }) {
      var s
      if (
        !(await Me.isNetworkSupported(
          (s = Q.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId
        ))
      )
        throw new Error('Network not supported for Swaps')
      return fi.api.post({
        path: '/v1/convert/build-transaction',
        headers: { 'Content-Type': 'application/json' },
        body: {
          amount: t,
          eip155: { slippage: Fn.CONVERT_SLIPPAGE_TOLERANCE },
          projectId: be.state.projectId,
          from: e,
          to: n,
          userAddress: r
        }
      })
    },
    async generateApproveCalldata({ from: t, to: e, userAddress: n }) {
      var c
      const { st: r, sv: i } = Me.getSdkProperties()
      if (
        !(await Me.isNetworkSupported(
          (c = Q.state.activeCaipNetwork) == null ? void 0 : c.caipNetworkId
        ))
      )
        throw new Error('Network not supported for Swaps')
      return Me.get({
        path: '/v1/convert/build-approve',
        headers: { 'Content-Type': 'application/json' },
        params: { userAddress: n, from: t, to: e, st: r, sv: i }
      })
    },
    async getBalance(t, e, n) {
      var d
      const { st: r, sv: i } = Me.getSdkProperties()
      if (
        !(await Me.isNetworkSupported(
          (d = Q.state.activeCaipNetwork) == null ? void 0 : d.caipNetworkId
        ))
      )
        return $t.showError('Token Balance Unavailable'), { balances: [] }
      const c = `${e}:${t}`,
        u = Ne.getBalanceCacheForCaipAddress(c)
      if (u) return u
      const f = await Me.get({
        path: `/v1/account/${t}/balance`,
        params: { currency: 'usd', chainId: e, forceUpdate: n, st: r, sv: i }
      })
      return Ne.updateBalanceCache({ caipAddress: c, balance: f, timestamp: Date.now() }), f
    },
    async lookupEnsName(t) {
      var n
      return (await Me.isNetworkSupported(
        (n = Q.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? Me.get({ path: `/v1/profile/account/${t}`, params: { apiVersion: '2' } })
        : { addresses: {}, attributes: [] }
    },
    async reverseLookupEnsName({ address: t }) {
      var n
      return (await Me.isNetworkSupported(
        (n = Q.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? Me.get({
            path: `/v1/profile/reverse/${t}`,
            params: { sender: Oe.state.address, apiVersion: '2' }
          })
        : []
    },
    async getEnsNameSuggestions(t) {
      var n
      return (await Me.isNetworkSupported(
        (n = Q.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? Me.get({ path: `/v1/profile/suggestions/${t}`, params: { zone: 'reown.id' } })
        : { suggestions: [] }
    },
    async registerEnsName({ coinType: t, address: e, message: n, signature: r }) {
      var s
      return (await Me.isNetworkSupported(
        (s = Q.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId
      ))
        ? fi.api.post({
            path: '/v1/profile/account',
            body: { coin_type: t, address: e, message: n, signature: r },
            headers: { 'Content-Type': 'application/json' }
          })
        : { success: !1 }
    },
    async generateOnRampURL({
      destinationWallets: t,
      partnerUserId: e,
      defaultNetwork: n,
      purchaseAmount: r,
      paymentAmount: i
    }) {
      var u
      return (await Me.isNetworkSupported(
        (u = Q.state.activeCaipNetwork) == null ? void 0 : u.caipNetworkId
      ))
        ? (
            await fi.api.post({
              path: '/v1/generators/onrampurl',
              params: { projectId: be.state.projectId },
              body: {
                destinationWallets: t,
                defaultNetwork: n,
                partnerUserId: e,
                defaultExperience: 'buy',
                presetCryptoAmount: r,
                presetFiatAmount: i
              }
            })
          ).url
        : ''
    },
    async getOnrampOptions() {
      var e
      if (
        !(await Me.isNetworkSupported(
          (e = Q.state.activeCaipNetwork) == null ? void 0 : e.caipNetworkId
        ))
      )
        return { paymentCurrencies: [], purchaseCurrencies: [] }
      try {
        return await Me.get({ path: '/v1/onramp/options' })
      } catch {
        return hX
      }
    },
    async getOnrampQuote({ purchaseCurrency: t, paymentCurrency: e, amount: n, network: r }) {
      var i
      try {
        return (await Me.isNetworkSupported(
          (i = Q.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId
        ))
          ? await fi.api.post({
              path: '/v1/onramp/quote',
              params: { projectId: be.state.projectId },
              body: { purchaseCurrency: t, paymentCurrency: e, amount: n, network: r }
            })
          : null
      } catch {
        return {
          coinbaseFee: { amount: n, currency: e.id },
          networkFee: { amount: n, currency: e.id },
          paymentSubtotal: { amount: n, currency: e.id },
          paymentTotal: { amount: n, currency: e.id },
          purchaseAmount: { amount: n, currency: e.id },
          quoteId: 'mocked-quote-id'
        }
      }
    },
    async getSmartSessions(t) {
      var n
      return (await Me.isNetworkSupported(
        (n = Q.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? Me.get({ path: `/v1/sessions/${t}` })
        : []
    },
    async revokeSmartSession(t, e, n) {
      var i
      return (await Me.isNetworkSupported(
        (i = Q.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId
      ))
        ? fi.api.post({
            path: `/v1/sessions/${t}/revoke`,
            params: { projectId: be.state.projectId },
            body: { pci: e, signature: n }
          })
        : { success: !1 }
    },
    setClientId(t) {
      ;(fi.clientId = t), (fi.api = new xm({ baseUrl: P9, clientId: t }))
    }
  },
  ih = {
    async getTokenList() {
      var r
      const t = Q.state.activeCaipNetwork,
        e = await Me.fetchSwapTokens({ chainId: t == null ? void 0 : t.caipNetworkId })
      return (
        ((r = e == null ? void 0 : e.tokens) == null
          ? void 0
          : r.map(i => ({
              ...i,
              eip2612: !1,
              quantity: { decimals: '0', numeric: '0' },
              price: 0,
              value: 0
            }))) || []
      )
    },
    async fetchGasPrice() {
      var e
      const t = Q.state.activeCaipNetwork
      if (!t) return null
      try {
        switch (t.chainNamespace) {
          case 'solana':
            const n =
              (e = await (ot == null ? void 0 : ot.estimateGas({ chainNamespace: 'solana' }))) ==
              null
                ? void 0
                : e.toString()
            return { standard: n, fast: n, instant: n }
          case 'eip155':
          default:
            return await Me.fetchGasPrice({ chainId: t.caipNetworkId })
        }
      } catch {
        return null
      }
    },
    async fetchSwapAllowance({
      tokenAddress: t,
      userAddress: e,
      sourceTokenAmount: n,
      sourceTokenDecimals: r
    }) {
      const i = await Me.fetchSwapAllowance({ tokenAddress: t, userAddress: e })
      if (i != null && i.allowance && n && r) {
        const s = ot.parseUnits(n, r) || 0
        return BigInt(i.allowance) >= s
      }
      return !1
    },
    async getMyTokensWithBalance(t) {
      const e = Oe.state.address,
        n = Q.state.activeCaipNetwork
      if (!e || !n) return []
      const i = (await Me.getBalance(e, n.caipNetworkId, t)).balances.filter(
        s => s.quantity.decimals !== '0'
      )
      return Oe.setTokenBalance(i, Q.state.activeChain), this.mapBalancesToSwapTokens(i)
    },
    mapBalancesToSwapTokens(t) {
      return (
        (t == null
          ? void 0
          : t.map(e => ({
              ...e,
              address: e != null && e.address ? e.address : Q.getActiveNetworkTokenAddress(),
              decimals: parseInt(e.quantity.decimals, 10),
              logoUri: e.iconUrl,
              eip2612: !1
            }))) || []
      )
    }
  },
  Sa = {
    getGasPriceInEther(t, e) {
      const n = e * t
      return Number(n) / 1e18
    },
    getGasPriceInUSD(t, e, n) {
      const r = Sa.getGasPriceInEther(e, n)
      return Lt.bigNumber(t).times(r).toNumber()
    },
    getPriceImpact({
      sourceTokenAmount: t,
      sourceTokenPriceInUSD: e,
      toTokenPriceInUSD: n,
      toTokenAmount: r
    }) {
      const i = Lt.bigNumber(t).times(e),
        s = Lt.bigNumber(r).times(n)
      return i.minus(s).div(i).times(100).toNumber()
    },
    getMaxSlippage(t, e) {
      const n = Lt.bigNumber(t).div(100)
      return Lt.multiply(e, n).toNumber()
    },
    getProviderFee(t, e = 0.0085) {
      return Lt.bigNumber(t).times(e).toString()
    },
    isInsufficientNetworkTokenForGas(t, e) {
      const n = e || '0'
      return Lt.bigNumber(t).eq(0) ? !0 : Lt.bigNumber(Lt.bigNumber(n)).gt(t)
    },
    isInsufficientSourceTokenForSwap(t, e, n) {
      var s, c
      const r =
        (c =
          (s = n == null ? void 0 : n.find(u => u.address === e)) == null ? void 0 : s.quantity) ==
        null
          ? void 0
          : c.numeric
      return Lt.bigNumber(r || '0').lt(t)
    },
    getToTokenAmount({
      sourceToken: t,
      toToken: e,
      sourceTokenPrice: n,
      toTokenPrice: r,
      sourceTokenAmount: i
    }) {
      if (i === '0' || !t || !e) return '0'
      const s = t.decimals,
        c = n,
        u = e.decimals,
        f = r
      if (f <= 0) return '0'
      const d = Lt.bigNumber(i).times(0.0085),
        g = Lt.bigNumber(i).minus(d).times(Lt.bigNumber(10).pow(s)),
        m = Lt.bigNumber(c).div(f),
        y = s - u
      return g
        .times(m)
        .div(Lt.bigNumber(10).pow(y))
        .div(Lt.bigNumber(10).pow(u))
        .toFixed(u)
        .toString()
    }
  },
  N4 = 15e4,
  pX = 6,
  Qr = {
    initializing: !1,
    initialized: !1,
    loadingPrices: !1,
    loadingQuote: !1,
    loadingApprovalTransaction: !1,
    loadingBuildTransaction: !1,
    loadingTransaction: !1,
    fetchError: !1,
    approvalTransaction: void 0,
    swapTransaction: void 0,
    transactionError: void 0,
    sourceToken: void 0,
    sourceTokenAmount: '',
    sourceTokenPriceInUSD: 0,
    toToken: void 0,
    toTokenAmount: '',
    toTokenPriceInUSD: 0,
    networkPrice: '0',
    networkBalanceInUSD: '0',
    networkTokenSymbol: '',
    inputError: void 0,
    slippage: Fn.CONVERT_SLIPPAGE_TOLERANCE,
    tokens: void 0,
    popularTokens: void 0,
    suggestedTokens: void 0,
    foundTokens: void 0,
    myTokensWithBalance: void 0,
    tokensPriceMap: {},
    gasFee: '0',
    gasPriceInUSD: 0,
    priceImpact: void 0,
    maxSlippage: void 0,
    providerFee: void 0
  },
  re = gn(Qr),
  Pg = {
    state: re,
    subscribe(t) {
      return Rr(re, () => t(re))
    },
    subscribeKey(t, e) {
      return zr(re, t, e)
    },
    getParams() {
      var f, d, p, g, m, y, A, E
      const t = Q.state.activeCaipAddress,
        e = Q.state.activeChain,
        n = $e.getPlainAddress(t),
        r = Q.getActiveNetworkTokenAddress(),
        i = Ge.getConnectorId(e)
      if (!n) throw new Error('No address found to swap the tokens from.')
      const s =
          !((f = re.toToken) != null && f.address) || !((d = re.toToken) != null && d.decimals),
        c =
          !((p = re.sourceToken) != null && p.address) ||
          !((g = re.sourceToken) != null && g.decimals) ||
          !Lt.bigNumber(re.sourceTokenAmount).gt(0),
        u = !re.sourceTokenAmount
      return {
        networkAddress: r,
        fromAddress: n,
        fromCaipAddress: t,
        sourceTokenAddress: (m = re.sourceToken) == null ? void 0 : m.address,
        toTokenAddress: (y = re.toToken) == null ? void 0 : y.address,
        toTokenAmount: re.toTokenAmount,
        toTokenDecimals: (A = re.toToken) == null ? void 0 : A.decimals,
        sourceTokenAmount: re.sourceTokenAmount,
        sourceTokenDecimals: (E = re.sourceToken) == null ? void 0 : E.decimals,
        invalidToToken: s,
        invalidSourceToken: c,
        invalidSourceTokenAmount: u,
        availableToSwap: t && !s && !c && !u,
        isAuthConnector: i === he.CONNECTOR_ID.AUTH
      }
    },
    setSourceToken(t) {
      if (!t) {
        ;(re.sourceToken = t), (re.sourceTokenAmount = ''), (re.sourceTokenPriceInUSD = 0)
        return
      }
      ;(re.sourceToken = t), this.setTokenPrice(t.address, 'sourceToken')
    },
    setSourceTokenAmount(t) {
      re.sourceTokenAmount = t
    },
    setToToken(t) {
      if (!t) {
        ;(re.toToken = t), (re.toTokenAmount = ''), (re.toTokenPriceInUSD = 0)
        return
      }
      ;(re.toToken = t), this.setTokenPrice(t.address, 'toToken')
    },
    setToTokenAmount(t) {
      re.toTokenAmount = t ? Lt.formatNumberToLocalString(t, pX) : ''
    },
    async setTokenPrice(t, e) {
      let n = re.tokensPriceMap[t] || 0
      n || ((re.loadingPrices = !0), (n = await this.getAddressPrice(t))),
        e === 'sourceToken'
          ? (re.sourceTokenPriceInUSD = n)
          : e === 'toToken' && (re.toTokenPriceInUSD = n),
        re.loadingPrices && (re.loadingPrices = !1),
        this.getParams().availableToSwap && this.swapTokens()
    },
    switchTokens() {
      if (re.initializing || !re.initialized) return
      const t = re.toToken ? { ...re.toToken } : void 0,
        e = re.sourceToken ? { ...re.sourceToken } : void 0,
        n = t && re.toTokenAmount === '' ? '1' : re.toTokenAmount
      this.setSourceToken(t),
        this.setToToken(e),
        this.setSourceTokenAmount(n),
        this.setToTokenAmount(''),
        this.swapTokens()
    },
    resetState() {
      ;(re.myTokensWithBalance = Qr.myTokensWithBalance),
        (re.tokensPriceMap = Qr.tokensPriceMap),
        (re.initialized = Qr.initialized),
        (re.sourceToken = Qr.sourceToken),
        (re.sourceTokenAmount = Qr.sourceTokenAmount),
        (re.sourceTokenPriceInUSD = Qr.sourceTokenPriceInUSD),
        (re.toToken = Qr.toToken),
        (re.toTokenAmount = Qr.toTokenAmount),
        (re.toTokenPriceInUSD = Qr.toTokenPriceInUSD),
        (re.networkPrice = Qr.networkPrice),
        (re.networkTokenSymbol = Qr.networkTokenSymbol),
        (re.networkBalanceInUSD = Qr.networkBalanceInUSD),
        (re.inputError = Qr.inputError)
    },
    resetValues() {
      var n
      const { networkAddress: t } = this.getParams(),
        e = (n = re.tokens) == null ? void 0 : n.find(r => r.address === t)
      this.setSourceToken(e), this.setToToken(void 0)
    },
    getApprovalLoadingState() {
      return re.loadingApprovalTransaction
    },
    clearError() {
      re.transactionError = void 0
    },
    async initializeState() {
      if (!re.initializing) {
        if (((re.initializing = !0), !re.initialized))
          try {
            await this.fetchTokens(), (re.initialized = !0)
          } catch {
            ;(re.initialized = !1), $t.showError('Failed to initialize swap'), ct.goBack()
          }
        re.initializing = !1
      }
    },
    async fetchTokens() {
      var n
      const { networkAddress: t } = this.getParams()
      await this.getTokenList(),
        await this.getNetworkTokenPrice(),
        await this.getMyTokensWithBalance()
      const e = (n = re.tokens) == null ? void 0 : n.find(r => r.address === t)
      e &&
        ((re.networkTokenSymbol = e.symbol), this.setSourceToken(e), this.setSourceTokenAmount('1'))
    },
    async getTokenList() {
      const t = await ih.getTokenList()
      ;(re.tokens = t),
        (re.popularTokens = t.sort((e, n) =>
          e.symbol < n.symbol ? -1 : e.symbol > n.symbol ? 1 : 0
        )),
        (re.suggestedTokens = t.filter(e => !!Fn.SWAP_SUGGESTED_TOKENS.includes(e.symbol), {}))
    },
    async getAddressPrice(t) {
      var f, d
      const e = re.tokensPriceMap[t]
      if (e) return e
      const n = await Me.fetchTokenPrice({ addresses: [t] }),
        r = (n == null ? void 0 : n.fungibles) || [],
        i = [...(re.tokens || []), ...(re.myTokensWithBalance || [])],
        s = (f = i == null ? void 0 : i.find(p => p.address === t)) == null ? void 0 : f.symbol,
        c =
          ((d = r.find(p => p.symbol.toLowerCase() === (s == null ? void 0 : s.toLowerCase()))) ==
          null
            ? void 0
            : d.price) || 0,
        u = parseFloat(c.toString())
      return (re.tokensPriceMap[t] = u), u
    },
    async getNetworkTokenPrice() {
      var i
      const { networkAddress: t } = this.getParams(),
        n =
          (i = (
            await Me.fetchTokenPrice({ addresses: [t] }).catch(
              () => ($t.showError('Failed to fetch network token price'), { fungibles: [] })
            )
          ).fungibles) == null
            ? void 0
            : i[0],
        r = (n == null ? void 0 : n.price.toString()) || '0'
      ;(re.tokensPriceMap[t] = parseFloat(r)),
        (re.networkTokenSymbol = (n == null ? void 0 : n.symbol) || ''),
        (re.networkPrice = r)
    },
    async getMyTokensWithBalance(t) {
      const e = await ih.getMyTokensWithBalance(t)
      e && (await this.getInitialGasPrice(), this.setBalances(e))
    },
    setBalances(t) {
      const { networkAddress: e } = this.getParams(),
        n = Q.state.activeCaipNetwork
      if (!n) return
      const r = t.find(i => i.address === e)
      t.forEach(i => {
        re.tokensPriceMap[i.address] = i.price || 0
      }),
        (re.myTokensWithBalance = t.filter(i => i.address.startsWith(n.caipNetworkId))),
        (re.networkBalanceInUSD = r ? Lt.multiply(r.quantity.numeric, r.price).toString() : '0')
    },
    async getInitialGasPrice() {
      var e, n
      const t = await ih.fetchGasPrice()
      if (!t) return { gasPrice: null, gasPriceInUSD: null }
      switch (
        (n = (e = Q.state) == null ? void 0 : e.activeCaipNetwork) == null
          ? void 0
          : n.chainNamespace
      ) {
        case 'solana':
          return (
            (re.gasFee = t.standard ?? '0'),
            (re.gasPriceInUSD = Lt.multiply(t.standard, re.networkPrice).div(1e9).toNumber()),
            { gasPrice: BigInt(re.gasFee), gasPriceInUSD: Number(re.gasPriceInUSD) }
          )
        case 'eip155':
        default:
          const r = t.standard ?? '0',
            i = BigInt(r),
            s = BigInt(N4),
            c = Sa.getGasPriceInUSD(re.networkPrice, s, i)
          return (re.gasFee = r), (re.gasPriceInUSD = c), { gasPrice: i, gasPriceInUSD: c }
      }
    },
    async swapTokens() {
      var s, c
      const t = Oe.state.address,
        e = re.sourceToken,
        n = re.toToken,
        r = Lt.bigNumber(re.sourceTokenAmount).gt(0)
      if ((r || this.setToTokenAmount(''), !n || !e || re.loadingPrices || !r)) return
      re.loadingQuote = !0
      const i = Lt.bigNumber(re.sourceTokenAmount)
        .times(10 ** e.decimals)
        .round(0)
      try {
        const u = await Me.fetchSwapQuote({
          userAddress: t,
          from: e.address,
          to: n.address,
          gasPrice: re.gasFee,
          amount: i.toString()
        })
        re.loadingQuote = !1
        const f =
          (c = (s = u == null ? void 0 : u.quotes) == null ? void 0 : s[0]) == null
            ? void 0
            : c.toAmount
        if (!f) {
          Vc.open(
            { shortMessage: 'Incorrect amount', longMessage: 'Please enter a valid amount' },
            'error'
          )
          return
        }
        const d = Lt.bigNumber(f)
          .div(10 ** n.decimals)
          .toString()
        this.setToTokenAmount(d),
          this.hasInsufficientToken(re.sourceTokenAmount, e.address)
            ? (re.inputError = 'Insufficient balance')
            : ((re.inputError = void 0), this.setTransactionDetails())
      } catch {
        ;(re.loadingQuote = !1), (re.inputError = 'Insufficient balance')
      }
    },
    async getTransaction() {
      const { fromCaipAddress: t, availableToSwap: e } = this.getParams(),
        n = re.sourceToken,
        r = re.toToken
      if (!(!t || !e || !n || !r || re.loadingQuote))
        try {
          re.loadingBuildTransaction = !0
          const i = await ih.fetchSwapAllowance({
            userAddress: t,
            tokenAddress: n.address,
            sourceTokenAmount: re.sourceTokenAmount,
            sourceTokenDecimals: n.decimals
          })
          let s
          return (
            i
              ? (s = await this.createSwapTransaction())
              : (s = await this.createAllowanceTransaction()),
            (re.loadingBuildTransaction = !1),
            (re.fetchError = !1),
            s
          )
        } catch {
          ct.goBack(),
            $t.showError('Failed to check allowance'),
            (re.loadingBuildTransaction = !1),
            (re.approvalTransaction = void 0),
            (re.swapTransaction = void 0),
            (re.fetchError = !0)
          return
        }
    },
    async createAllowanceTransaction() {
      const {
        fromCaipAddress: t,
        fromAddress: e,
        sourceTokenAddress: n,
        toTokenAddress: r
      } = this.getParams()
      if (!(!t || !r)) {
        if (!n) throw new Error('createAllowanceTransaction - No source token address found.')
        try {
          const i = await Me.generateApproveCalldata({ from: n, to: r, userAddress: t }),
            s = await ot.estimateGas({
              address: e,
              to: $e.getPlainAddress(i.tx.to),
              data: i.tx.data
            }),
            c = {
              data: i.tx.data,
              to: $e.getPlainAddress(i.tx.from),
              gas: s,
              gasPrice: BigInt(i.tx.eip155.gasPrice),
              value: BigInt(i.tx.value),
              toAmount: re.toTokenAmount
            }
          return (
            (re.swapTransaction = void 0),
            (re.approvalTransaction = {
              data: c.data,
              to: c.to,
              gas: c.gas ?? BigInt(0),
              gasPrice: c.gasPrice,
              value: c.value,
              toAmount: c.toAmount
            }),
            {
              data: c.data,
              to: c.to,
              gas: c.gas ?? BigInt(0),
              gasPrice: c.gasPrice,
              value: c.value,
              toAmount: c.toAmount
            }
          )
        } catch {
          ct.goBack(),
            $t.showError('Failed to create approval transaction'),
            (re.approvalTransaction = void 0),
            (re.swapTransaction = void 0),
            (re.fetchError = !0)
          return
        }
      }
    },
    async createSwapTransaction() {
      var c
      const { networkAddress: t, fromCaipAddress: e, sourceTokenAmount: n } = this.getParams(),
        r = re.sourceToken,
        i = re.toToken
      if (!e || !n || !r || !i) return
      const s = (c = ot.parseUnits(n, r.decimals)) == null ? void 0 : c.toString()
      try {
        const u = await Me.generateSwapCalldata({
            userAddress: e,
            from: r.address,
            to: i.address,
            amount: s
          }),
          f = r.address === t,
          d = BigInt(u.tx.eip155.gas),
          p = BigInt(u.tx.eip155.gasPrice),
          g = {
            data: u.tx.data,
            to: $e.getPlainAddress(u.tx.to),
            gas: d,
            gasPrice: p,
            value: BigInt(f ? (s ?? '0') : '0'),
            toAmount: re.toTokenAmount
          }
        return (
          (re.gasPriceInUSD = Sa.getGasPriceInUSD(re.networkPrice, d, p)),
          (re.approvalTransaction = void 0),
          (re.swapTransaction = g),
          g
        )
      } catch {
        ct.goBack(),
          $t.showError('Failed to create transaction'),
          (re.approvalTransaction = void 0),
          (re.swapTransaction = void 0),
          (re.fetchError = !0)
        return
      }
    },
    async sendTransactionForApproval(t) {
      var i, s, c
      const { fromAddress: e, isAuthConnector: n } = this.getParams()
      re.loadingApprovalTransaction = !0
      const r = 'Approve limit increase in your wallet'
      n
        ? ct.pushTransactionStack({
            view: null,
            goBack: !0,
            onSuccess() {
              $t.showLoading(r)
            }
          })
        : $t.showLoading(r)
      try {
        await ot.sendTransaction({
          address: e,
          to: t.to,
          data: t.data,
          gas: t.gas,
          gasPrice: BigInt(t.gasPrice),
          value: t.value,
          chainNamespace: 'eip155'
        }),
          await this.swapTokens(),
          await this.getTransaction(),
          (re.approvalTransaction = void 0),
          (re.loadingApprovalTransaction = !1)
      } catch (u) {
        const f = u
        ;(re.transactionError = f == null ? void 0 : f.shortMessage),
          (re.loadingApprovalTransaction = !1),
          $t.showError((f == null ? void 0 : f.shortMessage) || 'Transaction error'),
          Ft.sendEvent({
            type: 'track',
            event: 'SWAP_APPROVAL_ERROR',
            properties: {
              message:
                (f == null ? void 0 : f.shortMessage) ||
                (f == null ? void 0 : f.message) ||
                'Unknown',
              network: ((i = Q.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId) || '',
              swapFromToken: ((s = this.state.sourceToken) == null ? void 0 : s.symbol) || '',
              swapToToken: ((c = this.state.toToken) == null ? void 0 : c.symbol) || '',
              swapFromAmount: this.state.sourceTokenAmount || '',
              swapToAmount: this.state.toTokenAmount || '',
              isSmartAccount: Oe.state.preferredAccountType === yn.ACCOUNT_TYPES.SMART_ACCOUNT
            }
          })
      }
    },
    async sendTransactionForSwap(t) {
      var c, u, f, d, p, g, m, y, A, E, x, O
      if (!t) return
      const { fromAddress: e, toTokenAmount: n, isAuthConnector: r } = this.getParams()
      re.loadingTransaction = !0
      const i = `Swapping ${(c = re.sourceToken) == null ? void 0 : c.symbol} to ${Lt.formatNumberToLocalString(n, 3)} ${(u = re.toToken) == null ? void 0 : u.symbol}`,
        s = `Swapped ${(f = re.sourceToken) == null ? void 0 : f.symbol} to ${Lt.formatNumberToLocalString(n, 3)} ${(d = re.toToken) == null ? void 0 : d.symbol}`
      r
        ? ct.pushTransactionStack({
            view: 'Account',
            goBack: !1,
            onSuccess() {
              $t.showLoading(i), Pg.resetState()
            }
          })
        : $t.showLoading('Confirm transaction in your wallet')
      try {
        const I = [
            (p = re.sourceToken) == null ? void 0 : p.address,
            (g = re.toToken) == null ? void 0 : g.address
          ].join(','),
          M = await ot.sendTransaction({
            address: e,
            to: t.to,
            data: t.data,
            gas: t.gas,
            gasPrice: BigInt(t.gasPrice),
            value: t.value,
            chainNamespace: 'eip155'
          })
        return (
          (re.loadingTransaction = !1),
          $t.showSuccess(s),
          Ft.sendEvent({
            type: 'track',
            event: 'SWAP_SUCCESS',
            properties: {
              network: ((m = Q.state.activeCaipNetwork) == null ? void 0 : m.caipNetworkId) || '',
              swapFromToken: ((y = this.state.sourceToken) == null ? void 0 : y.symbol) || '',
              swapToToken: ((A = this.state.toToken) == null ? void 0 : A.symbol) || '',
              swapFromAmount: this.state.sourceTokenAmount || '',
              swapToAmount: this.state.toTokenAmount || '',
              isSmartAccount: Oe.state.preferredAccountType === yn.ACCOUNT_TYPES.SMART_ACCOUNT
            }
          }),
          Pg.resetState(),
          r || ct.replace('Account'),
          Pg.getMyTokensWithBalance(I),
          M
        )
      } catch (I) {
        const M = I
        ;(re.transactionError = M == null ? void 0 : M.shortMessage),
          (re.loadingTransaction = !1),
          $t.showError((M == null ? void 0 : M.shortMessage) || 'Transaction error'),
          Ft.sendEvent({
            type: 'track',
            event: 'SWAP_ERROR',
            properties: {
              message:
                (M == null ? void 0 : M.shortMessage) ||
                (M == null ? void 0 : M.message) ||
                'Unknown',
              network: ((E = Q.state.activeCaipNetwork) == null ? void 0 : E.caipNetworkId) || '',
              swapFromToken: ((x = this.state.sourceToken) == null ? void 0 : x.symbol) || '',
              swapToToken: ((O = this.state.toToken) == null ? void 0 : O.symbol) || '',
              swapFromAmount: this.state.sourceTokenAmount || '',
              swapToAmount: this.state.toTokenAmount || '',
              isSmartAccount: Oe.state.preferredAccountType === yn.ACCOUNT_TYPES.SMART_ACCOUNT
            }
          })
        return
      }
    },
    hasInsufficientToken(t, e) {
      const n = Sa.isInsufficientSourceTokenForSwap(t, e, re.myTokensWithBalance)
      let r = !0
      return (
        Oe.state.preferredAccountType === yn.ACCOUNT_TYPES.SMART_ACCOUNT
          ? (r = !1)
          : (r = Sa.isInsufficientNetworkTokenForGas(re.networkBalanceInUSD, re.gasPriceInUSD)),
        r || n
      )
    },
    setTransactionDetails() {
      const { toTokenAddress: t, toTokenDecimals: e } = this.getParams()
      !t ||
        !e ||
        ((re.gasPriceInUSD = Sa.getGasPriceInUSD(re.networkPrice, BigInt(re.gasFee), BigInt(N4))),
        (re.priceImpact = Sa.getPriceImpact({
          sourceTokenAmount: re.sourceTokenAmount,
          sourceTokenPriceInUSD: re.sourceTokenPriceInUSD,
          toTokenPriceInUSD: re.toTokenPriceInUSD,
          toTokenAmount: re.toTokenAmount
        })),
        (re.maxSlippage = Sa.getMaxSlippage(re.slippage, re.toTokenAmount)),
        (re.providerFee = Sa.getProviderFee(re.sourceTokenAmount)))
    }
  },
  Rs = gn({
    currentTab: 0,
    tokenBalance: [],
    smartAccountDeployed: !1,
    addressLabels: new Map(),
    allAccounts: []
  }),
  Oe = {
    state: Rs,
    replaceState(t) {
      t && Object.assign(Rs, Zc(t))
    },
    subscribe(t) {
      return Q.subscribeChainProp('accountState', e => {
        if (e) return t(e)
      })
    },
    subscribeKey(t, e, n) {
      let r
      return Q.subscribeChainProp(
        'accountState',
        i => {
          if (i) {
            const s = i[t]
            r !== s && ((r = s), e(s))
          }
        },
        n
      )
    },
    setStatus(t, e) {
      Q.setAccountProp('status', t, e)
    },
    getCaipAddress(t) {
      return Q.getAccountProp('caipAddress', t)
    },
    setCaipAddress(t, e) {
      const n = t ? $e.getPlainAddress(t) : void 0
      e === Q.state.activeChain && (Q.state.activeCaipAddress = t),
        Q.setAccountProp('caipAddress', t, e),
        Q.setAccountProp('address', n, e)
    },
    setBalance(t, e, n) {
      Q.setAccountProp('balance', t, n), Q.setAccountProp('balanceSymbol', e, n)
    },
    setProfileName(t, e) {
      Q.setAccountProp('profileName', t, e)
    },
    setProfileImage(t, e) {
      Q.setAccountProp('profileImage', t, e)
    },
    setUser(t, e) {
      Q.setAccountProp('user', t, e)
    },
    setAddressExplorerUrl(t, e) {
      Q.setAccountProp('addressExplorerUrl', t, e)
    },
    setSmartAccountDeployed(t, e) {
      Q.setAccountProp('smartAccountDeployed', t, e)
    },
    setCurrentTab(t) {
      Q.setAccountProp('currentTab', t, Q.state.activeChain)
    },
    setTokenBalance(t, e) {
      t && Q.setAccountProp('tokenBalance', t, e)
    },
    setShouldUpdateToAddress(t, e) {
      Q.setAccountProp('shouldUpdateToAddress', t, e)
    },
    setAllAccounts(t, e) {
      Q.setAccountProp('allAccounts', t, e)
    },
    addAddressLabel(t, e, n) {
      const r = Q.getAccountProp('addressLabels', n) || new Map()
      r.set(t, e), Q.setAccountProp('addressLabels', r, n)
    },
    removeAddressLabel(t, e) {
      const n = Q.getAccountProp('addressLabels', e) || new Map()
      n.delete(t), Q.setAccountProp('addressLabels', n, e)
    },
    setConnectedWalletInfo(t, e) {
      Q.setAccountProp('connectedWalletInfo', t, e, !1)
    },
    setPreferredAccountType(t, e) {
      Q.setAccountProp('preferredAccountType', t, e)
    },
    setSocialProvider(t, e) {
      t && Q.setAccountProp('socialProvider', t, e)
    },
    setSocialWindow(t, e) {
      Q.setAccountProp('socialWindow', t ? Zc(t) : void 0, e)
    },
    setFarcasterUrl(t, e) {
      Q.setAccountProp('farcasterUrl', t, e)
    },
    async fetchTokenBalance(t) {
      var s, c
      Rs.balanceLoading = !0
      const e = (s = Q.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId,
        n = (c = Q.state.activeCaipNetwork) == null ? void 0 : c.chainNamespace,
        r = Q.state.activeCaipAddress,
        i = r ? $e.getPlainAddress(r) : void 0
      if (Rs.lastRetry && !$e.isAllowedRetry(Rs.lastRetry, 30 * Fn.ONE_SEC_MS))
        return (Rs.balanceLoading = !1), []
      try {
        if (i && e && n) {
          const u = await Me.getBalance(i, e),
            f = u.balances.filter(d => d.quantity.decimals !== '0')
          return (
            this.setTokenBalance(f, n),
            Pg.setBalances(ih.mapBalancesToSwapTokens(u.balances)),
            (Rs.lastRetry = void 0),
            (Rs.balanceLoading = !1),
            f
          )
        }
      } catch (u) {
        ;(Rs.lastRetry = Date.now()), t == null || t(u), $t.showError('Token Balance Unavailable')
      } finally {
        Rs.balanceLoading = !1
      }
      return []
    },
    resetAccount(t) {
      Q.resetAccount(t)
    }
  },
  gX = $e.getApiUrl(),
  xr = new xm({ baseUrl: gX, clientId: null }),
  mX = '40',
  I4 = '4',
  bX = 20,
  Ln = gn({
    page: 1,
    count: 0,
    featured: [],
    recommended: [],
    wallets: [],
    search: [],
    isAnalyticsEnabled: !1,
    excludedRDNS: [],
    isFetchingRecommendedWallets: !1
  }),
  gt = {
    state: Ln,
    subscribeKey(t, e) {
      return zr(Ln, t, e)
    },
    _getSdkProperties() {
      const { projectId: t, sdkType: e, sdkVersion: n } = be.state
      return { projectId: t, st: e || 'appkit', sv: n || 'html-wagmi-4.2.2' }
    },
    _filterOutExtensions(t) {
      return be.state.isUniversalProvider
        ? t.filter(e => !!(e.mobile_link || e.desktop_link || e.webapp_link))
        : t
    },
    async _fetchWalletImage(t) {
      const e = `${xr.baseUrl}/getWalletImage/${t}`,
        n = await xr.getBlob({ path: e, params: gt._getSdkProperties() })
      os.setWalletImage(t, URL.createObjectURL(n))
    },
    async _fetchNetworkImage(t) {
      const e = `${xr.baseUrl}/public/getAssetImage/${t}`,
        n = await xr.getBlob({ path: e, params: gt._getSdkProperties() })
      os.setNetworkImage(t, URL.createObjectURL(n))
    },
    async _fetchConnectorImage(t) {
      const e = `${xr.baseUrl}/public/getAssetImage/${t}`,
        n = await xr.getBlob({ path: e, params: gt._getSdkProperties() })
      os.setConnectorImage(t, URL.createObjectURL(n))
    },
    async _fetchCurrencyImage(t) {
      const e = `${xr.baseUrl}/public/getCurrencyImage/${t}`,
        n = await xr.getBlob({ path: e, params: gt._getSdkProperties() })
      os.setCurrencyImage(t, URL.createObjectURL(n))
    },
    async _fetchTokenImage(t) {
      const e = `${xr.baseUrl}/public/getTokenImage/${t}`,
        n = await xr.getBlob({ path: e, params: gt._getSdkProperties() })
      os.setTokenImage(t, URL.createObjectURL(n))
    },
    async fetchNetworkImages() {
      const t = Q.getAllRequestedCaipNetworks(),
        e =
          t == null
            ? void 0
            : t
                .map(({ assets: n }) => (n == null ? void 0 : n.imageId))
                .filter(Boolean)
                .filter(n => !K8.getNetworkImageById(n))
      e && (await Promise.allSettled(e.map(n => gt._fetchNetworkImage(n))))
    },
    async fetchConnectorImages() {
      const { connectors: t } = Ge.state,
        e = t.map(({ imageId: n }) => n).filter(Boolean)
      await Promise.allSettled(e.map(n => gt._fetchConnectorImage(n)))
    },
    async fetchCurrencyImages(t = []) {
      await Promise.allSettled(t.map(e => gt._fetchCurrencyImage(e)))
    },
    async fetchTokenImages(t = []) {
      await Promise.allSettled(t.map(e => gt._fetchTokenImage(e)))
    },
    async fetchFeaturedWallets() {
      const { featuredWalletIds: t } = be.state
      if (t != null && t.length) {
        const { data: e } = await xr.get({
          path: '/getWallets',
          params: {
            ...gt._getSdkProperties(),
            page: '1',
            entries: t != null && t.length ? String(t.length) : I4,
            include: t == null ? void 0 : t.join(',')
          }
        })
        e.sort((r, i) => t.indexOf(r.id) - t.indexOf(i.id))
        const n = e.map(r => r.image_id).filter(Boolean)
        await Promise.allSettled(n.map(r => gt._fetchWalletImage(r))), (Ln.featured = e)
      }
    },
    async fetchRecommendedWallets() {
      try {
        Ln.isFetchingRecommendedWallets = !0
        const { includeWalletIds: t, excludeWalletIds: e, featuredWalletIds: n } = be.state,
          r = [...(e ?? []), ...(n ?? [])].filter(Boolean),
          i = Q.getRequestedCaipNetworkIds().join(','),
          { data: s, count: c } = await xr.get({
            path: '/getWallets',
            params: {
              ...gt._getSdkProperties(),
              page: '1',
              chains: i,
              entries: I4,
              include: t == null ? void 0 : t.join(','),
              exclude: r == null ? void 0 : r.join(',')
            }
          }),
          u = Ne.getRecentWallets(),
          f = s.map(p => p.image_id).filter(Boolean),
          d = u.map(p => p.image_id).filter(Boolean)
        await Promise.allSettled([...f, ...d].map(p => gt._fetchWalletImage(p))),
          (Ln.recommended = s),
          (Ln.count = c ?? 0)
      } catch {
      } finally {
        Ln.isFetchingRecommendedWallets = !1
      }
    },
    async fetchWallets({ page: t }) {
      const { includeWalletIds: e, excludeWalletIds: n, featuredWalletIds: r } = be.state,
        i = Q.getRequestedCaipNetworkIds().join(','),
        s = [...Ln.recommended.map(({ id: d }) => d), ...(n ?? []), ...(r ?? [])].filter(Boolean),
        { data: c, count: u } = await xr.get({
          path: '/getWallets',
          params: {
            ...gt._getSdkProperties(),
            page: String(t),
            entries: mX,
            chains: i,
            include: e == null ? void 0 : e.join(','),
            exclude: s.join(',')
          }
        }),
        f = c
          .slice(0, bX)
          .map(d => d.image_id)
          .filter(Boolean)
      await Promise.allSettled(f.map(d => gt._fetchWalletImage(d))),
        (Ln.wallets = $e.uniqueBy([...Ln.wallets, ...gt._filterOutExtensions(c)], 'id')),
        (Ln.count = u > Ln.count ? u : Ln.count),
        (Ln.page = t)
    },
    async initializeExcludedWalletRdns({ ids: t }) {
      const e = Q.getRequestedCaipNetworkIds().join(','),
        { data: n } = await xr.get({
          path: '/getWallets',
          params: {
            ...gt._getSdkProperties(),
            page: '1',
            entries: String(t.length),
            chains: e,
            include: t == null ? void 0 : t.join(',')
          }
        })
      n &&
        n.forEach(r => {
          r != null && r.rdns && Ln.excludedRDNS.push(r.rdns)
        })
    },
    async searchWallet({ search: t, badge: e }) {
      const { includeWalletIds: n, excludeWalletIds: r } = be.state
      Ln.search = []
      const i = Q.getRequestedCaipNetworkIds().join(','),
        { data: s } = await xr.get({
          path: '/getWallets',
          params: {
            ...gt._getSdkProperties(),
            page: '1',
            entries: '100',
            search: t == null ? void 0 : t.trim(),
            badge_type: e,
            chains: i,
            include: n == null ? void 0 : n.join(','),
            exclude: r == null ? void 0 : r.join(',')
          }
        })
      Ft.sendEvent({
        type: 'track',
        event: 'SEARCH_WALLET',
        properties: { badge: e ?? '', search: t ?? '' }
      })
      const c = s.map(u => u.image_id).filter(Boolean)
      await Promise.allSettled([...c.map(u => gt._fetchWalletImage(u)), $e.wait(300)]),
        (Ln.search = gt._filterOutExtensions(s))
    },
    prefetch({
      fetchConnectorImages: t = !0,
      fetchFeaturedWallets: e = !0,
      fetchRecommendedWallets: n = !0,
      fetchNetworkImages: r = !0
    } = {}) {
      if (Oe.state.status === 'connected') return Promise.resolve()
      if (Ln.prefetchPromise) return Ln.prefetchPromise
      const i = [
        t && gt.fetchConnectorImages(),
        e && gt.fetchFeaturedWallets(),
        n && gt.fetchRecommendedWallets(),
        r && gt.fetchNetworkImages()
      ].filter(Boolean)
      return (Ln.prefetchPromise = Promise.allSettled(i)), Ln.prefetchPromise
    },
    prefetchAnalyticsConfig() {
      var t
      ;(t = be.state.features) != null && t.analytics && gt.fetchAnalyticsConfig()
    },
    async fetchAnalyticsConfig() {
      try {
        const { isAnalyticsEnabled: t } = await xr.get({
          path: '/getAnalyticsConfig',
          params: gt._getSdkProperties()
        })
        be.setFeatures({ analytics: t })
      } catch {
        be.setFeatures({ analytics: !1 })
      }
    }
  },
  Wr = gn({ loading: !1, loadingNamespaceMap: new Map(), open: !1, shake: !1, namespace: void 0 }),
  Kn = {
    state: Wr,
    subscribe(t) {
      return Rr(Wr, () => t(Wr))
    },
    subscribeKey(t, e) {
      return zr(Wr, t, e)
    },
    async open(t) {
      var r
      ot.state.wcBasic
        ? gt.prefetch({ fetchNetworkImages: !1, fetchConnectorImages: !1 })
        : await gt.prefetch(),
        t != null && t.namespace
          ? (Ge.setFilterByNamespace(t.namespace),
            await Q.switchActiveNamespace(t.namespace),
            Kn.setLoading(!0, t.namespace))
          : Kn.setLoading(!0)
      const e =
        (r = Q.getAccountData(t == null ? void 0 : t.namespace)) == null ? void 0 : r.caipAddress
      Q.state.noAdapters && !e
        ? $e.isMobile()
          ? ct.reset('AllWallets')
          : ct.reset('ConnectingWalletConnectBasic')
        : t != null && t.view
          ? ct.reset(t.view)
          : e
            ? ct.reset('Account')
            : ct.reset('Connect'),
        (Wr.open = !0),
        Ra.set({ open: !0 }),
        Ft.sendEvent({ type: 'track', event: 'MODAL_OPEN', properties: { connected: !!e } })
    },
    close() {
      const t = be.state.enableEmbedded,
        e = !!Q.state.activeCaipAddress
      Wr.open &&
        Ft.sendEvent({ type: 'track', event: 'MODAL_CLOSE', properties: { connected: e } }),
        (Wr.open = !1),
        Kn.clearLoading(),
        t ? (e ? ct.replace('Account') : ct.push('Connect')) : Ra.set({ open: !1 }),
        Ge.clearNamespaceFilter(),
        ot.resetUri()
    },
    setLoading(t, e) {
      e && Wr.loadingNamespaceMap.set(e, t), (Wr.loading = t), Ra.set({ loading: t })
    },
    clearLoading() {
      Wr.loadingNamespaceMap.clear(), (Wr.loading = !1)
    },
    shake() {
      Wr.shake ||
        ((Wr.shake = !0),
        setTimeout(() => {
          Wr.shake = !1
        }, 500))
    }
  },
  O4 = 2147483648,
  yX = {
    convertEVMChainIdToCoinType(t) {
      if (t >= O4) throw new Error('Invalid chainId')
      return (O4 | t) >>> 0
    }
  },
  Pi = gn({ suggestions: [], loading: !1 }),
  M9 = {
    state: Pi,
    subscribe(t) {
      return Rr(Pi, () => t(Pi))
    },
    subscribeKey(t, e) {
      return zr(Pi, t, e)
    },
    async resolveName(t) {
      var e, n
      try {
        return await Me.lookupEnsName(t)
      } catch (r) {
        const i = r
        throw new Error(
          ((n = (e = i == null ? void 0 : i.reasons) == null ? void 0 : e[0]) == null
            ? void 0
            : n.description) || 'Error resolving name'
        )
      }
    },
    async isNameRegistered(t) {
      try {
        return await Me.lookupEnsName(t), !0
      } catch {
        return !1
      }
    },
    async getSuggestions(t) {
      try {
        ;(Pi.loading = !0), (Pi.suggestions = [])
        const e = await Me.getEnsNameSuggestions(t)
        return (
          (Pi.suggestions = e.suggestions.map(n => ({ ...n, name: n.name })) || []), Pi.suggestions
        )
      } catch (e) {
        const n = this.parseEnsApiError(e, 'Error fetching name suggestions')
        throw new Error(n)
      } finally {
        Pi.loading = !1
      }
    },
    async getNamesForAddress(t) {
      try {
        if (!Q.state.activeCaipNetwork) return []
        const n = Ne.getEnsFromCacheForAddress(t)
        if (n) return n
        const r = await Me.reverseLookupEnsName({ address: t })
        return Ne.updateEnsCache({ address: t, ens: r, timestamp: Date.now() }), r
      } catch (e) {
        const n = this.parseEnsApiError(e, 'Error fetching names for address')
        throw new Error(n)
      }
    },
    async registerName(t) {
      const e = Q.state.activeCaipNetwork
      if (!e) throw new Error('Network not found')
      const n = Oe.state.address,
        r = Ge.getAuthConnector()
      if (!n || !r) throw new Error('Address or auth connector not found')
      Pi.loading = !0
      try {
        const i = JSON.stringify({
          name: t,
          attributes: {},
          timestamp: Math.floor(Date.now() / 1e3)
        })
        ct.pushTransactionStack({
          view: 'RegisterAccountNameSuccess',
          goBack: !1,
          replace: !0,
          onCancel() {
            Pi.loading = !1
          }
        })
        const s = await ot.signMessage(i),
          c = e.id
        if (!c) throw new Error('Network not found')
        const u = yX.convertEVMChainIdToCoinType(Number(c))
        await Me.registerEnsName({ coinType: u, address: n, signature: s, message: i }),
          Oe.setProfileName(t, e.chainNamespace),
          ct.replace('RegisterAccountNameSuccess')
      } catch (i) {
        const s = this.parseEnsApiError(i, `Error registering name ${t}`)
        throw (ct.replace('RegisterAccountName'), new Error(s))
      } finally {
        Pi.loading = !1
      }
    },
    validateName(t) {
      return /^[a-zA-Z0-9-]{4,}$/u.test(t)
    },
    parseEnsApiError(t, e) {
      var r, i
      const n = t
      return (
        ((i = (r = n == null ? void 0 : n.reasons) == null ? void 0 : r[0]) == null
          ? void 0
          : i.description) || e
      )
    }
  }
var F1 = { exports: {} },
  j1 = {}
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var R4
function vX() {
  if (R4) return j1
  R4 = 1
  var t = gd()
  function e(g, m) {
    return (g === m && (g !== 0 || 1 / g === 1 / m)) || (g !== g && m !== m)
  }
  var n = typeof Object.is == 'function' ? Object.is : e,
    r = t.useState,
    i = t.useEffect,
    s = t.useLayoutEffect,
    c = t.useDebugValue
  function u(g, m) {
    var y = m(),
      A = r({ inst: { value: y, getSnapshot: m } }),
      E = A[0].inst,
      x = A[1]
    return (
      s(
        function () {
          ;(E.value = y), (E.getSnapshot = m), f(E) && x({ inst: E })
        },
        [g, y, m]
      ),
      i(
        function () {
          return (
            f(E) && x({ inst: E }),
            g(function () {
              f(E) && x({ inst: E })
            })
          )
        },
        [g]
      ),
      c(y),
      y
    )
  }
  function f(g) {
    var m = g.getSnapshot
    g = g.value
    try {
      var y = m()
      return !n(g, y)
    } catch {
      return !0
    }
  }
  function d(g, m) {
    return m()
  }
  var p =
    typeof window > 'u' ||
    typeof window.document > 'u' ||
    typeof window.document.createElement > 'u'
      ? d
      : u
  return (
    (j1.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : p), j1
  )
}
var D4
function wX() {
  return D4 || ((D4 = 1), (F1.exports = vX())), F1.exports
}
var EX = wX()
const AX = pd(EX),
  _X = {},
  { use: P4 } = t7,
  { useSyncExternalStore: CX } = AX,
  SX = (t, e) => {
    const n = Le.useRef()
    Le.useEffect(() => {
      n.current = h7(t, e)
    }),
      Le.useDebugValue(n.current)
  },
  TX = new WeakMap()
function k9(t, e) {
  const r = Le.useRef(),
    i = Le.useRef()
  let s = !0
  const c = CX(
    Le.useCallback(
      d => {
        const p = Rr(t, d)
        return d(), p
      },
      [t, void 0]
    ),
    () => {
      const d = Yc(t, P4)
      try {
        if (!s && r.current && i.current && !H8(r.current, d, i.current, new WeakMap()))
          return r.current
      } catch {}
      return d
    },
    () => Yc(t, P4)
  )
  s = !1
  const u = new WeakMap()
  Le.useEffect(() => {
    ;(r.current = c), (i.current = u)
  }),
    (_X ? 'production' : void 0) !== 'production' && SX(c, u)
  const f = Le.useMemo(() => new WeakMap(), [])
  return q8(c, u, f, TX)
}
function xX() {
  const { activeCaipNetwork: t } = k9(Q.state)
  return {
    caipNetwork: t,
    chainId: t == null ? void 0 : t.id,
    caipNetworkId: t == null ? void 0 : t.caipNetworkId
  }
}
function B2(t) {
  var s
  const e = k9(Q.state),
    n = e.activeChain
  if (!n)
    return {
      allAccounts: [],
      address: void 0,
      caipAddress: void 0,
      status: void 0,
      isConnected: !1,
      embeddedWalletInfo: void 0
    }
  const r = (s = e.chains.get(n)) == null ? void 0 : s.accountState,
    i = Ge.getAuthConnector(n)
  return {
    allAccounts: (r == null ? void 0 : r.allAccounts) || [],
    caipAddress: r == null ? void 0 : r.caipAddress,
    address: $e.getPlainAddress(r == null ? void 0 : r.caipAddress),
    isConnected: !!(r != null && r.caipAddress),
    status: r == null ? void 0 : r.status,
    embeddedWalletInfo: i
      ? {
          user: r == null ? void 0 : r.user,
          authProvider: (r == null ? void 0 : r.socialProvider) || 'email',
          accountType: r == null ? void 0 : r.preferredAccountType,
          isSmartAccountDeployed: !!(r != null && r.smartAccountDeployed)
        }
      : void 0
  }
}
function NX() {
  async function t() {
    await ot.disconnect()
  }
  return { disconnect: t }
}
const pn = {
    METMASK_CONNECTOR_NAME: 'MetaMask',
    TRUST_CONNECTOR_NAME: 'Trust Wallet',
    SOLFLARE_CONNECTOR_NAME: 'Solflare',
    PHANTOM_CONNECTOR_NAME: 'Phantom',
    COIN98_CONNECTOR_NAME: 'Coin98',
    MAGIC_EDEN_CONNECTOR_NAME: 'Magic Eden',
    BACKPACK_CONNECTOR_NAME: 'Backpack',
    BITGET_CONNECTOR_NAME: 'Bitget Wallet',
    FRONTIER_CONNECTOR_NAME: 'Frontier',
    XVERSE_CONNECTOR_NAME: 'Xverse Wallet',
    LEATHER_CONNECTOR_NAME: 'Leather',
    EIP155: 'eip155',
    ADD_CHAIN_METHOD: 'wallet_addEthereumChain',
    EIP6963_ANNOUNCE_EVENT: 'eip6963:announceProvider',
    EIP6963_REQUEST_EVENT: 'eip6963:requestProvider',
    CONNECTOR_RDNS_MAP: {
      coinbaseWallet: 'com.coinbase.wallet',
      coinbaseWalletSDK: 'com.coinbase.wallet'
    },
    CONNECTOR_TYPE_EXTERNAL: 'EXTERNAL',
    CONNECTOR_TYPE_WALLET_CONNECT: 'WALLET_CONNECT',
    CONNECTOR_TYPE_INJECTED: 'INJECTED',
    CONNECTOR_TYPE_ANNOUNCED: 'ANNOUNCED',
    CONNECTOR_TYPE_AUTH: 'AUTH',
    CONNECTOR_TYPE_MULTI_CHAIN: 'MULTI_CHAIN',
    CONNECTOR_TYPE_W3M_AUTH: 'ID_AUTH'
  },
  Lo = {
    ConnectorExplorerIds: {
      [he.CONNECTOR_ID.COINBASE]:
        'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa',
      [he.CONNECTOR_ID.COINBASE_SDK]:
        'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa',
      [he.CONNECTOR_ID.SAFE]: '225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f',
      [he.CONNECTOR_ID.LEDGER]: '19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927',
      [he.CONNECTOR_ID.OKX]: '971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709',
      [pn.METMASK_CONNECTOR_NAME]:
        'c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96',
      [pn.TRUST_CONNECTOR_NAME]: '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0',
      [pn.SOLFLARE_CONNECTOR_NAME]:
        '1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79',
      [pn.PHANTOM_CONNECTOR_NAME]:
        'a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393',
      [pn.COIN98_CONNECTOR_NAME]:
        '2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01',
      [pn.MAGIC_EDEN_CONNECTOR_NAME]:
        '8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6',
      [pn.BACKPACK_CONNECTOR_NAME]:
        '2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0',
      [pn.BITGET_CONNECTOR_NAME]:
        '38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662',
      [pn.FRONTIER_CONNECTOR_NAME]:
        '85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041',
      [pn.XVERSE_CONNECTOR_NAME]:
        '2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b',
      [pn.LEATHER_CONNECTOR_NAME]:
        '483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13'
    },
    NetworkImageIds: {
      1: 'ba0ba0cd-17c6-4806-ad93-f9d174f17900',
      42161: '3bff954d-5cb0-47a0-9a23-d20192e74600',
      43114: '30c46e53-e989-45fb-4549-be3bd4eb3b00',
      56: '93564157-2e8e-4ce7-81df-b264dbee9b00',
      250: '06b26297-fe0c-4733-5d6b-ffa5498aac00',
      10: 'ab9c186a-c52f-464b-2906-ca59d760a400',
      137: '41d04d42-da3b-4453-8506-668cc0727900',
      5e3: 'e86fae9b-b770-4eea-e520-150e12c81100',
      295: '6a97d510-cac8-4e58-c7ce-e8681b044c00',
      11155111: 'e909ea0a-f92a-4512-c8fc-748044ea6800',
      84532: 'a18a7ecd-e307-4360-4746-283182228e00',
      1301: '4eeea7ef-0014-4649-5d1d-07271a80f600',
      130: '2257980a-3463-48c6-cbac-a42d2a956e00',
      10143: '0a728e83-bacb-46db-7844-948f05434900',
      100: '02b53f6a-e3d4-479e-1cb4-21178987d100',
      9001: 'f926ff41-260d-4028-635e-91913fc28e00',
      324: 'b310f07f-4ef7-49f3-7073-2a0a39685800',
      314: '5a73b3dd-af74-424e-cae0-0de859ee9400',
      4689: '34e68754-e536-40da-c153-6ef2e7188a00',
      1088: '3897a66d-40b9-4833-162f-a2c90531c900',
      1284: '161038da-44ae-4ec7-1208-0ea569454b00',
      1285: 'f1d73bb6-5450-4e18-38f7-fb6484264a00',
      7777777: '845c60df-d429-4991-e687-91ae45791600',
      42220: 'ab781bbc-ccc6-418d-d32d-789b15da1f00',
      8453: '7289c336-3981-4081-c5f4-efc26ac64a00',
      1313161554: '3ff73439-a619-4894-9262-4470c773a100',
      2020: 'b8101fc0-9c19-4b6f-ec65-f6dfff106e00',
      2021: 'b8101fc0-9c19-4b6f-ec65-f6dfff106e00',
      80094: 'e329c2c9-59b0-4a02-83e4-212ff3779900',
      '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp': 'a1b58899-f671-4276-6a5e-56ca5bd59700',
      '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z': 'a1b58899-f671-4276-6a5e-56ca5bd59700',
      EtWTRABZaYq6iMfeYKouRu166VU2xqa1: 'a1b58899-f671-4276-6a5e-56ca5bd59700',
      '000000000019d6689c085ae165831e93': '21c895fa-e105-4829-9434-378bb54fa600',
      '000000000933ea01ad0ee984209779ba': '220bcb01-ba47-41d3-fe5b-e29bbc4a4b00'
    },
    ConnectorImageIds: {
      [he.CONNECTOR_ID.COINBASE]: '0c2840c3-5b04-4c44-9661-fbd4b49e1800',
      [he.CONNECTOR_ID.COINBASE_SDK]: '0c2840c3-5b04-4c44-9661-fbd4b49e1800',
      [he.CONNECTOR_ID.SAFE]: '461db637-8616-43ce-035a-d89b8a1d5800',
      [he.CONNECTOR_ID.LEDGER]: '54a1aa77-d202-4f8d-0fb2-5d2bb6db0300',
      [he.CONNECTOR_ID.WALLET_CONNECT]: 'ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400',
      [he.CONNECTOR_ID.INJECTED]: '07ba87ed-43aa-4adf-4540-9e6a2b9cae00'
    },
    ConnectorNamesMap: {
      [he.CONNECTOR_ID.INJECTED]: 'Browser Wallet',
      [he.CONNECTOR_ID.WALLET_CONNECT]: 'WalletConnect',
      [he.CONNECTOR_ID.COINBASE]: 'Coinbase',
      [he.CONNECTOR_ID.COINBASE_SDK]: 'Coinbase',
      [he.CONNECTOR_ID.LEDGER]: 'Ledger',
      [he.CONNECTOR_ID.SAFE]: 'Safe'
    },
    ConnectorTypesMap: {
      [he.CONNECTOR_ID.INJECTED]: 'INJECTED',
      [he.CONNECTOR_ID.WALLET_CONNECT]: 'WALLET_CONNECT',
      [he.CONNECTOR_ID.EIP6963]: 'ANNOUNCED',
      [he.CONNECTOR_ID.AUTH]: 'AUTH'
    }
  },
  U9 = {
    getCaipTokens(t) {
      if (!t) return
      const e = {}
      return (
        Object.entries(t).forEach(([n, r]) => {
          e[`${pn.EIP155}:${n}`] = r
        }),
        e
      )
    },
    isLowerCaseMatch(t, e) {
      return (t == null ? void 0 : t.toLowerCase()) === (e == null ? void 0 : e.toLowerCase())
    }
  },
  Pl = {
    UniversalProviderErrors: {
      UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
        message: 'Unauthorized: origin not allowed',
        alertErrorKey: 'INVALID_APP_CONFIGURATION'
      },
      JWT_VALIDATION_ERROR: {
        message: 'JWT validation error: JWT Token is not yet valid',
        alertErrorKey: 'JWT_TOKEN_NOT_VALID'
      },
      INVALID_KEY: { message: 'Unauthorized: invalid key', alertErrorKey: 'INVALID_PROJECT_ID' }
    },
    ALERT_ERRORS: {
      SWITCH_NETWORK_NOT_FOUND: {
        shortMessage: 'Network Not Found',
        longMessage:
          "Network not found - please make sure it is included in 'networks' array in createAppKit function"
      },
      INVALID_APP_CONFIGURATION: {
        shortMessage: 'Invalid App Configuration',
        longMessage: () =>
          `Origin ${IX() ? window.origin : 'unknown'} not found on Allowlist - update configuration on cloud.reown.com`
      },
      SOCIALS_TIMEOUT: {
        shortMessage: 'Invalid App Configuration',
        longMessage: () =>
          'There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com'
      },
      JWT_TOKEN_NOT_VALID: {
        shortMessage: 'Session Expired',
        longMessage:
          'Invalid session found on UniversalProvider - please check your time settings and connect again'
      },
      INVALID_PROJECT_ID: {
        shortMessage: 'Invalid App Configuration',
        longMessage: 'Invalid Project ID - update configuration'
      },
      PROJECT_ID_NOT_CONFIGURED: {
        shortMessage: 'Project ID Not Configured',
        longMessage: 'Project ID Not Configured - update configuration on cloud.reown.com'
      }
    }
  }
function IX() {
  return typeof window < 'u'
}
const OX = {
    createLogger(t, e = 'error') {
      const n = yd({ level: e }),
        { logger: r } = jE({ opts: n })
      return (
        (r.error = (...i) => {
          for (const s of i)
            if (s instanceof Error) {
              t(s, ...i)
              return
            }
          t(void 0, ...i)
        }),
        r
      )
    }
  },
  RX = 'rpc.walletconnect.org'
function DX(t, e) {
  const n = new URL('https://rpc.walletconnect.org/v1/')
  return n.searchParams.set('chainId', t), n.searchParams.set('projectId', e), n.toString()
}
const M4 = [
    'near:mainnet',
    'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
    'eip155:1101',
    'eip155:56',
    'eip155:42161',
    'eip155:7777777',
    'eip155:59144',
    'eip155:324',
    'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
    'eip155:5000',
    'solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz',
    'eip155:80084',
    'eip155:5003',
    'eip155:100',
    'eip155:8453',
    'eip155:42220',
    'eip155:1313161555',
    'eip155:17000',
    'eip155:1',
    'eip155:300',
    'eip155:1313161554',
    'eip155:1329',
    'eip155:84532',
    'eip155:421614',
    'eip155:11155111',
    'eip155:8217',
    'eip155:43114',
    'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
    'eip155:999999999',
    'eip155:11155420',
    'eip155:80002',
    'eip155:97',
    'eip155:43113',
    'eip155:137',
    'eip155:10',
    'eip155:1301',
    'bip122:000000000019d6689c085ae165831e93',
    'bip122:000000000933ea01ad0ee984209779ba'
  ],
  Wc = {
    extendRpcUrlWithProjectId(t, e) {
      let n = !1
      try {
        n = new URL(t).host === RX
      } catch {
        n = !1
      }
      if (n) {
        const r = new URL(t)
        return r.searchParams.has('projectId') || r.searchParams.set('projectId', e), r.toString()
      }
      return t
    },
    isCaipNetwork(t) {
      return 'chainNamespace' in t && 'caipNetworkId' in t
    },
    getChainNamespace(t) {
      return this.isCaipNetwork(t) ? t.chainNamespace : he.CHAIN.EVM
    },
    getCaipNetworkId(t) {
      return this.isCaipNetwork(t) ? t.caipNetworkId : `${he.CHAIN.EVM}:${t.id}`
    },
    getDefaultRpcUrl(t, e, n) {
      var i, s, c
      const r =
        (c = (s = (i = t.rpcUrls) == null ? void 0 : i.default) == null ? void 0 : s.http) == null
          ? void 0
          : c[0]
      return M4.includes(e) ? DX(e, n) : r || ''
    },
    extendCaipNetwork(t, { customNetworkImageUrls: e, projectId: n, customRpc: r }) {
      var f, d, p, g
      const i = this.getCaipNetworkId(t),
        s = this.getChainNamespace(t),
        c =
          (p =
            (d = (f = t == null ? void 0 : t.rpcUrls) == null ? void 0 : f.chainDefault) == null
              ? void 0
              : d.http) == null
            ? void 0
            : p[0]
      let u = ''
      return (
        r
          ? (u = ((g = t.rpcUrls.default.http) == null ? void 0 : g[0]) || '')
          : (u = this.getDefaultRpcUrl(t, i, n)),
        {
          ...t,
          chainNamespace: s,
          caipNetworkId: i,
          assets: { imageId: Lo.NetworkImageIds[t.id], imageUrl: e == null ? void 0 : e[t.id] },
          rpcUrls: {
            ...t.rpcUrls,
            default: { http: [u] },
            chainDefault: { http: [c || t.rpcUrls.default.http[0] || ''] }
          }
        }
      )
    },
    extendCaipNetworks(t, { customNetworkImageUrls: e, projectId: n, customRpcChainIds: r }) {
      return t.map(i =>
        Wc.extendCaipNetwork(i, {
          customNetworkImageUrls: e,
          projectId: n,
          customRpc: r == null ? void 0 : r.includes(i.id)
        })
      )
    },
    getViemTransport(t) {
      var n
      const e = (n = t.rpcUrls.default.http) == null ? void 0 : n[0]
      return M4.includes(t.caipNetworkId)
        ? PZ([B1(e, { fetchOptions: { headers: { 'Content-Type': 'text/plain' } } }), B1(e)])
        : B1(e)
    }
  },
  k4 = { transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u, signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u },
  yr = {
    set(t, e) {
      gi.isClient && localStorage.setItem(`${Re.STORAGE_KEY}${t}`, e)
    },
    get(t) {
      return gi.isClient ? localStorage.getItem(`${Re.STORAGE_KEY}${t}`) : null
    },
    delete(t, e) {
      gi.isClient &&
        (e ? localStorage.removeItem(t) : localStorage.removeItem(`${Re.STORAGE_KEY}${t}`))
    }
  },
  bg = 30 * 1e3,
  gi = {
    checkIfAllowedToTriggerEmail() {
      const t = yr.get(Re.LAST_EMAIL_LOGIN_TIME)
      if (t) {
        const e = Date.now() - Number(t)
        if (e < bg) {
          const n = Math.ceil((bg - e) / 1e3)
          throw new Error(`Please try again after ${n} seconds`)
        }
      }
    },
    getTimeToNextEmailLogin() {
      const t = yr.get(Re.LAST_EMAIL_LOGIN_TIME)
      if (t) {
        const e = Date.now() - Number(t)
        if (e < bg) return Math.ceil((bg - e) / 1e3)
      }
      return 0
    },
    checkIfRequestExists(t) {
      return yn.NOT_SAFE_RPC_METHODS.includes(t.method) || yn.SAFE_RPC_METHODS.includes(t.method)
    },
    getResponseType(t) {
      return typeof t == 'string' &&
        ((t == null ? void 0 : t.match(k4.transactionHash)) ||
          (t == null ? void 0 : t.match(k4.signedMessage)))
        ? Re.RPC_RESPONSE_TYPE_TX
        : Re.RPC_RESPONSE_TYPE_OBJECT
    },
    checkIfRequestIsSafe(t) {
      return yn.SAFE_RPC_METHODS.includes(t.method)
    },
    isClient: typeof window < 'u'
  }
var St
;(function (t) {
  t.assertEqual = i => i
  function e(i) {}
  t.assertIs = e
  function n(i) {
    throw new Error()
  }
  ;(t.assertNever = n),
    (t.arrayToEnum = i => {
      const s = {}
      for (const c of i) s[c] = c
      return s
    }),
    (t.getValidEnumValues = i => {
      const s = t.objectKeys(i).filter(u => typeof i[i[u]] != 'number'),
        c = {}
      for (const u of s) c[u] = i[u]
      return t.objectValues(c)
    }),
    (t.objectValues = i =>
      t.objectKeys(i).map(function (s) {
        return i[s]
      })),
    (t.objectKeys =
      typeof Object.keys == 'function'
        ? i => Object.keys(i)
        : i => {
            const s = []
            for (const c in i) Object.prototype.hasOwnProperty.call(i, c) && s.push(c)
            return s
          }),
    (t.find = (i, s) => {
      for (const c of i) if (s(c)) return c
    }),
    (t.isInteger =
      typeof Number.isInteger == 'function'
        ? i => Number.isInteger(i)
        : i => typeof i == 'number' && isFinite(i) && Math.floor(i) === i)
  function r(i, s = ' | ') {
    return i.map(c => (typeof c == 'string' ? `'${c}'` : c)).join(s)
  }
  ;(t.joinValues = r),
    (t.jsonStringifyReplacer = (i, s) => (typeof s == 'bigint' ? s.toString() : s))
})(St || (St = {}))
var uE
;(function (t) {
  t.mergeShapes = (e, n) => ({ ...e, ...n })
})(uE || (uE = {}))
const Ae = St.arrayToEnum([
    'string',
    'nan',
    'number',
    'integer',
    'float',
    'boolean',
    'date',
    'bigint',
    'symbol',
    'function',
    'undefined',
    'null',
    'array',
    'object',
    'unknown',
    'promise',
    'void',
    'never',
    'map',
    'set'
  ]),
  _o = t => {
    switch (typeof t) {
      case 'undefined':
        return Ae.undefined
      case 'string':
        return Ae.string
      case 'number':
        return isNaN(t) ? Ae.nan : Ae.number
      case 'boolean':
        return Ae.boolean
      case 'function':
        return Ae.function
      case 'bigint':
        return Ae.bigint
      case 'symbol':
        return Ae.symbol
      case 'object':
        return Array.isArray(t)
          ? Ae.array
          : t === null
            ? Ae.null
            : t.then && typeof t.then == 'function' && t.catch && typeof t.catch == 'function'
              ? Ae.promise
              : typeof Map < 'u' && t instanceof Map
                ? Ae.map
                : typeof Set < 'u' && t instanceof Set
                  ? Ae.set
                  : typeof Date < 'u' && t instanceof Date
                    ? Ae.date
                    : Ae.object
      default:
        return Ae.unknown
    }
  },
  pe = St.arrayToEnum([
    'invalid_type',
    'invalid_literal',
    'custom',
    'invalid_union',
    'invalid_union_discriminator',
    'invalid_enum_value',
    'unrecognized_keys',
    'invalid_arguments',
    'invalid_return_type',
    'invalid_date',
    'invalid_string',
    'too_small',
    'too_big',
    'invalid_intersection_types',
    'not_multiple_of',
    'not_finite'
  ]),
  PX = t => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, '$1:')
class ds extends Error {
  constructor(e) {
    super(),
      (this.issues = []),
      (this.addIssue = r => {
        this.issues = [...this.issues, r]
      }),
      (this.addIssues = (r = []) => {
        this.issues = [...this.issues, ...r]
      })
    const n = new.target.prototype
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : (this.__proto__ = n),
      (this.name = 'ZodError'),
      (this.issues = e)
  }
  get errors() {
    return this.issues
  }
  format(e) {
    const n =
        e ||
        function (s) {
          return s.message
        },
      r = { _errors: [] },
      i = s => {
        for (const c of s.issues)
          if (c.code === 'invalid_union') c.unionErrors.map(i)
          else if (c.code === 'invalid_return_type') i(c.returnTypeError)
          else if (c.code === 'invalid_arguments') i(c.argumentsError)
          else if (c.path.length === 0) r._errors.push(n(c))
          else {
            let u = r,
              f = 0
            for (; f < c.path.length; ) {
              const d = c.path[f]
              f === c.path.length - 1
                ? ((u[d] = u[d] || { _errors: [] }), u[d]._errors.push(n(c)))
                : (u[d] = u[d] || { _errors: [] }),
                (u = u[d]),
                f++
            }
          }
      }
    return i(this), r
  }
  toString() {
    return this.message
  }
  get message() {
    return JSON.stringify(this.issues, St.jsonStringifyReplacer, 2)
  }
  get isEmpty() {
    return this.issues.length === 0
  }
  flatten(e = n => n.message) {
    const n = {},
      r = []
    for (const i of this.issues)
      i.path.length > 0
        ? ((n[i.path[0]] = n[i.path[0]] || []), n[i.path[0]].push(e(i)))
        : r.push(e(i))
    return { formErrors: r, fieldErrors: n }
  }
  get formErrors() {
    return this.flatten()
  }
}
ds.create = t => new ds(t)
const Lh = (t, e) => {
  let n
  switch (t.code) {
    case pe.invalid_type:
      t.received === Ae.undefined
        ? (n = 'Required')
        : (n = `Expected ${t.expected}, received ${t.received}`)
      break
    case pe.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected, St.jsonStringifyReplacer)}`
      break
    case pe.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${St.joinValues(t.keys, ', ')}`
      break
    case pe.invalid_union:
      n = 'Invalid input'
      break
    case pe.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${St.joinValues(t.options)}`
      break
    case pe.invalid_enum_value:
      n = `Invalid enum value. Expected ${St.joinValues(t.options)}, received '${t.received}'`
      break
    case pe.invalid_arguments:
      n = 'Invalid function arguments'
      break
    case pe.invalid_return_type:
      n = 'Invalid function return type'
      break
    case pe.invalid_date:
      n = 'Invalid date'
      break
    case pe.invalid_string:
      typeof t.validation == 'object'
        ? 'includes' in t.validation
          ? ((n = `Invalid input: must include "${t.validation.includes}"`),
            typeof t.validation.position == 'number' &&
              (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`))
          : 'startsWith' in t.validation
            ? (n = `Invalid input: must start with "${t.validation.startsWith}"`)
            : 'endsWith' in t.validation
              ? (n = `Invalid input: must end with "${t.validation.endsWith}"`)
              : St.assertNever(t.validation)
        : t.validation !== 'regex'
          ? (n = `Invalid ${t.validation}`)
          : (n = 'Invalid')
      break
    case pe.too_small:
      t.type === 'array'
        ? (n = `Array must contain ${t.exact ? 'exactly' : t.inclusive ? 'at least' : 'more than'} ${t.minimum} element(s)`)
        : t.type === 'string'
          ? (n = `String must contain ${t.exact ? 'exactly' : t.inclusive ? 'at least' : 'over'} ${t.minimum} character(s)`)
          : t.type === 'number'
            ? (n = `Number must be ${t.exact ? 'exactly equal to ' : t.inclusive ? 'greater than or equal to ' : 'greater than '}${t.minimum}`)
            : t.type === 'date'
              ? (n = `Date must be ${t.exact ? 'exactly equal to ' : t.inclusive ? 'greater than or equal to ' : 'greater than '}${new Date(Number(t.minimum))}`)
              : (n = 'Invalid input')
      break
    case pe.too_big:
      t.type === 'array'
        ? (n = `Array must contain ${t.exact ? 'exactly' : t.inclusive ? 'at most' : 'less than'} ${t.maximum} element(s)`)
        : t.type === 'string'
          ? (n = `String must contain ${t.exact ? 'exactly' : t.inclusive ? 'at most' : 'under'} ${t.maximum} character(s)`)
          : t.type === 'number'
            ? (n = `Number must be ${t.exact ? 'exactly' : t.inclusive ? 'less than or equal to' : 'less than'} ${t.maximum}`)
            : t.type === 'bigint'
              ? (n = `BigInt must be ${t.exact ? 'exactly' : t.inclusive ? 'less than or equal to' : 'less than'} ${t.maximum}`)
              : t.type === 'date'
                ? (n = `Date must be ${t.exact ? 'exactly' : t.inclusive ? 'smaller than or equal to' : 'smaller than'} ${new Date(Number(t.maximum))}`)
                : (n = 'Invalid input')
      break
    case pe.custom:
      n = 'Invalid input'
      break
    case pe.invalid_intersection_types:
      n = 'Intersection results could not be merged'
      break
    case pe.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`
      break
    case pe.not_finite:
      n = 'Number must be finite'
      break
    default:
      ;(n = e.defaultError), St.assertNever(t)
  }
  return { message: n }
}
let B9 = Lh
function MX(t) {
  B9 = t
}
function om() {
  return B9
}
const cm = t => {
    const { data: e, path: n, errorMaps: r, issueData: i } = t,
      s = [...n, ...(i.path || [])],
      c = { ...i, path: s }
    let u = ''
    const f = r
      .filter(d => !!d)
      .slice()
      .reverse()
    for (const d of f) u = d(c, { data: e, defaultError: u }).message
    return { ...i, path: s, message: i.message || u }
  },
  kX = []
function xe(t, e) {
  const n = cm({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, om(), Lh].filter(r => !!r)
  })
  t.common.issues.push(n)
}
class Dr {
  constructor() {
    this.value = 'valid'
  }
  dirty() {
    this.value === 'valid' && (this.value = 'dirty')
  }
  abort() {
    this.value !== 'aborted' && (this.value = 'aborted')
  }
  static mergeArray(e, n) {
    const r = []
    for (const i of n) {
      if (i.status === 'aborted') return He
      i.status === 'dirty' && e.dirty(), r.push(i.value)
    }
    return { status: e.value, value: r }
  }
  static async mergeObjectAsync(e, n) {
    const r = []
    for (const i of n) r.push({ key: await i.key, value: await i.value })
    return Dr.mergeObjectSync(e, r)
  }
  static mergeObjectSync(e, n) {
    const r = {}
    for (const i of n) {
      const { key: s, value: c } = i
      if (s.status === 'aborted' || c.status === 'aborted') return He
      s.status === 'dirty' && e.dirty(),
        c.status === 'dirty' && e.dirty(),
        s.value !== '__proto__' && (typeof c.value < 'u' || i.alwaysSet) && (r[s.value] = c.value)
    }
    return { status: e.value, value: r }
  }
}
const He = Object.freeze({ status: 'aborted' }),
  L9 = t => ({ status: 'dirty', value: t }),
  jr = t => ({ status: 'valid', value: t }),
  lE = t => t.status === 'aborted',
  dE = t => t.status === 'dirty',
  $h = t => t.status === 'valid',
  um = t => typeof Promise < 'u' && t instanceof Promise
var Be
;(function (t) {
  ;(t.errToObj = e => (typeof e == 'string' ? { message: e } : e || {})),
    (t.toString = e => (typeof e == 'string' ? e : e == null ? void 0 : e.message))
})(Be || (Be = {}))
class Vs {
  constructor(e, n, r, i) {
    ;(this._cachedPath = []), (this.parent = e), (this.data = n), (this._path = r), (this._key = i)
  }
  get path() {
    return (
      this._cachedPath.length ||
        (this._key instanceof Array
          ? this._cachedPath.push(...this._path, ...this._key)
          : this._cachedPath.push(...this._path, this._key)),
      this._cachedPath
    )
  }
}
const U4 = (t, e) => {
  if ($h(e)) return { success: !0, data: e.value }
  if (!t.common.issues.length) throw new Error('Validation failed but no issues detected.')
  return {
    success: !1,
    get error() {
      if (this._error) return this._error
      const n = new ds(t.common.issues)
      return (this._error = n), this._error
    }
  }
}
function Ve(t) {
  if (!t) return {}
  const { errorMap: e, invalid_type_error: n, required_error: r, description: i } = t
  if (e && (n || r))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
    )
  return e
    ? { errorMap: e, description: i }
    : {
        errorMap: (c, u) =>
          c.code !== 'invalid_type'
            ? { message: u.defaultError }
            : typeof u.data > 'u'
              ? { message: r ?? u.defaultError }
              : { message: n ?? u.defaultError },
        description: i
      }
}
class Xe {
  constructor(e) {
    ;(this.spa = this.safeParseAsync),
      (this._def = e),
      (this.parse = this.parse.bind(this)),
      (this.safeParse = this.safeParse.bind(this)),
      (this.parseAsync = this.parseAsync.bind(this)),
      (this.safeParseAsync = this.safeParseAsync.bind(this)),
      (this.spa = this.spa.bind(this)),
      (this.refine = this.refine.bind(this)),
      (this.refinement = this.refinement.bind(this)),
      (this.superRefine = this.superRefine.bind(this)),
      (this.optional = this.optional.bind(this)),
      (this.nullable = this.nullable.bind(this)),
      (this.nullish = this.nullish.bind(this)),
      (this.array = this.array.bind(this)),
      (this.promise = this.promise.bind(this)),
      (this.or = this.or.bind(this)),
      (this.and = this.and.bind(this)),
      (this.transform = this.transform.bind(this)),
      (this.brand = this.brand.bind(this)),
      (this.default = this.default.bind(this)),
      (this.catch = this.catch.bind(this)),
      (this.describe = this.describe.bind(this)),
      (this.pipe = this.pipe.bind(this)),
      (this.readonly = this.readonly.bind(this)),
      (this.isNullable = this.isNullable.bind(this)),
      (this.isOptional = this.isOptional.bind(this))
  }
  get description() {
    return this._def.description
  }
  _getType(e) {
    return _o(e.data)
  }
  _getOrReturnCtx(e, n) {
    return (
      n || {
        common: e.parent.common,
        data: e.data,
        parsedType: _o(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    )
  }
  _processInputParams(e) {
    return {
      status: new Dr(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: _o(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    }
  }
  _parseSync(e) {
    const n = this._parse(e)
    if (um(n)) throw new Error('Synchronous parse encountered promise.')
    return n
  }
  _parseAsync(e) {
    const n = this._parse(e)
    return Promise.resolve(n)
  }
  parse(e, n) {
    const r = this.safeParse(e, n)
    if (r.success) return r.data
    throw r.error
  }
  safeParse(e, n) {
    var r
    const i = {
        common: {
          issues: [],
          async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
          contextualErrorMap: n == null ? void 0 : n.errorMap
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: _o(e)
      },
      s = this._parseSync({ data: e, path: i.path, parent: i })
    return U4(i, s)
  }
  async parseAsync(e, n) {
    const r = await this.safeParseAsync(e, n)
    if (r.success) return r.data
    throw r.error
  }
  async safeParseAsync(e, n) {
    const r = {
        common: { issues: [], contextualErrorMap: n == null ? void 0 : n.errorMap, async: !0 },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: _o(e)
      },
      i = this._parse({ data: e, path: r.path, parent: r }),
      s = await (um(i) ? i : Promise.resolve(i))
    return U4(r, s)
  }
  refine(e, n) {
    const r = i =>
      typeof n == 'string' || typeof n > 'u' ? { message: n } : typeof n == 'function' ? n(i) : n
    return this._refinement((i, s) => {
      const c = e(i),
        u = () => s.addIssue({ code: pe.custom, ...r(i) })
      return typeof Promise < 'u' && c instanceof Promise
        ? c.then(f => (f ? !0 : (u(), !1)))
        : c
          ? !0
          : (u(), !1)
    })
  }
  refinement(e, n) {
    return this._refinement((r, i) =>
      e(r) ? !0 : (i.addIssue(typeof n == 'function' ? n(r, i) : n), !1)
    )
  }
  _refinement(e) {
    return new hs({
      schema: this,
      typeName: je.ZodEffects,
      effect: { type: 'refinement', refinement: e }
    })
  }
  superRefine(e) {
    return this._refinement(e)
  }
  optional() {
    return Pa.create(this, this._def)
  }
  nullable() {
    return du.create(this, this._def)
  }
  nullish() {
    return this.nullable().optional()
  }
  array() {
    return fs.create(this, this._def)
  }
  promise() {
    return ud.create(this, this._def)
  }
  or(e) {
    return qh.create([this, e], this._def)
  }
  and(e) {
    return Hh.create(this, e, this._def)
  }
  transform(e) {
    return new hs({
      ...Ve(this._def),
      schema: this,
      typeName: je.ZodEffects,
      effect: { type: 'transform', transform: e }
    })
  }
  default(e) {
    const n = typeof e == 'function' ? e : () => e
    return new Qh({ ...Ve(this._def), innerType: this, defaultValue: n, typeName: je.ZodDefault })
  }
  brand() {
    return new F9({ typeName: je.ZodBranded, type: this, ...Ve(this._def) })
  }
  catch(e) {
    const n = typeof e == 'function' ? e : () => e
    return new hm({ ...Ve(this._def), innerType: this, catchValue: n, typeName: je.ZodCatch })
  }
  describe(e) {
    const n = this.constructor
    return new n({ ...this._def, description: e })
  }
  pipe(e) {
    return Op.create(this, e)
  }
  readonly() {
    return gm.create(this)
  }
  isOptional() {
    return this.safeParse(void 0).success
  }
  isNullable() {
    return this.safeParse(null).success
  }
}
const UX = /^c[^\s-]{8,}$/i,
  BX = /^[a-z][a-z0-9]*$/,
  LX = /^[0-9A-HJKMNP-TV-Z]{26}$/,
  $X = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  FX = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  jX = '^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$'
let z1
const zX =
    /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
  qX =
    /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  HX = t =>
    t.precision
      ? t.offset
        ? new RegExp(
            `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
          )
        : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`)
      : t.precision === 0
        ? t.offset
          ? new RegExp('^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$')
          : new RegExp('^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$')
        : t.offset
          ? new RegExp(
              '^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$'
            )
          : new RegExp('^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$')
function GX(t, e) {
  return !!(((e === 'v4' || !e) && zX.test(t)) || ((e === 'v6' || !e) && qX.test(t)))
}
class ls extends Xe {
  _parse(e) {
    if ((this._def.coerce && (e.data = String(e.data)), this._getType(e) !== Ae.string)) {
      const s = this._getOrReturnCtx(e)
      return xe(s, { code: pe.invalid_type, expected: Ae.string, received: s.parsedType }), He
    }
    const r = new Dr()
    let i
    for (const s of this._def.checks)
      if (s.kind === 'min')
        e.data.length < s.value &&
          ((i = this._getOrReturnCtx(e, i)),
          xe(i, {
            code: pe.too_small,
            minimum: s.value,
            type: 'string',
            inclusive: !0,
            exact: !1,
            message: s.message
          }),
          r.dirty())
      else if (s.kind === 'max')
        e.data.length > s.value &&
          ((i = this._getOrReturnCtx(e, i)),
          xe(i, {
            code: pe.too_big,
            maximum: s.value,
            type: 'string',
            inclusive: !0,
            exact: !1,
            message: s.message
          }),
          r.dirty())
      else if (s.kind === 'length') {
        const c = e.data.length > s.value,
          u = e.data.length < s.value
        ;(c || u) &&
          ((i = this._getOrReturnCtx(e, i)),
          c
            ? xe(i, {
                code: pe.too_big,
                maximum: s.value,
                type: 'string',
                inclusive: !0,
                exact: !0,
                message: s.message
              })
            : u &&
              xe(i, {
                code: pe.too_small,
                minimum: s.value,
                type: 'string',
                inclusive: !0,
                exact: !0,
                message: s.message
              }),
          r.dirty())
      } else if (s.kind === 'email')
        FX.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          xe(i, { validation: 'email', code: pe.invalid_string, message: s.message }),
          r.dirty())
      else if (s.kind === 'emoji')
        z1 || (z1 = new RegExp(jX, 'u')),
          z1.test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            xe(i, { validation: 'emoji', code: pe.invalid_string, message: s.message }),
            r.dirty())
      else if (s.kind === 'uuid')
        $X.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          xe(i, { validation: 'uuid', code: pe.invalid_string, message: s.message }),
          r.dirty())
      else if (s.kind === 'cuid')
        UX.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          xe(i, { validation: 'cuid', code: pe.invalid_string, message: s.message }),
          r.dirty())
      else if (s.kind === 'cuid2')
        BX.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          xe(i, { validation: 'cuid2', code: pe.invalid_string, message: s.message }),
          r.dirty())
      else if (s.kind === 'ulid')
        LX.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          xe(i, { validation: 'ulid', code: pe.invalid_string, message: s.message }),
          r.dirty())
      else if (s.kind === 'url')
        try {
          new URL(e.data)
        } catch {
          ;(i = this._getOrReturnCtx(e, i)),
            xe(i, { validation: 'url', code: pe.invalid_string, message: s.message }),
            r.dirty()
        }
      else
        s.kind === 'regex'
          ? ((s.regex.lastIndex = 0),
            s.regex.test(e.data) ||
              ((i = this._getOrReturnCtx(e, i)),
              xe(i, { validation: 'regex', code: pe.invalid_string, message: s.message }),
              r.dirty()))
          : s.kind === 'trim'
            ? (e.data = e.data.trim())
            : s.kind === 'includes'
              ? e.data.includes(s.value, s.position) ||
                ((i = this._getOrReturnCtx(e, i)),
                xe(i, {
                  code: pe.invalid_string,
                  validation: { includes: s.value, position: s.position },
                  message: s.message
                }),
                r.dirty())
              : s.kind === 'toLowerCase'
                ? (e.data = e.data.toLowerCase())
                : s.kind === 'toUpperCase'
                  ? (e.data = e.data.toUpperCase())
                  : s.kind === 'startsWith'
                    ? e.data.startsWith(s.value) ||
                      ((i = this._getOrReturnCtx(e, i)),
                      xe(i, {
                        code: pe.invalid_string,
                        validation: { startsWith: s.value },
                        message: s.message
                      }),
                      r.dirty())
                    : s.kind === 'endsWith'
                      ? e.data.endsWith(s.value) ||
                        ((i = this._getOrReturnCtx(e, i)),
                        xe(i, {
                          code: pe.invalid_string,
                          validation: { endsWith: s.value },
                          message: s.message
                        }),
                        r.dirty())
                      : s.kind === 'datetime'
                        ? HX(s).test(e.data) ||
                          ((i = this._getOrReturnCtx(e, i)),
                          xe(i, {
                            code: pe.invalid_string,
                            validation: 'datetime',
                            message: s.message
                          }),
                          r.dirty())
                        : s.kind === 'ip'
                          ? GX(e.data, s.version) ||
                            ((i = this._getOrReturnCtx(e, i)),
                            xe(i, {
                              validation: 'ip',
                              code: pe.invalid_string,
                              message: s.message
                            }),
                            r.dirty())
                          : St.assertNever(s)
    return { status: r.value, value: e.data }
  }
  _regex(e, n, r) {
    return this.refinement(i => e.test(i), {
      validation: n,
      code: pe.invalid_string,
      ...Be.errToObj(r)
    })
  }
  _addCheck(e) {
    return new ls({ ...this._def, checks: [...this._def.checks, e] })
  }
  email(e) {
    return this._addCheck({ kind: 'email', ...Be.errToObj(e) })
  }
  url(e) {
    return this._addCheck({ kind: 'url', ...Be.errToObj(e) })
  }
  emoji(e) {
    return this._addCheck({ kind: 'emoji', ...Be.errToObj(e) })
  }
  uuid(e) {
    return this._addCheck({ kind: 'uuid', ...Be.errToObj(e) })
  }
  cuid(e) {
    return this._addCheck({ kind: 'cuid', ...Be.errToObj(e) })
  }
  cuid2(e) {
    return this._addCheck({ kind: 'cuid2', ...Be.errToObj(e) })
  }
  ulid(e) {
    return this._addCheck({ kind: 'ulid', ...Be.errToObj(e) })
  }
  ip(e) {
    return this._addCheck({ kind: 'ip', ...Be.errToObj(e) })
  }
  datetime(e) {
    var n
    return typeof e == 'string'
      ? this._addCheck({ kind: 'datetime', precision: null, offset: !1, message: e })
      : this._addCheck({
          kind: 'datetime',
          precision:
            typeof (e == null ? void 0 : e.precision) > 'u'
              ? null
              : e == null
                ? void 0
                : e.precision,
          offset: (n = e == null ? void 0 : e.offset) !== null && n !== void 0 ? n : !1,
          ...Be.errToObj(e == null ? void 0 : e.message)
        })
  }
  regex(e, n) {
    return this._addCheck({ kind: 'regex', regex: e, ...Be.errToObj(n) })
  }
  includes(e, n) {
    return this._addCheck({
      kind: 'includes',
      value: e,
      position: n == null ? void 0 : n.position,
      ...Be.errToObj(n == null ? void 0 : n.message)
    })
  }
  startsWith(e, n) {
    return this._addCheck({ kind: 'startsWith', value: e, ...Be.errToObj(n) })
  }
  endsWith(e, n) {
    return this._addCheck({ kind: 'endsWith', value: e, ...Be.errToObj(n) })
  }
  min(e, n) {
    return this._addCheck({ kind: 'min', value: e, ...Be.errToObj(n) })
  }
  max(e, n) {
    return this._addCheck({ kind: 'max', value: e, ...Be.errToObj(n) })
  }
  length(e, n) {
    return this._addCheck({ kind: 'length', value: e, ...Be.errToObj(n) })
  }
  nonempty(e) {
    return this.min(1, Be.errToObj(e))
  }
  trim() {
    return new ls({ ...this._def, checks: [...this._def.checks, { kind: 'trim' }] })
  }
  toLowerCase() {
    return new ls({ ...this._def, checks: [...this._def.checks, { kind: 'toLowerCase' }] })
  }
  toUpperCase() {
    return new ls({ ...this._def, checks: [...this._def.checks, { kind: 'toUpperCase' }] })
  }
  get isDatetime() {
    return !!this._def.checks.find(e => e.kind === 'datetime')
  }
  get isEmail() {
    return !!this._def.checks.find(e => e.kind === 'email')
  }
  get isURL() {
    return !!this._def.checks.find(e => e.kind === 'url')
  }
  get isEmoji() {
    return !!this._def.checks.find(e => e.kind === 'emoji')
  }
  get isUUID() {
    return !!this._def.checks.find(e => e.kind === 'uuid')
  }
  get isCUID() {
    return !!this._def.checks.find(e => e.kind === 'cuid')
  }
  get isCUID2() {
    return !!this._def.checks.find(e => e.kind === 'cuid2')
  }
  get isULID() {
    return !!this._def.checks.find(e => e.kind === 'ulid')
  }
  get isIP() {
    return !!this._def.checks.find(e => e.kind === 'ip')
  }
  get minLength() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'min' && (e === null || n.value > e) && (e = n.value)
    return e
  }
  get maxLength() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'max' && (e === null || n.value < e) && (e = n.value)
    return e
  }
}
ls.create = t => {
  var e
  return new ls({
    checks: [],
    typeName: je.ZodString,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...Ve(t)
  })
}
function VX(t, e) {
  const n = (t.toString().split('.')[1] || '').length,
    r = (e.toString().split('.')[1] || '').length,
    i = n > r ? n : r,
    s = parseInt(t.toFixed(i).replace('.', '')),
    c = parseInt(e.toFixed(i).replace('.', ''))
  return (s % c) / Math.pow(10, i)
}
class Ko extends Xe {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte), (this.step = this.multipleOf)
  }
  _parse(e) {
    if ((this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== Ae.number)) {
      const s = this._getOrReturnCtx(e)
      return xe(s, { code: pe.invalid_type, expected: Ae.number, received: s.parsedType }), He
    }
    let r
    const i = new Dr()
    for (const s of this._def.checks)
      s.kind === 'int'
        ? St.isInteger(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          xe(r, {
            code: pe.invalid_type,
            expected: 'integer',
            received: 'float',
            message: s.message
          }),
          i.dirty())
        : s.kind === 'min'
          ? (s.inclusive ? e.data < s.value : e.data <= s.value) &&
            ((r = this._getOrReturnCtx(e, r)),
            xe(r, {
              code: pe.too_small,
              minimum: s.value,
              type: 'number',
              inclusive: s.inclusive,
              exact: !1,
              message: s.message
            }),
            i.dirty())
          : s.kind === 'max'
            ? (s.inclusive ? e.data > s.value : e.data >= s.value) &&
              ((r = this._getOrReturnCtx(e, r)),
              xe(r, {
                code: pe.too_big,
                maximum: s.value,
                type: 'number',
                inclusive: s.inclusive,
                exact: !1,
                message: s.message
              }),
              i.dirty())
            : s.kind === 'multipleOf'
              ? VX(e.data, s.value) !== 0 &&
                ((r = this._getOrReturnCtx(e, r)),
                xe(r, { code: pe.not_multiple_of, multipleOf: s.value, message: s.message }),
                i.dirty())
              : s.kind === 'finite'
                ? Number.isFinite(e.data) ||
                  ((r = this._getOrReturnCtx(e, r)),
                  xe(r, { code: pe.not_finite, message: s.message }),
                  i.dirty())
                : St.assertNever(s)
    return { status: i.value, value: e.data }
  }
  gte(e, n) {
    return this.setLimit('min', e, !0, Be.toString(n))
  }
  gt(e, n) {
    return this.setLimit('min', e, !1, Be.toString(n))
  }
  lte(e, n) {
    return this.setLimit('max', e, !0, Be.toString(n))
  }
  lt(e, n) {
    return this.setLimit('max', e, !1, Be.toString(n))
  }
  setLimit(e, n, r, i) {
    return new Ko({
      ...this._def,
      checks: [...this._def.checks, { kind: e, value: n, inclusive: r, message: Be.toString(i) }]
    })
  }
  _addCheck(e) {
    return new Ko({ ...this._def, checks: [...this._def.checks, e] })
  }
  int(e) {
    return this._addCheck({ kind: 'int', message: Be.toString(e) })
  }
  positive(e) {
    return this._addCheck({ kind: 'min', value: 0, inclusive: !1, message: Be.toString(e) })
  }
  negative(e) {
    return this._addCheck({ kind: 'max', value: 0, inclusive: !1, message: Be.toString(e) })
  }
  nonpositive(e) {
    return this._addCheck({ kind: 'max', value: 0, inclusive: !0, message: Be.toString(e) })
  }
  nonnegative(e) {
    return this._addCheck({ kind: 'min', value: 0, inclusive: !0, message: Be.toString(e) })
  }
  multipleOf(e, n) {
    return this._addCheck({ kind: 'multipleOf', value: e, message: Be.toString(n) })
  }
  finite(e) {
    return this._addCheck({ kind: 'finite', message: Be.toString(e) })
  }
  safe(e) {
    return this._addCheck({
      kind: 'min',
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Be.toString(e)
    })._addCheck({
      kind: 'max',
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Be.toString(e)
    })
  }
  get minValue() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'min' && (e === null || n.value > e) && (e = n.value)
    return e
  }
  get maxValue() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'max' && (e === null || n.value < e) && (e = n.value)
    return e
  }
  get isInt() {
    return !!this._def.checks.find(
      e => e.kind === 'int' || (e.kind === 'multipleOf' && St.isInteger(e.value))
    )
  }
  get isFinite() {
    let e = null,
      n = null
    for (const r of this._def.checks) {
      if (r.kind === 'finite' || r.kind === 'int' || r.kind === 'multipleOf') return !0
      r.kind === 'min'
        ? (n === null || r.value > n) && (n = r.value)
        : r.kind === 'max' && (e === null || r.value < e) && (e = r.value)
    }
    return Number.isFinite(n) && Number.isFinite(e)
  }
}
Ko.create = t =>
  new Ko({
    checks: [],
    typeName: je.ZodNumber,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...Ve(t)
  })
class Wo extends Xe {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte)
  }
  _parse(e) {
    if ((this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== Ae.bigint)) {
      const s = this._getOrReturnCtx(e)
      return xe(s, { code: pe.invalid_type, expected: Ae.bigint, received: s.parsedType }), He
    }
    let r
    const i = new Dr()
    for (const s of this._def.checks)
      s.kind === 'min'
        ? (s.inclusive ? e.data < s.value : e.data <= s.value) &&
          ((r = this._getOrReturnCtx(e, r)),
          xe(r, {
            code: pe.too_small,
            type: 'bigint',
            minimum: s.value,
            inclusive: s.inclusive,
            message: s.message
          }),
          i.dirty())
        : s.kind === 'max'
          ? (s.inclusive ? e.data > s.value : e.data >= s.value) &&
            ((r = this._getOrReturnCtx(e, r)),
            xe(r, {
              code: pe.too_big,
              type: 'bigint',
              maximum: s.value,
              inclusive: s.inclusive,
              message: s.message
            }),
            i.dirty())
          : s.kind === 'multipleOf'
            ? e.data % s.value !== BigInt(0) &&
              ((r = this._getOrReturnCtx(e, r)),
              xe(r, { code: pe.not_multiple_of, multipleOf: s.value, message: s.message }),
              i.dirty())
            : St.assertNever(s)
    return { status: i.value, value: e.data }
  }
  gte(e, n) {
    return this.setLimit('min', e, !0, Be.toString(n))
  }
  gt(e, n) {
    return this.setLimit('min', e, !1, Be.toString(n))
  }
  lte(e, n) {
    return this.setLimit('max', e, !0, Be.toString(n))
  }
  lt(e, n) {
    return this.setLimit('max', e, !1, Be.toString(n))
  }
  setLimit(e, n, r, i) {
    return new Wo({
      ...this._def,
      checks: [...this._def.checks, { kind: e, value: n, inclusive: r, message: Be.toString(i) }]
    })
  }
  _addCheck(e) {
    return new Wo({ ...this._def, checks: [...this._def.checks, e] })
  }
  positive(e) {
    return this._addCheck({ kind: 'min', value: BigInt(0), inclusive: !1, message: Be.toString(e) })
  }
  negative(e) {
    return this._addCheck({ kind: 'max', value: BigInt(0), inclusive: !1, message: Be.toString(e) })
  }
  nonpositive(e) {
    return this._addCheck({ kind: 'max', value: BigInt(0), inclusive: !0, message: Be.toString(e) })
  }
  nonnegative(e) {
    return this._addCheck({ kind: 'min', value: BigInt(0), inclusive: !0, message: Be.toString(e) })
  }
  multipleOf(e, n) {
    return this._addCheck({ kind: 'multipleOf', value: e, message: Be.toString(n) })
  }
  get minValue() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'min' && (e === null || n.value > e) && (e = n.value)
    return e
  }
  get maxValue() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'max' && (e === null || n.value < e) && (e = n.value)
    return e
  }
}
Wo.create = t => {
  var e
  return new Wo({
    checks: [],
    typeName: je.ZodBigInt,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...Ve(t)
  })
}
class Fh extends Xe {
  _parse(e) {
    if ((this._def.coerce && (e.data = !!e.data), this._getType(e) !== Ae.boolean)) {
      const r = this._getOrReturnCtx(e)
      return xe(r, { code: pe.invalid_type, expected: Ae.boolean, received: r.parsedType }), He
    }
    return jr(e.data)
  }
}
Fh.create = t =>
  new Fh({ typeName: je.ZodBoolean, coerce: (t == null ? void 0 : t.coerce) || !1, ...Ve(t) })
class uu extends Xe {
  _parse(e) {
    if ((this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== Ae.date)) {
      const s = this._getOrReturnCtx(e)
      return xe(s, { code: pe.invalid_type, expected: Ae.date, received: s.parsedType }), He
    }
    if (isNaN(e.data.getTime())) {
      const s = this._getOrReturnCtx(e)
      return xe(s, { code: pe.invalid_date }), He
    }
    const r = new Dr()
    let i
    for (const s of this._def.checks)
      s.kind === 'min'
        ? e.data.getTime() < s.value &&
          ((i = this._getOrReturnCtx(e, i)),
          xe(i, {
            code: pe.too_small,
            message: s.message,
            inclusive: !0,
            exact: !1,
            minimum: s.value,
            type: 'date'
          }),
          r.dirty())
        : s.kind === 'max'
          ? e.data.getTime() > s.value &&
            ((i = this._getOrReturnCtx(e, i)),
            xe(i, {
              code: pe.too_big,
              message: s.message,
              inclusive: !0,
              exact: !1,
              maximum: s.value,
              type: 'date'
            }),
            r.dirty())
          : St.assertNever(s)
    return { status: r.value, value: new Date(e.data.getTime()) }
  }
  _addCheck(e) {
    return new uu({ ...this._def, checks: [...this._def.checks, e] })
  }
  min(e, n) {
    return this._addCheck({ kind: 'min', value: e.getTime(), message: Be.toString(n) })
  }
  max(e, n) {
    return this._addCheck({ kind: 'max', value: e.getTime(), message: Be.toString(n) })
  }
  get minDate() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'min' && (e === null || n.value > e) && (e = n.value)
    return e != null ? new Date(e) : null
  }
  get maxDate() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'max' && (e === null || n.value < e) && (e = n.value)
    return e != null ? new Date(e) : null
  }
}
uu.create = t =>
  new uu({
    checks: [],
    coerce: (t == null ? void 0 : t.coerce) || !1,
    typeName: je.ZodDate,
    ...Ve(t)
  })
class lm extends Xe {
  _parse(e) {
    if (this._getType(e) !== Ae.symbol) {
      const r = this._getOrReturnCtx(e)
      return xe(r, { code: pe.invalid_type, expected: Ae.symbol, received: r.parsedType }), He
    }
    return jr(e.data)
  }
}
lm.create = t => new lm({ typeName: je.ZodSymbol, ...Ve(t) })
class jh extends Xe {
  _parse(e) {
    if (this._getType(e) !== Ae.undefined) {
      const r = this._getOrReturnCtx(e)
      return xe(r, { code: pe.invalid_type, expected: Ae.undefined, received: r.parsedType }), He
    }
    return jr(e.data)
  }
}
jh.create = t => new jh({ typeName: je.ZodUndefined, ...Ve(t) })
class zh extends Xe {
  _parse(e) {
    if (this._getType(e) !== Ae.null) {
      const r = this._getOrReturnCtx(e)
      return xe(r, { code: pe.invalid_type, expected: Ae.null, received: r.parsedType }), He
    }
    return jr(e.data)
  }
}
zh.create = t => new zh({ typeName: je.ZodNull, ...Ve(t) })
class cd extends Xe {
  constructor() {
    super(...arguments), (this._any = !0)
  }
  _parse(e) {
    return jr(e.data)
  }
}
cd.create = t => new cd({ typeName: je.ZodAny, ...Ve(t) })
class Qc extends Xe {
  constructor() {
    super(...arguments), (this._unknown = !0)
  }
  _parse(e) {
    return jr(e.data)
  }
}
Qc.create = t => new Qc({ typeName: je.ZodUnknown, ...Ve(t) })
class La extends Xe {
  _parse(e) {
    const n = this._getOrReturnCtx(e)
    return xe(n, { code: pe.invalid_type, expected: Ae.never, received: n.parsedType }), He
  }
}
La.create = t => new La({ typeName: je.ZodNever, ...Ve(t) })
class dm extends Xe {
  _parse(e) {
    if (this._getType(e) !== Ae.undefined) {
      const r = this._getOrReturnCtx(e)
      return xe(r, { code: pe.invalid_type, expected: Ae.void, received: r.parsedType }), He
    }
    return jr(e.data)
  }
}
dm.create = t => new dm({ typeName: je.ZodVoid, ...Ve(t) })
class fs extends Xe {
  _parse(e) {
    const { ctx: n, status: r } = this._processInputParams(e),
      i = this._def
    if (n.parsedType !== Ae.array)
      return xe(n, { code: pe.invalid_type, expected: Ae.array, received: n.parsedType }), He
    if (i.exactLength !== null) {
      const c = n.data.length > i.exactLength.value,
        u = n.data.length < i.exactLength.value
      ;(c || u) &&
        (xe(n, {
          code: c ? pe.too_big : pe.too_small,
          minimum: u ? i.exactLength.value : void 0,
          maximum: c ? i.exactLength.value : void 0,
          type: 'array',
          inclusive: !0,
          exact: !0,
          message: i.exactLength.message
        }),
        r.dirty())
    }
    if (
      (i.minLength !== null &&
        n.data.length < i.minLength.value &&
        (xe(n, {
          code: pe.too_small,
          minimum: i.minLength.value,
          type: 'array',
          inclusive: !0,
          exact: !1,
          message: i.minLength.message
        }),
        r.dirty()),
      i.maxLength !== null &&
        n.data.length > i.maxLength.value &&
        (xe(n, {
          code: pe.too_big,
          maximum: i.maxLength.value,
          type: 'array',
          inclusive: !0,
          exact: !1,
          message: i.maxLength.message
        }),
        r.dirty()),
      n.common.async)
    )
      return Promise.all(
        [...n.data].map((c, u) => i.type._parseAsync(new Vs(n, c, n.path, u)))
      ).then(c => Dr.mergeArray(r, c))
    const s = [...n.data].map((c, u) => i.type._parseSync(new Vs(n, c, n.path, u)))
    return Dr.mergeArray(r, s)
  }
  get element() {
    return this._def.type
  }
  min(e, n) {
    return new fs({ ...this._def, minLength: { value: e, message: Be.toString(n) } })
  }
  max(e, n) {
    return new fs({ ...this._def, maxLength: { value: e, message: Be.toString(n) } })
  }
  length(e, n) {
    return new fs({ ...this._def, exactLength: { value: e, message: Be.toString(n) } })
  }
  nonempty(e) {
    return this.min(1, e)
  }
}
fs.create = (t, e) =>
  new fs({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: je.ZodArray,
    ...Ve(e)
  })
function Nl(t) {
  if (t instanceof Sn) {
    const e = {}
    for (const n in t.shape) {
      const r = t.shape[n]
      e[n] = Pa.create(Nl(r))
    }
    return new Sn({ ...t._def, shape: () => e })
  } else
    return t instanceof fs
      ? new fs({ ...t._def, type: Nl(t.element) })
      : t instanceof Pa
        ? Pa.create(Nl(t.unwrap()))
        : t instanceof du
          ? du.create(Nl(t.unwrap()))
          : t instanceof Ks
            ? Ks.create(t.items.map(e => Nl(e)))
            : t
}
class Sn extends Xe {
  constructor() {
    super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend)
  }
  _getCached() {
    if (this._cached !== null) return this._cached
    const e = this._def.shape(),
      n = St.objectKeys(e)
    return (this._cached = { shape: e, keys: n })
  }
  _parse(e) {
    if (this._getType(e) !== Ae.object) {
      const d = this._getOrReturnCtx(e)
      return xe(d, { code: pe.invalid_type, expected: Ae.object, received: d.parsedType }), He
    }
    const { status: r, ctx: i } = this._processInputParams(e),
      { shape: s, keys: c } = this._getCached(),
      u = []
    if (!(this._def.catchall instanceof La && this._def.unknownKeys === 'strip'))
      for (const d in i.data) c.includes(d) || u.push(d)
    const f = []
    for (const d of c) {
      const p = s[d],
        g = i.data[d]
      f.push({
        key: { status: 'valid', value: d },
        value: p._parse(new Vs(i, g, i.path, d)),
        alwaysSet: d in i.data
      })
    }
    if (this._def.catchall instanceof La) {
      const d = this._def.unknownKeys
      if (d === 'passthrough')
        for (const p of u)
          f.push({
            key: { status: 'valid', value: p },
            value: { status: 'valid', value: i.data[p] }
          })
      else if (d === 'strict')
        u.length > 0 && (xe(i, { code: pe.unrecognized_keys, keys: u }), r.dirty())
      else if (d !== 'strip')
        throw new Error('Internal ZodObject error: invalid unknownKeys value.')
    } else {
      const d = this._def.catchall
      for (const p of u) {
        const g = i.data[p]
        f.push({
          key: { status: 'valid', value: p },
          value: d._parse(new Vs(i, g, i.path, p)),
          alwaysSet: p in i.data
        })
      }
    }
    return i.common.async
      ? Promise.resolve()
          .then(async () => {
            const d = []
            for (const p of f) {
              const g = await p.key
              d.push({ key: g, value: await p.value, alwaysSet: p.alwaysSet })
            }
            return d
          })
          .then(d => Dr.mergeObjectSync(r, d))
      : Dr.mergeObjectSync(r, f)
  }
  get shape() {
    return this._def.shape()
  }
  strict(e) {
    return (
      Be.errToObj,
      new Sn({
        ...this._def,
        unknownKeys: 'strict',
        ...(e !== void 0
          ? {
              errorMap: (n, r) => {
                var i, s, c, u
                const f =
                  (c =
                    (s = (i = this._def).errorMap) === null || s === void 0
                      ? void 0
                      : s.call(i, n, r).message) !== null && c !== void 0
                    ? c
                    : r.defaultError
                return n.code === 'unrecognized_keys'
                  ? { message: (u = Be.errToObj(e).message) !== null && u !== void 0 ? u : f }
                  : { message: f }
              }
            }
          : {})
      })
    )
  }
  strip() {
    return new Sn({ ...this._def, unknownKeys: 'strip' })
  }
  passthrough() {
    return new Sn({ ...this._def, unknownKeys: 'passthrough' })
  }
  extend(e) {
    return new Sn({ ...this._def, shape: () => ({ ...this._def.shape(), ...e }) })
  }
  merge(e) {
    return new Sn({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
      typeName: je.ZodObject
    })
  }
  setKey(e, n) {
    return this.augment({ [e]: n })
  }
  catchall(e) {
    return new Sn({ ...this._def, catchall: e })
  }
  pick(e) {
    const n = {}
    return (
      St.objectKeys(e).forEach(r => {
        e[r] && this.shape[r] && (n[r] = this.shape[r])
      }),
      new Sn({ ...this._def, shape: () => n })
    )
  }
  omit(e) {
    const n = {}
    return (
      St.objectKeys(this.shape).forEach(r => {
        e[r] || (n[r] = this.shape[r])
      }),
      new Sn({ ...this._def, shape: () => n })
    )
  }
  deepPartial() {
    return Nl(this)
  }
  partial(e) {
    const n = {}
    return (
      St.objectKeys(this.shape).forEach(r => {
        const i = this.shape[r]
        e && !e[r] ? (n[r] = i) : (n[r] = i.optional())
      }),
      new Sn({ ...this._def, shape: () => n })
    )
  }
  required(e) {
    const n = {}
    return (
      St.objectKeys(this.shape).forEach(r => {
        if (e && !e[r]) n[r] = this.shape[r]
        else {
          let s = this.shape[r]
          for (; s instanceof Pa; ) s = s._def.innerType
          n[r] = s
        }
      }),
      new Sn({ ...this._def, shape: () => n })
    )
  }
  keyof() {
    return $9(St.objectKeys(this.shape))
  }
}
Sn.create = (t, e) =>
  new Sn({
    shape: () => t,
    unknownKeys: 'strip',
    catchall: La.create(),
    typeName: je.ZodObject,
    ...Ve(e)
  })
Sn.strictCreate = (t, e) =>
  new Sn({
    shape: () => t,
    unknownKeys: 'strict',
    catchall: La.create(),
    typeName: je.ZodObject,
    ...Ve(e)
  })
Sn.lazycreate = (t, e) =>
  new Sn({
    shape: t,
    unknownKeys: 'strip',
    catchall: La.create(),
    typeName: je.ZodObject,
    ...Ve(e)
  })
class qh extends Xe {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e),
      r = this._def.options
    function i(s) {
      for (const u of s) if (u.result.status === 'valid') return u.result
      for (const u of s)
        if (u.result.status === 'dirty')
          return n.common.issues.push(...u.ctx.common.issues), u.result
      const c = s.map(u => new ds(u.ctx.common.issues))
      return xe(n, { code: pe.invalid_union, unionErrors: c }), He
    }
    if (n.common.async)
      return Promise.all(
        r.map(async s => {
          const c = { ...n, common: { ...n.common, issues: [] }, parent: null }
          return { result: await s._parseAsync({ data: n.data, path: n.path, parent: c }), ctx: c }
        })
      ).then(i)
    {
      let s
      const c = []
      for (const f of r) {
        const d = { ...n, common: { ...n.common, issues: [] }, parent: null },
          p = f._parseSync({ data: n.data, path: n.path, parent: d })
        if (p.status === 'valid') return p
        p.status === 'dirty' && !s && (s = { result: p, ctx: d }),
          d.common.issues.length && c.push(d.common.issues)
      }
      if (s) return n.common.issues.push(...s.ctx.common.issues), s.result
      const u = c.map(f => new ds(f))
      return xe(n, { code: pe.invalid_union, unionErrors: u }), He
    }
  }
  get options() {
    return this._def.options
  }
}
qh.create = (t, e) => new qh({ options: t, typeName: je.ZodUnion, ...Ve(e) })
const Mg = t =>
  t instanceof Vh
    ? Mg(t.schema)
    : t instanceof hs
      ? Mg(t.innerType())
      : t instanceof Kh
        ? [t.value]
        : t instanceof Qo
          ? t.options
          : t instanceof Wh
            ? Object.keys(t.enum)
            : t instanceof Qh
              ? Mg(t._def.innerType)
              : t instanceof jh
                ? [void 0]
                : t instanceof zh
                  ? [null]
                  : null
class Zm extends Xe {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e)
    if (n.parsedType !== Ae.object)
      return xe(n, { code: pe.invalid_type, expected: Ae.object, received: n.parsedType }), He
    const r = this.discriminator,
      i = n.data[r],
      s = this.optionsMap.get(i)
    return s
      ? n.common.async
        ? s._parseAsync({ data: n.data, path: n.path, parent: n })
        : s._parseSync({ data: n.data, path: n.path, parent: n })
      : (xe(n, {
          code: pe.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [r]
        }),
        He)
  }
  get discriminator() {
    return this._def.discriminator
  }
  get options() {
    return this._def.options
  }
  get optionsMap() {
    return this._def.optionsMap
  }
  static create(e, n, r) {
    const i = new Map()
    for (const s of n) {
      const c = Mg(s.shape[e])
      if (!c)
        throw new Error(
          `A discriminator value for key \`${e}\` could not be extracted from all schema options`
        )
      for (const u of c) {
        if (i.has(u))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(u)}`)
        i.set(u, s)
      }
    }
    return new Zm({
      typeName: je.ZodDiscriminatedUnion,
      discriminator: e,
      options: n,
      optionsMap: i,
      ...Ve(r)
    })
  }
}
function fE(t, e) {
  const n = _o(t),
    r = _o(e)
  if (t === e) return { valid: !0, data: t }
  if (n === Ae.object && r === Ae.object) {
    const i = St.objectKeys(e),
      s = St.objectKeys(t).filter(u => i.indexOf(u) !== -1),
      c = { ...t, ...e }
    for (const u of s) {
      const f = fE(t[u], e[u])
      if (!f.valid) return { valid: !1 }
      c[u] = f.data
    }
    return { valid: !0, data: c }
  } else if (n === Ae.array && r === Ae.array) {
    if (t.length !== e.length) return { valid: !1 }
    const i = []
    for (let s = 0; s < t.length; s++) {
      const c = t[s],
        u = e[s],
        f = fE(c, u)
      if (!f.valid) return { valid: !1 }
      i.push(f.data)
    }
    return { valid: !0, data: i }
  } else return n === Ae.date && r === Ae.date && +t == +e ? { valid: !0, data: t } : { valid: !1 }
}
class Hh extends Xe {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e),
      i = (s, c) => {
        if (lE(s) || lE(c)) return He
        const u = fE(s.value, c.value)
        return u.valid
          ? ((dE(s) || dE(c)) && n.dirty(), { status: n.value, value: u.data })
          : (xe(r, { code: pe.invalid_intersection_types }), He)
      }
    return r.common.async
      ? Promise.all([
          this._def.left._parseAsync({ data: r.data, path: r.path, parent: r }),
          this._def.right._parseAsync({ data: r.data, path: r.path, parent: r })
        ]).then(([s, c]) => i(s, c))
      : i(
          this._def.left._parseSync({ data: r.data, path: r.path, parent: r }),
          this._def.right._parseSync({ data: r.data, path: r.path, parent: r })
        )
  }
}
Hh.create = (t, e, n) => new Hh({ left: t, right: e, typeName: je.ZodIntersection, ...Ve(n) })
class Ks extends Xe {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e)
    if (r.parsedType !== Ae.array)
      return xe(r, { code: pe.invalid_type, expected: Ae.array, received: r.parsedType }), He
    if (r.data.length < this._def.items.length)
      return (
        xe(r, {
          code: pe.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: 'array'
        }),
        He
      )
    !this._def.rest &&
      r.data.length > this._def.items.length &&
      (xe(r, {
        code: pe.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: 'array'
      }),
      n.dirty())
    const s = [...r.data]
      .map((c, u) => {
        const f = this._def.items[u] || this._def.rest
        return f ? f._parse(new Vs(r, c, r.path, u)) : null
      })
      .filter(c => !!c)
    return r.common.async ? Promise.all(s).then(c => Dr.mergeArray(n, c)) : Dr.mergeArray(n, s)
  }
  get items() {
    return this._def.items
  }
  rest(e) {
    return new Ks({ ...this._def, rest: e })
  }
}
Ks.create = (t, e) => {
  if (!Array.isArray(t)) throw new Error('You must pass an array of schemas to z.tuple([ ... ])')
  return new Ks({ items: t, typeName: je.ZodTuple, rest: null, ...Ve(e) })
}
class Gh extends Xe {
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e)
    if (r.parsedType !== Ae.object)
      return xe(r, { code: pe.invalid_type, expected: Ae.object, received: r.parsedType }), He
    const i = [],
      s = this._def.keyType,
      c = this._def.valueType
    for (const u in r.data)
      i.push({
        key: s._parse(new Vs(r, u, r.path, u)),
        value: c._parse(new Vs(r, r.data[u], r.path, u))
      })
    return r.common.async ? Dr.mergeObjectAsync(n, i) : Dr.mergeObjectSync(n, i)
  }
  get element() {
    return this._def.valueType
  }
  static create(e, n, r) {
    return n instanceof Xe
      ? new Gh({ keyType: e, valueType: n, typeName: je.ZodRecord, ...Ve(r) })
      : new Gh({ keyType: ls.create(), valueType: e, typeName: je.ZodRecord, ...Ve(n) })
  }
}
class fm extends Xe {
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e)
    if (r.parsedType !== Ae.map)
      return xe(r, { code: pe.invalid_type, expected: Ae.map, received: r.parsedType }), He
    const i = this._def.keyType,
      s = this._def.valueType,
      c = [...r.data.entries()].map(([u, f], d) => ({
        key: i._parse(new Vs(r, u, r.path, [d, 'key'])),
        value: s._parse(new Vs(r, f, r.path, [d, 'value']))
      }))
    if (r.common.async) {
      const u = new Map()
      return Promise.resolve().then(async () => {
        for (const f of c) {
          const d = await f.key,
            p = await f.value
          if (d.status === 'aborted' || p.status === 'aborted') return He
          ;(d.status === 'dirty' || p.status === 'dirty') && n.dirty(), u.set(d.value, p.value)
        }
        return { status: n.value, value: u }
      })
    } else {
      const u = new Map()
      for (const f of c) {
        const d = f.key,
          p = f.value
        if (d.status === 'aborted' || p.status === 'aborted') return He
        ;(d.status === 'dirty' || p.status === 'dirty') && n.dirty(), u.set(d.value, p.value)
      }
      return { status: n.value, value: u }
    }
  }
}
fm.create = (t, e, n) => new fm({ valueType: e, keyType: t, typeName: je.ZodMap, ...Ve(n) })
class lu extends Xe {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e)
    if (r.parsedType !== Ae.set)
      return xe(r, { code: pe.invalid_type, expected: Ae.set, received: r.parsedType }), He
    const i = this._def
    i.minSize !== null &&
      r.data.size < i.minSize.value &&
      (xe(r, {
        code: pe.too_small,
        minimum: i.minSize.value,
        type: 'set',
        inclusive: !0,
        exact: !1,
        message: i.minSize.message
      }),
      n.dirty()),
      i.maxSize !== null &&
        r.data.size > i.maxSize.value &&
        (xe(r, {
          code: pe.too_big,
          maximum: i.maxSize.value,
          type: 'set',
          inclusive: !0,
          exact: !1,
          message: i.maxSize.message
        }),
        n.dirty())
    const s = this._def.valueType
    function c(f) {
      const d = new Set()
      for (const p of f) {
        if (p.status === 'aborted') return He
        p.status === 'dirty' && n.dirty(), d.add(p.value)
      }
      return { status: n.value, value: d }
    }
    const u = [...r.data.values()].map((f, d) => s._parse(new Vs(r, f, r.path, d)))
    return r.common.async ? Promise.all(u).then(f => c(f)) : c(u)
  }
  min(e, n) {
    return new lu({ ...this._def, minSize: { value: e, message: Be.toString(n) } })
  }
  max(e, n) {
    return new lu({ ...this._def, maxSize: { value: e, message: Be.toString(n) } })
  }
  size(e, n) {
    return this.min(e, n).max(e, n)
  }
  nonempty(e) {
    return this.min(1, e)
  }
}
lu.create = (t, e) =>
  new lu({ valueType: t, minSize: null, maxSize: null, typeName: je.ZodSet, ...Ve(e) })
class Ul extends Xe {
  constructor() {
    super(...arguments), (this.validate = this.implement)
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e)
    if (n.parsedType !== Ae.function)
      return xe(n, { code: pe.invalid_type, expected: Ae.function, received: n.parsedType }), He
    function r(u, f) {
      return cm({
        data: u,
        path: n.path,
        errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, om(), Lh].filter(d => !!d),
        issueData: { code: pe.invalid_arguments, argumentsError: f }
      })
    }
    function i(u, f) {
      return cm({
        data: u,
        path: n.path,
        errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, om(), Lh].filter(d => !!d),
        issueData: { code: pe.invalid_return_type, returnTypeError: f }
      })
    }
    const s = { errorMap: n.common.contextualErrorMap },
      c = n.data
    if (this._def.returns instanceof ud) {
      const u = this
      return jr(async function (...f) {
        const d = new ds([]),
          p = await u._def.args.parseAsync(f, s).catch(y => {
            throw (d.addIssue(r(f, y)), d)
          }),
          g = await Reflect.apply(c, this, p)
        return await u._def.returns._def.type.parseAsync(g, s).catch(y => {
          throw (d.addIssue(i(g, y)), d)
        })
      })
    } else {
      const u = this
      return jr(function (...f) {
        const d = u._def.args.safeParse(f, s)
        if (!d.success) throw new ds([r(f, d.error)])
        const p = Reflect.apply(c, this, d.data),
          g = u._def.returns.safeParse(p, s)
        if (!g.success) throw new ds([i(p, g.error)])
        return g.data
      })
    }
  }
  parameters() {
    return this._def.args
  }
  returnType() {
    return this._def.returns
  }
  args(...e) {
    return new Ul({ ...this._def, args: Ks.create(e).rest(Qc.create()) })
  }
  returns(e) {
    return new Ul({ ...this._def, returns: e })
  }
  implement(e) {
    return this.parse(e)
  }
  strictImplement(e) {
    return this.parse(e)
  }
  static create(e, n, r) {
    return new Ul({
      args: e || Ks.create([]).rest(Qc.create()),
      returns: n || Qc.create(),
      typeName: je.ZodFunction,
      ...Ve(r)
    })
  }
}
class Vh extends Xe {
  get schema() {
    return this._def.getter()
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e)
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n })
  }
}
Vh.create = (t, e) => new Vh({ getter: t, typeName: je.ZodLazy, ...Ve(e) })
class Kh extends Xe {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e)
      return xe(n, { received: n.data, code: pe.invalid_literal, expected: this._def.value }), He
    }
    return { status: 'valid', value: e.data }
  }
  get value() {
    return this._def.value
  }
}
Kh.create = (t, e) => new Kh({ value: t, typeName: je.ZodLiteral, ...Ve(e) })
function $9(t, e) {
  return new Qo({ values: t, typeName: je.ZodEnum, ...Ve(e) })
}
class Qo extends Xe {
  _parse(e) {
    if (typeof e.data != 'string') {
      const n = this._getOrReturnCtx(e),
        r = this._def.values
      return (
        xe(n, { expected: St.joinValues(r), received: n.parsedType, code: pe.invalid_type }), He
      )
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const n = this._getOrReturnCtx(e),
        r = this._def.values
      return xe(n, { received: n.data, code: pe.invalid_enum_value, options: r }), He
    }
    return jr(e.data)
  }
  get options() {
    return this._def.values
  }
  get enum() {
    const e = {}
    for (const n of this._def.values) e[n] = n
    return e
  }
  get Values() {
    const e = {}
    for (const n of this._def.values) e[n] = n
    return e
  }
  get Enum() {
    const e = {}
    for (const n of this._def.values) e[n] = n
    return e
  }
  extract(e) {
    return Qo.create(e)
  }
  exclude(e) {
    return Qo.create(this.options.filter(n => !e.includes(n)))
  }
}
Qo.create = $9
class Wh extends Xe {
  _parse(e) {
    const n = St.getValidEnumValues(this._def.values),
      r = this._getOrReturnCtx(e)
    if (r.parsedType !== Ae.string && r.parsedType !== Ae.number) {
      const i = St.objectValues(n)
      return (
        xe(r, { expected: St.joinValues(i), received: r.parsedType, code: pe.invalid_type }), He
      )
    }
    if (n.indexOf(e.data) === -1) {
      const i = St.objectValues(n)
      return xe(r, { received: r.data, code: pe.invalid_enum_value, options: i }), He
    }
    return jr(e.data)
  }
  get enum() {
    return this._def.values
  }
}
Wh.create = (t, e) => new Wh({ values: t, typeName: je.ZodNativeEnum, ...Ve(e) })
class ud extends Xe {
  unwrap() {
    return this._def.type
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e)
    if (n.parsedType !== Ae.promise && n.common.async === !1)
      return xe(n, { code: pe.invalid_type, expected: Ae.promise, received: n.parsedType }), He
    const r = n.parsedType === Ae.promise ? n.data : Promise.resolve(n.data)
    return jr(
      r.then(i =>
        this._def.type.parseAsync(i, { path: n.path, errorMap: n.common.contextualErrorMap })
      )
    )
  }
}
ud.create = (t, e) => new ud({ type: t, typeName: je.ZodPromise, ...Ve(e) })
class hs extends Xe {
  innerType() {
    return this._def.schema
  }
  sourceType() {
    return this._def.schema._def.typeName === je.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e),
      i = this._def.effect || null,
      s = {
        addIssue: c => {
          xe(r, c), c.fatal ? n.abort() : n.dirty()
        },
        get path() {
          return r.path
        }
      }
    if (((s.addIssue = s.addIssue.bind(s)), i.type === 'preprocess')) {
      const c = i.transform(r.data, s)
      return r.common.issues.length
        ? { status: 'dirty', value: r.data }
        : r.common.async
          ? Promise.resolve(c).then(u =>
              this._def.schema._parseAsync({ data: u, path: r.path, parent: r })
            )
          : this._def.schema._parseSync({ data: c, path: r.path, parent: r })
    }
    if (i.type === 'refinement') {
      const c = u => {
        const f = i.refinement(u, s)
        if (r.common.async) return Promise.resolve(f)
        if (f instanceof Promise)
          throw new Error(
            'Async refinement encountered during synchronous parse operation. Use .parseAsync instead.'
          )
        return u
      }
      if (r.common.async === !1) {
        const u = this._def.schema._parseSync({ data: r.data, path: r.path, parent: r })
        return u.status === 'aborted'
          ? He
          : (u.status === 'dirty' && n.dirty(), c(u.value), { status: n.value, value: u.value })
      } else
        return this._def.schema
          ._parseAsync({ data: r.data, path: r.path, parent: r })
          .then(u =>
            u.status === 'aborted'
              ? He
              : (u.status === 'dirty' && n.dirty(),
                c(u.value).then(() => ({ status: n.value, value: u.value })))
          )
    }
    if (i.type === 'transform')
      if (r.common.async === !1) {
        const c = this._def.schema._parseSync({ data: r.data, path: r.path, parent: r })
        if (!$h(c)) return c
        const u = i.transform(c.value, s)
        if (u instanceof Promise)
          throw new Error(
            'Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.'
          )
        return { status: n.value, value: u }
      } else
        return this._def.schema
          ._parseAsync({ data: r.data, path: r.path, parent: r })
          .then(c =>
            $h(c)
              ? Promise.resolve(i.transform(c.value, s)).then(u => ({ status: n.value, value: u }))
              : c
          )
    St.assertNever(i)
  }
}
hs.create = (t, e, n) => new hs({ schema: t, typeName: je.ZodEffects, effect: e, ...Ve(n) })
hs.createWithPreprocess = (t, e, n) =>
  new hs({
    schema: e,
    effect: { type: 'preprocess', transform: t },
    typeName: je.ZodEffects,
    ...Ve(n)
  })
class Pa extends Xe {
  _parse(e) {
    return this._getType(e) === Ae.undefined ? jr(void 0) : this._def.innerType._parse(e)
  }
  unwrap() {
    return this._def.innerType
  }
}
Pa.create = (t, e) => new Pa({ innerType: t, typeName: je.ZodOptional, ...Ve(e) })
class du extends Xe {
  _parse(e) {
    return this._getType(e) === Ae.null ? jr(null) : this._def.innerType._parse(e)
  }
  unwrap() {
    return this._def.innerType
  }
}
du.create = (t, e) => new du({ innerType: t, typeName: je.ZodNullable, ...Ve(e) })
class Qh extends Xe {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e)
    let r = n.data
    return (
      n.parsedType === Ae.undefined && (r = this._def.defaultValue()),
      this._def.innerType._parse({ data: r, path: n.path, parent: n })
    )
  }
  removeDefault() {
    return this._def.innerType
  }
}
Qh.create = (t, e) =>
  new Qh({
    innerType: t,
    typeName: je.ZodDefault,
    defaultValue: typeof e.default == 'function' ? e.default : () => e.default,
    ...Ve(e)
  })
class hm extends Xe {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e),
      r = { ...n, common: { ...n.common, issues: [] } },
      i = this._def.innerType._parse({ data: r.data, path: r.path, parent: { ...r } })
    return um(i)
      ? i.then(s => ({
          status: 'valid',
          value:
            s.status === 'valid'
              ? s.value
              : this._def.catchValue({
                  get error() {
                    return new ds(r.common.issues)
                  },
                  input: r.data
                })
        }))
      : {
          status: 'valid',
          value:
            i.status === 'valid'
              ? i.value
              : this._def.catchValue({
                  get error() {
                    return new ds(r.common.issues)
                  },
                  input: r.data
                })
        }
  }
  removeCatch() {
    return this._def.innerType
  }
}
hm.create = (t, e) =>
  new hm({
    innerType: t,
    typeName: je.ZodCatch,
    catchValue: typeof e.catch == 'function' ? e.catch : () => e.catch,
    ...Ve(e)
  })
class pm extends Xe {
  _parse(e) {
    if (this._getType(e) !== Ae.nan) {
      const r = this._getOrReturnCtx(e)
      return xe(r, { code: pe.invalid_type, expected: Ae.nan, received: r.parsedType }), He
    }
    return { status: 'valid', value: e.data }
  }
}
pm.create = t => new pm({ typeName: je.ZodNaN, ...Ve(t) })
const KX = Symbol('zod_brand')
class F9 extends Xe {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e),
      r = n.data
    return this._def.type._parse({ data: r, path: n.path, parent: n })
  }
  unwrap() {
    return this._def.type
  }
}
class Op extends Xe {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e)
    if (r.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({ data: r.data, path: r.path, parent: r })
        return s.status === 'aborted'
          ? He
          : s.status === 'dirty'
            ? (n.dirty(), L9(s.value))
            : this._def.out._parseAsync({ data: s.value, path: r.path, parent: r })
      })()
    {
      const i = this._def.in._parseSync({ data: r.data, path: r.path, parent: r })
      return i.status === 'aborted'
        ? He
        : i.status === 'dirty'
          ? (n.dirty(), { status: 'dirty', value: i.value })
          : this._def.out._parseSync({ data: i.value, path: r.path, parent: r })
    }
  }
  static create(e, n) {
    return new Op({ in: e, out: n, typeName: je.ZodPipeline })
  }
}
class gm extends Xe {
  _parse(e) {
    const n = this._def.innerType._parse(e)
    return $h(n) && (n.value = Object.freeze(n.value)), n
  }
}
gm.create = (t, e) => new gm({ innerType: t, typeName: je.ZodReadonly, ...Ve(e) })
const j9 = (t, e = {}, n) =>
    t
      ? cd.create().superRefine((r, i) => {
          var s, c
          if (!t(r)) {
            const u = typeof e == 'function' ? e(r) : typeof e == 'string' ? { message: e } : e,
              f =
                (c = (s = u.fatal) !== null && s !== void 0 ? s : n) !== null && c !== void 0
                  ? c
                  : !0,
              d = typeof u == 'string' ? { message: u } : u
            i.addIssue({ code: 'custom', ...d, fatal: f })
          }
        })
      : cd.create(),
  WX = { object: Sn.lazycreate }
var je
;(function (t) {
  ;(t.ZodString = 'ZodString'),
    (t.ZodNumber = 'ZodNumber'),
    (t.ZodNaN = 'ZodNaN'),
    (t.ZodBigInt = 'ZodBigInt'),
    (t.ZodBoolean = 'ZodBoolean'),
    (t.ZodDate = 'ZodDate'),
    (t.ZodSymbol = 'ZodSymbol'),
    (t.ZodUndefined = 'ZodUndefined'),
    (t.ZodNull = 'ZodNull'),
    (t.ZodAny = 'ZodAny'),
    (t.ZodUnknown = 'ZodUnknown'),
    (t.ZodNever = 'ZodNever'),
    (t.ZodVoid = 'ZodVoid'),
    (t.ZodArray = 'ZodArray'),
    (t.ZodObject = 'ZodObject'),
    (t.ZodUnion = 'ZodUnion'),
    (t.ZodDiscriminatedUnion = 'ZodDiscriminatedUnion'),
    (t.ZodIntersection = 'ZodIntersection'),
    (t.ZodTuple = 'ZodTuple'),
    (t.ZodRecord = 'ZodRecord'),
    (t.ZodMap = 'ZodMap'),
    (t.ZodSet = 'ZodSet'),
    (t.ZodFunction = 'ZodFunction'),
    (t.ZodLazy = 'ZodLazy'),
    (t.ZodLiteral = 'ZodLiteral'),
    (t.ZodEnum = 'ZodEnum'),
    (t.ZodEffects = 'ZodEffects'),
    (t.ZodNativeEnum = 'ZodNativeEnum'),
    (t.ZodOptional = 'ZodOptional'),
    (t.ZodNullable = 'ZodNullable'),
    (t.ZodDefault = 'ZodDefault'),
    (t.ZodCatch = 'ZodCatch'),
    (t.ZodPromise = 'ZodPromise'),
    (t.ZodBranded = 'ZodBranded'),
    (t.ZodPipeline = 'ZodPipeline'),
    (t.ZodReadonly = 'ZodReadonly')
})(je || (je = {}))
const QX = (t, e = { message: `Input not instance of ${t.name}` }) => j9(n => n instanceof t, e),
  z9 = ls.create,
  q9 = Ko.create,
  YX = pm.create,
  ZX = Wo.create,
  H9 = Fh.create,
  XX = uu.create,
  JX = lm.create,
  eJ = jh.create,
  tJ = zh.create,
  nJ = cd.create,
  rJ = Qc.create,
  iJ = La.create,
  sJ = dm.create,
  aJ = fs.create,
  oJ = Sn.create,
  cJ = Sn.strictCreate,
  uJ = qh.create,
  lJ = Zm.create,
  dJ = Hh.create,
  fJ = Ks.create,
  hJ = Gh.create,
  pJ = fm.create,
  gJ = lu.create,
  mJ = Ul.create,
  bJ = Vh.create,
  yJ = Kh.create,
  vJ = Qo.create,
  wJ = Wh.create,
  EJ = ud.create,
  B4 = hs.create,
  AJ = Pa.create,
  _J = du.create,
  CJ = hs.createWithPreprocess,
  SJ = Op.create,
  TJ = () => z9().optional(),
  xJ = () => q9().optional(),
  NJ = () => H9().optional(),
  IJ = {
    string: t => ls.create({ ...t, coerce: !0 }),
    number: t => Ko.create({ ...t, coerce: !0 }),
    boolean: t => Fh.create({ ...t, coerce: !0 }),
    bigint: t => Wo.create({ ...t, coerce: !0 }),
    date: t => uu.create({ ...t, coerce: !0 })
  },
  OJ = He
var H = Object.freeze({
  __proto__: null,
  defaultErrorMap: Lh,
  setErrorMap: MX,
  getErrorMap: om,
  makeIssue: cm,
  EMPTY_PATH: kX,
  addIssueToContext: xe,
  ParseStatus: Dr,
  INVALID: He,
  DIRTY: L9,
  OK: jr,
  isAborted: lE,
  isDirty: dE,
  isValid: $h,
  isAsync: um,
  get util() {
    return St
  },
  get objectUtil() {
    return uE
  },
  ZodParsedType: Ae,
  getParsedType: _o,
  ZodType: Xe,
  ZodString: ls,
  ZodNumber: Ko,
  ZodBigInt: Wo,
  ZodBoolean: Fh,
  ZodDate: uu,
  ZodSymbol: lm,
  ZodUndefined: jh,
  ZodNull: zh,
  ZodAny: cd,
  ZodUnknown: Qc,
  ZodNever: La,
  ZodVoid: dm,
  ZodArray: fs,
  ZodObject: Sn,
  ZodUnion: qh,
  ZodDiscriminatedUnion: Zm,
  ZodIntersection: Hh,
  ZodTuple: Ks,
  ZodRecord: Gh,
  ZodMap: fm,
  ZodSet: lu,
  ZodFunction: Ul,
  ZodLazy: Vh,
  ZodLiteral: Kh,
  ZodEnum: Qo,
  ZodNativeEnum: Wh,
  ZodPromise: ud,
  ZodEffects: hs,
  ZodTransformer: hs,
  ZodOptional: Pa,
  ZodNullable: du,
  ZodDefault: Qh,
  ZodCatch: hm,
  ZodNaN: pm,
  BRAND: KX,
  ZodBranded: F9,
  ZodPipeline: Op,
  ZodReadonly: gm,
  custom: j9,
  Schema: Xe,
  ZodSchema: Xe,
  late: WX,
  get ZodFirstPartyTypeKind() {
    return je
  },
  coerce: IJ,
  any: nJ,
  array: aJ,
  bigint: ZX,
  boolean: H9,
  date: XX,
  discriminatedUnion: lJ,
  effect: B4,
  enum: vJ,
  function: mJ,
  instanceof: QX,
  intersection: dJ,
  lazy: bJ,
  literal: yJ,
  map: pJ,
  nan: YX,
  nativeEnum: wJ,
  never: iJ,
  null: tJ,
  nullable: _J,
  number: q9,
  object: oJ,
  oboolean: NJ,
  onumber: xJ,
  optional: AJ,
  ostring: TJ,
  pipeline: SJ,
  preprocess: CJ,
  promise: EJ,
  record: hJ,
  set: gJ,
  strictObject: cJ,
  string: z9,
  symbol: JX,
  transformer: B4,
  tuple: fJ,
  undefined: eJ,
  union: uJ,
  unknown: rJ,
  void: sJ,
  NEVER: OJ,
  ZodIssueCode: pe,
  quotelessJson: PX,
  ZodError: ds
})
const kn = H.object({ message: H.string() })
function Se(t) {
  return H.literal(Re[t])
}
H.object({
  accessList: H.array(H.string()),
  blockHash: H.string().nullable(),
  blockNumber: H.string().nullable(),
  chainId: H.string().or(H.number()),
  from: H.string(),
  gas: H.string(),
  hash: H.string(),
  input: H.string().nullable(),
  maxFeePerGas: H.string(),
  maxPriorityFeePerGas: H.string(),
  nonce: H.string(),
  r: H.string(),
  s: H.string(),
  to: H.string(),
  transactionIndex: H.string().nullable(),
  type: H.string(),
  v: H.string(),
  value: H.string()
})
const RJ = H.object({ chainId: H.string().or(H.number()) }),
  DJ = H.object({ email: H.string().email() }),
  PJ = H.object({ otp: H.string() }),
  MJ = H.object({ uri: H.string() }),
  kJ = H.object({
    chainId: H.optional(H.string().or(H.number())),
    preferredAccountType: H.optional(H.string())
  }),
  UJ = H.object({ provider: H.enum(['google', 'github', 'apple', 'facebook', 'x', 'discord']) }),
  BJ = H.object({ email: H.string().email() }),
  LJ = H.object({ otp: H.string() }),
  $J = H.object({ otp: H.string() }),
  FJ = H.object({
    themeMode: H.optional(H.enum(['light', 'dark'])),
    themeVariables: H.optional(H.record(H.string(), H.string().or(H.number()))),
    w3mThemeVariables: H.optional(H.record(H.string(), H.string()))
  }),
  jJ = H.object({
    metadata: H.object({
      name: H.string(),
      description: H.string(),
      url: H.string(),
      icons: H.array(H.string())
    }).optional(),
    sdkVersion: H.string().optional(),
    sdkType: H.string().optional(),
    projectId: H.string()
  }),
  zJ = H.object({ type: H.string() }),
  qJ = H.object({ action: H.enum(['VERIFY_DEVICE', 'VERIFY_OTP', 'CONNECT']) }),
  HJ = H.object({ url: H.string() }),
  GJ = H.object({ userName: H.string() }),
  VJ = H.object({
    email: H.string().optional().nullable(),
    address: H.string(),
    chainId: H.string().or(H.number()),
    accounts: H.array(
      H.object({
        address: H.string(),
        type: H.enum([yn.ACCOUNT_TYPES.EOA, yn.ACCOUNT_TYPES.SMART_ACCOUNT])
      })
    ).optional(),
    userName: H.string().optional().nullable()
  }),
  KJ = H.object({ action: H.enum(['VERIFY_PRIMARY_OTP', 'VERIFY_SECONDARY_OTP']) }),
  WJ = H.object({
    email: H.string().email().optional().nullable(),
    address: H.string(),
    chainId: H.string().or(H.number()),
    smartAccountDeployed: H.optional(H.boolean()),
    accounts: H.array(
      H.object({
        address: H.string(),
        type: H.enum([yn.ACCOUNT_TYPES.EOA, yn.ACCOUNT_TYPES.SMART_ACCOUNT])
      })
    ).optional(),
    preferredAccountType: H.optional(H.string())
  }),
  QJ = H.object({ uri: H.string() }),
  YJ = H.object({ isConnected: H.boolean() }),
  ZJ = H.object({ chainId: H.string().or(H.number()) }),
  XJ = H.object({ chainId: H.string().or(H.number()) }),
  JJ = H.object({ newEmail: H.string().email() }),
  eee = H.object({ smartAccountEnabledNetworks: H.array(H.number()) })
H.object({ address: H.string(), isDeployed: H.boolean() })
const tee = H.object({ version: H.string().optional() }),
  nee = H.object({ type: H.string(), address: H.string() }),
  ree = H.any(),
  iee = H.object({ method: H.literal('eth_accounts') }),
  see = H.object({ method: H.literal('eth_blockNumber') }),
  aee = H.object({ method: H.literal('eth_call'), params: H.array(H.any()) }),
  oee = H.object({ method: H.literal('eth_chainId') }),
  cee = H.object({ method: H.literal('eth_estimateGas'), params: H.array(H.any()) }),
  uee = H.object({ method: H.literal('eth_feeHistory'), params: H.array(H.any()) }),
  lee = H.object({ method: H.literal('eth_gasPrice') }),
  dee = H.object({ method: H.literal('eth_getAccount'), params: H.array(H.any()) }),
  fee = H.object({ method: H.literal('eth_getBalance'), params: H.array(H.any()) }),
  hee = H.object({ method: H.literal('eth_getBlockByHash'), params: H.array(H.any()) }),
  pee = H.object({ method: H.literal('eth_getBlockByNumber'), params: H.array(H.any()) }),
  gee = H.object({ method: H.literal('eth_getBlockReceipts'), params: H.array(H.any()) }),
  mee = H.object({
    method: H.literal('eth_getBlockTransactionCountByHash'),
    params: H.array(H.any())
  }),
  bee = H.object({
    method: H.literal('eth_getBlockTransactionCountByNumber'),
    params: H.array(H.any())
  }),
  yee = H.object({ method: H.literal('eth_getCode'), params: H.array(H.any()) }),
  vee = H.object({ method: H.literal('eth_getFilterChanges'), params: H.array(H.any()) }),
  wee = H.object({ method: H.literal('eth_getFilterLogs'), params: H.array(H.any()) }),
  Eee = H.object({ method: H.literal('eth_getLogs'), params: H.array(H.any()) }),
  Aee = H.object({ method: H.literal('eth_getProof'), params: H.array(H.any()) }),
  _ee = H.object({ method: H.literal('eth_getStorageAt'), params: H.array(H.any()) }),
  Cee = H.object({
    method: H.literal('eth_getTransactionByBlockHashAndIndex'),
    params: H.array(H.any())
  }),
  See = H.object({
    method: H.literal('eth_getTransactionByBlockNumberAndIndex'),
    params: H.array(H.any())
  }),
  Tee = H.object({ method: H.literal('eth_getTransactionByHash'), params: H.array(H.any()) }),
  xee = H.object({ method: H.literal('eth_getTransactionCount'), params: H.array(H.any()) }),
  Nee = H.object({ method: H.literal('eth_getTransactionReceipt'), params: H.array(H.any()) }),
  Iee = H.object({ method: H.literal('eth_getUncleCountByBlockHash'), params: H.array(H.any()) }),
  Oee = H.object({ method: H.literal('eth_getUncleCountByBlockNumber'), params: H.array(H.any()) }),
  Ree = H.object({ method: H.literal('eth_maxPriorityFeePerGas') }),
  Dee = H.object({ method: H.literal('eth_newBlockFilter') }),
  Pee = H.object({ method: H.literal('eth_newFilter'), params: H.array(H.any()) }),
  Mee = H.object({ method: H.literal('eth_newPendingTransactionFilter') }),
  kee = H.object({ method: H.literal('eth_sendRawTransaction'), params: H.array(H.any()) }),
  Uee = H.object({ method: H.literal('eth_syncing'), params: H.array(H.any()) }),
  Bee = H.object({ method: H.literal('eth_uninstallFilter'), params: H.array(H.any()) }),
  L4 = H.object({ method: H.literal('personal_sign'), params: H.array(H.any()) }),
  Lee = H.object({ method: H.literal('eth_signTypedData_v4'), params: H.array(H.any()) }),
  $ee = H.object({ method: H.literal('eth_sendTransaction'), params: H.array(H.any()) }),
  Fee = H.object({
    method: H.literal('solana_signMessage'),
    params: H.object({ message: H.string(), pubkey: H.string() })
  }),
  jee = H.object({
    method: H.literal('solana_signTransaction'),
    params: H.object({ transaction: H.string() })
  }),
  zee = H.object({
    method: H.literal('solana_signAllTransactions'),
    params: H.object({ transactions: H.array(H.string()) })
  }),
  qee = H.object({
    method: H.literal('solana_signAndSendTransaction'),
    params: H.object({
      transaction: H.string(),
      options: H.object({
        skipPreflight: H.boolean().optional(),
        preflightCommitment: H.enum([
          'processed',
          'confirmed',
          'finalized',
          'recent',
          'single',
          'singleGossip',
          'root',
          'max'
        ]).optional(),
        maxRetries: H.number().optional(),
        minContextSlot: H.number().optional()
      }).optional()
    })
  }),
  Hee = H.object({
    method: H.literal('wallet_sendCalls'),
    params: H.array(
      H.object({
        chainId: H.string().or(H.number()).optional(),
        from: H.string().optional(),
        version: H.string().optional(),
        capabilities: H.any().optional(),
        calls: H.array(
          H.object({
            to: H.string().startsWith('0x'),
            data: H.string().startsWith('0x').optional(),
            value: H.string().optional()
          })
        )
      })
    )
  }),
  Gee = H.object({ method: H.literal('wallet_getCallsStatus'), params: H.array(H.string()) }),
  Vee = H.object({ method: H.literal('wallet_getCapabilities') }),
  Kee = H.object({ method: H.literal('wallet_grantPermissions'), params: H.array(H.any()) }),
  Wee = H.object({ method: H.literal('wallet_revokePermissions'), params: H.any() }),
  Qee = H.object({ method: H.literal('wallet_getAssets'), params: H.any() }),
  $4 = H.object({ token: H.string() }),
  Te = H.object({ id: H.string().optional() }),
  Yf = {
    appEvent: Te.extend({ type: Se('APP_SWITCH_NETWORK'), payload: RJ })
      .or(Te.extend({ type: Se('APP_CONNECT_EMAIL'), payload: DJ }))
      .or(Te.extend({ type: Se('APP_CONNECT_DEVICE') }))
      .or(Te.extend({ type: Se('APP_CONNECT_OTP'), payload: PJ }))
      .or(Te.extend({ type: Se('APP_CONNECT_SOCIAL'), payload: MJ }))
      .or(Te.extend({ type: Se('APP_GET_FARCASTER_URI') }))
      .or(Te.extend({ type: Se('APP_CONNECT_FARCASTER') }))
      .or(Te.extend({ type: Se('APP_GET_USER'), payload: H.optional(kJ) }))
      .or(Te.extend({ type: Se('APP_GET_SOCIAL_REDIRECT_URI'), payload: UJ }))
      .or(Te.extend({ type: Se('APP_SIGN_OUT') }))
      .or(Te.extend({ type: Se('APP_IS_CONNECTED'), payload: H.optional($4) }))
      .or(Te.extend({ type: Se('APP_GET_CHAIN_ID') }))
      .or(Te.extend({ type: Se('APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS') }))
      .or(Te.extend({ type: Se('APP_INIT_SMART_ACCOUNT') }))
      .or(Te.extend({ type: Se('APP_SET_PREFERRED_ACCOUNT'), payload: zJ }))
      .or(
        Te.extend({
          type: Se('APP_RPC_REQUEST'),
          payload: L4.or(Qee)
            .or(iee)
            .or(see)
            .or(aee)
            .or(oee)
            .or(cee)
            .or(uee)
            .or(lee)
            .or(dee)
            .or(fee)
            .or(hee)
            .or(pee)
            .or(gee)
            .or(mee)
            .or(bee)
            .or(yee)
            .or(vee)
            .or(wee)
            .or(Eee)
            .or(Aee)
            .or(_ee)
            .or(Cee)
            .or(See)
            .or(Tee)
            .or(xee)
            .or(Nee)
            .or(Iee)
            .or(Oee)
            .or(Ree)
            .or(Dee)
            .or(Pee)
            .or(Mee)
            .or(kee)
            .or(Uee)
            .or(Bee)
            .or(L4)
            .or(Lee)
            .or($ee)
            .or(Fee)
            .or(jee)
            .or(zee)
            .or(qee)
            .or(Gee)
            .or(Hee)
            .or(Vee)
            .or(Kee)
            .or(Wee)
        })
      )
      .or(Te.extend({ type: Se('APP_UPDATE_EMAIL'), payload: BJ }))
      .or(Te.extend({ type: Se('APP_UPDATE_EMAIL_PRIMARY_OTP'), payload: LJ }))
      .or(Te.extend({ type: Se('APP_UPDATE_EMAIL_SECONDARY_OTP'), payload: $J }))
      .or(Te.extend({ type: Se('APP_SYNC_THEME'), payload: FJ }))
      .or(Te.extend({ type: Se('APP_SYNC_DAPP_DATA'), payload: jJ }))
      .or(Te.extend({ type: Se('APP_RELOAD') })),
    frameEvent: Te.extend({ type: Se('FRAME_SWITCH_NETWORK_ERROR'), payload: kn })
      .or(Te.extend({ type: Se('FRAME_SWITCH_NETWORK_SUCCESS'), payload: XJ }))
      .or(Te.extend({ type: Se('FRAME_CONNECT_EMAIL_SUCCESS'), payload: qJ }))
      .or(Te.extend({ type: Se('FRAME_CONNECT_EMAIL_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_GET_FARCASTER_URI_SUCCESS'), payload: HJ }))
      .or(Te.extend({ type: Se('FRAME_GET_FARCASTER_URI_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_CONNECT_FARCASTER_SUCCESS'), payload: GJ }))
      .or(Te.extend({ type: Se('FRAME_CONNECT_FARCASTER_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_CONNECT_OTP_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_CONNECT_OTP_SUCCESS') }))
      .or(Te.extend({ type: Se('FRAME_CONNECT_DEVICE_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_CONNECT_DEVICE_SUCCESS') }))
      .or(Te.extend({ type: Se('FRAME_CONNECT_SOCIAL_SUCCESS'), payload: VJ }))
      .or(Te.extend({ type: Se('FRAME_CONNECT_SOCIAL_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_GET_USER_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_GET_USER_SUCCESS'), payload: WJ }))
      .or(Te.extend({ type: Se('FRAME_GET_SOCIAL_REDIRECT_URI_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS'), payload: QJ }))
      .or(Te.extend({ type: Se('FRAME_SIGN_OUT_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_SIGN_OUT_SUCCESS') }))
      .or(Te.extend({ type: Se('FRAME_IS_CONNECTED_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_IS_CONNECTED_SUCCESS'), payload: YJ }))
      .or(Te.extend({ type: Se('FRAME_GET_CHAIN_ID_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_GET_CHAIN_ID_SUCCESS'), payload: ZJ }))
      .or(Te.extend({ type: Se('FRAME_RPC_REQUEST_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_RPC_REQUEST_SUCCESS'), payload: ree }))
      .or(Te.extend({ type: Se('FRAME_SESSION_UPDATE'), payload: $4 }))
      .or(Te.extend({ type: Se('FRAME_UPDATE_EMAIL_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_UPDATE_EMAIL_SUCCESS'), payload: KJ }))
      .or(Te.extend({ type: Se('FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS') }))
      .or(Te.extend({ type: Se('FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS'), payload: JJ }))
      .or(Te.extend({ type: Se('FRAME_SYNC_THEME_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_SYNC_THEME_SUCCESS') }))
      .or(Te.extend({ type: Se('FRAME_SYNC_DAPP_DATA_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_SYNC_DAPP_DATA_SUCCESS') }))
      .or(Te.extend({ type: Se('FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS'), payload: eee }))
      .or(Te.extend({ type: Se('FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_INIT_SMART_ACCOUNT_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_SET_PREFERRED_ACCOUNT_SUCCESS'), payload: nee }))
      .or(Te.extend({ type: Se('FRAME_SET_PREFERRED_ACCOUNT_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_READY'), payload: tee }))
      .or(Te.extend({ type: Se('FRAME_RELOAD_ERROR'), payload: kn }))
      .or(Te.extend({ type: Se('FRAME_RELOAD_SUCCESS') }))
  }
function q1(t, e = {}) {
  var n
  return (
    typeof (e == null ? void 0 : e.type) == 'string' &&
    ((n = e == null ? void 0 : e.type) == null ? void 0 : n.includes(t))
  )
}
class Yee {
  constructor({
    projectId: e,
    isAppClient: n = !1,
    chainId: r = 'eip155:1',
    enableLogger: i = !0
  }) {
    if (
      ((this.iframe = null),
      (this.rpcUrl = he.BLOCKCHAIN_API_RPC_URL),
      (this.initFrame = () => {
        const s = document.getElementById('w3m-iframe')
        this.iframe && !s && document.body.appendChild(this.iframe)
      }),
      (this.events = {
        registerFrameEventHandler: (s, c, u) => {
          function f({ data: d }) {
            if (!q1(Re.FRAME_EVENT_KEY, d)) return
            const p = Yf.frameEvent.parse(d)
            p.id === s && (c(p), window.removeEventListener('message', f))
          }
          gi.isClient &&
            (window.addEventListener('message', f),
            u.addEventListener('abort', () => {
              window.removeEventListener('message', f)
            }))
        },
        onFrameEvent: s => {
          gi.isClient &&
            window.addEventListener('message', ({ data: c }) => {
              if (!q1(Re.FRAME_EVENT_KEY, c)) return
              const u = Yf.frameEvent.parse(c)
              s(u)
            })
        },
        onAppEvent: s => {
          gi.isClient &&
            window.addEventListener('message', ({ data: c }) => {
              if (!q1(Re.APP_EVENT_KEY, c)) return
              const u = Yf.appEvent.parse(c)
              s(u)
            })
        },
        postAppEvent: s => {
          var c
          if (gi.isClient) {
            if (!((c = this.iframe) != null && c.contentWindow))
              throw new Error('W3mFrame: iframe is not set')
            Yf.appEvent.parse(s), this.iframe.contentWindow.postMessage(s, '*')
          }
        },
        postFrameEvent: s => {
          if (gi.isClient) {
            if (!parent) throw new Error('W3mFrame: parent is not set')
            Yf.frameEvent.parse(s), parent.postMessage(s, '*')
          }
        }
      }),
      (this.projectId = e),
      (this.frameLoadPromise = new Promise((s, c) => {
        this.frameLoadPromiseResolver = { resolve: s, reject: c }
      })),
      n &&
        ((this.frameLoadPromise = new Promise((s, c) => {
          this.frameLoadPromiseResolver = { resolve: s, reject: c }
        })),
        gi.isClient))
    ) {
      const s = document.createElement('iframe')
      ;(s.id = 'w3m-iframe'),
        (s.src = `${nQ}?projectId=${e}&chainId=${r}&version=${iQ}&enableLogger=${i}`),
        (s.name = 'w3m-secure-iframe'),
        (s.style.position = 'fixed'),
        (s.style.zIndex = '999999'),
        (s.style.display = 'none'),
        (s.style.animationDelay = '0s, 50ms'),
        (s.style.borderBottomLeftRadius = 'clamp(0px, var(--wui-border-radius-l), 44px)'),
        (s.style.borderBottomRightRadius = 'clamp(0px, var(--wui-border-radius-l), 44px)'),
        (this.iframe = s),
        (this.iframe.onerror = () => {
          var c
          ;(c = this.frameLoadPromiseResolver) == null ||
            c.reject('Unable to load email login dependency')
        }),
        this.events.onFrameEvent(c => {
          var u
          c.type === '@w3m-frame/READY' &&
            ((u = this.frameLoadPromiseResolver) == null || u.resolve(void 0))
        })
    }
  }
  get networks() {
    const e = [
      'eip155:1',
      'eip155:5',
      'eip155:11155111',
      'eip155:10',
      'eip155:420',
      'eip155:42161',
      'eip155:421613',
      'eip155:137',
      'eip155:80001',
      'eip155:42220',
      'eip155:1313161554',
      'eip155:1313161555',
      'eip155:56',
      'eip155:97',
      'eip155:43114',
      'eip155:43113',
      'eip155:324',
      'eip155:280',
      'eip155:100',
      'eip155:8453',
      'eip155:84531',
      'eip155:84532',
      'eip155:7777777',
      'eip155:999',
      'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
      'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
      'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1'
    ].map(n => ({
      [n]: { rpcUrl: `${this.rpcUrl}/v1/?chainId=${n}&projectId=${this.projectId}`, chainId: n }
    }))
    return Object.assign({}, ...e)
  }
}
class Zee {
  constructor(e) {
    var s
    const n = yd({ level: rQ }),
      { logger: r, chunkLoggerController: i } = jE({ opts: n })
    ;(this.logger = Pr(r, this.constructor.name)),
      (this.chunkLoggerController = i),
      typeof window < 'u' &&
        (s = this.chunkLoggerController) != null &&
        s.downloadLogsBlobInBrowser &&
        (window.downloadAppKitLogsBlob || (window.downloadAppKitLogsBlob = {}),
        (window.downloadAppKitLogsBlob.sdk = () => {
          var c
          ;(c = this.chunkLoggerController) != null &&
            c.downloadLogsBlobInBrowser &&
            this.chunkLoggerController.downloadLogsBlobInBrowser({ projectId: e })
        }))
  }
}
class Xee {
  constructor({ projectId: e, chainId: n, enableLogger: r = !0, onTimeout: i }) {
    ;(this.openRpcRequests = []),
      r && (this.w3mLogger = new Zee(e)),
      (this.w3mFrame = new Yee({ projectId: e, isAppClient: !0, chainId: n, enableLogger: r })),
      (this.onTimeout = i),
      this.getLoginEmailUsed() && this.w3mFrame.initFrame(),
      (this.initPromise = new Promise(s => {
        this.w3mFrame.events.onFrameEvent(c => {
          c.type === Re.FRAME_READY && ((this.initPromise = void 0), s())
        })
      }))
  }
  async init() {
    this.w3mFrame.initFrame(), this.initPromise && (await this.initPromise)
  }
  getLoginEmailUsed() {
    return !!yr.get(Re.EMAIL_LOGIN_USED_KEY)
  }
  getEmail() {
    return yr.get(Re.EMAIL)
  }
  getUsername() {
    return yr.get(Re.SOCIAL_USERNAME)
  }
  async reload() {
    var e
    try {
      this.w3mFrame.initFrame(), await this.appEvent({ type: Re.APP_RELOAD })
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error reloading iframe'), n)
      )
    }
  }
  async connectEmail(e) {
    var n
    try {
      gi.checkIfAllowedToTriggerEmail(), this.w3mFrame.initFrame()
      const r = await this.appEvent({ type: Re.APP_CONNECT_EMAIL, payload: e })
      return this.setNewLastEmailLoginTime(), r
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error connecting email'), r)
      )
    }
  }
  async connectDevice() {
    var e
    try {
      return this.appEvent({ type: Re.APP_CONNECT_DEVICE })
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error connecting device'), n)
      )
    }
  }
  async connectOtp(e) {
    var n
    try {
      return this.appEvent({ type: Re.APP_CONNECT_OTP, payload: e })
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error connecting otp'), r)
      )
    }
  }
  async isConnected() {
    var e
    try {
      if (!this.getLoginEmailUsed()) return { isConnected: !1 }
      const n = await this.appEvent({ type: Re.APP_IS_CONNECTED })
      return n.isConnected || this.deleteAuthLoginCache(), n
    } catch (n) {
      throw (
        (this.deleteAuthLoginCache(),
        (e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error checking connection'),
        n)
      )
    }
  }
  async getChainId() {
    var e
    try {
      const n = await this.appEvent({ type: Re.APP_GET_CHAIN_ID })
      return this.setLastUsedChainId(n.chainId), n
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error getting chain id'), n)
      )
    }
  }
  async getSocialRedirectUri(e) {
    var n
    try {
      return (
        this.w3mFrame.initFrame(),
        this.appEvent({ type: Re.APP_GET_SOCIAL_REDIRECT_URI, payload: e })
      )
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, 'Error getting social redirect uri'),
        r)
      )
    }
  }
  async updateEmail(e) {
    var n
    try {
      const r = await this.appEvent({ type: Re.APP_UPDATE_EMAIL, payload: e })
      return this.setNewLastEmailLoginTime(), r
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error updating email'), r)
      )
    }
  }
  async updateEmailPrimaryOtp(e) {
    var n
    try {
      return this.appEvent({ type: Re.APP_UPDATE_EMAIL_PRIMARY_OTP, payload: e })
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, 'Error updating email primary otp'),
        r)
      )
    }
  }
  async updateEmailSecondaryOtp(e) {
    var n
    try {
      const r = await this.appEvent({ type: Re.APP_UPDATE_EMAIL_SECONDARY_OTP, payload: e })
      return this.setLoginSuccess(r.newEmail), r
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, 'Error updating email secondary otp'),
        r)
      )
    }
  }
  async syncTheme(e) {
    var n
    try {
      return this.appEvent({ type: Re.APP_SYNC_THEME, payload: e })
    } catch (r) {
      throw ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error syncing theme'), r)
    }
  }
  async syncDappData(e) {
    var n
    try {
      return this.appEvent({ type: Re.APP_SYNC_DAPP_DATA, payload: e })
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error syncing dapp data'), r)
      )
    }
  }
  async getSmartAccountEnabledNetworks() {
    var e
    try {
      const n = await this.appEvent({ type: Re.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS })
      return this.persistSmartAccountEnabledNetworks(n.smartAccountEnabledNetworks), n
    } catch (n) {
      throw (
        (this.persistSmartAccountEnabledNetworks([]),
        (e = this.w3mLogger) == null ||
          e.logger.error({ error: n }, 'Error getting smart account enabled networks'),
        n)
      )
    }
  }
  async setPreferredAccount(e) {
    var n
    try {
      return this.appEvent({ type: Re.APP_SET_PREFERRED_ACCOUNT, payload: { type: e } })
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, 'Error setting preferred account'),
        r)
      )
    }
  }
  async connect(e) {
    var n
    try {
      const r = (e == null ? void 0 : e.chainId) || this.getLastUsedChainId() || 1,
        i = await this.appEvent({ type: Re.APP_GET_USER, payload: { ...e, chainId: r } })
      return this.setLoginSuccess(i.email), this.setLastUsedChainId(i.chainId), (this.user = i), i
    } catch (r) {
      throw ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error connecting'), r)
    }
  }
  async getUser(e) {
    var n
    try {
      const r = (e == null ? void 0 : e.chainId) || this.getLastUsedChainId() || 1,
        i = await this.appEvent({ type: Re.APP_GET_USER, payload: { ...e, chainId: r } })
      return (this.user = i), i
    } catch (r) {
      throw ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error connecting'), r)
    }
  }
  async connectSocial(e) {
    var n
    try {
      this.w3mFrame.initFrame()
      const r = await this.appEvent({ type: Re.APP_CONNECT_SOCIAL, payload: { uri: e } })
      return r.userName && this.setSocialLoginSuccess(r.userName), r
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error connecting social'), r)
      )
    }
  }
  async getFarcasterUri() {
    var e
    try {
      return this.w3mFrame.initFrame(), await this.appEvent({ type: Re.APP_GET_FARCASTER_URI })
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: n }, 'Error getting farcaster uri'),
        n)
      )
    }
  }
  async connectFarcaster() {
    var e
    try {
      const n = await this.appEvent({ type: Re.APP_CONNECT_FARCASTER })
      return n.userName && this.setSocialLoginSuccess(n.userName), n
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error connecting farcaster'),
        n)
      )
    }
  }
  async switchNetwork(e) {
    var n
    try {
      const r = await this.appEvent({ type: Re.APP_SWITCH_NETWORK, payload: { chainId: e } })
      return this.setLastUsedChainId(r.chainId), r
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error switching network'), r)
      )
    }
  }
  async disconnect() {
    var e
    try {
      const n = await this.appEvent({ type: Re.APP_SIGN_OUT })
      return this.deleteAuthLoginCache(), n
    } catch (n) {
      throw ((e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error disconnecting'), n)
    }
  }
  async request(e) {
    var n, r, i, s
    try {
      if (yn.GET_CHAIN_ID === e.method) return this.getLastUsedChainId()
      ;(n = this.rpcRequestHandler) == null || n.call(this, e)
      const c = await this.appEvent({ type: Re.APP_RPC_REQUEST, payload: e })
      return (r = this.rpcSuccessHandler) == null || r.call(this, c, e), c
    } catch (c) {
      throw (
        ((i = this.rpcErrorHandler) == null || i.call(this, c, e),
        (s = this.w3mLogger) == null || s.logger.error({ error: c }, 'Error requesting'),
        c)
      )
    }
  }
  onRpcRequest(e) {
    this.rpcRequestHandler = e
  }
  onRpcSuccess(e) {
    this.rpcSuccessHandler = e
  }
  onRpcError(e) {
    this.rpcErrorHandler = e
  }
  onIsConnected(e) {
    this.w3mFrame.events.onFrameEvent(n => {
      n.type === Re.FRAME_IS_CONNECTED_SUCCESS && n.payload.isConnected && e()
    })
  }
  onNotConnected(e) {
    this.w3mFrame.events.onFrameEvent(n => {
      n.type === Re.FRAME_IS_CONNECTED_ERROR && e(),
        n.type === Re.FRAME_IS_CONNECTED_SUCCESS && !n.payload.isConnected && e()
    })
  }
  onConnect(e) {
    this.w3mFrame.events.onFrameEvent(n => {
      n.type === Re.FRAME_GET_USER_SUCCESS && e(n.payload)
    })
  }
  onSocialConnected(e) {
    this.w3mFrame.events.onFrameEvent(n => {
      n.type === Re.FRAME_CONNECT_SOCIAL_SUCCESS && e(n.payload)
    })
  }
  async getCapabilities() {
    try {
      return (await this.request({ method: 'wallet_getCapabilities' })) || {}
    } catch {
      return {}
    }
  }
  onSetPreferredAccount(e) {
    this.w3mFrame.events.onFrameEvent(n => {
      n.type === Re.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS
        ? e(n.payload)
        : n.type === Re.FRAME_SET_PREFERRED_ACCOUNT_ERROR && e({ type: yn.ACCOUNT_TYPES.EOA })
    })
  }
  onGetSmartAccountEnabledNetworks(e) {
    this.w3mFrame.events.onFrameEvent(n => {
      n.type === Re.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS
        ? e(n.payload.smartAccountEnabledNetworks)
        : n.type === Re.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR && e([])
    })
  }
  getAvailableChainIds() {
    return Object.keys(this.w3mFrame.networks)
  }
  rejectRpcRequests() {
    var e
    try {
      this.openRpcRequests.forEach(({ abortController: n, method: r }) => {
        yn.SAFE_RPC_METHODS.includes(r) || n.abort()
      }),
        (this.openRpcRequests = [])
    } catch (n) {
      ;(e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error aborting RPC request')
    }
  }
  async appEvent(e) {
    await this.w3mFrame.frameLoadPromise
    let n
    function r(u) {
      return u.replace('@w3m-app/', '')
    }
    const i = new AbortController(),
      s = r(e.type)
    return (
      [
        Re.APP_CONNECT_EMAIL,
        Re.APP_CONNECT_DEVICE,
        Re.APP_CONNECT_OTP,
        Re.APP_CONNECT_SOCIAL,
        Re.APP_GET_SOCIAL_REDIRECT_URI
      ]
        .map(r)
        .includes(s) &&
        (n = setTimeout(() => {
          var u
          ;(u = this.onTimeout) == null || u.call(this), i.abort()
        }, 3e4)),
      new Promise((u, f) => {
        var g, m, y
        const d = Math.random().toString(36).substring(7)
        if (
          ((y = (g = this.w3mLogger) == null ? void 0 : (m = g.logger).info) == null ||
            y.call(m, { event: e, id: d }, 'Sending app event'),
          this.w3mFrame.events.postAppEvent({ ...e, id: d }),
          s === 'RPC_REQUEST')
        ) {
          const A = e
          this.openRpcRequests = [...this.openRpcRequests, { ...A.payload, abortController: i }]
        }
        i.signal.addEventListener('abort', () => {
          s === 'RPC_REQUEST'
            ? f(new Error('Request was aborted'))
            : s !== 'GET_FARCASTER_URI' && f(new Error('Something went wrong'))
        })
        function p(A, E) {
          var x, O, I
          A.id === d &&
            ((O = E == null ? void 0 : (x = E.logger).info) == null ||
              O.call(x, { framEvent: A, id: d }, 'Received frame response'),
            A.type === `@w3m-frame/${s}_SUCCESS`
              ? (n && clearTimeout(n), 'payload' in A && u(A.payload), u(void 0))
              : A.type === `@w3m-frame/${s}_ERROR` &&
                (n && clearTimeout(n),
                'payload' in A &&
                  f(
                    new Error(((I = A.payload) == null ? void 0 : I.message) || 'An error occurred')
                  ),
                f(new Error('An error occurred'))))
        }
        this.w3mFrame.events.registerFrameEventHandler(d, A => p(A, this.w3mLogger), i.signal)
      })
    )
  }
  setNewLastEmailLoginTime() {
    yr.set(Re.LAST_EMAIL_LOGIN_TIME, Date.now().toString())
  }
  setSocialLoginSuccess(e) {
    yr.set(Re.SOCIAL_USERNAME, e)
  }
  setLoginSuccess(e) {
    e && yr.set(Re.EMAIL, e),
      yr.set(Re.EMAIL_LOGIN_USED_KEY, 'true'),
      yr.delete(Re.LAST_EMAIL_LOGIN_TIME)
  }
  deleteAuthLoginCache() {
    yr.delete(Re.EMAIL_LOGIN_USED_KEY),
      yr.delete(Re.EMAIL),
      yr.delete(Re.LAST_USED_CHAIN_KEY),
      yr.delete(Re.SOCIAL_USERNAME)
  }
  setLastUsedChainId(e) {
    e && yr.set(Re.LAST_USED_CHAIN_KEY, String(e))
  }
  getLastUsedChainId() {
    const e = yr.get(Re.LAST_USED_CHAIN_KEY) ?? void 0,
      n = Number(e)
    return isNaN(n) ? e : n
  }
  persistSmartAccountEnabledNetworks(e) {
    yr.set(Re.SMART_ACCOUNT_ENABLED_NETWORKS, e.join(','))
  }
}
class Bl {
  constructor() {}
  static getInstance({ projectId: e, chainId: n, enableLogger: r, onTimeout: i }) {
    return (
      Bl.instance ||
        (Bl.instance = new Xee({ projectId: e, chainId: n, enableLogger: r, onTimeout: i })),
      Bl.instance
    )
  }
}
const mm = { eip155: void 0, solana: void 0, polkadot: void 0, bip122: void 0 },
  Mi = gn({ providers: { ...mm }, providerIds: { ...mm } }),
  Wt = {
    state: Mi,
    subscribeKey(t, e) {
      return zr(Mi, t, e)
    },
    subscribeProviders(t) {
      return Rr(Mi.providers, () => t(Mi.providers))
    },
    setProvider(t, e) {
      e && (Mi.providers[t] = Zc(e))
    },
    getProvider(t) {
      return Mi.providers[t]
    },
    setProviderId(t, e) {
      e && (Mi.providerIds[t] = e)
    },
    getProviderId(t) {
      if (t) return Mi.providerIds[t]
    },
    reset() {
      ;(Mi.providers = { ...mm }), (Mi.providerIds = { ...mm })
    },
    resetChain(t) {
      ;(Mi.providers[t] = void 0), (Mi.providerIds[t] = void 0)
    }
  }
var F4 = {}
const Jee = {
    ACCOUNT_TABS: [{ label: 'Tokens' }, { label: 'NFTs' }, { label: 'Activity' }],
    SECURE_SITE_ORIGIN:
      (typeof process < 'u' && typeof F4 < 'u' ? F4.NEXT_PUBLIC_SECURE_SITE_ORIGIN : void 0) ||
      'https://secure.walletconnect.org',
    VIEW_DIRECTION: { Next: 'next', Prev: 'prev' },
    DEFAULT_CONNECT_METHOD_ORDER: ['email', 'social', 'wallet'],
    ANIMATION_DURATIONS: { HeaderText: 120, ModalHeight: 150, ViewTransition: 150 }
  },
  hE = {
    filterOutDuplicatesByRDNS(t) {
      const e = be.state.enableEIP6963 ? Ge.state.connectors : [],
        n = Ne.getRecentWallets(),
        r = e
          .map(u => {
            var f
            return (f = u.info) == null ? void 0 : f.rdns
          })
          .filter(Boolean),
        i = n.map(u => u.rdns).filter(Boolean),
        s = r.concat(i)
      if (s.includes('io.metamask.mobile') && $e.isMobile()) {
        const u = s.indexOf('io.metamask.mobile')
        s[u] = 'io.metamask'
      }
      return t.filter(u => !s.includes(String(u == null ? void 0 : u.rdns)))
    },
    filterOutDuplicatesByIds(t) {
      const e = Ge.state.connectors.filter(u => u.type === 'ANNOUNCED' || u.type === 'INJECTED'),
        n = Ne.getRecentWallets(),
        r = e.map(u => u.explorerId),
        i = n.map(u => u.id),
        s = r.concat(i)
      return t.filter(u => !s.includes(u == null ? void 0 : u.id))
    },
    filterOutDuplicateWallets(t) {
      const e = this.filterOutDuplicatesByRDNS(t)
      return this.filterOutDuplicatesByIds(e)
    },
    markWalletsAsInstalled(t) {
      const { connectors: e } = Ge.state,
        n = e
          .filter(s => s.type === 'ANNOUNCED')
          .reduce((s, c) => {
            var u
            return (u = c.info) != null && u.rdns && (s[c.info.rdns] = !0), s
          }, {})
      return t
        .map(s => ({ ...s, installed: !!s.rdns && !!n[s.rdns ?? ''] }))
        .sort((s, c) => Number(c.installed) - Number(s.installed))
    },
    getConnectOrderMethod(t, e) {
      var f
      const n =
          (t == null ? void 0 : t.connectMethodsOrder) ||
          ((f = be.state.features) == null ? void 0 : f.connectMethodsOrder),
        r = e || Ge.state.connectors
      if (n) return n
      const { injected: i, announced: s } = H1.getConnectorsByType(r),
        c = i.filter(H1.showConnector),
        u = s.filter(H1.showConnector)
      return c.length || u.length ? ['wallet', 'email', 'social'] : Jee.DEFAULT_CONNECT_METHOD_ORDER
    }
  },
  H1 = {
    getConnectorsByType(t) {
      const { featured: e, recommended: n } = gt.state,
        { customWallets: r } = be.state,
        i = Ne.getRecentWallets(),
        s = hE.filterOutDuplicateWallets(n),
        c = hE.filterOutDuplicateWallets(e),
        u = t.filter(g => g.type === 'MULTI_CHAIN'),
        f = t.filter(g => g.type === 'ANNOUNCED'),
        d = t.filter(g => g.type === 'INJECTED'),
        p = t.filter(g => g.type === 'EXTERNAL')
      return {
        custom: r,
        recent: i,
        external: p,
        multiChain: u,
        announced: f,
        injected: d,
        recommended: s,
        featured: c
      }
    },
    showConnector(t) {
      var e, n
      if (t.type === 'INJECTED') {
        if (!$e.isMobile() && t.name === 'Browser Wallet') return !1
        const r = (e = t.info) == null ? void 0 : e.rdns
        if (
          (!r && !ot.checkInstalled()) ||
          (r && gt.state.excludedRDNS && gt.state.excludedRDNS.includes(r))
        )
          return !1
      }
      if (t.type === 'ANNOUNCED') {
        const r = (n = t.info) == null ? void 0 : n.rdns
        if (r && gt.state.excludedRDNS.includes(r)) return !1
      }
      return !0
    },
    getIsConnectedWithWC() {
      return Array.from(Q.state.chains.values()).some(
        n => Ge.getConnectorId(n.namespace) === he.CONNECTOR_ID.WALLET_CONNECT
      )
    }
  }
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const kg = globalThis,
  L2 =
    kg.ShadowRoot &&
    (kg.ShadyCSS === void 0 || kg.ShadyCSS.nativeShadow) &&
    'adoptedStyleSheets' in Document.prototype &&
    'replace' in CSSStyleSheet.prototype,
  $2 = Symbol(),
  j4 = new WeakMap()
let G9 = class {
  constructor(e, n, r) {
    if (((this._$cssResult$ = !0), r !== $2))
      throw Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.')
    ;(this.cssText = e), (this.t = n)
  }
  get styleSheet() {
    let e = this.o
    const n = this.t
    if (L2 && e === void 0) {
      const r = n !== void 0 && n.length === 1
      r && (e = j4.get(n)),
        e === void 0 &&
          ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), r && j4.set(n, e))
    }
    return e
  }
  toString() {
    return this.cssText
  }
}
const ki = t => new G9(typeof t == 'string' ? t : t + '', void 0, $2),
  Ll = (t, ...e) => {
    const n =
      t.length === 1
        ? t[0]
        : e.reduce(
            (r, i, s) =>
              r +
              (c => {
                if (c._$cssResult$ === !0) return c.cssText
                if (typeof c == 'number') return c
                throw Error(
                  "Value passed to 'css' function must be a 'css' function result: " +
                    c +
                    ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security."
                )
              })(i) +
              t[s + 1],
            t[0]
          )
    return new G9(n, t, $2)
  },
  ete = (t, e) => {
    if (L2) t.adoptedStyleSheets = e.map(n => (n instanceof CSSStyleSheet ? n : n.styleSheet))
    else
      for (const n of e) {
        const r = document.createElement('style'),
          i = kg.litNonce
        i !== void 0 && r.setAttribute('nonce', i), (r.textContent = n.cssText), t.appendChild(r)
      }
  },
  z4 = L2
    ? t => t
    : t =>
        t instanceof CSSStyleSheet
          ? (e => {
              let n = ''
              for (const r of e.cssRules) n += r.cssText
              return ki(n)
            })(t)
          : t
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const {
    is: tte,
    defineProperty: nte,
    getOwnPropertyDescriptor: rte,
    getOwnPropertyNames: ite,
    getOwnPropertySymbols: ste,
    getPrototypeOf: ate
  } = Object,
  zo = globalThis,
  q4 = zo.trustedTypes,
  ote = q4 ? q4.emptyScript : '',
  G1 = zo.reactiveElementPolyfillSupport,
  ph = (t, e) => t,
  pE = {
    toAttribute(t, e) {
      switch (e) {
        case Boolean:
          t = t ? ote : null
          break
        case Object:
        case Array:
          t = t == null ? t : JSON.stringify(t)
      }
      return t
    },
    fromAttribute(t, e) {
      let n = t
      switch (e) {
        case Boolean:
          n = t !== null
          break
        case Number:
          n = t === null ? null : Number(t)
          break
        case Object:
        case Array:
          try {
            n = JSON.parse(t)
          } catch {
            n = null
          }
      }
      return n
    }
  },
  V9 = (t, e) => !tte(t, e),
  H4 = { attribute: !0, type: String, converter: pE, reflect: !1, hasChanged: V9 }
Symbol.metadata ?? (Symbol.metadata = Symbol('metadata')),
  zo.litPropertyMetadata ?? (zo.litPropertyMetadata = new WeakMap())
let Il = class extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e)
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()]
  }
  static createProperty(e, n = H4) {
    if (
      (n.state && (n.attribute = !1), this._$Ei(), this.elementProperties.set(e, n), !n.noAccessor)
    ) {
      const r = Symbol(),
        i = this.getPropertyDescriptor(e, r, n)
      i !== void 0 && nte(this.prototype, e, i)
    }
  }
  static getPropertyDescriptor(e, n, r) {
    const { get: i, set: s } = rte(this.prototype, e) ?? {
      get() {
        return this[n]
      },
      set(c) {
        this[n] = c
      }
    }
    return {
      get() {
        return i == null ? void 0 : i.call(this)
      },
      set(c) {
        const u = i == null ? void 0 : i.call(this)
        s.call(this, c), this.requestUpdate(e, u, r)
      },
      configurable: !0,
      enumerable: !0
    }
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? H4
  }
  static _$Ei() {
    if (this.hasOwnProperty(ph('elementProperties'))) return
    const e = ate(this)
    e.finalize(),
      e.l !== void 0 && (this.l = [...e.l]),
      (this.elementProperties = new Map(e.elementProperties))
  }
  static finalize() {
    if (this.hasOwnProperty(ph('finalized'))) return
    if (((this.finalized = !0), this._$Ei(), this.hasOwnProperty(ph('properties')))) {
      const n = this.properties,
        r = [...ite(n), ...ste(n)]
      for (const i of r) this.createProperty(i, n[i])
    }
    const e = this[Symbol.metadata]
    if (e !== null) {
      const n = litPropertyMetadata.get(e)
      if (n !== void 0) for (const [r, i] of n) this.elementProperties.set(r, i)
    }
    this._$Eh = new Map()
    for (const [n, r] of this.elementProperties) {
      const i = this._$Eu(n, r)
      i !== void 0 && this._$Eh.set(i, n)
    }
    this.elementStyles = this.finalizeStyles(this.styles)
  }
  static finalizeStyles(e) {
    const n = []
    if (Array.isArray(e)) {
      const r = new Set(e.flat(1 / 0).reverse())
      for (const i of r) n.unshift(z4(i))
    } else e !== void 0 && n.push(z4(e))
    return n
  }
  static _$Eu(e, n) {
    const r = n.attribute
    return r === !1
      ? void 0
      : typeof r == 'string'
        ? r
        : typeof e == 'string'
          ? e.toLowerCase()
          : void 0
  }
  constructor() {
    super(),
      (this._$Ep = void 0),
      (this.isUpdatePending = !1),
      (this.hasUpdated = !1),
      (this._$Em = null),
      this._$Ev()
  }
  _$Ev() {
    var e
    ;(this._$ES = new Promise(n => (this.enableUpdating = n))),
      (this._$AL = new Map()),
      this._$E_(),
      this.requestUpdate(),
      (e = this.constructor.l) == null || e.forEach(n => n(this))
  }
  addController(e) {
    var n
    ;(this._$EO ?? (this._$EO = new Set())).add(e),
      this.renderRoot !== void 0 && this.isConnected && ((n = e.hostConnected) == null || n.call(e))
  }
  removeController(e) {
    var n
    ;(n = this._$EO) == null || n.delete(e)
  }
  _$E_() {
    const e = new Map(),
      n = this.constructor.elementProperties
    for (const r of n.keys()) this.hasOwnProperty(r) && (e.set(r, this[r]), delete this[r])
    e.size > 0 && (this._$Ep = e)
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions)
    return ete(e, this.constructor.elementStyles), e
  }
  connectedCallback() {
    var e
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
      this.enableUpdating(!0),
      (e = this._$EO) == null ||
        e.forEach(n => {
          var r
          return (r = n.hostConnected) == null ? void 0 : r.call(n)
        })
  }
  enableUpdating(e) {}
  disconnectedCallback() {
    var e
    ;(e = this._$EO) == null ||
      e.forEach(n => {
        var r
        return (r = n.hostDisconnected) == null ? void 0 : r.call(n)
      })
  }
  attributeChangedCallback(e, n, r) {
    this._$AK(e, r)
  }
  _$EC(e, n) {
    var s
    const r = this.constructor.elementProperties.get(e),
      i = this.constructor._$Eu(e, r)
    if (i !== void 0 && r.reflect === !0) {
      const c = (
        ((s = r.converter) == null ? void 0 : s.toAttribute) !== void 0 ? r.converter : pE
      ).toAttribute(n, r.type)
      ;(this._$Em = e),
        c == null ? this.removeAttribute(i) : this.setAttribute(i, c),
        (this._$Em = null)
    }
  }
  _$AK(e, n) {
    var s
    const r = this.constructor,
      i = r._$Eh.get(e)
    if (i !== void 0 && this._$Em !== i) {
      const c = r.getPropertyOptions(i),
        u =
          typeof c.converter == 'function'
            ? { fromAttribute: c.converter }
            : ((s = c.converter) == null ? void 0 : s.fromAttribute) !== void 0
              ? c.converter
              : pE
      ;(this._$Em = i), (this[i] = u.fromAttribute(n, c.type)), (this._$Em = null)
    }
  }
  requestUpdate(e, n, r) {
    if (e !== void 0) {
      if ((r ?? (r = this.constructor.getPropertyOptions(e)), !(r.hasChanged ?? V9)(this[e], n)))
        return
      this.P(e, n, r)
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET())
  }
  P(e, n, r) {
    this._$AL.has(e) || this._$AL.set(e, n),
      r.reflect === !0 && this._$Em !== e && (this._$Ej ?? (this._$Ej = new Set())).add(e)
  }
  async _$ET() {
    this.isUpdatePending = !0
    try {
      await this._$ES
    } catch (n) {
      Promise.reject(n)
    }
    const e = this.scheduleUpdate()
    return e != null && (await e), !this.isUpdatePending
  }
  scheduleUpdate() {
    return this.performUpdate()
  }
  performUpdate() {
    var r
    if (!this.isUpdatePending) return
    if (!this.hasUpdated) {
      if ((this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep)) {
        for (const [s, c] of this._$Ep) this[s] = c
        this._$Ep = void 0
      }
      const i = this.constructor.elementProperties
      if (i.size > 0)
        for (const [s, c] of i)
          c.wrapped !== !0 || this._$AL.has(s) || this[s] === void 0 || this.P(s, this[s], c)
    }
    let e = !1
    const n = this._$AL
    try {
      ;(e = this.shouldUpdate(n)),
        e
          ? (this.willUpdate(n),
            (r = this._$EO) == null ||
              r.forEach(i => {
                var s
                return (s = i.hostUpdate) == null ? void 0 : s.call(i)
              }),
            this.update(n))
          : this._$EU()
    } catch (i) {
      throw ((e = !1), this._$EU(), i)
    }
    e && this._$AE(n)
  }
  willUpdate(e) {}
  _$AE(e) {
    var n
    ;(n = this._$EO) == null ||
      n.forEach(r => {
        var i
        return (i = r.hostUpdated) == null ? void 0 : i.call(r)
      }),
      this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(e)),
      this.updated(e)
  }
  _$EU() {
    ;(this._$AL = new Map()), (this.isUpdatePending = !1)
  }
  get updateComplete() {
    return this.getUpdateComplete()
  }
  getUpdateComplete() {
    return this._$ES
  }
  shouldUpdate(e) {
    return !0
  }
  update(e) {
    this._$Ej && (this._$Ej = this._$Ej.forEach(n => this._$EC(n, this[n]))), this._$EU()
  }
  updated(e) {}
  firstUpdated(e) {}
}
;(Il.elementStyles = []),
  (Il.shadowRootOptions = { mode: 'open' }),
  (Il[ph('elementProperties')] = new Map()),
  (Il[ph('finalized')] = new Map()),
  G1 == null || G1({ ReactiveElement: Il }),
  (zo.reactiveElementVersions ?? (zo.reactiveElementVersions = [])).push('2.0.4')
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const gh = globalThis,
  bm = gh.trustedTypes,
  G4 = bm ? bm.createPolicy('lit-html', { createHTML: t => t }) : void 0,
  K9 = '$lit$',
  Co = `lit$${Math.random().toFixed(9).slice(2)}$`,
  W9 = '?' + Co,
  cte = `<${W9}>`,
  fu = document,
  Yh = () => fu.createComment(''),
  Zh = t => t === null || (typeof t != 'object' && typeof t != 'function'),
  F2 = Array.isArray,
  ute = t => F2(t) || typeof (t == null ? void 0 : t[Symbol.iterator]) == 'function',
  V1 = `[ 	
\f\r]`,
  Zf = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
  V4 = /-->/g,
  K4 = />/g,
  Cc = RegExp(
    `>|${V1}(?:([^\\s"'>=/]+)(${V1}*=${V1}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
    'g'
  ),
  W4 = /'/g,
  Q4 = /"/g,
  Q9 = /^(?:script|style|textarea|title)$/i,
  Y9 =
    t =>
    (e, ...n) => ({ _$litType$: t, strings: e, values: n }),
  Ise = Y9(1),
  Ose = Y9(2),
  ld = Symbol.for('lit-noChange'),
  cr = Symbol.for('lit-nothing'),
  Y4 = new WeakMap(),
  kc = fu.createTreeWalker(fu, 129)
function Z9(t, e) {
  if (!F2(t) || !t.hasOwnProperty('raw')) throw Error('invalid template strings array')
  return G4 !== void 0 ? G4.createHTML(e) : e
}
const lte = (t, e) => {
  const n = t.length - 1,
    r = []
  let i,
    s = e === 2 ? '<svg>' : e === 3 ? '<math>' : '',
    c = Zf
  for (let u = 0; u < n; u++) {
    const f = t[u]
    let d,
      p,
      g = -1,
      m = 0
    for (; m < f.length && ((c.lastIndex = m), (p = c.exec(f)), p !== null); )
      (m = c.lastIndex),
        c === Zf
          ? p[1] === '!--'
            ? (c = V4)
            : p[1] !== void 0
              ? (c = K4)
              : p[2] !== void 0
                ? (Q9.test(p[2]) && (i = RegExp('</' + p[2], 'g')), (c = Cc))
                : p[3] !== void 0 && (c = Cc)
          : c === Cc
            ? p[0] === '>'
              ? ((c = i ?? Zf), (g = -1))
              : p[1] === void 0
                ? (g = -2)
                : ((g = c.lastIndex - p[2].length),
                  (d = p[1]),
                  (c = p[3] === void 0 ? Cc : p[3] === '"' ? Q4 : W4))
            : c === Q4 || c === W4
              ? (c = Cc)
              : c === V4 || c === K4
                ? (c = Zf)
                : ((c = Cc), (i = void 0))
    const y = c === Cc && t[u + 1].startsWith('/>') ? ' ' : ''
    s +=
      c === Zf
        ? f + cte
        : g >= 0
          ? (r.push(d), f.slice(0, g) + K9 + f.slice(g) + Co + y)
          : f + Co + (g === -2 ? u : y)
  }
  return [Z9(t, s + (t[n] || '<?>') + (e === 2 ? '</svg>' : e === 3 ? '</math>' : '')), r]
}
class Xh {
  constructor({ strings: e, _$litType$: n }, r) {
    let i
    this.parts = []
    let s = 0,
      c = 0
    const u = e.length - 1,
      f = this.parts,
      [d, p] = lte(e, n)
    if (
      ((this.el = Xh.createElement(d, r)), (kc.currentNode = this.el.content), n === 2 || n === 3)
    ) {
      const g = this.el.content.firstChild
      g.replaceWith(...g.childNodes)
    }
    for (; (i = kc.nextNode()) !== null && f.length < u; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes())
          for (const g of i.getAttributeNames())
            if (g.endsWith(K9)) {
              const m = p[c++],
                y = i.getAttribute(g).split(Co),
                A = /([.?@])?(.*)/.exec(m)
              f.push({
                type: 1,
                index: s,
                name: A[2],
                strings: y,
                ctor: A[1] === '.' ? fte : A[1] === '?' ? hte : A[1] === '@' ? pte : Xm
              }),
                i.removeAttribute(g)
            } else g.startsWith(Co) && (f.push({ type: 6, index: s }), i.removeAttribute(g))
        if (Q9.test(i.tagName)) {
          const g = i.textContent.split(Co),
            m = g.length - 1
          if (m > 0) {
            i.textContent = bm ? bm.emptyScript : ''
            for (let y = 0; y < m; y++)
              i.append(g[y], Yh()), kc.nextNode(), f.push({ type: 2, index: ++s })
            i.append(g[m], Yh())
          }
        }
      } else if (i.nodeType === 8)
        if (i.data === W9) f.push({ type: 2, index: s })
        else {
          let g = -1
          for (; (g = i.data.indexOf(Co, g + 1)) !== -1; )
            f.push({ type: 7, index: s }), (g += Co.length - 1)
        }
      s++
    }
  }
  static createElement(e, n) {
    const r = fu.createElement('template')
    return (r.innerHTML = e), r
  }
}
function dd(t, e, n = t, r) {
  var c, u
  if (e === ld) return e
  let i = r !== void 0 ? ((c = n._$Co) == null ? void 0 : c[r]) : n._$Cl
  const s = Zh(e) ? void 0 : e._$litDirective$
  return (
    (i == null ? void 0 : i.constructor) !== s &&
      ((u = i == null ? void 0 : i._$AO) == null || u.call(i, !1),
      s === void 0 ? (i = void 0) : ((i = new s(t)), i._$AT(t, n, r)),
      r !== void 0 ? ((n._$Co ?? (n._$Co = []))[r] = i) : (n._$Cl = i)),
    i !== void 0 && (e = dd(t, i._$AS(t, e.values), i, r)),
    e
  )
}
class dte {
  constructor(e, n) {
    ;(this._$AV = []), (this._$AN = void 0), (this._$AD = e), (this._$AM = n)
  }
  get parentNode() {
    return this._$AM.parentNode
  }
  get _$AU() {
    return this._$AM._$AU
  }
  u(e) {
    const {
        el: { content: n },
        parts: r
      } = this._$AD,
      i = ((e == null ? void 0 : e.creationScope) ?? fu).importNode(n, !0)
    kc.currentNode = i
    let s = kc.nextNode(),
      c = 0,
      u = 0,
      f = r[0]
    for (; f !== void 0; ) {
      if (c === f.index) {
        let d
        f.type === 2
          ? (d = new Rp(s, s.nextSibling, this, e))
          : f.type === 1
            ? (d = new f.ctor(s, f.name, f.strings, this, e))
            : f.type === 6 && (d = new gte(s, this, e)),
          this._$AV.push(d),
          (f = r[++u])
      }
      c !== (f == null ? void 0 : f.index) && ((s = kc.nextNode()), c++)
    }
    return (kc.currentNode = fu), i
  }
  p(e) {
    let n = 0
    for (const r of this._$AV)
      r !== void 0 &&
        (r.strings !== void 0 ? (r._$AI(e, r, n), (n += r.strings.length - 2)) : r._$AI(e[n])),
        n++
  }
}
class Rp {
  get _$AU() {
    var e
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv
  }
  constructor(e, n, r, i) {
    ;(this.type = 2),
      (this._$AH = cr),
      (this._$AN = void 0),
      (this._$AA = e),
      (this._$AB = n),
      (this._$AM = r),
      (this.options = i),
      (this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0)
  }
  get parentNode() {
    let e = this._$AA.parentNode
    const n = this._$AM
    return n !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = n.parentNode), e
  }
  get startNode() {
    return this._$AA
  }
  get endNode() {
    return this._$AB
  }
  _$AI(e, n = this) {
    ;(e = dd(this, e, n)),
      Zh(e)
        ? e === cr || e == null || e === ''
          ? (this._$AH !== cr && this._$AR(), (this._$AH = cr))
          : e !== this._$AH && e !== ld && this._(e)
        : e._$litType$ !== void 0
          ? this.$(e)
          : e.nodeType !== void 0
            ? this.T(e)
            : ute(e)
              ? this.k(e)
              : this._(e)
  }
  O(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB)
  }
  T(e) {
    this._$AH !== e && (this._$AR(), (this._$AH = this.O(e)))
  }
  _(e) {
    this._$AH !== cr && Zh(this._$AH)
      ? (this._$AA.nextSibling.data = e)
      : this.T(fu.createTextNode(e)),
      (this._$AH = e)
  }
  $(e) {
    var s
    const { values: n, _$litType$: r } = e,
      i =
        typeof r == 'number'
          ? this._$AC(e)
          : (r.el === void 0 && (r.el = Xh.createElement(Z9(r.h, r.h[0]), this.options)), r)
    if (((s = this._$AH) == null ? void 0 : s._$AD) === i) this._$AH.p(n)
    else {
      const c = new dte(i, this),
        u = c.u(this.options)
      c.p(n), this.T(u), (this._$AH = c)
    }
  }
  _$AC(e) {
    let n = Y4.get(e.strings)
    return n === void 0 && Y4.set(e.strings, (n = new Xh(e))), n
  }
  k(e) {
    F2(this._$AH) || ((this._$AH = []), this._$AR())
    const n = this._$AH
    let r,
      i = 0
    for (const s of e)
      i === n.length
        ? n.push((r = new Rp(this.O(Yh()), this.O(Yh()), this, this.options)))
        : (r = n[i]),
        r._$AI(s),
        i++
    i < n.length && (this._$AR(r && r._$AB.nextSibling, i), (n.length = i))
  }
  _$AR(e = this._$AA.nextSibling, n) {
    var r
    for ((r = this._$AP) == null ? void 0 : r.call(this, !1, !0, n); e && e !== this._$AB; ) {
      const i = e.nextSibling
      e.remove(), (e = i)
    }
  }
  setConnected(e) {
    var n
    this._$AM === void 0 && ((this._$Cv = e), (n = this._$AP) == null || n.call(this, e))
  }
}
class Xm {
  get tagName() {
    return this.element.tagName
  }
  get _$AU() {
    return this._$AM._$AU
  }
  constructor(e, n, r, i, s) {
    ;(this.type = 1),
      (this._$AH = cr),
      (this._$AN = void 0),
      (this.element = e),
      (this.name = n),
      (this._$AM = i),
      (this.options = s),
      r.length > 2 || r[0] !== '' || r[1] !== ''
        ? ((this._$AH = Array(r.length - 1).fill(new String())), (this.strings = r))
        : (this._$AH = cr)
  }
  _$AI(e, n = this, r, i) {
    const s = this.strings
    let c = !1
    if (s === void 0)
      (e = dd(this, e, n, 0)), (c = !Zh(e) || (e !== this._$AH && e !== ld)), c && (this._$AH = e)
    else {
      const u = e
      let f, d
      for (e = s[0], f = 0; f < s.length - 1; f++)
        (d = dd(this, u[r + f], n, f)),
          d === ld && (d = this._$AH[f]),
          c || (c = !Zh(d) || d !== this._$AH[f]),
          d === cr ? (e = cr) : e !== cr && (e += (d ?? '') + s[f + 1]),
          (this._$AH[f] = d)
    }
    c && !i && this.j(e)
  }
  j(e) {
    e === cr
      ? this.element.removeAttribute(this.name)
      : this.element.setAttribute(this.name, e ?? '')
  }
}
class fte extends Xm {
  constructor() {
    super(...arguments), (this.type = 3)
  }
  j(e) {
    this.element[this.name] = e === cr ? void 0 : e
  }
}
class hte extends Xm {
  constructor() {
    super(...arguments), (this.type = 4)
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== cr)
  }
}
class pte extends Xm {
  constructor(e, n, r, i, s) {
    super(e, n, r, i, s), (this.type = 5)
  }
  _$AI(e, n = this) {
    if ((e = dd(this, e, n, 0) ?? cr) === ld) return
    const r = this._$AH,
      i =
        (e === cr && r !== cr) ||
        e.capture !== r.capture ||
        e.once !== r.once ||
        e.passive !== r.passive,
      s = e !== cr && (r === cr || i)
    i && this.element.removeEventListener(this.name, this, r),
      s && this.element.addEventListener(this.name, this, e),
      (this._$AH = e)
  }
  handleEvent(e) {
    var n
    typeof this._$AH == 'function'
      ? this._$AH.call(((n = this.options) == null ? void 0 : n.host) ?? this.element, e)
      : this._$AH.handleEvent(e)
  }
}
class gte {
  constructor(e, n, r) {
    ;(this.element = e), (this.type = 6), (this._$AN = void 0), (this._$AM = n), (this.options = r)
  }
  get _$AU() {
    return this._$AM._$AU
  }
  _$AI(e) {
    dd(this, e)
  }
}
const K1 = gh.litHtmlPolyfillSupport
K1 == null || K1(Xh, Rp), (gh.litHtmlVersions ?? (gh.litHtmlVersions = [])).push('3.2.1')
const mte = (t, e, n) => {
  const r = (n == null ? void 0 : n.renderBefore) ?? e
  let i = r._$litPart$
  if (i === void 0) {
    const s = (n == null ? void 0 : n.renderBefore) ?? null
    r._$litPart$ = i = new Rp(e.insertBefore(Yh(), s), s, void 0, n ?? {})
  }
  return i._$AI(t), i
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ class Ug extends Il {
  constructor() {
    super(...arguments), (this.renderOptions = { host: this }), (this._$Do = void 0)
  }
  createRenderRoot() {
    var n
    const e = super.createRenderRoot()
    return (n = this.renderOptions).renderBefore ?? (n.renderBefore = e.firstChild), e
  }
  update(e) {
    const n = this.render()
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
      super.update(e),
      (this._$Do = mte(n, this.renderRoot, this.renderOptions))
  }
  connectedCallback() {
    var e
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0)
  }
  disconnectedCallback() {
    var e
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1)
  }
  render() {
    return ld
  }
}
var O8
;(Ug._$litElement$ = !0),
  (Ug.finalized = !0),
  (O8 = globalThis.litElementHydrateSupport) == null || O8.call(globalThis, { LitElement: Ug })
const W1 = globalThis.litElementPolyfillSupport
W1 == null || W1({ LitElement: Ug })
;(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push('4.1.1')
let mh, qo, Ho
function Rse(t, e) {
  ;(mh = document.createElement('style')),
    (qo = document.createElement('style')),
    (Ho = document.createElement('style')),
    (mh.textContent = $l(t).core.cssText),
    (qo.textContent = $l(t).dark.cssText),
    (Ho.textContent = $l(t).light.cssText),
    document.head.appendChild(mh),
    document.head.appendChild(qo),
    document.head.appendChild(Ho),
    X9(e)
}
function X9(t) {
  qo &&
    Ho &&
    (t === 'light'
      ? (qo.removeAttribute('media'), (Ho.media = 'enabled'))
      : (Ho.removeAttribute('media'), (qo.media = 'enabled')))
}
function bte(t) {
  mh &&
    qo &&
    Ho &&
    ((mh.textContent = $l(t).core.cssText),
    (qo.textContent = $l(t).dark.cssText),
    (Ho.textContent = $l(t).light.cssText))
}
function $l(t) {
  return {
    core: Ll`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${ki(t != null && t['--w3m-color-mix-strength'] ? `${t['--w3m-color-mix-strength']}%` : '0%')};
        --w3m-font-family: ${ki((t == null ? void 0 : t['--w3m-font-family']) || 'Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;')};
        --w3m-font-size-master: ${ki((t == null ? void 0 : t['--w3m-font-size-master']) || '10px')};
        --w3m-border-radius-master: ${ki((t == null ? void 0 : t['--w3m-border-radius-master']) || '4px')};
        --w3m-z-index: ${ki((t == null ? void 0 : t['--w3m-z-index']) || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
    light: Ll`
      :root {
        --w3m-color-mix: ${ki((t == null ? void 0 : t['--w3m-color-mix']) || '#fff')};
        --w3m-accent: ${ki(Ia(t, 'dark')['--w3m-accent'])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${ki(Ia(t, 'dark')['--w3m-background'])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
    dark: Ll`
      :root {
        --w3m-color-mix: ${ki((t == null ? void 0 : t['--w3m-color-mix']) || '#000')};
        --w3m-accent: ${ki(Ia(t, 'light')['--w3m-accent'])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${ki(Ia(t, 'light')['--w3m-background'])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `
  }
}
const Dse = Ll`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`,
  Pse = Ll`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`,
  Mse = Ll`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`,
  yg = {
    ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
    ERROR_CODE_DEFAULT: 5e3,
    ERROR_INVALID_CHAIN_ID: 32603
  },
  yte = U2({
    id: 42161,
    name: 'Arbitrum One',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: { default: { http: ['https://arb1.arbitrum.io/rpc'] } },
    blockExplorers: {
      default: {
        name: 'Arbiscan',
        url: 'https://arbiscan.io',
        apiUrl: 'https://api.arbiscan.io/api'
      }
    },
    contracts: {
      multicall3: { address: '0xca11bde05977b3631167028862be2a173976ca11', blockCreated: 7654707 }
    }
  }),
  vte = U2({
    id: 1,
    name: 'Ethereum',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: { default: { http: ['https://eth.merkle.io'] } },
    blockExplorers: {
      default: {
        name: 'Etherscan',
        url: 'https://etherscan.io',
        apiUrl: 'https://api.etherscan.io/api'
      }
    },
    contracts: {
      ensRegistry: { address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e' },
      ensUniversalResolver: {
        address: '0xce01f8eee7E479C928F8919abD53E553a36CeF67',
        blockCreated: 19258213
      },
      multicall3: { address: '0xca11bde05977b3631167028862be2a173976ca11', blockCreated: 14353601 }
    }
  }),
  wte = U2({
    id: 11155111,
    name: 'Sepolia',
    nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: { default: { http: ['https://sepolia.drpc.org'] } },
    blockExplorers: {
      default: {
        name: 'Etherscan',
        url: 'https://sepolia.etherscan.io',
        apiUrl: 'https://api-sepolia.etherscan.io/api'
      }
    },
    contracts: {
      multicall3: { address: '0xca11bde05977b3631167028862be2a173976ca11', blockCreated: 751532 },
      ensRegistry: { address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e' },
      ensUniversalResolver: {
        address: '0xc8Af999e38273D658BE1b921b88A9Ddf005769cC',
        blockCreated: 5317080
      }
    },
    testnet: !0
  })
function Dp(t) {
  return { formatters: void 0, fees: void 0, serializers: void 0, ...t }
}
const Z4 = Dp({
    id: '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
    name: 'Solana',
    network: 'solana-mainnet',
    nativeCurrency: { name: 'Solana', symbol: 'SOL', decimals: 9 },
    rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
    blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
    testnet: !1,
    chainNamespace: 'solana',
    caipNetworkId: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
    deprecatedCaipNetworkId: 'solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ'
  }),
  X4 = Dp({
    id: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
    name: 'Solana Devnet',
    network: 'solana-devnet',
    nativeCurrency: { name: 'Solana', symbol: 'SOL', decimals: 9 },
    rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
    blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
    testnet: !0,
    chainNamespace: 'solana',
    caipNetworkId: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
    deprecatedCaipNetworkId: 'solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K'
  })
Dp({
  id: '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
  name: 'Solana Testnet',
  network: 'solana-testnet',
  nativeCurrency: { name: 'Solana', symbol: 'SOL', decimals: 9 },
  rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
  blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
  testnet: !0,
  chainNamespace: 'solana',
  caipNetworkId: 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z'
})
Dp({
  id: '000000000019d6689c085ae165831e93',
  caipNetworkId: 'bip122:000000000019d6689c085ae165831e93',
  chainNamespace: 'bip122',
  name: 'Bitcoin',
  nativeCurrency: { name: 'Bitcoin', symbol: 'BTC', decimals: 8 },
  rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } }
})
Dp({
  id: '000000000933ea01ad0ee984209779ba',
  caipNetworkId: 'bip122:000000000933ea01ad0ee984209779ba',
  chainNamespace: 'bip122',
  name: 'Bitcoin Testnet',
  nativeCurrency: { name: 'Bitcoin', symbol: 'BTC', decimals: 8 },
  rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
  testnet: !0
})
const Jm = {
  getMethodsByChainNamespace(t) {
    switch (t) {
      case 'solana':
        return [
          'solana_signMessage',
          'solana_signTransaction',
          'solana_requestAccounts',
          'solana_getAccounts',
          'solana_signAllTransactions',
          'solana_signAndSendTransaction'
        ]
      case 'eip155':
        return [
          'eth_accounts',
          'eth_requestAccounts',
          'eth_sendRawTransaction',
          'eth_sign',
          'eth_signTransaction',
          'eth_signTypedData',
          'eth_signTypedData_v3',
          'eth_signTypedData_v4',
          'eth_sendTransaction',
          'personal_sign',
          'wallet_switchEthereumChain',
          'wallet_addEthereumChain',
          'wallet_getPermissions',
          'wallet_requestPermissions',
          'wallet_registerOnboarding',
          'wallet_watchAsset',
          'wallet_scanQRCode',
          'wallet_getCallsStatus',
          'wallet_showCallsStatus',
          'wallet_sendCalls',
          'wallet_getCapabilities',
          'wallet_grantPermissions',
          'wallet_revokePermissions',
          'wallet_getAssets'
        ]
      case 'bip122':
        return ['sendTransfer', 'signMessage', 'signPsbt', 'getAccountAddresses']
      default:
        return []
    }
  },
  createNamespaces(t) {
    return t.reduce((e, n) => {
      const { id: r, chainNamespace: i, rpcUrls: s } = n,
        c = s.default.http[0],
        u = this.getMethodsByChainNamespace(i)
      e[i] ||
        (e[i] = { methods: u, events: ['accountsChanged', 'chainChanged'], chains: [], rpcMap: {} })
      const f = `${i}:${r}`,
        d = e[i]
      switch ((d.chains.push(f), f)) {
        case Z4.caipNetworkId:
          d.chains.push(Z4.deprecatedCaipNetworkId)
          break
        case X4.caipNetworkId:
          d.chains.push(X4.deprecatedCaipNetworkId)
          break
      }
      return d != null && d.rpcMap && c && (d.rpcMap[r] = c), e
    }, {})
  },
  resolveReownName: async t => {
    var r
    const e = await M9.resolveName(t)
    return (
      ((r = (Object.values(e == null ? void 0 : e.addresses) || [])[0]) == null
        ? void 0
        : r.address) || !1
    )
  },
  getChainsFromNamespaces(t = {}) {
    return Object.values(t).flatMap(e => {
      const n = e.chains || [],
        r = e.accounts.map(i => {
          const [s, c] = i.split(':')
          return `${s}:${c}`
        })
      return Array.from(new Set([...n, ...r]))
    })
  },
  isSessionEventData(t) {
    return (
      typeof t == 'object' &&
      t !== null &&
      'id' in t &&
      'topic' in t &&
      'params' in t &&
      typeof t.params == 'object' &&
      t.params !== null &&
      'chainId' in t.params &&
      'event' in t.params &&
      typeof t.params.event == 'object' &&
      t.params.event !== null
    )
  }
}
class j2 {
  constructor({ provider: e, caipNetworks: n, namespace: r }) {
    ;(this.id = he.CONNECTOR_ID.WALLET_CONNECT),
      (this.name = Lo.ConnectorNamesMap[he.CONNECTOR_ID.WALLET_CONNECT]),
      (this.type = 'WALLET_CONNECT'),
      (this.imageId = Lo.ConnectorImageIds[he.CONNECTOR_ID.WALLET_CONNECT]),
      (this.caipNetworks = n),
      (this.provider = e),
      (this.chain = r)
  }
  get chains() {
    return this.caipNetworks
  }
  async connectWalletConnect() {
    return (
      (await this.authenticate()) ||
        (await this.provider.connect({
          optionalNamespaces: Jm.createNamespaces(this.caipNetworks)
        })),
      {
        clientId: await this.provider.client.core.crypto.getClientId(),
        session: this.provider.session
      }
    )
  }
  async disconnect() {
    await this.provider.disconnect()
  }
  async authenticate() {
    const e = this.chains.map(n => n.caipNetworkId)
    return fh.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains: e,
      methods: Ete
    })
  }
}
const Ete = [
  'eth_accounts',
  'eth_requestAccounts',
  'eth_sendRawTransaction',
  'eth_sign',
  'eth_signTransaction',
  'eth_signTypedData',
  'eth_signTypedData_v3',
  'eth_signTypedData_v4',
  'eth_sendTransaction',
  'personal_sign',
  'wallet_switchEthereumChain',
  'wallet_addEthereumChain',
  'wallet_getPermissions',
  'wallet_requestPermissions',
  'wallet_registerOnboarding',
  'wallet_watchAsset',
  'wallet_scanQRCode',
  'wallet_getCallsStatus',
  'wallet_sendCalls',
  'wallet_getCapabilities',
  'wallet_grantPermissions',
  'wallet_revokePermissions',
  'wallet_getAssets'
]
class J9 {
  constructor(e) {
    ;(this.availableConnectors = []), (this.eventListeners = new Map()), e && this.construct(e)
  }
  construct(e) {
    ;(this.caipNetworks = e.networks),
      (this.projectId = e.projectId),
      (this.namespace = e.namespace)
  }
  get connectors() {
    return this.availableConnectors
  }
  get networks() {
    return this.caipNetworks || []
  }
  setAuthProvider(e) {
    this.addConnector({
      id: he.CONNECTOR_ID.AUTH,
      type: 'AUTH',
      name: he.CONNECTOR_NAMES.AUTH,
      provider: e,
      imageId: Lo.ConnectorImageIds[he.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    })
  }
  addConnector(...e) {
    const n = new Set()
    ;(this.availableConnectors = [...e, ...this.availableConnectors].filter(r =>
      n.has(r.id) ? !1 : (n.add(r.id), !0)
    )),
      this.emit('connectors', this.availableConnectors)
  }
  setStatus(e, n) {
    Oe.setStatus(e, n)
  }
  on(e, n) {
    var r
    this.eventListeners.has(e) || this.eventListeners.set(e, new Set()),
      (r = this.eventListeners.get(e)) == null || r.add(n)
  }
  off(e, n) {
    const r = this.eventListeners.get(e)
    r && r.delete(n)
  }
  removeAllEventListeners() {
    this.eventListeners.forEach(e => {
      e.clear()
    })
  }
  emit(e, n) {
    const r = this.eventListeners.get(e)
    r && r.forEach(i => i(n))
  }
  async connectWalletConnect(e) {
    return { clientId: (await this.getWalletConnectConnector().connectWalletConnect()).clientId }
  }
  async switchNetwork(e) {
    const { caipNetwork: n, providerType: r } = e
    if (!e.provider) return
    const i = 'provider' in e.provider ? e.provider.provider : e.provider
    if (r === 'WALLET_CONNECT') {
      i.setDefaultChain(n.caipNetworkId)
      return
    }
    if (i && r === 'AUTH') {
      const s = i
      await s.switchNetwork(n.caipNetworkId)
      const c = await s.getUser({
        chainId: n.caipNetworkId,
        preferredAccountType: be.state.defaultAccountTypes[n.chainNamespace]
      })
      this.emit('switchNetwork', c)
    }
  }
  getWalletConnectConnector() {
    const e = this.connectors.find(n => n instanceof j2)
    if (!e) throw new Error('WalletConnectConnector not found')
    return e
  }
}
class Ate extends J9 {
  setUniversalProvider(e) {
    this.addConnector(
      new j2({ provider: e, caipNetworks: this.caipNetworks || [], namespace: this.namespace })
    )
  }
  async connect(e) {
    return Promise.resolve({
      id: 'WALLET_CONNECT',
      type: 'WALLET_CONNECT',
      chainId: Number(e.chainId),
      provider: this.provider,
      address: ''
    })
  }
  async disconnect() {
    try {
      await this.getWalletConnectConnector().disconnect()
    } catch (e) {
      console.warn('UniversalAdapter:disconnect - error', e)
    }
  }
  async getAccounts({ namespace: e }) {
    var i, s, c, u
    const n = this.provider,
      r =
        ((u =
          (c =
            (s = (i = n == null ? void 0 : n.session) == null ? void 0 : i.namespaces) == null
              ? void 0
              : s[e]) == null
            ? void 0
            : c.accounts) == null
          ? void 0
          : u
              .map(f => {
                const [, , d] = f.split(':')
                return d
              })
              .filter((f, d, p) => p.indexOf(f) === d)) || []
    return Promise.resolve({
      accounts: r.map(f => $e.createAccount(e, f, e === 'bip122' ? 'payment' : 'eoa'))
    })
  }
  async syncConnectors() {
    return Promise.resolve()
  }
  async getBalance(e) {
    var s, c, u, f, d
    if (
      !(
        e.caipNetwork &&
        Fn.BALANCE_SUPPORTED_CHAINS.includes(
          (s = e.caipNetwork) == null ? void 0 : s.chainNamespace
        )
      ) ||
      ((c = e.caipNetwork) != null && c.testnet)
    )
      return {
        balance: '0.00',
        symbol: ((u = e.caipNetwork) == null ? void 0 : u.nativeCurrency.symbol) || ''
      }
    if (
      Oe.state.balanceLoading &&
      e.chainId === ((f = Q.state.activeCaipNetwork) == null ? void 0 : f.id)
    )
      return { balance: Oe.state.balance || '0.00', symbol: Oe.state.balanceSymbol || '' }
    const i = (await Oe.fetchTokenBalance()).find(p => {
      var g, m
      return (
        p.chainId === `${(g = e.caipNetwork) == null ? void 0 : g.chainNamespace}:${e.chainId}` &&
        p.symbol === ((m = e.caipNetwork) == null ? void 0 : m.nativeCurrency.symbol)
      )
    })
    return {
      balance: (i == null ? void 0 : i.quantity.numeric) || '0.00',
      symbol:
        (i == null ? void 0 : i.symbol) ||
        ((d = e.caipNetwork) == null ? void 0 : d.nativeCurrency.symbol) ||
        ''
    }
  }
  async signMessage(e) {
    var c, u, f
    const { provider: n, message: r, address: i } = e
    if (!n) throw new Error('UniversalAdapter:signMessage - provider is undefined')
    let s = ''
    return (
      ((c = Q.state.activeCaipNetwork) == null ? void 0 : c.chainNamespace) === he.CHAIN.SOLANA
        ? (s = (
            await n.request(
              {
                method: 'solana_signMessage',
                params: { message: rx.encode(new TextEncoder().encode(r)), pubkey: i }
              },
              (u = Q.state.activeCaipNetwork) == null ? void 0 : u.caipNetworkId
            )
          ).signature)
        : (s = await n.request(
            { method: 'personal_sign', params: [r, i] },
            (f = Q.state.activeCaipNetwork) == null ? void 0 : f.caipNetworkId
          )),
      { signature: s }
    )
  }
  async estimateGas() {
    return Promise.resolve({ gas: BigInt(0) })
  }
  async getProfile() {
    return Promise.resolve({ profileImage: '', profileName: '' })
  }
  async sendTransaction() {
    return Promise.resolve({ hash: '' })
  }
  walletGetAssets(e) {
    return Promise.resolve({})
  }
  async writeContract() {
    return Promise.resolve({ hash: '' })
  }
  async getEnsAddress() {
    return Promise.resolve({ address: !1 })
  }
  parseUnits() {
    return 0n
  }
  formatUnits() {
    return '0'
  }
  async getCapabilities() {
    return Promise.resolve({})
  }
  async grantPermissions() {
    return Promise.resolve({})
  }
  async revokePermissions() {
    return Promise.resolve('0x')
  }
  async syncConnection() {
    return Promise.resolve({
      id: 'WALLET_CONNECT',
      type: 'WALLET_CONNECT',
      chainId: 1,
      provider: this.provider,
      address: ''
    })
  }
  async switchNetwork(e) {
    var i, s, c, u, f, d
    const { caipNetwork: n } = e,
      r = this.getWalletConnectConnector()
    if (n.chainNamespace === he.CHAIN.EVM)
      try {
        await ((i = r.provider) == null
          ? void 0
          : i.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: Ba(n.id) }] }))
      } catch (p) {
        if (
          p.code === yg.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
          p.code === yg.ERROR_INVALID_CHAIN_ID ||
          p.code === yg.ERROR_CODE_DEFAULT ||
          ((c = (s = p == null ? void 0 : p.data) == null ? void 0 : s.originalError) == null
            ? void 0
            : c.code) === yg.ERROR_CODE_UNRECOGNIZED_CHAIN_ID
        )
          try {
            await ((d = r.provider) == null
              ? void 0
              : d.request({
                  method: 'wallet_addEthereumChain',
                  params: [
                    {
                      chainId: Ba(n.id),
                      rpcUrls: [
                        (u = n == null ? void 0 : n.rpcUrls.chainDefault) == null ? void 0 : u.http
                      ],
                      chainName: n.name,
                      nativeCurrency: n.nativeCurrency,
                      blockExplorerUrls: [(f = n.blockExplorers) == null ? void 0 : f.default.url]
                    }
                  ]
                }))
          } catch {
            throw new Error('Chain is not supported')
          }
      }
    r.provider.setDefaultChain(n.caipNetworkId)
  }
  getWalletConnectProvider() {
    const e = this.connectors.find(r => r.type === 'WALLET_CONNECT')
    return e == null ? void 0 : e.provider
  }
}
class _te {
  constructor(e) {
    var n
    ;(this.chainNamespaces = []),
      (this.reportedAlertErrors = {}),
      (this.getCaipNetwork = r => {
        var i, s
        if (r) {
          const c = (i = Q.getNetworkData(r)) == null ? void 0 : i.caipNetwork
          return (
            c ||
            ((s = Q.getRequestedCaipNetworks(r).filter(u => u.chainNamespace === r)) == null
              ? void 0
              : s[0])
          )
        }
        return Q.state.activeCaipNetwork || this.defaultCaipNetwork
      }),
      (this.getCaipNetworkId = () => {
        const r = this.getCaipNetwork()
        if (r) return r.id
      }),
      (this.getCaipNetworks = r => Q.getRequestedCaipNetworks(r)),
      (this.getActiveChainNamespace = () => Q.state.activeChain),
      (this.setRequestedCaipNetworks = (r, i) => {
        Q.setRequestedCaipNetworks(r, i)
      }),
      (this.getApprovedCaipNetworkIds = () => Q.getAllApprovedCaipNetworkIds()),
      (this.getCaipAddress = r =>
        Q.state.activeChain === r || !r
          ? Q.state.activeCaipAddress
          : Q.getAccountProp('caipAddress', r)),
      (this.setClientId = r => {
        Me.setClientId(r)
      }),
      (this.getProvider = r => Wt.getProvider(r)),
      (this.getProviderType = r => Wt.getProviderId(r)),
      (this.getPreferredAccountType = () => Oe.state.preferredAccountType),
      (this.setCaipAddress = (r, i) => {
        Oe.setCaipAddress(r, i)
      }),
      (this.setBalance = (r, i, s) => {
        Oe.setBalance(r, i, s)
      }),
      (this.setProfileName = (r, i) => {
        Oe.setProfileName(r, i)
      }),
      (this.setProfileImage = (r, i) => {
        Oe.setProfileImage(r, i)
      }),
      (this.setUser = (r, i) => {
        Oe.setUser(r, i), be.state.enableEmbedded && Kn.close()
      }),
      (this.resetAccount = r => {
        Oe.resetAccount(r)
      }),
      (this.setCaipNetwork = r => {
        Q.setActiveCaipNetwork(r)
      }),
      (this.setCaipNetworkOfNamespace = (r, i) => {
        Q.setChainNetworkData(i, { caipNetwork: r })
      }),
      (this.setAllAccounts = (r, i) => {
        Oe.setAllAccounts(r, i), be.setHasMultipleAddresses((r == null ? void 0 : r.length) > 1)
      }),
      (this.setStatus = (r, i) => {
        Oe.setStatus(r, i),
          Ge.isConnected()
            ? Ne.setConnectionStatus('connected')
            : Ne.setConnectionStatus('disconnected')
      }),
      (this.getAddressByChainNamespace = r => Q.getAccountProp('address', r)),
      (this.setConnectors = r => {
        const i = [...Ge.getConnectors(), ...r]
        Ge.setConnectors(i)
      }),
      (this.fetchIdentity = r => Me.fetchIdentity(r)),
      (this.getReownName = r => M9.getNamesForAddress(r)),
      (this.getConnectors = () => Ge.getConnectors()),
      (this.getConnectorImage = r => K8.getConnectorImage(r)),
      (this.setConnectedWalletInfo = (r, i) => {
        const s = Wt.getProviderId(i),
          c = r ? { ...r, type: s } : void 0
        Oe.setConnectedWalletInfo(c, i)
      }),
      (this.getIsConnectedState = () => !!Q.state.activeCaipAddress),
      (this.addAddressLabel = (r, i, s) => {
        Oe.addAddressLabel(r, i, s)
      }),
      (this.removeAddressLabel = (r, i) => {
        Oe.removeAddressLabel(r, i)
      }),
      (this.getAddress = r =>
        Q.state.activeChain === r || !r ? Oe.state.address : Q.getAccountProp('address', r)),
      (this.setApprovedCaipNetworksData = r => Q.setApprovedCaipNetworksData(r)),
      (this.resetNetwork = r => {
        Q.resetNetwork(r)
      }),
      (this.addConnector = r => {
        Ge.addConnector(r)
      }),
      (this.resetWcConnection = () => {
        ot.resetWcConnection()
      }),
      (this.setAddressExplorerUrl = (r, i) => {
        Oe.setAddressExplorerUrl(r, i)
      }),
      (this.setSmartAccountDeployed = (r, i) => {
        Oe.setSmartAccountDeployed(r, i)
      }),
      (this.setSmartAccountEnabledNetworks = (r, i) => {
        Q.setSmartAccountEnabledNetworks(r, i)
      }),
      (this.setPreferredAccountType = (r, i) => {
        Oe.setPreferredAccountType(r, i)
      }),
      (this.setEIP6963Enabled = r => {
        be.setEIP6963Enabled(r)
      }),
      (this.handleUnsafeRPCRequest = () => {
        if (this.isOpen()) {
          if (this.isTransactionStackEmpty()) return
          this.redirect('ApproveTransaction')
        } else this.open({ view: 'ApproveTransaction' })
      }),
      (this.options = e),
      (this.version = e.sdkVersion),
      (this.caipNetworks = this.extendCaipNetworks(e)),
      (this.chainNamespaces = [
        ...new Set((n = this.caipNetworks) == null ? void 0 : n.map(r => r.chainNamespace))
      ]),
      (this.defaultCaipNetwork = this.extendDefaultCaipNetwork(e)),
      (this.chainAdapters = this.createAdapters(e.adapters)),
      this.initialize(e),
      this.sendInitializeEvent(e)
  }
  async initialize(e) {
    this.initControllers(e),
      await this.initChainAdapters(),
      await this.injectModalUi(),
      await this.syncExistingConnection(),
      Ra.set({ initialized: !0 })
  }
  sendInitializeEvent(e) {
    var r
    const { ...n } = e
    delete n.adapters,
      Ft.sendEvent({
        type: 'track',
        event: 'INITIALIZE',
        properties: {
          ...n,
          networks: e.networks.map(i => i.id),
          siweConfig: { options: ((r = e.siweConfig) == null ? void 0 : r.options) || {} }
        }
      })
  }
  initControllers(e) {
    this.initializeOptionsController(e),
      this.initializeChainController(e),
      this.initializeThemeController(e),
      this.initializeConnectionController(e),
      this.initializeConnectorController()
  }
  initializeThemeController(e) {
    e.themeMode && Ir.setThemeMode(e.themeMode),
      e.themeVariables && Ir.setThemeVariables(e.themeVariables)
  }
  initializeChainController(e) {
    if (!this.connectionControllerClient || !this.networkControllerClient)
      throw new Error('ConnectionControllerClient and NetworkControllerClient must be set')
    Q.initialize(e.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    })
    const n = this.getDefaultNetwork()
    n && Q.setActiveCaipNetwork(n)
  }
  initializeConnectionController(e) {
    ot.setWcBasic(e.basic ?? !1)
  }
  initializeConnectorController() {
    Ge.initialize(this.chainNamespaces)
  }
  initializeOptionsController(e) {
    var i
    be.setDebug(e.debug !== !1),
      be.setEnableWalletConnect(e.enableWalletConnect !== !1),
      be.setEnableWalletGuide(e.enableWalletGuide !== !1),
      be.setEnableWallets(e.enableWallets !== !1),
      be.setEIP6963Enabled(e.enableEIP6963 !== !1),
      be.setEnableAuthLogger(e.enableAuthLogger !== !1),
      be.setSdkVersion(e.sdkVersion),
      be.setProjectId(e.projectId),
      be.setEnableEmbedded(e.enableEmbedded),
      be.setAllWallets(e.allWallets),
      be.setIncludeWalletIds(e.includeWalletIds),
      be.setExcludeWalletIds(e.excludeWalletIds),
      be.setFeaturedWalletIds(e.featuredWalletIds),
      be.setTokens(e.tokens),
      be.setTermsConditionsUrl(e.termsConditionsUrl),
      be.setPrivacyPolicyUrl(e.privacyPolicyUrl),
      be.setCustomWallets(e.customWallets),
      be.setFeatures(e.features),
      be.setAllowUnsupportedChain(e.allowUnsupportedChain),
      be.setDefaultAccountTypes(e.defaultAccountTypes)
    const n = this.getDefaultMetaData()
    if (
      (!e.metadata && n && (e.metadata = n),
      be.setMetadata(e.metadata),
      be.setDisableAppend(e.disableAppend),
      be.setEnableEmbedded(e.enableEmbedded),
      be.setSIWX(e.siwx),
      !e.projectId)
    ) {
      Vc.open(Pl.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, 'error')
      return
    }
    if (
      ((i = e.adapters) == null ? void 0 : i.find(s => s.namespace === he.CHAIN.EVM)) &&
      e.siweConfig
    ) {
      if (e.siwx) throw new Error('Cannot set both `siweConfig` and `siwx` options')
      be.setSIWX(e.siweConfig.mapToSIWX())
    }
  }
  getDefaultMetaData() {
    var e, n, r, i
    return typeof window < 'u' && typeof document < 'u'
      ? {
          name:
            ((n = (e = document.getElementsByTagName('title')) == null ? void 0 : e[0]) == null
              ? void 0
              : n.textContent) || '',
          description:
            ((r = document.querySelector('meta[property="og:description"]')) == null
              ? void 0
              : r.content) || '',
          url: window.location.origin,
          icons: [
            ((i = document.querySelector('link[rel~="icon"]')) == null ? void 0 : i.href) || ''
          ]
        }
      : null
  }
  getUnsupportedNetwork(e) {
    return {
      id: e.split(':')[1],
      caipNetworkId: e,
      name: he.UNSUPPORTED_NETWORK_NAME,
      chainNamespace: e.split(':')[0],
      nativeCurrency: { name: '', decimals: 0, symbol: '' },
      rpcUrls: { default: { http: [] } }
    }
  }
  setUnsupportedNetwork(e) {
    const n = this.getActiveChainNamespace()
    if (n) {
      const r = this.getUnsupportedNetwork(`${n}:${e}`)
      Q.setActiveCaipNetwork(r)
    }
  }
  getDefaultNetwork() {
    var n, r
    const e = Ne.getActiveCaipNetworkId()
    if (e) {
      const i = (n = this.caipNetworks) == null ? void 0 : n.find(s => s.caipNetworkId === e)
      return (
        i || (this.defaultCaipNetwork ? this.defaultCaipNetwork : this.getUnsupportedNetwork(e))
      )
    }
    return this.defaultCaipNetwork
      ? this.defaultCaipNetwork
      : (r = this.caipNetworks) == null
        ? void 0
        : r[0]
  }
  extendCaipNetwork(e, n) {
    return Wc.extendCaipNetwork(e, {
      customNetworkImageUrls: n.chainImages,
      projectId: n.projectId
    })
  }
  extendCaipNetworks(e) {
    return Wc.extendCaipNetworks(e.networks, {
      customNetworkImageUrls: e.chainImages,
      projectId: e.projectId
    })
  }
  extendDefaultCaipNetwork(e) {
    const n = e.networks.find(i => {
      var s
      return i.id === ((s = e.defaultNetwork) == null ? void 0 : s.id)
    })
    return n
      ? Wc.extendCaipNetwork(n, { customNetworkImageUrls: e.chainImages, projectId: e.projectId })
      : void 0
  }
  createClients() {
    ;(this.connectionControllerClient = {
      connectWalletConnect: async () => {
        var s
        const e = Q.state.activeChain,
          n = this.getAdapter(e),
          r = (s = this.getCaipNetwork(e)) == null ? void 0 : s.id
        if (!n) throw new Error('Adapter not found')
        const i = await n.connectWalletConnect(r)
        this.close(),
          this.setClientId((i == null ? void 0 : i.clientId) || null),
          Ne.setConnectedNamespaces([...Q.state.chains.keys()]),
          this.chainNamespaces.forEach(c => {
            Ge.setConnectorId(pn.CONNECTOR_TYPE_WALLET_CONNECT, c)
          }),
          await this.syncWalletConnectAccount()
      },
      connectExternal: async ({
        id: e,
        info: n,
        type: r,
        provider: i,
        chain: s,
        caipNetwork: c
      }) => {
        var y, A, E, x, O, I, M
        const u = Q.state.activeChain,
          f = s || u,
          d = this.getAdapter(f)
        if (s && s !== u && !c) {
          const $ = (y = this.caipNetworks) == null ? void 0 : y.find(D => D.chainNamespace === s)
          $ && this.setCaipNetwork($)
        }
        if (!d) throw new Error('Adapter not found')
        const p = this.getCaipNetwork(f),
          g = await d.connect({
            id: e,
            info: n,
            type: r,
            provider: i,
            chainId: (c == null ? void 0 : c.id) || (p == null ? void 0 : p.id),
            rpcUrl:
              ((x =
                (E = (A = c == null ? void 0 : c.rpcUrls) == null ? void 0 : A.default) == null
                  ? void 0
                  : E.http) == null
                ? void 0
                : x[0]) ||
              ((M =
                (I = (O = p == null ? void 0 : p.rpcUrls) == null ? void 0 : O.default) == null
                  ? void 0
                  : I.http) == null
                ? void 0
                : M[0])
          })
        if (!g) return
        Ne.addConnectedNamespace(f),
          this.syncProvider({ ...g, chainNamespace: f }),
          await this.syncAccount({ ...g, chainNamespace: f })
        const { accounts: m } = await d.getAccounts({ namespace: f, id: e })
        this.setAllAccounts(m, f)
      },
      reconnectExternal: async ({ id: e, info: n, type: r, provider: i }) => {
        var u
        const s = Q.state.activeChain,
          c = this.getAdapter(s)
        c != null &&
          c.reconnect &&
          (await (c == null
            ? void 0
            : c.reconnect({
                id: e,
                info: n,
                type: r,
                provider: i,
                chainId: (u = this.getCaipNetwork()) == null ? void 0 : u.id
              })),
          Ne.addConnectedNamespace(s))
      },
      disconnect: async () => {
        const e = Q.state.activeChain,
          n = this.getAdapter(e),
          r = Wt.getProvider(e),
          i = Wt.getProviderId(e)
        await (n == null ? void 0 : n.disconnect({ provider: r, providerType: i })),
          Ne.removeConnectedNamespace(e),
          Wt.resetChain(e),
          this.setUser(void 0, e),
          this.setStatus('disconnected', e)
      },
      checkInstalled: e =>
        e
          ? e.some(n => {
              var r
              return !!((r = window.ethereum) != null && r[String(n)])
            })
          : !!window.ethereum,
      signMessage: async e => {
        const n = this.getAdapter(Q.state.activeChain),
          r = await (n == null
            ? void 0
            : n.signMessage({
                message: e,
                address: Oe.state.address,
                provider: Wt.getProvider(Q.state.activeChain)
              }))
        return (r == null ? void 0 : r.signature) || ''
      },
      sendTransaction: async e => {
        if (e.chainNamespace === he.CHAIN.EVM) {
          const n = this.getAdapter(Q.state.activeChain),
            r = Wt.getProvider(Q.state.activeChain),
            i = await (n == null ? void 0 : n.sendTransaction({ ...e, provider: r }))
          return (i == null ? void 0 : i.hash) || ''
        }
        return ''
      },
      estimateGas: async e => {
        if (e.chainNamespace === he.CHAIN.EVM) {
          const n = this.getAdapter(Q.state.activeChain),
            r = Wt.getProvider(Q.state.activeChain),
            i = this.getCaipNetwork()
          if (!i) throw new Error('CaipNetwork is undefined')
          const s = await (n == null
            ? void 0
            : n.estimateGas({ ...e, provider: r, caipNetwork: i }))
          return (s == null ? void 0 : s.gas) || 0n
        }
        return 0n
      },
      getEnsAvatar: async () => {
        var r
        const e = this.getAdapter(Q.state.activeChain),
          n = await (e == null
            ? void 0
            : e.getProfile({
                address: Oe.state.address,
                chainId: Number((r = this.getCaipNetwork()) == null ? void 0 : r.id)
              }))
        return (n == null ? void 0 : n.profileImage) || !1
      },
      getEnsAddress: async e => {
        const n = this.getAdapter(Q.state.activeChain),
          r = this.getCaipNetwork()
        if (!r) return !1
        const i = await (n == null ? void 0 : n.getEnsAddress({ name: e, caipNetwork: r }))
        return (i == null ? void 0 : i.address) || !1
      },
      writeContract: async e => {
        const n = this.getAdapter(Q.state.activeChain),
          r = this.getCaipNetwork(),
          i = this.getCaipAddress(),
          s = Wt.getProvider(Q.state.activeChain)
        if (!r || !i) throw new Error('CaipNetwork or CaipAddress is undefined')
        const c = await (n == null
          ? void 0
          : n.writeContract({ ...e, caipNetwork: r, provider: s, caipAddress: i }))
        return c == null ? void 0 : c.hash
      },
      parseUnits: (e, n) => {
        const r = this.getAdapter(Q.state.activeChain)
        return (r == null ? void 0 : r.parseUnits({ value: e, decimals: n })) ?? 0n
      },
      formatUnits: (e, n) => {
        const r = this.getAdapter(Q.state.activeChain)
        return (r == null ? void 0 : r.formatUnits({ value: e, decimals: n })) ?? '0'
      },
      getCapabilities: async e => {
        const n = this.getAdapter(Q.state.activeChain)
        return await (n == null ? void 0 : n.getCapabilities(e))
      },
      grantPermissions: async e => {
        const n = this.getAdapter(Q.state.activeChain)
        return await (n == null ? void 0 : n.grantPermissions(e))
      },
      revokePermissions: async e => {
        const n = this.getAdapter(Q.state.activeChain)
        return n != null && n.revokePermissions ? await n.revokePermissions(e) : '0x'
      },
      walletGetAssets: async e => {
        const n = this.getAdapter(Q.state.activeChain)
        return (await (n == null ? void 0 : n.walletGetAssets(e))) ?? {}
      }
    }),
      (this.networkControllerClient = {
        switchCaipNetwork: async e => await this.switchCaipNetwork(e),
        getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()
      }),
      ot.setClient(this.connectionControllerClient)
  }
  getApprovedCaipNetworksData() {
    var n, r, i, s, c
    if (Wt.getProviderId(Q.state.activeChain) === pn.CONNECTOR_TYPE_WALLET_CONNECT) {
      const u =
        (r = (n = this.universalProvider) == null ? void 0 : n.session) == null
          ? void 0
          : r.namespaces
      return {
        supportsAllNetworks:
          ((c =
            (s = (i = this.universalProvider) == null ? void 0 : i.session) == null
              ? void 0
              : s.peer) == null
            ? void 0
            : c.metadata.name) === 'MetaMask Wallet',
        approvedCaipNetworkIds: this.getChainsFromNamespaces(u)
      }
    }
    return { supportsAllNetworks: !0, approvedCaipNetworkIds: [] }
  }
  async switchCaipNetwork(e) {
    if (!e) return
    const n = e.chainNamespace
    if (this.getAddressByChainNamespace(e.chainNamespace)) {
      const i = Wt.getProvider(n),
        s = Wt.getProviderId(n)
      if (e.chainNamespace === Q.state.activeChain) {
        const c = this.getAdapter(n)
        await (c == null
          ? void 0
          : c.switchNetwork({ caipNetwork: e, provider: i, providerType: s }))
      } else if ((this.setCaipNetwork(e), s === pn.CONNECTOR_TYPE_WALLET_CONNECT))
        this.syncWalletConnectAccount()
      else {
        const c = this.getAddressByChainNamespace(n)
        c && this.syncAccount({ address: c, chainId: e.id, chainNamespace: n })
      }
    } else this.setCaipNetwork(e)
  }
  getChainsFromNamespaces(e = {}) {
    return Object.values(e).flatMap(n => {
      const r = n.chains || [],
        i = n.accounts.map(s => {
          const { chainId: c, chainNamespace: u } = lo.parseCaipAddress(s)
          return `${u}:${c}`
        })
      return Array.from(new Set([...r, ...i]))
    })
  }
  createAdapters(e) {
    return (
      this.createClients(),
      this.chainNamespaces.reduce((n, r) => {
        var s
        const i = e == null ? void 0 : e.find(c => c.namespace === r)
        return (
          i
            ? ((n[r] = i),
              (n[r].namespace = r),
              n[r].construct({
                namespace: r,
                projectId: (s = this.options) == null ? void 0 : s.projectId,
                networks: this.caipNetworks
              }))
            : (n[r] = new Ate({ namespace: r, networks: this.caipNetworks })),
          n
        )
      }, {})
    )
  }
  async initChainAdapter(e) {
    var n
    this.onConnectors(e),
      this.listenAdapter(e),
      (n = this.chainAdapters) == null || n[e].syncConnectors(this.options, this),
      await this.createUniversalProviderForAdapter(e)
  }
  async initChainAdapters() {
    await Promise.all(
      this.chainNamespaces.map(async e => {
        await this.initChainAdapter(e)
      })
    )
  }
  onConnectors(e) {
    const n = this.getAdapter(e)
    n == null || n.on('connectors', this.setConnectors.bind(this))
  }
  listenAdapter(e) {
    const n = this.getAdapter(e)
    if (!n) return
    const r = Ne.getConnectionStatus()
    r === 'connected'
      ? this.setStatus('connecting', e)
      : r === 'disconnected'
        ? (Ne.clearAddressCache(), this.setStatus(r, e))
        : this.setStatus(r, e),
      n.on('switchNetwork', ({ address: i, chainId: s }) => {
        var d
        const c =
            (d = this.caipNetworks) == null
              ? void 0
              : d.find(p => p.id === s || p.caipNetworkId === s),
          u = Q.state.activeChain === e,
          f = Q.getAccountProp('address', e)
        if (c) {
          const p = u && i ? i : f
          p && this.syncAccount({ address: p, chainId: s, chainNamespace: e })
        } else this.setUnsupportedNetwork(s)
      }),
      n.on('disconnect', this.disconnect.bind(this)),
      n.on('pendingTransactions', () => {
        const i = Oe.state.address,
          s = Q.state.activeCaipNetwork
        !i || !(s != null && s.id) || this.updateNativeBalance(i, s.id, s.chainNamespace)
      }),
      n.on('accountChanged', ({ address: i, chainId: s }) => {
        var u, f
        const c = Q.state.activeChain === e
        c && s
          ? this.syncAccount({ address: i, chainId: s, chainNamespace: e })
          : c && (u = Q.state.activeCaipNetwork) != null && u.id
            ? this.syncAccount({
                address: i,
                chainId: (f = Q.state.activeCaipNetwork) == null ? void 0 : f.id,
                chainNamespace: e
              })
            : this.syncAccountInfo(i, s, e)
      })
  }
  async createUniversalProviderForAdapter(e) {
    var n, r, i
    await this.getUniversalProvider(),
      this.universalProvider &&
        ((i =
          (r = (n = this.chainAdapters) == null ? void 0 : n[e]) == null
            ? void 0
            : r.setUniversalProvider) == null ||
          i.call(r, this.universalProvider))
  }
  async syncExistingConnection() {
    await Promise.allSettled(this.chainNamespaces.map(e => this.syncNamespaceConnection(e)))
  }
  async syncNamespaceConnection(e) {
    try {
      const n = Ge.getConnectorId(e)
      switch ((this.setStatus('connecting', e), n)) {
        case he.CONNECTOR_ID.WALLET_CONNECT:
          await this.syncWalletConnectAccount()
          break
        case he.CONNECTOR_ID.AUTH:
          break
        default:
          await this.syncAdapterConnection(e)
      }
    } catch (n) {
      console.warn("AppKit couldn't sync existing connection", n), this.setStatus('disconnected', e)
    }
  }
  async syncAdapterConnection(e) {
    var c, u, f
    const n = this.getAdapter(e),
      r = Ge.getConnectorId(e),
      i = this.getCaipNetwork(),
      s = Ge.getConnectors(e).find(d => d.id === r)
    try {
      if (!n || !s) throw new Error(`Adapter or connector not found for namespace ${e}`)
      if (!(i != null && i.id)) throw new Error('CaipNetwork not found')
      const d = await (n == null
        ? void 0
        : n.syncConnection({
            namespace: e,
            id: s.id,
            chainId: i.id,
            rpcUrl:
              (f =
                (u = (c = i == null ? void 0 : i.rpcUrls) == null ? void 0 : c.default) == null
                  ? void 0
                  : u.http) == null
                ? void 0
                : f[0]
          }))
      if (d) {
        const p = await (n == null ? void 0 : n.getAccounts({ namespace: e, id: s.id }))
        p && p.accounts.length > 0
          ? this.setAllAccounts(p.accounts, e)
          : this.setAllAccounts([$e.createAccount(e, d.address, 'eoa')], e),
          this.syncProvider({ ...d, chainNamespace: e }),
          await this.syncAccount({ ...d, chainNamespace: e }),
          this.setStatus('connected', e)
      } else this.setStatus('disconnected', e)
    } catch {
      this.setStatus('disconnected', e)
    }
  }
  async syncWalletConnectAccount() {
    const e = this.chainNamespaces.map(async n => {
      var u, f, d, p, g
      const r = this.getAdapter(n),
        i =
          ((p =
            (d =
              (f = (u = this.universalProvider) == null ? void 0 : u.session) == null
                ? void 0
                : f.namespaces) == null
              ? void 0
              : d[n]) == null
            ? void 0
            : p.accounts) || [],
        s = (g = Q.state.activeCaipNetwork) == null ? void 0 : g.id,
        c =
          i.find(m => {
            const { chainId: y } = lo.parseCaipAddress(m)
            return y === (s == null ? void 0 : s.toString())
          }) || i[0]
      if (c) {
        const m = lo.validateCaipAddress(c),
          { chainId: y, address: A } = lo.parseCaipAddress(m)
        if (
          (Wt.setProviderId(n, pn.CONNECTOR_TYPE_WALLET_CONNECT),
          this.caipNetworks &&
            Q.state.activeCaipNetwork &&
            (r == null ? void 0 : r.namespace) !== he.CHAIN.EVM)
        ) {
          const E =
            r == null
              ? void 0
              : r.getWalletConnectProvider({
                  caipNetworks: this.caipNetworks,
                  provider: this.universalProvider,
                  activeCaipNetwork: Q.state.activeCaipNetwork
                })
          Wt.setProvider(n, E)
        } else Wt.setProvider(n, this.universalProvider)
        Ge.setConnectorId(he.CONNECTOR_ID.WALLET_CONNECT, n),
          Ne.addConnectedNamespace(n),
          this.syncWalletConnectAccounts(n),
          await this.syncAccount({ address: A, chainId: y, chainNamespace: n })
      } else this.setStatus('disconnected', n)
      await Q.setApprovedCaipNetworksData(n)
    })
    await Promise.all(e)
  }
  syncWalletConnectAccounts(e) {
    var r, i, s, c, u
    const n =
      (u =
        (c =
          (s =
            (i = (r = this.universalProvider) == null ? void 0 : r.session) == null
              ? void 0
              : i.namespaces) == null
            ? void 0
            : s[e]) == null
          ? void 0
          : c.accounts) == null
        ? void 0
        : u
            .map(f => {
              const { address: d } = lo.parseCaipAddress(f)
              return d
            })
            .filter((f, d, p) => p.indexOf(f) === d)
    n &&
      this.setAllAccounts(
        n.map(f => $e.createAccount(e, f, e === 'bip122' ? 'payment' : 'eoa')),
        e
      )
  }
  syncProvider({ type: e, provider: n, id: r, chainNamespace: i }) {
    Wt.setProviderId(i, e), Wt.setProvider(i, n), Ge.setConnectorId(r, i)
  }
  async syncAccount(e) {
    var g, m, y, A, E, x
    const n = e.chainNamespace === Q.state.activeChain,
      r = Q.getCaipNetworkByNamespace(e.chainNamespace, e.chainId),
      { address: i, chainId: s, chainNamespace: c } = e,
      { chainId: u } = Ne.getActiveNetworkProps(),
      f = s || u,
      d =
        ((g = Q.state.activeCaipNetwork) == null ? void 0 : g.name) === he.UNSUPPORTED_NETWORK_NAME,
      p = Q.getNetworkProp('supportsAllNetworks', c)
    if ((this.setStatus('connected', c), !(d && !p) && f)) {
      let O =
          (m = this.caipNetworks) == null ? void 0 : m.find($ => $.id.toString() === f.toString()),
        I = (y = this.caipNetworks) == null ? void 0 : y.find($ => $.chainNamespace === c)
      if (!p && !O && !I) {
        const $ = this.getApprovedCaipNetworkIds() || [],
          D = $.find(z => {
            var G
            return ((G = lo.parseCaipNetworkId(z)) == null ? void 0 : G.chainId) === f.toString()
          }),
          R = $.find(z => {
            var G
            return ((G = lo.parseCaipNetworkId(z)) == null ? void 0 : G.chainNamespace) === c
          })
        ;(O = (A = this.caipNetworks) == null ? void 0 : A.find(z => z.caipNetworkId === D)),
          (I =
            (E = this.caipNetworks) == null
              ? void 0
              : E.find(
                  z =>
                    z.caipNetworkId === R ||
                    ('deprecatedCaipNetworkId' in z && z.deprecatedCaipNetworkId === R)
                ))
      }
      const M = O || I
      ;(M == null ? void 0 : M.chainNamespace) === Q.state.activeChain
        ? !be.state.allowUnsupportedChain &&
          ((x = Q.state.activeCaipNetwork) == null ? void 0 : x.name) ===
            he.UNSUPPORTED_NETWORK_NAME
          ? Q.showUnsupportedChainUI()
          : this.setCaipNetwork(M)
        : n || (r && this.setCaipNetworkOfNamespace(r, c)),
        this.syncConnectedWalletInfo(c),
        U9.isLowerCaseMatch(i, Oe.state.address) ||
          this.syncAccountInfo(i, M == null ? void 0 : M.id, c),
        n
          ? await this.syncBalance({
              address: i,
              chainId: M == null ? void 0 : M.id,
              chainNamespace: c
            })
          : await this.syncBalance({
              address: i,
              chainId: r == null ? void 0 : r.id,
              chainNamespace: c
            })
    }
  }
  async syncAccountInfo(e, n, r) {
    const i = this.getCaipAddress(r),
      s = n || (i == null ? void 0 : i.split(':')[1])
    if (!s) return
    const c = `${r}:${s}:${e}`
    this.setCaipAddress(c, r),
      await this.syncIdentity({ address: e, chainId: s, chainNamespace: r })
  }
  async syncReownName(e, n) {
    try {
      const r = await this.getReownName(e)
      if (r[0]) {
        const i = r[0]
        this.setProfileName(i.name, n)
      } else this.setProfileName(null, n)
    } catch {
      this.setProfileName(null, n)
    }
  }
  syncConnectedWalletInfo(e) {
    var i
    const n = Ge.getConnectorId(e),
      r = Wt.getProviderId(e)
    if (r === pn.CONNECTOR_TYPE_ANNOUNCED || r === pn.CONNECTOR_TYPE_INJECTED) {
      if (n) {
        const s = this.getConnectors().find(c => c.id === n)
        if (s) {
          const { info: c, name: u, imageUrl: f } = s,
            d = f || this.getConnectorImage(s)
          this.setConnectedWalletInfo({ name: u, icon: d, ...c }, e)
        }
      }
    } else if (r === pn.CONNECTOR_TYPE_WALLET_CONNECT) {
      const s = Wt.getProvider(e)
      s != null &&
        s.session &&
        this.setConnectedWalletInfo(
          {
            ...s.session.peer.metadata,
            name: s.session.peer.metadata.name,
            icon: (i = s.session.peer.metadata.icons) == null ? void 0 : i[0]
          },
          e
        )
    } else if (n)
      if (n === he.CONNECTOR_ID.COINBASE) {
        const s = this.getConnectors().find(c => c.id === he.CONNECTOR_ID.COINBASE)
        this.setConnectedWalletInfo({ name: 'Coinbase Wallet', icon: this.getConnectorImage(s) }, e)
      } else this.setConnectedWalletInfo({ name: n }, e)
  }
  async syncBalance(e) {
    !yh.getNetworksByNamespace(this.caipNetworks, e.chainNamespace).find(r => {
      var i
      return r.id.toString() === ((i = e.chainId) == null ? void 0 : i.toString())
    }) ||
      !e.chainId ||
      (await this.updateNativeBalance(e.address, e.chainId, e.chainNamespace))
  }
  async updateNativeBalance(e, n, r) {
    const i = this.getAdapter(r)
    if (i) {
      const s = await i.getBalance({
        address: e,
        chainId: n,
        caipNetwork: this.getCaipNetwork(r),
        tokens: this.options.tokens
      })
      this.setBalance(s.balance, s.symbol, r)
    }
  }
  async initializeUniversalAdapter() {
    var r, i, s, c, u, f, d, p, g, m
    const e = OX.createLogger((y, ...A) => {
        y && this.handleAlertError(y), console.error(...A)
      }),
      n = {
        projectId: (r = this.options) == null ? void 0 : r.projectId,
        metadata: {
          name:
            (i = this.options) != null && i.metadata
              ? (s = this.options) == null
                ? void 0
                : s.metadata.name
              : '',
          description:
            (c = this.options) != null && c.metadata
              ? (u = this.options) == null
                ? void 0
                : u.metadata.description
              : '',
          url:
            (f = this.options) != null && f.metadata
              ? (d = this.options) == null
                ? void 0
                : d.metadata.url
              : '',
          icons:
            (p = this.options) != null && p.metadata
              ? (g = this.options) == null
                ? void 0
                : g.metadata.icons
              : ['']
        },
        logger: e
      }
    be.setManualWCControl(!!((m = this.options) != null && m.manualWCControl)),
      (this.universalProvider = this.options.universalProvider ?? (await eQ.init(n))),
      this.listenWalletConnect()
  }
  listenWalletConnect() {
    this.universalProvider &&
      (this.universalProvider.on('display_uri', e => {
        ot.setUri(e)
      }),
      this.universalProvider.on('connect', ot.finalizeWcConnection),
      this.universalProvider.on('disconnect', () => {
        this.chainNamespaces.forEach(e => {
          this.resetAccount(e)
        }),
          ot.resetWcConnection()
      }),
      this.universalProvider.on('chainChanged', e => {
        var i
        const n = (i = this.caipNetworks) == null ? void 0 : i.find(s => s.id == e),
          r = this.getCaipNetwork()
        if (!n) {
          this.setUnsupportedNetwork(e)
          return
        }
        ;(r == null ? void 0 : r.id) !== (n == null ? void 0 : n.id) && this.setCaipNetwork(n)
      }),
      this.universalProvider.on('session_event', e => {
        if (Jm.isSessionEventData(e)) {
          const { name: n, data: r } = e.params.event
          n === 'accountsChanged' &&
            Array.isArray(r) &&
            $e.isCaipAddress(r[0]) &&
            this.syncAccount(lo.parseCaipAddress(r[0]))
        }
      }))
  }
  createUniversalProvider() {
    var e
    return (
      !this.universalProviderInitPromise &&
        $e.isClient() &&
        (e = this.options) != null &&
        e.projectId &&
        (this.universalProviderInitPromise = this.initializeUniversalAdapter()),
      this.universalProviderInitPromise
    )
  }
  async getUniversalProvider() {
    if (!this.universalProvider)
      try {
        await this.createUniversalProvider()
      } catch {
        throw new Error('AppKit:getUniversalProvider - Cannot create provider')
      }
    return this.universalProvider
  }
  handleAlertError(e) {
    const n = Object.entries(Pl.UniversalProviderErrors).find(([, { message: u }]) =>
        e.message.includes(u)
      ),
      [r, i] = n ?? [],
      { message: s, alertErrorKey: c } = i ?? {}
    if (r && s && !this.reportedAlertErrors[r]) {
      const u = Pl.ALERT_ERRORS[c]
      u && (Vc.open(u, 'error'), (this.reportedAlertErrors[r] = !0))
    }
  }
  getAdapter(e) {
    var n
    if (e) return (n = this.chainAdapters) == null ? void 0 : n[e]
  }
  createAdapter(e) {
    var i
    if (!e) return
    const n = e.namespace
    if (!n) return
    this.createClients()
    const r = e
    ;(r.namespace = n),
      r.construct({
        namespace: n,
        projectId: (i = this.options) == null ? void 0 : i.projectId,
        networks: this.caipNetworks
      }),
      this.chainNamespaces.includes(n) || this.chainNamespaces.push(n),
      this.chainAdapters && (this.chainAdapters[n] = r)
  }
  async open(e) {
    await this.injectModalUi(), e != null && e.uri && ot.setUri(e.uri), await Kn.open(e)
  }
  async close() {
    await this.injectModalUi(), Kn.close()
  }
  setLoading(e, n) {
    Kn.setLoading(e, n)
  }
  async disconnect() {
    await ot.disconnect()
  }
  getError() {
    return ''
  }
  getChainId() {
    var e
    return (e = Q.state.activeCaipNetwork) == null ? void 0 : e.id
  }
  async switchNetwork(e) {
    var r
    const n = (r = this.caipNetworks) == null ? void 0 : r.find(i => i.id === e.id)
    if (!n) {
      Vc.open(Pl.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, 'error')
      return
    }
    await Q.switchActiveNetwork(n)
  }
  getWalletProvider() {
    return Q.state.activeChain ? Wt.state.providers[Q.state.activeChain] : null
  }
  getWalletProviderType() {
    return Wt.getProviderId(Q.state.activeChain)
  }
  subscribeProviders(e) {
    return Wt.subscribeProviders(e)
  }
  getThemeMode() {
    return Ir.state.themeMode
  }
  getThemeVariables() {
    return Ir.state.themeVariables
  }
  setThemeMode(e) {
    Ir.setThemeMode(e), X9(Ir.state.themeMode)
  }
  setTermsConditionsUrl(e) {
    be.setTermsConditionsUrl(e)
  }
  setPrivacyPolicyUrl(e) {
    be.setPrivacyPolicyUrl(e)
  }
  setThemeVariables(e) {
    Ir.setThemeVariables(e), bte(Ir.state.themeVariables)
  }
  subscribeTheme(e) {
    return Ir.subscribe(e)
  }
  getWalletInfo() {
    return Oe.state.connectedWalletInfo
  }
  getAccount(e) {
    const n = Ge.getAuthConnector(e),
      r = Q.getAccountData(e)
    if (r)
      return {
        allAccounts: r.allAccounts,
        caipAddress: r.caipAddress,
        address: $e.getPlainAddress(r.caipAddress),
        isConnected: !!r.caipAddress,
        status: r.status,
        embeddedWalletInfo: n
          ? {
              user: r.user,
              authProvider: r.socialProvider || 'email',
              accountType: r.preferredAccountType,
              isSmartAccountDeployed: !!r.smartAccountDeployed
            }
          : void 0
      }
  }
  subscribeAccount(e, n) {
    const r = () => {
      const i = this.getAccount(n)
      i && e(i)
    }
    n ? Q.subscribeChainProp('accountState', r, n) : Q.subscribe(r), Ge.subscribe(r)
  }
  subscribeNetwork(e) {
    return Q.subscribe(({ activeCaipNetwork: n }) => {
      e({
        caipNetwork: n,
        chainId: n == null ? void 0 : n.id,
        caipNetworkId: n == null ? void 0 : n.caipNetworkId
      })
    })
  }
  subscribeWalletInfo(e) {
    return Oe.subscribeKey('connectedWalletInfo', e)
  }
  subscribeShouldUpdateToAddress(e) {
    Oe.subscribeKey('shouldUpdateToAddress', e)
  }
  subscribeCaipNetworkChange(e) {
    Q.subscribeKey('activeCaipNetwork', e)
  }
  getState() {
    return Ra.state
  }
  subscribeState(e) {
    return Ra.subscribe(e)
  }
  showErrorMessage(e) {
    $t.showError(e)
  }
  showSuccessMessage(e) {
    $t.showSuccess(e)
  }
  getEvent() {
    return { ...Ft.state }
  }
  subscribeEvents(e) {
    return Ft.subscribe(e)
  }
  replace(e) {
    ct.replace(e)
  }
  redirect(e) {
    ct.push(e)
  }
  popTransactionStack(e) {
    ct.popTransactionStack(e)
  }
  isOpen() {
    return Kn.state.open
  }
  isTransactionStackEmpty() {
    return ct.state.transactionStack.length === 0
  }
  isTransactionShouldReplaceView() {
    var e
    return (e = ct.state.transactionStack[ct.state.transactionStack.length - 1]) == null
      ? void 0
      : e.replace
  }
  static getInstance() {
    return this.instance
  }
  updateFeatures(e) {
    be.setFeatures(e)
  }
  updateOptions(e) {
    const r = { ...(be.state || {}), ...e }
    be.setOptions(r)
  }
  setConnectMethodsOrder(e) {
    be.setConnectMethodsOrder(e)
  }
  setWalletFeaturesOrder(e) {
    be.setWalletFeaturesOrder(e)
  }
  setCollapseWallets(e) {
    be.setCollapseWallets(e)
  }
  setSocialsOrder(e) {
    be.setSocialsOrder(e)
  }
  getConnectMethodsOrder() {
    return hE.getConnectOrderMethod(be.state.features, Ge.getConnectors())
  }
  removeAdapter(e) {
    var s
    const n = this.getIsConnectedState(),
      r = this.getAdapter(e)
    if (!r || !this.chainAdapters || n) return
    const i = (s = this.caipNetworks) == null ? void 0 : s.filter(c => c.chainNamespace !== e)
    Q.removeAdapter(e),
      Ge.removeAdapter(e),
      (this.chainNamespaces = this.chainNamespaces.filter(c => c !== e)),
      (this.caipNetworks = i),
      r.removeAllEventListeners(),
      Reflect.deleteProperty(this.chainAdapters, e)
  }
  addAdapter(e, n) {
    const r = e.namespace
    if (
      !this.connectionControllerClient ||
      !this.networkControllerClient ||
      !this.chainAdapters ||
      !r
    )
      return
    const i = this.extendCaipNetworks({ ...this.options, networks: n })
    ;(this.caipNetworks = [...(this.caipNetworks || []), ...i]),
      this.createAdapter(e),
      this.initChainAdapter(r),
      Q.addAdapter(
        e,
        {
          connectionControllerClient: this.connectionControllerClient,
          networkControllerClient: this.networkControllerClient
        },
        i
      )
  }
  addNetwork(e, n) {
    var i
    if (this.chainAdapters && !this.chainAdapters[e])
      throw new Error(`Adapter for namespace ${e} doesn't exist`)
    const r = this.extendCaipNetwork(n, this.options)
    Q.addNetwork(r),
      this.caipNetworks &&
        !((i = this.caipNetworks) != null && i.find(s => s.id === r.id)) &&
        this.caipNetworks.push(r)
  }
  removeNetwork(e, n) {
    var s
    if (this.chainAdapters && !this.chainAdapters[e])
      throw new Error(`Adapter for namespace ${e} doesn't exist`)
    if (!((s = this.caipNetworks) == null ? void 0 : s.find(c => c.id === n)))
      throw new Error(`Network with ID ${n} not found`)
    if (!this.caipNetworks) return
    const i = this.caipNetworks.filter(c => c.chainNamespace === e && c.id !== n)
    if (!(i != null && i.length)) throw new Error('Cannot remove last network for a namespace')
    Q.removeNetwork(e, n), (this.caipNetworks = [...i])
  }
}
let J4 = !1
class Cte extends _te {
  setupAuthConnectorListeners(e) {
    e.onRpcRequest(n => {
      gi.checkIfRequestExists(n)
        ? gi.checkIfRequestIsSafe(n) || this.handleUnsafeRPCRequest()
        : (this.open(),
          console.error(yn.RPC_METHOD_NOT_ALLOWED_MESSAGE, { method: n.method }),
          setTimeout(() => {
            this.showErrorMessage(yn.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE)
          }, 300),
          e.rejectRpcRequests())
    }),
      e.onRpcError(() => {
        this.isOpen() &&
          (this.isTransactionStackEmpty() ? this.close() : this.popTransactionStack(!0))
      }),
      e.onRpcSuccess((n, r) => {
        const i = gi.checkIfRequestIsSafe(r),
          s = Oe.state.address,
          c = Q.state.activeCaipNetwork
        i ||
          (this.isTransactionStackEmpty()
            ? (this.close(),
              s && c != null && c.id && this.updateNativeBalance(s, c.id, c.chainNamespace))
            : (this.popTransactionStack(),
              s && c != null && c.id && this.updateNativeBalance(s, c.id, c.chainNamespace)))
      }),
      e.onNotConnected(() => {
        const n = Q.state.activeChain
        Ge.getConnectorId(n) === he.CONNECTOR_ID.AUTH &&
          (this.setCaipAddress(void 0, n), this.setLoading(!1, n))
      }),
      e.onConnect(async n => {
        var u
        const r = Q.state.activeChain,
          i = r === he.CHAIN.EVM ? `eip155:${n.chainId}:${n.address}` : `${n.chainId}:${n.address}`
        this.setSmartAccountDeployed(!!n.smartAccountDeployed, r),
          U9.isLowerCaseMatch(n.address, Oe.state.address) ||
            this.syncIdentity({ address: n.address, chainId: n.chainId, chainNamespace: r }),
          this.setCaipAddress(i, r),
          this.setUser({ ...(Oe.state.user || {}), email: n.email }, r)
        const s = n.preferredAccountType || be.state.defaultAccountTypes[r]
        this.setPreferredAccountType(s, r)
        const c =
          (u = n.accounts) == null
            ? void 0
            : u.map(f => $e.createAccount(r, f.address, f.type || be.state.defaultAccountTypes[r]))
        this.setAllAccounts(c || [$e.createAccount(r, n.address, s)], r),
          await e.getSmartAccountEnabledNetworks(),
          this.setLoading(!1, r)
      }),
      e.onSocialConnected(({ userName: n }) => {
        this.setUser({ ...(Oe.state.user || {}), username: n }, Q.state.activeChain)
      }),
      e.onGetSmartAccountEnabledNetworks(n => {
        this.setSmartAccountEnabledNetworks(n, Q.state.activeChain)
      }),
      e.onSetPreferredAccount(({ address: n, type: r }) => {
        n && this.setPreferredAccountType(r, Q.state.activeChain)
      })
  }
  async syncAuthConnector(e, n) {
    var p, g, m, y
    const r = he.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(n)
    if (!r) return
    this.setLoading(!0, n)
    const i = e.getLoginEmailUsed()
    this.setLoading(i, n), i && this.setStatus('connecting', n)
    const s = e.getEmail(),
      c = e.getUsername()
    this.setUser(
      { ...(((p = Oe.state) == null ? void 0 : p.user) || {}), username: c, email: s },
      Q.state.activeChain
    ),
      this.setupAuthConnectorListeners(e)
    const { isConnected: u } = await e.isConnected(),
      f = Ir.getSnapshot(),
      d = be.getSnapshot()
    e.syncDappData({
      metadata: d.metadata,
      sdkVersion: d.sdkVersion,
      projectId: d.projectId,
      sdkType: d.sdkType
    }),
      e.syncTheme({
        themeMode: f.themeMode,
        themeVariables: f.themeVariables,
        w3mThemeVariables: Ia(f.themeVariables, f.themeMode)
      }),
      n &&
        r &&
        (u && (g = this.connectionControllerClient) != null && g.connectExternal
          ? (await ((y = this.connectionControllerClient) == null
              ? void 0
              : y.connectExternal({
                  id: he.CONNECTOR_ID.AUTH,
                  info: { name: he.CONNECTOR_ID.AUTH },
                  type: pn.CONNECTOR_TYPE_AUTH,
                  provider: e,
                  chainId: (m = Q.state.activeCaipNetwork) == null ? void 0 : m.id,
                  chain: n
                })),
            this.setStatus('connected', n))
          : Ge.getConnectorId(n) === he.CONNECTOR_ID.AUTH &&
            (this.setStatus('disconnected', n), Ne.removeConnectedNamespace(n))),
      this.setLoading(!1, n)
  }
  async checkExistingTelegramSocialConnection(e) {
    var n
    try {
      if (!$e.isTelegram()) return
      const r = Ne.getTelegramSocialProvider()
      if (!r || typeof window > 'u' || typeof document > 'u') return
      const s = new URL(window.location.href).searchParams.get('result_uri')
      if (!s) return
      Oe.setSocialProvider(r, e), await ((n = this.authProvider) == null ? void 0 : n.init())
      const c = Ge.getAuthConnector()
      r &&
        c &&
        (this.setLoading(!0, e),
        await c.provider.connectSocial(s),
        await ot.connectExternal(c, c.chain),
        Ne.setConnectedSocialProvider(r),
        Ne.removeTelegramSocialProvider(),
        Ft.sendEvent({ type: 'track', event: 'SOCIAL_LOGIN_SUCCESS', properties: { provider: r } }))
    } catch (r) {
      this.setLoading(!1, e), console.error('checkExistingSTelegramocialConnection error', r)
    }
    try {
      const r = new URL(window.location.href)
      r.searchParams.delete('result_uri'),
        window.history.replaceState({}, document.title, r.toString())
    } catch (r) {
      console.error('tma social login failed', r)
    }
  }
  createAuthProvider(e) {
    var c, u, f, d, p, g, m, y, A, E, x
    if (!he.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(e)) return
    const r =
        ((u = (c = this.options) == null ? void 0 : c.features) == null ? void 0 : u.email) ===
        void 0
          ? Fn.DEFAULT_FEATURES.email
          : (d = (f = this.options) == null ? void 0 : f.features) == null
            ? void 0
            : d.email,
      i =
        (g = (p = this.options) == null ? void 0 : p.features) != null && g.socials
          ? ((A =
              (y = (m = this.options) == null ? void 0 : m.features) == null
                ? void 0
                : y.socials) == null
              ? void 0
              : A.length) > 0
          : Fn.DEFAULT_FEATURES.socials,
      s = r || i
    !this.authProvider &&
      (E = this.options) != null &&
      E.projectId &&
      s &&
      ((this.authProvider = Bl.getInstance({
        projectId: this.options.projectId,
        enableLogger: this.options.enableAuthLogger,
        chainId: (x = this.getCaipNetwork(e)) == null ? void 0 : x.caipNetworkId,
        onTimeout: () => {
          Vc.open(Pl.ALERT_ERRORS.SOCIALS_TIMEOUT, 'error')
        }
      })),
      this.subscribeState(O => {
        var I
        O.open || (I = this.authProvider) == null || I.rejectRpcRequests()
      }),
      this.syncAuthConnector(this.authProvider, e),
      this.checkExistingTelegramSocialConnection(e))
  }
  createAuthProviderForAdapter(e) {
    var n, r, i
    this.createAuthProvider(e),
      this.authProvider &&
        ((i =
          (r = (n = this.chainAdapters) == null ? void 0 : n[e]) == null
            ? void 0
            : r.setAuthProvider) == null ||
          i.call(r, this.authProvider))
  }
  initControllers(e) {
    super.initControllers(e),
      this.options.excludeWalletIds &&
        gt.initializeExcludedWalletRdns({ ids: this.options.excludeWalletIds })
  }
  async switchCaipNetwork(e) {
    var s, c
    if (!e) return
    const n = Q.state.activeChain,
      r = e.chainNamespace,
      i = this.getAddressByChainNamespace(e.chainNamespace)
    if (e.chainNamespace === Q.state.activeChain && i) {
      const u = this.getAdapter(r),
        f = Wt.getProvider(r),
        d = Wt.getProviderId(r)
      await (u == null
        ? void 0
        : u.switchNetwork({ caipNetwork: e, provider: f, providerType: d })),
        this.setCaipNetwork(e)
    } else {
      const f = Wt.getProviderId(n) === pn.CONNECTOR_TYPE_AUTH,
        d = Wt.getProviderId(r),
        p = d === pn.CONNECTOR_TYPE_AUTH,
        g = he.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(r)
      if ((f || p) && g)
        try {
          ;(Q.state.activeChain = e.chainNamespace),
            await ((c =
              (s = this.connectionControllerClient) == null ? void 0 : s.connectExternal) == null
              ? void 0
              : c.call(s, {
                  id: he.CONNECTOR_ID.AUTH,
                  provider: this.authProvider,
                  chain: r,
                  chainId: e.id,
                  type: pn.CONNECTOR_TYPE_AUTH,
                  caipNetwork: e
                })),
            this.setCaipNetwork(e)
        } catch {
          const y = this.getAdapter(r)
          await (y == null
            ? void 0
            : y.switchNetwork({ caipNetwork: e, provider: this.authProvider, providerType: d }))
        }
      else
        d === pn.CONNECTOR_TYPE_WALLET_CONNECT
          ? (this.setCaipNetwork(e), this.syncWalletConnectAccount())
          : (this.setCaipNetwork(e),
            i && this.syncAccount({ address: i, chainId: e.id, chainNamespace: r }))
    }
  }
  async initChainAdapter(e) {
    await super.initChainAdapter(e), this.createAuthProviderForAdapter(e)
  }
  async syncIdentity({ address: e, chainId: n, chainNamespace: r }) {
    var c
    const i = `${r}:${n}`,
      s = (c = this.caipNetworks) == null ? void 0 : c.find(u => u.caipNetworkId === i)
    if (r !== he.CHAIN.EVM || (s != null && s.testnet)) {
      this.setProfileName(null, r), this.setProfileImage(null, r)
      return
    }
    try {
      const { name: u, avatar: f } = await this.fetchIdentity({ address: e, caipNetworkId: i })
      if ((this.setProfileName(u, r), this.setProfileImage(f, r), !u)) {
        const d = this.getAdapter(r),
          p = await (d == null ? void 0 : d.getProfile({ address: e, chainId: Number(n) }))
        p != null && p.profileName
          ? (this.setProfileName(p.profileName, r),
            p.profileImage && this.setProfileImage(p.profileImage, r))
          : (await this.syncReownName(e, r), this.setProfileImage(null, r))
      }
    } catch {
      await this.syncReownName(e, r), n !== 1 && this.setProfileImage(null, r)
    }
  }
  syncConnectedWalletInfo(e) {
    const n = Wt.getProviderId(e)
    if (n === pn.CONNECTOR_TYPE_AUTH) {
      const r = this.authProvider
      if (r) {
        const i = Ne.getConnectedSocialProvider() ?? 'email',
          s = r.getEmail() ?? r.getUsername()
        this.setConnectedWalletInfo({ name: n, identifier: s, social: i }, e)
      }
    } else super.syncConnectedWalletInfo(e)
  }
  async injectModalUi() {
    if (!J4 && $e.isClient()) {
      const e = { ...Fn.DEFAULT_FEATURES, ...this.options.features },
        n = []
      if (
        (e &&
          ((e.email || (e.socials && e.socials.length)) &&
            n.push(
              ei(
                () => import('./embedded-wallet-CalfqdNI.js'),
                __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
              )
            ),
          e.email &&
            n.push(
              ei(() => import('./email-5kUJw0ce.js'), __vite__mapDeps([10, 1, 9, 5, 8, 4, 11, 6]))
            ),
          e.socials &&
            n.push(
              ei(
                () => import('./socials-Uau0-5BN.js'),
                __vite__mapDeps([12, 1, 13, 4, 5, 14, 8, 9, 15, 3, 16])
              )
            ),
          e.swaps &&
            n.push(
              ei(
                () => import('./swaps-BYyffamV.js'),
                __vite__mapDeps([17, 1, 4, 5, 18, 19, 16, 20, 3, 8, 6])
              )
            ),
          e.send &&
            n.push(
              ei(
                () => import('./send-CrjHOw2Z.js'),
                __vite__mapDeps([21, 1, 4, 5, 8, 9, 20, 3, 6, 22])
              )
            ),
          e.receive &&
            n.push(ei(() => import('./receive-BTHURE40.js'), __vite__mapDeps([23, 1, 24, 3, 15]))),
          e.onramp &&
            n.push(
              ei(
                () => import('./onramp-BzOH_Bbb.js'),
                __vite__mapDeps([25, 1, 26, 16, 8, 3, 5, 27, 13, 4, 9, 6])
              )
            ),
          e.history &&
            n.push(
              ei(
                () => import('./transactions-C-U2YbwL.js'),
                __vite__mapDeps([28, 1, 29, 26, 16, 8, 9, 3])
              )
            )),
        await Promise.all([
          ...n,
          ei(
            () => import('./index-DHeF6YgC.js'),
            __vite__mapDeps([
              30, 1, 3, 5, 22, 8, 31, 19, 7, 27, 4, 29, 26, 16, 9, 18, 6, 11, 13, 14, 2, 24, 15
            ])
          ),
          ei(() => import('./w3m-modal-2k5y_YMI.js'), __vite__mapDeps([32, 1, 7, 3, 8, 5, 19, 31]))
        ]),
        !document.querySelector('w3m-modal'))
      ) {
        const i = document.createElement('w3m-modal')
        !be.state.disableAppend &&
          !be.state.enableEmbedded &&
          document.body.insertAdjacentElement('beforeend', i)
      }
      J4 = !0
    }
  }
}
let wt
function Ste(t) {
  t && (wt = t)
}
function Tte() {
  if (!wt) throw new Error('Please call "createAppKit" before using "useAppKitTheme" hook')
  function t(c) {
    c && (wt == null || wt.setThemeMode(c))
  }
  function e(c) {
    c && (wt == null || wt.setThemeVariables(c))
  }
  const [n, r] = Le.useState(wt.getThemeMode()),
    [i, s] = Le.useState(wt.getThemeVariables())
  return (
    Le.useEffect(() => {
      const c =
        wt == null
          ? void 0
          : wt.subscribeTheme(u => {
              r(u.themeMode), s(u.themeVariables)
            })
      return () => {
        c == null || c()
      }
    }, []),
    { themeMode: n, themeVariables: i, setThemeMode: t, setThemeVariables: e }
  )
}
function xte() {
  if (!wt) throw new Error('Please call "createAppKit" before using "useAppKit" hook')
  async function t(n) {
    await (wt == null ? void 0 : wt.open(n))
  }
  async function e() {
    await (wt == null ? void 0 : wt.close())
  }
  return { open: t, close: e }
}
function Nte() {
  if (!wt) throw new Error('Please call "createAppKit" before using "useWalletInfo" hook')
  return {
    walletInfo: Le.useSyncExternalStore(wt.subscribeWalletInfo, wt.getWalletInfo, wt.getWalletInfo)
  }
}
function Ite() {
  if (!wt) throw new Error('Please call "createAppKit" before using "useAppKitState" hook')
  const [t, e] = Le.useState(wt.getState())
  return (
    Le.useEffect(() => {
      const n =
        wt == null
          ? void 0
          : wt.subscribeState(r => {
              e({ ...r })
            })
      return () => {
        n == null || n()
      }
    }, []),
    t
  )
}
function Ote() {
  if (!wt) throw new Error('Please call "createAppKit" before using "useAppKitEvents" hook')
  const [t, e] = Le.useState(wt.getEvent())
  return (
    Le.useEffect(() => {
      const n =
        wt == null
          ? void 0
          : wt.subscribeEvents(r => {
              e({ ...r })
            })
      return () => {
        n == null || n()
      }
    }, []),
    t
  )
}
const Rte = '1.7.0'
let Uc
function Dte(t) {
  return (
    Uc ||
      ((Uc = new Cte({ ...t, sdkVersion: $e.generateSdkVersion(t.adapters ?? [], 'react', Rte) })),
      Ste(Uc)),
    Uc
  )
}
function eI() {
  const { caipNetwork: t, caipNetworkId: e, chainId: n } = xX()
  function r(i) {
    Uc == null || Uc.switchNetwork(i)
  }
  return { caipNetwork: t, caipNetworkId: e, chainId: n, switchNetwork: r }
}
function Fr(t, e, n) {
  const r = t[e.name]
  if (typeof r == 'function') return r
  const i = t[n]
  return typeof i == 'function' ? i : s => e(t, s)
}
const Bg = '2.16.7',
  Pte = () => `@wagmi/core@${Bg}`
var tI = function (t, e, n, r) {
    if (n === 'a' && !r) throw new TypeError('Private accessor was defined without a getter')
    if (typeof e == 'function' ? t !== e || !r : !e.has(t))
      throw new TypeError(
        'Cannot read private member from an object whose class did not declare it'
      )
    return n === 'm' ? r : n === 'a' ? r.call(t) : r ? r.value : e.get(t)
  },
  ym,
  nI
let ja = class gE extends Error {
  get docsBaseUrl() {
    return 'https://wagmi.sh/core'
  }
  get version() {
    return Pte()
  }
  constructor(e, n = {}) {
    var s
    super(),
      ym.add(this),
      Object.defineProperty(this, 'details', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'docsPath', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'metaMessages', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'shortMessage', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'WagmiCoreError'
      })
    const r =
        n.cause instanceof gE
          ? n.cause.details
          : (s = n.cause) != null && s.message
            ? n.cause.message
            : n.details,
      i = (n.cause instanceof gE && n.cause.docsPath) || n.docsPath
    ;(this.message = [
      e || 'An error occurred.',
      '',
      ...(n.metaMessages ? [...n.metaMessages, ''] : []),
      ...(i ? [`Docs: ${this.docsBaseUrl}${i}.html${n.docsSlug ? `#${n.docsSlug}` : ''}`] : []),
      ...(r ? [`Details: ${r}`] : []),
      `Version: ${this.version}`
    ].join(`
`)),
      n.cause && (this.cause = n.cause),
      (this.details = r),
      (this.docsPath = i),
      (this.metaMessages = n.metaMessages),
      (this.shortMessage = e)
  }
  walk(e) {
    return tI(this, ym, 'm', nI).call(this, this, e)
  }
}
;(ym = new WeakSet()),
  (nI = function t(e, n) {
    return n != null && n(e) ? e : e.cause ? tI(this, ym, 'm', t).call(this, e.cause, n) : e
  })
class Jh extends ja {
  constructor() {
    super('Chain not configured.'),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ChainNotConfiguredError'
      })
  }
}
class Mte extends ja {
  constructor() {
    super('Connector already connected.'),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ConnectorAlreadyConnectedError'
      })
  }
}
class kte extends ja {
  constructor() {
    super('Connector not connected.'),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ConnectorNotConnectedError'
      })
  }
}
class Ute extends ja {
  constructor({ address: e, connector: n }) {
    super(`Account "${e}" not found for connector "${n.name}".`),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ConnectorAccountNotFoundError'
      })
  }
}
class Bte extends ja {
  constructor({ connectionChainId: e, connectorChainId: n }) {
    super(
      `The current chain of the connector (id: ${n}) does not match the connection's chain (id: ${e}).`,
      { metaMessages: [`Current Chain ID:  ${n}`, `Expected Chain ID: ${e}`] }
    ),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ConnectorChainMismatchError'
      })
  }
}
class Lte extends ja {
  constructor({ connector: e }) {
    super(`Connector "${e.name}" unavailable while reconnecting.`, {
      details: [
        'During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.',
        'All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.',
        'This error commonly occurs for connectors that asynchronously inject after reconnection has already started.'
      ].join(' ')
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ConnectorUnavailableReconnectingError'
      })
  }
}
async function e8(t, e) {
  var r
  let n
  if (
    (typeof e.connector == 'function'
      ? (n = t._internal.connectors.setup(e.connector))
      : (n = e.connector),
    n.uid === t.state.current)
  )
    throw new Mte()
  try {
    t.setState(f => ({ ...f, status: 'connecting' })),
      n.emitter.emit('message', { type: 'connecting' })
    const { connector: i, ...s } = e,
      c = await n.connect(s),
      u = c.accounts
    return (
      n.emitter.off('connect', t._internal.events.connect),
      n.emitter.on('change', t._internal.events.change),
      n.emitter.on('disconnect', t._internal.events.disconnect),
      await ((r = t.storage) == null ? void 0 : r.setItem('recentConnectorId', n.id)),
      t.setState(f => ({
        ...f,
        connections: new Map(f.connections).set(n.uid, {
          accounts: u,
          chainId: c.chainId,
          connector: n
        }),
        current: n.uid,
        status: 'connected'
      })),
      { accounts: u, chainId: c.chainId }
    )
  } catch (i) {
    throw (t.setState(s => ({ ...s, status: s.current ? 'connected' : 'disconnected' })), i)
  }
}
async function Pp(t, e = {}) {
  let n
  if (e.connector) {
    const { connector: d } = e
    if (t.state.status === 'reconnecting' && !d.getAccounts && !d.getChainId)
      throw new Lte({ connector: d })
    const [p, g] = await Promise.all([
      d.getAccounts().catch(m => {
        if (e.account === null) return []
        throw m
      }),
      d.getChainId()
    ])
    n = { accounts: p, chainId: g, connector: d }
  } else n = t.state.connections.get(t.state.current)
  if (!n) throw new kte()
  const r = e.chainId ?? n.chainId,
    i = await n.connector.getChainId()
  if (i !== n.chainId) throw new Bte({ connectionChainId: n.chainId, connectorChainId: i })
  const s = n.connector
  if (s.getClient) return s.getClient({ chainId: r })
  const c = Qs(e.account ?? n.accounts[0])
  if (
    (c && (c.address = Bo(c.address)),
    e.account && !n.accounts.some(d => d.toLowerCase() === c.address.toLowerCase()))
  )
    throw new Ute({ address: c.address, connector: s })
  const u = t.chains.find(d => d.id === r),
    f = await n.connector.getProvider({ chainId: r })
  return T9({
    account: c,
    chain: u,
    name: 'Connector Client',
    transport: d => DZ(f)({ ...d, retryCount: 0 })
  })
}
async function $te(t, e = {}) {
  var i, s
  let n
  if (e.connector) n = e.connector
  else {
    const { connections: c, current: u } = t.state,
      f = c.get(u)
    n = f == null ? void 0 : f.connector
  }
  const r = t.state.connections
  n &&
    (await n.disconnect(),
    n.emitter.off('change', t._internal.events.change),
    n.emitter.off('disconnect', t._internal.events.disconnect),
    n.emitter.on('connect', t._internal.events.connect),
    r.delete(n.uid)),
    t.setState(c => {
      if (r.size === 0)
        return { ...c, connections: new Map(), current: null, status: 'disconnected' }
      const u = r.values().next().value
      return { ...c, connections: new Map(r), current: u.connector.uid }
    })
  {
    const c = t.state.current
    if (!c) return
    const u = (i = t.state.connections.get(c)) == null ? void 0 : i.connector
    if (!u) return
    await ((s = t.storage) == null ? void 0 : s.setItem('recentConnectorId', u.id))
  }
}
async function rI(t, e) {
  const { chainId: n, connector: r, ...i } = e
  let s
  e.account
    ? (s = e.account)
    : (s = (await Pp(t, { account: e.account, chainId: n, connector: r })).account)
  const c = t.getClient({ chainId: n })
  return Fr(c, p9, 'estimateGas')({ ...i, account: s })
}
function iI(t) {
  return typeof t == 'number' ? t : t === 'wei' ? 0 : Math.abs(dY[t])
}
function ep(t) {
  const e = t.state.current,
    n = t.state.connections.get(e),
    r = n == null ? void 0 : n.accounts,
    i = r == null ? void 0 : r[0],
    s = t.chains.find(u => u.id === (n == null ? void 0 : n.chainId)),
    c = t.state.status
  switch (c) {
    case 'connected':
      return {
        address: i,
        addresses: r,
        chain: s,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !0,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !1,
        status: c
      }
    case 'reconnecting':
      return {
        address: i,
        addresses: r,
        chain: s,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !!i,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !0,
        status: c
      }
    case 'connecting':
      return {
        address: i,
        addresses: r,
        chain: s,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !1,
        isConnecting: !0,
        isDisconnected: !1,
        isReconnecting: !1,
        status: c
      }
    case 'disconnected':
      return {
        address: void 0,
        addresses: void 0,
        chain: void 0,
        chainId: void 0,
        connector: void 0,
        isConnected: !1,
        isConnecting: !1,
        isDisconnected: !0,
        isReconnecting: !1,
        status: c
      }
  }
}
async function Fte(t, e) {
  const { allowFailure: n = !0, chainId: r, contracts: i, ...s } = e,
    c = t.getClient({ chainId: r })
  return Fr(c, cX, 'multicall')({ allowFailure: n, contracts: i, ...s })
}
function sI(t, e) {
  const { chainId: n, ...r } = e,
    i = t.getClient({ chainId: n })
  return Fr(i, cu, 'readContract')(r)
}
async function jte(t, e) {
  var u
  const { allowFailure: n = !0, blockNumber: r, blockTag: i, ...s } = e,
    c = e.contracts
  try {
    const f = {}
    for (const [m, y] of c.entries()) {
      const A = y.chainId ?? t.state.chainId
      f[A] || (f[A] = []), (u = f[A]) == null || u.push({ contract: y, index: m })
    }
    const d = () =>
        Object.entries(f).map(([m, y]) =>
          Fte(t, {
            ...s,
            allowFailure: n,
            blockNumber: r,
            blockTag: i,
            chainId: Number.parseInt(m),
            contracts: y.map(({ contract: A }) => A)
          })
        ),
      p = (await Promise.all(d())).flat(),
      g = Object.values(f).flatMap(m => m.map(({ index: y }) => y))
    return p.reduce((m, y, A) => (m && (m[g[A]] = y), m), [])
  } catch (f) {
    if (f instanceof XN) throw f
    const d = () => c.map(p => sI(t, { ...p, blockNumber: r, blockTag: i }))
    return n
      ? (await Promise.allSettled(d())).map(p =>
          p.status === 'fulfilled'
            ? { result: p.value, status: 'success' }
            : { error: p.reason, result: void 0, status: 'failure' }
        )
      : await Promise.all(d())
  }
}
async function aI(t, e) {
  const { address: n, blockNumber: r, blockTag: i, chainId: s, token: c, unit: u = 'ether' } = e
  if (c)
    try {
      return await t8(t, { balanceAddress: n, chainId: s, symbolType: 'string', tokenAddress: c })
    } catch (m) {
      if (m.name === 'ContractFunctionExecutionError') {
        const y = await t8(t, {
            balanceAddress: n,
            chainId: s,
            symbolType: 'bytes32',
            tokenAddress: c
          }),
          A = LN(Sd(y.symbol, { dir: 'right' }))
        return { ...y, symbol: A }
      }
      throw m
    }
  const f = t.getClient({ chainId: s }),
    p = await Fr(
      f,
      h9,
      'getBalance'
    )(r ? { address: n, blockNumber: r } : { address: n, blockTag: i }),
    g = t.chains.find(m => m.id === s) ?? f.chain
  return {
    decimals: g.nativeCurrency.decimals,
    formatted: xd(p, iI(u)),
    symbol: g.nativeCurrency.symbol,
    value: p
  }
}
async function t8(t, e) {
  const { balanceAddress: n, chainId: r, symbolType: i, tokenAddress: s, unit: c } = e,
    u = {
      abi: [
        {
          type: 'function',
          name: 'balanceOf',
          stateMutability: 'view',
          inputs: [{ type: 'address' }],
          outputs: [{ type: 'uint256' }]
        },
        {
          type: 'function',
          name: 'decimals',
          stateMutability: 'view',
          inputs: [],
          outputs: [{ type: 'uint8' }]
        },
        {
          type: 'function',
          name: 'symbol',
          stateMutability: 'view',
          inputs: [],
          outputs: [{ type: i }]
        }
      ],
      address: s
    },
    [f, d, p] = await jte(t, {
      allowFailure: !1,
      contracts: [
        { ...u, functionName: 'balanceOf', args: [n], chainId: r },
        { ...u, functionName: 'decimals', chainId: r },
        { ...u, functionName: 'symbol', chainId: r }
      ]
    }),
    g = xd(f ?? '0', iI(c ?? d))
  return { decimals: d, formatted: g, symbol: p, value: f }
}
function n8(t) {
  return t.state.chainId
}
function tp(t, e) {
  if (t === e) return !0
  if (t && e && typeof t == 'object' && typeof e == 'object') {
    if (t.constructor !== e.constructor) return !1
    let n, r
    if (Array.isArray(t) && Array.isArray(e)) {
      if (((n = t.length), n !== e.length)) return !1
      for (r = n; r-- !== 0; ) if (!tp(t[r], e[r])) return !1
      return !0
    }
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === e.valueOf()
    if (t.toString !== Object.prototype.toString) return t.toString() === e.toString()
    const i = Object.keys(t)
    if (((n = i.length), n !== Object.keys(e).length)) return !1
    for (r = n; r-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(e, i[r])) return !1
    for (r = n; r-- !== 0; ) {
      const s = i[r]
      if (s && !tp(t[s], e[s])) return !1
    }
    return !0
  }
  return t !== t && e !== e
}
let vg = []
function Sl(t) {
  const e = [...t.state.connections.values()]
  return t.state.status === 'reconnecting' || tp(vg, e) ? vg : ((vg = e), e)
}
function zte(t, e) {
  const { chainId: n, ...r } = e,
    i = t.getClient({ chainId: n })
  return Fr(i, jZ, 'getEnsAddress')(r)
}
function qte(t, e) {
  const { chainId: n, ...r } = e,
    i = t.getClient({ chainId: n })
  return Fr(i, tX, 'getEnsAvatar')(r)
}
function Hte(t, e) {
  const { chainId: n, ...r } = e,
    i = t.getClient({ chainId: n })
  return Fr(i, nX, 'getEnsName')(r)
}
async function Gte(t, e) {
  const { account: n, chainId: r, ...i } = e,
    s = n ?? ep(t).address,
    c = t.getClient({ chainId: r })
  return Fr(c, I2, 'prepareTransactionRequest')({ ...i, ...(s ? { account: s } : {}) })
}
let Q1 = !1
async function oI(t, e = {}) {
  var d, p
  if (Q1) return []
  ;(Q1 = !0), t.setState(g => ({ ...g, status: g.current ? 'reconnecting' : 'connecting' }))
  const n = []
  if ((d = e.connectors) != null && d.length)
    for (const g of e.connectors) {
      let m
      typeof g == 'function' ? (m = t._internal.connectors.setup(g)) : (m = g), n.push(m)
    }
  else n.push(...t.connectors)
  let r
  try {
    r = await ((p = t.storage) == null ? void 0 : p.getItem('recentConnectorId'))
  } catch {}
  const i = {}
  for (const [, g] of t.state.connections) i[g.connector.id] = 1
  r && (i[r] = 0)
  const s = Object.keys(i).length > 0 ? [...n].sort((g, m) => (i[g.id] ?? 10) - (i[m.id] ?? 10)) : n
  let c = !1
  const u = [],
    f = []
  for (const g of s) {
    const m = await g.getProvider().catch(() => {})
    if (!m || f.some(E => E === m) || !(await g.isAuthorized())) continue
    const A = await g.connect({ isReconnecting: !0 }).catch(() => null)
    A &&
      (g.emitter.off('connect', t._internal.events.connect),
      g.emitter.on('change', t._internal.events.change),
      g.emitter.on('disconnect', t._internal.events.disconnect),
      t.setState(E => {
        const x = new Map(c ? E.connections : new Map()).set(g.uid, {
          accounts: A.accounts,
          chainId: A.chainId,
          connector: g
        })
        return { ...E, current: c ? E.current : g.uid, connections: x }
      }),
      u.push({ accounts: A.accounts, chainId: A.chainId, connector: g }),
      f.push(m),
      (c = !0))
  }
  return (
    (t.state.status === 'reconnecting' || t.state.status === 'connecting') &&
      (c
        ? t.setState(g => ({ ...g, status: 'connected' }))
        : t.setState(g => ({
            ...g,
            connections: new Map(),
            current: null,
            status: 'disconnected'
          }))),
    (Q1 = !1),
    u
  )
}
async function cI(t, e) {
  const { account: n, chainId: r, connector: i, ...s } = e
  let c
  return (
    typeof n == 'object' && (n == null ? void 0 : n.type) === 'local'
      ? (c = t.getClient({ chainId: r }))
      : (c = await Pp(t, { account: n ?? void 0, chainId: r, connector: i })),
    await Fr(
      c,
      C9,
      'sendTransaction'
    )({ ...s, ...(n ? { account: n } : {}), chain: r ? { id: r } : null, gas: s.gas ?? void 0 })
  )
}
async function uI(t, e) {
  const { account: n, connector: r, ...i } = e
  let s
  return (
    typeof n == 'object' && n.type === 'local'
      ? (s = t.getClient())
      : (s = await Pp(t, { account: n, connector: r })),
    Fr(s, fX, 'signMessage')({ ...i, ...(n ? { account: n } : {}) })
  )
}
class Ao extends ja {
  constructor() {
    super('Provider not found.'),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ProviderNotFoundError'
      })
  }
}
class Vte extends ja {
  constructor({ connector: e }) {
    super(`"${e.name}" does not support programmatic chain switching.`),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'SwitchChainNotSupportedError'
      })
  }
}
async function Kte(t, e) {
  var c
  const { addEthereumChainParameter: n, chainId: r } = e,
    i = t.state.connections.get(((c = e.connector) == null ? void 0 : c.uid) ?? t.state.current)
  if (i) {
    const u = i.connector
    if (!u.switchChain) throw new Vte({ connector: u })
    return await u.switchChain({ addEthereumChainParameter: n, chainId: r })
  }
  const s = t.chains.find(u => u.id === r)
  if (!s) throw new Jh()
  return t.setState(u => ({ ...u, chainId: r })), s
}
function lI(t, e) {
  const { onChange: n } = e
  return t.subscribe(() => ep(t), n, {
    equalityFn(r, i) {
      const { connector: s, ...c } = r,
        { connector: u, ...f } = i
      return (
        tp(c, f) &&
        (s == null ? void 0 : s.id) === (u == null ? void 0 : u.id) &&
        (s == null ? void 0 : s.uid) === (u == null ? void 0 : u.uid)
      )
    }
  })
}
function Wte(t, e) {
  const { onChange: n } = e
  return t.subscribe(r => r.chainId, n)
}
function Qte(t, e) {
  const { onChange: n } = e
  return t._internal.connectors.subscribe((r, i) => {
    n(Object.values(r), i)
  })
}
function Yte(t, e) {
  const { syncConnectedChain: n = t._internal.syncConnectedChain, ...r } = e
  let i
  const s = f => {
      i && i()
      const d = t.getClient({ chainId: f })
      return (i = Fr(d, dX, 'watchPendingTransactions')(r)), i
    },
    c = s(e.chainId)
  let u
  return (
    n &&
      !e.chainId &&
      (u = t.subscribe(
        ({ chainId: f }) => f,
        async f => s(f)
      )),
    () => {
      c == null || c(), u == null || u()
    }
  )
}
async function dI(t, e) {
  const { chainId: n, timeout: r = 0, ...i } = e,
    s = t.getClient({ chainId: n }),
    u = await Fr(s, lX, 'waitForTransactionReceipt')({ ...i, timeout: r })
  if (u.status === 'reverted') {
    const d = await Fr(s, D9, 'getTransaction')({ hash: u.transactionHash }),
      g = await Fr(
        s,
        A9,
        'call'
      )({
        ...d,
        data: d.input,
        gasPrice: d.type !== 'eip1559' ? d.gasPrice : void 0,
        maxFeePerGas: d.type === 'eip1559' ? d.maxFeePerGas : void 0,
        maxPriorityFeePerGas: d.type === 'eip1559' ? d.maxPriorityFeePerGas : void 0
      }),
      m = g != null && g.data ? LN(`0x${g.data.substring(138)}`) : 'unknown reason'
    throw new Error(m)
  }
  return { ...u, chainId: s.chain.id }
}
async function fI(t, e) {
  const { account: n, chainId: r, connector: i, ...s } = e
  let c
  return (
    typeof n == 'object' && (n == null ? void 0 : n.type) === 'local'
      ? (c = t.getClient({ chainId: r }))
      : (c = await Pp(t, { account: n ?? void 0, chainId: r, connector: i })),
    await Fr(
      c,
      NZ,
      'writeContract'
    )({ ...s, ...(n ? { account: n } : {}), chain: r ? { id: r } : null })
  )
}
function kse(t) {
  return t
}
eb.type = 'injected'
function eb(t = {}) {
  const { shimDisconnect: e = !0, unstable_shimAsyncInject: n } = t
  function r() {
    const f = t.target
    if (typeof f == 'function') {
      const d = f()
      if (d) return d
    }
    return typeof f == 'object'
      ? f
      : typeof f == 'string'
        ? {
            ...(Zte[f] ?? {
              id: f,
              name: `${f[0].toUpperCase()}${f.slice(1)}`,
              provider: `is${f[0].toUpperCase()}${f.slice(1)}`
            })
          }
        : {
            id: 'injected',
            name: 'Injected',
            provider(d) {
              return d == null ? void 0 : d.ethereum
            }
          }
  }
  let i, s, c, u
  return f => ({
    get icon() {
      return r().icon
    },
    get id() {
      return r().id
    },
    get name() {
      return r().name
    },
    get supportsSimulation() {
      return !0
    },
    type: eb.type,
    async setup() {
      const d = await this.getProvider()
      d != null &&
        d.on &&
        t.target &&
        (c || ((c = this.onConnect.bind(this)), d.on('connect', c)),
        i || ((i = this.onAccountsChanged.bind(this)), d.on('accountsChanged', i)))
    },
    async connect({ chainId: d, isReconnecting: p } = {}) {
      var y, A, E, x, O, I
      const g = await this.getProvider()
      if (!g) throw new Ao()
      let m = []
      if (p) m = await this.getAccounts().catch(() => [])
      else if (e)
        try {
          ;(m =
            (x =
              (E =
                (A =
                  (y = (
                    await g.request({
                      method: 'wallet_requestPermissions',
                      params: [{ eth_accounts: {} }]
                    })
                  )[0]) == null
                    ? void 0
                    : y.caveats) == null
                  ? void 0
                  : A[0]) == null
                ? void 0
                : E.value) == null
              ? void 0
              : x.map($ => Bo($))),
            m.length > 0 && (m = await this.getAccounts())
        } catch (M) {
          const $ = M
          if ($.code === Xn.code) throw new Xn($)
          if ($.code === jo.code) throw $
        }
      try {
        !(m != null && m.length) &&
          !p &&
          (m = (await g.request({ method: 'eth_requestAccounts' })).map(D => Bo(D))),
          c && (g.removeListener('connect', c), (c = void 0)),
          i || ((i = this.onAccountsChanged.bind(this)), g.on('accountsChanged', i)),
          s || ((s = this.onChainChanged.bind(this)), g.on('chainChanged', s)),
          u || ((u = this.onDisconnect.bind(this)), g.on('disconnect', u))
        let M = await this.getChainId()
        if (d && M !== d) {
          const $ = await this.switchChain({ chainId: d }).catch(D => {
            if (D.code === Xn.code) throw D
            return { id: M }
          })
          M = ($ == null ? void 0 : $.id) ?? M
        }
        return (
          e && (await ((O = f.storage) == null ? void 0 : O.removeItem(`${this.id}.disconnected`))),
          t.target ||
            (await ((I = f.storage) == null ? void 0 : I.setItem('injected.connected', !0))),
          { accounts: m, chainId: M }
        )
      } catch (M) {
        const $ = M
        throw $.code === Xn.code ? new Xn($) : $.code === jo.code ? new jo($) : $
      }
    },
    async disconnect() {
      var p, g
      const d = await this.getProvider()
      if (!d) throw new Ao()
      s && (d.removeListener('chainChanged', s), (s = void 0)),
        u && (d.removeListener('disconnect', u), (u = void 0)),
        c || ((c = this.onConnect.bind(this)), d.on('connect', c))
      try {
        await x9(
          () => d.request({ method: 'wallet_revokePermissions', params: [{ eth_accounts: {} }] }),
          { timeout: 100 }
        )
      } catch {}
      e && (await ((p = f.storage) == null ? void 0 : p.setItem(`${this.id}.disconnected`, !0))),
        t.target || (await ((g = f.storage) == null ? void 0 : g.removeItem('injected.connected')))
    },
    async getAccounts() {
      const d = await this.getProvider()
      if (!d) throw new Ao()
      return (await d.request({ method: 'eth_accounts' })).map(g => Bo(g))
    },
    async getChainId() {
      const d = await this.getProvider()
      if (!d) throw new Ao()
      const p = await d.request({ method: 'eth_chainId' })
      return Number(p)
    },
    async getProvider() {
      if (typeof window > 'u') return
      let d
      const p = r()
      return (
        typeof p.provider == 'function'
          ? (d = p.provider(window))
          : typeof p.provider == 'string'
            ? (d = Lg(window, p.provider))
            : (d = p.provider),
        d &&
          !d.removeListener &&
          ('off' in d && typeof d.off == 'function'
            ? (d.removeListener = d.off)
            : (d.removeListener = () => {})),
        d
      )
    },
    async isAuthorized() {
      var d, p
      try {
        if (
          (e &&
            (await ((d = f.storage) == null ? void 0 : d.getItem(`${this.id}.disconnected`)))) ||
          (!t.target &&
            !(await ((p = f.storage) == null ? void 0 : p.getItem('injected.connected'))))
        )
          return !1
        if (!(await this.getProvider())) {
          if (n !== void 0 && n !== !1) {
            const A = async () => (
                typeof window < 'u' && window.removeEventListener('ethereum#initialized', A),
                !!(await this.getProvider())
              ),
              E = typeof n == 'number' ? n : 1e3
            if (
              await Promise.race([
                ...(typeof window < 'u'
                  ? [
                      new Promise(O =>
                        window.addEventListener('ethereum#initialized', () => O(A()), { once: !0 })
                      )
                    ]
                  : []),
                new Promise(O => setTimeout(() => O(A()), E))
              ])
            )
              return !0
          }
          throw new Ao()
        }
        return !!(await am(() => this.getAccounts())).length
      } catch {
        return !1
      }
    },
    async switchChain({ addEthereumChainParameter: d, chainId: p }) {
      var A, E, x, O
      const g = await this.getProvider()
      if (!g) throw new Ao()
      const m = f.chains.find(I => I.id === p)
      if (!m) throw new Gs(new Jh())
      const y = new Promise(I => {
        const M = $ => {
          'chainId' in $ && $.chainId === p && (f.emitter.off('change', M), I())
        }
        f.emitter.on('change', M)
      })
      try {
        return (
          await Promise.all([
            g
              .request({ method: 'wallet_switchEthereumChain', params: [{ chainId: it(p) }] })
              .then(async () => {
                ;(await this.getChainId()) === p && f.emitter.emit('change', { chainId: p })
              }),
            y
          ]),
          m
        )
      } catch (I) {
        const M = I
        if (
          M.code === 4902 ||
          ((E = (A = M == null ? void 0 : M.data) == null ? void 0 : A.originalError) == null
            ? void 0
            : E.code) === 4902
        )
          try {
            const { default: $, ...D } = m.blockExplorers ?? {}
            let R
            d != null && d.blockExplorerUrls
              ? (R = d.blockExplorerUrls)
              : $ && (R = [$.url, ...Object.values(D).map(j => j.url)])
            let z
            ;(x = d == null ? void 0 : d.rpcUrls) != null && x.length
              ? (z = d.rpcUrls)
              : (z = [((O = m.rpcUrls.default) == null ? void 0 : O.http[0]) ?? ''])
            const G = {
              blockExplorerUrls: R,
              chainId: it(p),
              chainName: (d == null ? void 0 : d.chainName) ?? m.name,
              iconUrls: d == null ? void 0 : d.iconUrls,
              nativeCurrency: (d == null ? void 0 : d.nativeCurrency) ?? m.nativeCurrency,
              rpcUrls: z
            }
            return (
              await Promise.all([
                g.request({ method: 'wallet_addEthereumChain', params: [G] }).then(async () => {
                  if ((await this.getChainId()) === p) f.emitter.emit('change', { chainId: p })
                  else throw new Xn(new Error('User rejected switch after adding network.'))
                }),
                y
              ]),
              m
            )
          } catch ($) {
            throw new Xn($)
          }
        throw M.code === Xn.code ? new Xn(M) : new Gs(M)
      }
    },
    async onAccountsChanged(d) {
      var p
      if (d.length === 0) this.onDisconnect()
      else if (f.emitter.listenerCount('connect')) {
        const g = (await this.getChainId()).toString()
        this.onConnect({ chainId: g }),
          e && (await ((p = f.storage) == null ? void 0 : p.removeItem(`${this.id}.disconnected`)))
      } else f.emitter.emit('change', { accounts: d.map(g => Bo(g)) })
    },
    onChainChanged(d) {
      const p = Number(d)
      f.emitter.emit('change', { chainId: p })
    },
    async onConnect(d) {
      const p = await this.getAccounts()
      if (p.length === 0) return
      const g = Number(d.chainId)
      f.emitter.emit('connect', { accounts: p, chainId: g })
      const m = await this.getProvider()
      m &&
        (c && (m.removeListener('connect', c), (c = void 0)),
        i || ((i = this.onAccountsChanged.bind(this)), m.on('accountsChanged', i)),
        s || ((s = this.onChainChanged.bind(this)), m.on('chainChanged', s)),
        u || ((u = this.onDisconnect.bind(this)), m.on('disconnect', u)))
    },
    async onDisconnect(d) {
      const p = await this.getProvider()
      ;(d && d.code === 1013 && p && (await this.getAccounts()).length) ||
        (f.emitter.emit('disconnect'),
        p &&
          (s && (p.removeListener('chainChanged', s), (s = void 0)),
          u && (p.removeListener('disconnect', u), (u = void 0)),
          c || ((c = this.onConnect.bind(this)), p.on('connect', c))))
    }
  })
}
const Zte = {
  coinbaseWallet: {
    id: 'coinbaseWallet',
    name: 'Coinbase Wallet',
    provider(t) {
      return t != null && t.coinbaseWalletExtension
        ? t.coinbaseWalletExtension
        : Lg(t, 'isCoinbaseWallet')
    }
  },
  metaMask: {
    id: 'metaMask',
    name: 'MetaMask',
    provider(t) {
      return Lg(t, e => {
        if (!e.isMetaMask || (e.isBraveWallet && !e._events && !e._state)) return !1
        const n = [
          'isApexWallet',
          'isAvalanche',
          'isBitKeep',
          'isBlockWallet',
          'isKuCoinWallet',
          'isMathWallet',
          'isOkxWallet',
          'isOKExWallet',
          'isOneInchIOSWallet',
          'isOneInchAndroidWallet',
          'isOpera',
          'isPhantom',
          'isPortal',
          'isRabby',
          'isTokenPocket',
          'isTokenary',
          'isUniswapWallet',
          'isZerion'
        ]
        for (const r of n) if (e[r]) return !1
        return !0
      })
    }
  },
  phantom: {
    id: 'phantom',
    name: 'Phantom',
    provider(t) {
      var e, n
      return (e = t == null ? void 0 : t.phantom) != null && e.ethereum
        ? (n = t.phantom) == null
          ? void 0
          : n.ethereum
        : Lg(t, 'isPhantom')
    }
  }
}
function Lg(t, e) {
  function n(i) {
    return typeof e == 'function' ? e(i) : typeof e == 'string' ? i[e] : !0
  }
  const r = t.ethereum
  if (r != null && r.providers) return r.providers.find(i => n(i))
  if (r && n(r)) return r
}
function Xte(t) {
  if (typeof window > 'u') return
  const e = n => t(n.detail)
  return (
    window.addEventListener('eip6963:announceProvider', e),
    window.dispatchEvent(new CustomEvent('eip6963:requestProvider')),
    () => window.removeEventListener('eip6963:announceProvider', e)
  )
}
function Jte() {
  const t = new Set()
  let e = []
  const n = () =>
    Xte(i => {
      e.some(({ info: s }) => s.uuid === i.info.uuid) ||
        ((e = [...e, i]), t.forEach(s => s(e, { added: [i] })))
    })
  let r = n()
  return {
    _listeners() {
      return t
    },
    clear() {
      t.forEach(i => i([], { removed: [...e] })), (e = [])
    },
    destroy() {
      this.clear(), t.clear(), r == null || r()
    },
    findProvider({ rdns: i }) {
      return e.find(s => s.info.rdns === i)
    },
    getProviders() {
      return e
    },
    reset() {
      this.clear(), r == null || r(), (r = n())
    },
    subscribe(i, { emitImmediately: s } = {}) {
      return t.add(i), s && i(e, { added: e }), () => t.delete(i)
    }
  }
}
const ene = t => (e, n, r) => {
    const i = r.subscribe
    return (
      (r.subscribe = (c, u, f) => {
        let d = c
        if (u) {
          const p = (f == null ? void 0 : f.equalityFn) || Object.is
          let g = c(r.getState())
          ;(d = m => {
            const y = c(m)
            if (!p(g, y)) {
              const A = g
              u((g = y), A)
            }
          }),
            f != null && f.fireImmediately && u(g, g)
        }
        return i(d)
      }),
      t(e, n, r)
    )
  },
  tne = ene
function nne(t, e) {
  let n
  try {
    n = t()
  } catch {
    return
  }
  return {
    getItem: i => {
      var s
      const c = f => (f === null ? null : JSON.parse(f, void 0)),
        u = (s = n.getItem(i)) != null ? s : null
      return u instanceof Promise ? u.then(c) : c(u)
    },
    setItem: (i, s) => n.setItem(i, JSON.stringify(s, void 0)),
    removeItem: i => n.removeItem(i)
  }
}
const mE = t => e => {
    try {
      const n = t(e)
      return n instanceof Promise
        ? n
        : {
            then(r) {
              return mE(r)(n)
            },
            catch(r) {
              return this
            }
          }
    } catch (n) {
      return {
        then(r) {
          return this
        },
        catch(r) {
          return mE(r)(n)
        }
      }
    }
  },
  rne = (t, e) => (n, r, i) => {
    let s = {
        storage: nne(() => localStorage),
        partialize: E => E,
        version: 0,
        merge: (E, x) => ({ ...x, ...E }),
        ...e
      },
      c = !1
    const u = new Set(),
      f = new Set()
    let d = s.storage
    if (!d)
      return t(
        (...E) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
          ),
            n(...E)
        },
        r,
        i
      )
    const p = () => {
        const E = s.partialize({ ...r() })
        return d.setItem(s.name, { state: E, version: s.version })
      },
      g = i.setState
    i.setState = (E, x) => {
      g(E, x), p()
    }
    const m = t(
      (...E) => {
        n(...E), p()
      },
      r,
      i
    )
    i.getInitialState = () => m
    let y
    const A = () => {
      var E, x
      if (!d) return
      ;(c = !1),
        u.forEach(I => {
          var M
          return I((M = r()) != null ? M : m)
        })
      const O =
        ((x = s.onRehydrateStorage) == null ? void 0 : x.call(s, (E = r()) != null ? E : m)) ||
        void 0
      return mE(d.getItem.bind(d))(s.name)
        .then(I => {
          if (I)
            if (typeof I.version == 'number' && I.version !== s.version) {
              if (s.migrate) return [!0, s.migrate(I.state, I.version)]
              console.error(
                "State loaded from storage couldn't be migrated since no migrate function was provided"
              )
            } else return [!1, I.state]
          return [!1, void 0]
        })
        .then(I => {
          var M
          const [$, D] = I
          if (((y = s.merge(D, (M = r()) != null ? M : m)), n(y, !0), $)) return p()
        })
        .then(() => {
          O == null || O(y, void 0), (y = r()), (c = !0), f.forEach(I => I(y))
        })
        .catch(I => {
          O == null || O(void 0, I)
        })
    }
    return (
      (i.persist = {
        setOptions: E => {
          ;(s = { ...s, ...E }), E.storage && (d = E.storage)
        },
        clearStorage: () => {
          d == null || d.removeItem(s.name)
        },
        getOptions: () => s,
        rehydrate: () => A(),
        hasHydrated: () => c,
        onHydrate: E => (
          u.add(E),
          () => {
            u.delete(E)
          }
        ),
        onFinishHydration: E => (
          f.add(E),
          () => {
            f.delete(E)
          }
        )
      }),
      s.skipHydration || A(),
      y || m
    )
  },
  ine = rne,
  r8 = t => {
    let e
    const n = new Set(),
      r = (d, p) => {
        const g = typeof d == 'function' ? d(e) : d
        if (!Object.is(g, e)) {
          const m = e
          ;(e = (p ?? (typeof g != 'object' || g === null)) ? g : Object.assign({}, e, g)),
            n.forEach(y => y(e, m))
        }
      },
      i = () => e,
      u = {
        setState: r,
        getState: i,
        getInitialState: () => f,
        subscribe: d => (n.add(d), () => n.delete(d))
      },
      f = (e = t(r, i, u))
    return u
  },
  Y1 = t => (t ? r8(t) : r8)
var Z1 = { exports: {} },
  i8
function sne() {
  return (
    i8 ||
      ((i8 = 1),
      (function (t) {
        var e = Object.prototype.hasOwnProperty,
          n = '~'
        function r() {}
        Object.create && ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1))
        function i(f, d, p) {
          ;(this.fn = f), (this.context = d), (this.once = p || !1)
        }
        function s(f, d, p, g, m) {
          if (typeof p != 'function') throw new TypeError('The listener must be a function')
          var y = new i(p, g || f, m),
            A = n ? n + d : d
          return (
            f._events[A]
              ? f._events[A].fn
                ? (f._events[A] = [f._events[A], y])
                : f._events[A].push(y)
              : ((f._events[A] = y), f._eventsCount++),
            f
          )
        }
        function c(f, d) {
          --f._eventsCount === 0 ? (f._events = new r()) : delete f._events[d]
        }
        function u() {
          ;(this._events = new r()), (this._eventsCount = 0)
        }
        ;(u.prototype.eventNames = function () {
          var d = [],
            p,
            g
          if (this._eventsCount === 0) return d
          for (g in (p = this._events)) e.call(p, g) && d.push(n ? g.slice(1) : g)
          return Object.getOwnPropertySymbols ? d.concat(Object.getOwnPropertySymbols(p)) : d
        }),
          (u.prototype.listeners = function (d) {
            var p = n ? n + d : d,
              g = this._events[p]
            if (!g) return []
            if (g.fn) return [g.fn]
            for (var m = 0, y = g.length, A = new Array(y); m < y; m++) A[m] = g[m].fn
            return A
          }),
          (u.prototype.listenerCount = function (d) {
            var p = n ? n + d : d,
              g = this._events[p]
            return g ? (g.fn ? 1 : g.length) : 0
          }),
          (u.prototype.emit = function (d, p, g, m, y, A) {
            var E = n ? n + d : d
            if (!this._events[E]) return !1
            var x = this._events[E],
              O = arguments.length,
              I,
              M
            if (x.fn) {
              switch ((x.once && this.removeListener(d, x.fn, void 0, !0), O)) {
                case 1:
                  return x.fn.call(x.context), !0
                case 2:
                  return x.fn.call(x.context, p), !0
                case 3:
                  return x.fn.call(x.context, p, g), !0
                case 4:
                  return x.fn.call(x.context, p, g, m), !0
                case 5:
                  return x.fn.call(x.context, p, g, m, y), !0
                case 6:
                  return x.fn.call(x.context, p, g, m, y, A), !0
              }
              for (M = 1, I = new Array(O - 1); M < O; M++) I[M - 1] = arguments[M]
              x.fn.apply(x.context, I)
            } else {
              var $ = x.length,
                D
              for (M = 0; M < $; M++)
                switch ((x[M].once && this.removeListener(d, x[M].fn, void 0, !0), O)) {
                  case 1:
                    x[M].fn.call(x[M].context)
                    break
                  case 2:
                    x[M].fn.call(x[M].context, p)
                    break
                  case 3:
                    x[M].fn.call(x[M].context, p, g)
                    break
                  case 4:
                    x[M].fn.call(x[M].context, p, g, m)
                    break
                  default:
                    if (!I) for (D = 1, I = new Array(O - 1); D < O; D++) I[D - 1] = arguments[D]
                    x[M].fn.apply(x[M].context, I)
                }
            }
            return !0
          }),
          (u.prototype.on = function (d, p, g) {
            return s(this, d, p, g, !1)
          }),
          (u.prototype.once = function (d, p, g) {
            return s(this, d, p, g, !0)
          }),
          (u.prototype.removeListener = function (d, p, g, m) {
            var y = n ? n + d : d
            if (!this._events[y]) return this
            if (!p) return c(this, y), this
            var A = this._events[y]
            if (A.fn) A.fn === p && (!m || A.once) && (!g || A.context === g) && c(this, y)
            else {
              for (var E = 0, x = [], O = A.length; E < O; E++)
                (A[E].fn !== p || (m && !A[E].once) || (g && A[E].context !== g)) && x.push(A[E])
              x.length ? (this._events[y] = x.length === 1 ? x[0] : x) : c(this, y)
            }
            return this
          }),
          (u.prototype.removeAllListeners = function (d) {
            var p
            return (
              d
                ? ((p = n ? n + d : d), this._events[p] && c(this, p))
                : ((this._events = new r()), (this._eventsCount = 0)),
              this
            )
          }),
          (u.prototype.off = u.prototype.removeListener),
          (u.prototype.addListener = u.prototype.on),
          (u.prefixed = n),
          (u.EventEmitter = u),
          (t.exports = u)
      })(Z1)),
    Z1.exports
  )
}
var ane = sne()
const one = pd(ane)
class cne {
  constructor(e) {
    Object.defineProperty(this, 'uid', {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }),
      Object.defineProperty(this, '_emitter', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: new one()
      })
  }
  on(e, n) {
    this._emitter.on(e, n)
  }
  once(e, n) {
    this._emitter.once(e, n)
  }
  off(e, n) {
    this._emitter.off(e, n)
  }
  emit(e, ...n) {
    const r = n[0]
    this._emitter.emit(e, { uid: this.uid, ...r })
  }
  listenerCount(e) {
    return this._emitter.listenerCount(e)
  }
}
function une(t) {
  return new cne(t)
}
function lne(t, e) {
  return JSON.parse(t, (n, r) => {
    let i = r
    return (
      (i == null ? void 0 : i.__type) === 'bigint' && (i = BigInt(i.value)),
      (i == null ? void 0 : i.__type) === 'Map' && (i = new Map(i.value)),
      (e == null ? void 0 : e(n, i)) ?? i
    )
  })
}
function s8(t, e) {
  return t.slice(0, e).join('.') || '.'
}
function a8(t, e) {
  const { length: n } = t
  for (let r = 0; r < n; ++r) if (t[r] === e) return r + 1
  return 0
}
function dne(t, e) {
  const n = typeof t == 'function',
    r = typeof e == 'function',
    i = [],
    s = []
  return function (u, f) {
    if (typeof f == 'object')
      if (i.length) {
        const d = a8(i, this)
        d === 0 ? (i[i.length] = this) : (i.splice(d), s.splice(d)), (s[s.length] = u)
        const p = a8(i, f)
        if (p !== 0) return r ? e.call(this, u, f, s8(s, p)) : `[ref=${s8(s, p)}]`
      } else (i[0] = f), (s[0] = u)
    return n ? t.call(this, u, f) : f
  }
}
function fne(t, e, n, r) {
  return JSON.stringify(
    t,
    dne((i, s) => {
      let c = s
      return (
        typeof c == 'bigint' && (c = { __type: 'bigint', value: s.toString() }),
        c instanceof Map && (c = { __type: 'Map', value: Array.from(s.entries()) }),
        (e == null ? void 0 : e(i, c)) ?? c
      )
    }, r),
    n ?? void 0
  )
}
function hne(t) {
  const { deserialize: e = lne, key: n = 'wagmi', serialize: r = fne, storage: i = hI } = t
  function s(c) {
    return c instanceof Promise ? c.then(u => u).catch(() => null) : c
  }
  return {
    ...i,
    key: n,
    async getItem(c, u) {
      const f = i.getItem(`${n}.${c}`),
        d = await s(f)
      return d ? (e(d) ?? null) : (u ?? null)
    },
    async setItem(c, u) {
      const f = `${n}.${c}`
      u === null ? await s(i.removeItem(f)) : await s(i.setItem(f, r(u)))
    },
    async removeItem(c) {
      await s(i.removeItem(`${n}.${c}`))
    }
  }
}
const hI = { getItem: () => null, setItem: () => {}, removeItem: () => {} }
function pne() {
  const t = typeof window < 'u' && window.localStorage ? window.localStorage : hI
  return {
    getItem(e) {
      return t.getItem(e)
    },
    removeItem(e) {
      t.removeItem(e)
    },
    setItem(e, n) {
      try {
        t.setItem(e, n)
      } catch {}
    }
  }
}
const bE = 256
let wg = bE,
  Eg
function gne(t = 11) {
  if (!Eg || wg + t > bE * 2) {
    ;(Eg = ''), (wg = 0)
    for (let e = 0; e < bE; e++) Eg += ((256 + Math.random() * 256) | 0).toString(16).substring(1)
  }
  return Eg.substring(wg, wg++ + t)
}
function mne(t) {
  const {
      multiInjectedProviderDiscovery: e = !0,
      storage: n = hne({ storage: pne() }),
      syncConnectedChain: r = !0,
      ssr: i = !1,
      ...s
    } = t,
    c = typeof window < 'u' && e ? Jte() : void 0,
    u = Y1(() => s.chains),
    f = Y1(() => {
      const D = [],
        R = new Set()
      for (const z of s.connectors ?? []) {
        const G = d(z)
        if ((D.push(G), !i && G.rdns)) {
          const j = typeof G.rdns == 'string' ? [G.rdns] : G.rdns
          for (const V of j) R.add(V)
        }
      }
      if (!i && c) {
        const z = c.getProviders()
        for (const G of z) R.has(G.info.rdns) || D.push(d(p(G)))
      }
      return D
    })
  function d(D) {
    var G
    const R = une(gne()),
      z = {
        ...D({ emitter: R, chains: u.getState(), storage: n, transports: s.transports }),
        emitter: R,
        uid: R.uid
      }
    return R.on('connect', M), (G = z.setup) == null || G.call(z), z
  }
  function p(D) {
    const { info: R } = D,
      z = D.provider
    return eb({ target: { ...R, id: R.rdns, provider: z } })
  }
  const g = new Map()
  function m(D = {}) {
    const R = D.chainId ?? x.getState().chainId,
      z = u.getState().find(j => j.id === R)
    if (D.chainId && !z) throw new Jh()
    {
      const j = g.get(x.getState().chainId)
      if (j && !z) return j
      if (!z) throw new Jh()
    }
    {
      const j = g.get(R)
      if (j) return j
    }
    let G
    if (s.client) G = s.client({ chain: z })
    else {
      const j = z.id,
        V = u.getState().map(C => C.id),
        L = {},
        v = Object.entries(s)
      for (const [C, N] of v)
        if (!(C === 'chains' || C === 'client' || C === 'connectors' || C === 'transports'))
          if (typeof N == 'object')
            if (j in N) L[C] = N[j]
            else {
              if (V.some(S => S in N)) continue
              L[C] = N
            }
          else L[C] = N
      G = T9({
        ...L,
        chain: z,
        batch: L.batch ?? { multicall: !0 },
        transport: C => s.transports[j]({ ...C, connectors: f })
      })
    }
    return g.set(R, G), G
  }
  function y() {
    return {
      chainId: u.getState()[0].id,
      connections: new Map(),
      current: null,
      status: 'disconnected'
    }
  }
  let A
  const E = '0.0.0-canary-'
  Bg.startsWith(E)
    ? (A = Number.parseInt(Bg.replace(E, '')))
    : (A = Number.parseInt(Bg.split('.')[0] ?? '0'))
  const x = Y1(
    tne(
      n
        ? ine(y, {
            migrate(D, R) {
              if (R === A) return D
              const z = y(),
                G = O(D, z.chainId)
              return { ...z, chainId: G }
            },
            name: 'store',
            partialize(D) {
              return {
                connections: {
                  __type: 'Map',
                  value: Array.from(D.connections.entries()).map(([R, z]) => {
                    const { id: G, name: j, type: V, uid: L } = z.connector
                    return [R, { ...z, connector: { id: G, name: j, type: V, uid: L } }]
                  })
                },
                chainId: D.chainId,
                current: D.current
              }
            },
            merge(D, R) {
              typeof D == 'object' && D && 'status' in D && delete D.status
              const z = O(D, R.chainId)
              return { ...R, ...D, chainId: z }
            },
            skipHydration: i,
            storage: n,
            version: A
          })
        : y
    )
  )
  x.setState(y())
  function O(D, R) {
    return D &&
      typeof D == 'object' &&
      'chainId' in D &&
      typeof D.chainId == 'number' &&
      u.getState().some(z => z.id === D.chainId)
      ? D.chainId
      : R
  }
  r &&
    x.subscribe(
      ({ connections: D, current: R }) => {
        var z
        return R ? ((z = D.get(R)) == null ? void 0 : z.chainId) : void 0
      },
      D => {
        if (u.getState().some(z => z.id === D))
          return x.setState(z => ({ ...z, chainId: D ?? z.chainId }))
      }
    ),
    c == null ||
      c.subscribe(D => {
        const R = new Set(),
          z = new Set()
        for (const j of f.getState())
          if ((R.add(j.id), j.rdns)) {
            const V = typeof j.rdns == 'string' ? [j.rdns] : j.rdns
            for (const L of V) z.add(L)
          }
        const G = []
        for (const j of D) {
          if (z.has(j.info.rdns)) continue
          const V = d(p(j))
          R.has(V.id) || G.push(V)
        }
        ;(n && !x.persist.hasHydrated()) || f.setState(j => [...j, ...G], !0)
      })
  function I(D) {
    x.setState(R => {
      const z = R.connections.get(D.uid)
      return z
        ? {
            ...R,
            connections: new Map(R.connections).set(D.uid, {
              accounts: D.accounts ?? z.accounts,
              chainId: D.chainId ?? z.chainId,
              connector: z.connector
            })
          }
        : R
    })
  }
  function M(D) {
    x.getState().status === 'connecting' ||
      x.getState().status === 'reconnecting' ||
      x.setState(R => {
        const z = f.getState().find(G => G.uid === D.uid)
        return z
          ? (z.emitter.listenerCount('connect') && z.emitter.off('connect', I),
            z.emitter.listenerCount('change') || z.emitter.on('change', I),
            z.emitter.listenerCount('disconnect') || z.emitter.on('disconnect', $),
            {
              ...R,
              connections: new Map(R.connections).set(D.uid, {
                accounts: D.accounts,
                chainId: D.chainId,
                connector: z
              }),
              current: D.uid,
              status: 'connected'
            })
          : R
      })
  }
  function $(D) {
    x.setState(R => {
      const z = R.connections.get(D.uid)
      if (z) {
        const j = z.connector
        j.emitter.listenerCount('change') && z.connector.emitter.off('change', I),
          j.emitter.listenerCount('disconnect') && z.connector.emitter.off('disconnect', $),
          j.emitter.listenerCount('connect') || z.connector.emitter.on('connect', M)
      }
      if ((R.connections.delete(D.uid), R.connections.size === 0))
        return { ...R, connections: new Map(), current: null, status: 'disconnected' }
      const G = R.connections.values().next().value
      return { ...R, connections: new Map(R.connections), current: G.connector.uid }
    })
  }
  return {
    get chains() {
      return u.getState()
    },
    get connectors() {
      return f.getState()
    },
    storage: n,
    getClient: m,
    get state() {
      return x.getState()
    },
    setState(D) {
      let R
      typeof D == 'function' ? (R = D(x.getState())) : (R = D)
      const z = y()
      typeof R != 'object' && (R = z),
        Object.keys(z).some(j => !(j in R)) && (R = z),
        x.setState(R, !0)
    },
    subscribe(D, R, z) {
      return x.subscribe(D, R, z ? { ...z, fireImmediately: z.emitImmediately } : void 0)
    },
    _internal: {
      mipd: c,
      store: x,
      ssr: !!i,
      syncConnectedChain: r,
      transports: s.transports,
      chains: {
        setState(D) {
          const R = typeof D == 'function' ? D(u.getState()) : D
          if (R.length !== 0) return u.setState(R, !0)
        },
        subscribe(D) {
          return u.subscribe(D)
        }
      },
      connectors: {
        providerDetailToConnector: p,
        setup: d,
        setState(D) {
          return f.setState(typeof D == 'function' ? D(f.getState()) : D, !0)
        },
        subscribe(D) {
          return f.subscribe(D)
        }
      },
      events: { change: I, connect: M, disconnect: $ }
    }
  }
}
function bne(t, e) {
  const { initialState: n, reconnectOnMount: r } = e
  return (
    n &&
      !t._internal.store.persist.hasHydrated() &&
      t.setState({
        ...n,
        chainId: t.chains.some(i => i.id === n.chainId) ? n.chainId : t.chains[0].id,
        connections: r ? n.connections : new Map(),
        status: r ? 'reconnecting' : 'disconnected'
      }),
    {
      async onMount() {
        t._internal.ssr &&
          (await t._internal.store.persist.rehydrate(),
          t._internal.mipd &&
            t._internal.connectors.setState(i => {
              var f
              const s = new Set()
              for (const d of i ?? [])
                if (d.rdns) {
                  const p = Array.isArray(d.rdns) ? d.rdns : [d.rdns]
                  for (const g of p) s.add(g)
                }
              const c = [],
                u = ((f = t._internal.mipd) == null ? void 0 : f.getProviders()) ?? []
              for (const d of u) {
                if (s.has(d.info.rdns)) continue
                const p = t._internal.connectors.providerDetailToConnector(d),
                  g = t._internal.connectors.setup(p)
                c.push(g)
              }
              return [...i, ...c]
            })),
          r ? oI(t) : t.storage && t.setState(i => ({ ...i, connections: new Map() }))
      }
    }
  )
}
function yne(t) {
  const { children: e, config: n, initialState: r, reconnectOnMount: i = !0 } = t,
    { onMount: s } = bne(n, { initialState: r, reconnectOnMount: i })
  n._internal.ssr || s()
  const c = Le.useRef(!0)
  return (
    Le.useEffect(() => {
      if (c.current && n._internal.ssr)
        return (
          s(),
          () => {
            c.current = !1
          }
        )
    }, []),
    e
  )
}
const pI = Le.createContext(void 0)
function vne(t) {
  const { children: e, config: n } = t,
    r = { value: n }
  return Le.createElement(yne, t, Le.createElement(pI.Provider, r, e))
}
const wne = '2.14.15',
  Ene = () => `wagmi@${wne}`
class Ane extends ja {
  constructor() {
    super(...arguments),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'WagmiError'
      })
  }
  get docsBaseUrl() {
    return 'https://wagmi.sh/react'
  }
  get version() {
    return Ene()
  }
}
class _ne extends Ane {
  constructor() {
    super('`useConfig` must be used within `WagmiProvider`.', { docsPath: '/api/WagmiProvider' }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'WagmiProviderNotFoundError'
      })
  }
}
function Ys(t = {}) {
  const e = t.config ?? Le.useContext(pI)
  if (!e) throw new _ne()
  return e
}
var X1 = { exports: {} },
  J1 = {},
  ew = { exports: {} },
  tw = {}
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var o8
function Cne() {
  if (o8) return tw
  o8 = 1
  var t = gd()
  function e(g, m) {
    return (g === m && (g !== 0 || 1 / g === 1 / m)) || (g !== g && m !== m)
  }
  var n = typeof Object.is == 'function' ? Object.is : e,
    r = t.useState,
    i = t.useEffect,
    s = t.useLayoutEffect,
    c = t.useDebugValue
  function u(g, m) {
    var y = m(),
      A = r({ inst: { value: y, getSnapshot: m } }),
      E = A[0].inst,
      x = A[1]
    return (
      s(
        function () {
          ;(E.value = y), (E.getSnapshot = m), f(E) && x({ inst: E })
        },
        [g, y, m]
      ),
      i(
        function () {
          return (
            f(E) && x({ inst: E }),
            g(function () {
              f(E) && x({ inst: E })
            })
          )
        },
        [g]
      ),
      c(y),
      y
    )
  }
  function f(g) {
    var m = g.getSnapshot
    g = g.value
    try {
      var y = m()
      return !n(g, y)
    } catch {
      return !0
    }
  }
  function d(g, m) {
    return m()
  }
  var p =
    typeof window > 'u' ||
    typeof window.document > 'u' ||
    typeof window.document.createElement > 'u'
      ? d
      : u
  return (
    (tw.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : p), tw
  )
}
var c8
function Sne() {
  return c8 || ((c8 = 1), (ew.exports = Cne())), ew.exports
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var u8
function Tne() {
  if (u8) return J1
  u8 = 1
  var t = gd(),
    e = Sne()
  function n(d, p) {
    return (d === p && (d !== 0 || 1 / d === 1 / p)) || (d !== d && p !== p)
  }
  var r = typeof Object.is == 'function' ? Object.is : n,
    i = e.useSyncExternalStore,
    s = t.useRef,
    c = t.useEffect,
    u = t.useMemo,
    f = t.useDebugValue
  return (
    (J1.useSyncExternalStoreWithSelector = function (d, p, g, m, y) {
      var A = s(null)
      if (A.current === null) {
        var E = { hasValue: !1, value: null }
        A.current = E
      } else E = A.current
      A = u(
        function () {
          function O(R) {
            if (!I) {
              if (((I = !0), (M = R), (R = m(R)), y !== void 0 && E.hasValue)) {
                var z = E.value
                if (y(z, R)) return ($ = z)
              }
              return ($ = R)
            }
            if (((z = $), r(M, R))) return z
            var G = m(R)
            return y !== void 0 && y(z, G) ? ((M = R), z) : ((M = R), ($ = G))
          }
          var I = !1,
            M,
            $,
            D = g === void 0 ? null : g
          return [
            function () {
              return O(p())
            },
            D === null
              ? void 0
              : function () {
                  return O(D())
                }
          ]
        },
        [p, g, m, y]
      )
      var x = i(d, A[0], A[1])
      return (
        c(
          function () {
            ;(E.hasValue = !0), (E.value = x)
          },
          [x]
        ),
        f(x),
        x
      )
    }),
    J1
  )
}
var l8
function xne() {
  return l8 || ((l8 = 1), (X1.exports = Tne())), X1.exports
}
var Nne = xne()
const nw = t => typeof t == 'object' && !Array.isArray(t)
function Ine(t, e, n = e, r = tp) {
  const i = Le.useRef([]),
    s = Nne.useSyncExternalStoreWithSelector(
      t,
      e,
      n,
      c => c,
      (c, u) => {
        if (nw(c) && nw(u) && i.current.length) {
          for (const f of i.current) if (!r(c[f], u[f])) return !1
          return !0
        }
        return r(c, u)
      }
    )
  return Le.useMemo(() => {
    if (nw(s)) {
      const c = { ...s }
      let u = {}
      for (const [f, d] of Object.entries(c))
        u = {
          ...u,
          [f]: {
            configurable: !1,
            enumerable: !0,
            get: () => (i.current.includes(f) || i.current.push(f), d)
          }
        }
      return Object.defineProperties(c, u), c
    }
    return s
  }, [s])
}
function One(t = {}) {
  const e = Ys(t)
  return Ine(
    n => lI(e, { onChange: n }),
    () => ep(e)
  )
}
var Id = class {
    constructor() {
      ;(this.listeners = new Set()), (this.subscribe = this.subscribe.bind(this))
    }
    subscribe(t) {
      return (
        this.listeners.add(t),
        this.onSubscribe(),
        () => {
          this.listeners.delete(t), this.onUnsubscribe()
        }
      )
    }
    hasListeners() {
      return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
  },
  hu = typeof window > 'u' || 'Deno' in globalThis
function $i() {}
function Rne(t, e) {
  return typeof t == 'function' ? t(e) : t
}
function yE(t) {
  return typeof t == 'number' && t >= 0 && t !== 1 / 0
}
function gI(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0)
}
function Fl(t, e) {
  return typeof t == 'function' ? t(e) : t
}
function cs(t, e) {
  return typeof t == 'function' ? t(e) : t
}
function d8(t, e) {
  const { type: n = 'all', exact: r, fetchStatus: i, predicate: s, queryKey: c, stale: u } = t
  if (c) {
    if (r) {
      if (e.queryHash !== z2(c, e.options)) return !1
    } else if (!np(e.queryKey, c)) return !1
  }
  if (n !== 'all') {
    const f = e.isActive()
    if ((n === 'active' && !f) || (n === 'inactive' && f)) return !1
  }
  return !(
    (typeof u == 'boolean' && e.isStale() !== u) ||
    (i && i !== e.state.fetchStatus) ||
    (s && !s(e))
  )
}
function f8(t, e) {
  const { exact: n, status: r, predicate: i, mutationKey: s } = t
  if (s) {
    if (!e.options.mutationKey) return !1
    if (n) {
      if (pu(e.options.mutationKey) !== pu(s)) return !1
    } else if (!np(e.options.mutationKey, s)) return !1
  }
  return !((r && e.state.status !== r) || (i && !i(e)))
}
function z2(t, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || pu)(t)
}
function pu(t) {
  return JSON.stringify(t, (e, n) =>
    vE(n)
      ? Object.keys(n)
          .sort()
          .reduce((r, i) => ((r[i] = n[i]), r), {})
      : n
  )
}
function np(t, e) {
  return t === e
    ? !0
    : typeof t != typeof e
      ? !1
      : t && e && typeof t == 'object' && typeof e == 'object'
        ? !Object.keys(e).some(n => !np(t[n], e[n]))
        : !1
}
function q2(t, e) {
  if (t === e) return t
  const n = h8(t) && h8(e)
  if (n || (vE(t) && vE(e))) {
    const r = n ? t : Object.keys(t),
      i = r.length,
      s = n ? e : Object.keys(e),
      c = s.length,
      u = n ? [] : {}
    let f = 0
    for (let d = 0; d < c; d++) {
      const p = n ? d : s[d]
      ;((!n && r.includes(p)) || n) && t[p] === void 0 && e[p] === void 0
        ? ((u[p] = void 0), f++)
        : ((u[p] = q2(t[p], e[p])), u[p] === t[p] && t[p] !== void 0 && f++)
    }
    return i === c && f === i ? t : u
  }
  return e
}
function vm(t, e) {
  if (!e || Object.keys(t).length !== Object.keys(e).length) return !1
  for (const n in t) if (t[n] !== e[n]) return !1
  return !0
}
function h8(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length
}
function vE(t) {
  if (!p8(t)) return !1
  const e = t.constructor
  if (e === void 0) return !0
  const n = e.prototype
  return !(
    !p8(n) ||
    !n.hasOwnProperty('isPrototypeOf') ||
    Object.getPrototypeOf(t) !== Object.prototype
  )
}
function p8(t) {
  return Object.prototype.toString.call(t) === '[object Object]'
}
function Dne(t) {
  return new Promise(e => {
    setTimeout(e, t)
  })
}
function wE(t, e, n) {
  return typeof n.structuralSharing == 'function'
    ? n.structuralSharing(t, e)
    : n.structuralSharing !== !1
      ? q2(t, e)
      : e
}
function Pne(t, e, n = 0) {
  const r = [...t, e]
  return n && r.length > n ? r.slice(1) : r
}
function Mne(t, e, n = 0) {
  const r = [e, ...t]
  return n && r.length > n ? r.slice(0, -1) : r
}
var H2 = Symbol()
function mI(t, e) {
  return !t.queryFn && e != null && e.initialPromise
    ? () => e.initialPromise
    : !t.queryFn || t.queryFn === H2
      ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`))
      : t.queryFn
}
var Lc,
  So,
  zl,
  R8,
  kne =
    ((R8 = class extends Id {
      constructor() {
        super()
        Ue(this, Lc)
        Ue(this, So)
        Ue(this, zl)
        Ee(this, zl, e => {
          if (!hu && window.addEventListener) {
            const n = () => e()
            return (
              window.addEventListener('visibilitychange', n, !1),
              () => {
                window.removeEventListener('visibilitychange', n)
              }
            )
          }
        })
      }
      onSubscribe() {
        W(this, So) || this.setEventListener(W(this, zl))
      }
      onUnsubscribe() {
        var e
        this.hasListeners() || ((e = W(this, So)) == null || e.call(this), Ee(this, So, void 0))
      }
      setEventListener(e) {
        var n
        Ee(this, zl, e),
          (n = W(this, So)) == null || n.call(this),
          Ee(
            this,
            So,
            e(r => {
              typeof r == 'boolean' ? this.setFocused(r) : this.onFocus()
            })
          )
      }
      setFocused(e) {
        W(this, Lc) !== e && (Ee(this, Lc, e), this.onFocus())
      }
      onFocus() {
        const e = this.isFocused()
        this.listeners.forEach(n => {
          n(e)
        })
      }
      isFocused() {
        var e
        return typeof W(this, Lc) == 'boolean'
          ? W(this, Lc)
          : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== 'hidden'
      }
    }),
    (Lc = new WeakMap()),
    (So = new WeakMap()),
    (zl = new WeakMap()),
    R8),
  G2 = new kne(),
  ql,
  To,
  Hl,
  D8,
  Une =
    ((D8 = class extends Id {
      constructor() {
        super()
        Ue(this, ql, !0)
        Ue(this, To)
        Ue(this, Hl)
        Ee(this, Hl, e => {
          if (!hu && window.addEventListener) {
            const n = () => e(!0),
              r = () => e(!1)
            return (
              window.addEventListener('online', n, !1),
              window.addEventListener('offline', r, !1),
              () => {
                window.removeEventListener('online', n), window.removeEventListener('offline', r)
              }
            )
          }
        })
      }
      onSubscribe() {
        W(this, To) || this.setEventListener(W(this, Hl))
      }
      onUnsubscribe() {
        var e
        this.hasListeners() || ((e = W(this, To)) == null || e.call(this), Ee(this, To, void 0))
      }
      setEventListener(e) {
        var n
        Ee(this, Hl, e),
          (n = W(this, To)) == null || n.call(this),
          Ee(this, To, e(this.setOnline.bind(this)))
      }
      setOnline(e) {
        W(this, ql) !== e &&
          (Ee(this, ql, e),
          this.listeners.forEach(r => {
            r(e)
          }))
      }
      isOnline() {
        return W(this, ql)
      }
    }),
    (ql = new WeakMap()),
    (To = new WeakMap()),
    (Hl = new WeakMap()),
    D8),
  wm = new Une()
function EE() {
  let t, e
  const n = new Promise((i, s) => {
    ;(t = i), (e = s)
  })
  ;(n.status = 'pending'), n.catch(() => {})
  function r(i) {
    Object.assign(n, i), delete n.resolve, delete n.reject
  }
  return (
    (n.resolve = i => {
      r({ status: 'fulfilled', value: i }), t(i)
    }),
    (n.reject = i => {
      r({ status: 'rejected', reason: i }), e(i)
    }),
    n
  )
}
function Bne(t) {
  return Math.min(1e3 * 2 ** t, 3e4)
}
function bI(t) {
  return (t ?? 'online') === 'online' ? wm.isOnline() : !0
}
var yI = class extends Error {
  constructor(t) {
    super('CancelledError'),
      (this.revert = t == null ? void 0 : t.revert),
      (this.silent = t == null ? void 0 : t.silent)
  }
}
function rw(t) {
  return t instanceof yI
}
function vI(t) {
  let e = !1,
    n = 0,
    r = !1,
    i
  const s = EE(),
    c = E => {
      var x
      r || (m(new yI(E)), (x = t.abort) == null || x.call(t))
    },
    u = () => {
      e = !0
    },
    f = () => {
      e = !1
    },
    d = () => G2.isFocused() && (t.networkMode === 'always' || wm.isOnline()) && t.canRun(),
    p = () => bI(t.networkMode) && t.canRun(),
    g = E => {
      var x
      r || ((r = !0), (x = t.onSuccess) == null || x.call(t, E), i == null || i(), s.resolve(E))
    },
    m = E => {
      var x
      r || ((r = !0), (x = t.onError) == null || x.call(t, E), i == null || i(), s.reject(E))
    },
    y = () =>
      new Promise(E => {
        var x
        ;(i = O => {
          ;(r || d()) && E(O)
        }),
          (x = t.onPause) == null || x.call(t)
      }).then(() => {
        var E
        ;(i = void 0), r || (E = t.onContinue) == null || E.call(t)
      }),
    A = () => {
      if (r) return
      let E
      const x = n === 0 ? t.initialPromise : void 0
      try {
        E = x ?? t.fn()
      } catch (O) {
        E = Promise.reject(O)
      }
      Promise.resolve(E)
        .then(g)
        .catch(O => {
          var R
          if (r) return
          const I = t.retry ?? (hu ? 0 : 3),
            M = t.retryDelay ?? Bne,
            $ = typeof M == 'function' ? M(n, O) : M,
            D = I === !0 || (typeof I == 'number' && n < I) || (typeof I == 'function' && I(n, O))
          if (e || !D) {
            m(O)
            return
          }
          n++,
            (R = t.onFail) == null || R.call(t, n, O),
            Dne($)
              .then(() => (d() ? void 0 : y()))
              .then(() => {
                e ? m(O) : A()
              })
        })
    }
  return {
    promise: s,
    cancel: c,
    continue: () => (i == null || i(), s),
    cancelRetry: u,
    continueRetry: f,
    canStart: p,
    start: () => (p() ? A() : y().then(A), s)
  }
}
function Lne() {
  let t = [],
    e = 0,
    n = u => {
      u()
    },
    r = u => {
      u()
    },
    i = u => setTimeout(u, 0)
  const s = u => {
      e
        ? t.push(u)
        : i(() => {
            n(u)
          })
    },
    c = () => {
      const u = t
      ;(t = []),
        u.length &&
          i(() => {
            r(() => {
              u.forEach(f => {
                n(f)
              })
            })
          })
    }
  return {
    batch: u => {
      let f
      e++
      try {
        f = u()
      } finally {
        e--, e || c()
      }
      return f
    },
    batchCalls:
      u =>
      (...f) => {
        s(() => {
          u(...f)
        })
      },
    schedule: s,
    setNotifyFunction: u => {
      n = u
    },
    setBatchNotifyFunction: u => {
      r = u
    },
    setScheduler: u => {
      i = u
    }
  }
}
var er = Lne(),
  $c,
  P8,
  wI =
    ((P8 = class {
      constructor() {
        Ue(this, $c)
      }
      destroy() {
        this.clearGcTimeout()
      }
      scheduleGc() {
        this.clearGcTimeout(),
          yE(this.gcTime) &&
            Ee(
              this,
              $c,
              setTimeout(() => {
                this.optionalRemove()
              }, this.gcTime)
            )
      }
      updateGcTime(t) {
        this.gcTime = Math.max(this.gcTime || 0, t ?? (hu ? 1 / 0 : 5 * 60 * 1e3))
      }
      clearGcTimeout() {
        W(this, $c) && (clearTimeout(W(this, $c)), Ee(this, $c, void 0))
      }
    }),
    ($c = new WeakMap()),
    P8),
  Gl,
  Vl,
  Bi,
  Fc,
  Nr,
  op,
  jc,
  ss,
  Ta,
  M8,
  $ne =
    ((M8 = class extends wI {
      constructor(e) {
        super()
        Ue(this, ss)
        Ue(this, Gl)
        Ue(this, Vl)
        Ue(this, Bi)
        Ue(this, Fc)
        Ue(this, Nr)
        Ue(this, op)
        Ue(this, jc)
        Ee(this, jc, !1),
          Ee(this, op, e.defaultOptions),
          this.setOptions(e.options),
          (this.observers = []),
          Ee(this, Fc, e.client),
          Ee(this, Bi, W(this, Fc).getQueryCache()),
          (this.queryKey = e.queryKey),
          (this.queryHash = e.queryHash),
          Ee(this, Gl, Fne(this.options)),
          (this.state = e.state ?? W(this, Gl)),
          this.scheduleGc()
      }
      get meta() {
        return this.options.meta
      }
      get promise() {
        var e
        return (e = W(this, Nr)) == null ? void 0 : e.promise
      }
      setOptions(e) {
        ;(this.options = { ...W(this, op), ...e }), this.updateGcTime(this.options.gcTime)
      }
      optionalRemove() {
        !this.observers.length && this.state.fetchStatus === 'idle' && W(this, Bi).remove(this)
      }
      setData(e, n) {
        const r = wE(this.state.data, e, this.options)
        return (
          Ye(this, ss, Ta).call(this, {
            data: r,
            type: 'success',
            dataUpdatedAt: n == null ? void 0 : n.updatedAt,
            manual: n == null ? void 0 : n.manual
          }),
          r
        )
      }
      setState(e, n) {
        Ye(this, ss, Ta).call(this, { type: 'setState', state: e, setStateOptions: n })
      }
      cancel(e) {
        var r, i
        const n = (r = W(this, Nr)) == null ? void 0 : r.promise
        return (
          (i = W(this, Nr)) == null || i.cancel(e), n ? n.then($i).catch($i) : Promise.resolve()
        )
      }
      destroy() {
        super.destroy(), this.cancel({ silent: !0 })
      }
      reset() {
        this.destroy(), this.setState(W(this, Gl))
      }
      isActive() {
        return this.observers.some(e => cs(e.options.enabled, this) !== !1)
      }
      isDisabled() {
        return this.getObserversCount() > 0
          ? !this.isActive()
          : this.options.queryFn === H2 ||
              this.state.dataUpdateCount + this.state.errorUpdateCount === 0
      }
      isStale() {
        return this.state.isInvalidated
          ? !0
          : this.getObserversCount() > 0
            ? this.observers.some(e => e.getCurrentResult().isStale)
            : this.state.data === void 0
      }
      isStaleByTime(e = 0) {
        return (
          this.state.isInvalidated || this.state.data === void 0 || !gI(this.state.dataUpdatedAt, e)
        )
      }
      onFocus() {
        var n
        const e = this.observers.find(r => r.shouldFetchOnWindowFocus())
        e == null || e.refetch({ cancelRefetch: !1 }), (n = W(this, Nr)) == null || n.continue()
      }
      onOnline() {
        var n
        const e = this.observers.find(r => r.shouldFetchOnReconnect())
        e == null || e.refetch({ cancelRefetch: !1 }), (n = W(this, Nr)) == null || n.continue()
      }
      addObserver(e) {
        this.observers.includes(e) ||
          (this.observers.push(e),
          this.clearGcTimeout(),
          W(this, Bi).notify({ type: 'observerAdded', query: this, observer: e }))
      }
      removeObserver(e) {
        this.observers.includes(e) &&
          ((this.observers = this.observers.filter(n => n !== e)),
          this.observers.length ||
            (W(this, Nr) &&
              (W(this, jc) ? W(this, Nr).cancel({ revert: !0 }) : W(this, Nr).cancelRetry()),
            this.scheduleGc()),
          W(this, Bi).notify({ type: 'observerRemoved', query: this, observer: e }))
      }
      getObserversCount() {
        return this.observers.length
      }
      invalidate() {
        this.state.isInvalidated || Ye(this, ss, Ta).call(this, { type: 'invalidate' })
      }
      fetch(e, n) {
        var f, d, p
        if (this.state.fetchStatus !== 'idle') {
          if (this.state.data !== void 0 && n != null && n.cancelRefetch)
            this.cancel({ silent: !0 })
          else if (W(this, Nr)) return W(this, Nr).continueRetry(), W(this, Nr).promise
        }
        if ((e && this.setOptions(e), !this.options.queryFn)) {
          const g = this.observers.find(m => m.options.queryFn)
          g && this.setOptions(g.options)
        }
        const r = new AbortController(),
          i = g => {
            Object.defineProperty(g, 'signal', {
              enumerable: !0,
              get: () => (Ee(this, jc, !0), r.signal)
            })
          },
          s = () => {
            const g = mI(this.options, n),
              m = { client: W(this, Fc), queryKey: this.queryKey, meta: this.meta }
            return (
              i(m),
              Ee(this, jc, !1),
              this.options.persister ? this.options.persister(g, m, this) : g(m)
            )
          },
          c = {
            fetchOptions: n,
            options: this.options,
            queryKey: this.queryKey,
            client: W(this, Fc),
            state: this.state,
            fetchFn: s
          }
        i(c),
          (f = this.options.behavior) == null || f.onFetch(c, this),
          Ee(this, Vl, this.state),
          (this.state.fetchStatus === 'idle' ||
            this.state.fetchMeta !== ((d = c.fetchOptions) == null ? void 0 : d.meta)) &&
            Ye(this, ss, Ta).call(this, {
              type: 'fetch',
              meta: (p = c.fetchOptions) == null ? void 0 : p.meta
            })
        const u = g => {
          var m, y, A, E
          ;(rw(g) && g.silent) || Ye(this, ss, Ta).call(this, { type: 'error', error: g }),
            rw(g) ||
              ((y = (m = W(this, Bi).config).onError) == null || y.call(m, g, this),
              (E = (A = W(this, Bi).config).onSettled) == null ||
                E.call(A, this.state.data, g, this)),
            this.scheduleGc()
        }
        return (
          Ee(
            this,
            Nr,
            vI({
              initialPromise: n == null ? void 0 : n.initialPromise,
              fn: c.fetchFn,
              abort: r.abort.bind(r),
              onSuccess: g => {
                var m, y, A, E
                if (g === void 0) {
                  u(new Error(`${this.queryHash} data is undefined`))
                  return
                }
                try {
                  this.setData(g)
                } catch (x) {
                  u(x)
                  return
                }
                ;(y = (m = W(this, Bi).config).onSuccess) == null || y.call(m, g, this),
                  (E = (A = W(this, Bi).config).onSettled) == null ||
                    E.call(A, g, this.state.error, this),
                  this.scheduleGc()
              },
              onError: u,
              onFail: (g, m) => {
                Ye(this, ss, Ta).call(this, { type: 'failed', failureCount: g, error: m })
              },
              onPause: () => {
                Ye(this, ss, Ta).call(this, { type: 'pause' })
              },
              onContinue: () => {
                Ye(this, ss, Ta).call(this, { type: 'continue' })
              },
              retry: c.options.retry,
              retryDelay: c.options.retryDelay,
              networkMode: c.options.networkMode,
              canRun: () => !0
            })
          ),
          W(this, Nr).start()
        )
      }
    }),
    (Gl = new WeakMap()),
    (Vl = new WeakMap()),
    (Bi = new WeakMap()),
    (Fc = new WeakMap()),
    (Nr = new WeakMap()),
    (op = new WeakMap()),
    (jc = new WeakMap()),
    (ss = new WeakSet()),
    (Ta = function (e) {
      const n = r => {
        switch (e.type) {
          case 'failed':
            return { ...r, fetchFailureCount: e.failureCount, fetchFailureReason: e.error }
          case 'pause':
            return { ...r, fetchStatus: 'paused' }
          case 'continue':
            return { ...r, fetchStatus: 'fetching' }
          case 'fetch':
            return { ...r, ...EI(r.data, this.options), fetchMeta: e.meta ?? null }
          case 'success':
            return {
              ...r,
              data: e.data,
              dataUpdateCount: r.dataUpdateCount + 1,
              dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
              error: null,
              isInvalidated: !1,
              status: 'success',
              ...(!e.manual && {
                fetchStatus: 'idle',
                fetchFailureCount: 0,
                fetchFailureReason: null
              })
            }
          case 'error':
            const i = e.error
            return rw(i) && i.revert && W(this, Vl)
              ? { ...W(this, Vl), fetchStatus: 'idle' }
              : {
                  ...r,
                  error: i,
                  errorUpdateCount: r.errorUpdateCount + 1,
                  errorUpdatedAt: Date.now(),
                  fetchFailureCount: r.fetchFailureCount + 1,
                  fetchFailureReason: i,
                  fetchStatus: 'idle',
                  status: 'error'
                }
          case 'invalidate':
            return { ...r, isInvalidated: !0 }
          case 'setState':
            return { ...r, ...e.state }
        }
      }
      ;(this.state = n(this.state)),
        er.batch(() => {
          this.observers.forEach(r => {
            r.onQueryUpdate()
          }),
            W(this, Bi).notify({ query: this, type: 'updated', action: e })
        })
    }),
    M8)
function EI(t, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: bI(e.networkMode) ? 'fetching' : 'paused',
    ...(t === void 0 && { error: null, status: 'pending' })
  }
}
function Fne(t) {
  const e = typeof t.initialData == 'function' ? t.initialData() : t.initialData,
    n = e !== void 0,
    r = n
      ? typeof t.initialDataUpdatedAt == 'function'
        ? t.initialDataUpdatedAt()
        : t.initialDataUpdatedAt
      : 0
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? (r ?? Date.now()) : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? 'success' : 'pending',
    fetchStatus: 'idle'
  }
}
var ks,
  k8,
  jne =
    ((k8 = class extends Id {
      constructor(e = {}) {
        super()
        Ue(this, ks)
        ;(this.config = e), Ee(this, ks, new Map())
      }
      build(e, n, r) {
        const i = n.queryKey,
          s = n.queryHash ?? z2(i, n)
        let c = this.get(s)
        return (
          c ||
            ((c = new $ne({
              client: e,
              queryKey: i,
              queryHash: s,
              options: e.defaultQueryOptions(n),
              state: r,
              defaultOptions: e.getQueryDefaults(i)
            })),
            this.add(c)),
          c
        )
      }
      add(e) {
        W(this, ks).has(e.queryHash) ||
          (W(this, ks).set(e.queryHash, e), this.notify({ type: 'added', query: e }))
      }
      remove(e) {
        const n = W(this, ks).get(e.queryHash)
        n &&
          (e.destroy(),
          n === e && W(this, ks).delete(e.queryHash),
          this.notify({ type: 'removed', query: e }))
      }
      clear() {
        er.batch(() => {
          this.getAll().forEach(e => {
            this.remove(e)
          })
        })
      }
      get(e) {
        return W(this, ks).get(e)
      }
      getAll() {
        return [...W(this, ks).values()]
      }
      find(e) {
        const n = { exact: !0, ...e }
        return this.getAll().find(r => d8(n, r))
      }
      findAll(e = {}) {
        const n = this.getAll()
        return Object.keys(e).length > 0 ? n.filter(r => d8(e, r)) : n
      }
      notify(e) {
        er.batch(() => {
          this.listeners.forEach(n => {
            n(e)
          })
        })
      }
      onFocus() {
        er.batch(() => {
          this.getAll().forEach(e => {
            e.onFocus()
          })
        })
      }
      onOnline() {
        er.batch(() => {
          this.getAll().forEach(e => {
            e.onOnline()
          })
        })
      }
    }),
    (ks = new WeakMap()),
    k8),
  Us,
  Br,
  zc,
  Bs,
  vo,
  U8,
  zne =
    ((U8 = class extends wI {
      constructor(e) {
        super()
        Ue(this, Bs)
        Ue(this, Us)
        Ue(this, Br)
        Ue(this, zc)
        ;(this.mutationId = e.mutationId),
          Ee(this, Br, e.mutationCache),
          Ee(this, Us, []),
          (this.state = e.state || AI()),
          this.setOptions(e.options),
          this.scheduleGc()
      }
      setOptions(e) {
        ;(this.options = e), this.updateGcTime(this.options.gcTime)
      }
      get meta() {
        return this.options.meta
      }
      addObserver(e) {
        W(this, Us).includes(e) ||
          (W(this, Us).push(e),
          this.clearGcTimeout(),
          W(this, Br).notify({ type: 'observerAdded', mutation: this, observer: e }))
      }
      removeObserver(e) {
        Ee(
          this,
          Us,
          W(this, Us).filter(n => n !== e)
        ),
          this.scheduleGc(),
          W(this, Br).notify({ type: 'observerRemoved', mutation: this, observer: e })
      }
      optionalRemove() {
        W(this, Us).length ||
          (this.state.status === 'pending' ? this.scheduleGc() : W(this, Br).remove(this))
      }
      continue() {
        var e
        return (
          ((e = W(this, zc)) == null ? void 0 : e.continue()) ?? this.execute(this.state.variables)
        )
      }
      async execute(e) {
        var i, s, c, u, f, d, p, g, m, y, A, E, x, O, I, M, $, D, R, z
        Ee(
          this,
          zc,
          vI({
            fn: () =>
              this.options.mutationFn
                ? this.options.mutationFn(e)
                : Promise.reject(new Error('No mutationFn found')),
            onFail: (G, j) => {
              Ye(this, Bs, vo).call(this, { type: 'failed', failureCount: G, error: j })
            },
            onPause: () => {
              Ye(this, Bs, vo).call(this, { type: 'pause' })
            },
            onContinue: () => {
              Ye(this, Bs, vo).call(this, { type: 'continue' })
            },
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => W(this, Br).canRun(this)
          })
        )
        const n = this.state.status === 'pending',
          r = !W(this, zc).canStart()
        try {
          if (!n) {
            Ye(this, Bs, vo).call(this, { type: 'pending', variables: e, isPaused: r }),
              await ((s = (i = W(this, Br).config).onMutate) == null ? void 0 : s.call(i, e, this))
            const j = await ((u = (c = this.options).onMutate) == null ? void 0 : u.call(c, e))
            j !== this.state.context &&
              Ye(this, Bs, vo).call(this, {
                type: 'pending',
                context: j,
                variables: e,
                isPaused: r
              })
          }
          const G = await W(this, zc).start()
          return (
            await ((d = (f = W(this, Br).config).onSuccess) == null
              ? void 0
              : d.call(f, G, e, this.state.context, this)),
            await ((g = (p = this.options).onSuccess) == null
              ? void 0
              : g.call(p, G, e, this.state.context)),
            await ((y = (m = W(this, Br).config).onSettled) == null
              ? void 0
              : y.call(m, G, null, this.state.variables, this.state.context, this)),
            await ((E = (A = this.options).onSettled) == null
              ? void 0
              : E.call(A, G, null, e, this.state.context)),
            Ye(this, Bs, vo).call(this, { type: 'success', data: G }),
            G
          )
        } catch (G) {
          try {
            throw (
              (await ((O = (x = W(this, Br).config).onError) == null
                ? void 0
                : O.call(x, G, e, this.state.context, this)),
              await ((M = (I = this.options).onError) == null
                ? void 0
                : M.call(I, G, e, this.state.context)),
              await ((D = ($ = W(this, Br).config).onSettled) == null
                ? void 0
                : D.call($, void 0, G, this.state.variables, this.state.context, this)),
              await ((z = (R = this.options).onSettled) == null
                ? void 0
                : z.call(R, void 0, G, e, this.state.context)),
              G)
            )
          } finally {
            Ye(this, Bs, vo).call(this, { type: 'error', error: G })
          }
        } finally {
          W(this, Br).runNext(this)
        }
      }
    }),
    (Us = new WeakMap()),
    (Br = new WeakMap()),
    (zc = new WeakMap()),
    (Bs = new WeakSet()),
    (vo = function (e) {
      const n = r => {
        switch (e.type) {
          case 'failed':
            return { ...r, failureCount: e.failureCount, failureReason: e.error }
          case 'pause':
            return { ...r, isPaused: !0 }
          case 'continue':
            return { ...r, isPaused: !1 }
          case 'pending':
            return {
              ...r,
              context: e.context,
              data: void 0,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: e.isPaused,
              status: 'pending',
              variables: e.variables,
              submittedAt: Date.now()
            }
          case 'success':
            return {
              ...r,
              data: e.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: 'success',
              isPaused: !1
            }
          case 'error':
            return {
              ...r,
              data: void 0,
              error: e.error,
              failureCount: r.failureCount + 1,
              failureReason: e.error,
              isPaused: !1,
              status: 'error'
            }
        }
      }
      ;(this.state = n(this.state)),
        er.batch(() => {
          W(this, Us).forEach(r => {
            r.onMutationUpdate(e)
          }),
            W(this, Br).notify({ mutation: this, type: 'updated', action: e })
        })
    }),
    U8)
function AI() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: 'idle',
    variables: void 0,
    submittedAt: 0
  }
}
var xa,
  as,
  cp,
  B8,
  qne =
    ((B8 = class extends Id {
      constructor(e = {}) {
        super()
        Ue(this, xa)
        Ue(this, as)
        Ue(this, cp)
        ;(this.config = e), Ee(this, xa, new Set()), Ee(this, as, new Map()), Ee(this, cp, 0)
      }
      build(e, n, r) {
        const i = new zne({
          mutationCache: this,
          mutationId: ++W0(this, cp)._,
          options: e.defaultMutationOptions(n),
          state: r
        })
        return this.add(i), i
      }
      add(e) {
        W(this, xa).add(e)
        const n = Ag(e)
        if (typeof n == 'string') {
          const r = W(this, as).get(n)
          r ? r.push(e) : W(this, as).set(n, [e])
        }
        this.notify({ type: 'added', mutation: e })
      }
      remove(e) {
        if (W(this, xa).delete(e)) {
          const n = Ag(e)
          if (typeof n == 'string') {
            const r = W(this, as).get(n)
            if (r)
              if (r.length > 1) {
                const i = r.indexOf(e)
                i !== -1 && r.splice(i, 1)
              } else r[0] === e && W(this, as).delete(n)
          }
        }
        this.notify({ type: 'removed', mutation: e })
      }
      canRun(e) {
        const n = Ag(e)
        if (typeof n == 'string') {
          const r = W(this, as).get(n),
            i = r == null ? void 0 : r.find(s => s.state.status === 'pending')
          return !i || i === e
        } else return !0
      }
      runNext(e) {
        var r
        const n = Ag(e)
        if (typeof n == 'string') {
          const i =
            (r = W(this, as).get(n)) == null ? void 0 : r.find(s => s !== e && s.state.isPaused)
          return (i == null ? void 0 : i.continue()) ?? Promise.resolve()
        } else return Promise.resolve()
      }
      clear() {
        er.batch(() => {
          W(this, xa).forEach(e => {
            this.notify({ type: 'removed', mutation: e })
          }),
            W(this, xa).clear(),
            W(this, as).clear()
        })
      }
      getAll() {
        return Array.from(W(this, xa))
      }
      find(e) {
        const n = { exact: !0, ...e }
        return this.getAll().find(r => f8(n, r))
      }
      findAll(e = {}) {
        return this.getAll().filter(n => f8(e, n))
      }
      notify(e) {
        er.batch(() => {
          this.listeners.forEach(n => {
            n(e)
          })
        })
      }
      resumePausedMutations() {
        const e = this.getAll().filter(n => n.state.isPaused)
        return er.batch(() => Promise.all(e.map(n => n.continue().catch($i))))
      }
    }),
    (xa = new WeakMap()),
    (as = new WeakMap()),
    (cp = new WeakMap()),
    B8)
function Ag(t) {
  var e
  return (e = t.options.scope) == null ? void 0 : e.id
}
function g8(t) {
  return {
    onFetch: (e, n) => {
      var p, g, m, y, A
      const r = e.options,
        i =
          (m =
            (g = (p = e.fetchOptions) == null ? void 0 : p.meta) == null ? void 0 : g.fetchMore) ==
          null
            ? void 0
            : m.direction,
        s = ((y = e.state.data) == null ? void 0 : y.pages) || [],
        c = ((A = e.state.data) == null ? void 0 : A.pageParams) || []
      let u = { pages: [], pageParams: [] },
        f = 0
      const d = async () => {
        let E = !1
        const x = M => {
            Object.defineProperty(M, 'signal', {
              enumerable: !0,
              get: () => (
                e.signal.aborted
                  ? (E = !0)
                  : e.signal.addEventListener('abort', () => {
                      E = !0
                    }),
                e.signal
              )
            })
          },
          O = mI(e.options, e.fetchOptions),
          I = async (M, $, D) => {
            if (E) return Promise.reject()
            if ($ == null && M.pages.length) return Promise.resolve(M)
            const R = {
              client: e.client,
              queryKey: e.queryKey,
              pageParam: $,
              direction: D ? 'backward' : 'forward',
              meta: e.options.meta
            }
            x(R)
            const z = await O(R),
              { maxPages: G } = e.options,
              j = D ? Mne : Pne
            return { pages: j(M.pages, z, G), pageParams: j(M.pageParams, $, G) }
          }
        if (i && s.length) {
          const M = i === 'backward',
            $ = M ? Hne : m8,
            D = { pages: s, pageParams: c },
            R = $(r, D)
          u = await I(D, R, M)
        } else {
          const M = t ?? s.length
          do {
            const $ = f === 0 ? (c[0] ?? r.initialPageParam) : m8(r, u)
            if (f > 0 && $ == null) break
            ;(u = await I(u, $)), f++
          } while (f < M)
        }
        return u
      }
      e.options.persister
        ? (e.fetchFn = () => {
            var E, x
            return (x = (E = e.options).persister) == null
              ? void 0
              : x.call(
                  E,
                  d,
                  {
                    client: e.client,
                    queryKey: e.queryKey,
                    meta: e.options.meta,
                    signal: e.signal
                  },
                  n
                )
          })
        : (e.fetchFn = d)
    }
  }
}
function m8(t, { pages: e, pageParams: n }) {
  const r = e.length - 1
  return e.length > 0 ? t.getNextPageParam(e[r], e, n[r], n) : void 0
}
function Hne(t, { pages: e, pageParams: n }) {
  var r
  return e.length > 0
    ? (r = t.getPreviousPageParam) == null
      ? void 0
      : r.call(t, e[0], e, n[0], n)
    : void 0
}
var Un,
  xo,
  No,
  Kl,
  Wl,
  Io,
  Ql,
  Yl,
  L8,
  Gne =
    ((L8 = class {
      constructor(t = {}) {
        Ue(this, Un)
        Ue(this, xo)
        Ue(this, No)
        Ue(this, Kl)
        Ue(this, Wl)
        Ue(this, Io)
        Ue(this, Ql)
        Ue(this, Yl)
        Ee(this, Un, t.queryCache || new jne()),
          Ee(this, xo, t.mutationCache || new qne()),
          Ee(this, No, t.defaultOptions || {}),
          Ee(this, Kl, new Map()),
          Ee(this, Wl, new Map()),
          Ee(this, Io, 0)
      }
      mount() {
        W0(this, Io)._++,
          W(this, Io) === 1 &&
            (Ee(
              this,
              Ql,
              G2.subscribe(async t => {
                t && (await this.resumePausedMutations(), W(this, Un).onFocus())
              })
            ),
            Ee(
              this,
              Yl,
              wm.subscribe(async t => {
                t && (await this.resumePausedMutations(), W(this, Un).onOnline())
              })
            ))
      }
      unmount() {
        var t, e
        W0(this, Io)._--,
          W(this, Io) === 0 &&
            ((t = W(this, Ql)) == null || t.call(this),
            Ee(this, Ql, void 0),
            (e = W(this, Yl)) == null || e.call(this),
            Ee(this, Yl, void 0))
      }
      isFetching(t) {
        return W(this, Un).findAll({ ...t, fetchStatus: 'fetching' }).length
      }
      isMutating(t) {
        return W(this, xo).findAll({ ...t, status: 'pending' }).length
      }
      getQueryData(t) {
        var n
        const e = this.defaultQueryOptions({ queryKey: t })
        return (n = W(this, Un).get(e.queryHash)) == null ? void 0 : n.state.data
      }
      ensureQueryData(t) {
        const e = this.defaultQueryOptions(t),
          n = W(this, Un).build(this, e),
          r = n.state.data
        return r === void 0
          ? this.fetchQuery(t)
          : (t.revalidateIfStale && n.isStaleByTime(Fl(e.staleTime, n)) && this.prefetchQuery(e),
            Promise.resolve(r))
      }
      getQueriesData(t) {
        return W(this, Un)
          .findAll(t)
          .map(({ queryKey: e, state: n }) => {
            const r = n.data
            return [e, r]
          })
      }
      setQueryData(t, e, n) {
        const r = this.defaultQueryOptions({ queryKey: t }),
          i = W(this, Un).get(r.queryHash),
          s = i == null ? void 0 : i.state.data,
          c = Rne(e, s)
        if (c !== void 0)
          return W(this, Un)
            .build(this, r)
            .setData(c, { ...n, manual: !0 })
      }
      setQueriesData(t, e, n) {
        return er.batch(() =>
          W(this, Un)
            .findAll(t)
            .map(({ queryKey: r }) => [r, this.setQueryData(r, e, n)])
        )
      }
      getQueryState(t) {
        var n
        const e = this.defaultQueryOptions({ queryKey: t })
        return (n = W(this, Un).get(e.queryHash)) == null ? void 0 : n.state
      }
      removeQueries(t) {
        const e = W(this, Un)
        er.batch(() => {
          e.findAll(t).forEach(n => {
            e.remove(n)
          })
        })
      }
      resetQueries(t, e) {
        const n = W(this, Un)
        return er.batch(
          () => (
            n.findAll(t).forEach(r => {
              r.reset()
            }),
            this.refetchQueries({ type: 'active', ...t }, e)
          )
        )
      }
      cancelQueries(t, e = {}) {
        const n = { revert: !0, ...e },
          r = er.batch(() =>
            W(this, Un)
              .findAll(t)
              .map(i => i.cancel(n))
          )
        return Promise.all(r).then($i).catch($i)
      }
      invalidateQueries(t, e = {}) {
        return er.batch(
          () => (
            W(this, Un)
              .findAll(t)
              .forEach(n => {
                n.invalidate()
              }),
            (t == null ? void 0 : t.refetchType) === 'none'
              ? Promise.resolve()
              : this.refetchQueries(
                  {
                    ...t,
                    type:
                      (t == null ? void 0 : t.refetchType) ??
                      (t == null ? void 0 : t.type) ??
                      'active'
                  },
                  e
                )
          )
        )
      }
      refetchQueries(t, e = {}) {
        const n = { ...e, cancelRefetch: e.cancelRefetch ?? !0 },
          r = er.batch(() =>
            W(this, Un)
              .findAll(t)
              .filter(i => !i.isDisabled())
              .map(i => {
                let s = i.fetch(void 0, n)
                return (
                  n.throwOnError || (s = s.catch($i)),
                  i.state.fetchStatus === 'paused' ? Promise.resolve() : s
                )
              })
          )
        return Promise.all(r).then($i)
      }
      fetchQuery(t) {
        const e = this.defaultQueryOptions(t)
        e.retry === void 0 && (e.retry = !1)
        const n = W(this, Un).build(this, e)
        return n.isStaleByTime(Fl(e.staleTime, n)) ? n.fetch(e) : Promise.resolve(n.state.data)
      }
      prefetchQuery(t) {
        return this.fetchQuery(t).then($i).catch($i)
      }
      fetchInfiniteQuery(t) {
        return (t.behavior = g8(t.pages)), this.fetchQuery(t)
      }
      prefetchInfiniteQuery(t) {
        return this.fetchInfiniteQuery(t).then($i).catch($i)
      }
      ensureInfiniteQueryData(t) {
        return (t.behavior = g8(t.pages)), this.ensureQueryData(t)
      }
      resumePausedMutations() {
        return wm.isOnline() ? W(this, xo).resumePausedMutations() : Promise.resolve()
      }
      getQueryCache() {
        return W(this, Un)
      }
      getMutationCache() {
        return W(this, xo)
      }
      getDefaultOptions() {
        return W(this, No)
      }
      setDefaultOptions(t) {
        Ee(this, No, t)
      }
      setQueryDefaults(t, e) {
        W(this, Kl).set(pu(t), { queryKey: t, defaultOptions: e })
      }
      getQueryDefaults(t) {
        const e = [...W(this, Kl).values()],
          n = {}
        return (
          e.forEach(r => {
            np(t, r.queryKey) && Object.assign(n, r.defaultOptions)
          }),
          n
        )
      }
      setMutationDefaults(t, e) {
        W(this, Wl).set(pu(t), { mutationKey: t, defaultOptions: e })
      }
      getMutationDefaults(t) {
        const e = [...W(this, Wl).values()],
          n = {}
        return (
          e.forEach(r => {
            np(t, r.mutationKey) && Object.assign(n, r.defaultOptions)
          }),
          n
        )
      }
      defaultQueryOptions(t) {
        if (t._defaulted) return t
        const e = {
          ...W(this, No).queries,
          ...this.getQueryDefaults(t.queryKey),
          ...t,
          _defaulted: !0
        }
        return (
          e.queryHash || (e.queryHash = z2(e.queryKey, e)),
          e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== 'always'),
          e.throwOnError === void 0 && (e.throwOnError = !!e.suspense),
          !e.networkMode && e.persister && (e.networkMode = 'offlineFirst'),
          e.queryFn === H2 && (e.enabled = !1),
          e
        )
      }
      defaultMutationOptions(t) {
        return t != null && t._defaulted
          ? t
          : {
              ...W(this, No).mutations,
              ...((t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey)),
              ...t,
              _defaulted: !0
            }
      }
      clear() {
        W(this, Un).clear(), W(this, xo).clear()
      }
    }),
    (Un = new WeakMap()),
    (xo = new WeakMap()),
    (No = new WeakMap()),
    (Kl = new WeakMap()),
    (Wl = new WeakMap()),
    (Io = new WeakMap()),
    (Ql = new WeakMap()),
    (Yl = new WeakMap()),
    L8),
  Xr,
  pt,
  up,
  Lr,
  qc,
  Zl,
  Oo,
  Ls,
  lp,
  Xl,
  Jl,
  Hc,
  Gc,
  Ro,
  ed,
  Mt,
  sh,
  AE,
  _E,
  CE,
  SE,
  TE,
  xE,
  NE,
  _I,
  $8,
  Vne =
    (($8 = class extends Id {
      constructor(e, n) {
        super()
        Ue(this, Mt)
        Ue(this, Xr)
        Ue(this, pt)
        Ue(this, up)
        Ue(this, Lr)
        Ue(this, qc)
        Ue(this, Zl)
        Ue(this, Oo)
        Ue(this, Ls)
        Ue(this, lp)
        Ue(this, Xl)
        Ue(this, Jl)
        Ue(this, Hc)
        Ue(this, Gc)
        Ue(this, Ro)
        Ue(this, ed, new Set())
        ;(this.options = n),
          Ee(this, Xr, e),
          Ee(this, Ls, null),
          Ee(this, Oo, EE()),
          this.options.experimental_prefetchInRender ||
            W(this, Oo).reject(
              new Error('experimental_prefetchInRender feature flag is not enabled')
            ),
          this.bindMethods(),
          this.setOptions(n)
      }
      bindMethods() {
        this.refetch = this.refetch.bind(this)
      }
      onSubscribe() {
        this.listeners.size === 1 &&
          (W(this, pt).addObserver(this),
          b8(W(this, pt), this.options) ? Ye(this, Mt, sh).call(this) : this.updateResult(),
          Ye(this, Mt, SE).call(this))
      }
      onUnsubscribe() {
        this.hasListeners() || this.destroy()
      }
      shouldFetchOnReconnect() {
        return IE(W(this, pt), this.options, this.options.refetchOnReconnect)
      }
      shouldFetchOnWindowFocus() {
        return IE(W(this, pt), this.options, this.options.refetchOnWindowFocus)
      }
      destroy() {
        ;(this.listeners = new Set()),
          Ye(this, Mt, TE).call(this),
          Ye(this, Mt, xE).call(this),
          W(this, pt).removeObserver(this)
      }
      setOptions(e) {
        const n = this.options,
          r = W(this, pt)
        if (
          ((this.options = W(this, Xr).defaultQueryOptions(e)),
          this.options.enabled !== void 0 &&
            typeof this.options.enabled != 'boolean' &&
            typeof this.options.enabled != 'function' &&
            typeof cs(this.options.enabled, W(this, pt)) != 'boolean')
        )
          throw new Error('Expected enabled to be a boolean or a callback that returns a boolean')
        Ye(this, Mt, NE).call(this),
          W(this, pt).setOptions(this.options),
          n._defaulted &&
            !vm(this.options, n) &&
            W(this, Xr)
              .getQueryCache()
              .notify({ type: 'observerOptionsUpdated', query: W(this, pt), observer: this })
        const i = this.hasListeners()
        i && y8(W(this, pt), r, this.options, n) && Ye(this, Mt, sh).call(this),
          this.updateResult(),
          i &&
            (W(this, pt) !== r ||
              cs(this.options.enabled, W(this, pt)) !== cs(n.enabled, W(this, pt)) ||
              Fl(this.options.staleTime, W(this, pt)) !== Fl(n.staleTime, W(this, pt))) &&
            Ye(this, Mt, AE).call(this)
        const s = Ye(this, Mt, _E).call(this)
        i &&
          (W(this, pt) !== r ||
            cs(this.options.enabled, W(this, pt)) !== cs(n.enabled, W(this, pt)) ||
            s !== W(this, Ro)) &&
          Ye(this, Mt, CE).call(this, s)
      }
      getOptimisticResult(e) {
        const n = W(this, Xr).getQueryCache().build(W(this, Xr), e),
          r = this.createResult(n, e)
        return (
          Wne(this, r) &&
            (Ee(this, Lr, r), Ee(this, Zl, this.options), Ee(this, qc, W(this, pt).state)),
          r
        )
      }
      getCurrentResult() {
        return W(this, Lr)
      }
      trackResult(e, n) {
        const r = {}
        return (
          Object.keys(e).forEach(i => {
            Object.defineProperty(r, i, {
              configurable: !1,
              enumerable: !0,
              get: () => (this.trackProp(i), n == null || n(i), e[i])
            })
          }),
          r
        )
      }
      trackProp(e) {
        W(this, ed).add(e)
      }
      getCurrentQuery() {
        return W(this, pt)
      }
      refetch({ ...e } = {}) {
        return this.fetch({ ...e })
      }
      fetchOptimistic(e) {
        const n = W(this, Xr).defaultQueryOptions(e),
          r = W(this, Xr).getQueryCache().build(W(this, Xr), n)
        return r.fetch().then(() => this.createResult(r, n))
      }
      fetch(e) {
        return Ye(this, Mt, sh)
          .call(this, { ...e, cancelRefetch: e.cancelRefetch ?? !0 })
          .then(() => (this.updateResult(), W(this, Lr)))
      }
      createResult(e, n) {
        var G
        const r = W(this, pt),
          i = this.options,
          s = W(this, Lr),
          c = W(this, qc),
          u = W(this, Zl),
          d = e !== r ? e.state : W(this, up),
          { state: p } = e
        let g = { ...p },
          m = !1,
          y
        if (n._optimisticResults) {
          const j = this.hasListeners(),
            V = !j && b8(e, n),
            L = j && y8(e, r, n, i)
          ;(V || L) && (g = { ...g, ...EI(p.data, e.options) }),
            n._optimisticResults === 'isRestoring' && (g.fetchStatus = 'idle')
        }
        let { error: A, errorUpdatedAt: E, status: x } = g
        if (n.select && g.data !== void 0)
          if (s && g.data === (c == null ? void 0 : c.data) && n.select === W(this, lp))
            y = W(this, Xl)
          else
            try {
              Ee(this, lp, n.select),
                (y = n.select(g.data)),
                (y = wE(s == null ? void 0 : s.data, y, n)),
                Ee(this, Xl, y),
                Ee(this, Ls, null)
            } catch (j) {
              Ee(this, Ls, j)
            }
        else y = g.data
        if (n.placeholderData !== void 0 && y === void 0 && x === 'pending') {
          let j
          if (
            s != null &&
            s.isPlaceholderData &&
            n.placeholderData === (u == null ? void 0 : u.placeholderData)
          )
            j = s.data
          else if (
            ((j =
              typeof n.placeholderData == 'function'
                ? n.placeholderData((G = W(this, Jl)) == null ? void 0 : G.state.data, W(this, Jl))
                : n.placeholderData),
            n.select && j !== void 0)
          )
            try {
              ;(j = n.select(j)), Ee(this, Ls, null)
            } catch (V) {
              Ee(this, Ls, V)
            }
          j !== void 0 && ((x = 'success'), (y = wE(s == null ? void 0 : s.data, j, n)), (m = !0))
        }
        W(this, Ls) && ((A = W(this, Ls)), (y = W(this, Xl)), (E = Date.now()), (x = 'error'))
        const O = g.fetchStatus === 'fetching',
          I = x === 'pending',
          M = x === 'error',
          $ = I && O,
          D = y !== void 0,
          z = {
            status: x,
            fetchStatus: g.fetchStatus,
            isPending: I,
            isSuccess: x === 'success',
            isError: M,
            isInitialLoading: $,
            isLoading: $,
            data: y,
            dataUpdatedAt: g.dataUpdatedAt,
            error: A,
            errorUpdatedAt: E,
            failureCount: g.fetchFailureCount,
            failureReason: g.fetchFailureReason,
            errorUpdateCount: g.errorUpdateCount,
            isFetched: g.dataUpdateCount > 0 || g.errorUpdateCount > 0,
            isFetchedAfterMount:
              g.dataUpdateCount > d.dataUpdateCount || g.errorUpdateCount > d.errorUpdateCount,
            isFetching: O,
            isRefetching: O && !I,
            isLoadingError: M && !D,
            isPaused: g.fetchStatus === 'paused',
            isPlaceholderData: m,
            isRefetchError: M && D,
            isStale: V2(e, n),
            refetch: this.refetch,
            promise: W(this, Oo)
          }
        if (this.options.experimental_prefetchInRender) {
          const j = v => {
              z.status === 'error' ? v.reject(z.error) : z.data !== void 0 && v.resolve(z.data)
            },
            V = () => {
              const v = Ee(this, Oo, (z.promise = EE()))
              j(v)
            },
            L = W(this, Oo)
          switch (L.status) {
            case 'pending':
              e.queryHash === r.queryHash && j(L)
              break
            case 'fulfilled':
              ;(z.status === 'error' || z.data !== L.value) && V()
              break
            case 'rejected':
              ;(z.status !== 'error' || z.error !== L.reason) && V()
              break
          }
        }
        return z
      }
      updateResult() {
        const e = W(this, Lr),
          n = this.createResult(W(this, pt), this.options)
        if (
          (Ee(this, qc, W(this, pt).state),
          Ee(this, Zl, this.options),
          W(this, qc).data !== void 0 && Ee(this, Jl, W(this, pt)),
          vm(n, e))
        )
          return
        Ee(this, Lr, n)
        const r = () => {
          if (!e) return !0
          const { notifyOnChangeProps: i } = this.options,
            s = typeof i == 'function' ? i() : i
          if (s === 'all' || (!s && !W(this, ed).size)) return !0
          const c = new Set(s ?? W(this, ed))
          return (
            this.options.throwOnError && c.add('error'),
            Object.keys(W(this, Lr)).some(u => {
              const f = u
              return W(this, Lr)[f] !== e[f] && c.has(f)
            })
          )
        }
        Ye(this, Mt, _I).call(this, { listeners: r() })
      }
      onQueryUpdate() {
        this.updateResult(), this.hasListeners() && Ye(this, Mt, SE).call(this)
      }
    }),
    (Xr = new WeakMap()),
    (pt = new WeakMap()),
    (up = new WeakMap()),
    (Lr = new WeakMap()),
    (qc = new WeakMap()),
    (Zl = new WeakMap()),
    (Oo = new WeakMap()),
    (Ls = new WeakMap()),
    (lp = new WeakMap()),
    (Xl = new WeakMap()),
    (Jl = new WeakMap()),
    (Hc = new WeakMap()),
    (Gc = new WeakMap()),
    (Ro = new WeakMap()),
    (ed = new WeakMap()),
    (Mt = new WeakSet()),
    (sh = function (e) {
      Ye(this, Mt, NE).call(this)
      let n = W(this, pt).fetch(this.options, e)
      return (e != null && e.throwOnError) || (n = n.catch($i)), n
    }),
    (AE = function () {
      Ye(this, Mt, TE).call(this)
      const e = Fl(this.options.staleTime, W(this, pt))
      if (hu || W(this, Lr).isStale || !yE(e)) return
      const r = gI(W(this, Lr).dataUpdatedAt, e) + 1
      Ee(
        this,
        Hc,
        setTimeout(() => {
          W(this, Lr).isStale || this.updateResult()
        }, r)
      )
    }),
    (_E = function () {
      return (
        (typeof this.options.refetchInterval == 'function'
          ? this.options.refetchInterval(W(this, pt))
          : this.options.refetchInterval) ?? !1
      )
    }),
    (CE = function (e) {
      Ye(this, Mt, xE).call(this),
        Ee(this, Ro, e),
        !(
          hu ||
          cs(this.options.enabled, W(this, pt)) === !1 ||
          !yE(W(this, Ro)) ||
          W(this, Ro) === 0
        ) &&
          Ee(
            this,
            Gc,
            setInterval(
              () => {
                ;(this.options.refetchIntervalInBackground || G2.isFocused()) &&
                  Ye(this, Mt, sh).call(this)
              },
              W(this, Ro)
            )
          )
    }),
    (SE = function () {
      Ye(this, Mt, AE).call(this), Ye(this, Mt, CE).call(this, Ye(this, Mt, _E).call(this))
    }),
    (TE = function () {
      W(this, Hc) && (clearTimeout(W(this, Hc)), Ee(this, Hc, void 0))
    }),
    (xE = function () {
      W(this, Gc) && (clearInterval(W(this, Gc)), Ee(this, Gc, void 0))
    }),
    (NE = function () {
      const e = W(this, Xr).getQueryCache().build(W(this, Xr), this.options)
      if (e === W(this, pt)) return
      const n = W(this, pt)
      Ee(this, pt, e),
        Ee(this, up, e.state),
        this.hasListeners() && (n == null || n.removeObserver(this), e.addObserver(this))
    }),
    (_I = function (e) {
      er.batch(() => {
        e.listeners &&
          this.listeners.forEach(n => {
            n(W(this, Lr))
          }),
          W(this, Xr)
            .getQueryCache()
            .notify({ query: W(this, pt), type: 'observerResultsUpdated' })
      })
    }),
    $8)
function Kne(t, e) {
  return (
    cs(e.enabled, t) !== !1 &&
    t.state.data === void 0 &&
    !(t.state.status === 'error' && e.retryOnMount === !1)
  )
}
function b8(t, e) {
  return Kne(t, e) || (t.state.data !== void 0 && IE(t, e, e.refetchOnMount))
}
function IE(t, e, n) {
  if (cs(e.enabled, t) !== !1) {
    const r = typeof n == 'function' ? n(t) : n
    return r === 'always' || (r !== !1 && V2(t, e))
  }
  return !1
}
function y8(t, e, n, r) {
  return (
    (t !== e || cs(r.enabled, t) === !1) && (!n.suspense || t.state.status !== 'error') && V2(t, n)
  )
}
function V2(t, e) {
  return cs(e.enabled, t) !== !1 && t.isStaleByTime(Fl(e.staleTime, t))
}
function Wne(t, e) {
  return !vm(t.getCurrentResult(), e)
}
var Do,
  Po,
  Jr,
  Na,
  Ma,
  $g,
  OE,
  F8,
  Qne =
    ((F8 = class extends Id {
      constructor(n, r) {
        super()
        Ue(this, Ma)
        Ue(this, Do)
        Ue(this, Po)
        Ue(this, Jr)
        Ue(this, Na)
        Ee(this, Do, n), this.setOptions(r), this.bindMethods(), Ye(this, Ma, $g).call(this)
      }
      bindMethods() {
        ;(this.mutate = this.mutate.bind(this)), (this.reset = this.reset.bind(this))
      }
      setOptions(n) {
        var i
        const r = this.options
        ;(this.options = W(this, Do).defaultMutationOptions(n)),
          vm(this.options, r) ||
            W(this, Do)
              .getMutationCache()
              .notify({ type: 'observerOptionsUpdated', mutation: W(this, Jr), observer: this }),
          r != null &&
          r.mutationKey &&
          this.options.mutationKey &&
          pu(r.mutationKey) !== pu(this.options.mutationKey)
            ? this.reset()
            : ((i = W(this, Jr)) == null ? void 0 : i.state.status) === 'pending' &&
              W(this, Jr).setOptions(this.options)
      }
      onUnsubscribe() {
        var n
        this.hasListeners() || (n = W(this, Jr)) == null || n.removeObserver(this)
      }
      onMutationUpdate(n) {
        Ye(this, Ma, $g).call(this), Ye(this, Ma, OE).call(this, n)
      }
      getCurrentResult() {
        return W(this, Po)
      }
      reset() {
        var n
        ;(n = W(this, Jr)) == null || n.removeObserver(this),
          Ee(this, Jr, void 0),
          Ye(this, Ma, $g).call(this),
          Ye(this, Ma, OE).call(this)
      }
      mutate(n, r) {
        var i
        return (
          Ee(this, Na, r),
          (i = W(this, Jr)) == null || i.removeObserver(this),
          Ee(this, Jr, W(this, Do).getMutationCache().build(W(this, Do), this.options)),
          W(this, Jr).addObserver(this),
          W(this, Jr).execute(n)
        )
      }
    }),
    (Do = new WeakMap()),
    (Po = new WeakMap()),
    (Jr = new WeakMap()),
    (Na = new WeakMap()),
    (Ma = new WeakSet()),
    ($g = function () {
      var r
      const n = ((r = W(this, Jr)) == null ? void 0 : r.state) ?? AI()
      Ee(this, Po, {
        ...n,
        isPending: n.status === 'pending',
        isSuccess: n.status === 'success',
        isError: n.status === 'error',
        isIdle: n.status === 'idle',
        mutate: this.mutate,
        reset: this.reset
      })
    }),
    (OE = function (n) {
      er.batch(() => {
        var r, i, s, c, u, f, d, p
        if (W(this, Na) && this.hasListeners()) {
          const g = W(this, Po).variables,
            m = W(this, Po).context
          ;(n == null ? void 0 : n.type) === 'success'
            ? ((i = (r = W(this, Na)).onSuccess) == null || i.call(r, n.data, g, m),
              (c = (s = W(this, Na)).onSettled) == null || c.call(s, n.data, null, g, m))
            : (n == null ? void 0 : n.type) === 'error' &&
              ((f = (u = W(this, Na)).onError) == null || f.call(u, n.error, g, m),
              (p = (d = W(this, Na)).onSettled) == null || p.call(d, void 0, n.error, g, m))
        }
        this.listeners.forEach(g => {
          g(W(this, Po))
        })
      })
    }),
    F8)
function Yne(t, e) {
  return q2(t, e)
}
function Zne(t) {
  return JSON.stringify(t, (e, n) =>
    Xne(n)
      ? Object.keys(n)
          .sort()
          .reduce((r, i) => ((r[i] = n[i]), r), {})
      : typeof n == 'bigint'
        ? n.toString()
        : n
  )
}
function Xne(t) {
  if (!v8(t)) return !1
  const e = t.constructor
  if (typeof e > 'u') return !0
  const n = e.prototype
  return !(!v8(n) || !n.hasOwnProperty('isPrototypeOf'))
}
function v8(t) {
  return Object.prototype.toString.call(t) === '[object Object]'
}
function Mp(t) {
  const {
    _defaulted: e,
    behavior: n,
    gcTime: r,
    initialData: i,
    initialDataUpdatedAt: s,
    maxPages: c,
    meta: u,
    networkMode: f,
    queryFn: d,
    queryHash: p,
    queryKey: g,
    queryKeyHashFn: m,
    retry: y,
    retryDelay: A,
    structuralSharing: E,
    getPreviousPageParam: x,
    getNextPageParam: O,
    initialPageParam: I,
    _optimisticResults: M,
    enabled: $,
    notifyOnChangeProps: D,
    placeholderData: R,
    refetchInterval: z,
    refetchIntervalInBackground: G,
    refetchOnMount: j,
    refetchOnReconnect: V,
    refetchOnWindowFocus: L,
    retryOnMount: v,
    select: C,
    staleTime: N,
    suspense: T,
    throwOnError: S,
    config: k,
    connector: F,
    query: P,
    ...w
  } = t
  return w
}
function Jne(t, e = {}) {
  return {
    async queryFn({ queryKey: n }) {
      const { connector: r } = e,
        { account: i, scopeKey: s, ...c } = n[1]
      if (!i && !r) throw new Error('account or connector is required')
      return rI(t, { account: i, connector: r, ...c })
    },
    queryKey: ere(e)
  }
}
function ere(t = {}) {
  const { connector: e, ...n } = t
  return ['estimateGas', Mp(n)]
}
function tre(t, e = {}) {
  return {
    async queryFn({ queryKey: n }) {
      const { address: r, scopeKey: i, ...s } = n[1]
      if (!r) throw new Error('address is required')
      return (await aI(t, { ...s, address: r })) ?? null
    },
    queryKey: nre(e)
  }
}
function nre(t = {}) {
  return ['balance', Mp(t)]
}
function rre(t, e = {}) {
  return {
    gcTime: 0,
    async queryFn({ queryKey: n }) {
      const { connector: r } = e,
        { connectorUid: i, scopeKey: s, ...c } = n[1]
      return Pp(t, { ...c, connector: r })
    },
    queryKey: ire(e)
  }
}
function ire(t = {}) {
  const { connector: e, ...n } = t
  return ['connectorClient', { ...Mp(n), connectorUid: e == null ? void 0 : e.uid }]
}
function sre(t, e = {}) {
  return {
    async queryFn({ queryKey: n }) {
      const r = e.abi
      if (!r) throw new Error('abi is required')
      const { functionName: i, scopeKey: s, ...c } = n[1],
        u = (() => {
          const f = n[1]
          if (f.address) return { address: f.address }
          if (f.code) return { code: f.code }
          throw new Error('address or code is required')
        })()
      if (!i) throw new Error('functionName is required')
      return sI(t, { abi: r, functionName: i, args: c.args, ...u, ...c })
    },
    queryKey: are(e)
  }
}
function are(t = {}) {
  const { abi: e, ...n } = t
  return ['readContract', Mp(n)]
}
function ore(t) {
  return {
    mutationFn(e) {
      return cI(t, e)
    },
    mutationKey: ['sendTransaction']
  }
}
function cre(t) {
  return {
    mutationFn(e) {
      return uI(t, e)
    },
    mutationKey: ['signMessage']
  }
}
function ure(t, e = {}) {
  return {
    async queryFn({ queryKey: n }) {
      const { hash: r, ...i } = n[1]
      if (!r) throw new Error('hash is required')
      return dI(t, { ...i, onReplaced: e.onReplaced, hash: r })
    },
    queryKey: lre(e)
  }
}
function lre(t = {}) {
  const { onReplaced: e, ...n } = t
  return ['waitForTransactionReceipt', Mp(n)]
}
function dre(t) {
  return {
    mutationFn(e) {
      return fI(t, e)
    },
    mutationKey: ['writeContract']
  }
}
var CI = Le.createContext(void 0),
  K2 = t => {
    const e = Le.useContext(CI)
    if (!e) throw new Error('No QueryClient set, use QueryClientProvider to set one')
    return e
  },
  fre = ({ client: t, children: e }) => (
    Le.useEffect(
      () => (
        t.mount(),
        () => {
          t.unmount()
        }
      ),
      [t]
    ),
    De.jsx(CI.Provider, { value: t, children: e })
  ),
  SI = Le.createContext(!1),
  hre = () => Le.useContext(SI)
SI.Provider
function pre() {
  let t = !1
  return {
    clearReset: () => {
      t = !1
    },
    reset: () => {
      t = !0
    },
    isReset: () => t
  }
}
var gre = Le.createContext(pre()),
  mre = () => Le.useContext(gre)
function TI(t, e) {
  return typeof t == 'function' ? t(...e) : !!t
}
function RE() {}
var bre = (t, e) => {
    ;(t.suspense || t.throwOnError || t.experimental_prefetchInRender) &&
      (e.isReset() || (t.retryOnMount = !1))
  },
  yre = t => {
    Le.useEffect(() => {
      t.clearReset()
    }, [t])
  },
  vre = ({ result: t, errorResetBoundary: e, throwOnError: n, query: r, suspense: i }) =>
    t.isError &&
    !e.isReset() &&
    !t.isFetching &&
    r &&
    ((i && t.data === void 0) || TI(n, [t.error, r])),
  wre = t => {
    const e = t.staleTime
    t.suspense &&
      ((t.staleTime =
        typeof e == 'function' ? (...n) => Math.max(e(...n), 1e3) : Math.max(e ?? 1e3, 1e3)),
      typeof t.gcTime == 'number' && (t.gcTime = Math.max(t.gcTime, 1e3)))
  },
  Ere = (t, e) => t.isLoading && t.isFetching && !e,
  Are = (t, e) => (t == null ? void 0 : t.suspense) && e.isPending,
  w8 = (t, e, n) =>
    e.fetchOptimistic(t).catch(() => {
      n.clearReset()
    })
function _re(t, e, n) {
  var g, m, y, A, E
  const r = K2(),
    i = hre(),
    s = mre(),
    c = r.defaultQueryOptions(t)
  ;(m = (g = r.getDefaultOptions().queries) == null ? void 0 : g._experimental_beforeQuery) ==
    null || m.call(g, c),
    (c._optimisticResults = i ? 'isRestoring' : 'optimistic'),
    wre(c),
    bre(c, s),
    yre(s)
  const u = !r.getQueryCache().get(c.queryHash),
    [f] = Le.useState(() => new e(r, c)),
    d = f.getOptimisticResult(c),
    p = !i && t.subscribed !== !1
  if (
    (Le.useSyncExternalStore(
      Le.useCallback(
        x => {
          const O = p ? f.subscribe(er.batchCalls(x)) : RE
          return f.updateResult(), O
        },
        [f, p]
      ),
      () => f.getCurrentResult(),
      () => f.getCurrentResult()
    ),
    Le.useEffect(() => {
      f.setOptions(c)
    }, [c, f]),
    Are(c, d))
  )
    throw w8(c, f, s)
  if (
    vre({
      result: d,
      errorResetBoundary: s,
      throwOnError: c.throwOnError,
      query: r.getQueryCache().get(c.queryHash),
      suspense: c.suspense
    })
  )
    throw d.error
  if (
    ((A = (y = r.getDefaultOptions().queries) == null ? void 0 : y._experimental_afterQuery) ==
      null || A.call(y, c, d),
    c.experimental_prefetchInRender && !hu && Ere(d, i))
  ) {
    const x = u
      ? w8(c, f, s)
      : (E = r.getQueryCache().get(c.queryHash)) == null
        ? void 0
        : E.promise
    x == null ||
      x.catch(RE).finally(() => {
        f.updateResult()
      })
  }
  return c.notifyOnChangeProps ? d : f.trackResult(d)
}
function Cre(t, e) {
  return _re(t, Vne)
}
function W2(t, e) {
  const n = K2(),
    [r] = Le.useState(() => new Qne(n, t))
  Le.useEffect(() => {
    r.setOptions(t)
  }, [r, t])
  const i = Le.useSyncExternalStore(
      Le.useCallback(c => r.subscribe(er.batchCalls(c)), [r]),
      () => r.getCurrentResult(),
      () => r.getCurrentResult()
    ),
    s = Le.useCallback(
      (c, u) => {
        r.mutate(c, u).catch(RE)
      },
      [r]
    )
  if (i.error && TI(r.options.throwOnError, [i.error])) throw i.error
  return { ...i, mutate: s, mutateAsync: i.mutate }
}
function kp(t) {
  const e = Cre({ ...t, queryKeyHashFn: Zne })
  return (e.queryKey = t.queryKey), e
}
function Up(t = {}) {
  const e = Ys(t)
  return Le.useSyncExternalStore(
    n => Wte(e, { onChange: n }),
    () => n8(e),
    () => n8(e)
  )
}
function Sre(t = {}) {
  const { address: e, query: n = {} } = t,
    r = Ys(t),
    i = Up({ config: r }),
    s = tre(r, { ...t, chainId: t.chainId ?? i }),
    c = !!(e && (n.enabled ?? !0))
  return kp({ ...n, ...s, enabled: c })
}
function Tre(t = {}) {
  const { query: e = {}, ...n } = t,
    r = Ys(n),
    i = K2(),
    { address: s, connector: c, status: u } = One({ config: r }),
    f = Up({ config: r }),
    d = t.connector ?? c,
    { queryKey: p, ...g } = rre(r, { ...t, chainId: t.chainId ?? f, connector: d }),
    m = !!(
      (u === 'connected' || (u === 'reconnecting' && d != null && d.getProvider)) &&
      (e.enabled ?? !0)
    ),
    y = Le.useRef(s)
  return (
    Le.useEffect(() => {
      const A = y.current
      !s && A
        ? (i.removeQueries({ queryKey: p }), (y.current = void 0))
        : s !== A && (i.invalidateQueries({ queryKey: p }), (y.current = s))
    }, [s, i]),
    kp({ ...e, ...g, queryKey: p, enabled: m, staleTime: Number.POSITIVE_INFINITY })
  )
}
function xre(t = {}) {
  const { connector: e, query: n = {} } = t,
    r = Ys(t),
    { data: i } = Tre({ config: r, connector: e, query: { enabled: t.account === void 0 } }),
    s = t.account ?? (i == null ? void 0 : i.account),
    c = Up({ config: r }),
    u = Jne(r, { ...t, account: s, chainId: t.chainId ?? c, connector: e }),
    f = !!((s || e) && (n.enabled ?? !0))
  return kp({ ...n, ...u, enabled: f })
}
function Nre(t = {}) {
  const { abi: e, address: n, functionName: r, query: i = {} } = t,
    s = t.code,
    c = Ys(t),
    u = Up({ config: c }),
    f = sre(c, { ...t, chainId: t.chainId ?? u }),
    d = !!((n || s) && e && r && (i.enabled ?? !0))
  return kp({ ...i, ...f, enabled: d, structuralSharing: i.structuralSharing ?? Yne })
}
function Ire(t = {}) {
  const { mutation: e } = t,
    n = Ys(t),
    r = ore(n),
    { mutate: i, mutateAsync: s, ...c } = W2({ ...e, ...r })
  return { ...c, sendTransaction: i, sendTransactionAsync: s }
}
function Ore(t = {}) {
  const { mutation: e } = t,
    n = Ys(t),
    r = cre(n),
    { mutate: i, mutateAsync: s, ...c } = W2({ ...e, ...r })
  return { ...c, signMessage: i, signMessageAsync: s }
}
function Rre(t = {}) {
  const { hash: e, query: n = {} } = t,
    r = Ys(t),
    i = Up({ config: r }),
    s = ure(r, { ...t, chainId: t.chainId ?? i }),
    c = !!(e && (n.enabled ?? !0))
  return kp({ ...n, ...s, enabled: c })
}
function Dre(t = {}) {
  const { mutation: e } = t,
    n = Ys(t),
    r = dre(n),
    { mutate: i, mutateAsync: s, ...c } = W2({ ...e, ...r })
  return { ...c, writeContract: i, writeContractAsync: s }
}
var Pre =
  'AEkU4AngDVgB0QKRAQYBOwDqATEAnwDbAIUApABsAOAAbwCRAEYAiQBPAHYAPgA+ACsANwAlAGMAHwAvACsAJQAWAC8AGwAiACIALwAUACsAEQAiAAsAGwARABcAGAA6ACkALAAsADUAFgAsABEAHQAhAA8AGwAdABUAFgAZAA0ADQAXABAAGQAUABIEqgYJAR4UFjfDBdMAsQCuPwFnAKUBA10jAK5/Ly8vLwE/pwUJ6/0HPwbkMQVXBVgAPSs5APa2EQbIwQuUCkEDyJ4zAsUKLwKOoQKG2D+Ob4kCxcsCg/IBH98JAPKtAUECLY0KP48A4wDiChUAF9S5yAwLPZ0EG3cA/QI5GL0P6wkGKekFBIFnDRsHLQCrAGmR76WcfwBbBpMjBukAGwA7DJMAWxVbqfu75wzbIM8IuykDsRQ7APcta6MAoX0YABcEJdcWAR0AuRnNBPoJIEw3CZcJiB4bVllM44NCABMADAAVAA5rVAAhAA4AR+4V2D3zOVjKleYuChAdX01YPewAEwAMABUADmsgXECXAMPrABsAOQzFABsVW6n7Adq4HB0FWwXiAtCfAsSwCkwcpGUUcxptTPUAuw1nAuEACy00iRfJkQKBewETGwC9DWcC4QALLQFIUCWRTAoDLfsFMgnXaRetAddDAEkrEncCMRYhAusnuTdrADnhAfUlAMcOy7UBG2OBALEFAAUAitNJBRvDHwcXAKgn0QGhKy0DmwBnAQoZPu03dAQYFwCqAccCIQDTKxJzOvNQsAWQOncnNUgF+icFWQVYr7gFaTtdQhI6WEGXe5NmX6H4CxMDxQcl8XcjBKNLAlNTAnUbqycBj6OlNVsDRRcEg2EJANEGqz8vIwcpAjldAGsBYR9xAIMdGQCVAUm3ACdpFwGvxQM3LSFDUwFvWQZlAmUA8UkXAykBBQBJQQCrAF0AcwArtQYH8+8ZjX8ACSEAKQCzG0cB0QHbBwsxl3iB6AAKABEANAA9ADgzd3nTwBBfEFwBTQlMbDoVCwKsD6YL5REVDNEqy9PYADSpB+sDUwfrA1MDUwfrB+sDUwfrA1MDUwNTA1McCvAa08AQXw9IBG0FjgWLBNYIgyZJEYEHKAjSVA10HhxHA0UA/CMlSRw7kzMLJUJMDE0DB/w2QmynfTgDRzGrVPWQogPLMk85bAEecRKgACoPcxw1tU5+ekdxoApLT661f0liTmcCvjqoP/gKIQmTb7t3TgY9EBcnoRDzDC8BsQE3DelL1ATtBjcExR95GRUPyZWYCKEt2QzpJt8unYBWI/EqfwXpS/A82QtJUWQPVQthCd86X4FKAx0BCSKHCtkNNQhpEO8KxWcN4RFBBzUD0UmWAKEG/QsNHTEVsSYMYqgLBTlzBvca8guLJqsTJXr4Bc8aHQZJASUa+wDLLuOFrFotXBhPWwX/CyEjwxSkUBwNIUCzeEQaFwcRJaUCjUNsSoNRMh6PIfI8OQ1iLg9ReAfxPAEZSwt9PJpGp0UKEc4+iT1EIkVMKAQxeywrJ4cJyw+BDLV8bgFVCR0JrQxtEy0REzfBCDUHFSmXICcRCB1GkWCWBPObA+8TzQMHBTsJPQcPA7EcKRMqFSUFCYEg0wLvNtEurwKLVnwBEwXHDyEf2xBMR9wO5QiXAmEDfyXnACkVHQATIpcIP18AW4/UUwEuxwjDamgjcANjFONdEW8HjQ5TB6McLxW7HN1wxF4HhgQon6sJVwFxCZUBWwTfCAU1V4ycID1nT4tUGJcgXUE7XfgCLQxhFZtEuYd0AocPZxIXATEBbwc1DP0CcxHpEWcQkQjnhgA1sTP0OiEESyF/IA0KIwNLbMoLIyb1DPRlAZ8SXgMINDl36menYLIgF/kHFTLBQVwh7QuOT8kMmBq9GD5UKhngB7sD7xrvJ+ZBUwX7A58POkkz6gS5C2UIhwk7AEUOnxMH0xhmCm2MzAEthwGzlQNTjX8Ca4sGMwcHAGMHgwV14QAZAqMInwABAMsDUwA1AqkHmQAVAIE9ATkDIysBHeECiwOPCC3HAZErAe8lBBe/DBEA8zNuRgLDrQKAZmaeBdlUAooCRTEBSSEEAUpDTQOrbd0A1wBHBg/bQwERp0bHFt8/AdtrJwDDAPcAATEHAT0ByQHvaQCzAVsLLQmer7EBSeUlAH8AEWcB0wKFANkAMQB77QFPAEkFVfUFzwJLRQENLRQnU10BtwMbAS8BCQB1BseJocUDGwRpB88CEBcV3QLvKgexAyLbE8lCwQK92lEAMhIKNAq1CrQfX/NcLwItbj1MAAofpD7DP0oFTTtPO1Q7TztUO087VDtPO1Q7TztUA5O73rveCmhfQWHnDKIN0ETEOkUT12BNYC4TxC2zFL0VyiVSGTkauCcBJeBVBQ8ALc9mLAgoNHEXuAA7KWSDPWOCHiwKRxzjU41U9C0XAK1LnjOrDagbEUQ8BUN16WImFgoKHgJkfQJiPldJq1c3HAKh8wJolAJmBQKfgDgXBwJmNwJmIgRqBHsDfw8Dfo45AjlzEzl+Oh8fAmwZAjIyOAYCbcMCbarrhi9jQScBYwDaAN0ARgEHlAyJAPoHvgAJsQJ3KwJ2njsCeUc/Ani2GVjXRapG0wJ8OwJ6xAJ9BQJ87AVVBRxH/Eh5XyAAJxFJVEpXERNKyALQ/QLQyEsjA4hLA4fiRMGRLgLynVz/AwOqS8pMKSHLTUhNqwKLOwKK1L0XAxk/YwGzAo4zAo5YPJN9Ao7VAo5YdFGwUzEGUtBUgQKT9wKTCADlABhVGlWrVcwCLBcpkYIy3XhiRTc1ApebAu+uWB2kAFUhApaLApZ4mAClWahaBX1JADcClrEClkpcQFzNApnHAplgXMZdAxUCnJc5vjqZApwSAp+XAp60hgAZCy0mCwKd7QKejgCxOWEwYesCns8CoGoBpQKemxsCnkqhY8RkIyEnAierAiZ6AqD3AqBIAqLZAqHAAqYrAqXKAqf7AHkCp+5oeGit/0VqGGrNAqzfAqyqAq1jAqz+AlcZAlXYArHd0wMfSmyTArK5CQKy5BNs3G1fbURbAyXJArZYNztujAMpQQK4WgK5QxECuSZzcDJw3QK9FQK71nCSAzINAr6Ecf4DM20CvhZzHnNLAsPHAsMAc350RzFBdNwDPKMDPJYDPbsCxXgCxkMCxgyFAshlTQLIQALJSwLJKgJkmQLdznh1XXiqeSFLzAMYn2b+AmHwGe+VIHsHXo5etw0Cz2cCz2grR0/O7w+bAMKpAs9vASXmA04OfkcBAtwjAtuGAtJLA1JYA1NbAP0DVYiAhTvHEulcQYIYgs+CyoOJAtrDAtnahAyERac4A4ahACsDZAqGbVX1AFEC32EC3rRvcwLiK+0QAfMsIwH0lwHyzoMC6+8C6Wx1Aur1AurgAPVDAbUC7oUC65iWppb/Au47A4XcmHVw3HGdAvL/AGUDjhKZjwL3DwORagOSgwL3lAL51QL4YpoYmqe3M5saA51/Av72ARcANZ8Yn68DBYkDpmYDptUAzcEDBmahhKIBBQMMRQELARsHaQZdtWMBALcEZ7sNhx6vCQATcTUAHwMvEkkDhXsBXyMdAIzrAB0A5p8Dm40IswYbn8EApwURu+kdPT4WeAVoNz5AK0IhQrRfcRFfvACWxQUyAJBMGZu5OyZgMhG6zw4vGMYYicn2BVcFWAVXBVgFYwVYBVcFWAVXBVgFVwVYBVcFWEYVCNeFZwICAgpkXukrBMkDsQYvu7sAuwSnuwDnQCkWsgVGPmk+cEI/QrZfdTdf6ABYETOrAIz+zGvL/KbnRno9JiMEKxYnNjV+bd9qwfEZwixpAWvXbjAXBV8FasnBybgIz0lbAAAACnxefYu+ADM/gQADFtEG5a0jBQCMwwsDAQ0A5WUdPSQfSkKxQrxBOCNfJ2A2JzgjCcE9CkQ/Qz54PoE+cD5xAolCvElCO1/LTk9qTQosa1QvagtuH1/gMzobCWebCmIjKzwdJkKrQrwrzAHL/F/JDh8uCQgJIn6d32o6LUoXyavJrAllwcvMCmBBXw/lEKMRAJONHUVCJRupbTnOOAozP0M+cEI/HAcKHUxHbFssLVrhvBIKfe0dK0I/HF0ISgkOM1RDQjcEO0OcLAqBGy1CPxv1CFMiIxgwMQAFj2HwXgpxZMlgC2AtI25DYBk5AhseYLMGAmsQZU5gTREBZOdgFWCVYH1gs2BLYJFoFhcGtQ7cVam8WgtDFqsBuyvNwQIfFQAcAx4BeQJsLzCVUoABigq4RxoA5CN0jgrKDaZN6gGbAoecTwVAXwD39wkANBZXDAulDCQfuq9HAE8MNAAVE58rggh6AtILS2URGwDYTgZ1BAoeWgAxALa4AZonCxZvqyQ4nxkBWwGGCfwD2e0PBqoGSga5AB3LValaCbthE4kLLT8OuwG7ASICR1ooKCggHh8hLBImBiEMjQBUAm5XkEmVAW4fD3FHAdN1D85RIBmpsE3qBxEFTF8A9/cKAHoGJGwKKwulODAtx69WDQsAX7wLAGNAlQh6AOpN7yIbvwAxALa4AZonLTsOzgKQGHtQu1jIdHKO16WbDvWZFT0b7AEpEFwSBg8bAccJOhCTBRArDDYLABEAs84BAgCkAOEAmIIABWtXLwAUAFsbxi5sdioNwRACOyQz0+EcHgsbfQJ7Ls6hHATBCqrxbAA3OS0Opge7CQAQOi7OERkAfavaHA+7GkcczaF3HgE9Kl8cAuugCAHCAULz5B9lAb4Jtwz6CDwKPgAFwAs9AksNuwi8DTwKvC7OoSoJPA67BZgBG2sKD4sa4QHDARELuxY7AKALOxC7BBige9wAO2sMPAACpgm8BRvQ9QUBvgH6bsoGewAHuwG7D00RErwBAQDqAQAAdBVbBhbLFPxvF7sYOwAuuwLrDlaouwAeuwJVICp/AAG7AALjAAg7FTwVuwAbuwG9KOClWw6/xAD0AGj7L7ZtvgNIo7vIqDsDAbuVJ0sAAlsACrsEAOfdGbsIGnsIoQUK/3AA37unuxjbGruji3lyBvupm4MAErsGGwsBvAAAhgBtuwYAC7unOwEaO7oIoZzKAbsL7QfAqTsA4XsBvwAA5QAVuwAG+wAJuwBpiwAauwAOuwIYu45pFfsAAVsADmsALkseAAa7ABe7CCEADUoBwgC3ryYBwAAAtAAOmwG+J+QAsloAHBsBv/7hCqEABcYLFRXbAAebAEK7AQIAabsAC3sAHbsACLsJoQAFygBunxnVAJEIIQAFygABOwAH2wAdmwghAAaaAAl7ABsrAG0bAOa7gAAIWwAUuwkhAAbKAOOLAAk7C6EOxPtfAAc7AG6cQEgARwADOwAJrQM3AAcbABl7Abv/Aab7AAobAAo7AAn7p+sGuwAJGwADCwAQOwAAFDsAEWsAD4sADesADbsAGQsGFhsAFTsAbpsWswG7ALoAEzsDAGkrCgDhSwACOwAEUgAXewUbAAbQABi7AAv7AF+7AGv7AOSLAbsAF3YBvAABcguhAAVKHgF7KFIAOUUA/gcNDHIAKCpwAaQFCF4BvF4jDAkHb0tsXyqJHzwUYi02A6EKtAHYABYC0QNuAXZyR1IUIQNPAhU+ASwGA3NGvHtSekAAKQAxAfsAUwrbAHuQLAErAHblDREyRgFKAFcFAAFQAQeKzAB4OwQgpQBaANYVAJVoNx+LAM1rsQDP1BYIwnVzGxhWHQnRAYiQqyJTU01IEjzCifkAfxw3QCkr4BGXTwByASksMClCGQ8DMFUE98XuAEtl3ABqAnECPxF6Osd4LjXVBgUAEBsdCggMKgQfHSlOU04IuboAChLNACYAARoAhgCJAI41AO4AtADgAJ08ALsAqwCmAKEA8gCfANMAnADrAQwBBwDAAHkAWgDLAM0BBwDXAOsAiACiATUA4wDYANUDAQcqM9TU1NS2wNzN0M5DMhcBTQFXL0cBVQFkAWMBVgFHS0NFaA0BThUHCAMyNgwHACINJCYpLDg6Oj09PT4/DkAeUVFRUVNTUlMpVFVXVlYcXWFhYGJhI2ZocG9ycnJycnJ0dHR0dHR0dHR0dHZ2d3Z1WwBA7ABFAJYAdAAuAGLyAIoAUwBTADMCc+kAh//y8gBgAI/sAJsASwBeAGD5+aoAgQCBAGUAUgCtAB4AsgB/AjwCPwD4AOMA+gD6AOQA+wDlAOUA5ADiACkCdwFNATwBOgFQAToBOgE6ATUBNAE0ATQBGAFUDwArCAAATRcKFgMVFg4AigCSAKIASwBkGAItAHAAaQCRAxIDJCoDHkE+RykAiwJLAMMCUwKgALoCkgKSApICkgKSApIChwKSApICkgKSApICkgKRApEClAKcApMCkgKSApACkAKQApACjgKRAnEB0AKTApsCkgKSApEWeQsA+gUDpwJdAjYXAVAQNQLeEQorEwFKNxNNkQF3pDwBZVkA/wM9RwEAAJMpHhiPagApYABpAC4AiQOUzIvwroRaBborDsIRAZ3VdCoLBCMxbAEzWmwBsgDdfoB/foB+gYKCfoOGhH6FiIaAh4KIgol+in6LfoyKjX6Ofo+CkH6RfpJ+k36Ug5WIloKXftoC2WzhAtdsAIJsJGygAINsbARCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAlmZsAKMDh2wAtGYBBWwAyVFsbADPbAIMbAD2WmwA9gEZAPYA9AD0APUA9AN8XmzUhCNlvwD2APQA9AD1APQcbGwAiVpsAPYAiQEZAPYAiQLsAPYAiQN8XmzUhCNlvxxsAPdabAEZAPYA9gD0APQA9QD0APcA9AD0APUA9AN8XmzUhCNlvxxsbACJWmwBGQD2AIkA9gCJAuwA9gCJA3xebNSEI2W/HGwCQwE2bAJKATlsAkvBbGwCV2xsA54C7AOeA54DnwOfA58DnwN8XmzUhCNlvxxsbACJWmwBGQOeAIkDngCJAuwDngCJA3xebNSEI2W/HGwEN2wAiQQ4AIkGjTFtIC9s1m4DJmwA/QDGWgJsbABVWv4UMgJsbACJAmwAVAEAuV5sAmxebGwAiV5sAmxebD3YAEls1gJsbEZFNiJ9FGVAe8xvEZKvxVfKZszAVTBzYBH2d1iyUXEHH7twNw7eZF5JJRHI5EgaRr5D20/3dfONrFLSq5qSrrgd2CEUq722WBQ/LzpA+bx1oREI5xy4BDSZNun0ZWORUJqInZSyMaioyvfSI0l5uFDzbWaQ28/zdB0hwR4OQZ0/jn9ALSLNikjFYGfqR389qtFlhD3a6KdIh97rhZYpywuLc7o8ql5/X8KCbPU3L/QlmCowhRXhsGDvg6wUNprA9bM/49uxlAj7ZVy3ouEY/BgFXBNyK0TLrSjZWeJm/T4nz6QGLT3cJNtWRZVZTvIdtaxMMJRHgig9+S11LjBh7Inr06ykoch1U097Rw0hvgmOrydQyaWcEQDg0RavuMuT0zYabUZl1e33HNSK1oNUCS03eh+9C2EvF3fq9h+XBaAMFuoWeZf+mfZgL4HzyiKDIUtfNU4oFu0aE9qt3VA3U4D3fOSrAcYVnjG3cSkp1vhXZnp3JQm4JknKdBitO2NVnGCYQwU3YMWHWB87NEd+4AHuOKI8BSIH92reW0pfs+kWCTJxDCbRjFv8Cfc4/DSBYJScJYTeAEgg9wTEvcwd/QuHRHqGzAQ4fXf5FUI1lPrO+fvEcPl4JInM1z9AtBT2bL4QYEREe7KiSnnxTwtmAFjn8lqT3mND8qTktX2F16Ae9cakqJ6/pEQsHURqyqWlRMCzKXRKfCHT7sYHWx9/T/ugYTFY6iVN3Btm58ATJR5alYZybKMWojwOw3HbFn23NFyeLl7+Er82RchyYuBoGQ3j7SAWNxiYvp5U+Fq/DEzB9cG5DlJWsqkosRze92OVlCtQEYo1S1lF72Z8xWc4ld/+fFcfTEDTFb9d8tJGQ75dpJEvcWyGmGBiTbiWDdGOcw93Dmxq5ISUrmasygONfHLvhgo83HQZenbdBtSzBkvYrCEQ/xEDMhMZsN6gqplx5jGG9mSQLhM81UEdEeJ59sdNJDAFy/gPyJoKlwPZgB/MkC/kICLiCB8va+nCdO2ry4aDfkmPFpF/H/SGQ3LJ6aAv9dtJ8DniHtLOckZix0BVb0iR5V3LAp521LBSIi6AtV7r2ZB/hQEvAw54EFNOQcFnl1xGUIc67tqK1INNwD2n/RbwgzO9h45LM6VMuN8V1ZNIQ6t+Xy3lTqyVCD5kqLy/t3/b8MLbgDg8JIWDkSZ+LrGhhr+gYpH+pr1TnCUnZPjpUdw6bSL6MWVXoDDciQDWECwU2e6VEpfrcOBbrSOijqGkEIoJPbpmeJLkcwbvA0yWIixQVjo0HnYh7fji+Dfdq1mtV1lG2Zz9R7eFMHS+FK7nybutu2fwzDpFldO2pZBshsHJWaltn3PWOoGJpCT2jE8EHOuC6FkejNWcfsWCqNqMLP9xTwcWArj2EiiI7D+EaDi7/2cqHL1gPiF6C/J7aUo7RQqogPZ11WqbyP97nsoMxPOC78wZMF7B1Y0g7JNXJV/nN1m4xx8hbqWz07KSaqr5hE4icB326DMR/vUKX9LoNjle/ZWtbUhrTAcsdgrLlG5Ne8aiR0bS/2ZhpNOVVxavWIZsEM/rd68EB4vjbbD13NkMK1qvMk74vGbSkL7ULO0sZ9R6APSCo6KH+Xn98wEdw1bCPAnDTaBsD6sidAGN58uiH4a3ovG1KyZAu2XtyGgF/vgWKGxw9R1lfAVcfuYE71DHuxtTzfGZnHaDpDGWmfEq0N4GawE7yIkaoz8jcmVmzJe1ydM8q0p08YIxFcY1YcqQc1djWBEoNETDFcgk5waRftEJasPREkrV++N/TOKkERF1fCLrXS8DFGYGRBeECMQRNEs0ES3FzUtXCcNxpYEM3Uei6XodZruXUIRnn+UXf2b/r7n1vQutoi6WoIbW7svDNWBbUWcDUc7F9SJK3bvSy9KIqhgyJHoW2Kpvv0J4ob14HFXGWWVsYXJzjwxS+SADShTgCRjhoDgjAYRGxwJ1Vonw+cpnCKhz8NQPrb0SFxHIRbmG95Q2hlC4mDxvPBRbkFa60cvWakd7f0kVBxxktzZ9agPJEWyA63RSHYVqt8cPrs2uFJ3rS3k9ETGKn5+A6F9IOrdZHfT1biEyUJKEvwzuscwshGCBJvd16TrefW03xVnJf4xvs72PdxrMidjJO8EiWyN/VWyB3fv9kc34YIuZTFtXGo9DuG3H1Uka5FgBMwDPEvRcSabi3WakNQkXFecJlFk6buLVk5YHpuKWTw6oF632FPPSVIVl5hgUAeHhj0t/sw/PEEvThLQDDFE34eCg/rLOyXT3r+L98oRKrlTO0MdALYQ3rRQqC7d822dJPGxF1K4J2TtfPSMFaCAg0n0NGk9yiaKKOJD1v2aBX9HUOIawjjfvwCmjHZJTR62R9c9x33JnBjWrN4QYEOmehy0oZMP9XM9Zyi6TYoe07PaLceRXcCWZiY/imRUWW6+mci7+wMxSdwMdbXckXtvhJH8sc4iQcTwm7yp+3f7CaesTTQB2qkgeXh+wFiSMXfMlH7Yil0OoZ2QTtRLTip2O0cLZ4SstqWHZ6H+8A2kZXhpm0kPbL9dUanTOvziqIUh6Ambwa3WrCb2eWbuCN3L1hgWUmjRC3JoL3dBhR3imSQI8xuCMfsszlji7cSShNSYdqCXPxEVwbqO9i5B6hf93YI7aeyI8jxgcVXK0I/klbvhSXjkjOIwZgPdVwmsFW7HGPLUAvDRuKm+itybRg7c8+Yqqjg824Qf+/NxsBSUNAK9KCoJpauFqK0XQULrWYj4FnxeKDuvr54iokpi+D57e6Y1zxRJJdsHnDR3JyraCUufHBRTKODWBVzthjm4k3/Hv+Q990XDVR+KW+TcJX045LW86EKhz/97aqj89A8ZvTk1//tczosU90loIPVaHuWegJU3wP//7XHcO7c0yQM2jM/IhQKrf8hiObHWiWDZManF8Uf/HzbmDfC2wT//aiZ4hGTv/xzgKwdb1sD6cGEkceow0s3b89/zg+3plyRm0HlZi886j5wUwFhdHiDTaBidZRo5cx/tMeLyguOATbzq17ydhzbrpxunuHx6lbFGiO97gsd4dk//7iCIo+Ew+hG2so5kvv+ITG4c1fzHPtu1Xn5QfUnqY3/uByVmB7gmnE/E+5zdm+6nDmoews5fr+NzThdSHzK4bBQOL9c4O8OI0xLSqjJ4lbniLJg1aFpQRLwaSMZmpkC9e/j6FOVrTQ6a/a4alGgfrl2ZL1sbHUQ3DOI7ntq9diHFfm3t1mul3rdJEJCHnlW/hlQntipMrpeMs7fUr6wK370D7VbXH0DUHzdYfRg/6Z11Ult1sffJS+heHbco15Sxy3+rDnPesqH1lajk0yu02hPUvEUqvcUXWXL7Ad0wNGMx5gOle4XJxq/r/YY0xdco2wRSEGwcT7YADlBrHc9ZbvzOL0QwyWCWWChB9Obg800v7tyBWaNvdwz+fL7Ph9i2irEeJkRgOzeEDw+JiD/V93vH9FgMEoFIJMoIuogmicZohf94SBuPn6hXaV9jP4VVVA/bu+Wg8S88GLtmEPSNRLdtlXx2XL/nuM8nKkhnlnjaropiKKLIH94pLIASci0pDBfj9Hi5BfaTSXQg5+PMjQX91Ktk4MOqK1K99l4BRPv5+vNovGZ3IxQv8ICvjV4/diThpoaM8uvd3D9d/DE477w3yAbW3IDm2i73pZ9aEj38JqS6h/s8/xgmUIVcuq2JTgefAyuoafzQxAuRASeg3NtG3ach/JEkyuX+JDt2PnDZTShUhyHHG3ttBg/6lhAchGjLJBtopj4e01MlCp2yqQRTr4sBBXru+lKaoanwYX8y2aWCJiR3KnhCOkYVFSvsO0oDRujUFOEptiNDTYrJoUbvOyvl4AhC9h3wORiTXK1MrpMfnvdnndnR/HRVSusMBgIxwrLdn3vq1VcncPiD0SquTx/kNmxeFyCT4uXVUd9AL+rSGmuq7OOCzDKeVPjiNWVaoP5KOFqYq5Xcuf/xW9S+u9eIq9GAtZWtQlgkRecjRtvG1NR4WXXpn+pwsTBTIy079Ikg8rSef1aVapIFcXCd6C2wHVjLXR+N0tw4Taw6x6H90BFRgNrtlq2up6hHKuV3inM5RJaQWZHd84e6RsKkk9po3dk9by54tpPw7cBkFas/G+GbHwuG+AwP55BZyXILTHCIVrPpXHEaUPYfL6nphJP1Rc10xG4UaCeY4IHCwuur8xmSQDgY4aVwhzWhjbtSHG8JO6P2i2nC9/0Bfx0zk6dYQq3aw7k5vIObD7SEKrxhz0fQ0+YTOfHW23CBNeZci1qNsUDhoeqmfyP6PvjoEjHk8QbrFyQVZPHVWijnb8YCM65iYNoEbvnchStZ/9cKg5Vd45j8KnB6UjzXl/bkyZx7VoD47ocUUi117WwgySSb4rXgLJ52Mv5XJbp3I+uBP81BUvOjy4Cacgi+GWWlC/8dwgqwiojjUBDnEOxyRyowwLQfytFra1OZS4XvRYr4uoamAfG3I/p2bA7G90yqKThH8Ke00Tqd+3l3dmJpaCZelBMYjGqNLVa3SM4+LQeL56gY6Bymy2LQPVOxjWfj5tq4o74swcxhyGJPynkS5xAjOXZP1/FAYcBT3u6qLoIkEfErwo4gozmyI1YCvM0oyI3ghjGPQSsof2sKUhq91WsKy9cYWN+4A2v4pG/Mxpdc6w6kI/HX7Xb0TuihmsiOy2wQIsrZbUmr3OBSUo6oDJNgQp+YqYkgTgYcWZDgawJw3DFfdzT//PhVUidgB2qa8uw/j9ToHBAS33iT8YLhhAfyXG0bQUFp7QmH7oQ3i6Flf4OTZLvJdh8pfuflmWu2ohm5pTiSg1pl3vq9uluTJwqXfh1hqy8e2iHoD+Y35gCIViTo6VOtK5dD8HYClucJucXASzwe2kPj4S4eYQtmkYHagXhAzp/F541xE8YFYqSPszDuz3soWzHy0p3E2jwZNQaIcGU9FNQwQxeDw0ZlK9dxXrj9IUHGUPTOyib8CqXmbZ7Ex54bn1rLx3qqAavu/gh6XjV0GmN1p+yyMK9HN5uYEvxgbAk43tsheREhyI+Q5WLIneKTGPmYiM/lxOp8fvqHy8YgXK0TlMiX0tliLI2JtfmWZP8eVV732sdYm+pcWzDzEmKLJZyeelyaZKkjPnnUO9keDwtgiLnmd5+t+Sr5y8brRnlvxcWEWfCqIALQYHvaXx6jTg4dAlye469uGwwOZVZCILLfGjaMg4LUCNMTtMSp1aC2y/3wR2t1v3w/iNBRQ+bNbtDqL2NAr7K4rUcyqbSpNrXZgAWXvjxBBtfYLK1uRYt3q2pfXJOAL0HtWcEwJLddOSJKV1SwvcvEuzg/4MPnA8MIUJOLqm3qI6wFyN99Ck6zYaV/zGSAzF/PGsaNa4vPLe5QnyuqVUnVQ6xELA6gbe53aGgeke+R/ycb2LJVyc7BhuzI90zA+c6wUDTb7NH//gdDSl2u/aW7lRJm8m1fLtPxcNuEM5JbkOCZKPM88HUsLRoC1pmKKlvWyeAXuxILbu0snpSxf8N+RgtLUSe5n2gdjOjoSTaN7mMZ7bF+cWk/MS8mFD4pcyl5UN7CbpFZH2a+Pm1VAnUTVfbw8qrmz1G9m5aKmRzY1SMhhPrlCn2t4uNUXNA3IFe6NOjSC1DEaAFZAfDlEkQCsbNhsZPj6NQPDSB3tLiTo0ZYoEbIeEIaKtU3Wk60rEszawTFuyHVd365LA/c/uarABN5M5rGq/dqTG3Ilye/5EKiYisisuzqNaZjmWv0z9TORc0CKbaTea214oNM9u2sXUZub/eqM3Pi/PjRSyQiOSwPWif2asTgu6hS6fb5UGosCWxdedMqdViIUUSSdIJx+qQ4KShfTT39VAWZbi+mB+iKICNwpt6cflY57Rcbs6d1kA26Iru73cuxYVlSvuJdcR5VfDYZRk8X0AXePROyw3Le6LaUdmTLzYsoNhhgQpd67xVNiHgk3pakmndeIAtTC4DCXy9oS6eU4CWxDdVmY53pKNbdAKmQsP37lrJZC6iDXMELGKcHjNuuZgcDyY8W/yv6ha3DX7OWm/35fpvhw55oitf4V+GULlcPWYyGGuVBdro19c8u0RDddDun40W7G5cSIzHLh/qZxb59R+EPY+wZ2XerkUim92hhXpKyW6WtAh6zQS97DrPyjCvKi3pCw96LeKynOpyjtsMQc2RmI/20zFOZcSa2AK++PoRcT6zeJyxlBZ7kk5mhqXGkLlM2hFKc+/T544xXP0Ua38Q6xdPTLTeG1PHnLMaOvksUQMrEFTB/lizCirmFQL8zYVU+OTeYQEFaITsBSMMYexS9HkajO2gGIf2micvntCZJsZQEwIH3/4JGJQGflBuH5rNXmnRRYXDQs3ZoEQoMtYDr1kFKUS/siiQSUxcTH9XYeBZiKDDFQoExREO9dddKQLO3BwMHvymCSTFyY+vxn3D27NDx6OlU092D5EDUwilttqVHpjJQDUceJYCLsK2swfXeNUVrBJT/w/sk+7si8rPtiMFis+oxvGdGQxirMBID700T39mULuNHzOyN+xBfcFACZcyngF1aSpv0JPkNUrAZTqfplv509cGXFUiEEm5dZb+OsP/blizqdK45/dSsIrufYTrCPY2lgJD6k6QljTfXVlHfYKSq+MsagyUcaMintyr95bD8kdTAeYNLNsMmo/Wdd8a2nStBP49ARIjqqpUHWY4q4mvO5Cq/CgCP+4/B+5zutGwX5pssgVLr1+fIM7WWLfiUQDk4c6ZdHZOWv5hG3g2dgQ5NXnpIY+BWwJpaouf25bXnjDzbHnQNofH/c6m+dEAS9Gs2h7pFRPKOBDnqswZ8KZjhId1ytHUTs533KwBoSiImoxKQUgZ7z6pA9QB3sZ8Cq0vwutJTTkfbX8AzCpm2cFXx/P22niUMHauU8IGc+78R6TsutoonoqFuoNA3l80t387YHMoL5KGAT1JO4zmx+vJ0LbLHlicHraSVYvJjnO9p++qnWgKw9OwFVVUagvZuf9qfiuum+hIicxP1q4zDnzkHsCNriLxBpxY9N+UOmqzdY1MunLMDgkMyi3uvnN3UBXJeZ8YLs5xr8QrOhimYoKuGBebZHAiBIkViv3DG8k2oNpp5OIgX6ulqaRN8V62QUPjn5tl1kPXhT9bcd8qIm8gi4or/FGbvQ6pgGSHmnayrugmf5E0upGxPRf/3xOtitGMaHLKJVm5zhglmVfI91o0yxhJZVS/5wQ8zfxK8Ylw0WmHXoGfRkoBRx9Hsnl/6sgTjAVwpmNuSeZtBwlX4qB8Bh8lxjqBDIuFGJ4I1wxN0XRlAAslzqMKwQfyA7OkuivCXfv+i+3XmhcBFM2n4jdT+NyUmBnQJPV3F2sZfKvJhUlXzSosFR4VevVVcOkFnnjdiRWc0TeSYxj41sJGYMbZTeLI3GvyZ8/gAAudQ1+4oFX+enX5V49MczGCYVBuoC4kHjp7ZVxj+clBwPr9k+v05SsezQK3enxLs1Nt/N7c7AImVUysjGou4iOohHo83Zs9/MI/OWB+OyXzOBD93NbApGHXrv8CVRHp2bwH+xB55cfNrdqFD35HSMx4iVmtzYAmSCIV8kXsHoq3DIb93riTWbubnjxbBW5zConVtbxLRStXHkIyAByaozME952Gc9aAdAbBpZSVCH88Uwb/4bPTVOVl+WoMYD7JIvK8VcMrJ8zHV4bbG0Dg7Kx17A4ej/ZcZ2Z5pVuVLUH1E/AccUTKm81SE+LQ6STTUDscUk0x2OWIbEORhg69tdoTGNkA1RfkGIRZHr5mCXOpLC55WWzCZoGPFUVtZRHwh0nq039CDdjEPo+JyaxSQAvDgR6Iqvxy0frrtEG1A385N81l05SSzN+IDm9bypF9m92EUqblnauZ5sjc37wRykOdl7w4o8WMgQsjii3EE/aJYDfHs1cH6DNBEujjcCc8qAefYFyIAURDcDnzun5UmkbBQsU4eu/W8I9nBE0qJKTdg2hwjq0+XV7a3TJ7R+alvJZCRia9lJ+grNB9dbrOmWEvUotMjvDhq4wV/kq4fvIBkzUGpDeYH74rne8uU3dgoNZdR9pUL6q9YDNRfOiF6Dyk+SYXQIghTjm9qR4tBHh0gnmF/9q3Qv22EzaLhSvDlDOxMrrCNRmLCl1jApzLrBCPn2mjn5zqK7OYK7VxOfQ5GfBfoPdyQwqFEgCVHkJ9oTnagRM3R0+rsuN5jQv9icCav/p1WqiEXSzCdLd/WEA6z6dDP7tPqPbeDYKAkVcz1lLGbFOC9b7cBd3MV0Ve8dZ89oR7OnxGS7uVpSry8banVZwpJg+nkH1jRBYa2BvBMY2xITH9ERXCjHzdZxs+ipdXP2DY7X+eWiBhtT2L0RRGTLPeazn5tpl4tu8iE2rWig731iuJDRbCHHy+g/Mb9+miAyVqfIpXT/iZeOxOxODO0hEpLM78I1+G2Z45yi3lS1K3m4WMQ559Lp4UML5vZUjYGJuxl+OPpUH5klpyBujkjprhei0TmUik10gjvNUp8mDkWlNKikmYspaVTqewbnOzJrmz8FLIpsT67EJLHIIfeDcWEfiP+DJrZ1jfxpoAb2abeMqLx+9RuZGzQoYtYVGgAWwEM9Kek2vPIeBNAKD6ao7nw6sgvfeLZPoXkbYO/tStHJdKzk+WFSFEU2NcALJAEP6S8pcnqqBBt57dwTrzQNCIdk2SocK4dLRbD/pu/VryKnm65ZYXiJCfHJk3mx9MRSl+nSK6OqEBSoGjz0/LADddwF/HqcfK3K3O+6YUGQcmj8pZL4PhZ6KrGkb8B38FmDvvLd3XQXbvS/FQmrXFTvJNkaN/FGo83KuS43BK1UfVnIqigGkCoP5fBda2MwAGTGNKX9K9t4Bx83pMFc5KSORmWKv+8VoVggWxoaBz3/9IBh6RwLd1tebwy89xvE5z6EEpXpDfrXWfRsMs6+ekUHH6idVosno55+xQ8Zqzelh0bxtJTgCcH3Z3/Cxlx9eNIS4JIFKOAVrDqbrXRszmY55a5+niJGHtkO3b6mnIDxLa1WXc7BAe33mt2KyM4Fbc3R6/WVTQN8QhlqAtave2WsQTqzWeSlKuGUVIJRqtObpv294rS0kDN1RKzdstZTXJebR2HlzsQ4P3NbMHUqFZMZw+/IKXnh4t+lY8qocp/B1oMszR03EFs3bPeND8QkItMvllObeCz3SZAjqZrobmLcrpFyQV7mwBjg3C3C8/bc5goQhv8j/IXMLGnt4mF7tybRDG5G0polxoUScQkPvmnga2/K+aapKeqSL0BTmo1Cm5g+booNOtdyKva2KoefRURaBk7113QKo3y+WTuFKtgETIK8HRluYS9DvlcciCDvnG8UaJRfZE2siZsiTHvRmN80xkUIInHeRZl5Re/+ATL6VhKFi8CZ/n/jbFV6T5pZ+Uoppvsi3qjacVFOJgWWfdlwVHKPW/TJO3na9hRM9bS2yo2rEsC6IBzRReVO6IesJU7PItzOamr+ROFfwGZmZ7ue8HNxAgLJKb7P3p8dMqk6Be5PJaT/5Rdc1deYVihWH9cjVKc9uz5EnfHqxLUkOO8iJUENBNVf5LyNy8zjLu/78k5WNTywiPfYeX3CPk7yc6CI3lum/CEZwfUaNpcI3KsPqfn2lmz3kd/acQjKA1ebkJaiuLD+epQ/Fc1llHXXMzofWzz/Kd29SNmOhcjMWw1jq1g3YfrXZ9rzXDYW4ZttfgfMi6oCUtBs0PkMVuxmq5lxEoCaSXPSqCJJ7MlKdRDidVt0AFlxk5cTdX++sBF2+E35mjwfm8ERVxH0FvuAQtsfA4V2G0TKTUxeyRGVjd/u6F1SvuAiU2/WaQjcNCU4Ep7VunXCYSbZj3U3wzu/LWM5MPlYuyQ3FOOCD/zt7K295hY2JhwF+ODDIZ676vGQFKveEQYkWj7lkK7rVmD7MhU0Y/tF8EcTTpo4/yqOufbd/zWIpMajnbDuWK2vn6OPPtz2rc9MIBNlPd8tt+yf+7SC4wqEPbozKMCwY5Bygx4JmoIEDsixWRDcdHd6S3/dZMHXOJAAv7+NIstl00crgSqHZKAEe4g3G4dzIV51EeZB01r7p8GNlfUnG/GjZgNGsqXZdYMBVtAtFNv3hJWPve4GvqZ2XxuiNkHTz5kxWgr0PjQdJlVywJ9Zf2ZvqeeTbolKtvK54re2Lq5BoyzfsRtvDfyao3kmyFzDQ88nM+qx83w74RDlkngtYiArI05Epre3GgBeSlMig0pE6RGQaFznKkGeb0SozLCyiOtxh7hgwZlbKbClzUUfC8ntMiHUOZE375RhTy9c4DA+oMLkUDkztSybZbdmP1xpaIbjUpPAHBq3cIq+CBFzbMlMMCCkUQ6d9LGV6GYCsYiEWZIy3nBnuxOYXeU4YTGDSin9e4/pCjPtQSHlg5LMEvIlF0ElthqrF129iK2RPBEWd3XWOl3SWV5uz5VUyZYp5kEFmz7QfP/B1W1BBzQ2iTGbSVT79lUHzcGXz3PJceSgz4uknETUwo0xffpr2KUvZF0i/r2sL3IFIClYx8CbIZE6Qt7MDJbOPB3xMScwaOcWG66IJfCnDkb0D2Mb+PHzX+oiCbxeTIogtyN+s2NJirNACk/OACSOTtV6vscwbzW4M168xqaI+RzR47S1nlV/rOoZnid87n/Ima2XYa3un3BuGAisNjb8eLMT9OnMtazQROFCuO1HiZXaOc0oUDbNC4eKLToOx8DzVhMgGA8XIAQ2x3b6I0uEyLssQjJX3QphcUMx4KsMgJ+72km4N2aqkBF2coKmUEt1eqIMGn+5txMT4kYVGd3ALO+y9Z4PP3d3l48JQK8s9ZZ/Qx/+NBKgBEJFlQ32psoJiihGO7FSYM5L81q72kaAYcilEFMG+ZK1BcMqELkflyCV7v8JEXLO4Rf/oZYNZHZVjJhfL6fnpP9Tio3Euue5uS7FMkfGOeRCTrBZ06Caev7tgufeTrX34Ur/Vvc+b8ksiIShNJtuF9WmYxOZ4xg8y6zTdy3KAB2y5kYkcRnXsptWwAFyKZ2I/QGySNeoQLkINUMloC+5L3WuMMx297Q1xUYLKqZ9XHavaobo6QQv4auMm+i84IhxRpPt9nUmcav9NcjCcP+TcMmxsQZ/F3mgeoA0fQgwvTsyXuuTaM3Sqtv2jaaajmaFQpK9W6uIbeqwvSDo34ZrY6elDUHwSCjHRRmlwmyy+eOra64Ssq0XSXYljMHtKY+FShcMkHsEUY/4Bw63dJ6KpwDaxmthlDdbdE+TvYF3v33cGSKqO+1H1pKYhJMvZD5ckQcHyNF8zrtiR5b0ko6NPGoRexUZTYP6VbUdn3zzxGBOi8Z0OqHjGqYxRXwN3mYi0GYEEZYq+Q3QvdKcEHILLLj8S+VFepSfErtmfZCdvxbfIifFSpEzKi+7VJsLMT+zEFeyp1OdwRC1VZrfTLIyR7xTPUcZFYPD9qI7D70uTb4hdpqPXsJIRNYbZtNwch1OI3trh3u2ScoQyM9POnInsUa+OovcwkUP1UfIzPb95n4BaF2ev57NHAej0+BVMF9/Cj9663HN2/JN3SQgslL914bKfiTTDFAz9PlQEL/dSv1H8xl3mtWxh1McFO9EJXlRDaKQDsyKO4vOJW90NFE6yw2tjbc2GeF95sbs0I9enAa6QwQVf/kJQhAD2BzUDKggOyjy1TEhED6sfk+418lQy3c/uj8aw8UEzZ6hIMCd8RohAkumMtIj9m73l2yPWoGHVTPaywkC7Yj9tBM1NxMgcrDwRtk4RO2WHT7Ql5kQCKdJj6kNuOTeyEBYBjLMhGz+O5/YGa84HEiTYEpZ6fFzy26GG2hWtTyteuYrhSyG56BjsT/wQeLRytpTY3D7sIMqZnJ9z1FDrfyjFlGl2TNw9BQysbaxOuwYYZs/7I6BANgkqCknWZC7/BBXvaeKwAmC959I+G39BUE9bExkNlbRoFRyEtNzv+NJ91FuisG3JCS6uYBeRnfv8AkAfKTeg9EYamqnsGfAV7d0f9DghHEQ5IsPGDIUhgoSj7obM4Bu5uhQ3/CYEDTHc92AsFvDK4XGrwUeGBWBHPlS+f4x+CxmmHz2sAGmSFNt65kwZC64mnaoWlu2310laYn8r62AqsR5dfjyK18MEdurdagldzfJtjFXlZs7St4QhdPiye6TPh2/ZAQLU/Fip5s7TDEM16KtRWrK9hmxnQ7bmfa/+7pa10Z8WDPK3NuJ+NN/RAbQ5vHx2uX0Lm7/w7cAEH/hvZA+mt7J7zGw7YtQYwnNN6dpgwkGjjrS3yQoeoYt1EnczmtmJfQZWzUlP3Hlg9Wzlr9IH23q3thGth+QNEANFettxKfskkGOlLk8AqoKJwDqOxAa6UzAx07plSSyNBJSGco9zjnC5gGbDoKvsMDuBR6bGRlGzJ+hFsGa/Izt78aI+WZ6dJlZKp4pGISuv9rV0sAS0MWEwCmfauO7oQZMiakHU35LBxiyJoOMddhUWgcZuC8r4Ksvn75TTcQXLJ7kWtYhGuGqPd9dZuFjBWQHNwosXY5snbHFQq72CvHXhIg+shQxycuLOuWYErwCLZeF24b7F78pO7xw4X6lIAR02hUOf5087Rl0nOaeb6CK4i/KA/EZv76ftOWZtjwxslNr0E/u8rWUmnf3amfg6UZmBAluuoj3Dd7UV+9IAJ6iYcDfSJlgmIImohjfIUMJ27z+opj50Ak9af2LCNrWrBJvMovA1OeNO+MF/MwZvnaCxTgG7Cw4QfSPF6AYCGFt21M8PySZFeV3t2Rqqs5JMzMYzGRgq4o+UaKRgBf9GHi/9X9HXA3wxkCsd/UhnHSh2zUVDiraio/6nP4y3XJqs8ABfALAtCYU7DHPMPRjgcM6Ad/HiSXDAbOdSMkvGZPAkHs8wuQTy6X2Ov/JFvcPuKfV3/r9Q28'
const E8 = new Map([
    [8217, 'apostrophe'],
    [8260, 'fraction slash'],
    [12539, 'middle dot']
  ]),
  A8 = 4
function Mre(t) {
  let e = 0
  function n() {
    return (t[e++] << 8) | t[e++]
  }
  let r = n(),
    i = 1,
    s = [0, 1]
  for (let D = 1; D < r; D++) s.push((i += n()))
  let c = n(),
    u = e
  e += c
  let f = 0,
    d = 0
  function p() {
    return f == 0 && ((d = (d << 8) | t[e++]), (f = 8)), (d >> --f) & 1
  }
  const g = 31,
    m = 2 ** g,
    y = m >>> 1,
    A = y >> 1,
    E = m - 1
  let x = 0
  for (let D = 0; D < g; D++) x = (x << 1) | p()
  let O = [],
    I = 0,
    M = m
  for (;;) {
    let D = Math.floor(((x - I + 1) * i - 1) / M),
      R = 0,
      z = r
    for (; z - R > 1; ) {
      let V = (R + z) >>> 1
      D < s[V] ? (z = V) : (R = V)
    }
    if (R == 0) break
    O.push(R)
    let G = I + Math.floor((M * s[R]) / i),
      j = I + Math.floor((M * s[R + 1]) / i) - 1
    for (; ((G ^ j) & y) == 0; )
      (x = ((x << 1) & E) | p()), (G = (G << 1) & E), (j = ((j << 1) & E) | 1)
    for (; G & ~j & A; )
      (x = (x & y) | ((x << 1) & (E >>> 1)) | p()), (G = (G << 1) ^ y), (j = ((j ^ y) << 1) | y | 1)
    ;(I = G), (M = 1 + j - G)
  }
  let $ = r - 4
  return O.map(D => {
    switch (D - $) {
      case 3:
        return $ + 65792 + ((t[u++] << 16) | (t[u++] << 8) | t[u++])
      case 2:
        return $ + 256 + ((t[u++] << 8) | t[u++])
      case 1:
        return $ + t[u++]
      default:
        return D - 1
    }
  })
}
function kre(t) {
  let e = 0
  return () => t[e++]
}
function xI(t) {
  return kre(Mre(Ure(t)))
}
function Ure(t) {
  let e = []
  ;[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach(
    (i, s) => (e[i.charCodeAt(0)] = s)
  )
  let n = t.length,
    r = new Uint8Array((6 * n) >> 3)
  for (let i = 0, s = 0, c = 0, u = 0; i < n; i++)
    (u = (u << 6) | e[t.charCodeAt(i)]), (c += 6), c >= 8 && (r[s++] = u >> (c -= 8))
  return r
}
function Bre(t) {
  return t & 1 ? ~t >> 1 : t >> 1
}
function Lre(t, e) {
  let n = Array(t)
  for (let r = 0, i = 0; r < t; r++) n[r] = i += Bre(e())
  return n
}
function rp(t, e = 0) {
  let n = []
  for (;;) {
    let r = t(),
      i = t()
    if (!i) break
    e += r
    for (let s = 0; s < i; s++) n.push(e + s)
    e += i + 1
  }
  return n
}
function NI(t) {
  return ip(() => {
    let e = rp(t)
    if (e.length) return e
  })
}
function II(t) {
  let e = []
  for (;;) {
    let n = t()
    if (n == 0) break
    e.push($re(n, t))
  }
  for (;;) {
    let n = t() - 1
    if (n < 0) break
    e.push(Fre(n, t))
  }
  return e.flat()
}
function ip(t) {
  let e = []
  for (;;) {
    let n = t(e.length)
    if (!n) break
    e.push(n)
  }
  return e
}
function OI(t, e, n) {
  let r = Array(t)
    .fill()
    .map(() => [])
  for (let i = 0; i < e; i++) Lre(t, n).forEach((s, c) => r[c].push(s))
  return r
}
function $re(t, e) {
  let n = 1 + e(),
    r = e(),
    i = ip(e)
  return OI(i.length, 1 + t, e).flatMap((c, u) => {
    let [f, ...d] = c
    return Array(i[u])
      .fill()
      .map((p, g) => {
        let m = g * r
        return [f + g * n, d.map(y => y + m)]
      })
  })
}
function Fre(t, e) {
  let n = 1 + e()
  return OI(n, 1 + t, e).map(i => [i[0], i.slice(1)])
}
function jre(t) {
  let e = [],
    n = rp(t)
  return i(r([]), []), e
  function r(s) {
    let c = t(),
      u = ip(() => {
        let f = rp(t).map(d => n[d])
        if (f.length) return r(f)
      })
    return { S: c, B: u, Q: s }
  }
  function i({ S: s, B: c }, u, f) {
    if (!(s & 4 && f === u[u.length - 1])) {
      s & 2 && (f = u[u.length - 1]), s & 1 && e.push(u)
      for (let d of c) for (let p of d.Q) i(d, [...u, p], f)
    }
  }
}
function zre(t) {
  return t.toString(16).toUpperCase().padStart(2, '0')
}
function RI(t) {
  return `{${zre(t)}}`
}
function qre(t) {
  let e = []
  for (let n = 0, r = t.length; n < r; ) {
    let i = t.codePointAt(n)
    ;(n += i < 65536 ? 1 : 2), e.push(i)
  }
  return e
}
function fd(t) {
  let n = t.length
  if (n < 4096) return String.fromCodePoint(...t)
  let r = []
  for (let i = 0; i < n; ) r.push(String.fromCodePoint(...t.slice(i, (i += 4096))))
  return r.join('')
}
function Hre(t, e) {
  let n = t.length,
    r = n - e.length
  for (let i = 0; r == 0 && i < n; i++) r = t[i] - e[i]
  return r
}
var Gre =
  'AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA'
const sp = 44032,
  Em = 4352,
  Am = 4449,
  _m = 4519,
  DI = 19,
  PI = 21,
  hd = 28,
  Cm = PI * hd,
  Vre = DI * Cm,
  Kre = sp + Vre,
  Wre = Em + DI,
  Qre = Am + PI,
  Yre = _m + hd
function ah(t) {
  return (t >> 24) & 255
}
function MI(t) {
  return t & 16777215
}
let DE, _8, PE, Fg
function Zre() {
  let t = xI(Gre)
  ;(DE = new Map(NI(t).flatMap((e, n) => e.map(r => [r, (n + 1) << 24])))),
    (_8 = new Set(rp(t))),
    (PE = new Map()),
    (Fg = new Map())
  for (let [e, n] of II(t)) {
    if (!_8.has(e) && n.length == 2) {
      let [r, i] = n,
        s = Fg.get(r)
      s || ((s = new Map()), Fg.set(r, s)), s.set(i, e)
    }
    PE.set(e, n.reverse())
  }
}
function kI(t) {
  return t >= sp && t < Kre
}
function Xre(t, e) {
  if (t >= Em && t < Wre && e >= Am && e < Qre) return sp + (t - Em) * Cm + (e - Am) * hd
  if (kI(t) && e > _m && e < Yre && (t - sp) % hd == 0) return t + (e - _m)
  {
    let n = Fg.get(t)
    return n && ((n = n.get(e)), n) ? n : -1
  }
}
function UI(t) {
  DE || Zre()
  let e = [],
    n = [],
    r = !1
  function i(s) {
    let c = DE.get(s)
    c && ((r = !0), (s |= c)), e.push(s)
  }
  for (let s of t)
    for (;;) {
      if (s < 128) e.push(s)
      else if (kI(s)) {
        let c = s - sp,
          u = (c / Cm) | 0,
          f = ((c % Cm) / hd) | 0,
          d = c % hd
        i(Em + u), i(Am + f), d > 0 && i(_m + d)
      } else {
        let c = PE.get(s)
        c ? n.push(...c) : i(s)
      }
      if (!n.length) break
      s = n.pop()
    }
  if (r && e.length > 1) {
    let s = ah(e[0])
    for (let c = 1; c < e.length; c++) {
      let u = ah(e[c])
      if (u == 0 || s <= u) {
        s = u
        continue
      }
      let f = c - 1
      for (;;) {
        let d = e[f + 1]
        if (((e[f + 1] = e[f]), (e[f] = d), !f || ((s = ah(e[--f])), s <= u))) break
      }
      s = ah(e[c])
    }
  }
  return e
}
function Jre(t) {
  let e = [],
    n = [],
    r = -1,
    i = 0
  for (let s of t) {
    let c = ah(s),
      u = MI(s)
    if (r == -1) c == 0 ? (r = u) : e.push(u)
    else if (i > 0 && i >= c)
      c == 0 ? (e.push(r, ...n), (n.length = 0), (r = u)) : n.push(u), (i = c)
    else {
      let f = Xre(r, u)
      f >= 0 ? (r = f) : i == 0 && c == 0 ? (e.push(r), (r = u)) : (n.push(u), (i = c))
    }
  }
  return r >= 0 && e.push(r, ...n), e
}
function BI(t) {
  return UI(t).map(MI)
}
function eie(t) {
  return Jre(UI(t))
}
const C8 = 45,
  LI = '.',
  $I = 65039,
  FI = 1,
  Sm = t => Array.from(t)
function ap(t, e) {
  return t.P.has(e) || t.Q.has(e)
}
class tie extends Array {
  get is_emoji() {
    return !0
  }
}
let ME, jI, Bc, kE, zI, jl, iw, Ol, xc, S8, UE
function Q2() {
  if (ME) return
  let t = xI(Pre)
  const e = () => rp(t),
    n = () => new Set(e()),
    r = (p, g) => g.forEach(m => p.add(m))
  ;(ME = new Map(II(t))),
    (jI = n()),
    (Bc = e()),
    (kE = new Set(e().map(p => Bc[p]))),
    (Bc = new Set(Bc)),
    (zI = n()),
    n()
  let i = NI(t),
    s = t()
  const c = () => {
    let p = new Set()
    return e().forEach(g => r(p, i[g])), r(p, e()), p
  }
  ;(jl = ip(p => {
    let g = ip(t).map(m => m + 96)
    if (g.length) {
      let m = p >= s
      ;(g[0] -= 32), (g = fd(g)), m && (g = `Restricted[${g}]`)
      let y = c(),
        A = c(),
        E = !t()
      return { N: g, P: y, Q: A, M: E, R: m }
    }
  })),
    (iw = n()),
    (Ol = new Map())
  let u = e()
    .concat(Sm(iw))
    .sort((p, g) => p - g)
  u.forEach((p, g) => {
    let m = t(),
      y = (u[g] = m ? u[g - m] : { V: [], M: new Map() })
    y.V.push(p), iw.has(p) || Ol.set(p, y)
  })
  for (let { V: p, M: g } of new Set(Ol.values())) {
    let m = []
    for (let A of p) {
      let E = jl.filter(O => ap(O, A)),
        x = m.find(({ G: O }) => E.some(I => O.has(I)))
      x || ((x = { G: new Set(), V: [] }), m.push(x)), x.V.push(A), r(x.G, E)
    }
    let y = m.flatMap(A => Sm(A.G))
    for (let { G: A, V: E } of m) {
      let x = new Set(y.filter(O => !A.has(O)))
      for (let O of E) g.set(O, x)
    }
  }
  xc = new Set()
  let f = new Set()
  const d = p => (xc.has(p) ? f.add(p) : xc.add(p))
  for (let p of jl) {
    for (let g of p.P) d(g)
    for (let g of p.Q) d(g)
  }
  for (let p of xc) !Ol.has(p) && !f.has(p) && Ol.set(p, FI)
  r(xc, BI(xc)),
    (S8 = jre(t)
      .map(p => tie.from(p))
      .sort(Hre)),
    (UE = new Map())
  for (let p of S8) {
    let g = [UE]
    for (let m of p) {
      let y = g.map(A => {
        let E = A.get(m)
        return E || ((E = new Map()), A.set(m, E)), E
      })
      m === $I ? g.push(...y) : (g = y)
    }
    for (let m of g) m.V = p
  }
}
function Y2(t) {
  return (qI(t) ? '' : `${Z2(tb([t]))} `) + RI(t)
}
function Z2(t) {
  return `"${t}"‎`
}
function nie(t) {
  if (t.length >= 4 && t[2] == C8 && t[3] == C8)
    throw new Error(`invalid label extension: "${fd(t.slice(0, 4))}"`)
}
function rie(t) {
  for (let n = t.lastIndexOf(95); n > 0; )
    if (t[--n] !== 95) throw new Error('underscore allowed only at start')
}
function iie(t) {
  let e = t[0],
    n = E8.get(e)
  if (n) throw bh(`leading ${n}`)
  let r = t.length,
    i = -1
  for (let s = 1; s < r; s++) {
    e = t[s]
    let c = E8.get(e)
    if (c) {
      if (i == s) throw bh(`${n} + ${c}`)
      ;(i = s + 1), (n = c)
    }
  }
  if (i == r) throw bh(`trailing ${n}`)
}
function tb(t, e = 1 / 0, n = RI) {
  let r = []
  sie(t[0]) && r.push('◌'),
    t.length > e && ((e >>= 1), (t = [...t.slice(0, e), 8230, ...t.slice(-e)]))
  let i = 0,
    s = t.length
  for (let c = 0; c < s; c++) {
    let u = t[c]
    qI(u) && (r.push(fd(t.slice(i, c))), r.push(n(u)), (i = c + 1))
  }
  return r.push(fd(t.slice(i, s))), r.join('')
}
function sie(t, e) {
  return Q2(), Bc.has(t)
}
function qI(t) {
  return Q2(), zI.has(t)
}
function aie(t) {
  return lie(oie(t, eie, hie))
}
function oie(t, e, n) {
  if (!t) return []
  Q2()
  let r = 0
  return t.split(LI).map(i => {
    let s = qre(i),
      c = { input: s, offset: r }
    r += s.length + 1
    try {
      let u = (c.tokens = fie(s, e, n)),
        f = u.length,
        d
      if (!f) throw new Error('empty label')
      let p = (c.output = u.flat())
      if ((rie(p), !(c.emoji = f > 1 || u[0].is_emoji) && p.every(m => m < 128)))
        nie(p), (d = 'ASCII')
      else {
        let m = u.flatMap(y => (y.is_emoji ? [] : y))
        if (!m.length) d = 'Emoji'
        else {
          if (Bc.has(p[0])) throw bh('leading combining mark')
          for (let E = 1; E < f; E++) {
            let x = u[E]
            if (!x.is_emoji && Bc.has(x[0]))
              throw bh(`emoji + combining mark: "${fd(u[E - 1])} + ${tb([x[0]])}"`)
          }
          iie(p)
          let y = Sm(new Set(m)),
            [A] = uie(y)
          die(A, m), cie(A, y), (d = A.N)
        }
      }
      c.type = d
    } catch (u) {
      c.error = u
    }
    return c
  })
}
function cie(t, e) {
  let n,
    r = []
  for (let i of e) {
    let s = Ol.get(i)
    if (s === FI) return
    if (s) {
      let c = s.M.get(i)
      if (((n = n ? n.filter(u => c.has(u)) : Sm(c)), !n.length)) return
    } else r.push(i)
  }
  if (n) {
    for (let i of n)
      if (r.every(s => ap(i, s))) throw new Error(`whole-script confusable: ${t.N}/${i.N}`)
  }
}
function uie(t) {
  let e = jl
  for (let n of t) {
    let r = e.filter(i => ap(i, n))
    if (!r.length) throw jl.some(i => ap(i, n)) ? GI(e[0], n) : HI(n)
    if (((e = r), r.length == 1)) break
  }
  return e
}
function lie(t) {
  return t
    .map(({ input: e, error: n, output: r }) => {
      if (n) {
        let i = n.message
        throw new Error(t.length == 1 ? i : `Invalid label ${Z2(tb(e, 63))}: ${i}`)
      }
      return fd(r)
    })
    .join(LI)
}
function HI(t) {
  return new Error(`disallowed character: ${Y2(t)}`)
}
function GI(t, e) {
  let n = Y2(e),
    r = jl.find(i => i.P.has(e))
  return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${t.N} + ${n}`)
}
function bh(t) {
  return new Error(`illegal placement: ${t}`)
}
function die(t, e) {
  for (let n of e) if (!ap(t, n)) throw GI(t, n)
  if (t.M) {
    let n = BI(e)
    for (let r = 1, i = n.length; r < i; r++)
      if (kE.has(n[r])) {
        let s = r + 1
        for (let c; s < i && kE.has((c = n[s])); s++)
          for (let u = r; u < s; u++)
            if (n[u] == c) throw new Error(`duplicate non-spacing marks: ${Y2(c)}`)
        if (s - r > A8)
          throw new Error(
            `excessive non-spacing marks: ${Z2(tb(n.slice(r - 1, s)))} (${s - r}/${A8})`
          )
        r = s
      }
  }
}
function fie(t, e, n) {
  let r = [],
    i = []
  for (t = t.slice().reverse(); t.length; ) {
    let s = pie(t)
    if (s) i.length && (r.push(e(i)), (i = [])), r.push(n(s))
    else {
      let c = t.pop()
      if (xc.has(c)) i.push(c)
      else {
        let u = ME.get(c)
        if (u) i.push(...u)
        else if (!jI.has(c)) throw HI(c)
      }
    }
  }
  return i.length && r.push(e(i)), r
}
function hie(t) {
  return t.filter(e => e != $I)
}
function pie(t, e) {
  let n = UE,
    r,
    i = t.length
  for (; i && ((n = n.get(t[--i])), !!n); ) {
    let { V: s } = n
    s && ((r = s), (t.length = i))
  }
  return r
}
function gie(t) {
  return aie(t)
}
function mie(t) {
  return gie(t)
}
function bie(t) {
  let e = []
  function n(r) {
    return yh.parseEvmChainId(r) || 1
  }
  return r => ({
    id: he.CONNECTOR_ID.AUTH,
    name: he.CONNECTOR_NAMES.AUTH,
    type: 'AUTH',
    chain: he.CHAIN.EVM,
    async connect(i = {}) {
      var g
      const s = await this.getProvider()
      let c = i.chainId
      if (i.isReconnecting) {
        const m = yh.parseEvmChainId(s.getLastUsedChainId() || ''),
          y = (g = t.chains) == null ? void 0 : g[0].id
        if (((c = m || y), !c)) throw new Error('ChainId not found in provider')
      }
      const {
        address: u,
        chainId: f,
        accounts: d
      } = await s.connect({ chainId: c, preferredAccountType: be.state.defaultAccountTypes.eip155 })
      ;(e = (d == null ? void 0 : d.map(m => m.address)) || [u]),
        await s.getSmartAccountEnabledNetworks()
      const p = n(f)
      return { accounts: e, account: u, chainId: p, chain: { id: p, unsuported: !1 } }
    },
    async disconnect() {
      await (await this.getProvider()).disconnect()
    },
    getAccounts() {
      return e != null && e.length
        ? (r.emitter.emit('change', { accounts: e }), Promise.resolve(e))
        : Promise.resolve([])
    },
    async getProvider() {
      return (
        this.provider ||
          (this.provider = Bl.getInstance({
            projectId: t.options.projectId,
            enableLogger: t.options.enableAuthLogger,
            onTimeout: () => {
              Vc.open(Pl.ALERT_ERRORS.SOCIALS_TIMEOUT, 'error')
            }
          })),
        Promise.resolve(this.provider)
      )
    },
    async getChainId() {
      const i = await this.getProvider(),
        { chainId: s } = await i.getChainId()
      return n(s)
    },
    async isAuthorized() {
      const i = await this.getProvider()
      return Promise.resolve(i.getLoginEmailUsed())
    },
    async switchChain({ chainId: i }) {
      var s
      try {
        const c = r.chains.find(d => d.id === i)
        if (!c) throw new Gs(new Error('chain not found on connector.'))
        const f = await (
          await this.getProvider()
        ).connect({ chainId: i, preferredAccountType: be.state.defaultAccountTypes.eip155 })
        return (
          (e = ((s = f == null ? void 0 : f.accounts) == null ? void 0 : s.map(d => d.address)) || [
            f.address
          ]),
          r.emitter.emit('change', { chainId: Number(i), accounts: e }),
          c
        )
      } catch (c) {
        throw c instanceof Error ? new Gs(c) : c
      }
    },
    onAccountsChanged(i) {
      i.length === 0 ? this.onDisconnect() : r.emitter.emit('change', { accounts: i.map(Bo) })
    },
    onChainChanged(i) {
      const s = Number(i)
      r.emitter.emit('change', { chainId: s })
    },
    async onDisconnect(i) {
      await (await this.getProvider()).disconnect()
    }
  })
}
X2.type = 'walletConnect'
function X2(t, e, n) {
  const r = t.isNewChainsStale ?? !0
  let i, s, c, u, f, d, p
  return g => ({
    id: 'walletConnect',
    name: 'WalletConnect',
    type: X2.type,
    async setup() {
      const m = await this.getProvider().catch(() => null)
      m &&
        (u || ((u = this.onConnect.bind(this)), m.on('connect', u)),
        d || ((d = this.onSessionDelete.bind(this)), m.on('session_delete', d)))
    },
    async connect({ ...m } = {}) {
      try {
        const y = await this.getProvider()
        if (!y) throw new Ao()
        f || ((f = this.onDisplayUri), y.on('display_uri', f))
        const A = await this.isChainsStale()
        if ((y.session && A && (await y.disconnect()), !y.session || A)) {
          const O = Jm.createNamespaces(n)
          await y.connect({
            optionalNamespaces: O,
            ...('pairingTopic' in m ? { pairingTopic: m.pairingTopic } : {})
          }),
            this.setRequestedChainsIds(n.map(I => Number(I.id)))
        }
        const E = (await y.enable()).map(O => Bo(O)),
          x = await this.getChainId()
        return (
          f && (y.removeListener('display_uri', f), (f = void 0)),
          u && (y.removeListener('connect', u), (u = void 0)),
          s || ((s = this.onAccountsChanged.bind(this)), y.on('accountsChanged', s)),
          c || ((c = this.onChainChanged.bind(this)), y.on('chainChanged', c)),
          p || ((p = this.onDisconnect.bind(this)), y.on('disconnect', p)),
          d || ((d = this.onSessionDelete.bind(this)), y.on('session_delete', d)),
          y.setDefaultChain(`eip155:${x}`),
          { accounts: E, chainId: x }
        )
      } catch (y) {
        throw /(user rejected|connection request reset)/i.test(y == null ? void 0 : y.message)
          ? new Xn(y)
          : y
      }
    },
    async disconnect() {
      const m = await this.getProvider()
      try {
        await (m == null ? void 0 : m.disconnect())
      } catch (y) {
        if (!/No matching key/i.test(y.message)) throw y
      } finally {
        c && (m == null || m.removeListener('chainChanged', c), (c = void 0)),
          p && (m == null || m.removeListener('disconnect', p), (p = void 0)),
          u || ((u = this.onConnect.bind(this)), m == null || m.on('connect', u)),
          s && (m == null || m.removeListener('accountsChanged', s), (s = void 0)),
          d && (m == null || m.removeListener('session_delete', d), (d = void 0)),
          this.setRequestedChainsIds([])
      }
    },
    async getAccounts() {
      var E, x, O
      const m = await this.getProvider()
      if (!((E = m == null ? void 0 : m.session) != null && E.namespaces)) return []
      const y =
        (O = (x = m == null ? void 0 : m.session) == null ? void 0 : x.namespaces[he.CHAIN.EVM]) ==
        null
          ? void 0
          : O.accounts
      return (y == null ? void 0 : y.map(I => I.split(':')[2])) ?? []
    },
    async getProvider({ chainId: m } = {}) {
      var E, x
      i ||
        ((i = await e.getUniversalProvider()),
        i == null || i.events.setMaxListeners(Number.POSITIVE_INFINITY))
      const y = Ne.getActiveNamespace(),
        A = (E = e.getCaipNetwork()) == null ? void 0 : E.id
      if (m && A !== m && y) {
        const O = Ne.getStoredActiveCaipNetworkId(),
          I = e == null ? void 0 : e.getCaipNetworks(y),
          M = I == null ? void 0 : I.find($ => $.id === O)
        M &&
          M.chainNamespace === he.CHAIN.EVM &&
          (await ((x = this.switchChain) == null
            ? void 0
            : x.call(this, { chainId: Number(M.id) })))
      }
      return i
    },
    async getChainId() {
      var x, O, I, M
      const m = (x = e.getCaipNetwork(he.CHAIN.EVM)) == null ? void 0 : x.id
      if (m) return m
      const A =
          (M =
            (I =
              (O = (await this.getProvider()).session) == null
                ? void 0
                : O.namespaces[he.CHAIN.EVM]) == null
              ? void 0
              : I.chains) == null
            ? void 0
            : M[0],
        E = n.find($ => $.id === A)
      return E == null ? void 0 : E.id
    },
    async isAuthorized() {
      try {
        const [m, y] = await Promise.all([this.getAccounts(), this.getProvider()])
        return m.length
          ? (await this.isChainsStale()) && y.session
            ? (await y.disconnect().catch(() => {}), !1)
            : !0
          : !1
      } catch {
        return !1
      }
    },
    async switchChain({ addEthereumChainParameter: m, chainId: y }) {
      var x, O, I, M
      const A = await this.getProvider()
      if (!A) throw new Ao()
      const E = n.find($ => $.id === y)
      if (!E) throw new Gs(new Jh())
      try {
        await A.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: it(y) }] }),
          E != null && E.caipNetworkId && A.setDefaultChain(E == null ? void 0 : E.caipNetworkId),
          g.emitter.emit('change', { chainId: Number(y) })
        const $ = await this.getRequestedChainsIds()
        return this.setRequestedChainsIds([...$, y]), { ...E, id: E.id }
      } catch ($) {
        const D = $
        if (/(?:user rejected)/iu.test(D.message)) throw new Xn(D)
        try {
          let R
          m != null && m.blockExplorerUrls
            ? (R = m.blockExplorerUrls)
            : (R =
                (x = E.blockExplorers) != null && x.default.url
                  ? [(O = E.blockExplorers) == null ? void 0 : O.default.url]
                  : [])
          const z =
              ((M = (I = E.rpcUrls) == null ? void 0 : I.chainDefault) == null ? void 0 : M.http) ||
              [],
            G = {
              blockExplorerUrls: R,
              chainId: it(y),
              chainName: E.name,
              iconUrls: m == null ? void 0 : m.iconUrls,
              nativeCurrency: E.nativeCurrency,
              rpcUrls: z
            }
          await A.request({ method: 'wallet_addEthereumChain', params: [G] })
          const j = await this.getRequestedChainsIds()
          return this.setRequestedChainsIds([...j, y]), { ...E, id: E.id }
        } catch (R) {
          throw new Xn(R)
        }
      }
    },
    onAccountsChanged(m) {
      m.length === 0
        ? this.onDisconnect()
        : g.emitter.emit('change', { accounts: m.map(y => Bo(y)) })
    },
    onChainChanged(m) {
      const y = Number(m)
      g.emitter.emit('change', { chainId: y })
    },
    onConnect(m) {
      this.setRequestedChainsIds(n.map(y => Number(y.id)))
    },
    async onDisconnect(m) {
      this.setRequestedChainsIds([]), g.emitter.emit('disconnect')
      const y = await this.getProvider()
      s && (y.removeListener('accountsChanged', s), (s = void 0)),
        c && (y.removeListener('chainChanged', c), (c = void 0)),
        p && (y.removeListener('disconnect', p), (p = void 0)),
        d && (y.removeListener('session_delete', d), (d = void 0)),
        u || ((u = this.onConnect.bind(this)), y.on('connect', u))
    },
    onDisplayUri(m) {
      g.emitter.emit('message', { type: 'display_uri', data: m })
    },
    onSessionDelete() {
      this.onDisconnect()
    },
    getNamespaceChainsIds() {
      var A, E, x
      if (!((A = i == null ? void 0 : i.session) != null && A.namespaces)) return []
      const m =
        (x = (E = i == null ? void 0 : i.session) == null ? void 0 : E.namespaces[he.CHAIN.EVM]) ==
        null
          ? void 0
          : x.accounts
      return (m == null ? void 0 : m.map(O => Number.parseInt(O.split(':')[1] ?? ''))) ?? []
    },
    async getRequestedChainsIds() {
      var y
      const m =
        (await ((y = g.storage) == null ? void 0 : y.getItem(this.requestedChainsStorageKey))) ?? []
      return [...new Set(m)]
    },
    async isChainsStale() {
      if (!r) return !1
      const m = g.chains.map(E => E.id),
        y = this.getNamespaceChainsIds()
      if (y.length && !y.some(E => m.includes(E))) return !1
      const A = await this.getRequestedChainsIds()
      return !m.every(E => A.includes(Number(E)))
    },
    async setRequestedChainsIds(m) {
      var y
      await ((y = g.storage) == null ? void 0 : y.setItem(this.requestedChainsStorageKey, m))
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`
    }
  })
}
const Xf = gn({ pendingTransactions: 0 }),
  T8 = {
    state: Xf,
    subscribeKey(t, e) {
      return zr(Xf, t, e)
    },
    increase(t) {
      Xf[t] += 1
    },
    decrease(t) {
      Xf[t] -= 1
    },
    reset(t) {
      Xf[t] = 0
    }
  }
function yie(t) {
  try {
    return JSON.parse(t)
  } catch {
    throw new Error('Error parsing wallet capabilities')
  }
}
const vie = { enable: !1, pollingInterval: 3e4 }
class wie extends J9 {
  constructor(e) {
    super({
      projectId: e.projectId,
      networks: Wc.extendCaipNetworks(e.networks, {
        projectId: e.projectId,
        customNetworkImageUrls: {},
        customRpcChainIds: e.transports ? Object.keys(e.transports).map(Number) : []
      })
    }),
      (this.adapterType = 'wagmi'),
      (this.balancePromises = {}),
      (this.pendingTransactionsFilter = { ...vie, ...(e.pendingTransactionsFilter ?? {}) }),
      (this.namespace = he.CHAIN.EVM),
      this.createConfig({
        ...e,
        networks: Wc.extendCaipNetworks(e.networks, {
          projectId: e.projectId,
          customNetworkImageUrls: {},
          customRpcChainIds: e.transports ? Object.keys(e.transports).map(Number) : []
        }),
        projectId: e.projectId
      }),
      this.setupWatchers()
  }
  async getAccounts(e) {
    var s
    const n = this.getWagmiConnector(e.id)
    if (!n) return { accounts: [] }
    if (n.id === he.CONNECTOR_ID.AUTH) {
      const c = n.provider,
        { address: u, accounts: f } = await c.connect()
      return Promise.resolve({
        accounts: (f || [{ address: u, type: 'eoa' }]).map(d =>
          $e.createAccount('eip155', d.address, d.type)
        )
      })
    }
    const { addresses: r, address: i } = ep(this.wagmiConfig)
    return Promise.resolve({
      accounts:
        (s = r || [i]) == null ? void 0 : s.map(c => $e.createAccount('eip155', c || '', 'eoa'))
    })
  }
  getWagmiConnector(e) {
    return this.wagmiConfig.connectors.find(n => n.id === e)
  }
  createConfig(e) {
    ;(this.caipNetworks = e.networks),
      (this.wagmiChains = this.caipNetworks.filter(s => s.chainNamespace === he.CHAIN.EVM))
    const n = this.wagmiChains.map(s => [s.id, Wc.getViemTransport(s)])
    Object.entries(e.transports ?? {}).forEach(([s, c]) => {
      const u = n.findIndex(([f]) => f === Number(s))
      u === -1 ? n.push([Number(s), c]) : (n[u] = [Number(s), c])
    })
    const r = Object.fromEntries(n),
      i = [...(e.connectors ?? [])]
    this.wagmiConfig = mne({ ...e, chains: this.wagmiChains, transports: r, connectors: i })
  }
  setupWatchPendingTransactions() {
    if (!this.pendingTransactionsFilter.enable || this.unwatchPendingTransactions) return
    this.unwatchPendingTransactions = Yte(this.wagmiConfig, {
      pollingInterval: this.pendingTransactionsFilter.pollingInterval,
      onError: () => {},
      onTransactions: () => {
        this.emit('pendingTransactions'), T8.increase('pendingTransactions')
      }
    })
    const e = T8.subscribeKey('pendingTransactions', n => {
      var r
      n >= he.LIMITS.PENDING_TRANSACTIONS &&
        ((r = this.unwatchPendingTransactions) == null || r.call(this), e())
    })
  }
  setupWatchers() {
    lI(this.wagmiConfig, {
      onChange: (e, n) => {
        e.status === 'disconnected' && n.address && this.emit('disconnect'),
          e.status === 'connected' &&
            ((e.address !== (n == null ? void 0 : n.address) || n.status !== 'connected') &&
              (this.setupWatchPendingTransactions(),
              this.emit('accountChanged', { address: e.address })),
            e.chainId !== (n == null ? void 0 : n.chainId) &&
              this.emit('switchNetwork', { address: e.address, chainId: e.chainId }))
      }
    })
  }
  async addThirdPartyConnectors(e) {
    var r, i
    const n = []
    if (e.enableCoinbase !== !1)
      try {
        const { coinbaseWallet: s } = await ei(async () => {
          const { coinbaseWallet: c } = await import('./index-Ch5gbc8c.js')
          return { coinbaseWallet: c }
        }, [])
        s &&
          n.push(
            s({
              version: '4',
              appName: ((r = e.metadata) == null ? void 0 : r.name) ?? 'Unknown',
              appLogoUrl: ((i = e.metadata) == null ? void 0 : i.icons[0]) ?? 'Unknown',
              preference: e.coinbasePreference ?? 'all'
            })
          )
      } catch (s) {
        console.error('Failed to import Coinbase Wallet SDK:', s)
      }
    n.forEach(s => {
      const c = this.wagmiConfig._internal.connectors.setup(s)
      this.wagmiConfig._internal.connectors.setState(u => [...u, c])
    })
  }
  addWagmiConnectors(e, n) {
    var c, u, f, d, p
    const r = []
    e.enableWalletConnect !== !1 && r.push(X2(e, n, this.caipNetworks)),
      e.enableInjected !== !1 && r.push(eb({ shimDisconnect: !0 }))
    const i =
        ((c = e.features) == null ? void 0 : c.email) === void 0
          ? Fn.DEFAULT_FEATURES.email
          : (u = e.features) == null
            ? void 0
            : u.email,
      s =
        (f = e.features) != null && f.socials
          ? ((p = (d = e.features) == null ? void 0 : d.socials) == null ? void 0 : p.length) > 0
          : Fn.DEFAULT_FEATURES.socials
    ;(i || s) &&
      r.push(
        bie({
          chains: this.wagmiChains,
          options: { projectId: e.projectId, enableAuthLogger: e.enableAuthLogger }
        })
      ),
      r.forEach(g => {
        const m = this.wagmiConfig._internal.connectors.setup(g)
        this.wagmiConfig._internal.connectors.setState(y => [...y, m])
      })
  }
  async signMessage(e) {
    try {
      return { signature: await uI(this.wagmiConfig, { message: e.message, account: e.address }) }
    } catch {
      throw new Error('WagmiAdapter:signMessage - Sign message failed')
    }
  }
  async sendTransaction(e) {
    const { chainId: n } = ep(this.wagmiConfig),
      r = {
        account: e.address,
        to: e.to,
        value: e.value,
        gas: e.gas,
        gasPrice: e.gasPrice,
        data: e.data,
        chainId: n,
        type: 'legacy'
      }
    await Gte(this.wagmiConfig, r)
    const i = await cI(this.wagmiConfig, r)
    return await dI(this.wagmiConfig, { hash: i, timeout: 25e3 }), { hash: i }
  }
  async writeContract(e) {
    var c
    const { caipNetwork: n, ...r } = e,
      i = Number(yh.caipNetworkIdToNumber(n.caipNetworkId))
    return {
      hash: await fI(this.wagmiConfig, {
        chain: (c = this.wagmiChains) == null ? void 0 : c[i],
        chainId: i,
        address: r.tokenAddress,
        account: r.fromAddress,
        abi: r.abi,
        functionName: r.method,
        args: r.args,
        __mode: 'prepared'
      })
    }
  }
  async getEnsAddress(e) {
    const { name: n, caipNetwork: r } = e
    try {
      if (!this.wagmiConfig)
        throw new Error(
          'networkControllerClient:getApprovedCaipNetworksData - wagmiConfig is undefined'
        )
      let i = !1,
        s = !1
      return (
        O7(n) && (s = (await Jm.resolveReownName(n)) || !1),
        r.id === 1 && (i = await zte(this.wagmiConfig, { name: mie(n), chainId: r.id })),
        { address: i || s || !1 }
      )
    } catch {
      return { address: !1 }
    }
  }
  async estimateGas(e) {
    try {
      return {
        gas: await rI(this.wagmiConfig, {
          account: e.address,
          to: e.to,
          data: e.data,
          type: 'legacy'
        })
      }
    } catch {
      throw new Error('WagmiAdapter:estimateGas - error estimating gas')
    }
  }
  parseUnits(e) {
    return R9(e.value, e.decimals)
  }
  formatUnits(e) {
    return xd(e.value, e.decimals)
  }
  async addWagmiConnector(e, n) {
    var i
    if (e.id === he.CONNECTOR_ID.AUTH || e.id === he.CONNECTOR_ID.WALLET_CONNECT) return
    const r = await e.getProvider().catch(() => {})
    this.addConnector({
      id: e.id,
      explorerId: Lo.ConnectorExplorerIds[e.id],
      imageUrl: ((i = n == null ? void 0 : n.connectorImages) == null ? void 0 : i[e.id]) ?? e.icon,
      name: Lo.ConnectorNamesMap[e.id] ?? e.name,
      imageId: Lo.ConnectorImageIds[e.id],
      type: Lo.ConnectorTypesMap[e.type] ?? 'EXTERNAL',
      info: e.id === he.CONNECTOR_ID.INJECTED ? void 0 : { rdns: e.id },
      provider: r,
      chain: this.namespace,
      chains: []
    })
  }
  async syncConnectors(e, n) {
    Qte(this.wagmiConfig, { onChange: r => r.forEach(i => this.addWagmiConnector(i, e)) }),
      await Promise.all(this.wagmiConfig.connectors.map(r => this.addWagmiConnector(r, e))),
      this.addWagmiConnectors(e, n),
      await this.addThirdPartyConnectors(e)
  }
  async syncConnection(e) {
    const { id: n } = e,
      i = Sl(this.wagmiConfig).find(u => u.connector.id === n),
      s = this.getWagmiConnector(n),
      c = await (s == null ? void 0 : s.getProvider())
    return {
      chainId: Number(i == null ? void 0 : i.chainId),
      address: i == null ? void 0 : i.accounts[0],
      provider: c,
      type: i == null ? void 0 : i.connector.type,
      id: i == null ? void 0 : i.connector.id
    }
  }
  async connectWalletConnect(e) {
    const n = this.getWalletConnectConnector()
    await n.authenticate()
    const r = this.getWagmiConnector('walletConnect')
    if (!r) throw new Error('UniversalAdapter:connectWalletConnect - connector not found')
    return (
      await e8(this.wagmiConfig, { connector: r, chainId: e ? Number(e) : void 0 }),
      { clientId: await n.provider.client.core.crypto.getClientId() }
    )
  }
  async connect(e) {
    var d
    const { id: n, provider: r, type: i, info: s, chainId: c } = e,
      u = this.getWagmiConnector(n)
    if (!u) throw new Error('connectionControllerClient:connectExternal - connector is undefined')
    r &&
      s &&
      u.id === he.CONNECTOR_ID.EIP6963 &&
      ((d = u.setEip6963Wallet) == null || d.call(u, { provider: r, info: s }))
    const f = await e8(this.wagmiConfig, { connector: u, chainId: c ? Number(c) : void 0 })
    return { address: f.accounts[0], chainId: f.chainId, provider: r, type: i, id: n }
  }
  async reconnect(e) {
    const { id: n } = e,
      r = this.getWagmiConnector(n)
    if (!r) throw new Error('connectionControllerClient:connectExternal - connector is undefined')
    await oI(this.wagmiConfig, { connectors: [r] })
  }
  async getBalance(e) {
    var i
    const n = e.address,
      r = (i = this.caipNetworks) == null ? void 0 : i.find(s => s.id === e.chainId)
    if (!n) return Promise.resolve({ balance: '0.00', symbol: 'ETH' })
    if (r && this.wagmiConfig) {
      const s = `${r.caipNetworkId}:${e.address}`,
        c = this.balancePromises[s]
      if (c) return c
      const u = Ne.getNativeBalanceCacheForCaipAddress(s)
      return u
        ? { balance: u.balance, symbol: u.symbol }
        : ((this.balancePromises[s] = new Promise(async f => {
            var g, m
            const d = Number(e.chainId),
              p = await aI(this.wagmiConfig, {
                address: e.address,
                chainId: d,
                token:
                  (m = (g = e.tokens) == null ? void 0 : g[r.caipNetworkId]) == null
                    ? void 0
                    : m.address
              })
            Ne.updateNativeBalanceCache({
              caipAddress: s,
              balance: p.formatted,
              symbol: p.symbol,
              timestamp: Date.now()
            }),
              f({ balance: p.formatted, symbol: p.symbol })
          }).finally(() => {
            delete this.balancePromises[s]
          })),
          this.balancePromises[s] || { balance: '0.00', symbol: 'ETH' })
    }
    return { balance: '', symbol: '' }
  }
  async getProfile(e) {
    const n = e.chainId,
      r = await Hte(this.wagmiConfig, { address: e.address, chainId: n })
    if (r) {
      const i = await qte(this.wagmiConfig, { name: r, chainId: n })
      return { profileName: r, profileImage: i ?? void 0 }
    }
    return { profileName: void 0, profileImage: void 0 }
  }
  getWalletConnectProvider() {
    var e
    return (e = this.getWagmiConnector('walletConnect')) == null ? void 0 : e.provider
  }
  async disconnect() {
    const e = Sl(this.wagmiConfig)
    await Promise.all(
      e.map(async n => {
        const r = this.getWagmiConnector(n.connector.id)
        r && (await $te(this.wagmiConfig, { connector: r }))
      })
    )
  }
  async switchNetwork(e) {
    await Kte(this.wagmiConfig, { chainId: e.caipNetwork.id }), await super.switchNetwork(e)
  }
  async getCapabilities(e) {
    var u, f
    if (!this.wagmiConfig)
      throw new Error('connectionControllerClient:getCapabilities - wagmiConfig is undefined')
    const r = Sl(this.wagmiConfig)[0],
      i = r ? this.getWagmiConnector(r.connector.id) : null
    if (!i) throw new Error('connectionControllerClient:getCapabilities - connector is undefined')
    const s = await i.getProvider()
    if (!s) throw new Error('connectionControllerClient:getCapabilities - provider is undefined')
    const c =
      (f = (u = s.session) == null ? void 0 : u.sessionProperties) == null ? void 0 : f.capabilities
    if (c) {
      const p = yie(c)[e]
      if (p) return p
    }
    return await s.request({ method: 'wallet_getCapabilities', params: [e] })
  }
  async grantPermissions(e) {
    if (!this.wagmiConfig)
      throw new Error('connectionControllerClient:grantPermissions - wagmiConfig is undefined')
    const r = Sl(this.wagmiConfig)[0],
      i = r ? this.getWagmiConnector(r.connector.id) : null
    if (!i) throw new Error('connectionControllerClient:grantPermissions - connector is undefined')
    const s = await i.getProvider()
    if (!s) throw new Error('connectionControllerClient:grantPermissions - provider is undefined')
    return s.request({ method: 'wallet_grantPermissions', params: e })
  }
  async revokePermissions(e) {
    if (!this.wagmiConfig)
      throw new Error('connectionControllerClient:revokePermissions - wagmiConfig is undefined')
    const r = Sl(this.wagmiConfig)[0],
      i = r ? this.getWagmiConnector(r.connector.id) : null
    if (!i) throw new Error('connectionControllerClient:revokePermissions - connector is undefined')
    const s = await i.getProvider()
    if (!s) throw new Error('connectionControllerClient:revokePermissions - provider is undefined')
    return s.request({ method: 'wallet_revokePermissions', params: e })
  }
  async walletGetAssets(e) {
    if (!this.wagmiConfig)
      throw new Error('connectionControllerClient:walletGetAssets - wagmiConfig is undefined')
    const r = Sl(this.wagmiConfig)[0],
      i = r ? this.getWagmiConnector(r.connector.id) : null
    if (!i) throw new Error('connectionControllerClient:walletGetAssets - connector is undefined')
    const s = await i.getProvider()
    if (!s) throw new Error('connectionControllerClient:walletGetAssets - provider is undefined')
    return s.request({ method: 'wallet_getAssets', params: [e] })
  }
  setUniversalProvider(e) {
    this.addConnector(
      new j2({ provider: e, caipNetworks: this.caipNetworks || [], namespace: 'eip155' })
    )
  }
}
const VI = 'b56e18d47c72ab683b10814fe9495694',
  Eie = {
    name: 'AppKit',
    description: 'AppKit Example',
    url: 'https://reown.com',
    icons: ['https://avatars.githubusercontent.com/u/179229932']
  },
  J2 = [vte, yte, wte],
  eA = new wie({ projectId: VI, networks: J2 })
eA.wagmiConfig
const x8 = { to: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', value: oX('0.0001') },
  Aie = ({ sendHash: t, sendSignMsg: e, sendBalance: n }) => {
    const { disconnect: r } = NX(),
      { open: i } = xte(),
      { switchNetwork: s } = eI(),
      { address: c, isConnected: u } = B2(),
      { data: f } = xre({ ...x8 }),
      { data: d, sendTransaction: p } = Ire(),
      { signMessageAsync: g } = Ore(),
      { refetch: m } = Sre({ address: c })
    Le.useEffect(() => {
      d && t(d)
    }, [d])
    const y = () => {
        try {
          p({ ...x8, gas: f })
        } catch (O) {
          console.log('Error sending transaction:', O)
        }
      },
      A = async () => {
        const I = await g({ message: 'Hello Reown AppKit!', account: c })
        e(I)
      },
      E = async () => {
        var I, M
        const O = await m()
        n(
          ((I = O == null ? void 0 : O.data) == null ? void 0 : I.value.toString()) +
            ' ' +
            ((M = O == null ? void 0 : O.data) == null ? void 0 : M.symbol.toString())
        )
      },
      x = async () => {
        try {
          await r()
        } catch (O) {
          console.error('Failed to disconnect:', O)
        }
      }
    return (
      u &&
      De.jsxs('div', {
        children: [
          De.jsx('button', { onClick: () => i(), children: 'Open' }),
          De.jsx('button', { onClick: x, children: 'Disconnect' }),
          De.jsx('button', { onClick: () => s(J2[1]), children: 'Switch' }),
          De.jsx('button', { onClick: A, children: 'Sign msg' }),
          De.jsx('button', { onClick: y, children: 'Send tx' }),
          De.jsx('button', { onClick: E, children: 'Get Balance' })
        ]
      })
    )
  },
  N8 = [
    {
      inputs: [],
      name: 'retrieve',
      outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
      stateMutability: 'view',
      type: 'function'
    },
    {
      inputs: [{ internalType: 'uint256', name: 'num', type: 'uint256' }],
      name: 'store',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function'
    }
  ],
  I8 = '0xEe6D291CC60d7CeD6627fA4cd8506912245c8cA4',
  _ie = () => {
    const { isConnected: t } = B2(),
      { chainId: e } = eI(),
      { writeContract: n, isSuccess: r } = Dre(),
      i = Nre({ address: I8, abi: N8, functionName: 'retrieve', query: { enabled: !1 } })
    Le.useEffect(() => {
      r && console.log('contract write success')
    }, [r])
    const s = async () => {
        console.log('Read Sepolia Smart Contract')
        const { data: u } = await i.refetch()
        console.log('data: ', u)
      },
      c = () => {
        console.log('Write Sepolia Smart Contract'),
          n({ address: I8, abi: N8, functionName: 'store', args: [123n] })
      }
    return (
      t &&
      e === 11155111 &&
      De.jsxs('div', {
        children: [
          De.jsx('button', { onClick: s, children: 'Read Sepolia Smart Contract' }),
          De.jsx('button', { onClick: c, children: 'Write Sepolia Smart Contract' })
        ]
      })
    )
  },
  Cie = ({ hash: t, signedMsg: e, balance: n }) => {
    var y, A, E, x, O
    const r = Tte(),
      i = Ite(),
      { address: s, caipAddress: c, isConnected: u, status: f, embeddedWalletInfo: d } = B2(),
      p = Ote(),
      { walletInfo: g } = Nte(),
      { data: m } = Rre({ hash: t, confirmations: 2, timeout: 3e5, pollingInterval: 1e3 })
    return (
      Le.useEffect(() => {
        console.log('Events: ', p)
      }, [p]),
      Le.useEffect(() => {
        console.log('Embedded Wallet Info: ', d)
      }, [d]),
      De.jsxs(De.Fragment, {
        children: [
          n && De.jsx('section', { children: De.jsxs('h2', { children: ['Balance: ', n] }) }),
          t &&
            De.jsxs('section', {
              children: [
                De.jsx('h2', { children: 'Sign Tx' }),
                De.jsxs('pre', {
                  children: [
                    'Hash: ',
                    t,
                    De.jsx('br', {}),
                    'Status: ',
                    m == null ? void 0 : m.status.toString(),
                    De.jsx('br', {})
                  ]
                })
              ]
            }),
          e &&
            De.jsxs('section', {
              children: [
                De.jsx('h2', { children: 'Sign msg' }),
                De.jsxs('pre', { children: ['signedMsg: ', e, De.jsx('br', {})] })
              ]
            }),
          De.jsxs('section', {
            children: [
              De.jsx('h2', { children: 'useAppKit' }),
              De.jsxs('pre', {
                children: [
                  'Address: ',
                  s,
                  De.jsx('br', {}),
                  'caip Address: ',
                  c,
                  De.jsx('br', {}),
                  'Connected: ',
                  u.toString(),
                  De.jsx('br', {}),
                  'Status: ',
                  f,
                  De.jsx('br', {}),
                  'Account Type: ',
                  d == null ? void 0 : d.accountType,
                  De.jsx('br', {}),
                  ((y = d == null ? void 0 : d.user) == null ? void 0 : y.email) &&
                    `Email: ${(A = d == null ? void 0 : d.user) == null ? void 0 : A.email}
`,
                  ((E = d == null ? void 0 : d.user) == null ? void 0 : E.username) &&
                    `Username: ${(x = d == null ? void 0 : d.user) == null ? void 0 : x.username}
`,
                  (d == null ? void 0 : d.authProvider) &&
                    `Provider: ${d == null ? void 0 : d.authProvider}
`
                ]
              })
            ]
          }),
          De.jsxs('section', {
            children: [
              De.jsx('h2', { children: 'Theme' }),
              De.jsxs('pre', { children: ['Theme: ', r.themeMode, De.jsx('br', {})] })
            ]
          }),
          De.jsxs('section', {
            children: [
              De.jsx('h2', { children: 'State' }),
              De.jsxs('pre', {
                children: [
                  'activeChain: ',
                  i.activeChain,
                  De.jsx('br', {}),
                  'loading: ',
                  i.loading.toString(),
                  De.jsx('br', {}),
                  'open: ',
                  i.open.toString(),
                  De.jsx('br', {}),
                  'selectedNetworkId: ',
                  (O = i.selectedNetworkId) == null ? void 0 : O.toString(),
                  De.jsx('br', {})
                ]
              })
            ]
          }),
          De.jsxs('section', {
            children: [
              De.jsx('h2', { children: 'WalletInfo' }),
              De.jsxs('pre', { children: ['Name: ', JSON.stringify(g), De.jsx('br', {})] })
            ]
          })
        ]
      })
    )
  },
  Sie = new Gne(),
  Tie = {
    projectId: VI,
    networks: J2,
    metadata: Eie,
    themeMode: 'light',
    themeVariables: { '--w3m-accent': '#000000' }
  }
Dte({ adapters: [eA], ...Tie, features: { analytics: !0 } })
function xie() {
  const [t, e] = Le.useState(void 0),
    [n, r] = Le.useState(''),
    [i, s] = Le.useState(''),
    c = d => {
      e(d)
    },
    u = d => {
      r(d)
    },
    f = d => {
      s(d)
    }
  return De.jsxs('div', {
    className: 'pages',
    children: [
      De.jsx('img', {
        src: '/reown.svg',
        alt: 'Reown',
        style: { width: '150px', height: '150px' }
      }),
      De.jsx('h1', { children: 'AppKit Wagmi React dApp Example' }),
      De.jsx(vne, {
        config: eA.wagmiConfig,
        children: De.jsxs(fre, {
          client: Sie,
          children: [
            De.jsx('appkit-button', {}),
            De.jsx(Aie, { sendHash: c, sendSignMsg: u, sendBalance: f }),
            De.jsx(_ie, {}),
            De.jsx('div', {
              className: 'advice',
              children: De.jsxs('p', {
                children: [
                  'This projectId only works on localhost. ',
                  De.jsx('br', {}),
                  'Go to ',
                  De.jsx('a', {
                    href: 'https://cloud.reown.com',
                    target: '_blank',
                    className: 'link-button',
                    rel: 'Reown Cloud',
                    children: 'Reown Cloud'
                  }),
                  ' to get your own.'
                ]
              })
            }),
            De.jsx(Cie, { hash: t, signedMsg: n, balance: i })
          ]
        })
      })
    ]
  })
}
c7.createRoot(document.getElementById('root')).render(
  De.jsx(Le.StrictMode, { children: De.jsx(xie, {}) })
)
export {
  Gs as $,
  Oe as A,
  Me as B,
  Ge as C,
  Mse as D,
  M9 as E,
  Ose as F,
  hE as G,
  H1 as H,
  pn as I,
  fh as J,
  pd as K,
  cr as L,
  Kn as M,
  Lt as N,
  be as O,
  Vc as P,
  Rse as Q,
  ct as R,
  $t as S,
  Ir as T,
  V9 as U,
  pE as V,
  yn as W,
  ld as X,
  kse as Y,
  Bo as Z,
  ei as _,
  Fn as a,
  Jh as a0,
  it as a1,
  Xn as a2,
  eb as a3,
  fe as a4,
  E2 as a5,
  ji as a6,
  uY as a7,
  JY as a8,
  A9 as a9,
  au as aa,
  HN as ab,
  hh as ac,
  Ua as ad,
  YT as ae,
  dse as af,
  QE as ag,
  Wg as ah,
  bp as ai,
  pse as aj,
  hse as ak,
  pL as al,
  fse as am,
  one as an,
  ux as ao,
  Mm as ap,
  j8 as aq,
  D7 as ar,
  $s as as,
  sne as at,
  Dse as b,
  he as c,
  $e as d,
  Ft as e,
  Pse as f,
  Ia as g,
  gi as h,
  Ll as i,
  Q as j,
  ot as k,
  Jee as l,
  Ne as m,
  Pg as n,
  x4 as o,
  K8 as p,
  gn as q,
  Ug as r,
  Iie as s,
  gt as t,
  Oie as u,
  zr as v,
  Rr as w,
  Ise as x,
  lQ as y,
  os as z
}
