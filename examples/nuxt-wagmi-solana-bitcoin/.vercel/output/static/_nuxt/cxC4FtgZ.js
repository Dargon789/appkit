const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      './CbKxocG1.js',
      './D1u8rsYX.js',
      './r3wKis81.js',
      './D5z3hTdP.js',
      './DFaAtWOZ.js',
      './DsbIaR_i.js',
      './JuF9HxfP.js',
      './BmM00R2E.js',
      './CmZgvnX6.js',
      './Byf3mnWf.js',
      './BZU83xiY.js',
      './DPcD01Y-.js',
      './DsZhg2eE.js',
      './FCK0KV_d.js',
      './BFpzFLve.js',
      './CgL49DcC.js',
      './Cm82hlkb.js',
      './CgAXqmu2.js',
      './DfhYfNQu.js',
      './BDn2hctu.js',
      './CXtVhYXf.js',
      './Bj1RrTHK.js',
      './ObusKAv1.js',
      './CVyQrXOe.js',
      './4J_2vLEF.js',
      './VeQhFUeZ.js',
      './Ci7UvA_a.js',
      './D_pt2Wo-.js',
      './D3U4eLiN.js',
      './CWev_0dc.js',
      './DmqZ4eto.js',
      './BDdoSM5a.js',
      './BKj7FodF.js',
      './TVxiSsSt.js',
      './D1Gp4_tn.js',
      './error-404.C7ehc5wm.css',
      './DJuK5Oly.js',
      './error-500.Bd_pQmlY.css'
    ])
) => i.map(i => d[i])
var eB = Object.defineProperty
var g_ = t => {
  throw TypeError(t)
}
var tB = (t, e, n) =>
  e in t ? eB(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)
var Cn = (t, e, n) => tB(t, typeof e != 'symbol' ? e + '' : e, n),
  ky = (t, e, n) => e.has(t) || g_('Cannot ' + n)
var Ee = (t, e, n) => (ky(t, e, 'read from private field'), n ? n.call(t) : e.get(t)),
  Jt = (t, e, n) =>
    e.has(t)
      ? g_('Cannot add the same private member more than once')
      : e instanceof WeakSet
        ? e.add(t)
        : e.set(t, n),
  Pt = (t, e, n, r) => (ky(t, e, 'write to private field'), r ? r.call(t, n) : e.set(t, n), n),
  Dr = (t, e, n) => (ky(t, e, 'access private method'), n)
var kp = (t, e, n, r) => ({
  set _(s) {
    Pt(t, e, s, n)
  },
  get _() {
    return Ee(t, e, r)
  }
})
;(function () {
  const e = document.createElement('link').relList
  if (e && e.supports && e.supports('modulepreload')) return
  for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s)
  new MutationObserver(s => {
    for (const i of s)
      if (i.type === 'childList')
        for (const o of i.addedNodes) o.tagName === 'LINK' && o.rel === 'modulepreload' && r(o)
  }).observe(document, { childList: !0, subtree: !0 })
  function n(s) {
    const i = {}
    return (
      s.integrity && (i.integrity = s.integrity),
      s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy),
      s.crossOrigin === 'use-credentials'
        ? (i.credentials = 'include')
        : s.crossOrigin === 'anonymous'
          ? (i.credentials = 'omit')
          : (i.credentials = 'same-origin'),
      i
    )
  }
  function r(s) {
    if (s.ep) return
    s.ep = !0
    const i = n(s)
    fetch(s.href, i)
  }
})()
/**
 * @vue/shared v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ /*! #__NO_SIDE_EFFECTS__ */ function Qv(t) {
  const e = Object.create(null)
  for (const n of t.split(',')) e[n] = 1
  return n => n in e
}
const En = {},
  El = [],
  eo = () => {},
  nB = () => !1,
  Jf = t =>
    t.charCodeAt(0) === 111 &&
    t.charCodeAt(1) === 110 &&
    (t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97),
  Zv = t => t.startsWith('onUpdate:'),
  Gr = Object.assign,
  Yv = (t, e) => {
    const n = t.indexOf(e)
    n > -1 && t.splice(n, 1)
  },
  rB = Object.prototype.hasOwnProperty,
  tn = (t, e) => rB.call(t, e),
  _t = Array.isArray,
  Al = t => Zm(t) === '[object Map]',
  nN = t => Zm(t) === '[object Set]',
  bt = t => typeof t == 'function',
  Hn = t => typeof t == 'string',
  oc = t => typeof t == 'symbol',
  Pn = t => t !== null && typeof t == 'object',
  rN = t => (Pn(t) || bt(t)) && bt(t.then) && bt(t.catch),
  sN = Object.prototype.toString,
  Zm = t => sN.call(t),
  sB = t => Zm(t).slice(8, -1),
  iN = t => Zm(t) === '[object Object]',
  Jv = t => Hn(t) && t !== 'NaN' && t[0] !== '-' && '' + parseInt(t, 10) === t,
  _l = Qv(
    ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
  ),
  Ym = t => {
    const e = Object.create(null)
    return n => e[n] || (e[n] = t(n))
  },
  iB = /-(\w)/g,
  ai = Ym(t => t.replace(iB, (e, n) => (n ? n.toUpperCase() : ''))),
  oB = /\B([A-Z])/g,
  Au = Ym(t => t.replace(oB, '-$1').toLowerCase()),
  Jm = Ym(t => t.charAt(0).toUpperCase() + t.slice(1)),
  Oy = Ym(t => (t ? `on${Jm(t)}` : '')),
  Fa = (t, e) => !Object.is(t, e),
  By = (t, ...e) => {
    for (let n = 0; n < t.length; n++) t[n](...e)
  },
  oN = (t, e, n, r = !1) => {
    Object.defineProperty(t, e, { configurable: !0, enumerable: !1, writable: r, value: n })
  },
  aB = t => {
    const e = parseFloat(t)
    return isNaN(e) ? t : e
  },
  cB = t => {
    const e = Hn(t) ? Number(t) : NaN
    return isNaN(e) ? t : e
  }
let m_
const Xm = () =>
  m_ ||
  (m_ =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
        ? self
        : typeof window < 'u'
          ? window
          : typeof global < 'u'
            ? global
            : {})
function e0(t) {
  if (_t(t)) {
    const e = {}
    for (let n = 0; n < t.length; n++) {
      const r = t[n],
        s = Hn(r) ? hB(r) : e0(r)
      if (s) for (const i in s) e[i] = s[i]
    }
    return e
  } else if (Hn(t) || Pn(t)) return t
}
const uB = /;(?![^(]*\))/g,
  lB = /:([^]+)/,
  dB = /\/\*[^]*?\*\//g
function hB(t) {
  const e = {}
  return (
    t
      .replace(dB, '')
      .split(uB)
      .forEach(n => {
        if (n) {
          const r = n.split(lB)
          r.length > 1 && (e[r[0].trim()] = r[1].trim())
        }
      }),
    e
  )
}
function t0(t) {
  let e = ''
  if (Hn(t)) e = t
  else if (_t(t))
    for (let n = 0; n < t.length; n++) {
      const r = t0(t[n])
      r && (e += r + ' ')
    }
  else if (Pn(t)) for (const n in t) t[n] && (e += n + ' ')
  return e.trim()
}
function fB(t) {
  if (!t) return null
  let { class: e, style: n } = t
  return e && !Hn(e) && (t.class = t0(e)), n && (t.style = e0(n)), t
}
const pB = 'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
  gB = Qv(pB)
function aN(t) {
  return !!t || t === ''
}
const cN = t => !!(t && t.__v_isRef === !0),
  Hi = t =>
    Hn(t)
      ? t
      : t == null
        ? ''
        : _t(t) || (Pn(t) && (t.toString === sN || !bt(t.toString)))
          ? cN(t)
            ? Hi(t.value)
            : JSON.stringify(t, uN, 2)
          : String(t),
  uN = (t, e) =>
    cN(e)
      ? uN(t, e.value)
      : Al(e)
        ? {
            [`Map(${e.size})`]: [...e.entries()].reduce(
              (n, [r, s], i) => ((n[Dy(r, i) + ' =>'] = s), n),
              {}
            )
          }
        : nN(e)
          ? { [`Set(${e.size})`]: [...e.values()].map(n => Dy(n)) }
          : oc(e)
            ? Dy(e)
            : Pn(e) && !_t(e) && !iN(e)
              ? String(e)
              : e,
  Dy = (t, e = '') => {
    var n
    return oc(t) ? `Symbol(${(n = t.description) != null ? n : e})` : t
  }
/**
 * @vue/reactivity v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ let Bs
class lN {
  constructor(e = !1) {
    ;(this.detached = e),
      (this._active = !0),
      (this.effects = []),
      (this.cleanups = []),
      (this._isPaused = !1),
      (this.parent = Bs),
      !e && Bs && (this.index = (Bs.scopes || (Bs.scopes = [])).push(this) - 1)
  }
  get active() {
    return this._active
  }
  pause() {
    if (this._active) {
      this._isPaused = !0
      let e, n
      if (this.scopes) for (e = 0, n = this.scopes.length; e < n; e++) this.scopes[e].pause()
      for (e = 0, n = this.effects.length; e < n; e++) this.effects[e].pause()
    }
  }
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1
      let e, n
      if (this.scopes) for (e = 0, n = this.scopes.length; e < n; e++) this.scopes[e].resume()
      for (e = 0, n = this.effects.length; e < n; e++) this.effects[e].resume()
    }
  }
  run(e) {
    if (this._active) {
      const n = Bs
      try {
        return (Bs = this), e()
      } finally {
        Bs = n
      }
    }
  }
  on() {
    Bs = this
  }
  off() {
    Bs = this.parent
  }
  stop(e) {
    if (this._active) {
      this._active = !1
      let n, r
      for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop()
      for (this.effects.length = 0, n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]()
      if (((this.cleanups.length = 0), this.scopes)) {
        for (n = 0, r = this.scopes.length; n < r; n++) this.scopes[n].stop(!0)
        this.scopes.length = 0
      }
      if (!this.detached && this.parent && !e) {
        const s = this.parent.scopes.pop()
        s && s !== this && ((this.parent.scopes[this.index] = s), (s.index = this.index))
      }
      this.parent = void 0
    }
  }
}
function mB(t) {
  return new lN(t)
}
function dN() {
  return Bs
}
let vn
const My = new WeakSet()
class hN {
  constructor(e) {
    ;(this.fn = e),
      (this.deps = void 0),
      (this.depsTail = void 0),
      (this.flags = 5),
      (this.next = void 0),
      (this.cleanup = void 0),
      (this.scheduler = void 0),
      Bs && Bs.active && Bs.effects.push(this)
  }
  pause() {
    this.flags |= 64
  }
  resume() {
    this.flags & 64 && ((this.flags &= -65), My.has(this) && (My.delete(this), this.trigger()))
  }
  notify() {
    ;(this.flags & 2 && !(this.flags & 32)) || this.flags & 8 || pN(this)
  }
  run() {
    if (!(this.flags & 1)) return this.fn()
    ;(this.flags |= 2), y_(this), gN(this)
    const e = vn,
      n = Ti
    ;(vn = this), (Ti = !0)
    try {
      return this.fn()
    } finally {
      mN(this), (vn = e), (Ti = n), (this.flags &= -3)
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep) tE(e)
      ;(this.deps = this.depsTail = void 0),
        y_(this),
        this.onStop && this.onStop(),
        (this.flags &= -2)
    }
  }
  trigger() {
    this.flags & 64 ? My.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
  }
  runIfDirty() {
    Kb(this) && this.run()
  }
  get dirty() {
    return Kb(this)
  }
}
let fN = 0,
  Ch,
  Sh
function pN(t, e = !1) {
  if (((t.flags |= 8), e)) {
    ;(t.next = Sh), (Sh = t)
    return
  }
  ;(t.next = Ch), (Ch = t)
}
function Xv() {
  fN++
}
function eE() {
  if (--fN > 0) return
  if (Sh) {
    let e = Sh
    for (Sh = void 0; e; ) {
      const n = e.next
      ;(e.next = void 0), (e.flags &= -9), (e = n)
    }
  }
  let t
  for (; Ch; ) {
    let e = Ch
    for (Ch = void 0; e; ) {
      const n = e.next
      if (((e.next = void 0), (e.flags &= -9), e.flags & 1))
        try {
          e.trigger()
        } catch (r) {
          t || (t = r)
        }
      e = n
    }
  }
  if (t) throw t
}
function gN(t) {
  for (let e = t.deps; e; e = e.nextDep)
    (e.version = -1), (e.prevActiveLink = e.dep.activeLink), (e.dep.activeLink = e)
}
function mN(t) {
  let e,
    n = t.depsTail,
    r = n
  for (; r; ) {
    const s = r.prevDep
    r.version === -1 ? (r === n && (n = s), tE(r), yB(r)) : (e = r),
      (r.dep.activeLink = r.prevActiveLink),
      (r.prevActiveLink = void 0),
      (r = s)
  }
  ;(t.deps = e), (t.depsTail = n)
}
function Kb(t) {
  for (let e = t.deps; e; e = e.nextDep)
    if (
      e.dep.version !== e.version ||
      (e.dep.computed && (yN(e.dep.computed) || e.dep.version !== e.version))
    )
      return !0
  return !!t._dirty
}
function yN(t) {
  if ((t.flags & 4 && !(t.flags & 16)) || ((t.flags &= -17), t.globalVersion === Hh)) return
  t.globalVersion = Hh
  const e = t.dep
  if (((t.flags |= 2), e.version > 0 && !t.isSSR && t.deps && !Kb(t))) {
    t.flags &= -3
    return
  }
  const n = vn,
    r = Ti
  ;(vn = t), (Ti = !0)
  try {
    gN(t)
    const s = t.fn(t._value)
    ;(e.version === 0 || Fa(s, t._value)) && ((t._value = s), e.version++)
  } catch (s) {
    throw (e.version++, s)
  } finally {
    ;(vn = n), (Ti = r), mN(t), (t.flags &= -3)
  }
}
function tE(t, e = !1) {
  const { dep: n, prevSub: r, nextSub: s } = t
  if (
    (r && ((r.nextSub = s), (t.prevSub = void 0)),
    s && ((s.prevSub = r), (t.nextSub = void 0)),
    n.subs === t && ((n.subs = r), !r && n.computed))
  ) {
    n.computed.flags &= -5
    for (let i = n.computed.deps; i; i = i.nextDep) tE(i, !0)
  }
  !e && !--n.sc && n.map && n.map.delete(n.key)
}
function yB(t) {
  const { prevDep: e, nextDep: n } = t
  e && ((e.nextDep = n), (t.prevDep = void 0)), n && ((n.prevDep = e), (t.nextDep = void 0))
}
let Ti = !0
const wN = []
function ac() {
  wN.push(Ti), (Ti = !1)
}
function cc() {
  const t = wN.pop()
  Ti = t === void 0 ? !0 : t
}
function y_(t) {
  const { cleanup: e } = t
  if (((t.cleanup = void 0), e)) {
    const n = vn
    vn = void 0
    try {
      e()
    } finally {
      vn = n
    }
  }
}
let Hh = 0
class wB {
  constructor(e, n) {
    ;(this.sub = e),
      (this.dep = n),
      (this.version = n.version),
      (this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0)
  }
}
class nE {
  constructor(e) {
    ;(this.computed = e),
      (this.version = 0),
      (this.activeLink = void 0),
      (this.subs = void 0),
      (this.map = void 0),
      (this.key = void 0),
      (this.sc = 0)
  }
  track(e) {
    if (!vn || !Ti || vn === this.computed) return
    let n = this.activeLink
    if (n === void 0 || n.sub !== vn)
      (n = this.activeLink = new wB(vn, this)),
        vn.deps
          ? ((n.prevDep = vn.depsTail), (vn.depsTail.nextDep = n), (vn.depsTail = n))
          : (vn.deps = vn.depsTail = n),
        bN(n)
    else if (n.version === -1 && ((n.version = this.version), n.nextDep)) {
      const r = n.nextDep
      ;(r.prevDep = n.prevDep),
        n.prevDep && (n.prevDep.nextDep = r),
        (n.prevDep = vn.depsTail),
        (n.nextDep = void 0),
        (vn.depsTail.nextDep = n),
        (vn.depsTail = n),
        vn.deps === n && (vn.deps = r)
    }
    return n
  }
  trigger(e) {
    this.version++, Hh++, this.notify(e)
  }
  notify(e) {
    Xv()
    try {
      for (let n = this.subs; n; n = n.prevSub) n.sub.notify() && n.sub.dep.notify()
    } finally {
      eE()
    }
  }
}
function bN(t) {
  if ((t.dep.sc++, t.sub.flags & 4)) {
    const e = t.dep.computed
    if (e && !t.dep.subs) {
      e.flags |= 20
      for (let r = e.deps; r; r = r.nextDep) bN(r)
    }
    const n = t.dep.subs
    n !== t && ((t.prevSub = n), n && (n.nextSub = t)), (t.dep.subs = t)
  }
}
const Vg = new WeakMap(),
  Vc = Symbol(''),
  Vb = Symbol(''),
  qh = Symbol('')
function Wr(t, e, n) {
  if (Ti && vn) {
    let r = Vg.get(t)
    r || Vg.set(t, (r = new Map()))
    let s = r.get(n)
    s || (r.set(n, (s = new nE())), (s.map = r), (s.key = n)), s.track()
  }
}
function $o(t, e, n, r, s, i) {
  const o = Vg.get(t)
  if (!o) {
    Hh++
    return
  }
  const a = c => {
    c && c.trigger()
  }
  if ((Xv(), e === 'clear')) o.forEach(a)
  else {
    const c = _t(t),
      u = c && Jv(n)
    if (c && n === 'length') {
      const l = Number(r)
      o.forEach((d, h) => {
        ;(h === 'length' || h === qh || (!oc(h) && h >= l)) && a(d)
      })
    } else
      switch (((n !== void 0 || o.has(void 0)) && a(o.get(n)), u && a(o.get(qh)), e)) {
        case 'add':
          c ? u && a(o.get('length')) : (a(o.get(Vc)), Al(t) && a(o.get(Vb)))
          break
        case 'delete':
          c || (a(o.get(Vc)), Al(t) && a(o.get(Vb)))
          break
        case 'set':
          Al(t) && a(o.get(Vc))
          break
      }
  }
  eE()
}
function bB(t, e) {
  const n = Vg.get(t)
  return n && n.get(e)
}
function Mu(t) {
  const e = Zt(t)
  return e === t ? e : (Wr(e, 'iterate', qh), Ni(t) ? e : e.map(ss))
}
function rE(t) {
  return Wr((t = Zt(t)), 'iterate', qh), t
}
const vB = {
  __proto__: null,
  [Symbol.iterator]() {
    return Uy(this, Symbol.iterator, ss)
  },
  concat(...t) {
    return Mu(this).concat(...t.map(e => (_t(e) ? Mu(e) : e)))
  },
  entries() {
    return Uy(this, 'entries', t => ((t[1] = ss(t[1])), t))
  },
  every(t, e) {
    return bo(this, 'every', t, e, void 0, arguments)
  },
  filter(t, e) {
    return bo(this, 'filter', t, e, n => n.map(ss), arguments)
  },
  find(t, e) {
    return bo(this, 'find', t, e, ss, arguments)
  },
  findIndex(t, e) {
    return bo(this, 'findIndex', t, e, void 0, arguments)
  },
  findLast(t, e) {
    return bo(this, 'findLast', t, e, ss, arguments)
  },
  findLastIndex(t, e) {
    return bo(this, 'findLastIndex', t, e, void 0, arguments)
  },
  forEach(t, e) {
    return bo(this, 'forEach', t, e, void 0, arguments)
  },
  includes(...t) {
    return Ly(this, 'includes', t)
  },
  indexOf(...t) {
    return Ly(this, 'indexOf', t)
  },
  join(t) {
    return Mu(this).join(t)
  },
  lastIndexOf(...t) {
    return Ly(this, 'lastIndexOf', t)
  },
  map(t, e) {
    return bo(this, 'map', t, e, void 0, arguments)
  },
  pop() {
    return Ud(this, 'pop')
  },
  push(...t) {
    return Ud(this, 'push', t)
  },
  reduce(t, ...e) {
    return w_(this, 'reduce', t, e)
  },
  reduceRight(t, ...e) {
    return w_(this, 'reduceRight', t, e)
  },
  shift() {
    return Ud(this, 'shift')
  },
  some(t, e) {
    return bo(this, 'some', t, e, void 0, arguments)
  },
  splice(...t) {
    return Ud(this, 'splice', t)
  },
  toReversed() {
    return Mu(this).toReversed()
  },
  toSorted(t) {
    return Mu(this).toSorted(t)
  },
  toSpliced(...t) {
    return Mu(this).toSpliced(...t)
  },
  unshift(...t) {
    return Ud(this, 'unshift', t)
  },
  values() {
    return Uy(this, 'values', ss)
  }
}
function Uy(t, e, n) {
  const r = rE(t),
    s = r[e]()
  return (
    r !== t &&
      !Ni(t) &&
      ((s._next = s.next),
      (s.next = () => {
        const i = s._next()
        return i.value && (i.value = n(i.value)), i
      })),
    s
  )
}
const EB = Array.prototype
function bo(t, e, n, r, s, i) {
  const o = rE(t),
    a = o !== t && !Ni(t),
    c = o[e]
  if (c !== EB[e]) {
    const d = c.apply(t, i)
    return a ? ss(d) : d
  }
  let u = n
  o !== t &&
    (a
      ? (u = function (d, h) {
          return n.call(this, ss(d), h, t)
        })
      : n.length > 2 &&
        (u = function (d, h) {
          return n.call(this, d, h, t)
        }))
  const l = c.call(o, u, r)
  return a && s ? s(l) : l
}
function w_(t, e, n, r) {
  const s = rE(t)
  let i = n
  return (
    s !== t &&
      (Ni(t)
        ? n.length > 3 &&
          (i = function (o, a, c) {
            return n.call(this, o, a, c, t)
          })
        : (i = function (o, a, c) {
            return n.call(this, o, ss(a), c, t)
          })),
    s[e](i, ...r)
  )
}
function Ly(t, e, n) {
  const r = Zt(t)
  Wr(r, 'iterate', qh)
  const s = r[e](...n)
  return (s === -1 || s === !1) && oE(n[0]) ? ((n[0] = Zt(n[0])), r[e](...n)) : s
}
function Ud(t, e, n = []) {
  ac(), Xv()
  const r = Zt(t)[e].apply(t, n)
  return eE(), cc(), r
}
const AB = Qv('__proto__,__v_isRef,__isVue'),
  vN = new Set(
    Object.getOwnPropertyNames(Symbol)
      .filter(t => t !== 'arguments' && t !== 'caller')
      .map(t => Symbol[t])
      .filter(oc)
  )
function _B(t) {
  oc(t) || (t = String(t))
  const e = Zt(this)
  return Wr(e, 'has', t), e.hasOwnProperty(t)
}
class EN {
  constructor(e = !1, n = !1) {
    ;(this._isReadonly = e), (this._isShallow = n)
  }
  get(e, n, r) {
    if (n === '__v_skip') return e.__v_skip
    const s = this._isReadonly,
      i = this._isShallow
    if (n === '__v_isReactive') return !s
    if (n === '__v_isReadonly') return s
    if (n === '__v_isShallow') return i
    if (n === '__v_raw')
      return r === (s ? (i ? OB : SN) : i ? CN : _N).get(e) ||
        Object.getPrototypeOf(e) === Object.getPrototypeOf(r)
        ? e
        : void 0
    const o = _t(e)
    if (!s) {
      let c
      if (o && (c = vB[n])) return c
      if (n === 'hasOwnProperty') return _B
    }
    const a = Reflect.get(e, n, Vn(e) ? e : r)
    return (oc(n) ? vN.has(n) : AB(n)) || (s || Wr(e, 'get', n), i)
      ? a
      : Vn(a)
        ? o && Jv(n)
          ? a
          : a.value
        : Pn(a)
          ? s
            ? IN(a)
            : zs(a)
          : a
  }
}
class AN extends EN {
  constructor(e = !1) {
    super(!1, e)
  }
  set(e, n, r, s) {
    let i = e[n]
    if (!this._isShallow) {
      const c = Za(i)
      if ((!Ni(r) && !Za(r) && ((i = Zt(i)), (r = Zt(r))), !_t(e) && Vn(i) && !Vn(r)))
        return c ? !1 : ((i.value = r), !0)
    }
    const o = _t(e) && Jv(n) ? Number(n) < e.length : tn(e, n),
      a = Reflect.set(e, n, r, Vn(e) ? e : s)
    return e === Zt(s) && (o ? Fa(r, i) && $o(e, 'set', n, r) : $o(e, 'add', n, r)), a
  }
  deleteProperty(e, n) {
    const r = tn(e, n)
    e[n]
    const s = Reflect.deleteProperty(e, n)
    return s && r && $o(e, 'delete', n, void 0), s
  }
  has(e, n) {
    const r = Reflect.has(e, n)
    return (!oc(n) || !vN.has(n)) && Wr(e, 'has', n), r
  }
  ownKeys(e) {
    return Wr(e, 'iterate', _t(e) ? 'length' : Vc), Reflect.ownKeys(e)
  }
}
class CB extends EN {
  constructor(e = !1) {
    super(!0, e)
  }
  set(e, n) {
    return !0
  }
  deleteProperty(e, n) {
    return !0
  }
}
const SB = new AN(),
  IB = new CB(),
  xB = new AN(!0)
const Gb = t => t,
  Op = t => Reflect.getPrototypeOf(t)
function TB(t, e, n) {
  return function (...r) {
    const s = this.__v_raw,
      i = Zt(s),
      o = Al(i),
      a = t === 'entries' || (t === Symbol.iterator && o),
      c = t === 'keys' && o,
      u = s[t](...r),
      l = n ? Gb : e ? Qb : ss
    return (
      !e && Wr(i, 'iterate', c ? Vb : Vc),
      {
        next() {
          const { value: d, done: h } = u.next()
          return h ? { value: d, done: h } : { value: a ? [l(d[0]), l(d[1])] : l(d), done: h }
        },
        [Symbol.iterator]() {
          return this
        }
      }
    )
  }
}
function Bp(t) {
  return function (...e) {
    return t === 'delete' ? !1 : t === 'clear' ? void 0 : this
  }
}
function NB(t, e) {
  const n = {
    get(s) {
      const i = this.__v_raw,
        o = Zt(i),
        a = Zt(s)
      t || (Fa(s, a) && Wr(o, 'get', s), Wr(o, 'get', a))
      const { has: c } = Op(o),
        u = e ? Gb : t ? Qb : ss
      if (c.call(o, s)) return u(i.get(s))
      if (c.call(o, a)) return u(i.get(a))
      i !== o && i.get(s)
    },
    get size() {
      const s = this.__v_raw
      return !t && Wr(Zt(s), 'iterate', Vc), Reflect.get(s, 'size', s)
    },
    has(s) {
      const i = this.__v_raw,
        o = Zt(i),
        a = Zt(s)
      return (
        t || (Fa(s, a) && Wr(o, 'has', s), Wr(o, 'has', a)),
        s === a ? i.has(s) : i.has(s) || i.has(a)
      )
    },
    forEach(s, i) {
      const o = this,
        a = o.__v_raw,
        c = Zt(a),
        u = e ? Gb : t ? Qb : ss
      return !t && Wr(c, 'iterate', Vc), a.forEach((l, d) => s.call(i, u(l), u(d), o))
    }
  }
  return (
    Gr(
      n,
      t
        ? { add: Bp('add'), set: Bp('set'), delete: Bp('delete'), clear: Bp('clear') }
        : {
            add(s) {
              !e && !Ni(s) && !Za(s) && (s = Zt(s))
              const i = Zt(this)
              return Op(i).has.call(i, s) || (i.add(s), $o(i, 'add', s, s)), this
            },
            set(s, i) {
              !e && !Ni(i) && !Za(i) && (i = Zt(i))
              const o = Zt(this),
                { has: a, get: c } = Op(o)
              let u = a.call(o, s)
              u || ((s = Zt(s)), (u = a.call(o, s)))
              const l = c.call(o, s)
              return o.set(s, i), u ? Fa(i, l) && $o(o, 'set', s, i) : $o(o, 'add', s, i), this
            },
            delete(s) {
              const i = Zt(this),
                { has: o, get: a } = Op(i)
              let c = o.call(i, s)
              c || ((s = Zt(s)), (c = o.call(i, s))), a && a.call(i, s)
              const u = i.delete(s)
              return c && $o(i, 'delete', s, void 0), u
            },
            clear() {
              const s = Zt(this),
                i = s.size !== 0,
                o = s.clear()
              return i && $o(s, 'clear', void 0, void 0), o
            }
          }
    ),
    ['keys', 'values', 'entries', Symbol.iterator].forEach(s => {
      n[s] = TB(s, t, e)
    }),
    n
  )
}
function sE(t, e) {
  const n = NB(t, e)
  return (r, s, i) =>
    s === '__v_isReactive'
      ? !t
      : s === '__v_isReadonly'
        ? t
        : s === '__v_raw'
          ? r
          : Reflect.get(tn(n, s) && s in r ? n : r, s, i)
}
const PB = { get: sE(!1, !1) },
  RB = { get: sE(!1, !0) },
  kB = { get: sE(!0, !1) }
const _N = new WeakMap(),
  CN = new WeakMap(),
  SN = new WeakMap(),
  OB = new WeakMap()
function BB(t) {
  switch (t) {
    case 'Object':
    case 'Array':
      return 1
    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2
    default:
      return 0
  }
}
function DB(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : BB(sB(t))
}
function zs(t) {
  return Za(t) ? t : iE(t, !1, SB, PB, _N)
}
function hl(t) {
  return iE(t, !1, xB, RB, CN)
}
function IN(t) {
  return iE(t, !0, IB, kB, SN)
}
function iE(t, e, n, r, s) {
  if (!Pn(t) || (t.__v_raw && !(e && t.__v_isReactive))) return t
  const i = s.get(t)
  if (i) return i
  const o = DB(t)
  if (o === 0) return t
  const a = new Proxy(t, o === 2 ? r : n)
  return s.set(t, a), a
}
function Cl(t) {
  return Za(t) ? Cl(t.__v_raw) : !!(t && t.__v_isReactive)
}
function Za(t) {
  return !!(t && t.__v_isReadonly)
}
function Ni(t) {
  return !!(t && t.__v_isShallow)
}
function oE(t) {
  return t ? !!t.__v_raw : !1
}
function Zt(t) {
  const e = t && t.__v_raw
  return e ? Zt(e) : t
}
function MB(t) {
  return !tn(t, '__v_skip') && Object.isExtensible(t) && oN(t, '__v_skip', !0), t
}
const ss = t => (Pn(t) ? zs(t) : t),
  Qb = t => (Pn(t) ? IN(t) : t)
function Vn(t) {
  return t ? t.__v_isRef === !0 : !1
}
function wr(t) {
  return xN(t, !1)
}
function b_(t) {
  return xN(t, !0)
}
function xN(t, e) {
  return Vn(t) ? t : new UB(t, e)
}
class UB {
  constructor(e, n) {
    ;(this.dep = new nE()),
      (this.__v_isRef = !0),
      (this.__v_isShallow = !1),
      (this._rawValue = n ? e : Zt(e)),
      (this._value = n ? e : ss(e)),
      (this.__v_isShallow = n)
  }
  get value() {
    return this.dep.track(), this._value
  }
  set value(e) {
    const n = this._rawValue,
      r = this.__v_isShallow || Ni(e) || Za(e)
    ;(e = r ? e : Zt(e)),
      Fa(e, n) && ((this._rawValue = e), (this._value = r ? e : ss(e)), this.dep.trigger())
  }
}
function Qn(t) {
  return Vn(t) ? t.value : t
}
function LB(t) {
  return bt(t) ? t() : Qn(t)
}
const $B = {
  get: (t, e, n) => (e === '__v_raw' ? t : Qn(Reflect.get(t, e, n))),
  set: (t, e, n, r) => {
    const s = t[e]
    return Vn(s) && !Vn(n) ? ((s.value = n), !0) : Reflect.set(t, e, n, r)
  }
}
function TN(t) {
  return Cl(t) ? t : new Proxy(t, $B)
}
class FB {
  constructor(e, n, r) {
    ;(this._object = e),
      (this._key = n),
      (this._defaultValue = r),
      (this.__v_isRef = !0),
      (this._value = void 0)
  }
  get value() {
    const e = this._object[this._key]
    return (this._value = e === void 0 ? this._defaultValue : e)
  }
  set value(e) {
    this._object[this._key] = e
  }
  get dep() {
    return bB(Zt(this._object), this._key)
  }
}
class jB {
  constructor(e) {
    ;(this._getter = e), (this.__v_isRef = !0), (this.__v_isReadonly = !0), (this._value = void 0)
  }
  get value() {
    return (this._value = this._getter())
  }
}
function HB(t, e, n) {
  return Vn(t) ? t : bt(t) ? new jB(t) : Pn(t) && arguments.length > 1 ? qB(t, e, n) : wr(t)
}
function qB(t, e, n) {
  const r = t[e]
  return Vn(r) ? r : new FB(t, e, n)
}
class zB {
  constructor(e, n, r) {
    ;(this.fn = e),
      (this.setter = n),
      (this._value = void 0),
      (this.dep = new nE(this)),
      (this.__v_isRef = !0),
      (this.deps = void 0),
      (this.depsTail = void 0),
      (this.flags = 16),
      (this.globalVersion = Hh - 1),
      (this.next = void 0),
      (this.effect = this),
      (this.__v_isReadonly = !n),
      (this.isSSR = r)
  }
  notify() {
    if (((this.flags |= 16), !(this.flags & 8) && vn !== this)) return pN(this, !0), !0
  }
  get value() {
    const e = this.dep.track()
    return yN(this), e && (e.version = this.dep.version), this._value
  }
  set value(e) {
    this.setter && this.setter(e)
  }
}
function WB(t, e, n = !1) {
  let r, s
  return bt(t) ? (r = t) : ((r = t.get), (s = t.set)), new zB(r, s, n)
}
const Dp = {},
  Gg = new WeakMap()
let Sc
function KB(t, e = !1, n = Sc) {
  if (n) {
    let r = Gg.get(n)
    r || Gg.set(n, (r = [])), r.push(t)
  }
}
function VB(t, e, n = En) {
  const { immediate: r, deep: s, once: i, scheduler: o, augmentJob: a, call: c } = n,
    u = R => (s ? R : Ni(R) || s === !1 || s === 0 ? Sa(R, 1) : Sa(R))
  let l,
    d,
    h,
    p,
    y = !1,
    m = !1
  if (
    (Vn(t)
      ? ((d = () => t.value), (y = Ni(t)))
      : Cl(t)
        ? ((d = () => u(t)), (y = !0))
        : _t(t)
          ? ((m = !0),
            (y = t.some(R => Cl(R) || Ni(R))),
            (d = () =>
              t.map(R => {
                if (Vn(R)) return R.value
                if (Cl(R)) return u(R)
                if (bt(R)) return c ? c(R, 2) : R()
              })))
          : bt(t)
            ? e
              ? (d = c ? () => c(t, 2) : t)
              : (d = () => {
                  if (h) {
                    ac()
                    try {
                      h()
                    } finally {
                      cc()
                    }
                  }
                  const R = Sc
                  Sc = l
                  try {
                    return c ? c(t, 3, [p]) : t(p)
                  } finally {
                    Sc = R
                  }
                })
            : (d = eo),
    e && s)
  ) {
    const R = d,
      N = s === !0 ? 1 / 0 : s
    d = () => Sa(R(), N)
  }
  const b = dN(),
    I = () => {
      l.stop(), b && b.active && Yv(b.effects, l)
    }
  if (i && e) {
    const R = e
    e = (...N) => {
      R(...N), I()
    }
  }
  let x = m ? new Array(t.length).fill(Dp) : Dp
  const _ = R => {
    if (!(!(l.flags & 1) || (!l.dirty && !R)))
      if (e) {
        const N = l.run()
        if (s || y || (m ? N.some((T, M) => Fa(T, x[M])) : Fa(N, x))) {
          h && h()
          const T = Sc
          Sc = l
          try {
            const M = [N, x === Dp ? void 0 : m && x[0] === Dp ? [] : x, p]
            c ? c(e, 3, M) : e(...M), (x = N)
          } finally {
            Sc = T
          }
        }
      } else l.run()
  }
  return (
    a && a(_),
    (l = new hN(d)),
    (l.scheduler = o ? () => o(_, !1) : _),
    (p = R => KB(R, !1, l)),
    (h = l.onStop =
      () => {
        const R = Gg.get(l)
        if (R) {
          if (c) c(R, 4)
          else for (const N of R) N()
          Gg.delete(l)
        }
      }),
    e ? (r ? _(!0) : (x = l.run())) : o ? o(_.bind(null, !0), !0) : l.run(),
    (I.pause = l.pause.bind(l)),
    (I.resume = l.resume.bind(l)),
    (I.stop = I),
    I
  )
}
function Sa(t, e = 1 / 0, n) {
  if (e <= 0 || !Pn(t) || t.__v_skip || ((n = n || new Set()), n.has(t))) return t
  if ((n.add(t), e--, Vn(t))) Sa(t.value, e, n)
  else if (_t(t)) for (let r = 0; r < t.length; r++) Sa(t[r], e, n)
  else if (nN(t) || Al(t))
    t.forEach(r => {
      Sa(r, e, n)
    })
  else if (iN(t)) {
    for (const r in t) Sa(t[r], e, n)
    for (const r of Object.getOwnPropertySymbols(t))
      Object.prototype.propertyIsEnumerable.call(t, r) && Sa(t[r], e, n)
  }
  return t
}
/**
 * @vue/runtime-core v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function Xf(t, e, n, r) {
  try {
    return r ? t(...r) : t()
  } catch (s) {
    md(s, e, n)
  }
}
function ro(t, e, n, r) {
  if (bt(t)) {
    const s = Xf(t, e, n, r)
    return (
      s &&
        rN(s) &&
        s.catch(i => {
          md(i, e, n)
        }),
      s
    )
  }
  if (_t(t)) {
    const s = []
    for (let i = 0; i < t.length; i++) s.push(ro(t[i], e, n, r))
    return s
  }
}
function md(t, e, n, r = !0) {
  const s = e ? e.vnode : null,
    { errorHandler: i, throwUnhandledErrorInProduction: o } = (e && e.appContext.config) || En
  if (e) {
    let a = e.parent
    const c = e.proxy,
      u = `https://vuejs.org/error-reference/#runtime-${n}`
    for (; a; ) {
      const l = a.ec
      if (l) {
        for (let d = 0; d < l.length; d++) if (l[d](t, c, u) === !1) return
      }
      a = a.parent
    }
    if (i) {
      ac(), Xf(i, null, 10, [t, c, u]), cc()
      return
    }
  }
  GB(t, n, s, r, o)
}
function GB(t, e, n, r = !0, s = !1) {
  if (s) throw t
  console.error(t)
}
const is = []
let zi = -1
const Sl = []
let ba = null,
  il = 0
const NN = Promise.resolve()
let Qg = null
function aE(t) {
  const e = Qg || NN
  return t ? e.then(this ? t.bind(this) : t) : e
}
function QB(t) {
  let e = zi + 1,
    n = is.length
  for (; e < n; ) {
    const r = (e + n) >>> 1,
      s = is[r],
      i = zh(s)
    i < t || (i === t && s.flags & 2) ? (e = r + 1) : (n = r)
  }
  return e
}
function cE(t) {
  if (!(t.flags & 1)) {
    const e = zh(t),
      n = is[is.length - 1]
    !n || (!(t.flags & 2) && e >= zh(n)) ? is.push(t) : is.splice(QB(e), 0, t), (t.flags |= 1), PN()
  }
}
function PN() {
  Qg || (Qg = NN.then(RN))
}
function Zb(t) {
  _t(t)
    ? Sl.push(...t)
    : ba && t.id === -1
      ? ba.splice(il + 1, 0, t)
      : t.flags & 1 || (Sl.push(t), (t.flags |= 1)),
    PN()
}
function v_(t, e, n = zi + 1) {
  for (; n < is.length; n++) {
    const r = is[n]
    if (r && r.flags & 2) {
      if (t && r.id !== t.uid) continue
      is.splice(n, 1), n--, r.flags & 4 && (r.flags &= -2), r(), r.flags & 4 || (r.flags &= -2)
    }
  }
}
function Zg(t) {
  if (Sl.length) {
    const e = [...new Set(Sl)].sort((n, r) => zh(n) - zh(r))
    if (((Sl.length = 0), ba)) {
      ba.push(...e)
      return
    }
    for (ba = e, il = 0; il < ba.length; il++) {
      const n = ba[il]
      n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), (n.flags &= -2)
    }
    ;(ba = null), (il = 0)
  }
}
const zh = t => (t.id == null ? (t.flags & 2 ? -1 : 1 / 0) : t.id)
function RN(t) {
  try {
    for (zi = 0; zi < is.length; zi++) {
      const e = is[zi]
      e &&
        !(e.flags & 8) &&
        (e.flags & 4 && (e.flags &= -2), Xf(e, e.i, e.i ? 15 : 14), e.flags & 4 || (e.flags &= -2))
    }
  } finally {
    for (; zi < is.length; zi++) {
      const e = is[zi]
      e && (e.flags &= -2)
    }
    ;(zi = -1), (is.length = 0), Zg(), (Qg = null), (is.length || Sl.length) && RN()
  }
}
let Hs = null,
  kN = null
function Yg(t) {
  const e = Hs
  return (Hs = t), (kN = (t && t.type.__scopeId) || null), e
}
function uE(t, e = Hs, n) {
  if (!e || t._n) return t
  const r = (...s) => {
    r._d && B_(-1)
    const i = Yg(e)
    let o
    try {
      o = t(...s)
    } finally {
      Yg(i), r._d && B_(1)
    }
    return o
  }
  return (r._n = !0), (r._c = !0), (r._d = !0), r
}
function Vi(t, e, n, r) {
  const s = t.dirs,
    i = e && e.dirs
  for (let o = 0; o < s.length; o++) {
    const a = s[o]
    i && (a.oldValue = i[o].value)
    let c = a.dir[r]
    c && (ac(), ro(c, n, 8, [t.el, a, t, e]), cc())
  }
}
const ZB = Symbol('_vte'),
  YB = t => t.__isTeleport
function lE(t, e) {
  t.shapeFlag & 6 && t.component
    ? ((t.transition = e), lE(t.component.subTree, e))
    : t.shapeFlag & 128
      ? ((t.ssContent.transition = e.clone(t.ssContent)),
        (t.ssFallback.transition = e.clone(t.ssFallback)))
      : (t.transition = e)
}
/*! #__NO_SIDE_EFFECTS__ */ function n0(t, e) {
  return bt(t) ? Gr({ name: t.name }, e, { setup: t }) : t
}
function dE(t) {
  t.ids = [t.ids[0] + t.ids[2]++ + '-', 0, 0]
}
function Wh(t, e, n, r, s = !1) {
  if (_t(t)) {
    t.forEach((y, m) => Wh(y, e && (_t(e) ? e[m] : e), n, r, s))
    return
  }
  if (Il(r) && !s) {
    r.shapeFlag & 512 &&
      r.type.__asyncResolved &&
      r.component.subTree.component &&
      Wh(t, e, n, r.component.subTree)
    return
  }
  const i = r.shapeFlag & 4 ? bE(r.component) : r.el,
    o = s ? null : i,
    { i: a, r: c } = t,
    u = e && e.r,
    l = a.refs === En ? (a.refs = {}) : a.refs,
    d = a.setupState,
    h = Zt(d),
    p = d === En ? () => !1 : y => tn(h, y)
  if (
    (u != null &&
      u !== c &&
      (Hn(u) ? ((l[u] = null), p(u) && (d[u] = null)) : Vn(u) && (u.value = null)),
    bt(c))
  )
    Xf(c, a, 12, [o, l])
  else {
    const y = Hn(c),
      m = Vn(c)
    if (y || m) {
      const b = () => {
        if (t.f) {
          const I = y ? (p(c) ? d[c] : l[c]) : c.value
          s
            ? _t(I) && Yv(I, i)
            : _t(I)
              ? I.includes(i) || I.push(i)
              : y
                ? ((l[c] = [i]), p(c) && (d[c] = l[c]))
                : ((c.value = [i]), t.k && (l[t.k] = c.value))
        } else y ? ((l[c] = o), p(c) && (d[c] = o)) : m && ((c.value = o), t.k && (l[t.k] = o))
      }
      o ? ((b.id = -1), Rs(b, n)) : b()
    }
  }
}
let E_ = !1
const Uu = () => {
    E_ || (console.error('Hydration completed but contains mismatches.'), (E_ = !0))
  },
  JB = t => t.namespaceURI.includes('svg') && t.tagName !== 'foreignObject',
  XB = t => t.namespaceURI.includes('MathML'),
  Mp = t => {
    if (t.nodeType === 1) {
      if (JB(t)) return 'svg'
      if (XB(t)) return 'mathml'
    }
  },
  fl = t => t.nodeType === 8
function e6(t) {
  const {
      mt: e,
      p: n,
      o: {
        patchProp: r,
        createText: s,
        nextSibling: i,
        parentNode: o,
        remove: a,
        insert: c,
        createComment: u
      }
    } = t,
    l = (_, R) => {
      if (!R.hasChildNodes()) {
        n(null, _, R), Zg(), (R._vnode = _)
        return
      }
      d(R.firstChild, _, null, null, null), Zg(), (R._vnode = _)
    },
    d = (_, R, N, T, M, H = !1) => {
      H = H || !!R.dynamicChildren
      const B = fl(_) && _.data === '[',
        $ = () => m(_, R, N, T, M, B),
        { type: D, ref: W, shapeFlag: U, patchFlag: w } = R
      let v = _.nodeType
      ;(R.el = _), w === -2 && ((H = !1), (R.dynamicChildren = null))
      let A = null
      switch (D) {
        case Qc:
          v !== 3
            ? R.children === ''
              ? (c((R.el = s('')), o(_), _), (A = _))
              : (A = $())
            : (_.data !== R.children && (Uu(), (_.data = R.children)), (A = i(_)))
          break
        case so:
          x(_)
            ? ((A = i(_)), I((R.el = _.content.firstChild), _, N))
            : v !== 8 || B
              ? (A = $())
              : (A = i(_))
          break
        case xh:
          if ((B && ((_ = i(_)), (v = _.nodeType)), v === 1 || v === 3)) {
            A = _
            const P = !R.children.length
            for (let O = 0; O < R.staticCount; O++)
              P && (R.children += A.nodeType === 1 ? A.outerHTML : A.data),
                O === R.staticCount - 1 && (R.anchor = A),
                (A = i(A))
            return B ? i(A) : A
          } else $()
          break
        case Ai:
          B ? (A = y(_, R, N, T, M, H)) : (A = $())
          break
        default:
          if (U & 1)
            (v !== 1 || R.type.toLowerCase() !== _.tagName.toLowerCase()) && !x(_)
              ? (A = $())
              : (A = h(_, R, N, T, M, H))
          else if (U & 6) {
            R.slotScopeIds = M
            const P = o(_)
            if (
              (B
                ? (A = b(_))
                : fl(_) && _.data === 'teleport start'
                  ? (A = b(_, _.data, 'teleport end'))
                  : (A = i(_)),
              e(R, P, null, N, T, Mp(P), H),
              Il(R) && !R.type.__asyncResolved)
            ) {
              let O
              B
                ? ((O = An(Ai)), (O.anchor = A ? A.previousSibling : P.lastChild))
                : (O = _.nodeType === 3 ? hP('') : An('div')),
                (O.el = _),
                (R.component.subTree = O)
            }
          } else
            U & 64
              ? v !== 8
                ? (A = $())
                : (A = R.type.hydrate(_, R, N, T, M, H, t, p))
              : U & 128 && (A = R.type.hydrate(_, R, N, T, Mp(o(_)), M, H, t, d))
      }
      return W != null && Wh(W, null, T, R), A
    },
    h = (_, R, N, T, M, H) => {
      H = H || !!R.dynamicChildren
      const { type: B, props: $, patchFlag: D, shapeFlag: W, dirs: U, transition: w } = R,
        v = B === 'input' || B === 'option'
      if (v || D !== -1) {
        U && Vi(R, null, N, 'created')
        let A = !1
        if (x(_)) {
          A = eP(null, w) && N && N.vnode.props && N.vnode.props.appear
          const O = _.content.firstChild
          A && w.beforeEnter(O), I(O, _, N), (R.el = _ = O)
        }
        if (W & 16 && !($ && ($.innerHTML || $.textContent))) {
          let O = p(_.firstChild, R, _, N, T, M, H)
          for (; O; ) {
            Up(_, 1) || Uu()
            const F = O
            ;(O = O.nextSibling), a(F)
          }
        } else if (W & 8) {
          let O = R.children
          O[0] ===
            `
` &&
            (_.tagName === 'PRE' || _.tagName === 'TEXTAREA') &&
            (O = O.slice(1)),
            _.textContent !== O && (Up(_, 0) || Uu(), (_.textContent = R.children))
        }
        if ($) {
          if (v || !H || D & 48) {
            const O = _.tagName.includes('-')
            for (const F in $)
              ((v && (F.endsWith('value') || F === 'indeterminate')) ||
                (Jf(F) && !_l(F)) ||
                F[0] === '.' ||
                O) &&
                r(_, F, null, $[F], void 0, N)
          } else if ($.onClick) r(_, 'onClick', null, $.onClick, void 0, N)
          else if (D & 4 && Cl($.style)) for (const O in $.style) $.style[O]
        }
        let P
        ;(P = $ && $.onVnodeBeforeMount) && ei(P, N, R),
          U && Vi(R, null, N, 'beforeMount'),
          ((P = $ && $.onVnodeMounted) || U || A) &&
            aP(() => {
              P && ei(P, N, R), A && w.enter(_), U && Vi(R, null, N, 'mounted')
            }, T)
      }
      return _.nextSibling
    },
    p = (_, R, N, T, M, H, B) => {
      B = B || !!R.dynamicChildren
      const $ = R.children,
        D = $.length
      for (let W = 0; W < D; W++) {
        const U = B ? $[W] : ($[W] = Fs($[W])),
          w = U.type === Qc
        _
          ? (w &&
              !B &&
              W + 1 < D &&
              Fs($[W + 1]).type === Qc &&
              (c(s(_.data.slice(U.children.length)), N, i(_)), (_.data = U.children)),
            (_ = d(_, U, T, M, H, B)))
          : w && !U.children
            ? c((U.el = s('')), N)
            : (Up(N, 1) || Uu(), n(null, U, N, null, T, M, Mp(N), H))
      }
      return _
    },
    y = (_, R, N, T, M, H) => {
      const { slotScopeIds: B } = R
      B && (M = M ? M.concat(B) : B)
      const $ = o(_),
        D = p(i(_), R, $, N, T, M, H)
      return D && fl(D) && D.data === ']'
        ? i((R.anchor = D))
        : (Uu(), c((R.anchor = u(']')), $, D), D)
    },
    m = (_, R, N, T, M, H) => {
      if ((Up(_.parentElement, 1) || Uu(), (R.el = null), H)) {
        const D = b(_)
        for (;;) {
          const W = i(_)
          if (W && W !== D) a(W)
          else break
        }
      }
      const B = i(_),
        $ = o(_)
      return a(_), n(null, R, $, B, N, T, Mp($), M), N && ((N.vnode.el = R.el), i0(N, R.el)), B
    },
    b = (_, R = '[', N = ']') => {
      let T = 0
      for (; _; )
        if (((_ = i(_)), _ && fl(_) && (_.data === R && T++, _.data === N))) {
          if (T === 0) return i(_)
          T--
        }
      return _
    },
    I = (_, R, N) => {
      const T = R.parentNode
      T && T.replaceChild(_, R)
      let M = N
      for (; M; ) M.vnode.el === R && (M.vnode.el = M.subTree.el = _), (M = M.parent)
    },
    x = _ => _.nodeType === 1 && _.tagName === 'TEMPLATE'
  return [l, d]
}
const A_ = 'data-allow-mismatch',
  t6 = { 0: 'text', 1: 'children', 2: 'class', 3: 'style', 4: 'attribute' }
function Up(t, e) {
  if (e === 0 || e === 1) for (; t && !t.hasAttribute(A_); ) t = t.parentElement
  const n = t && t.getAttribute(A_)
  if (n == null) return !1
  if (n === '') return !0
  {
    const r = n.split(',')
    return e === 0 && r.includes('children') ? !0 : n.split(',').includes(t6[e])
  }
}
Xm().requestIdleCallback
Xm().cancelIdleCallback
function n6(t, e) {
  if (fl(t) && t.data === '[') {
    let n = 1,
      r = t.nextSibling
    for (; r; ) {
      if (r.nodeType === 1) {
        if (e(r) === !1) break
      } else if (fl(r))
        if (r.data === ']') {
          if (--n === 0) break
        } else r.data === '[' && n++
      r = r.nextSibling
    }
  } else e(t)
}
const Il = t => !!t.type.__asyncLoader
/*! #__NO_SIDE_EFFECTS__ */ function __(t) {
  bt(t) && (t = { loader: t })
  const {
    loader: e,
    loadingComponent: n,
    errorComponent: r,
    delay: s = 200,
    hydrate: i,
    timeout: o,
    suspensible: a = !0,
    onError: c
  } = t
  let u = null,
    l,
    d = 0
  const h = () => (d++, (u = null), p()),
    p = () => {
      let y
      return (
        u ||
        (y = u =
          e()
            .catch(m => {
              if (((m = m instanceof Error ? m : new Error(String(m))), c))
                return new Promise((b, I) => {
                  c(
                    m,
                    () => b(h()),
                    () => I(m),
                    d + 1
                  )
                })
              throw m
            })
            .then(m =>
              y !== u && u
                ? u
                : (m && (m.__esModule || m[Symbol.toStringTag] === 'Module') && (m = m.default),
                  (l = m),
                  m)
            ))
      )
    }
  return n0({
    name: 'AsyncComponentWrapper',
    __asyncLoader: p,
    __asyncHydrate(y, m, b) {
      const I = i
        ? () => {
            const x = i(b, _ => n6(y, _))
            x && (m.bum || (m.bum = [])).push(x)
          }
        : b
      l ? I() : p().then(() => !m.isUnmounted && I())
    },
    get __asyncResolved() {
      return l
    },
    setup() {
      const y = sr
      if ((dE(y), l)) return () => $y(l, y)
      const m = _ => {
        ;(u = null), md(_, y, 13, !r)
      }
      if ((a && y.suspense) || Gl)
        return p()
          .then(_ => () => $y(_, y))
          .catch(_ => (m(_), () => (r ? An(r, { error: _ }) : null)))
      const b = wr(!1),
        I = wr(),
        x = wr(!!s)
      return (
        s &&
          setTimeout(() => {
            x.value = !1
          }, s),
        o != null &&
          setTimeout(() => {
            if (!b.value && !I.value) {
              const _ = new Error(`Async component timed out after ${o}ms.`)
              m(_), (I.value = _)
            }
          }, o),
        p()
          .then(() => {
            ;(b.value = !0), y.parent && hE(y.parent.vnode) && y.parent.update()
          })
          .catch(_ => {
            m(_), (I.value = _)
          }),
        () => {
          if (b.value && l) return $y(l, y)
          if (I.value && r) return An(r, { error: I.value })
          if (n && !x.value) return An(n)
        }
      )
    }
  })
}
function $y(t, e) {
  const { ref: n, props: r, children: s, ce: i } = e.vnode,
    o = An(t, r, s)
  return (o.ref = n), (o.ce = i), delete e.vnode.ce, o
}
const hE = t => t.type.__isKeepAlive
function ON(t, e) {
  DN(t, 'a', e)
}
function BN(t, e) {
  DN(t, 'da', e)
}
function DN(t, e, n = sr) {
  const r =
    t.__wdc ||
    (t.__wdc = () => {
      let s = n
      for (; s; ) {
        if (s.isDeactivated) return
        s = s.parent
      }
      return t()
    })
  if ((r0(e, r, n), n)) {
    let s = n.parent
    for (; s && s.parent; ) hE(s.parent.vnode) && r6(r, e, n, s), (s = s.parent)
  }
}
function r6(t, e, n, r) {
  const s = r0(e, t, r, !0)
  uc(() => {
    Yv(r[e], s)
  }, n)
}
function r0(t, e, n = sr, r = !1) {
  if (n) {
    const s = n[t] || (n[t] = []),
      i =
        e.__weh ||
        (e.__weh = (...o) => {
          ac()
          const a = ep(n),
            c = ro(e, n, t, o)
          return a(), cc(), c
        })
    return r ? s.unshift(i) : s.push(i), i
  }
}
const ta =
    t =>
    (e, n = sr) => {
      ;(!Gl || t === 'sp') && r0(t, (...r) => e(...r), n)
    },
  s6 = ta('bm'),
  fE = ta('m'),
  i6 = ta('bu'),
  o6 = ta('u'),
  MN = ta('bum'),
  uc = ta('um'),
  a6 = ta('sp'),
  c6 = ta('rtg'),
  u6 = ta('rtc')
function UN(t, e = sr) {
  r0('ec', t, e)
}
const LN = 'components'
function C_(t, e) {
  return FN(LN, t, !0, e) || t
}
const $N = Symbol.for('v-ndc')
function l6(t) {
  return Hn(t) ? FN(LN, t, !1) || t : t || $N
}
function FN(t, e, n = !0, r = !1) {
  const s = Hs || sr
  if (s) {
    const i = s.type
    {
      const a = tD(i, !1)
      if (a && (a === e || a === ai(e) || a === Jm(ai(e)))) return i
    }
    const o = S_(s[t] || i[t], e) || S_(s.appContext[t], e)
    return !o && r ? i : o
  }
}
function S_(t, e) {
  return t && (t[e] || t[ai(e)] || t[Jm(ai(e))])
}
const Yb = t => (t ? (pP(t) ? bE(t) : Yb(t.parent)) : null),
  Ih = Gr(Object.create(null), {
    $: t => t,
    $el: t => t.vnode.el,
    $data: t => t.data,
    $props: t => t.props,
    $attrs: t => t.attrs,
    $slots: t => t.slots,
    $refs: t => t.refs,
    $parent: t => Yb(t.parent),
    $root: t => Yb(t.root),
    $host: t => t.ce,
    $emit: t => t.emit,
    $options: t => HN(t),
    $forceUpdate: t =>
      t.f ||
      (t.f = () => {
        cE(t.update)
      }),
    $nextTick: t => t.n || (t.n = aE.bind(t.proxy)),
    $watch: t => R6.bind(t)
  }),
  Fy = (t, e) => t !== En && !t.__isScriptSetup && tn(t, e),
  d6 = {
    get({ _: t }, e) {
      if (e === '__v_skip') return !0
      const { ctx: n, setupState: r, data: s, props: i, accessCache: o, type: a, appContext: c } = t
      let u
      if (e[0] !== '$') {
        const p = o[e]
        if (p !== void 0)
          switch (p) {
            case 1:
              return r[e]
            case 2:
              return s[e]
            case 4:
              return n[e]
            case 3:
              return i[e]
          }
        else {
          if (Fy(r, e)) return (o[e] = 1), r[e]
          if (s !== En && tn(s, e)) return (o[e] = 2), s[e]
          if ((u = t.propsOptions[0]) && tn(u, e)) return (o[e] = 3), i[e]
          if (n !== En && tn(n, e)) return (o[e] = 4), n[e]
          Jb && (o[e] = 0)
        }
      }
      const l = Ih[e]
      let d, h
      if (l) return e === '$attrs' && Wr(t.attrs, 'get', ''), l(t)
      if ((d = a.__cssModules) && (d = d[e])) return d
      if (n !== En && tn(n, e)) return (o[e] = 4), n[e]
      if (((h = c.config.globalProperties), tn(h, e))) return h[e]
    },
    set({ _: t }, e, n) {
      const { data: r, setupState: s, ctx: i } = t
      return Fy(s, e)
        ? ((s[e] = n), !0)
        : r !== En && tn(r, e)
          ? ((r[e] = n), !0)
          : tn(t.props, e) || (e[0] === '$' && e.slice(1) in t)
            ? !1
            : ((i[e] = n), !0)
    },
    has(
      { _: { data: t, setupState: e, accessCache: n, ctx: r, appContext: s, propsOptions: i } },
      o
    ) {
      let a
      return (
        !!n[o] ||
        (t !== En && tn(t, o)) ||
        Fy(e, o) ||
        ((a = i[0]) && tn(a, o)) ||
        tn(r, o) ||
        tn(Ih, o) ||
        tn(s.config.globalProperties, o)
      )
    },
    defineProperty(t, e, n) {
      return (
        n.get != null ? (t._.accessCache[e] = 0) : tn(n, 'value') && this.set(t, e, n.value, null),
        Reflect.defineProperty(t, e, n)
      )
    }
  }
function I_(t) {
  return _t(t) ? t.reduce((e, n) => ((e[n] = null), e), {}) : t
}
let Jb = !0
function h6(t) {
  const e = HN(t),
    n = t.proxy,
    r = t.ctx
  ;(Jb = !1), e.beforeCreate && x_(e.beforeCreate, t, 'bc')
  const {
    data: s,
    computed: i,
    methods: o,
    watch: a,
    provide: c,
    inject: u,
    created: l,
    beforeMount: d,
    mounted: h,
    beforeUpdate: p,
    updated: y,
    activated: m,
    deactivated: b,
    beforeDestroy: I,
    beforeUnmount: x,
    destroyed: _,
    unmounted: R,
    render: N,
    renderTracked: T,
    renderTriggered: M,
    errorCaptured: H,
    serverPrefetch: B,
    expose: $,
    inheritAttrs: D,
    components: W,
    directives: U,
    filters: w
  } = e
  if ((u && f6(u, r, null), o))
    for (const P in o) {
      const O = o[P]
      bt(O) && (r[P] = O.bind(n))
    }
  if (s) {
    const P = s.call(n, n)
    Pn(P) && (t.data = zs(P))
  }
  if (((Jb = !0), i))
    for (const P in i) {
      const O = i[P],
        F = bt(O) ? O.bind(n, n) : bt(O.get) ? O.get.bind(n, n) : eo,
        z = !bt(O) && bt(O.set) ? O.set.bind(n) : eo,
        j = mP({ get: F, set: z })
      Object.defineProperty(r, P, {
        enumerable: !0,
        configurable: !0,
        get: () => j.value,
        set: E => (j.value = E)
      })
    }
  if (a) for (const P in a) jN(a[P], r, n, P)
  if (c) {
    const P = bt(c) ? c.call(n) : c
    Reflect.ownKeys(P).forEach(O => {
      pE(O, P[O])
    })
  }
  l && x_(l, t, 'c')
  function A(P, O) {
    _t(O) ? O.forEach(F => P(F.bind(n))) : O && P(O.bind(n))
  }
  if (
    (A(s6, d),
    A(fE, h),
    A(i6, p),
    A(o6, y),
    A(ON, m),
    A(BN, b),
    A(UN, H),
    A(u6, T),
    A(c6, M),
    A(MN, x),
    A(uc, R),
    A(a6, B),
    _t($))
  )
    if ($.length) {
      const P = t.exposed || (t.exposed = {})
      $.forEach(O => {
        Object.defineProperty(P, O, { get: () => n[O], set: F => (n[O] = F) })
      })
    } else t.exposed || (t.exposed = {})
  N && t.render === eo && (t.render = N),
    D != null && (t.inheritAttrs = D),
    W && (t.components = W),
    U && (t.directives = U),
    B && dE(t)
}
function f6(t, e, n = eo) {
  _t(t) && (t = Xb(t))
  for (const r in t) {
    const s = t[r]
    let i
    Pn(s)
      ? 'default' in s
        ? (i = xl(s.from || r, s.default, !0))
        : (i = xl(s.from || r))
      : (i = xl(s)),
      Vn(i)
        ? Object.defineProperty(e, r, {
            enumerable: !0,
            configurable: !0,
            get: () => i.value,
            set: o => (i.value = o)
          })
        : (e[r] = i)
  }
}
function x_(t, e, n) {
  ro(_t(t) ? t.map(r => r.bind(e.proxy)) : t.bind(e.proxy), e, n)
}
function jN(t, e, n, r) {
  let s = r.includes('.') ? rP(n, r) : () => n[r]
  if (Hn(t)) {
    const i = e[t]
    bt(i) && Hy(s, i)
  } else if (bt(t)) Hy(s, t.bind(n))
  else if (Pn(t))
    if (_t(t)) t.forEach(i => jN(i, e, n, r))
    else {
      const i = bt(t.handler) ? t.handler.bind(n) : e[t.handler]
      bt(i) && Hy(s, i, t)
    }
}
function HN(t) {
  const e = t.type,
    { mixins: n, extends: r } = e,
    {
      mixins: s,
      optionsCache: i,
      config: { optionMergeStrategies: o }
    } = t.appContext,
    a = i.get(e)
  let c
  return (
    a
      ? (c = a)
      : !s.length && !n && !r
        ? (c = e)
        : ((c = {}), s.length && s.forEach(u => Jg(c, u, o, !0)), Jg(c, e, o)),
    Pn(e) && i.set(e, c),
    c
  )
}
function Jg(t, e, n, r = !1) {
  const { mixins: s, extends: i } = e
  i && Jg(t, i, n, !0), s && s.forEach(o => Jg(t, o, n, !0))
  for (const o in e)
    if (!(r && o === 'expose')) {
      const a = p6[o] || (n && n[o])
      t[o] = a ? a(t[o], e[o]) : e[o]
    }
  return t
}
const p6 = {
  data: T_,
  props: N_,
  emits: N_,
  methods: gh,
  computed: gh,
  beforeCreate: ts,
  created: ts,
  beforeMount: ts,
  mounted: ts,
  beforeUpdate: ts,
  updated: ts,
  beforeDestroy: ts,
  beforeUnmount: ts,
  destroyed: ts,
  unmounted: ts,
  activated: ts,
  deactivated: ts,
  errorCaptured: ts,
  serverPrefetch: ts,
  components: gh,
  directives: gh,
  watch: m6,
  provide: T_,
  inject: g6
}
function T_(t, e) {
  return e
    ? t
      ? function () {
          return Gr(bt(t) ? t.call(this, this) : t, bt(e) ? e.call(this, this) : e)
        }
      : e
    : t
}
function g6(t, e) {
  return gh(Xb(t), Xb(e))
}
function Xb(t) {
  if (_t(t)) {
    const e = {}
    for (let n = 0; n < t.length; n++) e[t[n]] = t[n]
    return e
  }
  return t
}
function ts(t, e) {
  return t ? [...new Set([].concat(t, e))] : e
}
function gh(t, e) {
  return t ? Gr(Object.create(null), t, e) : e
}
function N_(t, e) {
  return t
    ? _t(t) && _t(e)
      ? [...new Set([...t, ...e])]
      : Gr(Object.create(null), I_(t), I_(e ?? {}))
    : e
}
function m6(t, e) {
  if (!t) return e
  if (!e) return t
  const n = Gr(Object.create(null), t)
  for (const r in e) n[r] = ts(t[r], e[r])
  return n
}
function qN() {
  return {
    app: null,
    config: {
      isNativeTag: nB,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  }
}
let y6 = 0
function w6(t, e) {
  return function (r, s = null) {
    bt(r) || (r = Gr({}, r)), s != null && !Pn(s) && (s = null)
    const i = qN(),
      o = new WeakSet(),
      a = []
    let c = !1
    const u = (i.app = {
      _uid: y6++,
      _component: r,
      _props: s,
      _container: null,
      _context: i,
      _instance: null,
      version: sD,
      get config() {
        return i.config
      },
      set config(l) {},
      use(l, ...d) {
        return (
          o.has(l) ||
            (l && bt(l.install) ? (o.add(l), l.install(u, ...d)) : bt(l) && (o.add(l), l(u, ...d))),
          u
        )
      },
      mixin(l) {
        return i.mixins.includes(l) || i.mixins.push(l), u
      },
      component(l, d) {
        return d ? ((i.components[l] = d), u) : i.components[l]
      },
      directive(l, d) {
        return d ? ((i.directives[l] = d), u) : i.directives[l]
      },
      mount(l, d, h) {
        if (!c) {
          const p = u._ceVNode || An(r, s)
          return (
            (p.appContext = i),
            h === !0 ? (h = 'svg') : h === !1 && (h = void 0),
            d && e ? e(p, l) : t(p, l, h),
            (c = !0),
            (u._container = l),
            (l.__vue_app__ = u),
            bE(p.component)
          )
        }
      },
      onUnmount(l) {
        a.push(l)
      },
      unmount() {
        c && (ro(a, u._instance, 16), t(null, u._container), delete u._container.__vue_app__)
      },
      provide(l, d) {
        return (i.provides[l] = d), u
      },
      runWithContext(l) {
        const d = Gc
        Gc = u
        try {
          return l()
        } finally {
          Gc = d
        }
      }
    })
    return u
  }
}
let Gc = null
function pE(t, e) {
  if (sr) {
    let n = sr.provides
    const r = sr.parent && sr.parent.provides
    r === n && (n = sr.provides = Object.create(r)), (n[t] = e)
  }
}
function xl(t, e, n = !1) {
  const r = sr || Hs
  if (r || Gc) {
    const s = Gc
      ? Gc._context.provides
      : r
        ? r.parent == null
          ? r.vnode.appContext && r.vnode.appContext.provides
          : r.parent.provides
        : void 0
    if (s && t in s) return s[t]
    if (arguments.length > 1) return n && bt(e) ? e.call(r && r.proxy) : e
  }
}
function gE() {
  return !!(sr || Hs || Gc)
}
const zN = {},
  WN = () => Object.create(zN),
  KN = t => Object.getPrototypeOf(t) === zN
function b6(t, e, n, r = !1) {
  const s = {},
    i = WN()
  ;(t.propsDefaults = Object.create(null)), VN(t, e, s, i)
  for (const o in t.propsOptions[0]) o in s || (s[o] = void 0)
  n ? (t.props = r ? s : hl(s)) : t.type.props ? (t.props = s) : (t.props = i), (t.attrs = i)
}
function v6(t, e, n, r) {
  const {
      props: s,
      attrs: i,
      vnode: { patchFlag: o }
    } = t,
    a = Zt(s),
    [c] = t.propsOptions
  let u = !1
  if ((r || o > 0) && !(o & 16)) {
    if (o & 8) {
      const l = t.vnode.dynamicProps
      for (let d = 0; d < l.length; d++) {
        let h = l[d]
        if (s0(t.emitsOptions, h)) continue
        const p = e[h]
        if (c)
          if (tn(i, h)) p !== i[h] && ((i[h] = p), (u = !0))
          else {
            const y = ai(h)
            s[y] = e1(c, a, y, p, t, !1)
          }
        else p !== i[h] && ((i[h] = p), (u = !0))
      }
    }
  } else {
    VN(t, e, s, i) && (u = !0)
    let l
    for (const d in a)
      (!e || (!tn(e, d) && ((l = Au(d)) === d || !tn(e, l)))) &&
        (c
          ? n && (n[d] !== void 0 || n[l] !== void 0) && (s[d] = e1(c, a, d, void 0, t, !0))
          : delete s[d])
    if (i !== a) for (const d in i) (!e || !tn(e, d)) && (delete i[d], (u = !0))
  }
  u && $o(t.attrs, 'set', '')
}
function VN(t, e, n, r) {
  const [s, i] = t.propsOptions
  let o = !1,
    a
  if (e)
    for (let c in e) {
      if (_l(c)) continue
      const u = e[c]
      let l
      s && tn(s, (l = ai(c)))
        ? !i || !i.includes(l)
          ? (n[l] = u)
          : ((a || (a = {}))[l] = u)
        : s0(t.emitsOptions, c) || ((!(c in r) || u !== r[c]) && ((r[c] = u), (o = !0)))
    }
  if (i) {
    const c = Zt(n),
      u = a || En
    for (let l = 0; l < i.length; l++) {
      const d = i[l]
      n[d] = e1(s, c, d, u[d], t, !tn(u, d))
    }
  }
  return o
}
function e1(t, e, n, r, s, i) {
  const o = t[n]
  if (o != null) {
    const a = tn(o, 'default')
    if (a && r === void 0) {
      const c = o.default
      if (o.type !== Function && !o.skipFactory && bt(c)) {
        const { propsDefaults: u } = s
        if (n in u) r = u[n]
        else {
          const l = ep(s)
          ;(r = u[n] = c.call(null, e)), l()
        }
      } else r = c
      s.ce && s.ce._setProp(n, r)
    }
    o[0] && (i && !a ? (r = !1) : o[1] && (r === '' || r === Au(n)) && (r = !0))
  }
  return r
}
const E6 = new WeakMap()
function GN(t, e, n = !1) {
  const r = n ? E6 : e.propsCache,
    s = r.get(t)
  if (s) return s
  const i = t.props,
    o = {},
    a = []
  let c = !1
  if (!bt(t)) {
    const l = d => {
      c = !0
      const [h, p] = GN(d, e, !0)
      Gr(o, h), p && a.push(...p)
    }
    !n && e.mixins.length && e.mixins.forEach(l),
      t.extends && l(t.extends),
      t.mixins && t.mixins.forEach(l)
  }
  if (!i && !c) return Pn(t) && r.set(t, El), El
  if (_t(i))
    for (let l = 0; l < i.length; l++) {
      const d = ai(i[l])
      P_(d) && (o[d] = En)
    }
  else if (i)
    for (const l in i) {
      const d = ai(l)
      if (P_(d)) {
        const h = i[l],
          p = (o[d] = _t(h) || bt(h) ? { type: h } : Gr({}, h)),
          y = p.type
        let m = !1,
          b = !0
        if (_t(y))
          for (let I = 0; I < y.length; ++I) {
            const x = y[I],
              _ = bt(x) && x.name
            if (_ === 'Boolean') {
              m = !0
              break
            } else _ === 'String' && (b = !1)
          }
        else m = bt(y) && y.name === 'Boolean'
        ;(p[0] = m), (p[1] = b), (m || tn(p, 'default')) && a.push(d)
      }
    }
  const u = [o, a]
  return Pn(t) && r.set(t, u), u
}
function P_(t) {
  return t[0] !== '$' && !_l(t)
}
const QN = t => t[0] === '_' || t === '$stable',
  mE = t => (_t(t) ? t.map(Fs) : [Fs(t)]),
  A6 = (t, e, n) => {
    if (e._n) return e
    const r = uE((...s) => mE(e(...s)), n)
    return (r._c = !1), r
  },
  ZN = (t, e, n) => {
    const r = t._ctx
    for (const s in t) {
      if (QN(s)) continue
      const i = t[s]
      if (bt(i)) e[s] = A6(s, i, r)
      else if (i != null) {
        const o = mE(i)
        e[s] = () => o
      }
    }
  },
  YN = (t, e) => {
    const n = mE(e)
    t.slots.default = () => n
  },
  JN = (t, e, n) => {
    for (const r in e) (n || r !== '_') && (t[r] = e[r])
  },
  _6 = (t, e, n) => {
    const r = (t.slots = WN())
    if (t.vnode.shapeFlag & 32) {
      const s = e._
      s ? (JN(r, e, n), n && oN(r, '_', s, !0)) : ZN(e, r)
    } else e && YN(t, e)
  },
  C6 = (t, e, n) => {
    const { vnode: r, slots: s } = t
    let i = !0,
      o = En
    if (r.shapeFlag & 32) {
      const a = e._
      a ? (n && a === 1 ? (i = !1) : JN(s, e, n)) : ((i = !e.$stable), ZN(e, s)), (o = e)
    } else e && (YN(t, e), (o = { default: 1 }))
    if (i) for (const a in s) !QN(a) && o[a] == null && delete s[a]
  },
  Rs = aP
function S6(t) {
  return XN(t)
}
function I6(t) {
  return XN(t, e6)
}
function XN(t, e) {
  const n = Xm()
  n.__VUE__ = !0
  const {
      insert: r,
      remove: s,
      patchProp: i,
      createElement: o,
      createText: a,
      createComment: c,
      setText: u,
      setElementText: l,
      parentNode: d,
      nextSibling: h,
      setScopeId: p = eo,
      insertStaticContent: y
    } = t,
    m = (
      Z,
      X,
      ie,
      be = null,
      ue = null,
      de = null,
      Te = void 0,
      we = null,
      ge = !!X.dynamicChildren
    ) => {
      if (Z === X) return
      Z && !xa(Z, X) && ((be = oe(Z)), E(Z, ue, de, !0), (Z = null)),
        X.patchFlag === -2 && ((ge = !1), (X.dynamicChildren = null))
      const { type: he, ref: Ne, shapeFlag: _e } = X
      switch (he) {
        case Qc:
          b(Z, X, ie, be)
          break
        case so:
          I(Z, X, ie, be)
          break
        case xh:
          Z == null && x(X, ie, be, Te)
          break
        case Ai:
          W(Z, X, ie, be, ue, de, Te, we, ge)
          break
        default:
          _e & 1
            ? N(Z, X, ie, be, ue, de, Te, we, ge)
            : _e & 6
              ? U(Z, X, ie, be, ue, de, Te, we, ge)
              : (_e & 64 || _e & 128) && he.process(Z, X, ie, be, ue, de, Te, we, ge, tt)
      }
      Ne != null && ue && Wh(Ne, Z && Z.ref, de, X || Z, !X)
    },
    b = (Z, X, ie, be) => {
      if (Z == null) r((X.el = a(X.children)), ie, be)
      else {
        const ue = (X.el = Z.el)
        X.children !== Z.children && u(ue, X.children)
      }
    },
    I = (Z, X, ie, be) => {
      Z == null ? r((X.el = c(X.children || '')), ie, be) : (X.el = Z.el)
    },
    x = (Z, X, ie, be) => {
      ;[Z.el, Z.anchor] = y(Z.children, X, ie, be, Z.el, Z.anchor)
    },
    _ = ({ el: Z, anchor: X }, ie, be) => {
      let ue
      for (; Z && Z !== X; ) (ue = h(Z)), r(Z, ie, be), (Z = ue)
      r(X, ie, be)
    },
    R = ({ el: Z, anchor: X }) => {
      let ie
      for (; Z && Z !== X; ) (ie = h(Z)), s(Z), (Z = ie)
      s(X)
    },
    N = (Z, X, ie, be, ue, de, Te, we, ge) => {
      X.type === 'svg' ? (Te = 'svg') : X.type === 'math' && (Te = 'mathml'),
        Z == null ? T(X, ie, be, ue, de, Te, we, ge) : B(Z, X, ue, de, Te, we, ge)
    },
    T = (Z, X, ie, be, ue, de, Te, we) => {
      let ge, he
      const { props: Ne, shapeFlag: _e, transition: Be, dirs: $e } = Z
      if (
        ((ge = Z.el = o(Z.type, de, Ne && Ne.is, Ne)),
        _e & 8 ? l(ge, Z.children) : _e & 16 && H(Z.children, ge, null, be, ue, jy(Z, de), Te, we),
        $e && Vi(Z, null, be, 'created'),
        M(ge, Z, Z.scopeId, Te, be),
        Ne)
      ) {
        for (const f in Ne) f !== 'value' && !_l(f) && i(ge, f, null, Ne[f], de, be)
        'value' in Ne && i(ge, 'value', null, Ne.value, de),
          (he = Ne.onVnodeBeforeMount) && ei(he, be, Z)
      }
      $e && Vi(Z, null, be, 'beforeMount')
      const S = eP(ue, Be)
      S && Be.beforeEnter(ge),
        r(ge, X, ie),
        ((he = Ne && Ne.onVnodeMounted) || S || $e) &&
          Rs(() => {
            he && ei(he, be, Z), S && Be.enter(ge), $e && Vi(Z, null, be, 'mounted')
          }, ue)
    },
    M = (Z, X, ie, be, ue) => {
      if ((ie && p(Z, ie), be)) for (let de = 0; de < be.length; de++) p(Z, be[de])
      if (ue) {
        let de = ue.subTree
        if (X === de || (iP(de.type) && (de.ssContent === X || de.ssFallback === X))) {
          const Te = ue.vnode
          M(Z, Te, Te.scopeId, Te.slotScopeIds, ue.parent)
        }
      }
    },
    H = (Z, X, ie, be, ue, de, Te, we, ge = 0) => {
      for (let he = ge; he < Z.length; he++) {
        const Ne = (Z[he] = we ? va(Z[he]) : Fs(Z[he]))
        m(null, Ne, X, ie, be, ue, de, Te, we)
      }
    },
    B = (Z, X, ie, be, ue, de, Te) => {
      const we = (X.el = Z.el)
      let { patchFlag: ge, dynamicChildren: he, dirs: Ne } = X
      ge |= Z.patchFlag & 16
      const _e = Z.props || En,
        Be = X.props || En
      let $e
      if (
        (ie && fc(ie, !1),
        ($e = Be.onVnodeBeforeUpdate) && ei($e, ie, X, Z),
        Ne && Vi(X, Z, ie, 'beforeUpdate'),
        ie && fc(ie, !0),
        ((_e.innerHTML && Be.innerHTML == null) || (_e.textContent && Be.textContent == null)) &&
          l(we, ''),
        he
          ? $(Z.dynamicChildren, he, we, ie, be, jy(X, ue), de)
          : Te || O(Z, X, we, null, ie, be, jy(X, ue), de, !1),
        ge > 0)
      ) {
        if (ge & 16) D(we, _e, Be, ie, ue)
        else if (
          (ge & 2 && _e.class !== Be.class && i(we, 'class', null, Be.class, ue),
          ge & 4 && i(we, 'style', _e.style, Be.style, ue),
          ge & 8)
        ) {
          const S = X.dynamicProps
          for (let f = 0; f < S.length; f++) {
            const g = S[f],
              k = _e[g],
              q = Be[g]
            ;(q !== k || g === 'value') && i(we, g, k, q, ue, ie)
          }
        }
        ge & 1 && Z.children !== X.children && l(we, X.children)
      } else !Te && he == null && D(we, _e, Be, ie, ue)
      ;(($e = Be.onVnodeUpdated) || Ne) &&
        Rs(() => {
          $e && ei($e, ie, X, Z), Ne && Vi(X, Z, ie, 'updated')
        }, be)
    },
    $ = (Z, X, ie, be, ue, de, Te) => {
      for (let we = 0; we < X.length; we++) {
        const ge = Z[we],
          he = X[we],
          Ne = ge.el && (ge.type === Ai || !xa(ge, he) || ge.shapeFlag & 70) ? d(ge.el) : ie
        m(ge, he, Ne, null, be, ue, de, Te, !0)
      }
    },
    D = (Z, X, ie, be, ue) => {
      if (X !== ie) {
        if (X !== En) for (const de in X) !_l(de) && !(de in ie) && i(Z, de, X[de], null, ue, be)
        for (const de in ie) {
          if (_l(de)) continue
          const Te = ie[de],
            we = X[de]
          Te !== we && de !== 'value' && i(Z, de, we, Te, ue, be)
        }
        'value' in ie && i(Z, 'value', X.value, ie.value, ue)
      }
    },
    W = (Z, X, ie, be, ue, de, Te, we, ge) => {
      const he = (X.el = Z ? Z.el : a('')),
        Ne = (X.anchor = Z ? Z.anchor : a(''))
      let { patchFlag: _e, dynamicChildren: Be, slotScopeIds: $e } = X
      $e && (we = we ? we.concat($e) : $e),
        Z == null
          ? (r(he, ie, be), r(Ne, ie, be), H(X.children || [], ie, Ne, ue, de, Te, we, ge))
          : _e > 0 && _e & 64 && Be && Z.dynamicChildren
            ? ($(Z.dynamicChildren, Be, ie, ue, de, Te, we),
              (X.key != null || (ue && X === ue.subTree)) && tP(Z, X, !0))
            : O(Z, X, ie, Ne, ue, de, Te, we, ge)
    },
    U = (Z, X, ie, be, ue, de, Te, we, ge) => {
      ;(X.slotScopeIds = we),
        Z == null
          ? X.shapeFlag & 512
            ? ue.ctx.activate(X, ie, be, Te, ge)
            : w(X, ie, be, ue, de, Te, ge)
          : v(Z, X, ge)
    },
    w = (Z, X, ie, be, ue, de, Te) => {
      const we = (Z.component = Z6(Z, be, ue))
      if ((hE(Z) && (we.ctx.renderer = tt), Y6(we, !1, Te), we.asyncDep)) {
        if ((ue && ue.registerDep(we, A, Te), !Z.el)) {
          const ge = (we.subTree = An(so))
          I(null, ge, X, ie)
        }
      } else A(we, Z, X, ie, ue, de, Te)
    },
    v = (Z, X, ie) => {
      const be = (X.component = Z.component)
      if (U6(Z, X, ie))
        if (be.asyncDep && !be.asyncResolved) {
          P(be, X, ie)
          return
        } else (be.next = X), be.update()
      else (X.el = Z.el), (be.vnode = X)
    },
    A = (Z, X, ie, be, ue, de, Te) => {
      const we = () => {
        if (Z.isMounted) {
          let { next: _e, bu: Be, u: $e, parent: S, vnode: f } = Z
          {
            const Y = nP(Z)
            if (Y) {
              _e && ((_e.el = f.el), P(Z, _e, Te)),
                Y.asyncDep.then(() => {
                  Z.isUnmounted || we()
                })
              return
            }
          }
          let g = _e,
            k
          fc(Z, !1),
            _e ? ((_e.el = f.el), P(Z, _e, Te)) : (_e = f),
            Be && By(Be),
            (k = _e.props && _e.props.onVnodeBeforeUpdate) && ei(k, S, _e, f),
            fc(Z, !0)
          const q = qy(Z),
            V = Z.subTree
          ;(Z.subTree = q),
            m(V, q, d(V.el), oe(V), Z, ue, de),
            (_e.el = q.el),
            g === null && i0(Z, q.el),
            $e && Rs($e, ue),
            (k = _e.props && _e.props.onVnodeUpdated) && Rs(() => ei(k, S, _e, f), ue)
        } else {
          let _e
          const { el: Be, props: $e } = X,
            { bm: S, m: f, parent: g, root: k, type: q } = Z,
            V = Il(X)
          if (
            (fc(Z, !1),
            S && By(S),
            !V && (_e = $e && $e.onVnodeBeforeMount) && ei(_e, g, X),
            fc(Z, !0),
            Be && nt)
          ) {
            const Y = () => {
              ;(Z.subTree = qy(Z)), nt(Be, Z.subTree, Z, ue, null)
            }
            V && q.__asyncHydrate ? q.__asyncHydrate(Be, Z, Y) : Y()
          } else {
            k.ce && k.ce._injectChildStyle(q)
            const Y = (Z.subTree = qy(Z))
            m(null, Y, ie, be, Z, ue, de), (X.el = Y.el)
          }
          if ((f && Rs(f, ue), !V && (_e = $e && $e.onVnodeMounted))) {
            const Y = X
            Rs(() => ei(_e, g, Y), ue)
          }
          ;(X.shapeFlag & 256 || (g && Il(g.vnode) && g.vnode.shapeFlag & 256)) &&
            Z.a &&
            Rs(Z.a, ue),
            (Z.isMounted = !0),
            (X = ie = be = null)
        }
      }
      Z.scope.on()
      const ge = (Z.effect = new hN(we))
      Z.scope.off()
      const he = (Z.update = ge.run.bind(ge)),
        Ne = (Z.job = ge.runIfDirty.bind(ge))
      ;(Ne.i = Z), (Ne.id = Z.uid), (ge.scheduler = () => cE(Ne)), fc(Z, !0), he()
    },
    P = (Z, X, ie) => {
      X.component = Z
      const be = Z.vnode.props
      ;(Z.vnode = X),
        (Z.next = null),
        v6(Z, X.props, be, ie),
        C6(Z, X.children, ie),
        ac(),
        v_(Z),
        cc()
    },
    O = (Z, X, ie, be, ue, de, Te, we, ge = !1) => {
      const he = Z && Z.children,
        Ne = Z ? Z.shapeFlag : 0,
        _e = X.children,
        { patchFlag: Be, shapeFlag: $e } = X
      if (Be > 0) {
        if (Be & 128) {
          z(he, _e, ie, be, ue, de, Te, we, ge)
          return
        } else if (Be & 256) {
          F(he, _e, ie, be, ue, de, Te, we, ge)
          return
        }
      }
      $e & 8
        ? (Ne & 16 && ee(he, ue, de), _e !== he && l(ie, _e))
        : Ne & 16
          ? $e & 16
            ? z(he, _e, ie, be, ue, de, Te, we, ge)
            : ee(he, ue, de, !0)
          : (Ne & 8 && l(ie, ''), $e & 16 && H(_e, ie, be, ue, de, Te, we, ge))
    },
    F = (Z, X, ie, be, ue, de, Te, we, ge) => {
      ;(Z = Z || El), (X = X || El)
      const he = Z.length,
        Ne = X.length,
        _e = Math.min(he, Ne)
      let Be
      for (Be = 0; Be < _e; Be++) {
        const $e = (X[Be] = ge ? va(X[Be]) : Fs(X[Be]))
        m(Z[Be], $e, ie, null, ue, de, Te, we, ge)
      }
      he > Ne ? ee(Z, ue, de, !0, !1, _e) : H(X, ie, be, ue, de, Te, we, ge, _e)
    },
    z = (Z, X, ie, be, ue, de, Te, we, ge) => {
      let he = 0
      const Ne = X.length
      let _e = Z.length - 1,
        Be = Ne - 1
      for (; he <= _e && he <= Be; ) {
        const $e = Z[he],
          S = (X[he] = ge ? va(X[he]) : Fs(X[he]))
        if (xa($e, S)) m($e, S, ie, null, ue, de, Te, we, ge)
        else break
        he++
      }
      for (; he <= _e && he <= Be; ) {
        const $e = Z[_e],
          S = (X[Be] = ge ? va(X[Be]) : Fs(X[Be]))
        if (xa($e, S)) m($e, S, ie, null, ue, de, Te, we, ge)
        else break
        _e--, Be--
      }
      if (he > _e) {
        if (he <= Be) {
          const $e = Be + 1,
            S = $e < Ne ? X[$e].el : be
          for (; he <= Be; )
            m(null, (X[he] = ge ? va(X[he]) : Fs(X[he])), ie, S, ue, de, Te, we, ge), he++
        }
      } else if (he > Be) for (; he <= _e; ) E(Z[he], ue, de, !0), he++
      else {
        const $e = he,
          S = he,
          f = new Map()
        for (he = S; he <= Be; he++) {
          const Oe = (X[he] = ge ? va(X[he]) : Fs(X[he]))
          Oe.key != null && f.set(Oe.key, he)
        }
        let g,
          k = 0
        const q = Be - S + 1
        let V = !1,
          Y = 0
        const ke = new Array(q)
        for (he = 0; he < q; he++) ke[he] = 0
        for (he = $e; he <= _e; he++) {
          const Oe = Z[he]
          if (k >= q) {
            E(Oe, ue, de, !0)
            continue
          }
          let st
          if (Oe.key != null) st = f.get(Oe.key)
          else
            for (g = S; g <= Be; g++)
              if (ke[g - S] === 0 && xa(Oe, X[g])) {
                st = g
                break
              }
          st === void 0
            ? E(Oe, ue, de, !0)
            : ((ke[st - S] = he + 1),
              st >= Y ? (Y = st) : (V = !0),
              m(Oe, X[st], ie, null, ue, de, Te, we, ge),
              k++)
        }
        const Ve = V ? x6(ke) : El
        for (g = Ve.length - 1, he = q - 1; he >= 0; he--) {
          const Oe = S + he,
            st = X[Oe],
            Ue = Oe + 1 < Ne ? X[Oe + 1].el : be
          ke[he] === 0
            ? m(null, st, ie, Ue, ue, de, Te, we, ge)
            : V && (g < 0 || he !== Ve[g] ? j(st, ie, Ue, 2) : g--)
        }
      }
    },
    j = (Z, X, ie, be, ue = null) => {
      const { el: de, type: Te, transition: we, children: ge, shapeFlag: he } = Z
      if (he & 6) {
        j(Z.component.subTree, X, ie, be)
        return
      }
      if (he & 128) {
        Z.suspense.move(X, ie, be)
        return
      }
      if (he & 64) {
        Te.move(Z, X, ie, tt)
        return
      }
      if (Te === Ai) {
        r(de, X, ie)
        for (let _e = 0; _e < ge.length; _e++) j(ge[_e], X, ie, be)
        r(Z.anchor, X, ie)
        return
      }
      if (Te === xh) {
        _(Z, X, ie)
        return
      }
      if (be !== 2 && he & 1 && we)
        if (be === 0) we.beforeEnter(de), r(de, X, ie), Rs(() => we.enter(de), ue)
        else {
          const { leave: _e, delayLeave: Be, afterLeave: $e } = we,
            S = () => r(de, X, ie),
            f = () => {
              _e(de, () => {
                S(), $e && $e()
              })
            }
          Be ? Be(de, S, f) : f()
        }
      else r(de, X, ie)
    },
    E = (Z, X, ie, be = !1, ue = !1) => {
      const {
        type: de,
        props: Te,
        ref: we,
        children: ge,
        dynamicChildren: he,
        shapeFlag: Ne,
        patchFlag: _e,
        dirs: Be,
        cacheIndex: $e
      } = Z
      if (
        (_e === -2 && (ue = !1),
        we != null && Wh(we, null, ie, Z, !0),
        $e != null && (X.renderCache[$e] = void 0),
        Ne & 256)
      ) {
        X.ctx.deactivate(Z)
        return
      }
      const S = Ne & 1 && Be,
        f = !Il(Z)
      let g
      if ((f && (g = Te && Te.onVnodeBeforeUnmount) && ei(g, X, Z), Ne & 6)) K(Z.component, ie, be)
      else {
        if (Ne & 128) {
          Z.suspense.unmount(ie, be)
          return
        }
        S && Vi(Z, null, X, 'beforeUnmount'),
          Ne & 64
            ? Z.type.remove(Z, X, ie, tt, be)
            : he && !he.hasOnce && (de !== Ai || (_e > 0 && _e & 64))
              ? ee(he, X, ie, !1, !0)
              : ((de === Ai && _e & 384) || (!ue && Ne & 16)) && ee(ge, X, ie),
          be && C(Z)
      }
      ;((f && (g = Te && Te.onVnodeUnmounted)) || S) &&
        Rs(() => {
          g && ei(g, X, Z), S && Vi(Z, null, X, 'unmounted')
        }, ie)
    },
    C = Z => {
      const { type: X, el: ie, anchor: be, transition: ue } = Z
      if (X === Ai) {
        L(ie, be)
        return
      }
      if (X === xh) {
        R(Z)
        return
      }
      const de = () => {
        s(ie), ue && !ue.persisted && ue.afterLeave && ue.afterLeave()
      }
      if (Z.shapeFlag & 1 && ue && !ue.persisted) {
        const { leave: Te, delayLeave: we } = ue,
          ge = () => Te(ie, de)
        we ? we(Z.el, de, ge) : ge()
      } else de()
    },
    L = (Z, X) => {
      let ie
      for (; Z !== X; ) (ie = h(Z)), s(Z), (Z = ie)
      s(X)
    },
    K = (Z, X, ie) => {
      const { bum: be, scope: ue, job: de, subTree: Te, um: we, m: ge, a: he } = Z
      R_(ge),
        R_(he),
        be && By(be),
        ue.stop(),
        de && ((de.flags |= 8), E(Te, Z, X, ie)),
        we && Rs(we, X),
        Rs(() => {
          Z.isUnmounted = !0
        }, X),
        X &&
          X.pendingBranch &&
          !X.isUnmounted &&
          Z.asyncDep &&
          !Z.asyncResolved &&
          Z.suspenseId === X.pendingId &&
          (X.deps--, X.deps === 0 && X.resolve())
    },
    ee = (Z, X, ie, be = !1, ue = !1, de = 0) => {
      for (let Te = de; Te < Z.length; Te++) E(Z[Te], X, ie, be, ue)
    },
    oe = Z => {
      if (Z.shapeFlag & 6) return oe(Z.component.subTree)
      if (Z.shapeFlag & 128) return Z.suspense.next()
      const X = h(Z.anchor || Z.el),
        ie = X && X[ZB]
      return ie ? h(ie) : X
    }
  let fe = !1
  const ve = (Z, X, ie) => {
      Z == null
        ? X._vnode && E(X._vnode, null, null, !0)
        : m(X._vnode || null, Z, X, null, null, null, ie),
        (X._vnode = Z),
        fe || ((fe = !0), v_(), Zg(), (fe = !1))
    },
    tt = { p: m, um: E, m: j, r: C, mt: w, mc: H, pc: O, pbc: $, n: oe, o: t }
  let Ge, nt
  return e && ([Ge, nt] = e(tt)), { render: ve, hydrate: Ge, createApp: w6(ve, Ge) }
}
function jy({ type: t, props: e }, n) {
  return (n === 'svg' && t === 'foreignObject') ||
    (n === 'mathml' && t === 'annotation-xml' && e && e.encoding && e.encoding.includes('html'))
    ? void 0
    : n
}
function fc({ effect: t, job: e }, n) {
  n ? ((t.flags |= 32), (e.flags |= 4)) : ((t.flags &= -33), (e.flags &= -5))
}
function eP(t, e) {
  return (!t || (t && !t.pendingBranch)) && e && !e.persisted
}
function tP(t, e, n = !1) {
  const r = t.children,
    s = e.children
  if (_t(r) && _t(s))
    for (let i = 0; i < r.length; i++) {
      const o = r[i]
      let a = s[i]
      a.shapeFlag & 1 &&
        !a.dynamicChildren &&
        ((a.patchFlag <= 0 || a.patchFlag === 32) && ((a = s[i] = va(s[i])), (a.el = o.el)),
        !n && a.patchFlag !== -2 && tP(o, a)),
        a.type === Qc && (a.el = o.el)
    }
}
function x6(t) {
  const e = t.slice(),
    n = [0]
  let r, s, i, o, a
  const c = t.length
  for (r = 0; r < c; r++) {
    const u = t[r]
    if (u !== 0) {
      if (((s = n[n.length - 1]), t[s] < u)) {
        ;(e[r] = s), n.push(r)
        continue
      }
      for (i = 0, o = n.length - 1; i < o; ) (a = (i + o) >> 1), t[n[a]] < u ? (i = a + 1) : (o = a)
      u < t[n[i]] && (i > 0 && (e[r] = n[i - 1]), (n[i] = r))
    }
  }
  for (i = n.length, o = n[i - 1]; i-- > 0; ) (n[i] = o), (o = e[o])
  return n
}
function nP(t) {
  const e = t.subTree.component
  if (e) return e.asyncDep && !e.asyncResolved ? e : nP(e)
}
function R_(t) {
  if (t) for (let e = 0; e < t.length; e++) t[e].flags |= 8
}
const T6 = Symbol.for('v-scx'),
  N6 = () => xl(T6)
function P6(t, e) {
  return yE(t, null, e)
}
function Hy(t, e, n) {
  return yE(t, e, n)
}
function yE(t, e, n = En) {
  const { immediate: r, deep: s, flush: i, once: o } = n,
    a = Gr({}, n),
    c = (e && r) || (!e && i !== 'post')
  let u
  if (Gl) {
    if (i === 'sync') {
      const p = N6()
      u = p.__watcherHandles || (p.__watcherHandles = [])
    } else if (!c) {
      const p = () => {}
      return (p.stop = eo), (p.resume = eo), (p.pause = eo), p
    }
  }
  const l = sr
  a.call = (p, y, m) => ro(p, l, y, m)
  let d = !1
  i === 'post'
    ? (a.scheduler = p => {
        Rs(p, l && l.suspense)
      })
    : i !== 'sync' &&
      ((d = !0),
      (a.scheduler = (p, y) => {
        y ? p() : cE(p)
      })),
    (a.augmentJob = p => {
      e && (p.flags |= 4), d && ((p.flags |= 2), l && ((p.id = l.uid), (p.i = l)))
    })
  const h = VB(t, e, a)
  return Gl && (u ? u.push(h) : c && h()), h
}
function R6(t, e, n) {
  const r = this.proxy,
    s = Hn(t) ? (t.includes('.') ? rP(r, t) : () => r[t]) : t.bind(r, r)
  let i
  bt(e) ? (i = e) : ((i = e.handler), (n = e))
  const o = ep(this),
    a = yE(s, i.bind(r), n)
  return o(), a
}
function rP(t, e) {
  const n = e.split('.')
  return () => {
    let r = t
    for (let s = 0; s < n.length && r; s++) r = r[n[s]]
    return r
  }
}
const k6 = (t, e) =>
  e === 'modelValue' || e === 'model-value'
    ? t.modelModifiers
    : t[`${e}Modifiers`] || t[`${ai(e)}Modifiers`] || t[`${Au(e)}Modifiers`]
function O6(t, e, ...n) {
  if (t.isUnmounted) return
  const r = t.vnode.props || En
  let s = n
  const i = e.startsWith('update:'),
    o = i && k6(r, e.slice(7))
  o && (o.trim && (s = n.map(l => (Hn(l) ? l.trim() : l))), o.number && (s = n.map(aB)))
  let a,
    c = r[(a = Oy(e))] || r[(a = Oy(ai(e)))]
  !c && i && (c = r[(a = Oy(Au(e)))]), c && ro(c, t, 6, s)
  const u = r[a + 'Once']
  if (u) {
    if (!t.emitted) t.emitted = {}
    else if (t.emitted[a]) return
    ;(t.emitted[a] = !0), ro(u, t, 6, s)
  }
}
function sP(t, e, n = !1) {
  const r = e.emitsCache,
    s = r.get(t)
  if (s !== void 0) return s
  const i = t.emits
  let o = {},
    a = !1
  if (!bt(t)) {
    const c = u => {
      const l = sP(u, e, !0)
      l && ((a = !0), Gr(o, l))
    }
    !n && e.mixins.length && e.mixins.forEach(c),
      t.extends && c(t.extends),
      t.mixins && t.mixins.forEach(c)
  }
  return !i && !a
    ? (Pn(t) && r.set(t, null), null)
    : (_t(i) ? i.forEach(c => (o[c] = null)) : Gr(o, i), Pn(t) && r.set(t, o), o)
}
function s0(t, e) {
  return !t || !Jf(e)
    ? !1
    : ((e = e.slice(2).replace(/Once$/, '')),
      tn(t, e[0].toLowerCase() + e.slice(1)) || tn(t, Au(e)) || tn(t, e))
}
function qy(t) {
  const {
      type: e,
      vnode: n,
      proxy: r,
      withProxy: s,
      propsOptions: [i],
      slots: o,
      attrs: a,
      emit: c,
      render: u,
      renderCache: l,
      props: d,
      data: h,
      setupState: p,
      ctx: y,
      inheritAttrs: m
    } = t,
    b = Yg(t)
  let I, x
  try {
    if (n.shapeFlag & 4) {
      const R = s || r,
        N = R
      ;(I = Fs(u.call(N, R, l, d, p, h, y))), (x = a)
    } else {
      const R = e
      ;(I = Fs(R.length > 1 ? R(d, { attrs: a, slots: o, emit: c }) : R(d, null))),
        (x = e.props ? a : D6(a))
    }
  } catch (R) {
    ;(Th.length = 0), md(R, t, 1), (I = An(so))
  }
  let _ = I
  if (x && m !== !1) {
    const R = Object.keys(x),
      { shapeFlag: N } = _
    R.length && N & 7 && (i && R.some(Zv) && (x = M6(x, i)), (_ = Vl(_, x, !1, !0)))
  }
  return (
    n.dirs && ((_ = Vl(_, null, !1, !0)), (_.dirs = _.dirs ? _.dirs.concat(n.dirs) : n.dirs)),
    n.transition && lE(_, n.transition),
    (I = _),
    Yg(b),
    I
  )
}
function B6(t, e = !0) {
  let n
  for (let r = 0; r < t.length; r++) {
    const s = t[r]
    if (Vh(s)) {
      if (s.type !== so || s.children === 'v-if') {
        if (n) return
        n = s
      }
    } else return
  }
  return n
}
const D6 = t => {
    let e
    for (const n in t) (n === 'class' || n === 'style' || Jf(n)) && ((e || (e = {}))[n] = t[n])
    return e
  },
  M6 = (t, e) => {
    const n = {}
    for (const r in t) (!Zv(r) || !(r.slice(9) in e)) && (n[r] = t[r])
    return n
  }
function U6(t, e, n) {
  const { props: r, children: s, component: i } = t,
    { props: o, children: a, patchFlag: c } = e,
    u = i.emitsOptions
  if (e.dirs || e.transition) return !0
  if (n && c >= 0) {
    if (c & 1024) return !0
    if (c & 16) return r ? k_(r, o, u) : !!o
    if (c & 8) {
      const l = e.dynamicProps
      for (let d = 0; d < l.length; d++) {
        const h = l[d]
        if (o[h] !== r[h] && !s0(u, h)) return !0
      }
    }
  } else
    return (s || a) && (!a || !a.$stable) ? !0 : r === o ? !1 : r ? (o ? k_(r, o, u) : !0) : !!o
  return !1
}
function k_(t, e, n) {
  const r = Object.keys(e)
  if (r.length !== Object.keys(t).length) return !0
  for (let s = 0; s < r.length; s++) {
    const i = r[s]
    if (e[i] !== t[i] && !s0(n, i)) return !0
  }
  return !1
}
function i0({ vnode: t, parent: e }, n) {
  for (; e; ) {
    const r = e.subTree
    if ((r.suspense && r.suspense.activeBranch === t && (r.el = t.el), r === t))
      ((t = e.vnode).el = n), (e = e.parent)
    else break
  }
}
const iP = t => t.__isSuspense
let t1 = 0
const L6 = {
    name: 'Suspense',
    __isSuspense: !0,
    process(t, e, n, r, s, i, o, a, c, u) {
      if (t == null) F6(e, n, r, s, i, o, a, c, u)
      else {
        if (i && i.deps > 0 && !t.suspense.isInFallback) {
          ;(e.suspense = t.suspense), (e.suspense.vnode = e), (e.el = t.el)
          return
        }
        j6(t, e, n, r, s, o, a, c, u)
      }
    },
    hydrate: H6,
    normalize: q6
  },
  $6 = L6
function Kh(t, e) {
  const n = t.props && t.props[e]
  bt(n) && n()
}
function F6(t, e, n, r, s, i, o, a, c) {
  const {
      p: u,
      o: { createElement: l }
    } = c,
    d = l('div'),
    h = (t.suspense = oP(t, s, r, e, d, n, i, o, a, c))
  u(null, (h.pendingBranch = t.ssContent), d, null, r, h, i, o),
    h.deps > 0
      ? (Kh(t, 'onPending'),
        Kh(t, 'onFallback'),
        u(null, t.ssFallback, e, n, r, null, i, o),
        Tl(h, t.ssFallback))
      : h.resolve(!1, !0)
}
function j6(t, e, n, r, s, i, o, a, { p: c, um: u, o: { createElement: l } }) {
  const d = (e.suspense = t.suspense)
  ;(d.vnode = e), (e.el = t.el)
  const h = e.ssContent,
    p = e.ssFallback,
    { activeBranch: y, pendingBranch: m, isInFallback: b, isHydrating: I } = d
  if (m)
    (d.pendingBranch = h),
      xa(h, m)
        ? (c(m, h, d.hiddenContainer, null, s, d, i, o, a),
          d.deps <= 0 ? d.resolve() : b && (I || (c(y, p, n, r, s, null, i, o, a), Tl(d, p))))
        : ((d.pendingId = t1++),
          I ? ((d.isHydrating = !1), (d.activeBranch = m)) : u(m, s, d),
          (d.deps = 0),
          (d.effects.length = 0),
          (d.hiddenContainer = l('div')),
          b
            ? (c(null, h, d.hiddenContainer, null, s, d, i, o, a),
              d.deps <= 0 ? d.resolve() : (c(y, p, n, r, s, null, i, o, a), Tl(d, p)))
            : y && xa(h, y)
              ? (c(y, h, n, r, s, d, i, o, a), d.resolve(!0))
              : (c(null, h, d.hiddenContainer, null, s, d, i, o, a), d.deps <= 0 && d.resolve()))
  else if (y && xa(h, y)) c(y, h, n, r, s, d, i, o, a), Tl(d, h)
  else if (
    (Kh(e, 'onPending'),
    (d.pendingBranch = h),
    h.shapeFlag & 512 ? (d.pendingId = h.component.suspenseId) : (d.pendingId = t1++),
    c(null, h, d.hiddenContainer, null, s, d, i, o, a),
    d.deps <= 0)
  )
    d.resolve()
  else {
    const { timeout: x, pendingId: _ } = d
    x > 0
      ? setTimeout(() => {
          d.pendingId === _ && d.fallback(p)
        }, x)
      : x === 0 && d.fallback(p)
  }
}
function oP(t, e, n, r, s, i, o, a, c, u, l = !1) {
  const {
    p: d,
    m: h,
    um: p,
    n: y,
    o: { parentNode: m, remove: b }
  } = u
  let I
  const x = z6(t)
  x && e && e.pendingBranch && ((I = e.pendingId), e.deps++)
  const _ = t.props ? cB(t.props.timeout) : void 0,
    R = i,
    N = {
      vnode: t,
      parent: e,
      parentComponent: n,
      namespace: o,
      container: r,
      hiddenContainer: s,
      deps: 0,
      pendingId: t1++,
      timeout: typeof _ == 'number' ? _ : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: !l,
      isHydrating: l,
      isUnmounted: !1,
      effects: [],
      resolve(T = !1, M = !1) {
        const {
          vnode: H,
          activeBranch: B,
          pendingBranch: $,
          pendingId: D,
          effects: W,
          parentComponent: U,
          container: w
        } = N
        let v = !1
        N.isHydrating
          ? (N.isHydrating = !1)
          : T ||
            ((v = B && $.transition && $.transition.mode === 'out-in'),
            v &&
              (B.transition.afterLeave = () => {
                D === N.pendingId && (h($, w, i === R ? y(B) : i, 0), Zb(W))
              }),
            B && (m(B.el) === w && (i = y(B)), p(B, U, N, !0)),
            v || h($, w, i, 0)),
          Tl(N, $),
          (N.pendingBranch = null),
          (N.isInFallback = !1)
        let A = N.parent,
          P = !1
        for (; A; ) {
          if (A.pendingBranch) {
            A.effects.push(...W), (P = !0)
            break
          }
          A = A.parent
        }
        !P && !v && Zb(W),
          (N.effects = []),
          x &&
            e &&
            e.pendingBranch &&
            I === e.pendingId &&
            (e.deps--, e.deps === 0 && !M && e.resolve()),
          Kh(H, 'onResolve')
      },
      fallback(T) {
        if (!N.pendingBranch) return
        const { vnode: M, activeBranch: H, parentComponent: B, container: $, namespace: D } = N
        Kh(M, 'onFallback')
        const W = y(H),
          U = () => {
            N.isInFallback && (d(null, T, $, W, B, null, D, a, c), Tl(N, T))
          },
          w = T.transition && T.transition.mode === 'out-in'
        w && (H.transition.afterLeave = U), (N.isInFallback = !0), p(H, B, null, !0), w || U()
      },
      move(T, M, H) {
        N.activeBranch && h(N.activeBranch, T, M, H), (N.container = T)
      },
      next() {
        return N.activeBranch && y(N.activeBranch)
      },
      registerDep(T, M, H) {
        const B = !!N.pendingBranch
        B && N.deps++
        const $ = T.vnode.el
        T.asyncDep
          .catch(D => {
            md(D, T, 0)
          })
          .then(D => {
            if (T.isUnmounted || N.isUnmounted || N.pendingId !== T.suspenseId) return
            T.asyncResolved = !0
            const { vnode: W } = T
            r1(T, D), $ && (W.el = $)
            const U = !$ && T.subTree.el
            M(T, W, m($ || T.subTree.el), $ ? null : y(T.subTree), N, o, H),
              U && b(U),
              i0(T, W.el),
              B && --N.deps === 0 && N.resolve()
          })
      },
      unmount(T, M) {
        ;(N.isUnmounted = !0),
          N.activeBranch && p(N.activeBranch, n, T, M),
          N.pendingBranch && p(N.pendingBranch, n, T, M)
      }
    }
  return N
}
function H6(t, e, n, r, s, i, o, a, c) {
  const u = (e.suspense = oP(
      e,
      r,
      n,
      t.parentNode,
      document.createElement('div'),
      null,
      s,
      i,
      o,
      a,
      !0
    )),
    l = c(t, (u.pendingBranch = e.ssContent), n, u, i, o)
  return u.deps === 0 && u.resolve(!1, !0), l
}
function q6(t) {
  const { shapeFlag: e, children: n } = t,
    r = e & 32
  ;(t.ssContent = O_(r ? n.default : n)), (t.ssFallback = r ? O_(n.fallback) : An(so))
}
function O_(t) {
  let e
  if (bt(t)) {
    const n = Kl && t._c
    n && ((t._d = !1), os()), (t = t()), n && ((t._d = !0), (e = Es), cP())
  }
  return (
    _t(t) && (t = B6(t)),
    (t = Fs(t)),
    e && !t.dynamicChildren && (t.dynamicChildren = e.filter(n => n !== t)),
    t
  )
}
function aP(t, e) {
  e && e.pendingBranch ? (_t(t) ? e.effects.push(...t) : e.effects.push(t)) : Zb(t)
}
function Tl(t, e) {
  t.activeBranch = e
  const { vnode: n, parentComponent: r } = t
  let s = e.el
  for (; !s && e.component; ) (e = e.component.subTree), (s = e.el)
  ;(n.el = s), r && r.subTree === n && ((r.vnode.el = s), i0(r, s))
}
function z6(t) {
  const e = t.props && t.props.suspensible
  return e != null && e !== !1
}
const Ai = Symbol.for('v-fgt'),
  Qc = Symbol.for('v-txt'),
  so = Symbol.for('v-cmt'),
  xh = Symbol.for('v-stc'),
  Th = []
let Es = null
function os(t = !1) {
  Th.push((Es = t ? null : []))
}
function cP() {
  Th.pop(), (Es = Th[Th.length - 1] || null)
}
let Kl = 1
function B_(t, e = !1) {
  ;(Kl += t), t < 0 && Es && e && (Es.hasOnce = !0)
}
function uP(t) {
  return (t.dynamicChildren = Kl > 0 ? Es || El : null), cP(), Kl > 0 && Es && Es.push(t), t
}
function Zc(t, e, n, r, s, i) {
  return uP(ht(t, e, n, r, s, i, !0))
}
function Ia(t, e, n, r, s) {
  return uP(An(t, e, n, r, s, !0))
}
function Vh(t) {
  return t ? t.__v_isVNode === !0 : !1
}
function xa(t, e) {
  return t.type === e.type && t.key === e.key
}
const lP = ({ key: t }) => t ?? null,
  Cg = ({ ref: t, ref_key: e, ref_for: n }) => (
    typeof t == 'number' && (t = '' + t),
    t != null ? (Hn(t) || Vn(t) || bt(t) ? { i: Hs, r: t, k: e, f: !!n } : t) : null
  )
function ht(t, e = null, n = null, r = 0, s = null, i = t === Ai ? 0 : 1, o = !1, a = !1) {
  const c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && lP(e),
    ref: e && Cg(e),
    scopeId: kN,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: i,
    patchFlag: r,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: Hs
  }
  return (
    a ? (wE(c, n), i & 128 && t.normalize(c)) : n && (c.shapeFlag |= Hn(n) ? 8 : 16),
    Kl > 0 && !o && Es && (c.patchFlag > 0 || i & 6) && c.patchFlag !== 32 && Es.push(c),
    c
  )
}
const An = W6
function W6(t, e = null, n = null, r = 0, s = null, i = !1) {
  if (((!t || t === $N) && (t = so), Vh(t))) {
    const a = Vl(t, e, !0)
    return (
      n && wE(a, n),
      Kl > 0 && !i && Es && (a.shapeFlag & 6 ? (Es[Es.indexOf(t)] = a) : Es.push(a)),
      (a.patchFlag = -2),
      a
    )
  }
  if ((nD(t) && (t = t.__vccOpts), e)) {
    e = dP(e)
    let { class: a, style: c } = e
    a && !Hn(a) && (e.class = t0(a)),
      Pn(c) && (oE(c) && !_t(c) && (c = Gr({}, c)), (e.style = e0(c)))
  }
  const o = Hn(t) ? 1 : iP(t) ? 128 : YB(t) ? 64 : Pn(t) ? 4 : bt(t) ? 2 : 0
  return ht(t, e, n, r, s, o, i, !0)
}
function dP(t) {
  return t ? (oE(t) || KN(t) ? Gr({}, t) : t) : null
}
function Vl(t, e, n = !1, r = !1) {
  const { props: s, ref: i, patchFlag: o, children: a, transition: c } = t,
    u = e ? V6(s || {}, e) : s,
    l = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: t.type,
      props: u,
      key: u && lP(u),
      ref: e && e.ref ? (n && i ? (_t(i) ? i.concat(Cg(e)) : [i, Cg(e)]) : Cg(e)) : i,
      scopeId: t.scopeId,
      slotScopeIds: t.slotScopeIds,
      children: a,
      target: t.target,
      targetStart: t.targetStart,
      targetAnchor: t.targetAnchor,
      staticCount: t.staticCount,
      shapeFlag: t.shapeFlag,
      patchFlag: e && t.type !== Ai ? (o === -1 ? 16 : o | 16) : o,
      dynamicProps: t.dynamicProps,
      dynamicChildren: t.dynamicChildren,
      appContext: t.appContext,
      dirs: t.dirs,
      transition: c,
      component: t.component,
      suspense: t.suspense,
      ssContent: t.ssContent && Vl(t.ssContent),
      ssFallback: t.ssFallback && Vl(t.ssFallback),
      el: t.el,
      anchor: t.anchor,
      ctx: t.ctx,
      ce: t.ce
    }
  return c && r && lE(l, c.clone(l)), l
}
function hP(t = ' ', e = 0) {
  return An(Qc, null, t, e)
}
function K6(t, e) {
  const n = An(xh, null, t)
  return (n.staticCount = e), n
}
function D_(t = '', e = !1) {
  return e ? (os(), Ia(so, null, t)) : An(so, null, t)
}
function Fs(t) {
  return t == null || typeof t == 'boolean'
    ? An(so)
    : _t(t)
      ? An(Ai, null, t.slice())
      : Vh(t)
        ? va(t)
        : An(Qc, null, String(t))
}
function va(t) {
  return (t.el === null && t.patchFlag !== -1) || t.memo ? t : Vl(t)
}
function wE(t, e) {
  let n = 0
  const { shapeFlag: r } = t
  if (e == null) e = null
  else if (_t(e)) n = 16
  else if (typeof e == 'object')
    if (r & 65) {
      const s = e.default
      s && (s._c && (s._d = !1), wE(t, s()), s._c && (s._d = !0))
      return
    } else {
      n = 32
      const s = e._
      !s && !KN(e)
        ? (e._ctx = Hs)
        : s === 3 && Hs && (Hs.slots._ === 1 ? (e._ = 1) : ((e._ = 2), (t.patchFlag |= 1024)))
    }
  else
    bt(e)
      ? ((e = { default: e, _ctx: Hs }), (n = 32))
      : ((e = String(e)), r & 64 ? ((n = 16), (e = [hP(e)])) : (n = 8))
  ;(t.children = e), (t.shapeFlag |= n)
}
function V6(...t) {
  const e = {}
  for (let n = 0; n < t.length; n++) {
    const r = t[n]
    for (const s in r)
      if (s === 'class') e.class !== r.class && (e.class = t0([e.class, r.class]))
      else if (s === 'style') e.style = e0([e.style, r.style])
      else if (Jf(s)) {
        const i = e[s],
          o = r[s]
        o && i !== o && !(_t(i) && i.includes(o)) && (e[s] = i ? [].concat(i, o) : o)
      } else s !== '' && (e[s] = r[s])
  }
  return e
}
function ei(t, e, n, r = null) {
  ro(t, e, 7, [n, r])
}
const G6 = qN()
let Q6 = 0
function Z6(t, e, n) {
  const r = t.type,
    s = (e ? e.appContext : t.appContext) || G6,
    i = {
      uid: Q6++,
      vnode: t,
      type: r,
      parent: e,
      appContext: s,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      job: null,
      scope: new lN(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: e ? e.provides : Object.create(s.provides),
      ids: e ? e.ids : ['', 0, 0],
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: GN(r, s),
      emitsOptions: sP(r, s),
      emit: null,
      emitted: null,
      propsDefaults: En,
      inheritAttrs: r.inheritAttrs,
      ctx: En,
      data: En,
      props: En,
      attrs: En,
      slots: En,
      refs: En,
      setupState: En,
      setupContext: null,
      suspense: n,
      suspenseId: n ? n.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    }
  return (
    (i.ctx = { _: i }), (i.root = e ? e.root : i), (i.emit = O6.bind(null, i)), t.ce && t.ce(i), i
  )
}
let sr = null
const fP = () => sr || Hs
let Xg, n1
{
  const t = Xm(),
    e = (n, r) => {
      let s
      return (
        (s = t[n]) || (s = t[n] = []),
        s.push(r),
        i => {
          s.length > 1 ? s.forEach(o => o(i)) : s[0](i)
        }
      )
    }
  ;(Xg = e('__VUE_INSTANCE_SETTERS__', n => (sr = n))),
    (n1 = e('__VUE_SSR_SETTERS__', n => (Gl = n)))
}
const ep = t => {
    const e = sr
    return (
      Xg(t),
      t.scope.on(),
      () => {
        t.scope.off(), Xg(e)
      }
    )
  },
  M_ = () => {
    sr && sr.scope.off(), Xg(null)
  }
function pP(t) {
  return t.vnode.shapeFlag & 4
}
let Gl = !1
function Y6(t, e = !1, n = !1) {
  e && n1(e)
  const { props: r, children: s } = t.vnode,
    i = pP(t)
  b6(t, r, i, e), _6(t, s, n)
  const o = i ? J6(t, e) : void 0
  return e && n1(!1), o
}
function J6(t, e) {
  const n = t.type
  ;(t.accessCache = Object.create(null)), (t.proxy = new Proxy(t.ctx, d6))
  const { setup: r } = n
  if (r) {
    ac()
    const s = (t.setupContext = r.length > 1 ? eD(t) : null),
      i = ep(t),
      o = Xf(r, t, 0, [t.props, s]),
      a = rN(o)
    if ((cc(), i(), (a || t.sp) && !Il(t) && dE(t), a)) {
      if ((o.then(M_, M_), e))
        return o
          .then(c => {
            r1(t, c)
          })
          .catch(c => {
            md(c, t, 0)
          })
      t.asyncDep = o
    } else r1(t, o)
  } else gP(t)
}
function r1(t, e, n) {
  bt(e)
    ? t.type.__ssrInlineRender
      ? (t.ssrRender = e)
      : (t.render = e)
    : Pn(e) && (t.setupState = TN(e)),
    gP(t)
}
function gP(t, e, n) {
  const r = t.type
  t.render || (t.render = r.render || eo)
  {
    const s = ep(t)
    ac()
    try {
      h6(t)
    } finally {
      cc(), s()
    }
  }
}
const X6 = {
  get(t, e) {
    return Wr(t, 'get', ''), t[e]
  }
}
function eD(t) {
  const e = n => {
    t.exposed = n || {}
  }
  return { attrs: new Proxy(t.attrs, X6), slots: t.slots, emit: t.emit, expose: e }
}
function bE(t) {
  return t.exposed
    ? t.exposeProxy ||
        (t.exposeProxy = new Proxy(TN(MB(t.exposed)), {
          get(e, n) {
            if (n in e) return e[n]
            if (n in Ih) return Ih[n](t)
          },
          has(e, n) {
            return n in e || n in Ih
          }
        }))
    : t.proxy
}
function tD(t, e = !0) {
  return bt(t) ? t.displayName || t.name : t.name || (e && t.__name)
}
function nD(t) {
  return bt(t) && '__vccOpts' in t
}
const mP = (t, e) => WB(t, e, Gl)
function rD(t, e, n) {
  const r = arguments.length
  return r === 2
    ? Pn(e) && !_t(e)
      ? Vh(e)
        ? An(t, null, [e])
        : An(t, e)
      : An(t, null, e)
    : (r > 3 ? (n = Array.prototype.slice.call(arguments, 2)) : r === 3 && Vh(n) && (n = [n]),
      An(t, e, n))
}
const sD = '3.5.13'
/**
 * @vue/runtime-dom v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ let s1
const U_ = typeof window < 'u' && window.trustedTypes
if (U_)
  try {
    s1 = U_.createPolicy('vue', { createHTML: t => t })
  } catch {}
const yP = s1 ? t => s1.createHTML(t) : t => t,
  iD = 'http://www.w3.org/2000/svg',
  oD = 'http://www.w3.org/1998/Math/MathML',
  Mo = typeof document < 'u' ? document : null,
  L_ = Mo && Mo.createElement('template'),
  aD = {
    insert: (t, e, n) => {
      e.insertBefore(t, n || null)
    },
    remove: t => {
      const e = t.parentNode
      e && e.removeChild(t)
    },
    createElement: (t, e, n, r) => {
      const s =
        e === 'svg'
          ? Mo.createElementNS(iD, t)
          : e === 'mathml'
            ? Mo.createElementNS(oD, t)
            : n
              ? Mo.createElement(t, { is: n })
              : Mo.createElement(t)
      return t === 'select' && r && r.multiple != null && s.setAttribute('multiple', r.multiple), s
    },
    createText: t => Mo.createTextNode(t),
    createComment: t => Mo.createComment(t),
    setText: (t, e) => {
      t.nodeValue = e
    },
    setElementText: (t, e) => {
      t.textContent = e
    },
    parentNode: t => t.parentNode,
    nextSibling: t => t.nextSibling,
    querySelector: t => Mo.querySelector(t),
    setScopeId(t, e) {
      t.setAttribute(e, '')
    },
    insertStaticContent(t, e, n, r, s, i) {
      const o = n ? n.previousSibling : e.lastChild
      if (s && (s === i || s.nextSibling))
        for (; e.insertBefore(s.cloneNode(!0), n), !(s === i || !(s = s.nextSibling)); );
      else {
        L_.innerHTML = yP(
          r === 'svg' ? `<svg>${t}</svg>` : r === 'mathml' ? `<math>${t}</math>` : t
        )
        const a = L_.content
        if (r === 'svg' || r === 'mathml') {
          const c = a.firstChild
          for (; c.firstChild; ) a.appendChild(c.firstChild)
          a.removeChild(c)
        }
        e.insertBefore(a, n)
      }
      return [o ? o.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
    }
  },
  cD = Symbol('_vtc')
function uD(t, e, n) {
  const r = t[cD]
  r && (e = (e ? [e, ...r] : [...r]).join(' ')),
    e == null ? t.removeAttribute('class') : n ? t.setAttribute('class', e) : (t.className = e)
}
const $_ = Symbol('_vod'),
  lD = Symbol('_vsh'),
  dD = Symbol(''),
  hD = /(^|;)\s*display\s*:/
function fD(t, e, n) {
  const r = t.style,
    s = Hn(n)
  let i = !1
  if (n && !s) {
    if (e)
      if (Hn(e))
        for (const o of e.split(';')) {
          const a = o.slice(0, o.indexOf(':')).trim()
          n[a] == null && Sg(r, a, '')
        }
      else for (const o in e) n[o] == null && Sg(r, o, '')
    for (const o in n) o === 'display' && (i = !0), Sg(r, o, n[o])
  } else if (s) {
    if (e !== n) {
      const o = r[dD]
      o && (n += ';' + o), (r.cssText = n), (i = hD.test(n))
    }
  } else e && t.removeAttribute('style')
  $_ in t && ((t[$_] = i ? r.display : ''), t[lD] && (r.display = 'none'))
}
const F_ = /\s*!important$/
function Sg(t, e, n) {
  if (_t(n)) n.forEach(r => Sg(t, e, r))
  else if ((n == null && (n = ''), e.startsWith('--'))) t.setProperty(e, n)
  else {
    const r = pD(t, e)
    F_.test(n) ? t.setProperty(Au(r), n.replace(F_, ''), 'important') : (t[r] = n)
  }
}
const j_ = ['Webkit', 'Moz', 'ms'],
  zy = {}
function pD(t, e) {
  const n = zy[e]
  if (n) return n
  let r = ai(e)
  if (r !== 'filter' && r in t) return (zy[e] = r)
  r = Jm(r)
  for (let s = 0; s < j_.length; s++) {
    const i = j_[s] + r
    if (i in t) return (zy[e] = i)
  }
  return e
}
const H_ = 'http://www.w3.org/1999/xlink'
function q_(t, e, n, r, s, i = gB(e)) {
  r && e.startsWith('xlink:')
    ? n == null
      ? t.removeAttributeNS(H_, e.slice(6, e.length))
      : t.setAttributeNS(H_, e, n)
    : n == null || (i && !aN(n))
      ? t.removeAttribute(e)
      : t.setAttribute(e, i ? '' : oc(n) ? String(n) : n)
}
function z_(t, e, n, r, s) {
  if (e === 'innerHTML' || e === 'textContent') {
    n != null && (t[e] = e === 'innerHTML' ? yP(n) : n)
    return
  }
  const i = t.tagName
  if (e === 'value' && i !== 'PROGRESS' && !i.includes('-')) {
    const a = i === 'OPTION' ? t.getAttribute('value') || '' : t.value,
      c = n == null ? (t.type === 'checkbox' ? 'on' : '') : String(n)
    ;(a !== c || !('_value' in t)) && (t.value = c),
      n == null && t.removeAttribute(e),
      (t._value = n)
    return
  }
  let o = !1
  if (n === '' || n == null) {
    const a = typeof t[e]
    a === 'boolean'
      ? (n = aN(n))
      : n == null && a === 'string'
        ? ((n = ''), (o = !0))
        : a === 'number' && ((n = 0), (o = !0))
  }
  try {
    t[e] = n
  } catch {}
  o && t.removeAttribute(s || e)
}
function gD(t, e, n, r) {
  t.addEventListener(e, n, r)
}
function mD(t, e, n, r) {
  t.removeEventListener(e, n, r)
}
const W_ = Symbol('_vei')
function yD(t, e, n, r, s = null) {
  const i = t[W_] || (t[W_] = {}),
    o = i[e]
  if (r && o) o.value = r
  else {
    const [a, c] = wD(e)
    if (r) {
      const u = (i[e] = ED(r, s))
      gD(t, a, u, c)
    } else o && (mD(t, a, o, c), (i[e] = void 0))
  }
}
const K_ = /(?:Once|Passive|Capture)$/
function wD(t) {
  let e
  if (K_.test(t)) {
    e = {}
    let r
    for (; (r = t.match(K_)); )
      (t = t.slice(0, t.length - r[0].length)), (e[r[0].toLowerCase()] = !0)
  }
  return [t[2] === ':' ? t.slice(3) : Au(t.slice(2)), e]
}
let Wy = 0
const bD = Promise.resolve(),
  vD = () => Wy || (bD.then(() => (Wy = 0)), (Wy = Date.now()))
function ED(t, e) {
  const n = r => {
    if (!r._vts) r._vts = Date.now()
    else if (r._vts <= n.attached) return
    ro(AD(r, n.value), e, 5, [r])
  }
  return (n.value = t), (n.attached = vD()), n
}
function AD(t, e) {
  if (_t(e)) {
    const n = t.stopImmediatePropagation
    return (
      (t.stopImmediatePropagation = () => {
        n.call(t), (t._stopped = !0)
      }),
      e.map(r => s => !s._stopped && r && r(s))
    )
  } else return e
}
const V_ = t =>
    t.charCodeAt(0) === 111 &&
    t.charCodeAt(1) === 110 &&
    t.charCodeAt(2) > 96 &&
    t.charCodeAt(2) < 123,
  _D = (t, e, n, r, s, i) => {
    const o = s === 'svg'
    e === 'class'
      ? uD(t, r, o)
      : e === 'style'
        ? fD(t, n, r)
        : Jf(e)
          ? Zv(e) || yD(t, e, n, r, i)
          : (
                e[0] === '.'
                  ? ((e = e.slice(1)), !0)
                  : e[0] === '^'
                    ? ((e = e.slice(1)), !1)
                    : CD(t, e, r, o)
              )
            ? (z_(t, e, r),
              !t.tagName.includes('-') &&
                (e === 'value' || e === 'checked' || e === 'selected') &&
                q_(t, e, r, o, i, e !== 'value'))
            : t._isVueCE && (/[A-Z]/.test(e) || !Hn(r))
              ? z_(t, ai(e), r, i, e)
              : (e === 'true-value'
                  ? (t._trueValue = r)
                  : e === 'false-value' && (t._falseValue = r),
                q_(t, e, r, o))
  }
function CD(t, e, n, r) {
  if (r) return !!(e === 'innerHTML' || e === 'textContent' || (e in t && V_(e) && bt(n)))
  if (
    e === 'spellcheck' ||
    e === 'draggable' ||
    e === 'translate' ||
    e === 'form' ||
    (e === 'list' && t.tagName === 'INPUT') ||
    (e === 'type' && t.tagName === 'TEXTAREA')
  )
    return !1
  if (e === 'width' || e === 'height') {
    const s = t.tagName
    if (s === 'IMG' || s === 'VIDEO' || s === 'CANVAS' || s === 'SOURCE') return !1
  }
  return V_(e) && Hn(n) ? !1 : e in t
}
const wP = Gr({ patchProp: _D }, aD)
let Nh,
  G_ = !1
function SD() {
  return Nh || (Nh = S6(wP))
}
function ID() {
  return (Nh = G_ ? Nh : I6(wP)), (G_ = !0), Nh
}
const xD = (...t) => {
    const e = SD().createApp(...t),
      { mount: n } = e
    return (
      (e.mount = r => {
        const s = vP(r)
        if (!s) return
        const i = e._component
        !bt(i) && !i.render && !i.template && (i.template = s.innerHTML),
          s.nodeType === 1 && (s.textContent = '')
        const o = n(s, !1, bP(s))
        return (
          s instanceof Element && (s.removeAttribute('v-cloak'), s.setAttribute('data-v-app', '')),
          o
        )
      }),
      e
    )
  },
  TD = (...t) => {
    const e = ID().createApp(...t),
      { mount: n } = e
    return (
      (e.mount = r => {
        const s = vP(r)
        if (s) return n(s, !0, bP(s))
      }),
      e
    )
  }
function bP(t) {
  if (t instanceof SVGElement) return 'svg'
  if (typeof MathMLElement == 'function' && t instanceof MathMLElement) return 'mathml'
}
function vP(t) {
  return Hn(t) ? document.querySelector(t) : t
}
const ND =
    /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
  PD =
    /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
  RD = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/
function kD(t, e) {
  if (t === '__proto__' || (t === 'constructor' && e && typeof e == 'object' && 'prototype' in e)) {
    OD(t)
    return
  }
  return e
}
function OD(t) {
  console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`)
}
function BD(t, e = {}) {
  if (typeof t != 'string') return t
  const n = t.trim()
  if (t[0] === '"' && t.endsWith('"') && !t.includes('\\')) return n.slice(1, -1)
  if (n.length <= 9) {
    const r = n.toLowerCase()
    if (r === 'true') return !0
    if (r === 'false') return !1
    if (r === 'undefined') return
    if (r === 'null') return null
    if (r === 'nan') return Number.NaN
    if (r === 'infinity') return Number.POSITIVE_INFINITY
    if (r === '-infinity') return Number.NEGATIVE_INFINITY
  }
  if (!RD.test(t)) {
    if (e.strict) throw new SyntaxError('[destr] Invalid JSON')
    return t
  }
  try {
    if (ND.test(t) || PD.test(t)) {
      if (e.strict) throw new Error('[destr] Possible prototype pollution')
      return JSON.parse(t, kD)
    }
    return JSON.parse(t)
  } catch (r) {
    if (e.strict) throw r
    return t
  }
}
const DD = /#/g,
  MD = /&/g,
  UD = /\//g,
  LD = /=/g,
  vE = /\+/g,
  $D = /%5e/gi,
  FD = /%60/gi,
  jD = /%7c/gi,
  HD = /%20/gi
function qD(t) {
  return encodeURI('' + t).replace(jD, '|')
}
function i1(t) {
  return qD(typeof t == 'string' ? t : JSON.stringify(t))
    .replace(vE, '%2B')
    .replace(HD, '+')
    .replace(DD, '%23')
    .replace(MD, '%26')
    .replace(FD, '`')
    .replace($D, '^')
    .replace(UD, '%2F')
}
function Ky(t) {
  return i1(t).replace(LD, '%3D')
}
function EP(t = '') {
  try {
    return decodeURIComponent('' + t)
  } catch {
    return '' + t
  }
}
function zD(t) {
  return EP(t.replace(vE, ' '))
}
function WD(t) {
  return EP(t.replace(vE, ' '))
}
function KD(t = '') {
  const e = {}
  t[0] === '?' && (t = t.slice(1))
  for (const n of t.split('&')) {
    const r = n.match(/([^=]+)=?(.*)/) || []
    if (r.length < 2) continue
    const s = zD(r[1])
    if (s === '__proto__' || s === 'constructor') continue
    const i = WD(r[2] || '')
    e[s] === void 0 ? (e[s] = i) : Array.isArray(e[s]) ? e[s].push(i) : (e[s] = [e[s], i])
  }
  return e
}
function VD(t, e) {
  return (
    (typeof e == 'number' || typeof e == 'boolean') && (e = String(e)),
    e ? (Array.isArray(e) ? e.map(n => `${Ky(t)}=${i1(n)}`).join('&') : `${Ky(t)}=${i1(e)}`) : Ky(t)
  )
}
function GD(t) {
  return Object.keys(t)
    .filter(e => t[e] !== void 0)
    .map(e => VD(e, t[e]))
    .filter(Boolean)
    .join('&')
}
const QD = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/,
  ZD = /^[\s\w\0+.-]{2,}:([/\\]{2})?/,
  YD = /^([/\\]\s*){2,}[^/\\]/,
  JD = /^\.?\//
function EE(t, e = {}) {
  return (
    typeof e == 'boolean' && (e = { acceptRelative: e }),
    e.strict ? QD.test(t) : ZD.test(t) || (e.acceptRelative ? YD.test(t) : !1)
  )
}
function XD(t = '', e) {
  return t.endsWith('/')
}
function eM(t = '', e) {
  return (XD(t) ? t.slice(0, -1) : t) || '/'
}
function tM(t = '', e) {
  return t.endsWith('/') ? t : t + '/'
}
function nM(t, e) {
  if (sM(e) || EE(t)) return t
  const n = eM(e)
  return t.startsWith(n) ? t : oM(n, t)
}
function rM(t, e) {
  const n = aM(t),
    r = { ...KD(n.search), ...e }
  return (n.search = GD(r)), cM(n)
}
function sM(t) {
  return !t || t === '/'
}
function iM(t) {
  return t && t !== '/'
}
function oM(t, ...e) {
  let n = t || ''
  for (const r of e.filter(s => iM(s)))
    if (n) {
      const s = r.replace(JD, '')
      n = tM(n) + s
    } else n = r
  return n
}
function AP(...t) {
  var o, a, c, u
  const e = /\/(?!\/)/,
    n = t.filter(Boolean),
    r = []
  let s = 0
  for (const l of n)
    if (!(!l || l === '/')) {
      for (const [d, h] of l.split(e).entries())
        if (!(!h || h === '.')) {
          if (h === '..') {
            if (r.length === 1 && EE(r[0])) continue
            r.pop(), s--
            continue
          }
          if (d === 1 && (o = r[r.length - 1]) != null && o.endsWith(':/')) {
            r[r.length - 1] += '/' + h
            continue
          }
          r.push(h), s++
        }
    }
  let i = r.join('/')
  return (
    s >= 0
      ? (a = n[0]) != null && a.startsWith('/') && !i.startsWith('/')
        ? (i = '/' + i)
        : (c = n[0]) != null && c.startsWith('./') && !i.startsWith('./') && (i = './' + i)
      : (i = '../'.repeat(-1 * s) + i),
    (u = n[n.length - 1]) != null && u.endsWith('/') && !i.endsWith('/') && (i += '/'),
    i
  )
}
const _P = Symbol.for('ufo:protocolRelative')
function aM(t = '', e) {
  const n = t.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i)
  if (n) {
    const [, d, h = ''] = n
    return {
      protocol: d.toLowerCase(),
      pathname: h,
      href: d + h,
      auth: '',
      host: '',
      search: '',
      hash: ''
    }
  }
  if (!EE(t, { acceptRelative: !0 })) return Q_(t)
  const [, r = '', s, i = ''] =
    t.replace(/\\/g, '/').match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || []
  let [, o = '', a = ''] = i.match(/([^#/?]*)(.*)?/) || []
  r === 'file:' && (a = a.replace(/\/(?=[A-Za-z]:)/, ''))
  const { pathname: c, search: u, hash: l } = Q_(a)
  return {
    protocol: r.toLowerCase(),
    auth: s ? s.slice(0, Math.max(0, s.length - 1)) : '',
    host: o,
    pathname: c,
    search: u,
    hash: l,
    [_P]: !r
  }
}
function Q_(t = '') {
  const [e = '', n = '', r = ''] = (t.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1)
  return { pathname: e, search: n, hash: r }
}
function cM(t) {
  const e = t.pathname || '',
    n = t.search ? (t.search.startsWith('?') ? '' : '?') + t.search : '',
    r = t.hash || '',
    s = t.auth ? t.auth + '@' : '',
    i = t.host || ''
  return (t.protocol || t[_P] ? (t.protocol || '') + '//' : '') + s + i + e + n + r
}
class uM extends Error {
  constructor(e, n) {
    super(e, n),
      (this.name = 'FetchError'),
      n != null && n.cause && !this.cause && (this.cause = n.cause)
  }
}
function lM(t) {
  var c, u, l, d, h
  const e =
      ((c = t.error) == null ? void 0 : c.message) ||
      ((u = t.error) == null ? void 0 : u.toString()) ||
      '',
    n =
      ((l = t.request) == null ? void 0 : l.method) ||
      ((d = t.options) == null ? void 0 : d.method) ||
      'GET',
    r = ((h = t.request) == null ? void 0 : h.url) || String(t.request) || '/',
    s = `[${n}] ${JSON.stringify(r)}`,
    i = t.response ? `${t.response.status} ${t.response.statusText}` : '<no response>',
    o = `${s}: ${i}${e ? ` ${e}` : ''}`,
    a = new uM(o, t.error ? { cause: t.error } : void 0)
  for (const p of ['request', 'options', 'response'])
    Object.defineProperty(a, p, {
      get() {
        return t[p]
      }
    })
  for (const [p, y] of [
    ['data', '_data'],
    ['status', 'status'],
    ['statusCode', 'status'],
    ['statusText', 'statusText'],
    ['statusMessage', 'statusText']
  ])
    Object.defineProperty(a, p, {
      get() {
        return t.response && t.response[y]
      }
    })
  return a
}
const dM = new Set(Object.freeze(['PATCH', 'POST', 'PUT', 'DELETE']))
function Z_(t = 'GET') {
  return dM.has(t.toUpperCase())
}
function hM(t) {
  if (t === void 0) return !1
  const e = typeof t
  return e === 'string' || e === 'number' || e === 'boolean' || e === null
    ? !0
    : e !== 'object'
      ? !1
      : Array.isArray(t)
        ? !0
        : t.buffer
          ? !1
          : (t.constructor && t.constructor.name === 'Object') || typeof t.toJSON == 'function'
}
const fM = new Set(['image/svg', 'application/xml', 'application/xhtml', 'application/html']),
  pM = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i
function gM(t = '') {
  if (!t) return 'json'
  const e = t.split(';').shift() || ''
  return pM.test(e) ? 'json' : fM.has(e) || e.startsWith('text/') ? 'text' : 'blob'
}
function mM(t, e, n, r) {
  const s = yM(
    (e == null ? void 0 : e.headers) ?? (t == null ? void 0 : t.headers),
    n == null ? void 0 : n.headers,
    r
  )
  let i
  return (
    ((n != null && n.query) ||
      (n != null && n.params) ||
      (e != null && e.params) ||
      (e != null && e.query)) &&
      (i = {
        ...(n == null ? void 0 : n.params),
        ...(n == null ? void 0 : n.query),
        ...(e == null ? void 0 : e.params),
        ...(e == null ? void 0 : e.query)
      }),
    { ...n, ...e, query: i, params: i, headers: s }
  )
}
function yM(t, e, n) {
  if (!e) return new n(t)
  const r = new n(e)
  if (t) for (const [s, i] of Symbol.iterator in t || Array.isArray(t) ? t : new n(t)) r.set(s, i)
  return r
}
async function Lp(t, e) {
  if (e)
    if (Array.isArray(e)) for (const n of e) await n(t)
    else await e(t)
}
const wM = new Set([408, 409, 425, 429, 500, 502, 503, 504]),
  bM = new Set([101, 204, 205, 304])
function CP(t = {}) {
  const {
    fetch: e = globalThis.fetch,
    Headers: n = globalThis.Headers,
    AbortController: r = globalThis.AbortController
  } = t
  async function s(a) {
    const c = (a.error && a.error.name === 'AbortError' && !a.options.timeout) || !1
    if (a.options.retry !== !1 && !c) {
      let l
      typeof a.options.retry == 'number'
        ? (l = a.options.retry)
        : (l = Z_(a.options.method) ? 0 : 1)
      const d = (a.response && a.response.status) || 500
      if (
        l > 0 &&
        (Array.isArray(a.options.retryStatusCodes)
          ? a.options.retryStatusCodes.includes(d)
          : wM.has(d))
      ) {
        const h =
          typeof a.options.retryDelay == 'function'
            ? a.options.retryDelay(a)
            : a.options.retryDelay || 0
        return (
          h > 0 && (await new Promise(p => setTimeout(p, h))),
          i(a.request, { ...a.options, retry: l - 1 })
        )
      }
    }
    const u = lM(a)
    throw (Error.captureStackTrace && Error.captureStackTrace(u, i), u)
  }
  const i = async function (c, u = {}) {
      const l = { request: c, options: mM(c, u, t.defaults, n), response: void 0, error: void 0 }
      l.options.method && (l.options.method = l.options.method.toUpperCase()),
        l.options.onRequest && (await Lp(l, l.options.onRequest)),
        typeof l.request == 'string' &&
          (l.options.baseURL && (l.request = nM(l.request, l.options.baseURL)),
          l.options.query && ((l.request = rM(l.request, l.options.query)), delete l.options.query),
          'query' in l.options && delete l.options.query,
          'params' in l.options && delete l.options.params),
        l.options.body &&
          Z_(l.options.method) &&
          (hM(l.options.body)
            ? ((l.options.body =
                typeof l.options.body == 'string'
                  ? l.options.body
                  : JSON.stringify(l.options.body)),
              (l.options.headers = new n(l.options.headers || {})),
              l.options.headers.has('content-type') ||
                l.options.headers.set('content-type', 'application/json'),
              l.options.headers.has('accept') ||
                l.options.headers.set('accept', 'application/json'))
            : (('pipeTo' in l.options.body && typeof l.options.body.pipeTo == 'function') ||
                typeof l.options.body.pipe == 'function') &&
              ('duplex' in l.options || (l.options.duplex = 'half')))
      let d
      if (!l.options.signal && l.options.timeout) {
        const p = new r()
        ;(d = setTimeout(() => {
          const y = new Error('[TimeoutError]: The operation was aborted due to timeout')
          ;(y.name = 'TimeoutError'), (y.code = 23), p.abort(y)
        }, l.options.timeout)),
          (l.options.signal = p.signal)
      }
      try {
        l.response = await e(l.request, l.options)
      } catch (p) {
        return (
          (l.error = p),
          l.options.onRequestError && (await Lp(l, l.options.onRequestError)),
          await s(l)
        )
      } finally {
        d && clearTimeout(d)
      }
      if (
        (l.response.body || l.response._bodyInit) &&
        !bM.has(l.response.status) &&
        l.options.method !== 'HEAD'
      ) {
        const p =
          (l.options.parseResponse ? 'json' : l.options.responseType) ||
          gM(l.response.headers.get('content-type') || '')
        switch (p) {
          case 'json': {
            const y = await l.response.text(),
              m = l.options.parseResponse || BD
            l.response._data = m(y)
            break
          }
          case 'stream': {
            l.response._data = l.response.body || l.response._bodyInit
            break
          }
          default:
            l.response._data = await l.response[p]()
        }
      }
      return (
        l.options.onResponse && (await Lp(l, l.options.onResponse)),
        !l.options.ignoreResponseError && l.response.status >= 400 && l.response.status < 600
          ? (l.options.onResponseError && (await Lp(l, l.options.onResponseError)), await s(l))
          : l.response
      )
    },
    o = async function (c, u) {
      return (await i(c, u))._data
    }
  return (
    (o.raw = i),
    (o.native = (...a) => e(...a)),
    (o.create = (a = {}, c = {}) =>
      CP({ ...t, ...c, defaults: { ...t.defaults, ...c.defaults, ...a } })),
    o
  )
}
const em = (function () {
    if (typeof globalThis < 'u') return globalThis
    if (typeof self < 'u') return self
    if (typeof window < 'u') return window
    if (typeof global < 'u') return global
    throw new Error('unable to locate global object')
  })(),
  vM = em.fetch
    ? (...t) => em.fetch(...t)
    : () => Promise.reject(new Error('[ofetch] global.fetch is not supported!')),
  EM = em.Headers,
  AM = em.AbortController,
  _M = CP({ fetch: vM, Headers: EM, AbortController: AM }),
  CM = _M,
  SM = () => {
    var t
    return ((t = window == null ? void 0 : window.__NUXT__) == null ? void 0 : t.config) || {}
  },
  tm = SM().app,
  IM = () => tm.baseURL,
  xM = () => tm.buildAssetsDir,
  AE = (...t) => AP(_E(), xM(), ...t),
  _E = (...t) => {
    const e = tm.cdnURL || tm.baseURL
    return t.length ? AP(e, ...t) : e
  }
;(globalThis.__buildAssetsURL = AE), (globalThis.__publicAssetsURL = _E)
globalThis.$fetch || (globalThis.$fetch = CM.create({ baseURL: IM() }))
function o1(t, e = {}, n) {
  for (const r in t) {
    const s = t[r],
      i = n ? `${n}:${r}` : r
    typeof s == 'object' && s !== null ? o1(s, e, i) : typeof s == 'function' && (e[i] = s)
  }
  return e
}
const TM = { run: t => t() },
  NM = () => TM,
  SP = typeof console.createTask < 'u' ? console.createTask : NM
function PM(t, e) {
  const n = e.shift(),
    r = SP(n)
  return t.reduce((s, i) => s.then(() => r.run(() => i(...e))), Promise.resolve())
}
function RM(t, e) {
  const n = e.shift(),
    r = SP(n)
  return Promise.all(t.map(s => r.run(() => s(...e))))
}
function Vy(t, e) {
  for (const n of [...t]) n(e)
}
class kM {
  constructor() {
    ;(this._hooks = {}),
      (this._before = void 0),
      (this._after = void 0),
      (this._deprecatedMessages = void 0),
      (this._deprecatedHooks = {}),
      (this.hook = this.hook.bind(this)),
      (this.callHook = this.callHook.bind(this)),
      (this.callHookWith = this.callHookWith.bind(this))
  }
  hook(e, n, r = {}) {
    if (!e || typeof n != 'function') return () => {}
    const s = e
    let i
    for (; this._deprecatedHooks[e]; ) (i = this._deprecatedHooks[e]), (e = i.to)
    if (i && !r.allowDeprecated) {
      let o = i.message
      o || (o = `${s} hook has been deprecated` + (i.to ? `, please use ${i.to}` : '')),
        this._deprecatedMessages || (this._deprecatedMessages = new Set()),
        this._deprecatedMessages.has(o) || (console.warn(o), this._deprecatedMessages.add(o))
    }
    if (!n.name)
      try {
        Object.defineProperty(n, 'name', {
          get: () => '_' + e.replace(/\W+/g, '_') + '_hook_cb',
          configurable: !0
        })
      } catch {}
    return (
      (this._hooks[e] = this._hooks[e] || []),
      this._hooks[e].push(n),
      () => {
        n && (this.removeHook(e, n), (n = void 0))
      }
    )
  }
  hookOnce(e, n) {
    let r,
      s = (...i) => (typeof r == 'function' && r(), (r = void 0), (s = void 0), n(...i))
    return (r = this.hook(e, s)), r
  }
  removeHook(e, n) {
    if (this._hooks[e]) {
      const r = this._hooks[e].indexOf(n)
      r !== -1 && this._hooks[e].splice(r, 1), this._hooks[e].length === 0 && delete this._hooks[e]
    }
  }
  deprecateHook(e, n) {
    this._deprecatedHooks[e] = typeof n == 'string' ? { to: n } : n
    const r = this._hooks[e] || []
    delete this._hooks[e]
    for (const s of r) this.hook(e, s)
  }
  deprecateHooks(e) {
    Object.assign(this._deprecatedHooks, e)
    for (const n in e) this.deprecateHook(n, e[n])
  }
  addHooks(e) {
    const n = o1(e),
      r = Object.keys(n).map(s => this.hook(s, n[s]))
    return () => {
      for (const s of r.splice(0, r.length)) s()
    }
  }
  removeHooks(e) {
    const n = o1(e)
    for (const r in n) this.removeHook(r, n[r])
  }
  removeAllHooks() {
    for (const e in this._hooks) delete this._hooks[e]
  }
  callHook(e, ...n) {
    return n.unshift(e), this.callHookWith(PM, e, ...n)
  }
  callHookParallel(e, ...n) {
    return n.unshift(e), this.callHookWith(RM, e, ...n)
  }
  callHookWith(e, n, ...r) {
    const s = this._before || this._after ? { name: n, args: r, context: {} } : void 0
    this._before && Vy(this._before, s)
    const i = e(n in this._hooks ? [...this._hooks[n]] : [], r)
    return i instanceof Promise
      ? i.finally(() => {
          this._after && s && Vy(this._after, s)
        })
      : (this._after && s && Vy(this._after, s), i)
  }
  beforeEach(e) {
    return (
      (this._before = this._before || []),
      this._before.push(e),
      () => {
        if (this._before !== void 0) {
          const n = this._before.indexOf(e)
          n !== -1 && this._before.splice(n, 1)
        }
      }
    )
  }
  afterEach(e) {
    return (
      (this._after = this._after || []),
      this._after.push(e),
      () => {
        if (this._after !== void 0) {
          const n = this._after.indexOf(e)
          n !== -1 && this._after.splice(n, 1)
        }
      }
    )
  }
}
function IP() {
  return new kM()
}
function OM(t = {}) {
  let e,
    n = !1
  const r = o => {
    if (e && e !== o) throw new Error('Context conflict')
  }
  let s
  if (t.asyncContext) {
    const o = t.AsyncLocalStorage || globalThis.AsyncLocalStorage
    o ? (s = new o()) : console.warn('[unctx] `AsyncLocalStorage` is not provided.')
  }
  const i = () => {
    if (s) {
      const o = s.getStore()
      if (o !== void 0) return o
    }
    return e
  }
  return {
    use: () => {
      const o = i()
      if (o === void 0) throw new Error('Context is not available')
      return o
    },
    tryUse: () => i(),
    set: (o, a) => {
      a || r(o), (e = o), (n = !0)
    },
    unset: () => {
      ;(e = void 0), (n = !1)
    },
    call: (o, a) => {
      r(o), (e = o)
      try {
        return s ? s.run(o, a) : a()
      } finally {
        n || (e = void 0)
      }
    },
    async callAsync(o, a) {
      e = o
      const c = () => {
          e = o
        },
        u = () => (e === o ? c : void 0)
      a1.add(u)
      try {
        const l = s ? s.run(o, a) : a()
        return n || (e = void 0), await l
      } finally {
        a1.delete(u)
      }
    }
  }
}
function BM(t = {}) {
  const e = {}
  return {
    get(n, r = {}) {
      return e[n] || (e[n] = OM({ ...t, ...r })), e[n]
    }
  }
}
const nm =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
        ? self
        : typeof global < 'u'
          ? global
          : typeof window < 'u'
            ? window
            : {},
  Y_ = '__unctx__',
  DM = nm[Y_] || (nm[Y_] = BM()),
  MM = (t, e = {}) => DM.get(t, e),
  J_ = '__unctx_async_handlers__',
  a1 = nm[J_] || (nm[J_] = new Set())
function xP(t) {
  const e = []
  for (const s of a1) {
    const i = s()
    i && e.push(i)
  }
  const n = () => {
    for (const s of e) s()
  }
  let r = t()
  return (
    r &&
      typeof r == 'object' &&
      'catch' in r &&
      (r = r.catch(s => {
        throw (n(), s)
      })),
    [r, n]
  )
}
const _ge = { componentName: 'NuxtLink', prefetch: !0, prefetchOn: { visibility: !0 } },
  UM = null,
  LM = '#__nuxt',
  TP = 'nuxt-app',
  X_ = 36e5,
  $M = 'vite:preloadError'
function NP(t = TP) {
  return MM(t, { asyncContext: !1 })
}
const FM = '__nuxt_plugin'
function jM(t) {
  var s
  let e = 0
  const n = {
    _id: t.id || TP || 'nuxt-app',
    _scope: mB(),
    provide: void 0,
    globalName: 'nuxt',
    versions: {
      get nuxt() {
        return '3.16.0'
      },
      get vue() {
        return n.vueApp.version
      }
    },
    payload: hl({
      ...(((s = t.ssrContext) == null ? void 0 : s.payload) || {}),
      data: hl({}),
      state: zs({}),
      once: new Set(),
      _errors: hl({})
    }),
    static: { data: {} },
    runWithContext(i) {
      return n._scope.active && !dN() ? n._scope.run(() => eC(n, i)) : eC(n, i)
    },
    isHydrating: !0,
    deferHydration() {
      if (!n.isHydrating) return () => {}
      e++
      let i = !1
      return () => {
        if (!i && ((i = !0), e--, e === 0))
          return (n.isHydrating = !1), n.callHook('app:suspense:resolve')
      }
    },
    _asyncDataPromises: {},
    _asyncData: hl({}),
    _payloadRevivers: {},
    ...t
  }
  {
    const i = window.__NUXT__
    if (i)
      for (const o in i)
        switch (o) {
          case 'data':
          case 'state':
          case '_errors':
            Object.assign(n.payload[o], i[o])
            break
          default:
            n.payload[o] = i[o]
        }
  }
  ;(n.hooks = IP()),
    (n.hook = n.hooks.hook),
    (n.callHook = n.hooks.callHook),
    (n.provide = (i, o) => {
      const a = '$' + i
      $p(n, a, o), $p(n.vueApp.config.globalProperties, a, o)
    }),
    $p(n.vueApp, '$nuxt', n),
    $p(n.vueApp.config.globalProperties, '$nuxt', n)
  {
    window.addEventListener($M, o => {
      n.callHook('app:chunkError', { error: o.payload }),
        (n.isHydrating || o.payload.message.includes('Unable to preload CSS')) && o.preventDefault()
    }),
      window.useNuxtApp || (window.useNuxtApp = Pr)
    const i = n.hook('app:error', (...o) => {
      console.error('[nuxt] error caught during app initialization', ...o)
    })
    n.hook('app:mounted', i)
  }
  const r = n.payload.config
  return n.provide('config', r), n
}
function HM(t, e) {
  e.hooks && t.hooks.addHooks(e.hooks)
}
async function qM(t, e) {
  if (typeof e == 'function') {
    const { provide: n } = (await t.runWithContext(() => e(t))) || {}
    if (n && typeof n == 'object') for (const r in n) t.provide(r, n[r])
  }
}
async function zM(t, e) {
  const n = [],
    r = [],
    s = [],
    i = []
  let o = 0
  async function a(c) {
    var l
    const u =
      ((l = c.dependsOn) == null
        ? void 0
        : l.filter(d => e.some(h => h._name === d) && !n.includes(d))) ?? []
    if (u.length > 0) r.push([new Set(u), c])
    else {
      const d = qM(t, c).then(async () => {
        c._name &&
          (n.push(c._name),
          await Promise.all(
            r.map(async ([h, p]) => {
              h.has(c._name) && (h.delete(c._name), h.size === 0 && (o++, await a(p)))
            })
          ))
      })
      c.parallel ? s.push(d.catch(h => i.push(h))) : await d
    }
  }
  for (const c of e) HM(t, c)
  for (const c of e) await a(c)
  if ((await Promise.all(s), o)) for (let c = 0; c < o; c++) await Promise.all(s)
  if (i.length) throw i[0]
}
function po(t) {
  if (typeof t == 'function') return t
  const e = t._name || t.name
  return delete t.name, Object.assign(t.setup || (() => {}), t, { [FM]: !0, _name: e })
}
function eC(t, e, n) {
  const r = () => e()
  return NP(t._id).set(t), t.vueApp.runWithContext(r)
}
function WM(t) {
  var n
  let e
  return (
    gE() && (e = (n = fP()) == null ? void 0 : n.appContext.app.$nuxt),
    e || (e = NP(t).tryUse()),
    e || null
  )
}
function Pr(t) {
  const e = WM(t)
  if (!e) throw new Error('[nuxt] instance unavailable')
  return e
}
function Gh(t) {
  return Pr().$config
}
function $p(t, e, n) {
  Object.defineProperty(t, e, { get: () => n })
}
const KM = /#/g,
  VM = /&/g,
  GM = /\//g,
  QM = /=/g,
  CE = /\+/g,
  ZM = /%5e/gi,
  YM = /%60/gi,
  JM = /%7c/gi,
  XM = /%20/gi
function e4(t) {
  return encodeURI('' + t).replace(JM, '|')
}
function c1(t) {
  return e4(typeof t == 'string' ? t : JSON.stringify(t))
    .replace(CE, '%2B')
    .replace(XM, '+')
    .replace(KM, '%23')
    .replace(VM, '%26')
    .replace(YM, '`')
    .replace(ZM, '^')
    .replace(GM, '%2F')
}
function Gy(t) {
  return c1(t).replace(QM, '%3D')
}
function rm(t = '') {
  try {
    return decodeURIComponent('' + t)
  } catch {
    return '' + t
  }
}
function t4(t) {
  return rm(t.replace(CE, ' '))
}
function n4(t) {
  return rm(t.replace(CE, ' '))
}
function SE(t = '') {
  const e = Object.create(null)
  t[0] === '?' && (t = t.slice(1))
  for (const n of t.split('&')) {
    const r = n.match(/([^=]+)=?(.*)/) || []
    if (r.length < 2) continue
    const s = t4(r[1])
    if (s === '__proto__' || s === 'constructor') continue
    const i = n4(r[2] || '')
    e[s] === void 0 ? (e[s] = i) : Array.isArray(e[s]) ? e[s].push(i) : (e[s] = [e[s], i])
  }
  return e
}
function r4(t, e) {
  return (
    (typeof e == 'number' || typeof e == 'boolean') && (e = String(e)),
    e ? (Array.isArray(e) ? e.map(n => `${Gy(t)}=${c1(n)}`).join('&') : `${Gy(t)}=${c1(e)}`) : Gy(t)
  )
}
function PP(t) {
  return Object.keys(t)
    .filter(e => t[e] !== void 0)
    .map(e => r4(e, t[e]))
    .filter(Boolean)
    .join('&')
}
const s4 = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/,
  i4 = /^[\s\w\0+.-]{2,}:([/\\]{2})?/,
  o4 = /^([/\\]\s*){2,}[^/\\]/,
  a4 = /^[\s\0]*(blob|data|javascript|vbscript):$/i,
  c4 = /\/$|\/\?|\/#/,
  u4 = /^\.?\//
function o0(t, e = {}) {
  return (
    typeof e == 'boolean' && (e = { acceptRelative: e }),
    e.strict ? s4.test(t) : i4.test(t) || (e.acceptRelative ? o4.test(t) : !1)
  )
}
function l4(t) {
  return !!t && a4.test(t)
}
function u1(t = '', e) {
  return e ? c4.test(t) : t.endsWith('/')
}
function RP(t = '', e) {
  if (!e) return (u1(t) ? t.slice(0, -1) : t) || '/'
  if (!u1(t, !0)) return t || '/'
  let n = t,
    r = ''
  const s = t.indexOf('#')
  s !== -1 && ((n = t.slice(0, s)), (r = t.slice(s)))
  const [i, ...o] = n.split('?')
  return (
    ((i.endsWith('/') ? i.slice(0, -1) : i) || '/') + (o.length > 0 ? `?${o.join('?')}` : '') + r
  )
}
function l1(t = '', e) {
  if (!e) return t.endsWith('/') ? t : t + '/'
  if (u1(t, !0)) return t || '/'
  let n = t,
    r = ''
  const s = t.indexOf('#')
  if (s !== -1 && ((n = t.slice(0, s)), (r = t.slice(s)), !n)) return r
  const [i, ...o] = n.split('?')
  return i + '/' + (o.length > 0 ? `?${o.join('?')}` : '') + r
}
function d4(t = '') {
  return t.startsWith('/')
}
function tC(t = '') {
  return d4(t) ? t : '/' + t
}
function h4(t, e) {
  if (p4(e)) return t
  const n = RP(e)
  if (!t.startsWith(n)) return t
  const r = t.slice(n.length)
  return r[0] === '/' ? r : '/' + r
}
function f4(t, e) {
  const n = xE(t),
    r = { ...SE(n.search), ...e }
  return (n.search = PP(r)), OP(n)
}
function p4(t) {
  return !t || t === '/'
}
function g4(t) {
  return t && t !== '/'
}
function IE(t, ...e) {
  let n = t || ''
  for (const r of e.filter(s => g4(s)))
    if (n) {
      const s = r.replace(u4, '')
      n = l1(n) + s
    } else n = r
  return n
}
function m4(t, e, n = {}) {
  return (
    n.trailingSlash || ((t = l1(t)), (e = l1(e))),
    n.leadingSlash || ((t = tC(t)), (e = tC(e))),
    n.encoding || ((t = rm(t)), (e = rm(e))),
    t === e
  )
}
const kP = Symbol.for('ufo:protocolRelative')
function xE(t = '', e) {
  const n = t.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i)
  if (n) {
    const [, d, h = ''] = n
    return {
      protocol: d.toLowerCase(),
      pathname: h,
      href: d + h,
      auth: '',
      host: '',
      search: '',
      hash: ''
    }
  }
  if (!o0(t, { acceptRelative: !0 })) return e ? xE(e + t) : nC(t)
  const [, r = '', s, i = ''] =
    t.replace(/\\/g, '/').match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || []
  let [, o = '', a = ''] = i.match(/([^#/?]*)(.*)?/) || []
  r === 'file:' && (a = a.replace(/\/(?=[A-Za-z]:)/, ''))
  const { pathname: c, search: u, hash: l } = nC(a)
  return {
    protocol: r.toLowerCase(),
    auth: s ? s.slice(0, Math.max(0, s.length - 1)) : '',
    host: o,
    pathname: c,
    search: u,
    hash: l,
    [kP]: !r
  }
}
function nC(t = '') {
  const [e = '', n = '', r = ''] = (t.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1)
  return { pathname: e, search: n, hash: r }
}
function OP(t) {
  const e = t.pathname || '',
    n = t.search ? (t.search.startsWith('?') ? '' : '?') + t.search : '',
    r = t.hash || '',
    s = t.auth ? t.auth + '@' : '',
    i = t.host || ''
  return (t.protocol || t[kP] ? (t.protocol || '') + '//' : '') + s + i + e + n + r
}
function y4(t, e) {
  return { ctx: { table: t }, matchAll: n => DP(n, t) }
}
function BP(t) {
  const e = {}
  for (const n in t)
    e[n] =
      n === 'dynamic'
        ? new Map(Object.entries(t[n]).map(([r, s]) => [r, BP(s)]))
        : new Map(Object.entries(t[n]))
  return e
}
function w4(t) {
  return y4(BP(t))
}
function DP(t, e, n) {
  t.endsWith('/') && (t = t.slice(0, -1) || '/')
  const r = []
  for (const [i, o] of rC(e.wildcard)) (t === i || t.startsWith(i + '/')) && r.push(o)
  for (const [i, o] of rC(e.dynamic))
    if (t.startsWith(i + '/')) {
      const a = '/' + t.slice(i.length).split('/').splice(2).join('/')
      r.push(...DP(a, o))
    }
  const s = e.static.get(t)
  return s && r.push(s), r.filter(Boolean)
}
function rC(t) {
  return [...t.entries()].sort((e, n) => e[0].length - n[0].length)
}
const b4 =
    /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
  v4 =
    /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
  E4 = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/
function A4(t, e) {
  if (t === '__proto__' || (t === 'constructor' && e && typeof e == 'object' && 'prototype' in e)) {
    _4(t)
    return
  }
  return e
}
function _4(t) {
  console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`)
}
function Bc(t, e = {}) {
  if (typeof t != 'string') return t
  if (t[0] === '"' && t[t.length - 1] === '"' && t.indexOf('\\') === -1) return t.slice(1, -1)
  const n = t.trim()
  if (n.length <= 9)
    switch (n.toLowerCase()) {
      case 'true':
        return !0
      case 'false':
        return !1
      case 'undefined':
        return
      case 'null':
        return null
      case 'nan':
        return Number.NaN
      case 'infinity':
        return Number.POSITIVE_INFINITY
      case '-infinity':
        return Number.NEGATIVE_INFINITY
    }
  if (!E4.test(t)) {
    if (e.strict) throw new SyntaxError('[destr] Invalid JSON')
    return t
  }
  try {
    if (b4.test(t) || v4.test(t)) {
      if (e.strict) throw new Error('[destr] Possible prototype pollution')
      return JSON.parse(t, A4)
    }
    return JSON.parse(t)
  } catch (r) {
    if (e.strict) throw r
    return t
  }
}
function Qy(t) {
  if (t === null || typeof t != 'object') return !1
  const e = Object.getPrototypeOf(t)
  return (e !== null && e !== Object.prototype && Object.getPrototypeOf(e) !== null) ||
    Symbol.iterator in t
    ? !1
    : Symbol.toStringTag in t
      ? Object.prototype.toString.call(t) === '[object Module]'
      : !0
}
function d1(t, e, n = '.', r) {
  if (!Qy(e)) return d1(t, {}, n, r)
  const s = Object.assign({}, e)
  for (const i in t) {
    if (i === '__proto__' || i === 'constructor') continue
    const o = t[i]
    o != null &&
      ((r && r(s, i, o, n)) ||
        (Array.isArray(o) && Array.isArray(s[i])
          ? (s[i] = [...o, ...s[i]])
          : Qy(o) && Qy(s[i])
            ? (s[i] = d1(o, s[i], (n ? `${n}.` : '') + i.toString(), r))
            : (s[i] = o)))
  }
  return s
}
function C4(t) {
  return (...e) => e.reduce((n, r) => d1(n, r, '', t), {})
}
const S4 = C4()
function I4(t, e) {
  try {
    return e in t
  } catch {
    return !1
  }
}
class h1 extends Error {
  constructor(n, r = {}) {
    super(n, r)
    Cn(this, 'statusCode', 500)
    Cn(this, 'fatal', !1)
    Cn(this, 'unhandled', !1)
    Cn(this, 'statusMessage')
    Cn(this, 'data')
    Cn(this, 'cause')
    r.cause && !this.cause && (this.cause = r.cause)
  }
  toJSON() {
    const n = { message: this.message, statusCode: f1(this.statusCode, 500) }
    return (
      this.statusMessage && (n.statusMessage = MP(this.statusMessage)),
      this.data !== void 0 && (n.data = this.data),
      n
    )
  }
}
Cn(h1, '__h3_error__', !0)
function x4(t) {
  if (typeof t == 'string') return new h1(t)
  if (T4(t)) return t
  const e = new h1(t.message ?? t.statusMessage ?? '', { cause: t.cause || t })
  if (I4(t, 'stack'))
    try {
      Object.defineProperty(e, 'stack', {
        get() {
          return t.stack
        }
      })
    } catch {
      try {
        e.stack = t.stack
      } catch {}
    }
  if (
    (t.data && (e.data = t.data),
    t.statusCode
      ? (e.statusCode = f1(t.statusCode, e.statusCode))
      : t.status && (e.statusCode = f1(t.status, e.statusCode)),
    t.statusMessage
      ? (e.statusMessage = t.statusMessage)
      : t.statusText && (e.statusMessage = t.statusText),
    e.statusMessage)
  ) {
    const n = e.statusMessage
    MP(e.statusMessage) !== n &&
      console.warn(
        '[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.'
      )
  }
  return (
    t.fatal !== void 0 && (e.fatal = t.fatal),
    t.unhandled !== void 0 && (e.unhandled = t.unhandled),
    e
  )
}
function T4(t) {
  var e
  return ((e = t == null ? void 0 : t.constructor) == null ? void 0 : e.__h3_error__) === !0
}
const N4 = /[^\u0009\u0020-\u007E]/g
function MP(t = '') {
  return t.replace(N4, '')
}
function f1(t, e = 200) {
  return !t || (typeof t == 'string' && (t = Number.parseInt(t, 10)), t < 100 || t > 999) ? e : t
}
const UP = Symbol('route'),
  ru = () => {
    var t
    return (t = Pr()) == null ? void 0 : t.$router
  },
  LP = () => (gE() ? xl(UP, Pr()._route) : Pr()._route)
const P4 = () => {
    try {
      if (Pr()._processingMiddleware) return !0
    } catch {
      return !1
    }
    return !1
  },
  R4 = (t, e) => {
    t || (t = '/')
    const n = typeof t == 'string' ? t : 'path' in t ? k4(t) : ru().resolve(t).href
    if (e != null && e.open) {
      const { target: c = '_blank', windowFeatures: u = {} } = e.open,
        l = Object.entries(u)
          .filter(([d, h]) => h !== void 0)
          .map(([d, h]) => `${d.toLowerCase()}=${h}`)
          .join(', ')
      return open(n, c, l), Promise.resolve()
    }
    const r = o0(n, { acceptRelative: !0 }),
      s = (e == null ? void 0 : e.external) || r
    if (s) {
      if (!(e != null && e.external))
        throw new Error(
          'Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.'
        )
      const { protocol: c } = new URL(n, window.location.href)
      if (c && l4(c)) throw new Error(`Cannot navigate to a URL with '${c}' protocol.`)
    }
    const i = P4()
    if (!s && i) {
      if (e != null && e.replace) {
        if (typeof t == 'string') {
          const { pathname: c, search: u, hash: l } = xE(t)
          return { path: c, ...(u && { query: SE(u) }), ...(l && { hash: l }), replace: !0 }
        }
        return { ...t, replace: !0 }
      }
      return t
    }
    const o = ru(),
      a = Pr()
    return s
      ? (a._scope.stop(),
        e != null && e.replace ? location.replace(n) : (location.href = n),
        i ? (a.isHydrating ? new Promise(() => {}) : !1) : Promise.resolve())
      : e != null && e.replace
        ? o.replace(t)
        : o.push(t)
  }
function k4(t) {
  return f4(t.path || '', t.query || {}) + (t.hash || '')
}
const $P = '__nuxt_error',
  TE = () => HB(Pr().payload, 'error'),
  O4 = t => {
    const e = NE(t)
    try {
      const n = Pr(),
        r = TE()
      n.hooks.callHook('app:error', e), r.value || (r.value = e)
    } catch {
      throw e
    }
    return e
  },
  B4 = async (t = {}) => {
    const e = Pr(),
      n = TE()
    e.callHook('app:error:cleared', t),
      t.redirect && (await ru().replace(t.redirect)),
      (n.value = UM)
  },
  D4 = t => !!t && typeof t == 'object' && $P in t,
  NE = t => {
    const e = x4(t)
    return Object.defineProperty(e, $P, { value: !0, configurable: !1, writable: !1 }), e
  }
function sC(t) {
  const e = U4(t),
    n = new ArrayBuffer(e.length),
    r = new DataView(n)
  for (let s = 0; s < n.byteLength; s++) r.setUint8(s, e.charCodeAt(s))
  return n
}
const M4 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
function U4(t) {
  t.length % 4 === 0 && (t = t.replace(/==?$/, ''))
  let e = '',
    n = 0,
    r = 0
  for (let s = 0; s < t.length; s++)
    (n <<= 6),
      (n |= M4.indexOf(t[s])),
      (r += 6),
      r === 24 &&
        ((e += String.fromCharCode((n & 16711680) >> 16)),
        (e += String.fromCharCode((n & 65280) >> 8)),
        (e += String.fromCharCode(n & 255)),
        (n = r = 0))
  return (
    r === 12
      ? ((n >>= 4), (e += String.fromCharCode(n)))
      : r === 18 &&
        ((n >>= 2),
        (e += String.fromCharCode((n & 65280) >> 8)),
        (e += String.fromCharCode(n & 255))),
    e
  )
}
const L4 = -1,
  $4 = -2,
  F4 = -3,
  j4 = -4,
  H4 = -5,
  q4 = -6
function z4(t, e) {
  return W4(JSON.parse(t), e)
}
function W4(t, e) {
  if (typeof t == 'number') return s(t, !0)
  if (!Array.isArray(t) || t.length === 0) throw new Error('Invalid input')
  const n = t,
    r = Array(n.length)
  function s(i, o = !1) {
    if (i === L4) return
    if (i === F4) return NaN
    if (i === j4) return 1 / 0
    if (i === H4) return -1 / 0
    if (i === q4) return -0
    if (o) throw new Error('Invalid input')
    if (i in r) return r[i]
    const a = n[i]
    if (!a || typeof a != 'object') r[i] = a
    else if (Array.isArray(a))
      if (typeof a[0] == 'string') {
        const c = a[0],
          u = e == null ? void 0 : e[c]
        if (u) return (r[i] = u(s(a[1])))
        switch (c) {
          case 'Date':
            r[i] = new Date(a[1])
            break
          case 'Set':
            const l = new Set()
            r[i] = l
            for (let p = 1; p < a.length; p += 1) l.add(s(a[p]))
            break
          case 'Map':
            const d = new Map()
            r[i] = d
            for (let p = 1; p < a.length; p += 2) d.set(s(a[p]), s(a[p + 1]))
            break
          case 'RegExp':
            r[i] = new RegExp(a[1], a[2])
            break
          case 'Object':
            r[i] = Object(a[1])
            break
          case 'BigInt':
            r[i] = BigInt(a[1])
            break
          case 'null':
            const h = Object.create(null)
            r[i] = h
            for (let p = 1; p < a.length; p += 2) h[a[p]] = s(a[p + 1])
            break
          case 'Int8Array':
          case 'Uint8Array':
          case 'Uint8ClampedArray':
          case 'Int16Array':
          case 'Uint16Array':
          case 'Int32Array':
          case 'Uint32Array':
          case 'Float32Array':
          case 'Float64Array':
          case 'BigInt64Array':
          case 'BigUint64Array': {
            const p = globalThis[c],
              y = a[1],
              m = sC(y),
              b = new p(m)
            r[i] = b
            break
          }
          case 'ArrayBuffer': {
            const p = a[1],
              y = sC(p)
            r[i] = y
            break
          }
          default:
            throw new Error(`Unknown type ${c}`)
        }
      } else {
        const c = new Array(a.length)
        r[i] = c
        for (let u = 0; u < a.length; u += 1) {
          const l = a[u]
          l !== $4 && (c[u] = s(l))
        }
      }
    else {
      const c = {}
      r[i] = c
      for (const u in a) {
        const l = a[u]
        c[u] = s(l)
      }
    }
    return r[i]
  }
  return s(0)
}
const K4 = new Set(['link', 'style', 'script', 'noscript']),
  V4 = new Set(['title', 'titleTemplate', 'script', 'style', 'noscript']),
  iC = new Set(['base', 'meta', 'link', 'style', 'script', 'noscript']),
  G4 = new Set([
    'title',
    'base',
    'htmlAttrs',
    'bodyAttrs',
    'meta',
    'link',
    'style',
    'script',
    'noscript'
  ]),
  Q4 = new Set(['base', 'title', 'titleTemplate', 'bodyAttrs', 'htmlAttrs', 'templateParams']),
  Z4 = new Set([
    'key',
    'tagPosition',
    'tagPriority',
    'tagDuplicateStrategy',
    'innerHTML',
    'textContent',
    'processTemplateParams'
  ]),
  Y4 = new Set(['templateParams', 'htmlAttrs', 'bodyAttrs']),
  J4 = new Set([
    'theme-color',
    'google-site-verification',
    'og',
    'article',
    'book',
    'profile',
    'twitter',
    'author'
  ]),
  X4 = ['name', 'property', 'http-equiv']
function FP(t) {
  const e = t.split(':')[1]
  return J4.has(e)
}
function p1(t) {
  const { props: e, tag: n } = t
  if (Q4.has(n)) return n
  if (n === 'link' && e.rel === 'canonical') return 'canonical'
  if (e.charset) return 'charset'
  if (t.tag === 'meta') {
    for (const r of X4) if (e[r] !== void 0) return `${n}:${e[r]}`
  }
  if (t.key) return `${n}:key:${t.key}`
  if (e.id) return `${n}:id:${e.id}`
  if (V4.has(n)) {
    const r = t.textContent || t.innerHTML
    if (r) return `${n}:content:${r}`
  }
}
function oC(t) {
  const e = t._h || t._d
  if (e) return e
  const n = t.textContent || t.innerHTML
  return (
    n ||
    `${t.tag}:${Object.entries(t.props)
      .map(([r, s]) => `${r}:${String(s)}`)
      .join(',')}`
  )
}
function sm(t, e, n) {
  typeof t === 'function' &&
    (!n || (n !== 'titleTemplate' && !(n[0] === 'o' && n[1] === 'n'))) &&
    (t = t())
  let s
  if ((e && (s = e(n, t)), Array.isArray(s))) return s.map(i => sm(i, e))
  if ((s == null ? void 0 : s.constructor) === Object) {
    const i = {}
    for (const o of Object.keys(s)) i[o] = sm(s[o], e, o)
    return i
  }
  return s
}
function eU(t, e) {
  const n = t === 'style' ? new Map() : new Set()
  function r(s) {
    const i = s.trim()
    if (i)
      if (t === 'style') {
        const [o, ...a] = i.split(':').map(c => c.trim())
        o && a.length && n.set(o, a.join(':'))
      } else
        i.split(' ')
          .filter(Boolean)
          .forEach(o => n.add(o))
  }
  return (
    typeof e == 'string'
      ? t === 'style'
        ? e.split(';').forEach(r)
        : r(e)
      : Array.isArray(e)
        ? e.forEach(s => r(s))
        : e &&
          typeof e == 'object' &&
          Object.entries(e).forEach(([s, i]) => {
            i && i !== 'false' && (t === 'style' ? n.set(s.trim(), i) : r(s))
          }),
    n
  )
}
function jP(t, e) {
  return (
    (t.props = t.props || {}),
    e &&
      Object.entries(e).forEach(([n, r]) => {
        if (r === null) {
          t.props[n] = null
          return
        }
        if (n === 'class' || n === 'style') {
          t.props[n] = eU(n, r)
          return
        }
        if (Z4.has(n)) {
          if (['textContent', 'innerHTML'].includes(n) && typeof r == 'object') {
            let o = e.type
            if (
              (e.type || (o = 'application/json'),
              !(o != null && o.endsWith('json')) && o !== 'speculationrules')
            )
              return
            ;(e.type = o), (t.props.type = o), (t[n] = JSON.stringify(r))
          } else t[n] = r
          return
        }
        const s = String(r),
          i = n.startsWith('data-')
        s === 'true' || s === ''
          ? (t.props[n] = i ? s : !0)
          : !r && i && s === 'false'
            ? (t.props[n] = 'false')
            : r !== void 0 && (t.props[n] = r)
      }),
    t
  )
}
function tU(t, e) {
  const n =
      typeof e == 'object' && typeof e != 'function'
        ? e
        : {
            [t === 'script' || t === 'noscript' || t === 'style' ? 'innerHTML' : 'textContent']: e
          },
    r = jP({ tag: t, props: {} }, n)
  return (
    r.key && K4.has(r.tag) && (r.props['data-hid'] = r._h = r.key),
    r.tag === 'script' &&
      typeof r.innerHTML == 'object' &&
      ((r.innerHTML = JSON.stringify(r.innerHTML)),
      (r.props.type = r.props.type || 'application/json')),
    Array.isArray(r.props.content)
      ? r.props.content.map(s => ({ ...r, props: { ...r.props, content: s } }))
      : r
  )
}
function nU(t, e) {
  if (!t) return []
  typeof t == 'function' && (t = t())
  const n = (s, i) => {
    for (let o = 0; o < e.length; o++) i = e[o](s, i)
    return i
  }
  t = n(void 0, t)
  const r = []
  return (
    (t = sm(t, n)),
    Object.entries(t || {}).forEach(([s, i]) => {
      if (i !== void 0) for (const o of Array.isArray(i) ? i : [i]) r.push(tU(s, o))
    }),
    r.flat()
  )
}
const aC = (t, e) => (t._w === e._w ? t._p - e._p : t._w - e._w),
  cC = { base: -10, title: 10 },
  rU = { critical: -8, high: -1, low: 2 },
  uC = {
    meta: { 'content-security-policy': -30, charset: -20, viewport: -15 },
    link: {
      preconnect: 20,
      stylesheet: 60,
      preload: 70,
      modulepreload: 70,
      prefetch: 90,
      'dns-prefetch': 90,
      prerender: 90
    },
    script: { async: 30, defer: 80, sync: 50 },
    style: { imported: 40, sync: 60 }
  },
  sU = /@import/,
  Ld = t => t === '' || t === !0
function iU(t, e) {
  var i
  if (typeof e.tagPriority == 'number') return e.tagPriority
  let n = 100
  const r = rU[e.tagPriority] || 0,
    s = t.resolvedOptions.disableCapoSorting ? { link: {}, script: {}, style: {} } : uC
  if (e.tag in cC) n = cC[e.tag]
  else if (e.tag === 'meta') {
    const o =
      e.props['http-equiv'] === 'content-security-policy'
        ? 'content-security-policy'
        : e.props.charset
          ? 'charset'
          : e.props.name === 'viewport'
            ? 'viewport'
            : null
    o && (n = uC.meta[o])
  } else
    e.tag === 'link' && e.props.rel
      ? (n = s.link[e.props.rel])
      : e.tag === 'script'
        ? Ld(e.props.async)
          ? (n = s.script.async)
          : e.props.src &&
              !Ld(e.props.defer) &&
              !Ld(e.props.async) &&
              e.props.type !== 'module' &&
              !((i = e.props.type) != null && i.endsWith('json'))
            ? (n = s.script.sync)
            : Ld(e.props.defer) && e.props.src && !Ld(e.props.async) && (n = s.script.defer)
        : e.tag === 'style' &&
          (n = e.innerHTML && sU.test(e.innerHTML) ? s.style.imported : s.style.sync)
  return (n || 100) + r
}
function lC(t, e) {
  const n = typeof e == 'function' ? e(t) : e,
    r = n.key || String(t.plugins.size + 1)
  t.plugins.get(r) || (t.plugins.set(r, n), t.hooks.addHooks(n.hooks || {}))
}
function oU(t = {}) {
  var a
  const e = IP()
  e.addHooks(t.hooks || {})
  const n = !t.document,
    r = new Map(),
    s = new Map(),
    i = [],
    o = {
      _entryCount: 1,
      plugins: s,
      dirty: !1,
      resolvedOptions: t,
      hooks: e,
      ssr: n,
      entries: r,
      headEntries() {
        return [...r.values()]
      },
      use: c => lC(o, c),
      push(c, u) {
        const l = { ...(u || {}) }
        delete l.head
        const d = l._index ?? o._entryCount++,
          h = { _i: d, input: c, options: l },
          p = {
            _poll(y = !1) {
              ;(o.dirty = !0), !y && i.push(d), e.callHook('entries:updated', o)
            },
            dispose() {
              r.delete(d) && p._poll(!0)
            },
            patch(y) {
              ;(!l.mode || (l.mode === 'server' && n) || (l.mode === 'client' && !n)) &&
                ((h.input = y), r.set(d, h), p._poll())
            }
          }
        return p.patch(c), p
      },
      async resolveTags() {
        var p
        const c = { tagMap: new Map(), tags: [], entries: [...o.entries.values()] }
        for (await e.callHook('entries:resolve', c); i.length; ) {
          const y = i.shift(),
            m = r.get(y)
          if (m) {
            const b = {
              tags: nU(m.input, t.propResolvers || []).map(I => Object.assign(I, m.options)),
              entry: m
            }
            await e.callHook('entries:normalize', b),
              (m._tags = b.tags.map(
                (I, x) => ((I._w = iU(o, I)), (I._p = (m._i << 10) + x), (I._d = p1(I)), I)
              ))
          }
        }
        let u = !1
        c.entries
          .flatMap(y => (y._tags || []).map(m => ({ ...m, props: { ...m.props } })))
          .sort(aC)
          .reduce((y, m) => {
            const b = String(m._d || m._p)
            if (!y.has(b)) return y.set(b, m)
            const I = y.get(b)
            if (
              ((m == null ? void 0 : m.tagDuplicateStrategy) ||
                (Y4.has(m.tag) ? 'merge' : null) ||
                (m.key && m.key === I.key ? 'merge' : null)) === 'merge'
            ) {
              const _ = { ...I.props }
              Object.entries(m.props).forEach(
                ([R, N]) =>
                  (_[R] =
                    R === 'style'
                      ? new Map([...(I.props.style || new Map()), ...N])
                      : R === 'class'
                        ? new Set([...(I.props.class || new Set()), ...N])
                        : N)
              ),
                y.set(b, { ...m, props: _ })
            } else
              m._p >> 10 === I._p >> 10 && FP(m._d)
                ? (y.set(b, Object.assign([...(Array.isArray(I) ? I : [I]), m], m)), (u = !0))
                : (m._w === I._w
                    ? m._p > I._p
                    : (m == null ? void 0 : m._w) < (I == null ? void 0 : I._w)) && y.set(b, m)
            return y
          }, c.tagMap)
        const l = c.tagMap.get('title'),
          d = c.tagMap.get('titleTemplate')
        if (((o._title = l == null ? void 0 : l.textContent), d)) {
          const y = d == null ? void 0 : d.textContent
          if (((o._titleTemplate = y), y)) {
            let m = typeof y == 'function' ? y(l == null ? void 0 : l.textContent) : y
            typeof m == 'string' &&
              !o.plugins.has('template-params') &&
              (m = m.replace('%s', (l == null ? void 0 : l.textContent) || '')),
              l
                ? m === null
                  ? c.tagMap.delete('title')
                  : c.tagMap.set('title', { ...l, textContent: m })
                : ((d.tag = 'title'), (d.textContent = m))
          }
        }
        ;(c.tags = Array.from(c.tagMap.values())),
          u && (c.tags = c.tags.flat().sort(aC)),
          await e.callHook('tags:beforeResolve', c),
          await e.callHook('tags:resolve', c),
          await e.callHook('tags:afterResolve', c)
        const h = []
        for (const y of c.tags) {
          const { innerHTML: m, tag: b, props: I } = y
          if (
            G4.has(b) &&
            !(Object.keys(I).length === 0 && !y.innerHTML && !y.textContent) &&
            !(b === 'meta' && !I.content && !I['http-equiv'] && !I.charset)
          ) {
            if (b === 'script' && m) {
              if ((p = I.type) != null && p.endsWith('json')) {
                const x = typeof m == 'string' ? m : JSON.stringify(m)
                y.innerHTML = x.replace(/</g, '\\u003C')
              } else
                typeof m == 'string' &&
                  (y.innerHTML = m.replace(new RegExp(`</${b}`, 'g'), `<\\/${b}`))
              y._d = p1(y)
            }
            h.push(y)
          }
        }
        return h
      }
    }
  return (
    ((t == null ? void 0 : t.plugins) || []).forEach(c => lC(o, c)),
    o.hooks.callHook('init', o),
    (a = t.init) == null || a.forEach(c => c && o.push(c)),
    o
  )
}
const aU = (t, e) => (Vn(e) ? LB(e) : e),
  HP = 'usehead'
function cU(t) {
  return {
    install(n) {
      ;(n.config.globalProperties.$unhead = t),
        (n.config.globalProperties.$head = t),
        n.provide(HP, t)
    }
  }.install
}
function uU() {
  if (gE()) {
    const t = xl(HP)
    if (!t)
      throw new Error(
        'useHead() was called without provide context, ensure you call it through the setup() function.'
      )
    return t
  }
  throw new Error(
    'useHead() was called without provide context, ensure you call it through the setup() function.'
  )
}
function Cge(t, e = {}) {
  const n = e.head || uU()
  return n.ssr ? n.push(t || {}, e) : lU(n, t, e)
}
function lU(t, e, n = {}) {
  const r = wr(!1)
  let s
  return (
    P6(() => {
      const o = r.value ? {} : sm(e, aU)
      s ? s.patch(o) : (s = t.push(o, n))
    }),
    fP() &&
      (MN(() => {
        s.dispose()
      }),
      BN(() => {
        r.value = !0
      }),
      ON(() => {
        r.value = !1
      })),
    s
  )
}
const dU = 'modulepreload',
  hU = function (t, e) {
    return new URL(t, e).href
  },
  dC = {},
  qr = function (e, n, r) {
    let s = Promise.resolve()
    if (n && n.length > 0) {
      const o = document.getElementsByTagName('link'),
        a = document.querySelector('meta[property=csp-nonce]'),
        c = (a == null ? void 0 : a.nonce) || (a == null ? void 0 : a.getAttribute('nonce'))
      s = Promise.allSettled(
        n.map(u => {
          if (((u = hU(u, r)), u in dC)) return
          dC[u] = !0
          const l = u.endsWith('.css'),
            d = l ? '[rel="stylesheet"]' : ''
          if (!!r)
            for (let y = o.length - 1; y >= 0; y--) {
              const m = o[y]
              if (m.href === u && (!l || m.rel === 'stylesheet')) return
            }
          else if (document.querySelector(`link[href="${u}"]${d}`)) return
          const p = document.createElement('link')
          if (
            ((p.rel = l ? 'stylesheet' : dU),
            l || (p.as = 'script'),
            (p.crossOrigin = ''),
            (p.href = u),
            c && p.setAttribute('nonce', c),
            document.head.appendChild(p),
            l)
          )
            return new Promise((y, m) => {
              p.addEventListener('load', y),
                p.addEventListener('error', () => m(new Error(`Unable to preload CSS for ${u}`)))
            })
        })
      )
    }
    function i(o) {
      const a = new Event('vite:preloadError', { cancelable: !0 })
      if (((a.payload = o), window.dispatchEvent(a), !a.defaultPrevented)) throw o
    }
    return s.then(o => {
      for (const a of o || []) a.status === 'rejected' && i(a.reason)
      return e().catch(i)
    })
  }
let Ig, xg
function fU() {
  return (
    (Ig = $fetch(AE(`builds/meta/${Gh().app.buildId}.json`), { responseType: 'json' })),
    Ig.then(t => {
      xg = w4(t.matcher)
    }).catch(t => {
      console.error('[nuxt] Error fetching app manifest.', t)
    }),
    Ig
  )
}
function a0() {
  return Ig || fU()
}
async function PE(t) {
  const e = typeof t == 'string' ? t : t.path
  if ((await a0(), !xg)) return console.error('[nuxt] Error creating app manifest matcher.', xg), {}
  try {
    return S4({}, ...xg.matchAll(e).reverse())
  } catch (n) {
    return console.error('[nuxt] Error matching route rules.', n), {}
  }
}
async function hC(t, e = {}) {
  const n = await gU(t, e),
    r = Pr(),
    s = r._payloadCache || (r._payloadCache = {})
  return n in s
    ? s[n] || null
    : ((s[n] = zP(t).then(i =>
        i ? qP(n).then(o => o || (delete s[n], null)) : ((s[n] = null), null)
      )),
      s[n])
}
const pU = '_payload.json'
async function gU(t, e = {}) {
  const n = new URL(t, 'http://localhost')
  if (n.host !== 'localhost' || o0(n.pathname, { acceptRelative: !0 }))
    throw new Error('Payload URL must not include hostname: ' + t)
  const r = Gh(),
    s = e.hash || (e.fresh ? Date.now() : r.app.buildId),
    i = r.app.cdnURL,
    o = i && (await zP(t)) ? i : r.app.baseURL
  return IE(o, n.pathname, pU + (s ? `?${s}` : ''))
}
async function qP(t) {
  const e = fetch(t).then(n => n.text().then(WP))
  try {
    return await e
  } catch (n) {
    console.warn('[nuxt] Cannot load payload ', t, n)
  }
  return null
}
async function zP(t = LP().path) {
  const e = Pr()
  return (
    (t = RP(t)),
    (await a0()).prerendered.includes(t)
      ? !0
      : e.runWithContext(async () => {
          const r = await PE({ path: t })
          return !!r.prerender && !r.redirect
        })
  )
}
let pc = null
async function mU() {
  var r
  if (pc) return pc
  const t = document.getElementById('__NUXT_DATA__')
  if (!t) return {}
  const e = await WP(t.textContent || ''),
    n = t.dataset.src ? await qP(t.dataset.src) : void 0
  return (
    (pc = { ...e, ...n, ...window.__NUXT__ }),
    (r = pc.config) != null && r.public && (pc.config.public = zs(pc.config.public)),
    pc
  )
}
async function WP(t) {
  return await z4(t, Pr()._payloadRevivers)
}
function yU(t, e) {
  Pr()._payloadRevivers[t] = e
}
const wU = [
    ['NuxtError', t => NE(t)],
    ['EmptyShallowRef', t => b_(t === '_' ? void 0 : t === '0n' ? BigInt(0) : Bc(t))],
    ['EmptyRef', t => wr(t === '_' ? void 0 : t === '0n' ? BigInt(0) : Bc(t))],
    ['ShallowRef', t => b_(t)],
    ['ShallowReactive', t => hl(t)],
    ['Ref', t => wr(t)],
    ['Reactive', t => zs(t)]
  ],
  bU = po({
    name: 'nuxt:revive-payload:client',
    order: -30,
    async setup(t) {
      let e, n
      for (const [r, s] of wU) yU(r, s)
      Object.assign(t.payload, (([e, n] = xP(() => t.runWithContext(mU))), (e = await e), n(), e)),
        (window.__NUXT__ = t.payload)
    }
  })
async function RE(t, e = {}) {
  const n = e.document || t.resolvedOptions.document
  if (!n || !t.dirty) return
  const r = { shouldRender: !0, tags: [] }
  if ((await t.hooks.callHook('dom:beforeRender', r), !!r.shouldRender))
    return (
      t._domUpdatePromise ||
        (t._domUpdatePromise = new Promise(async s => {
          var p
          const i = new Map(),
            o = new Promise(y => {
              t.resolveTags().then(m => {
                y(
                  m.map(b => {
                    const I = i.get(b._d) || 0,
                      x = { tag: b, id: (I ? `${b._d}:${I}` : b._d) || oC(b), shouldRender: !0 }
                    return b._d && FP(b._d) && i.set(b._d, I + 1), x
                  })
                )
              })
            })
          let a = t._dom
          if (!a) {
            a = {
              title: n.title,
              elMap: new Map().set('htmlAttrs', n.documentElement).set('bodyAttrs', n.body)
            }
            for (const y of ['body', 'head']) {
              const m = (p = n[y]) == null ? void 0 : p.children
              for (const b of m) {
                const I = b.tagName.toLowerCase()
                if (!iC.has(I)) continue
                const x = jP(
                  { tag: I, props: {} },
                  {
                    innerHTML: b.innerHTML,
                    ...(b
                      .getAttributeNames()
                      .reduce((_, R) => ((_[R] = b.getAttribute(R)), _), {}) || {})
                  }
                )
                if (
                  ((x.key = b.getAttribute('data-hid') || void 0),
                  (x._d = p1(x) || oC(x)),
                  a.elMap.has(x._d))
                ) {
                  let _ = 1,
                    R = x._d
                  for (; a.elMap.has(R); ) R = `${x._d}:${_++}`
                  a.elMap.set(R, b)
                } else a.elMap.set(x._d, b)
              }
            }
          }
          ;(a.pendingSideEffects = { ...a.sideEffects }), (a.sideEffects = {})
          function c(y, m, b) {
            const I = `${y}:${m}`
            ;(a.sideEffects[I] = b), delete a.pendingSideEffects[I]
          }
          function u({ id: y, $el: m, tag: b }) {
            const I = b.tag.endsWith('Attrs')
            a.elMap.set(y, m),
              I ||
                (b.textContent &&
                  b.textContent !== m.textContent &&
                  (m.textContent = b.textContent),
                b.innerHTML && b.innerHTML !== m.innerHTML && (m.innerHTML = b.innerHTML),
                c(y, 'el', () => {
                  m == null || m.remove(), a.elMap.delete(y)
                }))
            for (const x in b.props) {
              if (!Object.prototype.hasOwnProperty.call(b.props, x)) continue
              const _ = b.props[x]
              if (x.startsWith('on') && typeof _ == 'function') {
                const N = m == null ? void 0 : m.dataset
                if (N && N[`${x}fired`]) {
                  const T = x.slice(0, -5)
                  _.call(m, new Event(T.substring(2)))
                }
                m.getAttribute(`data-${x}`) !== '' &&
                  ((b.tag === 'bodyAttrs' ? n.defaultView : m).addEventListener(
                    x.substring(2),
                    _.bind(m)
                  ),
                  m.setAttribute(`data-${x}`, ''))
                continue
              }
              const R = `attr:${x}`
              if (x === 'class') {
                if (!_) continue
                for (const N of _)
                  I && c(y, `${R}:${N}`, () => m.classList.remove(N)),
                    !m.classList.contains(N) && m.classList.add(N)
              } else if (x === 'style') {
                if (!_) continue
                for (const [N, T] of _)
                  c(y, `${R}:${N}`, () => {
                    m.style.removeProperty(N)
                  }),
                    m.style.setProperty(N, T)
              } else
                _ !== !1 &&
                  _ !== null &&
                  (m.getAttribute(x) !== _ && m.setAttribute(x, _ === !0 ? '' : String(_)),
                  I && c(y, R, () => m.removeAttribute(x)))
            }
          }
          const l = [],
            d = { bodyClose: void 0, bodyOpen: void 0, head: void 0 },
            h = await o
          for (const y of h) {
            const { tag: m, shouldRender: b, id: I } = y
            if (b) {
              if (m.tag === 'title') {
                ;(n.title = m.textContent), c('title', '', () => (n.title = a.title))
                continue
              }
              ;(y.$el = y.$el || a.elMap.get(I)), y.$el ? u(y) : iC.has(m.tag) && l.push(y)
            }
          }
          for (const y of l) {
            const m = y.tag.tagPosition || 'head'
            ;(y.$el = n.createElement(y.tag.tag)),
              u(y),
              (d[m] = d[m] || n.createDocumentFragment()),
              d[m].appendChild(y.$el)
          }
          for (const y of h) await t.hooks.callHook('dom:renderTag', y, n, c)
          d.head && n.head.appendChild(d.head),
            d.bodyOpen && n.body.insertBefore(d.bodyOpen, n.body.firstChild),
            d.bodyClose && n.body.appendChild(d.bodyClose)
          for (const y in a.pendingSideEffects) a.pendingSideEffects[y]()
          ;(t._dom = a), await t.hooks.callHook('dom:rendered', { renders: h }), s()
        }).finally(() => {
          ;(t._domUpdatePromise = void 0), (t.dirty = !1)
        })),
      t._domUpdatePromise
    )
}
function vU(t = {}) {
  var r, s, i
  const e = ((r = t.domOptions) == null ? void 0 : r.render) || RE
  t.document = t.document || (typeof window < 'u' ? document : void 0)
  const n =
    ((i =
      (s = t.document) == null ? void 0 : s.head.querySelector('script[id="unhead:payload"]')) ==
    null
      ? void 0
      : i.innerHTML) || !1
  return oU({
    ...t,
    plugins: [...(t.plugins || []), { key: 'client', hooks: { 'entries:updated': e } }],
    init: [n ? JSON.parse(n) : !1, ...(t.init || [])]
  })
}
function EU(t, e) {
  let n = 0
  return () => {
    const r = ++n
    e(() => {
      n === r && t()
    })
  }
}
function AU(t = {}) {
  const e = vU({
    domOptions: {
      render: EU(
        () => RE(e),
        n => setTimeout(n, 0)
      )
    },
    ...t
  })
  return (e.install = cU(e)), e
}
const _U = (t, e) => (t._w === e._w ? t._p - e._p : t._w - e._w),
  Ea = '%separator',
  CU = new RegExp(`${Ea}(?:\\s*${Ea})*`, 'g')
function SU(t, e, n = !1) {
  var s
  let r
  if (e === 's' || e === 'pageTitle') r = t.pageTitle
  else if (e.includes('.')) {
    const i = e.indexOf('.')
    r = (s = t[e.substring(0, i)]) == null ? void 0 : s[e.substring(i + 1)]
  } else r = t[e]
  if (r !== void 0)
    return n
      ? (r || '').replace(/\\/g, '\\\\').replace(/</g, '\\u003C').replace(/"/g, '\\"')
      : r || ''
}
function Fp(t, e, n, r = !1) {
  if (typeof t != 'string' || !t.includes('%')) return t
  let s = t
  try {
    s = decodeURI(t)
  } catch {}
  const i = s.match(/%\w+(?:\.\w+)?/g)
  if (!i) return t
  const o = t.includes(Ea)
  return (
    (t = t
      .replace(/%\w+(?:\.\w+)?/g, a => {
        if (a === Ea || !i.includes(a)) return a
        const c = SU(e, a.slice(1), r)
        return c !== void 0 ? c : a
      })
      .trim()),
    o &&
      (t.endsWith(Ea) && (t = t.slice(0, -Ea.length)),
      t.startsWith(Ea) && (t = t.slice(Ea.length)),
      (t = t.replace(CU, n || '').trim())),
    t
  )
}
const fC = t => (t.includes(':key') ? t : t.split(':').join(':key:')),
  IU = {
    key: 'aliasSorting',
    hooks: {
      'tags:resolve': t => {
        let e = !1
        for (const n of t.tags) {
          const r = n.tagPriority
          if (!r) continue
          const s = String(r)
          if (s.startsWith('before:')) {
            const i = fC(s.slice(7)),
              o = t.tagMap.get(i)
            o &&
              (typeof o.tagPriority == 'number' && (n.tagPriority = o.tagPriority),
              (n._p = o._p - 1),
              (e = !0))
          } else if (s.startsWith('after:')) {
            const i = fC(s.slice(6)),
              o = t.tagMap.get(i)
            o &&
              (typeof o.tagPriority == 'number' && (n.tagPriority = o.tagPriority),
              (n._p = o._p + 1),
              (e = !0))
          }
        }
        e && (t.tags = t.tags.sort(_U))
      }
    }
  },
  xU = {
    key: 'deprecations',
    hooks: {
      'entries:normalize': ({ tags: t }) => {
        for (const e of t)
          e.props.children && ((e.innerHTML = e.props.children), delete e.props.children),
            e.props.hid && ((e.key = e.props.hid), delete e.props.hid),
            e.props.vmid && ((e.key = e.props.vmid), delete e.props.vmid),
            e.props.body && ((e.tagPosition = 'bodyClose'), delete e.props.body)
      }
    }
  }
async function g1(t) {
  if (typeof t === 'function') return t
  if (t instanceof Promise) return await t
  if (Array.isArray(t)) return await Promise.all(t.map(n => g1(n)))
  if ((t == null ? void 0 : t.constructor) === Object) {
    const n = {}
    for (const r of Object.keys(t)) n[r] = await g1(t[r])
    return n
  }
  return t
}
const TU = {
    key: 'promises',
    hooks: {
      'entries:resolve': async t => {
        const e = []
        for (const n in t.entries)
          t.entries[n]._promisesProcessed ||
            e.push(
              g1(t.entries[n].input).then(r => {
                ;(t.entries[n].input = r), (t.entries[n]._promisesProcessed = !0)
              })
            )
        await Promise.all(e)
      }
    }
  },
  NU = { meta: 'content', link: 'href', htmlAttrs: 'lang' },
  PU = ['innerHTML', 'textContent'],
  RU = t => ({
    key: 'template-params',
    hooks: {
      'entries:normalize': e => {
        var r, s, i
        const n =
          ((s =
            (r = e.tags.filter(o => o.tag === 'templateParams' && o.mode === 'server')) == null
              ? void 0
              : r[0]) == null
            ? void 0
            : s.props) || {}
        Object.keys(n).length &&
          (t._ssrPayload = {
            templateParams: {
              ...(((i = t._ssrPayload) == null ? void 0 : i.templateParams) || {}),
              ...n
            }
          })
      },
      'tags:resolve': ({ tagMap: e, tags: n }) => {
        var i
        const r = ((i = e.get('templateParams')) == null ? void 0 : i.props) || {},
          s = r.separator || '|'
        delete r.separator, (r.pageTitle = Fp(r.pageTitle || t._title || '', r, s))
        for (const o of n) {
          if (o.processTemplateParams === !1) continue
          const a = NU[o.tag]
          if (a && typeof o.props[a] == 'string') o.props[a] = Fp(o.props[a], r, s)
          else if (o.processTemplateParams || o.tag === 'titleTemplate' || o.tag === 'title')
            for (const c of PU)
              typeof o[c] == 'string' &&
                (o[c] = Fp(o[c], r, s, o.tag === 'script' && o.props.type.endsWith('json')))
        }
        ;(t._templateParams = r), (t._separator = s)
      },
      'tags:afterResolve': ({ tagMap: e }) => {
        const n = e.get('title')
        n != null &&
          n.textContent &&
          n.processTemplateParams !== !1 &&
          (n.textContent = Fp(n.textContent, t._templateParams, t._separator))
      }
    }
  }),
  kU = { disableDefaults: !0, disableCapoSorting: !1, plugins: [xU, TU, RU, IU] },
  OU = po({
    name: 'nuxt:head',
    enforce: 'pre',
    setup(t) {
      const e = AU(kU)
      t.vueApp.use(e)
      {
        let n = !0
        const r = async () => {
          ;(n = !1), await RE(e)
        }
        e.hooks.hook('dom:beforeRender', s => {
          s.shouldRender = !n
        }),
          t.hooks.hook('page:start', () => {
            n = !0
          }),
          t.hooks.hook('page:finish', () => {
            t.isHydrating || r()
          }),
          t.hooks.hook('app:error', r),
          t.hooks.hook('app:suspense:resolve', r)
      }
    }
  }),
  BU = async t => {
    let e, n
    const r = (([e, n] = xP(() => PE({ path: t.path }))), (e = await e), n(), e)
    if (r.redirect)
      return o0(r.redirect, { acceptRelative: !0 })
        ? ((window.location.href = r.redirect), !1)
        : r.redirect
  },
  DU = [BU]
function Zy(t) {
  typeof t == 'object' &&
    (t = OP({ pathname: t.path || '', search: PP(t.query || {}), hash: t.hash || '' }))
  const e = new URL(t.toString(), window.location.href)
  return {
    path: e.pathname,
    fullPath: t,
    query: SE(e.search),
    hash: e.hash,
    params: {},
    name: void 0,
    matched: [],
    redirectedFrom: void 0,
    meta: {},
    href: t
  }
}
const MU = po({
    name: 'nuxt:router',
    enforce: 'pre',
    setup(t) {
      const e =
          h4(window.location.pathname, Gh().app.baseURL) +
          window.location.search +
          window.location.hash,
        n = [],
        r = { 'navigate:before': [], 'resolve:before': [], 'navigate:after': [], error: [] },
        s = (d, h) => (r[d].push(h), () => r[d].splice(r[d].indexOf(h), 1)),
        i = Gh().app.baseURL,
        o = zs(Zy(e))
      async function a(d, h) {
        try {
          const p = Zy(d)
          for (const y of r['navigate:before']) {
            const m = await y(p, o)
            if (m === !1 || m instanceof Error) return
            if (typeof m == 'string' && m.length) return a(m, !0)
          }
          for (const y of r['resolve:before']) await y(p, o)
          Object.assign(o, p),
            window.history[h ? 'replaceState' : 'pushState']({}, '', IE(i, p.fullPath)),
            t.isHydrating || (await t.runWithContext(B4))
          for (const y of r['navigate:after']) await y(p, o)
        } catch (p) {
          for (const y of r.error) await y(p)
        }
      }
      const u = {
        currentRoute: mP(() => o),
        isReady: () => Promise.resolve(),
        options: {},
        install: () => Promise.resolve(),
        push: d => a(d, !1),
        replace: d => a(d, !0),
        back: () => window.history.go(-1),
        go: d => window.history.go(d),
        forward: () => window.history.go(1),
        beforeResolve: d => s('resolve:before', d),
        beforeEach: d => s('navigate:before', d),
        afterEach: d => s('navigate:after', d),
        onError: d => s('error', d),
        resolve: Zy,
        addRoute: (d, h) => {
          n.push(h)
        },
        getRoutes: () => n,
        hasRoute: d => n.some(h => h.name === d),
        removeRoute: d => {
          const h = n.findIndex(p => p.name === d)
          h !== -1 && n.splice(h, 1)
        }
      }
      t.vueApp.component(
        'RouterLink',
        n0({
          functional: !0,
          props: {
            to: { type: String, required: !0 },
            custom: Boolean,
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            ariaCurrentValue: String
          },
          setup: (d, { slots: h }) => {
            const p = () => a(d.to, d.replace)
            return () => {
              var m
              const y = u.resolve(d.to)
              return d.custom
                ? (m = h.default) == null
                  ? void 0
                  : m.call(h, { href: d.to, navigate: p, route: y })
                : rD('a', { href: d.to, onClick: b => (b.preventDefault(), p()) }, h)
            }
          }
        })
      ),
        window.addEventListener('popstate', d => {
          const h = d.target.location
          u.replace(h.href.replace(h.origin, ''))
        }),
        (t._route = o),
        t._middleware || (t._middleware = { global: [], named: {} })
      const l = t.payload.state._layout
      return (
        t.hooks.hookOnce('app:created', async () => {
          u.beforeEach(async (d, h) => {
            ;(d.meta = zs(d.meta || {})),
              t.isHydrating && l && !Za(d.meta.layout) && (d.meta.layout = l),
              (t._processingMiddleware = !0)
            {
              const p = new Set([...DU, ...t._middleware.global])
              {
                const y = await t.runWithContext(() => PE({ path: d.path }))
                if (y.appMiddleware)
                  for (const m in y.appMiddleware) {
                    const b = t._middleware.named[m]
                    if (!b) return
                    y.appMiddleware[m] ? p.add(b) : p.delete(b)
                  }
              }
              for (const y of p) {
                const m = await t.runWithContext(() => y(d, h))
                if (m !== !0 && (m || m === !1)) return m
              }
            }
          }),
            u.afterEach(() => {
              delete t._processingMiddleware
            }),
            await u.replace(e),
            m4(o.fullPath, e) || (await t.runWithContext(() => R4(o.fullPath)))
        }),
        { provide: { route: o, router: u } }
      )
    }
  }),
  pC =
    globalThis.requestIdleCallback ||
    (t => {
      const e = Date.now(),
        n = { didTimeout: !1, timeRemaining: () => Math.max(0, 50 - (Date.now() - e)) }
      return setTimeout(() => {
        t(n)
      }, 1)
    }),
  Sge =
    globalThis.cancelIdleCallback ||
    (t => {
      clearTimeout(t)
    }),
  kE = t => {
    const e = Pr()
    e.isHydrating
      ? e.hooks.hookOnce('app:suspense:resolve', () => {
          pC(() => t())
        })
      : pC(() => t())
  },
  UU = po({
    name: 'nuxt:payload',
    setup(t) {
      ru().beforeResolve(async (e, n) => {
        if (e.path === n.path) return
        const r = await hC(e.path)
        r && Object.assign(t.static.data, r.data)
      }),
        kE(() => {
          var e
          t.hooks.hook('link:prefetch', async n => {
            const { hostname: r } = new URL(n, window.location.href)
            r === window.location.hostname && (await hC(n))
          }),
            ((e = navigator.connection) == null ? void 0 : e.effectiveType) !== 'slow-2g' &&
              setTimeout(a0, 1e3)
        })
    }
  }),
  LU = po(() => {
    const t = ru()
    kE(() => {
      t.beforeResolve(async () => {
        await new Promise(e => {
          setTimeout(e, 100),
            requestAnimationFrame(() => {
              setTimeout(e, 0)
            })
        })
      })
    })
  }),
  $U = po(t => {
    let e
    async function n() {
      const r = await a0()
      e && clearTimeout(e), (e = setTimeout(n, X_))
      try {
        const s = await $fetch(AE('builds/latest.json') + `?${Date.now()}`)
        s.id !== r.id && t.hooks.callHook('app:manifest:update', s)
      } catch {}
    }
    kE(() => {
      e = setTimeout(n, X_)
    })
  })
function FU(t = {}) {
  const e = t.path || window.location.pathname
  let n = {}
  try {
    n = Bc(sessionStorage.getItem('nuxt:reload') || '{}')
  } catch {}
  if (
    t.force ||
    (n == null ? void 0 : n.path) !== e ||
    (n == null ? void 0 : n.expires) < Date.now()
  ) {
    try {
      sessionStorage.setItem(
        'nuxt:reload',
        JSON.stringify({ path: e, expires: Date.now() + (t.ttl ?? 1e4) })
      )
    } catch {}
    if (t.persistState)
      try {
        sessionStorage.setItem('nuxt:reload:state', JSON.stringify({ state: Pr().payload.state }))
      } catch {}
    window.location.pathname !== e ? (window.location.href = e) : window.location.reload()
  }
}
const jU = po({
    name: 'nuxt:chunk-reload',
    setup(t) {
      const e = ru(),
        n = Gh(),
        r = new Set()
      e.beforeEach(() => {
        r.clear()
      }),
        t.hook('app:chunkError', ({ error: i }) => {
          r.add(i)
        })
      function s(i) {
        const a =
          'href' in i && i.href[0] === '#' ? n.app.baseURL + i.href : IE(n.app.baseURL, i.fullPath)
        FU({ path: a, persistState: !0 })
      }
      t.hook('app:manifest:update', () => {
        e.beforeResolve(s)
      }),
        e.onError((i, o) => {
          r.has(i) && s(o)
        })
    }
  }),
  HU = po({ name: 'nuxt:global-components' })
var c0 = class {
    constructor() {
      ;(this.listeners = new Set()), (this.subscribe = this.subscribe.bind(this))
    }
    subscribe(t) {
      return (
        this.listeners.add(t),
        this.onSubscribe(),
        () => {
          this.listeners.delete(t), this.onUnsubscribe()
        }
      )
    }
    hasListeners() {
      return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
  },
  tp = typeof window > 'u' || 'Deno' in globalThis
function vi() {}
function qU(t, e) {
  return typeof t == 'function' ? t(e) : t
}
function zU(t) {
  return typeof t == 'number' && t >= 0 && t !== 1 / 0
}
function WU(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0)
}
function gC(t, e) {
  return typeof t == 'function' ? t(e) : t
}
function KU(t, e) {
  return typeof t == 'function' ? t(e) : t
}
function mC(t, e) {
  const { type: n = 'all', exact: r, fetchStatus: s, predicate: i, queryKey: o, stale: a } = t
  if (o) {
    if (r) {
      if (e.queryHash !== OE(o, e.options)) return !1
    } else if (!Zh(e.queryKey, o)) return !1
  }
  if (n !== 'all') {
    const c = e.isActive()
    if ((n === 'active' && !c) || (n === 'inactive' && c)) return !1
  }
  return !(
    (typeof a == 'boolean' && e.isStale() !== a) ||
    (s && s !== e.state.fetchStatus) ||
    (i && !i(e))
  )
}
function yC(t, e) {
  const { exact: n, status: r, predicate: s, mutationKey: i } = t
  if (i) {
    if (!e.options.mutationKey) return !1
    if (n) {
      if (Qh(e.options.mutationKey) !== Qh(i)) return !1
    } else if (!Zh(e.options.mutationKey, i)) return !1
  }
  return !((r && e.state.status !== r) || (s && !s(e)))
}
function OE(t, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || Qh)(t)
}
function Qh(t) {
  return JSON.stringify(t, (e, n) =>
    m1(n)
      ? Object.keys(n)
          .sort()
          .reduce((r, s) => ((r[s] = n[s]), r), {})
      : n
  )
}
function Zh(t, e) {
  return t === e
    ? !0
    : typeof t != typeof e
      ? !1
      : t && e && typeof t == 'object' && typeof e == 'object'
        ? !Object.keys(e).some(n => !Zh(t[n], e[n]))
        : !1
}
function KP(t, e) {
  if (t === e) return t
  const n = wC(t) && wC(e)
  if (n || (m1(t) && m1(e))) {
    const r = n ? t : Object.keys(t),
      s = r.length,
      i = n ? e : Object.keys(e),
      o = i.length,
      a = n ? [] : {}
    let c = 0
    for (let u = 0; u < o; u++) {
      const l = n ? u : i[u]
      ;((!n && r.includes(l)) || n) && t[l] === void 0 && e[l] === void 0
        ? ((a[l] = void 0), c++)
        : ((a[l] = KP(t[l], e[l])), a[l] === t[l] && t[l] !== void 0 && c++)
    }
    return s === o && c === s ? t : a
  }
  return e
}
function wC(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length
}
function m1(t) {
  if (!bC(t)) return !1
  const e = t.constructor
  if (e === void 0) return !0
  const n = e.prototype
  return !(
    !bC(n) ||
    !n.hasOwnProperty('isPrototypeOf') ||
    Object.getPrototypeOf(t) !== Object.prototype
  )
}
function bC(t) {
  return Object.prototype.toString.call(t) === '[object Object]'
}
function VU(t) {
  return new Promise(e => {
    setTimeout(e, t)
  })
}
function GU(t, e, n) {
  return typeof n.structuralSharing == 'function'
    ? n.structuralSharing(t, e)
    : n.structuralSharing !== !1
      ? KP(t, e)
      : e
}
function QU(t, e, n = 0) {
  const r = [...t, e]
  return n && r.length > n ? r.slice(1) : r
}
function ZU(t, e, n = 0) {
  const r = [e, ...t]
  return n && r.length > n ? r.slice(0, -1) : r
}
var BE = Symbol()
function VP(t, e) {
  return !t.queryFn && e != null && e.initialPromise
    ? () => e.initialPromise
    : !t.queryFn || t.queryFn === BE
      ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`))
      : t.queryFn
}
var qc,
  Ra,
  Ul,
  VT,
  YU =
    ((VT = class extends c0 {
      constructor() {
        super()
        Jt(this, qc)
        Jt(this, Ra)
        Jt(this, Ul)
        Pt(this, Ul, e => {
          if (!tp && window.addEventListener) {
            const n = () => e()
            return (
              window.addEventListener('visibilitychange', n, !1),
              () => {
                window.removeEventListener('visibilitychange', n)
              }
            )
          }
        })
      }
      onSubscribe() {
        Ee(this, Ra) || this.setEventListener(Ee(this, Ul))
      }
      onUnsubscribe() {
        var e
        this.hasListeners() || ((e = Ee(this, Ra)) == null || e.call(this), Pt(this, Ra, void 0))
      }
      setEventListener(e) {
        var n
        Pt(this, Ul, e),
          (n = Ee(this, Ra)) == null || n.call(this),
          Pt(
            this,
            Ra,
            e(r => {
              typeof r == 'boolean' ? this.setFocused(r) : this.onFocus()
            })
          )
      }
      setFocused(e) {
        Ee(this, qc) !== e && (Pt(this, qc, e), this.onFocus())
      }
      onFocus() {
        const e = this.isFocused()
        this.listeners.forEach(n => {
          n(e)
        })
      }
      isFocused() {
        var e
        return typeof Ee(this, qc) == 'boolean'
          ? Ee(this, qc)
          : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== 'hidden'
      }
    }),
    (qc = new WeakMap()),
    (Ra = new WeakMap()),
    (Ul = new WeakMap()),
    VT),
  GP = new YU(),
  Ll,
  ka,
  $l,
  GT,
  JU =
    ((GT = class extends c0 {
      constructor() {
        super()
        Jt(this, Ll, !0)
        Jt(this, ka)
        Jt(this, $l)
        Pt(this, $l, e => {
          if (!tp && window.addEventListener) {
            const n = () => e(!0),
              r = () => e(!1)
            return (
              window.addEventListener('online', n, !1),
              window.addEventListener('offline', r, !1),
              () => {
                window.removeEventListener('online', n), window.removeEventListener('offline', r)
              }
            )
          }
        })
      }
      onSubscribe() {
        Ee(this, ka) || this.setEventListener(Ee(this, $l))
      }
      onUnsubscribe() {
        var e
        this.hasListeners() || ((e = Ee(this, ka)) == null || e.call(this), Pt(this, ka, void 0))
      }
      setEventListener(e) {
        var n
        Pt(this, $l, e),
          (n = Ee(this, ka)) == null || n.call(this),
          Pt(this, ka, e(this.setOnline.bind(this)))
      }
      setOnline(e) {
        Ee(this, Ll) !== e &&
          (Pt(this, Ll, e),
          this.listeners.forEach(r => {
            r(e)
          }))
      }
      isOnline() {
        return Ee(this, Ll)
      }
    }),
    (Ll = new WeakMap()),
    (ka = new WeakMap()),
    ($l = new WeakMap()),
    GT),
  im = new JU()
function XU() {
  let t, e
  const n = new Promise((s, i) => {
    ;(t = s), (e = i)
  })
  ;(n.status = 'pending'), n.catch(() => {})
  function r(s) {
    Object.assign(n, s), delete n.resolve, delete n.reject
  }
  return (
    (n.resolve = s => {
      r({ status: 'fulfilled', value: s }), t(s)
    }),
    (n.reject = s => {
      r({ status: 'rejected', reason: s }), e(s)
    }),
    n
  )
}
function eL(t) {
  return Math.min(1e3 * 2 ** t, 3e4)
}
function QP(t) {
  return (t ?? 'online') === 'online' ? im.isOnline() : !0
}
var ZP = class extends Error {
  constructor(t) {
    super('CancelledError'),
      (this.revert = t == null ? void 0 : t.revert),
      (this.silent = t == null ? void 0 : t.silent)
  }
}
function Yy(t) {
  return t instanceof ZP
}
function YP(t) {
  let e = !1,
    n = 0,
    r = !1,
    s
  const i = XU(),
    o = m => {
      var b
      r || (h(new ZP(m)), (b = t.abort) == null || b.call(t))
    },
    a = () => {
      e = !0
    },
    c = () => {
      e = !1
    },
    u = () => GP.isFocused() && (t.networkMode === 'always' || im.isOnline()) && t.canRun(),
    l = () => QP(t.networkMode) && t.canRun(),
    d = m => {
      var b
      r || ((r = !0), (b = t.onSuccess) == null || b.call(t, m), s == null || s(), i.resolve(m))
    },
    h = m => {
      var b
      r || ((r = !0), (b = t.onError) == null || b.call(t, m), s == null || s(), i.reject(m))
    },
    p = () =>
      new Promise(m => {
        var b
        ;(s = I => {
          ;(r || u()) && m(I)
        }),
          (b = t.onPause) == null || b.call(t)
      }).then(() => {
        var m
        ;(s = void 0), r || (m = t.onContinue) == null || m.call(t)
      }),
    y = () => {
      if (r) return
      let m
      const b = n === 0 ? t.initialPromise : void 0
      try {
        m = b ?? t.fn()
      } catch (I) {
        m = Promise.reject(I)
      }
      Promise.resolve(m)
        .then(d)
        .catch(I => {
          var T
          if (r) return
          const x = t.retry ?? (tp ? 0 : 3),
            _ = t.retryDelay ?? eL,
            R = typeof _ == 'function' ? _(n, I) : _,
            N = x === !0 || (typeof x == 'number' && n < x) || (typeof x == 'function' && x(n, I))
          if (e || !N) {
            h(I)
            return
          }
          n++,
            (T = t.onFail) == null || T.call(t, n, I),
            VU(R)
              .then(() => (u() ? void 0 : p()))
              .then(() => {
                e ? h(I) : y()
              })
        })
    }
  return {
    promise: i,
    cancel: o,
    continue: () => (s == null || s(), i),
    cancelRetry: a,
    continueRetry: c,
    canStart: l,
    start: () => (l() ? y() : p().then(y), i)
  }
}
function tL() {
  let t = [],
    e = 0,
    n = a => {
      a()
    },
    r = a => {
      a()
    },
    s = a => setTimeout(a, 0)
  const i = a => {
      e
        ? t.push(a)
        : s(() => {
            n(a)
          })
    },
    o = () => {
      const a = t
      ;(t = []),
        a.length &&
          s(() => {
            r(() => {
              a.forEach(c => {
                n(c)
              })
            })
          })
    }
  return {
    batch: a => {
      let c
      e++
      try {
        c = a()
      } finally {
        e--, e || o()
      }
      return c
    },
    batchCalls:
      a =>
      (...c) => {
        i(() => {
          a(...c)
        })
      },
    schedule: i,
    setNotifyFunction: a => {
      n = a
    },
    setBatchNotifyFunction: a => {
      r = a
    },
    setScheduler: a => {
      s = a
    }
  }
}
var as = tL(),
  zc,
  QT,
  JP =
    ((QT = class {
      constructor() {
        Jt(this, zc)
      }
      destroy() {
        this.clearGcTimeout()
      }
      scheduleGc() {
        this.clearGcTimeout(),
          zU(this.gcTime) &&
            Pt(
              this,
              zc,
              setTimeout(() => {
                this.optionalRemove()
              }, this.gcTime)
            )
      }
      updateGcTime(t) {
        this.gcTime = Math.max(this.gcTime || 0, t ?? (tp ? 1 / 0 : 5 * 60 * 1e3))
      }
      clearGcTimeout() {
        Ee(this, zc) && (clearTimeout(Ee(this, zc)), Pt(this, zc, void 0))
      }
    }),
    (zc = new WeakMap()),
    QT),
  Fl,
  jl,
  ni,
  jr,
  Zf,
  Wc,
  Ei,
  Oo,
  ZT,
  nL =
    ((ZT = class extends JP {
      constructor(e) {
        super()
        Jt(this, Ei)
        Jt(this, Fl)
        Jt(this, jl)
        Jt(this, ni)
        Jt(this, jr)
        Jt(this, Zf)
        Jt(this, Wc)
        Pt(this, Wc, !1),
          Pt(this, Zf, e.defaultOptions),
          this.setOptions(e.options),
          (this.observers = []),
          Pt(this, ni, e.cache),
          (this.queryKey = e.queryKey),
          (this.queryHash = e.queryHash),
          Pt(this, Fl, sL(this.options)),
          (this.state = e.state ?? Ee(this, Fl)),
          this.scheduleGc()
      }
      get meta() {
        return this.options.meta
      }
      get promise() {
        var e
        return (e = Ee(this, jr)) == null ? void 0 : e.promise
      }
      setOptions(e) {
        ;(this.options = { ...Ee(this, Zf), ...e }), this.updateGcTime(this.options.gcTime)
      }
      optionalRemove() {
        !this.observers.length && this.state.fetchStatus === 'idle' && Ee(this, ni).remove(this)
      }
      setData(e, n) {
        const r = GU(this.state.data, e, this.options)
        return (
          Dr(this, Ei, Oo).call(this, {
            data: r,
            type: 'success',
            dataUpdatedAt: n == null ? void 0 : n.updatedAt,
            manual: n == null ? void 0 : n.manual
          }),
          r
        )
      }
      setState(e, n) {
        Dr(this, Ei, Oo).call(this, { type: 'setState', state: e, setStateOptions: n })
      }
      cancel(e) {
        var r, s
        const n = (r = Ee(this, jr)) == null ? void 0 : r.promise
        return (
          (s = Ee(this, jr)) == null || s.cancel(e), n ? n.then(vi).catch(vi) : Promise.resolve()
        )
      }
      destroy() {
        super.destroy(), this.cancel({ silent: !0 })
      }
      reset() {
        this.destroy(), this.setState(Ee(this, Fl))
      }
      isActive() {
        return this.observers.some(e => KU(e.options.enabled, this) !== !1)
      }
      isDisabled() {
        return this.getObserversCount() > 0
          ? !this.isActive()
          : this.options.queryFn === BE ||
              this.state.dataUpdateCount + this.state.errorUpdateCount === 0
      }
      isStale() {
        return this.state.isInvalidated
          ? !0
          : this.getObserversCount() > 0
            ? this.observers.some(e => e.getCurrentResult().isStale)
            : this.state.data === void 0
      }
      isStaleByTime(e = 0) {
        return (
          this.state.isInvalidated || this.state.data === void 0 || !WU(this.state.dataUpdatedAt, e)
        )
      }
      onFocus() {
        var n
        const e = this.observers.find(r => r.shouldFetchOnWindowFocus())
        e == null || e.refetch({ cancelRefetch: !1 }), (n = Ee(this, jr)) == null || n.continue()
      }
      onOnline() {
        var n
        const e = this.observers.find(r => r.shouldFetchOnReconnect())
        e == null || e.refetch({ cancelRefetch: !1 }), (n = Ee(this, jr)) == null || n.continue()
      }
      addObserver(e) {
        this.observers.includes(e) ||
          (this.observers.push(e),
          this.clearGcTimeout(),
          Ee(this, ni).notify({ type: 'observerAdded', query: this, observer: e }))
      }
      removeObserver(e) {
        this.observers.includes(e) &&
          ((this.observers = this.observers.filter(n => n !== e)),
          this.observers.length ||
            (Ee(this, jr) &&
              (Ee(this, Wc) ? Ee(this, jr).cancel({ revert: !0 }) : Ee(this, jr).cancelRetry()),
            this.scheduleGc()),
          Ee(this, ni).notify({ type: 'observerRemoved', query: this, observer: e }))
      }
      getObserversCount() {
        return this.observers.length
      }
      invalidate() {
        this.state.isInvalidated || Dr(this, Ei, Oo).call(this, { type: 'invalidate' })
      }
      fetch(e, n) {
        var c, u, l
        if (this.state.fetchStatus !== 'idle') {
          if (this.state.data !== void 0 && n != null && n.cancelRefetch)
            this.cancel({ silent: !0 })
          else if (Ee(this, jr)) return Ee(this, jr).continueRetry(), Ee(this, jr).promise
        }
        if ((e && this.setOptions(e), !this.options.queryFn)) {
          const d = this.observers.find(h => h.options.queryFn)
          d && this.setOptions(d.options)
        }
        const r = new AbortController(),
          s = d => {
            Object.defineProperty(d, 'signal', {
              enumerable: !0,
              get: () => (Pt(this, Wc, !0), r.signal)
            })
          },
          i = () => {
            const d = VP(this.options, n),
              h = { queryKey: this.queryKey, meta: this.meta }
            return (
              s(h),
              Pt(this, Wc, !1),
              this.options.persister ? this.options.persister(d, h, this) : d(h)
            )
          },
          o = {
            fetchOptions: n,
            options: this.options,
            queryKey: this.queryKey,
            state: this.state,
            fetchFn: i
          }
        s(o),
          (c = this.options.behavior) == null || c.onFetch(o, this),
          Pt(this, jl, this.state),
          (this.state.fetchStatus === 'idle' ||
            this.state.fetchMeta !== ((u = o.fetchOptions) == null ? void 0 : u.meta)) &&
            Dr(this, Ei, Oo).call(this, {
              type: 'fetch',
              meta: (l = o.fetchOptions) == null ? void 0 : l.meta
            })
        const a = d => {
          var h, p, y, m
          ;(Yy(d) && d.silent) || Dr(this, Ei, Oo).call(this, { type: 'error', error: d }),
            Yy(d) ||
              ((p = (h = Ee(this, ni).config).onError) == null || p.call(h, d, this),
              (m = (y = Ee(this, ni).config).onSettled) == null ||
                m.call(y, this.state.data, d, this)),
            this.scheduleGc()
        }
        return (
          Pt(
            this,
            jr,
            YP({
              initialPromise: n == null ? void 0 : n.initialPromise,
              fn: o.fetchFn,
              abort: r.abort.bind(r),
              onSuccess: d => {
                var h, p, y, m
                if (d === void 0) {
                  a(new Error(`${this.queryHash} data is undefined`))
                  return
                }
                try {
                  this.setData(d)
                } catch (b) {
                  a(b)
                  return
                }
                ;(p = (h = Ee(this, ni).config).onSuccess) == null || p.call(h, d, this),
                  (m = (y = Ee(this, ni).config).onSettled) == null ||
                    m.call(y, d, this.state.error, this),
                  this.scheduleGc()
              },
              onError: a,
              onFail: (d, h) => {
                Dr(this, Ei, Oo).call(this, { type: 'failed', failureCount: d, error: h })
              },
              onPause: () => {
                Dr(this, Ei, Oo).call(this, { type: 'pause' })
              },
              onContinue: () => {
                Dr(this, Ei, Oo).call(this, { type: 'continue' })
              },
              retry: o.options.retry,
              retryDelay: o.options.retryDelay,
              networkMode: o.options.networkMode,
              canRun: () => !0
            })
          ),
          Ee(this, jr).start()
        )
      }
    }),
    (Fl = new WeakMap()),
    (jl = new WeakMap()),
    (ni = new WeakMap()),
    (jr = new WeakMap()),
    (Zf = new WeakMap()),
    (Wc = new WeakMap()),
    (Ei = new WeakSet()),
    (Oo = function (e) {
      const n = r => {
        switch (e.type) {
          case 'failed':
            return { ...r, fetchFailureCount: e.failureCount, fetchFailureReason: e.error }
          case 'pause':
            return { ...r, fetchStatus: 'paused' }
          case 'continue':
            return { ...r, fetchStatus: 'fetching' }
          case 'fetch':
            return { ...r, ...rL(r.data, this.options), fetchMeta: e.meta ?? null }
          case 'success':
            return {
              ...r,
              data: e.data,
              dataUpdateCount: r.dataUpdateCount + 1,
              dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
              error: null,
              isInvalidated: !1,
              status: 'success',
              ...(!e.manual && {
                fetchStatus: 'idle',
                fetchFailureCount: 0,
                fetchFailureReason: null
              })
            }
          case 'error':
            const s = e.error
            return Yy(s) && s.revert && Ee(this, jl)
              ? { ...Ee(this, jl), fetchStatus: 'idle' }
              : {
                  ...r,
                  error: s,
                  errorUpdateCount: r.errorUpdateCount + 1,
                  errorUpdatedAt: Date.now(),
                  fetchFailureCount: r.fetchFailureCount + 1,
                  fetchFailureReason: s,
                  fetchStatus: 'idle',
                  status: 'error'
                }
          case 'invalidate':
            return { ...r, isInvalidated: !0 }
          case 'setState':
            return { ...r, ...e.state }
        }
      }
      ;(this.state = n(this.state)),
        as.batch(() => {
          this.observers.forEach(r => {
            r.onQueryUpdate()
          }),
            Ee(this, ni).notify({ query: this, type: 'updated', action: e })
        })
    }),
    ZT)
function rL(t, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: QP(e.networkMode) ? 'fetching' : 'paused',
    ...(t === void 0 && { error: null, status: 'pending' })
  }
}
function sL(t) {
  const e = typeof t.initialData == 'function' ? t.initialData() : t.initialData,
    n = e !== void 0,
    r = n
      ? typeof t.initialDataUpdatedAt == 'function'
        ? t.initialDataUpdatedAt()
        : t.initialDataUpdatedAt
      : 0
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? (r ?? Date.now()) : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? 'success' : 'pending',
    fetchStatus: 'idle'
  }
}
var Gi,
  YT,
  XP =
    ((YT = class extends c0 {
      constructor(n = {}) {
        super()
        Jt(this, Gi)
        ;(this.config = n), Pt(this, Gi, new Map())
      }
      build(n, r, s) {
        const i = r.queryKey,
          o = r.queryHash ?? OE(i, r)
        let a = this.get(o)
        return (
          a ||
            ((a = new nL({
              cache: this,
              queryKey: i,
              queryHash: o,
              options: n.defaultQueryOptions(r),
              state: s,
              defaultOptions: n.getQueryDefaults(i)
            })),
            this.add(a)),
          a
        )
      }
      add(n) {
        Ee(this, Gi).has(n.queryHash) ||
          (Ee(this, Gi).set(n.queryHash, n), this.notify({ type: 'added', query: n }))
      }
      remove(n) {
        const r = Ee(this, Gi).get(n.queryHash)
        r &&
          (n.destroy(),
          r === n && Ee(this, Gi).delete(n.queryHash),
          this.notify({ type: 'removed', query: n }))
      }
      clear() {
        as.batch(() => {
          this.getAll().forEach(n => {
            this.remove(n)
          })
        })
      }
      get(n) {
        return Ee(this, Gi).get(n)
      }
      getAll() {
        return [...Ee(this, Gi).values()]
      }
      find(n) {
        const r = { exact: !0, ...n }
        return this.getAll().find(s => mC(r, s))
      }
      findAll(n = {}) {
        const r = this.getAll()
        return Object.keys(n).length > 0 ? r.filter(s => mC(n, s)) : r
      }
      notify(n) {
        as.batch(() => {
          this.listeners.forEach(r => {
            r(n)
          })
        })
      }
      onFocus() {
        as.batch(() => {
          this.getAll().forEach(n => {
            n.onFocus()
          })
        })
      }
      onOnline() {
        as.batch(() => {
          this.getAll().forEach(n => {
            n.onOnline()
          })
        })
      }
    }),
    (Gi = new WeakMap()),
    YT),
  Qi,
  ns,
  Kc,
  Zi,
  wa,
  JT,
  iL =
    ((JT = class extends JP {
      constructor(e) {
        super()
        Jt(this, Zi)
        Jt(this, Qi)
        Jt(this, ns)
        Jt(this, Kc)
        ;(this.mutationId = e.mutationId),
          Pt(this, ns, e.mutationCache),
          Pt(this, Qi, []),
          (this.state = e.state || oL()),
          this.setOptions(e.options),
          this.scheduleGc()
      }
      setOptions(e) {
        ;(this.options = e), this.updateGcTime(this.options.gcTime)
      }
      get meta() {
        return this.options.meta
      }
      addObserver(e) {
        Ee(this, Qi).includes(e) ||
          (Ee(this, Qi).push(e),
          this.clearGcTimeout(),
          Ee(this, ns).notify({ type: 'observerAdded', mutation: this, observer: e }))
      }
      removeObserver(e) {
        Pt(
          this,
          Qi,
          Ee(this, Qi).filter(n => n !== e)
        ),
          this.scheduleGc(),
          Ee(this, ns).notify({ type: 'observerRemoved', mutation: this, observer: e })
      }
      optionalRemove() {
        Ee(this, Qi).length ||
          (this.state.status === 'pending' ? this.scheduleGc() : Ee(this, ns).remove(this))
      }
      continue() {
        var e
        return (
          ((e = Ee(this, Kc)) == null ? void 0 : e.continue()) ?? this.execute(this.state.variables)
        )
      }
      async execute(e) {
        var s, i, o, a, c, u, l, d, h, p, y, m, b, I, x, _, R, N, T, M
        Pt(
          this,
          Kc,
          YP({
            fn: () =>
              this.options.mutationFn
                ? this.options.mutationFn(e)
                : Promise.reject(new Error('No mutationFn found')),
            onFail: (H, B) => {
              Dr(this, Zi, wa).call(this, { type: 'failed', failureCount: H, error: B })
            },
            onPause: () => {
              Dr(this, Zi, wa).call(this, { type: 'pause' })
            },
            onContinue: () => {
              Dr(this, Zi, wa).call(this, { type: 'continue' })
            },
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => Ee(this, ns).canRun(this)
          })
        )
        const n = this.state.status === 'pending',
          r = !Ee(this, Kc).canStart()
        try {
          if (!n) {
            Dr(this, Zi, wa).call(this, { type: 'pending', variables: e, isPaused: r }),
              await ((i = (s = Ee(this, ns).config).onMutate) == null ? void 0 : i.call(s, e, this))
            const B = await ((a = (o = this.options).onMutate) == null ? void 0 : a.call(o, e))
            B !== this.state.context &&
              Dr(this, Zi, wa).call(this, {
                type: 'pending',
                context: B,
                variables: e,
                isPaused: r
              })
          }
          const H = await Ee(this, Kc).start()
          return (
            await ((u = (c = Ee(this, ns).config).onSuccess) == null
              ? void 0
              : u.call(c, H, e, this.state.context, this)),
            await ((d = (l = this.options).onSuccess) == null
              ? void 0
              : d.call(l, H, e, this.state.context)),
            await ((p = (h = Ee(this, ns).config).onSettled) == null
              ? void 0
              : p.call(h, H, null, this.state.variables, this.state.context, this)),
            await ((m = (y = this.options).onSettled) == null
              ? void 0
              : m.call(y, H, null, e, this.state.context)),
            Dr(this, Zi, wa).call(this, { type: 'success', data: H }),
            H
          )
        } catch (H) {
          try {
            throw (
              (await ((I = (b = Ee(this, ns).config).onError) == null
                ? void 0
                : I.call(b, H, e, this.state.context, this)),
              await ((_ = (x = this.options).onError) == null
                ? void 0
                : _.call(x, H, e, this.state.context)),
              await ((N = (R = Ee(this, ns).config).onSettled) == null
                ? void 0
                : N.call(R, void 0, H, this.state.variables, this.state.context, this)),
              await ((M = (T = this.options).onSettled) == null
                ? void 0
                : M.call(T, void 0, H, e, this.state.context)),
              H)
            )
          } finally {
            Dr(this, Zi, wa).call(this, { type: 'error', error: H })
          }
        } finally {
          Ee(this, ns).runNext(this)
        }
      }
    }),
    (Qi = new WeakMap()),
    (ns = new WeakMap()),
    (Kc = new WeakMap()),
    (Zi = new WeakSet()),
    (wa = function (e) {
      const n = r => {
        switch (e.type) {
          case 'failed':
            return { ...r, failureCount: e.failureCount, failureReason: e.error }
          case 'pause':
            return { ...r, isPaused: !0 }
          case 'continue':
            return { ...r, isPaused: !1 }
          case 'pending':
            return {
              ...r,
              context: e.context,
              data: void 0,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: e.isPaused,
              status: 'pending',
              variables: e.variables,
              submittedAt: Date.now()
            }
          case 'success':
            return {
              ...r,
              data: e.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: 'success',
              isPaused: !1
            }
          case 'error':
            return {
              ...r,
              data: void 0,
              error: e.error,
              failureCount: r.failureCount + 1,
              failureReason: e.error,
              isPaused: !1,
              status: 'error'
            }
        }
      }
      ;(this.state = n(this.state)),
        as.batch(() => {
          Ee(this, Qi).forEach(r => {
            r.onMutationUpdate(e)
          }),
            Ee(this, ns).notify({ mutation: this, type: 'updated', action: e })
        })
    }),
    JT)
function oL() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: 'idle',
    variables: void 0,
    submittedAt: 0
  }
}
var Os,
  Yf,
  XT,
  eR =
    ((XT = class extends c0 {
      constructor(n = {}) {
        super()
        Jt(this, Os)
        Jt(this, Yf)
        ;(this.config = n), Pt(this, Os, new Map()), Pt(this, Yf, Date.now())
      }
      build(n, r, s) {
        const i = new iL({
          mutationCache: this,
          mutationId: ++kp(this, Yf)._,
          options: n.defaultMutationOptions(r),
          state: s
        })
        return this.add(i), i
      }
      add(n) {
        const r = jp(n),
          s = Ee(this, Os).get(r) ?? []
        s.push(n), Ee(this, Os).set(r, s), this.notify({ type: 'added', mutation: n })
      }
      remove(n) {
        var s
        const r = jp(n)
        if (Ee(this, Os).has(r)) {
          const i = (s = Ee(this, Os).get(r)) == null ? void 0 : s.filter(o => o !== n)
          i && (i.length === 0 ? Ee(this, Os).delete(r) : Ee(this, Os).set(r, i))
        }
        this.notify({ type: 'removed', mutation: n })
      }
      canRun(n) {
        var s
        const r =
          (s = Ee(this, Os).get(jp(n))) == null ? void 0 : s.find(i => i.state.status === 'pending')
        return !r || r === n
      }
      runNext(n) {
        var s
        const r =
          (s = Ee(this, Os).get(jp(n))) == null ? void 0 : s.find(i => i !== n && i.state.isPaused)
        return (r == null ? void 0 : r.continue()) ?? Promise.resolve()
      }
      clear() {
        as.batch(() => {
          this.getAll().forEach(n => {
            this.remove(n)
          })
        })
      }
      getAll() {
        return [...Ee(this, Os).values()].flat()
      }
      find(n) {
        const r = { exact: !0, ...n }
        return this.getAll().find(s => yC(r, s))
      }
      findAll(n = {}) {
        return this.getAll().filter(r => yC(n, r))
      }
      notify(n) {
        as.batch(() => {
          this.listeners.forEach(r => {
            r(n)
          })
        })
      }
      resumePausedMutations() {
        const n = this.getAll().filter(r => r.state.isPaused)
        return as.batch(() => Promise.all(n.map(r => r.continue().catch(vi))))
      }
    }),
    (Os = new WeakMap()),
    (Yf = new WeakMap()),
    XT)
function jp(t) {
  var e
  return ((e = t.options.scope) == null ? void 0 : e.id) ?? String(t.mutationId)
}
function vC(t) {
  return {
    onFetch: (e, n) => {
      var l, d, h, p, y
      const r = e.options,
        s =
          (h =
            (d = (l = e.fetchOptions) == null ? void 0 : l.meta) == null ? void 0 : d.fetchMore) ==
          null
            ? void 0
            : h.direction,
        i = ((p = e.state.data) == null ? void 0 : p.pages) || [],
        o = ((y = e.state.data) == null ? void 0 : y.pageParams) || []
      let a = { pages: [], pageParams: [] },
        c = 0
      const u = async () => {
        let m = !1
        const b = _ => {
            Object.defineProperty(_, 'signal', {
              enumerable: !0,
              get: () => (
                e.signal.aborted
                  ? (m = !0)
                  : e.signal.addEventListener('abort', () => {
                      m = !0
                    }),
                e.signal
              )
            })
          },
          I = VP(e.options, e.fetchOptions),
          x = async (_, R, N) => {
            if (m) return Promise.reject()
            if (R == null && _.pages.length) return Promise.resolve(_)
            const T = {
              queryKey: e.queryKey,
              pageParam: R,
              direction: N ? 'backward' : 'forward',
              meta: e.options.meta
            }
            b(T)
            const M = await I(T),
              { maxPages: H } = e.options,
              B = N ? ZU : QU
            return { pages: B(_.pages, M, H), pageParams: B(_.pageParams, R, H) }
          }
        if (s && i.length) {
          const _ = s === 'backward',
            R = _ ? aL : EC,
            N = { pages: i, pageParams: o },
            T = R(r, N)
          a = await x(N, T, _)
        } else {
          const _ = t ?? i.length
          do {
            const R = c === 0 ? (o[0] ?? r.initialPageParam) : EC(r, a)
            if (c > 0 && R == null) break
            ;(a = await x(a, R)), c++
          } while (c < _)
        }
        return a
      }
      e.options.persister
        ? (e.fetchFn = () => {
            var m, b
            return (b = (m = e.options).persister) == null
              ? void 0
              : b.call(m, u, { queryKey: e.queryKey, meta: e.options.meta, signal: e.signal }, n)
          })
        : (e.fetchFn = u)
    }
  }
}
function EC(t, { pages: e, pageParams: n }) {
  const r = e.length - 1
  return e.length > 0 ? t.getNextPageParam(e[r], e, n[r], n) : void 0
}
function aL(t, { pages: e, pageParams: n }) {
  var r
  return e.length > 0
    ? (r = t.getPreviousPageParam) == null
      ? void 0
      : r.call(t, e[0], e, n[0], n)
    : void 0
}
var $n,
  Oa,
  Ba,
  Hl,
  ql,
  Da,
  zl,
  Wl,
  eN,
  cL =
    ((eN = class {
      constructor(e = {}) {
        Jt(this, $n)
        Jt(this, Oa)
        Jt(this, Ba)
        Jt(this, Hl)
        Jt(this, ql)
        Jt(this, Da)
        Jt(this, zl)
        Jt(this, Wl)
        Pt(this, $n, e.queryCache || new XP()),
          Pt(this, Oa, e.mutationCache || new eR()),
          Pt(this, Ba, e.defaultOptions || {}),
          Pt(this, Hl, new Map()),
          Pt(this, ql, new Map()),
          Pt(this, Da, 0)
      }
      mount() {
        kp(this, Da)._++,
          Ee(this, Da) === 1 &&
            (Pt(
              this,
              zl,
              GP.subscribe(async e => {
                e && (await this.resumePausedMutations(), Ee(this, $n).onFocus())
              })
            ),
            Pt(
              this,
              Wl,
              im.subscribe(async e => {
                e && (await this.resumePausedMutations(), Ee(this, $n).onOnline())
              })
            ))
      }
      unmount() {
        var e, n
        kp(this, Da)._--,
          Ee(this, Da) === 0 &&
            ((e = Ee(this, zl)) == null || e.call(this),
            Pt(this, zl, void 0),
            (n = Ee(this, Wl)) == null || n.call(this),
            Pt(this, Wl, void 0))
      }
      isFetching(e) {
        return Ee(this, $n).findAll({ ...e, fetchStatus: 'fetching' }).length
      }
      isMutating(e) {
        return Ee(this, Oa).findAll({ ...e, status: 'pending' }).length
      }
      getQueryData(e) {
        var r
        const n = this.defaultQueryOptions({ queryKey: e })
        return (r = Ee(this, $n).get(n.queryHash)) == null ? void 0 : r.state.data
      }
      ensureQueryData(e) {
        const n = this.getQueryData(e.queryKey)
        if (n === void 0) return this.fetchQuery(e)
        {
          const r = this.defaultQueryOptions(e),
            s = Ee(this, $n).build(this, r)
          return (
            e.revalidateIfStale && s.isStaleByTime(gC(r.staleTime, s)) && this.prefetchQuery(r),
            Promise.resolve(n)
          )
        }
      }
      getQueriesData(e) {
        return Ee(this, $n)
          .findAll(e)
          .map(({ queryKey: n, state: r }) => {
            const s = r.data
            return [n, s]
          })
      }
      setQueryData(e, n, r) {
        const s = this.defaultQueryOptions({ queryKey: e }),
          i = Ee(this, $n).get(s.queryHash),
          o = i == null ? void 0 : i.state.data,
          a = qU(n, o)
        if (a !== void 0)
          return Ee(this, $n)
            .build(this, s)
            .setData(a, { ...r, manual: !0 })
      }
      setQueriesData(e, n, r) {
        return as.batch(() =>
          Ee(this, $n)
            .findAll(e)
            .map(({ queryKey: s }) => [s, this.setQueryData(s, n, r)])
        )
      }
      getQueryState(e) {
        var r
        const n = this.defaultQueryOptions({ queryKey: e })
        return (r = Ee(this, $n).get(n.queryHash)) == null ? void 0 : r.state
      }
      removeQueries(e) {
        const n = Ee(this, $n)
        as.batch(() => {
          n.findAll(e).forEach(r => {
            n.remove(r)
          })
        })
      }
      resetQueries(e, n) {
        const r = Ee(this, $n),
          s = { type: 'active', ...e }
        return as.batch(
          () => (
            r.findAll(e).forEach(i => {
              i.reset()
            }),
            this.refetchQueries(s, n)
          )
        )
      }
      cancelQueries(e = {}, n = {}) {
        const r = { revert: !0, ...n },
          s = as.batch(() =>
            Ee(this, $n)
              .findAll(e)
              .map(i => i.cancel(r))
          )
        return Promise.all(s).then(vi).catch(vi)
      }
      invalidateQueries(e = {}, n = {}) {
        return as.batch(() => {
          if (
            (Ee(this, $n)
              .findAll(e)
              .forEach(s => {
                s.invalidate()
              }),
            e.refetchType === 'none')
          )
            return Promise.resolve()
          const r = { ...e, type: e.refetchType ?? e.type ?? 'active' }
          return this.refetchQueries(r, n)
        })
      }
      refetchQueries(e = {}, n) {
        const r = { ...n, cancelRefetch: (n == null ? void 0 : n.cancelRefetch) ?? !0 },
          s = as.batch(() =>
            Ee(this, $n)
              .findAll(e)
              .filter(i => !i.isDisabled())
              .map(i => {
                let o = i.fetch(void 0, r)
                return (
                  r.throwOnError || (o = o.catch(vi)),
                  i.state.fetchStatus === 'paused' ? Promise.resolve() : o
                )
              })
          )
        return Promise.all(s).then(vi)
      }
      fetchQuery(e) {
        const n = this.defaultQueryOptions(e)
        n.retry === void 0 && (n.retry = !1)
        const r = Ee(this, $n).build(this, n)
        return r.isStaleByTime(gC(n.staleTime, r)) ? r.fetch(n) : Promise.resolve(r.state.data)
      }
      prefetchQuery(e) {
        return this.fetchQuery(e).then(vi).catch(vi)
      }
      fetchInfiniteQuery(e) {
        return (e.behavior = vC(e.pages)), this.fetchQuery(e)
      }
      prefetchInfiniteQuery(e) {
        return this.fetchInfiniteQuery(e).then(vi).catch(vi)
      }
      ensureInfiniteQueryData(e) {
        return (e.behavior = vC(e.pages)), this.ensureQueryData(e)
      }
      resumePausedMutations() {
        return im.isOnline() ? Ee(this, Oa).resumePausedMutations() : Promise.resolve()
      }
      getQueryCache() {
        return Ee(this, $n)
      }
      getMutationCache() {
        return Ee(this, Oa)
      }
      getDefaultOptions() {
        return Ee(this, Ba)
      }
      setDefaultOptions(e) {
        Pt(this, Ba, e)
      }
      setQueryDefaults(e, n) {
        Ee(this, Hl).set(Qh(e), { queryKey: e, defaultOptions: n })
      }
      getQueryDefaults(e) {
        const n = [...Ee(this, Hl).values()]
        let r = {}
        return (
          n.forEach(s => {
            Zh(e, s.queryKey) && (r = { ...r, ...s.defaultOptions })
          }),
          r
        )
      }
      setMutationDefaults(e, n) {
        Ee(this, ql).set(Qh(e), { mutationKey: e, defaultOptions: n })
      }
      getMutationDefaults(e) {
        const n = [...Ee(this, ql).values()]
        let r = {}
        return (
          n.forEach(s => {
            Zh(e, s.mutationKey) && (r = { ...r, ...s.defaultOptions })
          }),
          r
        )
      }
      defaultQueryOptions(e) {
        if (e._defaulted) return e
        const n = {
          ...Ee(this, Ba).queries,
          ...this.getQueryDefaults(e.queryKey),
          ...e,
          _defaulted: !0
        }
        return (
          n.queryHash || (n.queryHash = OE(n.queryKey, n)),
          n.refetchOnReconnect === void 0 && (n.refetchOnReconnect = n.networkMode !== 'always'),
          n.throwOnError === void 0 && (n.throwOnError = !!n.suspense),
          !n.networkMode && n.persister && (n.networkMode = 'offlineFirst'),
          n.enabled !== !0 && n.queryFn === BE && (n.enabled = !1),
          n
        )
      }
      defaultMutationOptions(e) {
        return e != null && e._defaulted
          ? e
          : {
              ...Ee(this, Ba).mutations,
              ...((e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey)),
              ...e,
              _defaulted: !0
            }
      }
      clear() {
        Ee(this, $n).clear(), Ee(this, Oa).clear()
      }
    }),
    ($n = new WeakMap()),
    (Oa = new WeakMap()),
    (Ba = new WeakMap()),
    (Hl = new WeakMap()),
    (ql = new WeakMap()),
    (Da = new WeakMap()),
    (zl = new WeakMap()),
    (Wl = new WeakMap()),
    eN),
  uL = 'VUE_QUERY_CLIENT'
function lL(t) {
  const e = t ? `:${t}` : ''
  return `${uL}${e}`
}
function y1(t, e, n = '', r = 0) {
  if (e) {
    const s = e(t, n, r)
    if ((s === void 0 && Vn(t)) || s !== void 0) return s
  }
  if (Array.isArray(t)) return t.map((s, i) => y1(s, e, String(i), r + 1))
  if (typeof t == 'object' && hL(t)) {
    const s = Object.entries(t).map(([i, o]) => [i, y1(o, e, i, r + 1)])
    return Object.fromEntries(s)
  }
  return t
}
function dL(t, e) {
  return y1(t, e)
}
function Ut(t, e = !1) {
  return dL(t, (n, r, s) => {
    if (s === 1 && r === 'queryKey') return Ut(n, !0)
    if (e && fL(n)) return Ut(n(), e)
    if (Vn(n)) return Ut(Qn(n), e)
  })
}
function hL(t) {
  if (Object.prototype.toString.call(t) !== '[object Object]') return !1
  const e = Object.getPrototypeOf(t)
  return e === null || e === Object.prototype
}
function fL(t) {
  return typeof t == 'function'
}
var pL = class extends XP {
    find(t) {
      return super.find(Ut(t))
    }
    findAll(t = {}) {
      return super.findAll(Ut(t))
    }
  },
  gL = class extends eR {
    find(t) {
      return super.find(Ut(t))
    }
    findAll(t = {}) {
      return super.findAll(Ut(t))
    }
  },
  tR = class extends cL {
    constructor(t = {}) {
      const e = {
        defaultOptions: t.defaultOptions,
        queryCache: t.queryCache || new pL(),
        mutationCache: t.mutationCache || new gL()
      }
      super(e), (this.isRestoring = wr(!1))
    }
    isFetching(t = {}) {
      return super.isFetching(Ut(t))
    }
    isMutating(t = {}) {
      return super.isMutating(Ut(t))
    }
    getQueryData(t) {
      return super.getQueryData(Ut(t))
    }
    ensureQueryData(t) {
      return super.ensureQueryData(Ut(t))
    }
    getQueriesData(t) {
      return super.getQueriesData(Ut(t))
    }
    setQueryData(t, e, n = {}) {
      return super.setQueryData(Ut(t), e, Ut(n))
    }
    setQueriesData(t, e, n = {}) {
      return super.setQueriesData(Ut(t), e, Ut(n))
    }
    getQueryState(t) {
      return super.getQueryState(Ut(t))
    }
    removeQueries(t = {}) {
      return super.removeQueries(Ut(t))
    }
    resetQueries(t = {}, e = {}) {
      return super.resetQueries(Ut(t), Ut(e))
    }
    cancelQueries(t = {}, e = {}) {
      return super.cancelQueries(Ut(t), Ut(e))
    }
    invalidateQueries(t = {}, e = {}) {
      const n = Ut(t),
        r = Ut(e)
      if ((super.invalidateQueries({ ...n, refetchType: 'none' }, r), n.refetchType === 'none'))
        return Promise.resolve()
      const s = { ...n, type: n.refetchType ?? n.type ?? 'active' }
      return aE().then(() => super.refetchQueries(s, r))
    }
    refetchQueries(t = {}, e = {}) {
      return super.refetchQueries(Ut(t), Ut(e))
    }
    fetchQuery(t) {
      return super.fetchQuery(Ut(t))
    }
    prefetchQuery(t) {
      return super.prefetchQuery(Ut(t))
    }
    fetchInfiniteQuery(t) {
      return super.fetchInfiniteQuery(Ut(t))
    }
    prefetchInfiniteQuery(t) {
      return super.prefetchInfiniteQuery(Ut(t))
    }
    setDefaultOptions(t) {
      super.setDefaultOptions(Ut(t))
    }
    setQueryDefaults(t, e) {
      super.setQueryDefaults(Ut(t), Ut(e))
    }
    getQueryDefaults(t) {
      return super.getQueryDefaults(Ut(t))
    }
    setMutationDefaults(t, e) {
      super.setMutationDefaults(Ut(t), Ut(e))
    }
    getMutationDefaults(t) {
      return super.getMutationDefaults(Ut(t))
    }
  },
  mL = {
    install: (t, e = {}) => {
      const n = lL(e.queryClientKey)
      let r
      if ('queryClient' in e && e.queryClient) r = e.queryClient
      else {
        const o = 'queryClientConfig' in e ? e.queryClientConfig : void 0
        r = new tR(o)
      }
      tp || r.mount()
      let s = () => {}
      if (e.clientPersister) {
        r.isRestoring.value = !0
        const [o, a] = e.clientPersister(r)
        ;(s = o),
          a.then(() => {
            var c
            ;(r.isRestoring.value = !1), (c = e.clientPersisterOnSuccess) == null || c.call(e, r)
          })
      }
      const i = () => {
        r.unmount(), s()
      }
      if (t.onUnmount) t.onUnmount(i)
      else {
        const o = t.unmount
        t.unmount = function () {
          i(), o()
        }
      }
      t.provide(n, r)
    }
  }
const yL = po(t => {
    const e = new tR({ defaultOptions: { queries: { staleTime: 5e3 } } })
    t.vueApp.use(mL, { queryClient: e, enableDevtoolsV6Plugin: !0 })
  }),
  nR = '2.23.13'
let $d = {
    getDocsUrl: ({ docsBaseUrl: t, docsPath: e = '', docsSlug: n }) =>
      e ? `${t ?? 'https://viem.sh'}${e}${n ? `#${n}` : ''}` : void 0,
    version: `viem@${nR}`
  },
  Se = class w1 extends Error {
    constructor(e, n = {}) {
      var a
      const r = (() => {
          var c
          return n.cause instanceof w1
            ? n.cause.details
            : (c = n.cause) != null && c.message
              ? n.cause.message
              : n.details
        })(),
        s = (n.cause instanceof w1 && n.cause.docsPath) || n.docsPath,
        i = (a = $d.getDocsUrl) == null ? void 0 : a.call($d, { ...n, docsPath: s }),
        o = [
          e || 'An error occurred.',
          '',
          ...(n.metaMessages ? [...n.metaMessages, ''] : []),
          ...(i ? [`Docs: ${i}`] : []),
          ...(r ? [`Details: ${r}`] : []),
          ...($d.version ? [`Version: ${$d.version}`] : [])
        ].join(`
`)
      super(o, n.cause ? { cause: n.cause } : void 0),
        Object.defineProperty(this, 'details', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'docsPath', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'metaMessages', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'shortMessage', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'version', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, 'name', {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: 'BaseError'
        }),
        (this.details = r),
        (this.docsPath = s),
        (this.metaMessages = n.metaMessages),
        (this.name = n.name ?? this.name),
        (this.shortMessage = e),
        (this.version = nR)
    }
    walk(e) {
      return rR(this, e)
    }
  }
function rR(t, e) {
  return e != null && e(t)
    ? t
    : t && typeof t == 'object' && 'cause' in t && t.cause !== void 0
      ? rR(t.cause, e)
      : e
        ? null
        : t
}
let sR = class extends Se {
  constructor({ max: e, min: n, signed: r, size: s, value: i }) {
    super(
      `Number "${i}" is not in safe ${s ? `${s * 8}-bit ${r ? 'signed' : 'unsigned'} ` : ''}integer range ${e ? `(${n} to ${e})` : `(above ${n})`}`,
      { name: 'IntegerOutOfRangeError' }
    )
  }
}
class wL extends Se {
  constructor(e) {
    super(
      `Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,
      { name: 'InvalidBytesBooleanError' }
    )
  }
}
let bL = class extends Se {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${e} bytes.`, { name: 'SizeOverflowError' })
  }
}
class iR extends Se {
  constructor({ offset: e, position: n, size: r }) {
    super(
      `Slice ${n === 'start' ? 'starting' : 'ending'} at offset "${e}" is out-of-bounds (size: ${r}).`,
      { name: 'SliceOffsetOutOfBoundsError' }
    )
  }
}
let oR = class extends Se {
  constructor({ size: e, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${e}) exceeds padding size (${n}).`,
      { name: 'SizeExceedsPaddingSizeError' }
    )
  }
}
class AC extends Se {
  constructor({ size: e, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} is expected to be ${n} ${r} long, but is ${e} ${r} long.`,
      { name: 'InvalidBytesLengthError' }
    )
  }
}
function yd(t, { dir: e, size: n = 32 } = {}) {
  return typeof t == 'string' ? ja(t, { dir: e, size: n }) : vL(t, { dir: e, size: n })
}
function ja(t, { dir: e, size: n = 32 } = {}) {
  if (n === null) return t
  const r = t.replace('0x', '')
  if (r.length > n * 2) throw new oR({ size: Math.ceil(r.length / 2), targetSize: n, type: 'hex' })
  return `0x${r[e === 'right' ? 'padEnd' : 'padStart'](n * 2, '0')}`
}
function vL(t, { dir: e, size: n = 32 } = {}) {
  if (n === null) return t
  if (t.length > n) throw new oR({ size: t.length, targetSize: n, type: 'bytes' })
  const r = new Uint8Array(n)
  for (let s = 0; s < n; s++) {
    const i = e === 'right'
    r[i ? s : n - s - 1] = t[i ? s : t.length - s - 1]
  }
  return r
}
function Yo(t, { strict: e = !0 } = {}) {
  return !t || typeof t != 'string' ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith('0x')
}
function ir(t) {
  return Yo(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length
}
function io(t, { dir: e = 'left' } = {}) {
  let n = typeof t == 'string' ? t.replace('0x', '') : t,
    r = 0
  for (
    let s = 0;
    s < n.length - 1 && n[e === 'left' ? s : n.length - s - 1].toString() === '0';
    s++
  )
    r++
  return (
    (n = e === 'left' ? n.slice(r) : n.slice(0, n.length - r)),
    typeof t == 'string'
      ? (n.length === 1 && e === 'right' && (n = `${n}0`), `0x${n.length % 2 === 1 ? `0${n}` : n}`)
      : n
  )
}
const EL = new TextEncoder()
function np(t, e = {}) {
  return typeof t == 'number' || typeof t == 'bigint'
    ? _L(t, e)
    : typeof t == 'boolean'
      ? AL(t, e)
      : Yo(t)
        ? oo(t, e)
        : Yc(t, e)
}
function AL(t, e = {}) {
  const n = new Uint8Array(1)
  return (
    (n[0] = Number(t)),
    typeof e.size == 'number' ? (Di(n, { size: e.size }), yd(n, { size: e.size })) : n
  )
}
const vo = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 }
function _C(t) {
  if (t >= vo.zero && t <= vo.nine) return t - vo.zero
  if (t >= vo.A && t <= vo.F) return t - (vo.A - 10)
  if (t >= vo.a && t <= vo.f) return t - (vo.a - 10)
}
function oo(t, e = {}) {
  let n = t
  e.size && (Di(n, { size: e.size }), (n = yd(n, { dir: 'right', size: e.size })))
  let r = n.slice(2)
  r.length % 2 && (r = `0${r}`)
  const s = r.length / 2,
    i = new Uint8Array(s)
  for (let o = 0, a = 0; o < s; o++) {
    const c = _C(r.charCodeAt(a++)),
      u = _C(r.charCodeAt(a++))
    if (c === void 0 || u === void 0)
      throw new Se(`Invalid byte sequence ("${r[a - 2]}${r[a - 1]}" in "${r}").`)
    i[o] = c * 16 + u
  }
  return i
}
function _L(t, e) {
  const n = Mt(t, e)
  return oo(n)
}
function Yc(t, e = {}) {
  const n = EL.encode(t)
  return typeof e.size == 'number'
    ? (Di(n, { size: e.size }), yd(n, { dir: 'right', size: e.size }))
    : n
}
function Di(t, { size: e }) {
  if (ir(t) > e) throw new bL({ givenSize: ir(t), maxSize: e })
}
function Ci(t, e = {}) {
  const { signed: n } = e
  e.size && Di(t, { size: e.size })
  const r = BigInt(t)
  if (!n) return r
  const s = (t.length - 2) / 2,
    i = (1n << (BigInt(s) * 8n - 1n)) - 1n
  return r <= i ? r : r - BigInt(`0x${'f'.padStart(s * 2, 'f')}`) - 1n
}
function Ya(t, e = {}) {
  return Number(Ci(t, e))
}
function aR(t, e = {}) {
  let n = oo(t)
  return (
    e.size && (Di(n, { size: e.size }), (n = io(n, { dir: 'right' }))), new TextDecoder().decode(n)
  )
}
const CL = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, '0'))
function wt(t, e = {}) {
  return typeof t == 'number' || typeof t == 'bigint'
    ? Mt(t, e)
    : typeof t == 'string'
      ? u0(t, e)
      : typeof t == 'boolean'
        ? cR(t, e)
        : br(t, e)
}
function cR(t, e = {}) {
  const n = `0x${Number(t)}`
  return typeof e.size == 'number' ? (Di(n, { size: e.size }), yd(n, { size: e.size })) : n
}
function br(t, e = {}) {
  let n = ''
  for (let s = 0; s < t.length; s++) n += CL[t[s]]
  const r = `0x${n}`
  return typeof e.size == 'number'
    ? (Di(r, { size: e.size }), yd(r, { dir: 'right', size: e.size }))
    : r
}
function Mt(t, e = {}) {
  const { signed: n, size: r } = e,
    s = BigInt(t)
  let i
  r
    ? n
      ? (i = (1n << (BigInt(r) * 8n - 1n)) - 1n)
      : (i = 2n ** (BigInt(r) * 8n) - 1n)
    : typeof t == 'number' && (i = BigInt(Number.MAX_SAFE_INTEGER))
  const o = typeof i == 'bigint' && n ? -i - 1n : 0
  if ((i && s > i) || s < o) {
    const c = typeof t == 'bigint' ? 'n' : ''
    throw new sR({
      max: i ? `${i}${c}` : void 0,
      min: `${o}${c}`,
      signed: n,
      size: r,
      value: `${t}${c}`
    })
  }
  const a = `0x${(n && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`
  return r ? yd(a, { size: r }) : a
}
const SL = new TextEncoder()
function u0(t, e = {}) {
  const n = SL.encode(t)
  return br(n, e)
}
function Ja(t, { includeName: e = !1 } = {}) {
  if (t.type !== 'function' && t.type !== 'event' && t.type !== 'error') throw new UL(t.type)
  return `${t.name}(${l0(t.inputs, { includeName: e })})`
}
function l0(t, { includeName: e = !1 } = {}) {
  return t ? t.map(n => IL(n, { includeName: e })).join(e ? ', ' : ',') : ''
}
function IL(t, { includeName: e }) {
  return t.type.startsWith('tuple')
    ? `(${l0(t.components, { includeName: e })})${t.type.slice(5)}`
    : t.type + (e && t.name ? ` ${t.name}` : '')
}
class xL extends Se {
  constructor({ docsPath: e }) {
    super(
      [
        'A constructor was not found on the ABI.',
        'Make sure you are using the correct ABI and that the constructor exists on it.'
      ].join(`
`),
      { docsPath: e, name: 'AbiConstructorNotFoundError' }
    )
  }
}
class CC extends Se {
  constructor({ docsPath: e }) {
    super(
      [
        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',
        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.'
      ].join(`
`),
      { docsPath: e, name: 'AbiConstructorParamsNotFoundError' }
    )
  }
}
class uR extends Se {
  constructor({ data: e, params: n, size: r }) {
    super(
      [`Data size of ${r} bytes is too small for given parameters.`].join(`
`),
      {
        metaMessages: [`Params: (${l0(n, { includeName: !0 })})`, `Data:   ${e} (${r} bytes)`],
        name: 'AbiDecodingDataSizeTooSmallError'
      }
    ),
      Object.defineProperty(this, 'data', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'params', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'size', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.data = e),
      (this.params = n),
      (this.size = r)
  }
}
class d0 extends Se {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: 'AbiDecodingZeroDataError'
    })
  }
}
class TL extends Se {
  constructor({ expectedLength: e, givenLength: n, type: r }) {
    super(
      [
        `ABI encoding array length mismatch for type ${r}.`,
        `Expected length: ${e}`,
        `Given length: ${n}`
      ].join(`
`),
      { name: 'AbiEncodingArrayLengthMismatchError' }
    )
  }
}
class NL extends Se {
  constructor({ expectedSize: e, value: n }) {
    super(`Size of bytes "${n}" (bytes${ir(n)}) does not match expected size (bytes${e}).`, {
      name: 'AbiEncodingBytesSizeMismatchError'
    })
  }
}
class PL extends Se {
  constructor({ expectedLength: e, givenLength: n }) {
    super(
      [
        'ABI encoding params/values length mismatch.',
        `Expected length (params): ${e}`,
        `Given length (values): ${n}`
      ].join(`
`),
      { name: 'AbiEncodingLengthMismatchError' }
    )
  }
}
class lR extends Se {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Encoded error signature "${e}" not found on ABI.`,
        'Make sure you are using the correct ABI and that the error exists on it.',
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`
      ].join(`
`),
      { docsPath: n, name: 'AbiErrorSignatureNotFoundError' }
    ),
      Object.defineProperty(this, 'signature', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.signature = e)
  }
}
class RL extends Se {
  constructor({ docsPath: e }) {
    super('Cannot extract event signature from empty topics.', {
      docsPath: e,
      name: 'AbiEventSignatureEmptyTopicsError'
    })
  }
}
class dR extends Se {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Encoded event signature "${e}" not found on ABI.`,
        'Make sure you are using the correct ABI and that the event exists on it.',
        `You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`
      ].join(`
`),
      { docsPath: n, name: 'AbiEventSignatureNotFoundError' }
    )
  }
}
class om extends Se {
  constructor(e, { docsPath: n } = {}) {
    super(
      [
        `Function ${e ? `"${e}" ` : ''}not found on ABI.`,
        'Make sure you are using the correct ABI and that the function exists on it.'
      ].join(`
`),
      { docsPath: n, name: 'AbiFunctionNotFoundError' }
    )
  }
}
class kL extends Se {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Function "${e}" does not contain any \`outputs\` on ABI.`,
        'Cannot decode function result without knowing what the parameter types are.',
        'Make sure you are using the correct ABI and that the function exists on it.'
      ].join(`
`),
      { docsPath: n, name: 'AbiFunctionOutputsNotFoundError' }
    )
  }
}
class OL extends Se {
  constructor(e, n) {
    super('Found ambiguous types in overloaded ABI items.', {
      metaMessages: [
        `\`${e.type}\` in \`${Ja(e.abiItem)}\`, and`,
        `\`${n.type}\` in \`${Ja(n.abiItem)}\``,
        '',
        'These types encode differently and cannot be distinguished at runtime.',
        'Remove one of the ambiguous items in the ABI.'
      ],
      name: 'AbiItemAmbiguityError'
    })
  }
}
class b1 extends Se {
  constructor({ abiItem: e, data: n, params: r, size: s }) {
    super(
      [`Data size of ${s} bytes is too small for non-indexed event parameters.`].join(`
`),
      {
        metaMessages: [`Params: (${l0(r, { includeName: !0 })})`, `Data:   ${n} (${s} bytes)`],
        name: 'DecodeLogDataMismatch'
      }
    ),
      Object.defineProperty(this, 'abiItem', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'data', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'params', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'size', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.abiItem = e),
      (this.data = n),
      (this.params = r),
      (this.size = s)
  }
}
class hR extends Se {
  constructor({ abiItem: e, param: n }) {
    super(
      [
        `Expected a topic for indexed event parameter${n.name ? ` "${n.name}"` : ''} on event "${Ja(e, { includeName: !0 })}".`
      ].join(`
`),
      { name: 'DecodeLogTopicsMismatch' }
    ),
      Object.defineProperty(this, 'abiItem', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.abiItem = e)
  }
}
class BL extends Se {
  constructor(e, { docsPath: n }) {
    super(
      [`Type "${e}" is not a valid encoding type.`, 'Please provide a valid ABI type.'].join(`
`),
      { docsPath: n, name: 'InvalidAbiEncodingType' }
    )
  }
}
class DL extends Se {
  constructor(e, { docsPath: n }) {
    super(
      [`Type "${e}" is not a valid decoding type.`, 'Please provide a valid ABI type.'].join(`
`),
      { docsPath: n, name: 'InvalidAbiDecodingType' }
    )
  }
}
class ML extends Se {
  constructor(e) {
    super(
      [`Value "${e}" is not a valid array.`].join(`
`),
      { name: 'InvalidArrayError' }
    )
  }
}
class UL extends Se {
  constructor(e) {
    super(
      [`"${e}" is not a valid definition type.`, 'Valid types: "function", "event", "error"'].join(`
`),
      { name: 'InvalidDefinitionTypeError' }
    )
  }
}
function su(t) {
  return typeof t[0] == 'string' ? na(t) : LL(t)
}
function LL(t) {
  let e = 0
  for (const s of t) e += s.length
  const n = new Uint8Array(e)
  let r = 0
  for (const s of t) n.set(s, r), (r += s.length)
  return n
}
function na(t) {
  return `0x${t.reduce((e, n) => e + n.replace('0x', ''), '')}`
}
class Cs extends Se {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        '- Address must be a hex value of 20 bytes (40 hex characters).',
        '- Address must match its checksum counterpart.'
      ],
      name: 'InvalidAddressError'
    })
  }
}
let h0 = class extends Map {
  constructor(e) {
    super(),
      Object.defineProperty(this, 'maxSize', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.maxSize = e)
  }
  get(e) {
    const n = super.get(e)
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n
  }
  set(e, n) {
    if ((super.set(e, n), this.maxSize && this.size > this.maxSize)) {
      const r = this.keys().next().value
      r && this.delete(r)
    }
    return this
  }
}
function am(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error('positive integer expected, got ' + t)
}
function $L(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function wd(t, ...e) {
  if (!$L(t)) throw new Error('Uint8Array expected')
  if (e.length > 0 && !e.includes(t.length))
    throw new Error('Uint8Array expected of length ' + e + ', got length=' + t.length)
}
function FL(t) {
  if (typeof t != 'function' || typeof t.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor')
  am(t.outputLen), am(t.blockLen)
}
function Ql(t, e = !0) {
  if (t.destroyed) throw new Error('Hash instance has been destroyed')
  if (e && t.finished) throw new Error('Hash#digest() has already been called')
}
function fR(t, e) {
  wd(t)
  const n = e.outputLen
  if (t.length < n) throw new Error('digestInto() expects output buffer of length at least ' + n)
}
const Hp = BigInt(2 ** 32 - 1),
  v1 = BigInt(32)
function pR(t, e = !1) {
  return e
    ? { h: Number(t & Hp), l: Number((t >> v1) & Hp) }
    : { h: Number((t >> v1) & Hp) | 0, l: Number(t & Hp) | 0 }
}
function gR(t, e = !1) {
  let n = new Uint32Array(t.length),
    r = new Uint32Array(t.length)
  for (let s = 0; s < t.length; s++) {
    const { h: i, l: o } = pR(t[s], e)
    ;[n[s], r[s]] = [i, o]
  }
  return [n, r]
}
const jL = (t, e) => (BigInt(t >>> 0) << v1) | BigInt(e >>> 0),
  HL = (t, e, n) => t >>> n,
  qL = (t, e, n) => (t << (32 - n)) | (e >>> n),
  zL = (t, e, n) => (t >>> n) | (e << (32 - n)),
  WL = (t, e, n) => (t << (32 - n)) | (e >>> n),
  KL = (t, e, n) => (t << (64 - n)) | (e >>> (n - 32)),
  VL = (t, e, n) => (t >>> (n - 32)) | (e << (64 - n)),
  GL = (t, e) => e,
  QL = (t, e) => t,
  mR = (t, e, n) => (t << n) | (e >>> (32 - n)),
  yR = (t, e, n) => (e << n) | (t >>> (32 - n)),
  wR = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
  bR = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n))
function ZL(t, e, n, r) {
  const s = (e >>> 0) + (r >>> 0)
  return { h: (t + n + ((s / 2 ** 32) | 0)) | 0, l: s | 0 }
}
const YL = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),
  JL = (t, e, n, r) => (e + n + r + ((t / 2 ** 32) | 0)) | 0,
  XL = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
  e$ = (t, e, n, r, s) => (e + n + r + s + ((t / 2 ** 32) | 0)) | 0,
  t$ = (t, e, n, r, s) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0),
  n$ = (t, e, n, r, s, i) => (e + n + r + s + i + ((t / 2 ** 32) | 0)) | 0,
  kt = {
    fromBig: pR,
    split: gR,
    toBig: jL,
    shrSH: HL,
    shrSL: qL,
    rotrSH: zL,
    rotrSL: WL,
    rotrBH: KL,
    rotrBL: VL,
    rotr32H: GL,
    rotr32L: QL,
    rotlSH: mR,
    rotlSL: yR,
    rotlBH: wR,
    rotlBL: bR,
    add: ZL,
    add3L: YL,
    add3H: JL,
    add4L: XL,
    add4H: e$,
    add5H: n$,
    add5L: t$
  },
  Lu = typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function r$(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4))
}
function Jy(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength)
}
function Ui(t, e) {
  return (t << (32 - e)) | (t >>> e)
}
const SC = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68
function s$(t) {
  return ((t << 24) & 4278190080) | ((t << 8) & 16711680) | ((t >>> 8) & 65280) | ((t >>> 24) & 255)
}
function IC(t) {
  for (let e = 0; e < t.length; e++) t[e] = s$(t[e])
}
const i$ = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, '0'))
function Oge(t) {
  wd(t)
  let e = ''
  for (let n = 0; n < t.length; n++) e += i$[t[n]]
  return e
}
function o$(t) {
  if (typeof t != 'string') throw new Error('utf8ToBytes expected string, got ' + typeof t)
  return new Uint8Array(new TextEncoder().encode(t))
}
function f0(t) {
  return typeof t == 'string' && (t = o$(t)), wd(t), t
}
function a$(...t) {
  let e = 0
  for (let r = 0; r < t.length; r++) {
    const s = t[r]
    wd(s), (e += s.length)
  }
  const n = new Uint8Array(e)
  for (let r = 0, s = 0; r < t.length; r++) {
    const i = t[r]
    n.set(i, s), (s += i.length)
  }
  return n
}
class DE {
  clone() {
    return this._cloneInto()
  }
}
function ME(t) {
  const e = r => t().update(f0(r)).digest(),
    n = t()
  return (e.outputLen = n.outputLen), (e.blockLen = n.blockLen), (e.create = () => t()), e
}
function vR(t = 32) {
  if (Lu && typeof Lu.getRandomValues == 'function') return Lu.getRandomValues(new Uint8Array(t))
  if (Lu && typeof Lu.randomBytes == 'function') return Lu.randomBytes(t)
  throw new Error('crypto.getRandomValues must be defined')
}
const ER = [],
  AR = [],
  _R = [],
  c$ = BigInt(0),
  Fd = BigInt(1),
  u$ = BigInt(2),
  l$ = BigInt(7),
  d$ = BigInt(256),
  h$ = BigInt(113)
for (let t = 0, e = Fd, n = 1, r = 0; t < 24; t++) {
  ;([n, r] = [r, (2 * n + 3 * r) % 5]),
    ER.push(2 * (5 * r + n)),
    AR.push((((t + 1) * (t + 2)) / 2) % 64)
  let s = c$
  for (let i = 0; i < 7; i++)
    (e = ((e << Fd) ^ ((e >> l$) * h$)) % d$), e & u$ && (s ^= Fd << ((Fd << BigInt(i)) - Fd))
  _R.push(s)
}
const [f$, p$] = gR(_R, !0),
  xC = (t, e, n) => (n > 32 ? wR(t, e, n) : mR(t, e, n)),
  TC = (t, e, n) => (n > 32 ? bR(t, e, n) : yR(t, e, n))
function g$(t, e = 24) {
  const n = new Uint32Array(10)
  for (let r = 24 - e; r < 24; r++) {
    for (let o = 0; o < 10; o++) n[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40]
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10,
        c = (o + 2) % 10,
        u = n[c],
        l = n[c + 1],
        d = xC(u, l, 1) ^ n[a],
        h = TC(u, l, 1) ^ n[a + 1]
      for (let p = 0; p < 50; p += 10) (t[o + p] ^= d), (t[o + p + 1] ^= h)
    }
    let s = t[2],
      i = t[3]
    for (let o = 0; o < 24; o++) {
      const a = AR[o],
        c = xC(s, i, a),
        u = TC(s, i, a),
        l = ER[o]
      ;(s = t[l]), (i = t[l + 1]), (t[l] = c), (t[l + 1] = u)
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) n[a] = t[o + a]
      for (let a = 0; a < 10; a++) t[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10]
    }
    ;(t[0] ^= f$[r]), (t[1] ^= p$[r])
  }
  n.fill(0)
}
class UE extends DE {
  constructor(e, n, r, s = !1, i = 24) {
    if (
      (super(),
      (this.blockLen = e),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = s),
      (this.rounds = i),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      am(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error('Sha3 supports only keccak-f1600 function')
    ;(this.state = new Uint8Array(200)), (this.state32 = r$(this.state))
  }
  keccak() {
    SC || IC(this.state32),
      g$(this.state32, this.rounds),
      SC || IC(this.state32),
      (this.posOut = 0),
      (this.pos = 0)
  }
  update(e) {
    Ql(this)
    const { blockLen: n, state: r } = this
    e = f0(e)
    const s = e.length
    for (let i = 0; i < s; ) {
      const o = Math.min(n - this.pos, s - i)
      for (let a = 0; a < o; a++) r[this.pos++] ^= e[i++]
      this.pos === n && this.keccak()
    }
    return this
  }
  finish() {
    if (this.finished) return
    this.finished = !0
    const { state: e, suffix: n, pos: r, blockLen: s } = this
    ;(e[r] ^= n), (n & 128) !== 0 && r === s - 1 && this.keccak(), (e[s - 1] ^= 128), this.keccak()
  }
  writeInto(e) {
    Ql(this, !1), wd(e), this.finish()
    const n = this.state,
      { blockLen: r } = this
    for (let s = 0, i = e.length; s < i; ) {
      this.posOut >= r && this.keccak()
      const o = Math.min(r - this.posOut, i - s)
      e.set(n.subarray(this.posOut, this.posOut + o), s), (this.posOut += o), (s += o)
    }
    return e
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error('XOF is not possible for this instance')
    return this.writeInto(e)
  }
  xof(e) {
    return am(e), this.xofInto(new Uint8Array(e))
  }
  digestInto(e) {
    if ((fR(e, this), this.finished)) throw new Error('digest() was already called')
    return this.writeInto(e), this.destroy(), e
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen))
  }
  destroy() {
    ;(this.destroyed = !0), this.state.fill(0)
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: s, rounds: i, enableXOF: o } = this
    return (
      e || (e = new UE(n, r, s, o, i)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = i),
      (e.suffix = r),
      (e.outputLen = s),
      (e.enableXOF = o),
      (e.destroyed = this.destroyed),
      e
    )
  }
}
const m$ = (t, e, n) => ME(() => new UE(e, t, n)),
  CR = m$(1, 136, 256 / 8)
function Xa(t, e) {
  const n = e || 'hex',
    r = CR(Yo(t, { strict: !1 }) ? np(t) : t)
  return n === 'bytes' ? r : wt(r)
}
const Xy = new h0(8192)
function p0(t, e) {
  if (Xy.has(`${t}.${e}`)) return Xy.get(`${t}.${e}`)
  const n = e ? `${e}${t.toLowerCase()}` : t.substring(2).toLowerCase(),
    r = Xa(Yc(n), 'bytes'),
    s = (e ? n.substring(`${e}0x`.length) : n).split('')
  for (let o = 0; o < 40; o += 2)
    r[o >> 1] >> 4 >= 8 && s[o] && (s[o] = s[o].toUpperCase()),
      (r[o >> 1] & 15) >= 8 && s[o + 1] && (s[o + 1] = s[o + 1].toUpperCase())
  const i = `0x${s.join('')}`
  return Xy.set(`${t}.${e}`, i), i
}
function Dc(t, e) {
  if (!Rr(t, { strict: !1 })) throw new Cs({ address: t })
  return p0(t, e)
}
const y$ = /^0x[a-fA-F0-9]{40}$/,
  ew = new h0(8192)
function Rr(t, e) {
  const { strict: n = !0 } = e ?? {},
    r = `${t}.${n}`
  if (ew.has(r)) return ew.get(r)
  const s = y$.test(t) ? (t.toLowerCase() === t ? !0 : n ? p0(t) === t : !0) : !1
  return ew.set(r, s), s
}
function Yh(t, e, n, { strict: r } = {}) {
  return Yo(t, { strict: !1 }) ? w$(t, e, n, { strict: r }) : xR(t, e, n, { strict: r })
}
function SR(t, e) {
  if (typeof e == 'number' && e > 0 && e > ir(t) - 1)
    throw new iR({ offset: e, position: 'start', size: ir(t) })
}
function IR(t, e, n) {
  if (typeof e == 'number' && typeof n == 'number' && ir(t) !== n - e)
    throw new iR({ offset: n, position: 'end', size: ir(t) })
}
function xR(t, e, n, { strict: r } = {}) {
  SR(t, e)
  const s = t.slice(e, n)
  return r && IR(s, e, n), s
}
function w$(t, e, n, { strict: r } = {}) {
  SR(t, e)
  const s = `0x${t.replace('0x', '').slice((e ?? 0) * 2, (n ?? t.length) * 2)}`
  return r && IR(s, e, n), s
}
const b$ =
  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/
function TR(t, e) {
  if (t.length !== e.length) throw new PL({ expectedLength: t.length, givenLength: e.length })
  const n = v$({ params: t, values: e }),
    r = $E(n)
  return r.length === 0 ? '0x' : r
}
function v$({ params: t, values: e }) {
  const n = []
  for (let r = 0; r < t.length; r++) n.push(LE({ param: t[r], value: e[r] }))
  return n
}
function LE({ param: t, value: e }) {
  const n = FE(t.type)
  if (n) {
    const [r, s] = n
    return A$(e, { length: r, param: { ...t, type: s } })
  }
  if (t.type === 'tuple') return x$(e, { param: t })
  if (t.type === 'address') return E$(e)
  if (t.type === 'bool') return C$(e)
  if (t.type.startsWith('uint') || t.type.startsWith('int')) {
    const r = t.type.startsWith('int'),
      [, , s = '256'] = b$.exec(t.type) ?? []
    return S$(e, { signed: r, size: Number(s) })
  }
  if (t.type.startsWith('bytes')) return _$(e, { param: t })
  if (t.type === 'string') return I$(e)
  throw new BL(t.type, { docsPath: '/docs/contract/encodeAbiParameters' })
}
function $E(t) {
  let e = 0
  for (let i = 0; i < t.length; i++) {
    const { dynamic: o, encoded: a } = t[i]
    o ? (e += 32) : (e += ir(a))
  }
  const n = [],
    r = []
  let s = 0
  for (let i = 0; i < t.length; i++) {
    const { dynamic: o, encoded: a } = t[i]
    o ? (n.push(Mt(e + s, { size: 32 })), r.push(a), (s += ir(a))) : n.push(a)
  }
  return su([...n, ...r])
}
function E$(t) {
  if (!Rr(t)) throw new Cs({ address: t })
  return { dynamic: !1, encoded: ja(t.toLowerCase()) }
}
function A$(t, { length: e, param: n }) {
  const r = e === null
  if (!Array.isArray(t)) throw new ML(t)
  if (!r && t.length !== e)
    throw new TL({ expectedLength: e, givenLength: t.length, type: `${n.type}[${e}]` })
  let s = !1
  const i = []
  for (let o = 0; o < t.length; o++) {
    const a = LE({ param: n, value: t[o] })
    a.dynamic && (s = !0), i.push(a)
  }
  if (r || s) {
    const o = $E(i)
    if (r) {
      const a = Mt(i.length, { size: 32 })
      return { dynamic: !0, encoded: i.length > 0 ? su([a, o]) : a }
    }
    if (s) return { dynamic: !0, encoded: o }
  }
  return { dynamic: !1, encoded: su(i.map(({ encoded: o }) => o)) }
}
function _$(t, { param: e }) {
  const [, n] = e.type.split('bytes'),
    r = ir(t)
  if (!n) {
    let s = t
    return (
      r % 32 !== 0 && (s = ja(s, { dir: 'right', size: Math.ceil((t.length - 2) / 2 / 32) * 32 })),
      { dynamic: !0, encoded: su([ja(Mt(r, { size: 32 })), s]) }
    )
  }
  if (r !== Number.parseInt(n)) throw new NL({ expectedSize: Number.parseInt(n), value: t })
  return { dynamic: !1, encoded: ja(t, { dir: 'right' }) }
}
function C$(t) {
  if (typeof t != 'boolean')
    throw new Se(
      `Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`
    )
  return { dynamic: !1, encoded: ja(cR(t)) }
}
function S$(t, { signed: e, size: n = 256 }) {
  if (typeof n == 'number') {
    const r = 2n ** (BigInt(n) - (e ? 1n : 0n)) - 1n,
      s = e ? -r - 1n : 0n
    if (t > r || t < s)
      throw new sR({
        max: r.toString(),
        min: s.toString(),
        signed: e,
        size: n / 8,
        value: t.toString()
      })
  }
  return { dynamic: !1, encoded: Mt(t, { size: 32, signed: e }) }
}
function I$(t) {
  const e = u0(t),
    n = Math.ceil(ir(e) / 32),
    r = []
  for (let s = 0; s < n; s++) r.push(ja(Yh(e, s * 32, (s + 1) * 32), { dir: 'right' }))
  return { dynamic: !0, encoded: su([ja(Mt(ir(e), { size: 32 })), ...r]) }
}
function x$(t, { param: e }) {
  let n = !1
  const r = []
  for (let s = 0; s < e.components.length; s++) {
    const i = e.components[s],
      o = Array.isArray(t) ? s : i.name,
      a = LE({ param: i, value: t[o] })
    r.push(a), a.dynamic && (n = !0)
  }
  return { dynamic: n, encoded: n ? $E(r) : su(r.map(({ encoded: s }) => s)) }
}
function FE(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/)
  return e ? [e[2] ? Number(e[2]) : null, e[1]] : void 0
}
const tw = '/docs/contract/encodeDeployData'
function NR(t) {
  const { abi: e, args: n, bytecode: r } = t
  if (!n || n.length === 0) return r
  const s = e.find(o => 'type' in o && o.type === 'constructor')
  if (!s) throw new xL({ docsPath: tw })
  if (!('inputs' in s)) throw new CC({ docsPath: tw })
  if (!s.inputs || s.inputs.length === 0) throw new CC({ docsPath: tw })
  const i = TR(s.inputs, n)
  return na([r, i])
}
function go(t) {
  return typeof t == 'string' ? { address: t, type: 'json-rpc' } : t
}
class jE extends Se {
  constructor({ docsPath: e } = {}) {
    super(
      [
        'Could not find an Account to execute with this Action.',
        'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.'
      ].join(`
`),
      { docsPath: e, docsSlug: 'account', name: 'AccountNotFoundError' }
    )
  }
}
class nw extends Se {
  constructor({ docsPath: e, metaMessages: n, type: r }) {
    super(`Account type "${r}" is not supported.`, {
      docsPath: e,
      metaMessages: n,
      name: 'AccountTypeNotSupportedError'
    })
  }
}
function T$(t) {
  const e = Xa(`0x${t.substring(4)}`).substring(26)
  return p0(`0x${e}`)
}
async function N$({ hash: t, signature: e }) {
  const n = Yo(t) ? t : wt(t),
    { secp256k1: r } = await qr(
      async () => {
        const { secp256k1: o } = await Promise.resolve().then(() => z3)
        return { secp256k1: o }
      },
      void 0,
      import.meta.url
    )
  return `0x${(() => {
    if (typeof e == 'object' && 'r' in e && 's' in e) {
      const { r: u, s: l, v: d, yParity: h } = e,
        p = Number(h ?? d),
        y = NC(p)
      return new r.Signature(Ci(u), Ci(l)).addRecoveryBit(y)
    }
    const o = Yo(e) ? e : wt(e),
      a = Ya(`0x${o.slice(130)}`),
      c = NC(a)
    return r.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(c)
  })()
    .recoverPublicKey(n.substring(2))
    .toHex(!1)}`
}
function NC(t) {
  if (t === 0 || t === 1) return t
  if (t === 27) return 0
  if (t === 28) return 1
  throw new Error('Invalid yParityOrV value')
}
async function P$({ hash: t, signature: e }) {
  return T$(await N$({ hash: t, signature: e }))
}
class PC extends Se {
  constructor({ offset: e }) {
    super(`Offset \`${e}\` cannot be negative.`, { name: 'NegativeOffsetError' })
  }
}
class PR extends Se {
  constructor({ length: e, position: n }) {
    super(`Position \`${n}\` is out of bounds (\`0 < position < ${e}\`).`, {
      name: 'PositionOutOfBoundsError'
    })
  }
}
class R$ extends Se {
  constructor({ count: e, limit: n }) {
    super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${e}\`).`, {
      name: 'RecursiveReadLimitExceededError'
    })
  }
}
const k$ = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new R$({ count: this.recursiveReadCount + 1, limit: this.recursiveReadLimit })
  },
  assertPosition(t) {
    if (t < 0 || t > this.bytes.length - 1) throw new PR({ length: this.bytes.length, position: t })
  },
  decrementPosition(t) {
    if (t < 0) throw new PC({ offset: t })
    const e = this.position - t
    this.assertPosition(e), (this.position = e)
  },
  getReadCount(t) {
    return this.positionReadCount.get(t || this.position) || 0
  },
  incrementPosition(t) {
    if (t < 0) throw new PC({ offset: t })
    const e = this.position + t
    this.assertPosition(e), (this.position = e)
  },
  inspectByte(t) {
    const e = t ?? this.position
    return this.assertPosition(e), this.bytes[e]
  },
  inspectBytes(t, e) {
    const n = e ?? this.position
    return this.assertPosition(n + t - 1), this.bytes.subarray(n, n + t)
  },
  inspectUint8(t) {
    const e = t ?? this.position
    return this.assertPosition(e), this.bytes[e]
  },
  inspectUint16(t) {
    const e = t ?? this.position
    return this.assertPosition(e + 1), this.dataView.getUint16(e)
  },
  inspectUint24(t) {
    const e = t ?? this.position
    return (
      this.assertPosition(e + 2), (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2)
    )
  },
  inspectUint32(t) {
    const e = t ?? this.position
    return this.assertPosition(e + 3), this.dataView.getUint32(e)
  },
  pushByte(t) {
    this.assertPosition(this.position), (this.bytes[this.position] = t), this.position++
  },
  pushBytes(t) {
    this.assertPosition(this.position + t.length - 1),
      this.bytes.set(t, this.position),
      (this.position += t.length)
  },
  pushUint8(t) {
    this.assertPosition(this.position), (this.bytes[this.position] = t), this.position++
  },
  pushUint16(t) {
    this.assertPosition(this.position + 1),
      this.dataView.setUint16(this.position, t),
      (this.position += 2)
  },
  pushUint24(t) {
    this.assertPosition(this.position + 2),
      this.dataView.setUint16(this.position, t >> 8),
      this.dataView.setUint8(this.position + 2, t & 255),
      (this.position += 3)
  },
  pushUint32(t) {
    this.assertPosition(this.position + 3),
      this.dataView.setUint32(this.position, t),
      (this.position += 4)
  },
  readByte() {
    this.assertReadLimit(), this._touch()
    const t = this.inspectByte()
    return this.position++, t
  },
  readBytes(t, e) {
    this.assertReadLimit(), this._touch()
    const n = this.inspectBytes(t)
    return (this.position += e ?? t), n
  },
  readUint8() {
    this.assertReadLimit(), this._touch()
    const t = this.inspectUint8()
    return (this.position += 1), t
  },
  readUint16() {
    this.assertReadLimit(), this._touch()
    const t = this.inspectUint16()
    return (this.position += 2), t
  },
  readUint24() {
    this.assertReadLimit(), this._touch()
    const t = this.inspectUint24()
    return (this.position += 3), t
  },
  readUint32() {
    this.assertReadLimit(), this._touch()
    const t = this.inspectUint32()
    return (this.position += 4), t
  },
  get remaining() {
    return this.bytes.length - this.position
  },
  setPosition(t) {
    const e = this.position
    return this.assertPosition(t), (this.position = t), () => (this.position = e)
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return
    const t = this.getReadCount()
    this.positionReadCount.set(this.position, t + 1), t > 0 && this.recursiveReadCount++
  }
}
function HE(t, { recursiveReadLimit: e = 8192 } = {}) {
  const n = Object.create(k$)
  return (
    (n.bytes = t),
    (n.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength)),
    (n.positionReadCount = new Map()),
    (n.recursiveReadLimit = e),
    n
  )
}
function ec(t, e = 'hex') {
  const n = RR(t),
    r = HE(new Uint8Array(n.length))
  return n.encode(r), e === 'hex' ? br(r.bytes) : r.bytes
}
function RR(t) {
  return Array.isArray(t) ? O$(t.map(e => RR(e))) : B$(t)
}
function O$(t) {
  const e = t.reduce((s, i) => s + i.length, 0),
    n = kR(e)
  return {
    length: e <= 55 ? 1 + e : 1 + n + e,
    encode(s) {
      e <= 55
        ? s.pushByte(192 + e)
        : (s.pushByte(247 + n),
          n === 1
            ? s.pushUint8(e)
            : n === 2
              ? s.pushUint16(e)
              : n === 3
                ? s.pushUint24(e)
                : s.pushUint32(e))
      for (const { encode: i } of t) i(s)
    }
  }
}
function B$(t) {
  const e = typeof t == 'string' ? oo(t) : t,
    n = kR(e.length)
  return {
    length: e.length === 1 && e[0] < 128 ? 1 : e.length <= 55 ? 1 + e.length : 1 + n + e.length,
    encode(s) {
      e.length === 1 && e[0] < 128
        ? s.pushBytes(e)
        : e.length <= 55
          ? (s.pushByte(128 + e.length), s.pushBytes(e))
          : (s.pushByte(183 + n),
            n === 1
              ? s.pushUint8(e.length)
              : n === 2
                ? s.pushUint16(e.length)
                : n === 3
                  ? s.pushUint24(e.length)
                  : s.pushUint32(e.length),
            s.pushBytes(e))
    }
  }
}
function kR(t) {
  if (t < 2 ** 8) return 1
  if (t < 2 ** 16) return 2
  if (t < 2 ** 24) return 3
  if (t < 2 ** 32) return 4
  throw new Se('Length is too large.')
}
function D$(t) {
  const { chainId: e, contractAddress: n, nonce: r, to: s } = t,
    i = Xa(na(['0x05', ec([e ? Mt(e) : '0x', n, r ? Mt(r) : '0x'])]))
  return s === 'bytes' ? oo(i) : i
}
async function OR(t) {
  const { authorization: e, signature: n } = t
  return P$({ hash: D$(e), signature: n ?? e })
}
class E1 extends Se {
  constructor({ blockNumber: e, chain: n, contract: r }) {
    super(`Chain "${n.name}" does not support contract "${r.name}".`, {
      metaMessages: [
        'This could be due to any of the following:',
        ...(e && r.blockCreated && r.blockCreated > e
          ? [
              `- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${e}).`
            ]
          : [`- The chain does not have the contract "${r.name}" configured.`])
      ],
      name: 'ChainDoesNotSupportContract'
    })
  }
}
class M$ extends Se {
  constructor({ chain: e, currentChainId: n }) {
    super(
      `The current chain of the wallet (id: ${n}) does not match the target chain for the transaction (id: ${e.id}  ${e.name}).`,
      {
        metaMessages: [`Current Chain ID:  ${n}`, `Expected Chain ID: ${e.id}  ${e.name}`],
        name: 'ChainMismatchError'
      }
    )
  }
}
class U$ extends Se {
  constructor() {
    super(
      [
        'No chain was provided to the request.',
        'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.'
      ].join(`
`),
      { name: 'ChainNotFoundError' }
    )
  }
}
class BR extends Se {
  constructor() {
    super('No chain was provided to the Client.', { name: 'ClientChainNotConfiguredError' })
  }
}
class g0 extends Se {
  constructor({ chainId: e }) {
    super(typeof e == 'number' ? `Chain ID "${e}" is invalid.` : 'Chain ID is invalid.', {
      name: 'InvalidChainIdError'
    })
  }
}
function L$({ chain: t, currentChainId: e }) {
  if (!t) throw new U$()
  if (e !== t.id) throw new M$({ chain: t, currentChainId: e })
}
const $$ = { gwei: 9, wei: 18 },
  F$ = { ether: -9, wei: 9 },
  j$ = { ether: -18, gwei: -9 }
function bd(t, e) {
  let n = t.toString()
  const r = n.startsWith('-')
  r && (n = n.slice(1)), (n = n.padStart(e, '0'))
  let [s, i] = [n.slice(0, n.length - e), n.slice(n.length - e)]
  return (i = i.replace(/(0+)$/, '')), `${r ? '-' : ''}${s || '0'}${i ? `.${i}` : ''}`
}
function As(t, e = 'wei') {
  return bd(t, F$[e])
}
class Mc extends Se {
  constructor({ cause: e, message: n } = {}) {
    var s
    const r =
      (s = n == null ? void 0 : n.replace('execution reverted: ', '')) == null
        ? void 0
        : s.replace('execution reverted', '')
    super(`Execution reverted ${r ? `with reason: ${r}` : 'for an unknown reason'}.`, {
      cause: e,
      name: 'ExecutionRevertedError'
    })
  }
}
Object.defineProperty(Mc, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 3 })
Object.defineProperty(Mc, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
})
class iu extends Se {
  constructor({ cause: e, maxFeePerGas: n } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${n ? ` = ${As(n)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`,
      { cause: e, name: 'FeeCapTooHighError' }
    )
  }
}
Object.defineProperty(iu, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
})
class A1 extends Se {
  constructor({ cause: e, maxFeePerGas: n } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${n ? ` = ${As(n)}` : ''} gwei) cannot be lower than the block base fee.`,
      { cause: e, name: 'FeeCapTooLowError' }
    )
  }
}
Object.defineProperty(A1, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value:
    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
})
class _1 extends Se {
  constructor({ cause: e, nonce: n } = {}) {
    super(
      `Nonce provided for the transaction ${n ? `(${n}) ` : ''}is higher than the next one expected.`,
      { cause: e, name: 'NonceTooHighError' }
    )
  }
}
Object.defineProperty(_1, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
})
class C1 extends Se {
  constructor({ cause: e, nonce: n } = {}) {
    super(
      [
        `Nonce provided for the transaction ${n ? `(${n}) ` : ''}is lower than the current nonce of the account.`,
        'Try increasing the nonce or find the latest nonce with `getTransactionCount`.'
      ].join(`
`),
      { cause: e, name: 'NonceTooLowError' }
    )
  }
}
Object.defineProperty(C1, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
})
class S1 extends Se {
  constructor({ cause: e, nonce: n } = {}) {
    super(
      `Nonce provided for the transaction ${n ? `(${n}) ` : ''}exceeds the maximum allowed nonce.`,
      { cause: e, name: 'NonceMaxValueError' }
    )
  }
}
Object.defineProperty(S1, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
})
class I1 extends Se {
  constructor({ cause: e } = {}) {
    super(
      [
        'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.'
      ].join(`
`),
      {
        cause: e,
        metaMessages: [
          'This error could arise when the account does not have enough funds to:',
          ' - pay for the total gas fee,',
          ' - pay for the value to send.',
          ' ',
          'The cost of the transaction is calculated as `gas * gas fee + value`, where:',
          ' - `gas` is the amount of gas needed for transaction to execute,',
          ' - `gas fee` is the gas fee,',
          ' - `value` is the amount of ether to send to the recipient.'
        ],
        name: 'InsufficientFundsError'
      }
    )
  }
}
Object.defineProperty(I1, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
})
class x1 extends Se {
  constructor({ cause: e, gas: n } = {}) {
    super(
      `The amount of gas ${n ? `(${n}) ` : ''}provided for the transaction exceeds the limit allowed for the block.`,
      { cause: e, name: 'IntrinsicGasTooHighError' }
    )
  }
}
Object.defineProperty(x1, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
})
class T1 extends Se {
  constructor({ cause: e, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ''}provided for the transaction is too low.`, {
      cause: e,
      name: 'IntrinsicGasTooLowError'
    })
  }
}
Object.defineProperty(T1, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
})
class N1 extends Se {
  constructor({ cause: e }) {
    super('The transaction type is not supported for this chain.', {
      cause: e,
      name: 'TransactionTypeNotSupportedError'
    })
  }
}
Object.defineProperty(N1, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
})
class Jh extends Se {
  constructor({ cause: e, maxPriorityFeePerGas: n, maxFeePerGas: r } = {}) {
    super(
      [
        `The provided tip (\`maxPriorityFeePerGas\`${n ? ` = ${As(n)} gwei` : ''}) cannot be higher than the fee cap (\`maxFeePerGas\`${r ? ` = ${As(r)} gwei` : ''}).`
      ].join(`
`),
      { cause: e, name: 'TipAboveFeeCapError' }
    )
  }
}
Object.defineProperty(Jh, 'nodeMessage', {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
})
class m0 extends Se {
  constructor({ cause: e }) {
    super(`An error occurred while executing: ${e == null ? void 0 : e.shortMessage}`, {
      cause: e,
      name: 'UnknownNodeError'
    })
  }
}
function qE(t, e = 'wei') {
  return bd(t, $$[e])
}
function rp(t) {
  const e = Object.entries(t)
      .map(([r, s]) => (s === void 0 || s === !1 ? null : [r, s]))
      .filter(Boolean),
    n = e.reduce((r, [s]) => Math.max(r, s.length), 0)
  return e.map(([r, s]) => `  ${`${r}:`.padEnd(n + 1)}  ${s}`).join(`
`)
}
class H$ extends Se {
  constructor() {
    super(
      [
        'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',
        'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.'
      ].join(`
`),
      { name: 'FeeConflictError' }
    )
  }
}
class q$ extends Se {
  constructor({ v: e }) {
    super(`Invalid \`v\` value "${e}". Expected 27 or 28.`, { name: 'InvalidLegacyVError' })
  }
}
class z$ extends Se {
  constructor({ transaction: e }) {
    super('Cannot infer a transaction type from provided transaction.', {
      metaMessages: [
        'Provided Transaction:',
        '{',
        rp(e),
        '}',
        '',
        'To infer the type, either provide:',
        '- a `type` to the Transaction, or',
        '- an EIP-1559 Transaction with `maxFeePerGas`, or',
        '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',
        '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or',
        '- an EIP-7702 Transaction with `authorizationList`, or',
        '- a Legacy Transaction with `gasPrice`'
      ],
      name: 'InvalidSerializableTransactionError'
    })
  }
}
class W$ extends Se {
  constructor({ storageKey: e }) {
    super(
      `Size for storage key "${e}" is invalid. Expected 32 bytes. Got ${Math.floor((e.length - 2) / 2)} bytes.`,
      { name: 'InvalidStorageKeySizeError' }
    )
  }
}
class K$ extends Se {
  constructor(
    e,
    {
      account: n,
      docsPath: r,
      chain: s,
      data: i,
      gas: o,
      gasPrice: a,
      maxFeePerGas: c,
      maxPriorityFeePerGas: u,
      nonce: l,
      to: d,
      value: h
    }
  ) {
    var y
    const p = rp({
      chain: s && `${s == null ? void 0 : s.name} (id: ${s == null ? void 0 : s.id})`,
      from: n == null ? void 0 : n.address,
      to: d,
      value:
        typeof h < 'u' &&
        `${qE(h)} ${((y = s == null ? void 0 : s.nativeCurrency) == null ? void 0 : y.symbol) || 'ETH'}`,
      data: i,
      gas: o,
      gasPrice: typeof a < 'u' && `${As(a)} gwei`,
      maxFeePerGas: typeof c < 'u' && `${As(c)} gwei`,
      maxPriorityFeePerGas: typeof u < 'u' && `${As(u)} gwei`,
      nonce: l
    })
    super(e.shortMessage, {
      cause: e,
      docsPath: r,
      metaMessages: [
        ...(e.metaMessages ? [...e.metaMessages, ' '] : []),
        'Request Arguments:',
        p
      ].filter(Boolean),
      name: 'TransactionExecutionError'
    }),
      Object.defineProperty(this, 'cause', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.cause = e)
  }
}
class DR extends Se {
  constructor({ blockHash: e, blockNumber: n, blockTag: r, hash: s, index: i }) {
    let o = 'Transaction'
    r && i !== void 0 && (o = `Transaction at block time "${r}" at index "${i}"`),
      e && i !== void 0 && (o = `Transaction at block hash "${e}" at index "${i}"`),
      n && i !== void 0 && (o = `Transaction at block number "${n}" at index "${i}"`),
      s && (o = `Transaction with hash "${s}"`),
      super(`${o} could not be found.`, { name: 'TransactionNotFoundError' })
  }
}
class MR extends Se {
  constructor({ hash: e }) {
    super(
      `Transaction receipt with hash "${e}" could not be found. The Transaction may not be processed on a block yet.`,
      { name: 'TransactionReceiptNotFoundError' }
    )
  }
}
class V$ extends Se {
  constructor({ hash: e }) {
    super(`Timed out while waiting for transaction with hash "${e}" to be confirmed.`, {
      name: 'WaitForTransactionReceiptTimeoutError'
    })
  }
}
const oi = (t, e, n) => JSON.stringify(t, (r, s) => (typeof s == 'bigint' ? s.toString() : s), n),
  G$ = t => t,
  zE = t => t
class Ph extends Se {
  constructor({ body: e, cause: n, details: r, headers: s, status: i, url: o }) {
    super('HTTP request failed.', {
      cause: n,
      details: r,
      metaMessages: [i && `Status: ${i}`, `URL: ${zE(o)}`, e && `Request body: ${oi(e)}`].filter(
        Boolean
      ),
      name: 'HttpRequestError'
    }),
      Object.defineProperty(this, 'body', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'headers', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'status', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'url', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.body = e),
      (this.headers = s),
      (this.status = i),
      (this.url = o)
  }
}
class WE extends Se {
  constructor({ body: e, error: n, url: r }) {
    super('RPC Request failed.', {
      cause: n,
      details: n.message,
      metaMessages: [`URL: ${zE(r)}`, `Request body: ${oi(e)}`],
      name: 'RpcRequestError'
    }),
      Object.defineProperty(this, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'data', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.code = n.code),
      (this.data = n.data)
  }
}
class RC extends Se {
  constructor({ body: e, url: n }) {
    super('The request took too long to respond.', {
      details: 'The request timed out.',
      metaMessages: [`URL: ${zE(n)}`, `Request body: ${oi(e)}`],
      name: 'TimeoutError'
    })
  }
}
const Q$ = -1
class Ss extends Se {
  constructor(e, { code: n, docsPath: r, metaMessages: s, name: i, shortMessage: o }) {
    super(o, {
      cause: e,
      docsPath: r,
      metaMessages: s || (e == null ? void 0 : e.metaMessages),
      name: i || 'RpcError'
    }),
      Object.defineProperty(this, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.name = i || e.name),
      (this.code = e instanceof WE ? e.code : (n ?? Q$))
  }
}
class vd extends Ss {
  constructor(e, n) {
    super(e, n),
      Object.defineProperty(this, 'data', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.data = n.data)
  }
}
class Xh extends Ss {
  constructor(e) {
    super(e, {
      code: Xh.code,
      name: 'ParseRpcError',
      shortMessage:
        'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.'
    })
  }
}
Object.defineProperty(Xh, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32700 })
class ef extends Ss {
  constructor(e) {
    super(e, {
      code: ef.code,
      name: 'InvalidRequestRpcError',
      shortMessage: 'JSON is not a valid request object.'
    })
  }
}
Object.defineProperty(ef, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32600 })
class tf extends Ss {
  constructor(e, { method: n } = {}) {
    super(e, {
      code: tf.code,
      name: 'MethodNotFoundRpcError',
      shortMessage: `The method${n ? ` "${n}"` : ''} does not exist / is not available.`
    })
  }
}
Object.defineProperty(tf, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32601 })
class nf extends Ss {
  constructor(e) {
    super(e, {
      code: nf.code,
      name: 'InvalidParamsRpcError',
      shortMessage: [
        'Invalid parameters were provided to the RPC method.',
        'Double check you have provided the correct parameters.'
      ].join(`
`)
    })
  }
}
Object.defineProperty(nf, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32602 })
class ou extends Ss {
  constructor(e) {
    super(e, {
      code: ou.code,
      name: 'InternalRpcError',
      shortMessage: 'An internal error was received.'
    })
  }
}
Object.defineProperty(ou, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32603 })
class rf extends Ss {
  constructor(e) {
    super(e, {
      code: rf.code,
      name: 'InvalidInputRpcError',
      shortMessage: [
        'Missing or invalid parameters.',
        'Double check you have provided the correct parameters.'
      ].join(`
`)
    })
  }
}
Object.defineProperty(rf, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32e3 })
class sf extends Ss {
  constructor(e) {
    super(e, {
      code: sf.code,
      name: 'ResourceNotFoundRpcError',
      shortMessage: 'Requested resource not found.'
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ResourceNotFoundRpcError'
      })
  }
}
Object.defineProperty(sf, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32001 })
class Ha extends Ss {
  constructor(e) {
    super(e, {
      code: Ha.code,
      name: 'ResourceUnavailableRpcError',
      shortMessage: 'Requested resource not available.'
    })
  }
}
Object.defineProperty(Ha, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32002 })
class Zl extends Ss {
  constructor(e) {
    super(e, {
      code: Zl.code,
      name: 'TransactionRejectedRpcError',
      shortMessage: 'Transaction creation failed.'
    })
  }
}
Object.defineProperty(Zl, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32003 })
class Uc extends Ss {
  constructor(e, { method: n } = {}) {
    super(e, {
      code: Uc.code,
      name: 'MethodNotSupportedRpcError',
      shortMessage: `Method${n ? ` "${n}"` : ''} is not supported.`
    })
  }
}
Object.defineProperty(Uc, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32004 })
class Yl extends Ss {
  constructor(e) {
    super(e, {
      code: Yl.code,
      name: 'LimitExceededRpcError',
      shortMessage: 'Request exceeds defined limit.'
    })
  }
}
Object.defineProperty(Yl, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32005 })
class of extends Ss {
  constructor(e) {
    super(e, {
      code: of.code,
      name: 'JsonRpcVersionUnsupportedError',
      shortMessage: 'Version of JSON-RPC protocol is not supported.'
    })
  }
}
Object.defineProperty(of, 'code', { enumerable: !0, configurable: !0, writable: !0, value: -32006 })
class nr extends vd {
  constructor(e) {
    super(e, {
      code: nr.code,
      name: 'UserRejectedRequestError',
      shortMessage: 'User rejected the request.'
    })
  }
}
Object.defineProperty(nr, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 4001 })
class af extends vd {
  constructor(e) {
    super(e, {
      code: af.code,
      name: 'UnauthorizedProviderError',
      shortMessage: 'The requested method and/or account has not been authorized by the user.'
    })
  }
}
Object.defineProperty(af, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 4100 })
class cf extends vd {
  constructor(e, { method: n } = {}) {
    super(e, {
      code: cf.code,
      name: 'UnsupportedProviderMethodError',
      shortMessage: `The Provider does not support the requested method${n ? ` " ${n}"` : ''}.`
    })
  }
}
Object.defineProperty(cf, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 4200 })
class uf extends vd {
  constructor(e) {
    super(e, {
      code: uf.code,
      name: 'ProviderDisconnectedError',
      shortMessage: 'The Provider is disconnected from all chains.'
    })
  }
}
Object.defineProperty(uf, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 4900 })
class lf extends vd {
  constructor(e) {
    super(e, {
      code: lf.code,
      name: 'ChainDisconnectedError',
      shortMessage: 'The Provider is not connected to the requested chain.'
    })
  }
}
Object.defineProperty(lf, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 4901 })
class ao extends vd {
  constructor(e) {
    super(e, {
      code: ao.code,
      name: 'SwitchChainError',
      shortMessage: 'An error occurred when attempting to switch chain.'
    })
  }
}
Object.defineProperty(ao, 'code', { enumerable: !0, configurable: !0, writable: !0, value: 4902 })
class Z$ extends Ss {
  constructor(e) {
    super(e, { name: 'UnknownRpcError', shortMessage: 'An unknown RPC error occurred.' })
  }
}
function KE(t, e) {
  const n = (t.details || '').toLowerCase(),
    r = t instanceof Se ? t.walk(s => (s == null ? void 0 : s.code) === Mc.code) : t
  return r instanceof Se
    ? new Mc({ cause: t, message: r.details })
    : Mc.nodeMessage.test(n)
      ? new Mc({ cause: t, message: t.details })
      : iu.nodeMessage.test(n)
        ? new iu({ cause: t, maxFeePerGas: e == null ? void 0 : e.maxFeePerGas })
        : A1.nodeMessage.test(n)
          ? new A1({ cause: t, maxFeePerGas: e == null ? void 0 : e.maxFeePerGas })
          : _1.nodeMessage.test(n)
            ? new _1({ cause: t, nonce: e == null ? void 0 : e.nonce })
            : C1.nodeMessage.test(n)
              ? new C1({ cause: t, nonce: e == null ? void 0 : e.nonce })
              : S1.nodeMessage.test(n)
                ? new S1({ cause: t, nonce: e == null ? void 0 : e.nonce })
                : I1.nodeMessage.test(n)
                  ? new I1({ cause: t })
                  : x1.nodeMessage.test(n)
                    ? new x1({ cause: t, gas: e == null ? void 0 : e.gas })
                    : T1.nodeMessage.test(n)
                      ? new T1({ cause: t, gas: e == null ? void 0 : e.gas })
                      : N1.nodeMessage.test(n)
                        ? new N1({ cause: t })
                        : Jh.nodeMessage.test(n)
                          ? new Jh({
                              cause: t,
                              maxFeePerGas: e == null ? void 0 : e.maxFeePerGas,
                              maxPriorityFeePerGas: e == null ? void 0 : e.maxPriorityFeePerGas
                            })
                          : new m0({ cause: t })
}
function Y$(t, { docsPath: e, ...n }) {
  const r = (() => {
    const s = KE(t, n)
    return s instanceof m0 ? t : s
  })()
  return new K$(r, { docsPath: e, ...n })
}
function VE(t, { format: e }) {
  if (!e) return {}
  const n = {}
  function r(i) {
    const o = Object.keys(i)
    for (const a of o)
      a in t && (n[a] = t[a]), i[a] && typeof i[a] == 'object' && !Array.isArray(i[a]) && r(i[a])
  }
  const s = e(t || {})
  return r(s), n
}
function GE(t, e) {
  return ({ exclude: n, format: r }) => ({
    exclude: n,
    format: s => {
      const i = e(s)
      if (n) for (const o of n) delete i[o]
      return { ...i, ...r(s) }
    },
    type: t
  })
}
const J$ = { legacy: '0x0', eip2930: '0x1', eip1559: '0x2', eip4844: '0x3', eip7702: '0x4' }
function QE(t) {
  const e = {}
  return (
    typeof t.authorizationList < 'u' && (e.authorizationList = X$(t.authorizationList)),
    typeof t.accessList < 'u' && (e.accessList = t.accessList),
    typeof t.blobVersionedHashes < 'u' && (e.blobVersionedHashes = t.blobVersionedHashes),
    typeof t.blobs < 'u' &&
      (typeof t.blobs[0] != 'string' ? (e.blobs = t.blobs.map(n => br(n))) : (e.blobs = t.blobs)),
    typeof t.data < 'u' && (e.data = t.data),
    typeof t.from < 'u' && (e.from = t.from),
    typeof t.gas < 'u' && (e.gas = Mt(t.gas)),
    typeof t.gasPrice < 'u' && (e.gasPrice = Mt(t.gasPrice)),
    typeof t.maxFeePerBlobGas < 'u' && (e.maxFeePerBlobGas = Mt(t.maxFeePerBlobGas)),
    typeof t.maxFeePerGas < 'u' && (e.maxFeePerGas = Mt(t.maxFeePerGas)),
    typeof t.maxPriorityFeePerGas < 'u' && (e.maxPriorityFeePerGas = Mt(t.maxPriorityFeePerGas)),
    typeof t.nonce < 'u' && (e.nonce = Mt(t.nonce)),
    typeof t.to < 'u' && (e.to = t.to),
    typeof t.type < 'u' && (e.type = J$[t.type]),
    typeof t.value < 'u' && (e.value = Mt(t.value)),
    e
  )
}
function X$(t) {
  return t.map(e => ({
    address: e.contractAddress,
    r: e.r ? Mt(BigInt(e.r)) : e.r,
    s: e.s ? Mt(BigInt(e.s)) : e.s,
    chainId: Mt(e.chainId),
    nonce: Mt(e.nonce),
    ...(typeof e.yParity < 'u' ? { yParity: Mt(e.yParity) } : {}),
    ...(typeof e.v < 'u' && typeof e.yParity > 'u' ? { v: Mt(e.v) } : {})
  }))
}
function cn(t, e, n) {
  const r = t[e.name]
  if (typeof r == 'function') return r
  const s = t[n]
  return typeof s == 'function' ? s : i => e(t, i)
}
const y0 = 2n ** 256n - 1n
function w0(t) {
  const { account: e, gasPrice: n, maxFeePerGas: r, maxPriorityFeePerGas: s, to: i } = t,
    o = e ? go(e) : void 0
  if (o && !Rr(o.address)) throw new Cs({ address: o.address })
  if (i && !Rr(i)) throw new Cs({ address: i })
  if (typeof n < 'u' && (typeof r < 'u' || typeof s < 'u')) throw new H$()
  if (r && r > y0) throw new iu({ maxFeePerGas: r })
  if (s && r && s > r) throw new Jh({ maxFeePerGas: r, maxPriorityFeePerGas: s })
}
async function UR(t) {
  const e = await t.request({ method: 'eth_chainId' }, { dedupe: !0 })
  return Ya(e)
}
class eF extends Se {
  constructor() {
    super('`baseFeeMultiplier` must be greater than 1.', { name: 'BaseFeeScalarError' })
  }
}
class ZE extends Se {
  constructor() {
    super('Chain does not support EIP-1559 fees.', { name: 'Eip1559FeesNotSupportedError' })
  }
}
class tF extends Se {
  constructor({ maxPriorityFeePerGas: e }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${As(e)} gwei).`, {
      name: 'MaxFeePerGasTooLowError'
    })
  }
}
class LR extends Se {
  constructor({ blockHash: e, blockNumber: n }) {
    let r = 'Block'
    e && (r = `Block at hash "${e}"`),
      n && (r = `Block at number "${n}"`),
      super(`${r} could not be found.`, { name: 'BlockNotFoundError' })
  }
}
const $R = {
  '0x0': 'legacy',
  '0x1': 'eip2930',
  '0x2': 'eip1559',
  '0x3': 'eip4844',
  '0x4': 'eip7702'
}
function b0(t) {
  const e = {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    chainId: t.chainId ? Ya(t.chainId) : void 0,
    gas: t.gas ? BigInt(t.gas) : void 0,
    gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
    maxFeePerBlobGas: t.maxFeePerBlobGas ? BigInt(t.maxFeePerBlobGas) : void 0,
    maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: t.maxPriorityFeePerGas ? BigInt(t.maxPriorityFeePerGas) : void 0,
    nonce: t.nonce ? Ya(t.nonce) : void 0,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    type: t.type ? $R[t.type] : void 0,
    typeHex: t.type ? t.type : void 0,
    value: t.value ? BigInt(t.value) : void 0,
    v: t.v ? BigInt(t.v) : void 0
  }
  return (
    t.authorizationList && (e.authorizationList = rF(t.authorizationList)),
    (e.yParity = (() => {
      if (t.yParity) return Number(t.yParity)
      if (typeof e.v == 'bigint') {
        if (e.v === 0n || e.v === 27n) return 0
        if (e.v === 1n || e.v === 28n) return 1
        if (e.v >= 35n) return e.v % 2n === 0n ? 1 : 0
      }
    })()),
    e.type === 'legacy' &&
      (delete e.accessList,
      delete e.maxFeePerBlobGas,
      delete e.maxFeePerGas,
      delete e.maxPriorityFeePerGas,
      delete e.yParity),
    e.type === 'eip2930' &&
      (delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas),
    e.type === 'eip1559' && delete e.maxFeePerBlobGas,
    e
  )
}
const nF = GE('transaction', b0)
function rF(t) {
  return t.map(e => ({
    contractAddress: e.address,
    chainId: Number(e.chainId),
    nonce: Number(e.nonce),
    r: e.r,
    s: e.s,
    yParity: Number(e.yParity)
  }))
}
function FR(t) {
  const e = (t.transactions ?? []).map(n => (typeof n == 'string' ? n : b0(n)))
  return {
    ...t,
    baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
    blobGasUsed: t.blobGasUsed ? BigInt(t.blobGasUsed) : void 0,
    difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
    excessBlobGas: t.excessBlobGas ? BigInt(t.excessBlobGas) : void 0,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
    hash: t.hash ? t.hash : null,
    logsBloom: t.logsBloom ? t.logsBloom : null,
    nonce: t.nonce ? t.nonce : null,
    number: t.number ? BigInt(t.number) : null,
    size: t.size ? BigInt(t.size) : void 0,
    timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
    transactions: e,
    totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null
  }
}
const sF = GE('block', FR)
async function df(t, { blockHash: e, blockNumber: n, blockTag: r, includeTransactions: s } = {}) {
  var l, d, h
  const i = r ?? 'latest',
    o = s ?? !1,
    a = n !== void 0 ? Mt(n) : void 0
  let c = null
  if (
    (e
      ? (c = await t.request({ method: 'eth_getBlockByHash', params: [e, o] }, { dedupe: !0 }))
      : (c = await t.request(
          { method: 'eth_getBlockByNumber', params: [a || i, o] },
          { dedupe: !!a }
        )),
    !c)
  )
    throw new LR({ blockHash: e, blockNumber: n })
  return (
    ((h = (d = (l = t.chain) == null ? void 0 : l.formatters) == null ? void 0 : d.block) == null
      ? void 0
      : h.format) || FR
  )(c)
}
async function jR(t) {
  const e = await t.request({ method: 'eth_gasPrice' })
  return BigInt(e)
}
async function iF(t, e) {
  var i, o
  const { block: n, chain: r = t.chain, request: s } = e || {}
  try {
    const a =
      ((i = r == null ? void 0 : r.fees) == null ? void 0 : i.maxPriorityFeePerGas) ??
      ((o = r == null ? void 0 : r.fees) == null ? void 0 : o.defaultPriorityFee)
    if (typeof a == 'function') {
      const u = n || (await cn(t, df, 'getBlock')({})),
        l = await a({ block: u, client: t, request: s })
      if (l === null) throw new Error()
      return l
    }
    if (typeof a < 'u') return a
    const c = await t.request({ method: 'eth_maxPriorityFeePerGas' })
    return Ci(c)
  } catch {
    const [a, c] = await Promise.all([
      n ? Promise.resolve(n) : cn(t, df, 'getBlock')({}),
      cn(t, jR, 'getGasPrice')({})
    ])
    if (typeof a.baseFeePerGas != 'bigint') throw new ZE()
    const u = c - a.baseFeePerGas
    return u < 0n ? 0n : u
  }
}
async function kC(t, e) {
  var h, p
  const { block: n, chain: r = t.chain, request: s, type: i = 'eip1559' } = e || {},
    o = await (async () => {
      var y, m
      return typeof ((y = r == null ? void 0 : r.fees) == null ? void 0 : y.baseFeeMultiplier) ==
        'function'
        ? r.fees.baseFeeMultiplier({ block: n, client: t, request: s })
        : (((m = r == null ? void 0 : r.fees) == null ? void 0 : m.baseFeeMultiplier) ?? 1.2)
    })()
  if (o < 1) throw new eF()
  const c = 10 ** (((h = o.toString().split('.')[1]) == null ? void 0 : h.length) ?? 0),
    u = y => (y * BigInt(Math.ceil(o * c))) / BigInt(c),
    l = n || (await cn(t, df, 'getBlock')({}))
  if (
    typeof ((p = r == null ? void 0 : r.fees) == null ? void 0 : p.estimateFeesPerGas) == 'function'
  ) {
    const y = await r.fees.estimateFeesPerGas({
      block: n,
      client: t,
      multiply: u,
      request: s,
      type: i
    })
    if (y !== null) return y
  }
  if (i === 'eip1559') {
    if (typeof l.baseFeePerGas != 'bigint') throw new ZE()
    const y =
        typeof (s == null ? void 0 : s.maxPriorityFeePerGas) == 'bigint'
          ? s.maxPriorityFeePerGas
          : await iF(t, { block: l, chain: r, request: s }),
      m = u(l.baseFeePerGas)
    return { maxFeePerGas: (s == null ? void 0 : s.maxFeePerGas) ?? m + y, maxPriorityFeePerGas: y }
  }
  return { gasPrice: (s == null ? void 0 : s.gasPrice) ?? u(await cn(t, jR, 'getGasPrice')({})) }
}
class oF extends Se {
  constructor(
    e,
    {
      account: n,
      docsPath: r,
      chain: s,
      data: i,
      gas: o,
      gasPrice: a,
      maxFeePerGas: c,
      maxPriorityFeePerGas: u,
      nonce: l,
      to: d,
      value: h
    }
  ) {
    var y
    const p = rp({
      from: n == null ? void 0 : n.address,
      to: d,
      value:
        typeof h < 'u' &&
        `${qE(h)} ${((y = s == null ? void 0 : s.nativeCurrency) == null ? void 0 : y.symbol) || 'ETH'}`,
      data: i,
      gas: o,
      gasPrice: typeof a < 'u' && `${As(a)} gwei`,
      maxFeePerGas: typeof c < 'u' && `${As(c)} gwei`,
      maxPriorityFeePerGas: typeof u < 'u' && `${As(u)} gwei`,
      nonce: l
    })
    super(e.shortMessage, {
      cause: e,
      docsPath: r,
      metaMessages: [
        ...(e.metaMessages ? [...e.metaMessages, ' '] : []),
        'Estimate Gas Arguments:',
        p
      ].filter(Boolean),
      name: 'EstimateGasExecutionError'
    }),
      Object.defineProperty(this, 'cause', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.cause = e)
  }
}
function aF(t, { docsPath: e, ...n }) {
  const r = (() => {
    const s = KE(t, n)
    return s instanceof m0 ? t : s
  })()
  return new oF(r, { docsPath: e, ...n })
}
class cF extends Se {
  constructor({ address: e }) {
    super(`State for account "${e}" is set multiple times.`, { name: 'AccountStateConflictError' })
  }
}
class uF extends Se {
  constructor() {
    super('state and stateDiff are set on the same account.', {
      name: 'StateAssignmentConflictError'
    })
  }
}
function OC(t) {
  return t.reduce(
    (e, { slot: n, value: r }) => `${e}        ${n}: ${r}
`,
    ''
  )
}
function lF(t) {
  return t
    .reduce(
      (e, { address: n, ...r }) => {
        let s = `${e}    ${n}:
`
        return (
          r.nonce &&
            (s += `      nonce: ${r.nonce}
`),
          r.balance &&
            (s += `      balance: ${r.balance}
`),
          r.code &&
            (s += `      code: ${r.code}
`),
          r.state &&
            ((s += `      state:
`),
            (s += OC(r.state))),
          r.stateDiff &&
            ((s += `      stateDiff:
`),
            (s += OC(r.stateDiff))),
          s
        )
      },
      `  State Override:
`
    )
    .slice(0, -1)
}
function BC(t) {
  if (!(!t || t.length === 0))
    return t.reduce((e, { slot: n, value: r }) => {
      if (n.length !== 66) throw new AC({ size: n.length, targetSize: 66, type: 'hex' })
      if (r.length !== 66) throw new AC({ size: r.length, targetSize: 66, type: 'hex' })
      return (e[n] = r), e
    }, {})
}
function dF(t) {
  const { balance: e, nonce: n, state: r, stateDiff: s, code: i } = t,
    o = {}
  if (
    (i !== void 0 && (o.code = i),
    e !== void 0 && (o.balance = Mt(e)),
    n !== void 0 && (o.nonce = Mt(n)),
    r !== void 0 && (o.state = BC(r)),
    s !== void 0)
  ) {
    if (o.state) throw new uF()
    o.stateDiff = BC(s)
  }
  return o
}
function HR(t) {
  if (!t) return
  const e = {}
  for (const { address: n, ...r } of t) {
    if (!Rr(n, { strict: !1 })) throw new Cs({ address: n })
    if (e[n]) throw new cF({ address: n })
    e[n] = dF(r)
  }
  return e
}
async function qR(t, { address: e, blockNumber: n, blockTag: r = 'latest' }) {
  const s = n ? Mt(n) : void 0,
    i = await t.request({ method: 'eth_getBalance', params: [e, s || r] })
  return BigInt(i)
}
async function zR(t, e) {
  var s, i, o
  const { account: n = t.account } = e,
    r = n ? go(n) : void 0
  try {
    let w = function (A) {
      const { block: P, request: O, rpcStateOverride: F } = A
      return t.request({
        method: 'eth_estimateGas',
        params: F ? [O, P ?? 'latest', F] : P ? [O, P] : [O]
      })
    }
    const {
        accessList: a,
        authorizationList: c,
        blobs: u,
        blobVersionedHashes: l,
        blockNumber: d,
        blockTag: h,
        data: p,
        gas: y,
        gasPrice: m,
        maxFeePerBlobGas: b,
        maxFeePerGas: I,
        maxPriorityFeePerGas: x,
        nonce: _,
        value: R,
        stateOverride: N,
        ...T
      } = await eA(t, {
        ...e,
        parameters: (r == null ? void 0 : r.type) === 'local' ? void 0 : ['blobVersionedHashes']
      }),
      H = (d ? Mt(d) : void 0) || h,
      B = HR(N),
      $ = await (async () => {
        if (T.to) return T.to
        if (c && c.length > 0)
          return await OR({ authorization: c[0] }).catch(() => {
            throw new Se('`to` is required. Could not infer from `authorizationList`')
          })
      })()
    w0(e)
    const D =
        (o =
          (i = (s = t.chain) == null ? void 0 : s.formatters) == null
            ? void 0
            : i.transactionRequest) == null
          ? void 0
          : o.format,
      U = (D || QE)({
        ...VE(T, { format: D }),
        from: r == null ? void 0 : r.address,
        accessList: a,
        authorizationList: c,
        blobs: u,
        blobVersionedHashes: l,
        data: p,
        gas: y,
        gasPrice: m,
        maxFeePerBlobGas: b,
        maxFeePerGas: I,
        maxPriorityFeePerGas: x,
        nonce: _,
        to: $,
        value: R
      })
    let v = BigInt(await w({ block: H, request: U, rpcStateOverride: B }))
    if (c) {
      const A = await qR(t, { address: U.from }),
        P = await Promise.all(
          c.map(async O => {
            const { contractAddress: F } = O,
              z = await w({
                block: H,
                request: {
                  authorizationList: void 0,
                  data: p,
                  from: r == null ? void 0 : r.address,
                  to: F,
                  value: Mt(A)
                },
                rpcStateOverride: B
              }).catch(() => 100000n)
            return 2n * BigInt(z)
          })
        )
      v += P.reduce((O, F) => O + F, 0n)
    }
    return v
  } catch (a) {
    throw aF(a, { ...e, account: r, chain: t.chain })
  }
}
async function hF(t, { address: e, blockTag: n = 'latest', blockNumber: r }) {
  const s = await t.request(
    { method: 'eth_getTransactionCount', params: [e, r ? Mt(r) : n] },
    { dedupe: !!r }
  )
  return Ya(s)
}
function YE(t) {
  const { kzg: e } = t,
    n = t.to ?? (typeof t.blobs[0] == 'string' ? 'hex' : 'bytes'),
    r = typeof t.blobs[0] == 'string' ? t.blobs.map(i => oo(i)) : t.blobs,
    s = []
  for (const i of r) s.push(Uint8Array.from(e.blobToKzgCommitment(i)))
  return n === 'bytes' ? s : s.map(i => br(i))
}
function JE(t) {
  const { kzg: e } = t,
    n = t.to ?? (typeof t.blobs[0] == 'string' ? 'hex' : 'bytes'),
    r = typeof t.blobs[0] == 'string' ? t.blobs.map(o => oo(o)) : t.blobs,
    s = typeof t.commitments[0] == 'string' ? t.commitments.map(o => oo(o)) : t.commitments,
    i = []
  for (let o = 0; o < r.length; o++) {
    const a = r[o],
      c = s[o]
    i.push(Uint8Array.from(e.computeBlobKzgProof(a, c)))
  }
  return n === 'bytes' ? i : i.map(o => br(o))
}
function fF(t, e, n, r) {
  if (typeof t.setBigUint64 == 'function') return t.setBigUint64(e, n, r)
  const s = BigInt(32),
    i = BigInt(4294967295),
    o = Number((n >> s) & i),
    a = Number(n & i),
    c = r ? 4 : 0,
    u = r ? 0 : 4
  t.setUint32(e + c, o, r), t.setUint32(e + u, a, r)
}
function pF(t, e, n) {
  return (t & e) ^ (~t & n)
}
function gF(t, e, n) {
  return (t & e) ^ (t & n) ^ (e & n)
}
class WR extends DE {
  constructor(e, n, r, s) {
    super(),
      (this.blockLen = e),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = s),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(e)),
      (this.view = Jy(this.buffer))
  }
  update(e) {
    Ql(this)
    const { view: n, buffer: r, blockLen: s } = this
    e = f0(e)
    const i = e.length
    for (let o = 0; o < i; ) {
      const a = Math.min(s - this.pos, i - o)
      if (a === s) {
        const c = Jy(e)
        for (; s <= i - o; o += s) this.process(c, o)
        continue
      }
      r.set(e.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === s && (this.process(n, 0), (this.pos = 0))
    }
    return (this.length += e.length), this.roundClean(), this
  }
  digestInto(e) {
    Ql(this), fR(e, this), (this.finished = !0)
    const { buffer: n, view: r, blockLen: s, isLE: i } = this
    let { pos: o } = this
    ;(n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > s - o && (this.process(r, 0), (o = 0))
    for (let d = o; d < s; d++) n[d] = 0
    fF(r, s - 8, BigInt(this.length * 8), i), this.process(r, 0)
    const a = Jy(e),
      c = this.outputLen
    if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit')
    const u = c / 4,
      l = this.get()
    if (u > l.length) throw new Error('_sha2: outputLen bigger than state')
    for (let d = 0; d < u; d++) a.setUint32(4 * d, l[d], i)
  }
  digest() {
    const { buffer: e, outputLen: n } = this
    this.digestInto(e)
    const r = e.slice(0, n)
    return this.destroy(), r
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get())
    const { blockLen: n, buffer: r, length: s, finished: i, destroyed: o, pos: a } = this
    return (
      (e.length = s), (e.pos = a), (e.finished = i), (e.destroyed = o), s % n && e.buffer.set(r), e
    )
  }
}
const mF = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298
  ]),
  ia = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225
  ]),
  oa = new Uint32Array(64)
class yF extends WR {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = ia[0] | 0),
      (this.B = ia[1] | 0),
      (this.C = ia[2] | 0),
      (this.D = ia[3] | 0),
      (this.E = ia[4] | 0),
      (this.F = ia[5] | 0),
      (this.G = ia[6] | 0),
      (this.H = ia[7] | 0)
  }
  get() {
    const { A: e, B: n, C: r, D: s, E: i, F: o, G: a, H: c } = this
    return [e, n, r, s, i, o, a, c]
  }
  set(e, n, r, s, i, o, a, c) {
    ;(this.A = e | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = s | 0),
      (this.E = i | 0),
      (this.F = o | 0),
      (this.G = a | 0),
      (this.H = c | 0)
  }
  process(e, n) {
    for (let d = 0; d < 16; d++, n += 4) oa[d] = e.getUint32(n, !1)
    for (let d = 16; d < 64; d++) {
      const h = oa[d - 15],
        p = oa[d - 2],
        y = Ui(h, 7) ^ Ui(h, 18) ^ (h >>> 3),
        m = Ui(p, 17) ^ Ui(p, 19) ^ (p >>> 10)
      oa[d] = (m + oa[d - 7] + y + oa[d - 16]) | 0
    }
    let { A: r, B: s, C: i, D: o, E: a, F: c, G: u, H: l } = this
    for (let d = 0; d < 64; d++) {
      const h = Ui(a, 6) ^ Ui(a, 11) ^ Ui(a, 25),
        p = (l + h + pF(a, c, u) + mF[d] + oa[d]) | 0,
        m = ((Ui(r, 2) ^ Ui(r, 13) ^ Ui(r, 22)) + gF(r, s, i)) | 0
      ;(l = u), (u = c), (c = a), (a = (o + p) | 0), (o = i), (i = s), (s = r), (r = (p + m) | 0)
    }
    ;(r = (r + this.A) | 0),
      (s = (s + this.B) | 0),
      (i = (i + this.C) | 0),
      (o = (o + this.D) | 0),
      (a = (a + this.E) | 0),
      (c = (c + this.F) | 0),
      (u = (u + this.G) | 0),
      (l = (l + this.H) | 0),
      this.set(r, s, i, o, a, c, u, l)
  }
  roundClean() {
    oa.fill(0)
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
  }
}
const cm = ME(() => new yF())
function wF(t, e) {
  return cm(Yo(t, { strict: !1 }) ? np(t) : t)
}
function bF(t) {
  const { commitment: e, version: n = 1 } = t,
    r = t.to ?? (typeof e == 'string' ? 'hex' : 'bytes'),
    s = wF(e)
  return s.set([n], 0), r === 'bytes' ? s : br(s)
}
function KR(t) {
  const { commitments: e, version: n } = t,
    r = t.to ?? (typeof e[0] == 'string' ? 'hex' : 'bytes'),
    s = []
  for (const i of e) s.push(bF({ commitment: i, to: r, version: n }))
  return s
}
const DC = 6,
  VR = 32,
  XE = 4096,
  GR = VR * XE,
  MC = GR * DC - 1 - 1 * XE * DC,
  QR = 1
class vF extends Se {
  constructor({ maxSize: e, size: n }) {
    super('Blob size is too large.', {
      metaMessages: [`Max: ${e} bytes`, `Given: ${n} bytes`],
      name: 'BlobSizeTooLargeError'
    })
  }
}
class ZR extends Se {
  constructor() {
    super('Blob data must not be empty.', { name: 'EmptyBlobError' })
  }
}
class EF extends Se {
  constructor({ hash: e, size: n }) {
    super(`Versioned hash "${e}" size is invalid.`, {
      metaMessages: ['Expected: 32', `Received: ${n}`],
      name: 'InvalidVersionedHashSizeError'
    })
  }
}
class AF extends Se {
  constructor({ hash: e, version: n }) {
    super(`Versioned hash "${e}" version is invalid.`, {
      metaMessages: [`Expected: ${QR}`, `Received: ${n}`],
      name: 'InvalidVersionedHashVersionError'
    })
  }
}
function _F(t) {
  const e = t.to ?? (typeof t.data == 'string' ? 'hex' : 'bytes'),
    n = typeof t.data == 'string' ? oo(t.data) : t.data,
    r = ir(n)
  if (!r) throw new ZR()
  if (r > MC) throw new vF({ maxSize: MC, size: r })
  const s = []
  let i = !0,
    o = 0
  for (; i; ) {
    const a = HE(new Uint8Array(GR))
    let c = 0
    for (; c < XE; ) {
      const u = n.slice(o, o + (VR - 1))
      if ((a.pushByte(0), a.pushBytes(u), u.length < 31)) {
        a.pushByte(128), (i = !1)
        break
      }
      c++, (o += 31)
    }
    s.push(a)
  }
  return e === 'bytes' ? s.map(a => a.bytes) : s.map(a => br(a.bytes))
}
function YR(t) {
  const { data: e, kzg: n, to: r } = t,
    s = t.blobs ?? _F({ data: e, to: r }),
    i = t.commitments ?? YE({ blobs: s, kzg: n, to: r }),
    o = t.proofs ?? JE({ blobs: s, commitments: i, kzg: n, to: r }),
    a = []
  for (let c = 0; c < s.length; c++) a.push({ blob: s[c], commitment: i[c], proof: o[c] })
  return a
}
function JR(t) {
  if (t.type) return t.type
  if (typeof t.authorizationList < 'u') return 'eip7702'
  if (
    typeof t.blobs < 'u' ||
    typeof t.blobVersionedHashes < 'u' ||
    typeof t.maxFeePerBlobGas < 'u' ||
    typeof t.sidecars < 'u'
  )
    return 'eip4844'
  if (typeof t.maxFeePerGas < 'u' || typeof t.maxPriorityFeePerGas < 'u') return 'eip1559'
  if (typeof t.gasPrice < 'u') return typeof t.accessList < 'u' ? 'eip2930' : 'legacy'
  throw new z$({ transaction: t })
}
const XR = ['blobVersionedHashes', 'chainId', 'fees', 'gas', 'nonce', 'type'],
  UC = new Map()
async function eA(t, e) {
  const {
      account: n = t.account,
      blobs: r,
      chain: s,
      gas: i,
      kzg: o,
      nonce: a,
      nonceManager: c,
      parameters: u = XR,
      type: l
    } = e,
    d = n && go(n),
    h = { ...e, ...(d ? { from: d == null ? void 0 : d.address } : {}) }
  let p
  async function y() {
    return p || ((p = await cn(t, df, 'getBlock')({ blockTag: 'latest' })), p)
  }
  let m
  async function b() {
    return (
      m ||
      (s ? s.id : typeof e.chainId < 'u' ? e.chainId : ((m = await cn(t, UR, 'getChainId')({})), m))
    )
  }
  if (u.includes('nonce') && typeof a > 'u' && d)
    if (c) {
      const I = await b()
      h.nonce = await c.consume({ address: d.address, chainId: I, client: t })
    } else
      h.nonce = await cn(t, hF, 'getTransactionCount')({ address: d.address, blockTag: 'pending' })
  if ((u.includes('blobVersionedHashes') || u.includes('sidecars')) && r && o) {
    const I = YE({ blobs: r, kzg: o })
    if (u.includes('blobVersionedHashes')) {
      const x = KR({ commitments: I, to: 'hex' })
      h.blobVersionedHashes = x
    }
    if (u.includes('sidecars')) {
      const x = JE({ blobs: r, commitments: I, kzg: o }),
        _ = YR({ blobs: r, commitments: I, proofs: x, to: 'hex' })
      h.sidecars = _
    }
  }
  if (
    (u.includes('chainId') && (h.chainId = await b()),
    (u.includes('fees') || u.includes('type')) && typeof l > 'u')
  )
    try {
      h.type = JR(h)
    } catch {
      let I = UC.get(t.uid)
      if (typeof I > 'u') {
        const x = await y()
        ;(I = typeof (x == null ? void 0 : x.baseFeePerGas) == 'bigint'), UC.set(t.uid, I)
      }
      h.type = I ? 'eip1559' : 'legacy'
    }
  if (u.includes('fees'))
    if (h.type !== 'legacy' && h.type !== 'eip2930') {
      if (typeof h.maxFeePerGas > 'u' || typeof h.maxPriorityFeePerGas > 'u') {
        const I = await y(),
          { maxFeePerGas: x, maxPriorityFeePerGas: _ } = await kC(t, {
            block: I,
            chain: s,
            request: h
          })
        if (typeof e.maxPriorityFeePerGas > 'u' && e.maxFeePerGas && e.maxFeePerGas < _)
          throw new tF({ maxPriorityFeePerGas: _ })
        ;(h.maxPriorityFeePerGas = _), (h.maxFeePerGas = x)
      }
    } else {
      if (typeof e.maxFeePerGas < 'u' || typeof e.maxPriorityFeePerGas < 'u') throw new ZE()
      if (typeof e.gasPrice > 'u') {
        const I = await y(),
          { gasPrice: x } = await kC(t, { block: I, chain: s, request: h, type: 'legacy' })
        h.gasPrice = x
      }
    }
  return (
    u.includes('gas') &&
      typeof i > 'u' &&
      (h.gas = await cn(
        t,
        zR,
        'estimateGas'
      )({ ...h, account: d && { address: d.address, type: 'json-rpc' } })),
    w0(h),
    delete h.parameters,
    h
  )
}
async function CF(t, { serializedTransaction: e }) {
  return t.request({ method: 'eth_sendRawTransaction', params: [e] }, { retryCount: 0 })
}
const rw = new h0(128)
async function e3(t, e) {
  var I, x, _, R
  const {
    account: n = t.account,
    chain: r = t.chain,
    accessList: s,
    authorizationList: i,
    blobs: o,
    data: a,
    gas: c,
    gasPrice: u,
    maxFeePerBlobGas: l,
    maxFeePerGas: d,
    maxPriorityFeePerGas: h,
    nonce: p,
    value: y,
    ...m
  } = e
  if (typeof n > 'u') throw new jE({ docsPath: '/docs/actions/wallet/sendTransaction' })
  const b = n ? go(n) : null
  try {
    w0(e)
    const N = await (async () => {
      if (e.to) return e.to
      if (e.to !== null && i && i.length > 0)
        return await OR({ authorization: i[0] }).catch(() => {
          throw new Se('`to` is required. Could not infer from `authorizationList`.')
        })
    })()
    if ((b == null ? void 0 : b.type) === 'json-rpc' || b === null) {
      let T
      r !== null && ((T = await cn(t, UR, 'getChainId')({})), L$({ currentChainId: T, chain: r }))
      const M =
          (_ =
            (x = (I = t.chain) == null ? void 0 : I.formatters) == null
              ? void 0
              : x.transactionRequest) == null
            ? void 0
            : _.format,
        B = (M || QE)({
          ...VE(m, { format: M }),
          accessList: s,
          authorizationList: i,
          blobs: o,
          chainId: T,
          data: a,
          from: b == null ? void 0 : b.address,
          gas: c,
          gasPrice: u,
          maxFeePerBlobGas: l,
          maxFeePerGas: d,
          maxPriorityFeePerGas: h,
          nonce: p,
          to: N,
          value: y
        }),
        $ = rw.get(t.uid),
        D = $ ? 'wallet_sendTransaction' : 'eth_sendTransaction'
      try {
        return await t.request({ method: D, params: [B] }, { retryCount: 0 })
      } catch (W) {
        if ($ === !1) throw W
        const U = W
        if (
          U.name === 'InvalidInputRpcError' ||
          U.name === 'InvalidParamsRpcError' ||
          U.name === 'MethodNotFoundRpcError' ||
          U.name === 'MethodNotSupportedRpcError'
        )
          return await t
            .request({ method: 'wallet_sendTransaction', params: [B] }, { retryCount: 0 })
            .then(w => (rw.set(t.uid, !0), w))
            .catch(w => {
              const v = w
              throw v.name === 'MethodNotFoundRpcError' || v.name === 'MethodNotSupportedRpcError'
                ? (rw.set(t.uid, !1), U)
                : v
            })
        throw U
      }
    }
    if ((b == null ? void 0 : b.type) === 'local') {
      const T = await cn(
          t,
          eA,
          'prepareTransactionRequest'
        )({
          account: b,
          accessList: s,
          authorizationList: i,
          blobs: o,
          chain: r,
          data: a,
          gas: c,
          gasPrice: u,
          maxFeePerBlobGas: l,
          maxFeePerGas: d,
          maxPriorityFeePerGas: h,
          nonce: p,
          nonceManager: b.nonceManager,
          parameters: [...XR, 'sidecars'],
          value: y,
          ...m,
          to: N
        }),
        M = (R = r == null ? void 0 : r.serializers) == null ? void 0 : R.transaction,
        H = await b.signTransaction(T, { serializer: M })
      return await cn(t, CF, 'sendRawTransaction')({ serializedTransaction: H })
    }
    throw (b == null ? void 0 : b.type) === 'smart'
      ? new nw({
          metaMessages: ['Consider using the `sendUserOperation` Action instead.'],
          docsPath: '/docs/actions/bundler/sendUserOperation',
          type: 'smart'
        })
      : new nw({
          docsPath: '/docs/actions/wallet/sendTransaction',
          type: b == null ? void 0 : b.type
        })
  } catch (N) {
    throw N instanceof nw ? N : Y$(N, { ...e, account: b, chain: e.chain || void 0 })
  }
}
const P1 = [
    {
      inputs: [
        {
          components: [
            { name: 'target', type: 'address' },
            { name: 'allowFailure', type: 'bool' },
            { name: 'callData', type: 'bytes' }
          ],
          name: 'calls',
          type: 'tuple[]'
        }
      ],
      name: 'aggregate3',
      outputs: [
        {
          components: [
            { name: 'success', type: 'bool' },
            { name: 'returnData', type: 'bytes' }
          ],
          name: 'returnData',
          type: 'tuple[]'
        }
      ],
      stateMutability: 'view',
      type: 'function'
    }
  ],
  t3 = [
    { inputs: [], name: 'ResolverNotFound', type: 'error' },
    { inputs: [], name: 'ResolverWildcardNotSupported', type: 'error' },
    { inputs: [], name: 'ResolverNotContract', type: 'error' },
    { inputs: [{ name: 'returnData', type: 'bytes' }], name: 'ResolverError', type: 'error' },
    {
      inputs: [
        {
          components: [
            { name: 'status', type: 'uint16' },
            { name: 'message', type: 'string' }
          ],
          name: 'errors',
          type: 'tuple[]'
        }
      ],
      name: 'HttpError',
      type: 'error'
    }
  ],
  n3 = [
    ...t3,
    {
      name: 'resolve',
      type: 'function',
      stateMutability: 'view',
      inputs: [
        { name: 'name', type: 'bytes' },
        { name: 'data', type: 'bytes' }
      ],
      outputs: [
        { name: '', type: 'bytes' },
        { name: 'address', type: 'address' }
      ]
    },
    {
      name: 'resolve',
      type: 'function',
      stateMutability: 'view',
      inputs: [
        { name: 'name', type: 'bytes' },
        { name: 'data', type: 'bytes' },
        { name: 'gateways', type: 'string[]' }
      ],
      outputs: [
        { name: '', type: 'bytes' },
        { name: 'address', type: 'address' }
      ]
    }
  ],
  SF = [
    ...t3,
    {
      name: 'reverse',
      type: 'function',
      stateMutability: 'view',
      inputs: [{ type: 'bytes', name: 'reverseName' }],
      outputs: [
        { type: 'string', name: 'resolvedName' },
        { type: 'address', name: 'resolvedAddress' },
        { type: 'address', name: 'reverseResolver' },
        { type: 'address', name: 'resolver' }
      ]
    },
    {
      name: 'reverse',
      type: 'function',
      stateMutability: 'view',
      inputs: [
        { type: 'bytes', name: 'reverseName' },
        { type: 'string[]', name: 'gateways' }
      ],
      outputs: [
        { type: 'string', name: 'resolvedName' },
        { type: 'address', name: 'resolvedAddress' },
        { type: 'address', name: 'reverseResolver' },
        { type: 'address', name: 'resolver' }
      ]
    }
  ],
  LC = [
    {
      name: 'text',
      type: 'function',
      stateMutability: 'view',
      inputs: [
        { name: 'name', type: 'bytes32' },
        { name: 'key', type: 'string' }
      ],
      outputs: [{ name: '', type: 'string' }]
    }
  ],
  $C = [
    {
      name: 'addr',
      type: 'function',
      stateMutability: 'view',
      inputs: [{ name: 'name', type: 'bytes32' }],
      outputs: [{ name: '', type: 'address' }]
    },
    {
      name: 'addr',
      type: 'function',
      stateMutability: 'view',
      inputs: [
        { name: 'name', type: 'bytes32' },
        { name: 'coinType', type: 'uint256' }
      ],
      outputs: [{ name: '', type: 'bytes' }]
    }
  ]
function IF(t, e = {}) {
  typeof e.size < 'u' && Di(t, { size: e.size })
  const n = br(t, e)
  return Ci(n, e)
}
function xF(t, e = {}) {
  let n = t
  if ((typeof e.size < 'u' && (Di(n, { size: e.size }), (n = io(n))), n.length > 1 || n[0] > 1))
    throw new wL(n)
  return !!n[0]
}
function Wo(t, e = {}) {
  typeof e.size < 'u' && Di(t, { size: e.size })
  const n = br(t, e)
  return Ya(n, e)
}
function TF(t, e = {}) {
  let n = t
  return (
    typeof e.size < 'u' && (Di(n, { size: e.size }), (n = io(n, { dir: 'right' }))),
    new TextDecoder().decode(n)
  )
}
function v0(t, e) {
  const n = typeof e == 'string' ? oo(e) : e,
    r = HE(n)
  if (ir(n) === 0 && t.length > 0) throw new d0()
  if (ir(e) && ir(e) < 32)
    throw new uR({ data: typeof e == 'string' ? e : br(e), params: t, size: ir(e) })
  let s = 0
  const i = []
  for (let o = 0; o < t.length; ++o) {
    const a = t[o]
    r.setPosition(s)
    const [c, u] = Nl(r, a, { staticPosition: 0 })
    ;(s += u), i.push(c)
  }
  return i
}
function Nl(t, e, { staticPosition: n }) {
  const r = FE(e.type)
  if (r) {
    const [s, i] = r
    return PF(t, { ...e, type: i }, { length: s, staticPosition: n })
  }
  if (e.type === 'tuple') return BF(t, e, { staticPosition: n })
  if (e.type === 'address') return NF(t)
  if (e.type === 'bool') return RF(t)
  if (e.type.startsWith('bytes')) return kF(t, e, { staticPosition: n })
  if (e.type.startsWith('uint') || e.type.startsWith('int')) return OF(t, e)
  if (e.type === 'string') return DF(t, { staticPosition: n })
  throw new DL(e.type, { docsPath: '/docs/contract/decodeAbiParameters' })
}
const FC = 32,
  R1 = 32
function NF(t) {
  const e = t.readBytes(32)
  return [p0(br(xR(e, -20))), 32]
}
function PF(t, e, { length: n, staticPosition: r }) {
  if (!n) {
    const o = Wo(t.readBytes(R1)),
      a = r + o,
      c = a + FC
    t.setPosition(a)
    const u = Wo(t.readBytes(FC)),
      l = hf(e)
    let d = 0
    const h = []
    for (let p = 0; p < u; ++p) {
      t.setPosition(c + (l ? p * 32 : d))
      const [y, m] = Nl(t, e, { staticPosition: c })
      ;(d += m), h.push(y)
    }
    return t.setPosition(r + 32), [h, 32]
  }
  if (hf(e)) {
    const o = Wo(t.readBytes(R1)),
      a = r + o,
      c = []
    for (let u = 0; u < n; ++u) {
      t.setPosition(a + u * 32)
      const [l] = Nl(t, e, { staticPosition: a })
      c.push(l)
    }
    return t.setPosition(r + 32), [c, 32]
  }
  let s = 0
  const i = []
  for (let o = 0; o < n; ++o) {
    const [a, c] = Nl(t, e, { staticPosition: r + s })
    ;(s += c), i.push(a)
  }
  return [i, s]
}
function RF(t) {
  return [xF(t.readBytes(32), { size: 32 }), 32]
}
function kF(t, e, { staticPosition: n }) {
  const [r, s] = e.type.split('bytes')
  if (!s) {
    const o = Wo(t.readBytes(32))
    t.setPosition(n + o)
    const a = Wo(t.readBytes(32))
    if (a === 0) return t.setPosition(n + 32), ['0x', 32]
    const c = t.readBytes(a)
    return t.setPosition(n + 32), [br(c), 32]
  }
  return [br(t.readBytes(Number.parseInt(s), 32)), 32]
}
function OF(t, e) {
  const n = e.type.startsWith('int'),
    r = Number.parseInt(e.type.split('int')[1] || '256'),
    s = t.readBytes(32)
  return [r > 48 ? IF(s, { signed: n }) : Wo(s, { signed: n }), 32]
}
function BF(t, e, { staticPosition: n }) {
  const r = e.components.length === 0 || e.components.some(({ name: o }) => !o),
    s = r ? [] : {}
  let i = 0
  if (hf(e)) {
    const o = Wo(t.readBytes(R1)),
      a = n + o
    for (let c = 0; c < e.components.length; ++c) {
      const u = e.components[c]
      t.setPosition(a + i)
      const [l, d] = Nl(t, u, { staticPosition: a })
      ;(i += d), (s[r ? c : u == null ? void 0 : u.name] = l)
    }
    return t.setPosition(n + 32), [s, 32]
  }
  for (let o = 0; o < e.components.length; ++o) {
    const a = e.components[o],
      [c, u] = Nl(t, a, { staticPosition: n })
    ;(s[r ? o : a == null ? void 0 : a.name] = c), (i += u)
  }
  return [s, i]
}
function DF(t, { staticPosition: e }) {
  const n = Wo(t.readBytes(32)),
    r = e + n
  t.setPosition(r)
  const s = Wo(t.readBytes(32))
  if (s === 0) return t.setPosition(e + 32), ['', 32]
  const i = t.readBytes(s, 32),
    o = TF(io(i))
  return t.setPosition(e + 32), [o, 32]
}
function hf(t) {
  var r
  const { type: e } = t
  if (e === 'string' || e === 'bytes' || e.endsWith('[]')) return !0
  if (e === 'tuple') return (r = t.components) == null ? void 0 : r.some(hf)
  const n = FE(t.type)
  return !!(n && hf({ ...t, type: n[1] }))
}
const MF = t => Xa(np(t))
function UF(t) {
  return MF(t)
}
const LF = '1.0.8'
let ci = class k1 extends Error {
  constructor(e, n = {}) {
    var o
    const r =
        n.cause instanceof k1
          ? n.cause.details
          : (o = n.cause) != null && o.message
            ? n.cause.message
            : n.details,
      s = (n.cause instanceof k1 && n.cause.docsPath) || n.docsPath,
      i = [
        e || 'An error occurred.',
        '',
        ...(n.metaMessages ? [...n.metaMessages, ''] : []),
        ...(s ? [`Docs: https://abitype.dev${s}`] : []),
        ...(r ? [`Details: ${r}`] : []),
        `Version: abitype@${LF}`
      ].join(`
`)
    super(i),
      Object.defineProperty(this, 'details', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'docsPath', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'metaMessages', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'shortMessage', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'AbiTypeError'
      }),
      n.cause && (this.cause = n.cause),
      (this.details = r),
      (this.docsPath = s),
      (this.metaMessages = n.metaMessages),
      (this.shortMessage = e)
  }
}
function ra(t, e) {
  const n = t.exec(e)
  return n == null ? void 0 : n.groups
}
const r3 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
  s3 =
    /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
  i3 = /^\(.+?\).*?$/,
  jC = /^tuple(?<array>(\[(\d*)\])*)$/
function O1(t) {
  let e = t.type
  if (jC.test(t.type) && 'components' in t) {
    e = '('
    const n = t.components.length
    for (let s = 0; s < n; s++) {
      const i = t.components[s]
      ;(e += O1(i)), s < n - 1 && (e += ', ')
    }
    const r = ra(jC, t.type)
    return (e += `)${(r == null ? void 0 : r.array) ?? ''}`), O1({ ...t, type: e })
  }
  return 'indexed' in t && t.indexed && (e = `${e} indexed`), t.name ? `${e} ${t.name}` : e
}
function jd(t) {
  let e = ''
  const n = t.length
  for (let r = 0; r < n; r++) {
    const s = t[r]
    ;(e += O1(s)), r !== n - 1 && (e += ', ')
  }
  return e
}
function $F(t) {
  var e
  return t.type === 'function'
    ? `function ${t.name}(${jd(t.inputs)})${t.stateMutability && t.stateMutability !== 'nonpayable' ? ` ${t.stateMutability}` : ''}${(e = t.outputs) != null && e.length ? ` returns (${jd(t.outputs)})` : ''}`
    : t.type === 'event'
      ? `event ${t.name}(${jd(t.inputs)})`
      : t.type === 'error'
        ? `error ${t.name}(${jd(t.inputs)})`
        : t.type === 'constructor'
          ? `constructor(${jd(t.inputs)})${t.stateMutability === 'payable' ? ' payable' : ''}`
          : t.type === 'fallback'
            ? `fallback() external${t.stateMutability === 'payable' ? ' payable' : ''}`
            : 'receive() external payable'
}
const o3 = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/
function FF(t) {
  return o3.test(t)
}
function jF(t) {
  return ra(o3, t)
}
const a3 = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/
function HF(t) {
  return a3.test(t)
}
function qF(t) {
  return ra(a3, t)
}
const c3 =
  /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/
function zF(t) {
  return c3.test(t)
}
function WF(t) {
  return ra(c3, t)
}
const u3 = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/
function l3(t) {
  return u3.test(t)
}
function KF(t) {
  return ra(u3, t)
}
const d3 = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/
function VF(t) {
  return d3.test(t)
}
function GF(t) {
  return ra(d3, t)
}
const h3 = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/
function QF(t) {
  return h3.test(t)
}
function ZF(t) {
  return ra(h3, t)
}
const YF = /^receive\(\) external payable$/
function JF(t) {
  return YF.test(t)
}
const XF = new Set(['indexed']),
  B1 = new Set(['calldata', 'memory', 'storage'])
class e9 extends ci {
  constructor({ type: e }) {
    super('Unknown type.', {
      metaMessages: [
        `Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'UnknownTypeError'
      })
  }
}
class t9 extends ci {
  constructor({ type: e }) {
    super('Unknown type.', { metaMessages: [`Type "${e}" is not a valid ABI type.`] }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'UnknownSolidityTypeError'
      })
  }
}
class n9 extends ci {
  constructor({ param: e }) {
    super('Invalid ABI parameter.', { details: e }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidParameterError'
      })
  }
}
class r9 extends ci {
  constructor({ param: e, name: n }) {
    super('Invalid ABI parameter.', {
      details: e,
      metaMessages: [
        `"${n}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'SolidityProtectedKeywordError'
      })
  }
}
class s9 extends ci {
  constructor({ param: e, type: n, modifier: r }) {
    super('Invalid ABI parameter.', {
      details: e,
      metaMessages: [`Modifier "${r}" not allowed${n ? ` in "${n}" type` : ''}.`]
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidModifierError'
      })
  }
}
class i9 extends ci {
  constructor({ param: e, type: n, modifier: r }) {
    super('Invalid ABI parameter.', {
      details: e,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ''}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`
      ]
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidFunctionModifierError'
      })
  }
}
class o9 extends ci {
  constructor({ abiParameter: e }) {
    super('Invalid ABI parameter.', {
      details: JSON.stringify(e, null, 2),
      metaMessages: ['ABI parameter type is invalid.']
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidAbiTypeParameterError'
      })
  }
}
class Ed extends ci {
  constructor({ signature: e, type: n }) {
    super(`Invalid ${n} signature.`, { details: e }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidSignatureError'
      })
  }
}
class a9 extends ci {
  constructor({ signature: e }) {
    super('Unknown signature.', { details: e }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'UnknownSignatureError'
      })
  }
}
class c9 extends ci {
  constructor({ signature: e }) {
    super('Invalid struct signature.', { details: e, metaMessages: ['No properties exist.'] }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidStructSignatureError'
      })
  }
}
class u9 extends ci {
  constructor({ type: e }) {
    super('Circular reference detected.', {
      metaMessages: [`Struct "${e}" is a circular reference.`]
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'CircularReferenceError'
      })
  }
}
class l9 extends ci {
  constructor({ current: e, depth: n }) {
    super('Unbalanced parentheses.', {
      metaMessages: [`"${e.trim()}" has too many ${n > 0 ? 'opening' : 'closing'} parentheses.`],
      details: `Depth "${n}"`
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'InvalidParenthesisError'
      })
  }
}
function d9(t, e, n) {
  let r = ''
  if (n)
    for (const s of Object.entries(n)) {
      if (!s) continue
      let i = ''
      for (const o of s[1]) i += `[${o.type}${o.name ? `:${o.name}` : ''}]`
      r += `(${s[0]}{${i}})`
    }
  return e ? `${e}:${t}${r}` : t
}
const sw = new Map([
  ['address', { type: 'address' }],
  ['bool', { type: 'bool' }],
  ['bytes', { type: 'bytes' }],
  ['bytes32', { type: 'bytes32' }],
  ['int', { type: 'int256' }],
  ['int256', { type: 'int256' }],
  ['string', { type: 'string' }],
  ['uint', { type: 'uint256' }],
  ['uint8', { type: 'uint8' }],
  ['uint16', { type: 'uint16' }],
  ['uint24', { type: 'uint24' }],
  ['uint32', { type: 'uint32' }],
  ['uint64', { type: 'uint64' }],
  ['uint96', { type: 'uint96' }],
  ['uint112', { type: 'uint112' }],
  ['uint160', { type: 'uint160' }],
  ['uint192', { type: 'uint192' }],
  ['uint256', { type: 'uint256' }],
  ['address owner', { type: 'address', name: 'owner' }],
  ['address to', { type: 'address', name: 'to' }],
  ['bool approved', { type: 'bool', name: 'approved' }],
  ['bytes _data', { type: 'bytes', name: '_data' }],
  ['bytes data', { type: 'bytes', name: 'data' }],
  ['bytes signature', { type: 'bytes', name: 'signature' }],
  ['bytes32 hash', { type: 'bytes32', name: 'hash' }],
  ['bytes32 r', { type: 'bytes32', name: 'r' }],
  ['bytes32 root', { type: 'bytes32', name: 'root' }],
  ['bytes32 s', { type: 'bytes32', name: 's' }],
  ['string name', { type: 'string', name: 'name' }],
  ['string symbol', { type: 'string', name: 'symbol' }],
  ['string tokenURI', { type: 'string', name: 'tokenURI' }],
  ['uint tokenId', { type: 'uint256', name: 'tokenId' }],
  ['uint8 v', { type: 'uint8', name: 'v' }],
  ['uint256 balance', { type: 'uint256', name: 'balance' }],
  ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],
  ['uint256 value', { type: 'uint256', name: 'value' }],
  ['event:address indexed from', { type: 'address', name: 'from', indexed: !0 }],
  ['event:address indexed to', { type: 'address', name: 'to', indexed: !0 }],
  ['event:uint indexed tokenId', { type: 'uint256', name: 'tokenId', indexed: !0 }],
  ['event:uint256 indexed tokenId', { type: 'uint256', name: 'tokenId', indexed: !0 }]
])
function h9(t, e = {}) {
  if (zF(t)) return f9(t, e)
  if (HF(t)) return p9(t, e)
  if (FF(t)) return g9(t, e)
  if (VF(t)) return m9(t, e)
  if (QF(t)) return y9(t)
  if (JF(t)) return { type: 'receive', stateMutability: 'payable' }
  throw new a9({ signature: t })
}
function f9(t, e = {}) {
  const n = WF(t)
  if (!n) throw new Ed({ signature: t, type: 'function' })
  const r = Si(n.parameters),
    s = [],
    i = r.length
  for (let a = 0; a < i; a++) s.push(au(r[a], { modifiers: B1, structs: e, type: 'function' }))
  const o = []
  if (n.returns) {
    const a = Si(n.returns),
      c = a.length
    for (let u = 0; u < c; u++) o.push(au(a[u], { modifiers: B1, structs: e, type: 'function' }))
  }
  return {
    name: n.name,
    type: 'function',
    stateMutability: n.stateMutability ?? 'nonpayable',
    inputs: s,
    outputs: o
  }
}
function p9(t, e = {}) {
  const n = qF(t)
  if (!n) throw new Ed({ signature: t, type: 'event' })
  const r = Si(n.parameters),
    s = [],
    i = r.length
  for (let o = 0; o < i; o++) s.push(au(r[o], { modifiers: XF, structs: e, type: 'event' }))
  return { name: n.name, type: 'event', inputs: s }
}
function g9(t, e = {}) {
  const n = jF(t)
  if (!n) throw new Ed({ signature: t, type: 'error' })
  const r = Si(n.parameters),
    s = [],
    i = r.length
  for (let o = 0; o < i; o++) s.push(au(r[o], { structs: e, type: 'error' }))
  return { name: n.name, type: 'error', inputs: s }
}
function m9(t, e = {}) {
  const n = GF(t)
  if (!n) throw new Ed({ signature: t, type: 'constructor' })
  const r = Si(n.parameters),
    s = [],
    i = r.length
  for (let o = 0; o < i; o++) s.push(au(r[o], { structs: e, type: 'constructor' }))
  return { type: 'constructor', stateMutability: n.stateMutability ?? 'nonpayable', inputs: s }
}
function y9(t) {
  const e = ZF(t)
  if (!e) throw new Ed({ signature: t, type: 'fallback' })
  return { type: 'fallback', stateMutability: e.stateMutability ?? 'nonpayable' }
}
const w9 =
    /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
  b9 =
    /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
  v9 = /^u?int$/
function au(t, e) {
  var d, h
  const n = d9(t, e == null ? void 0 : e.type, e == null ? void 0 : e.structs)
  if (sw.has(n)) return sw.get(n)
  const r = i3.test(t),
    s = ra(r ? b9 : w9, t)
  if (!s) throw new n9({ param: t })
  if (s.name && A9(s.name)) throw new r9({ param: t, name: s.name })
  const i = s.name ? { name: s.name } : {},
    o = s.modifier === 'indexed' ? { indexed: !0 } : {},
    a = (e == null ? void 0 : e.structs) ?? {}
  let c,
    u = {}
  if (r) {
    c = 'tuple'
    const p = Si(s.type),
      y = [],
      m = p.length
    for (let b = 0; b < m; b++) y.push(au(p[b], { structs: a }))
    u = { components: y }
  } else if (s.type in a) (c = 'tuple'), (u = { components: a[s.type] })
  else if (v9.test(s.type)) c = `${s.type}256`
  else if (((c = s.type), (e == null ? void 0 : e.type) !== 'struct' && !f3(c)))
    throw new t9({ type: c })
  if (s.modifier) {
    if (
      !(
        (h = (d = e == null ? void 0 : e.modifiers) == null ? void 0 : d.has) != null &&
        h.call(d, s.modifier)
      )
    )
      throw new s9({ param: t, type: e == null ? void 0 : e.type, modifier: s.modifier })
    if (B1.has(s.modifier) && !_9(c, !!s.array))
      throw new i9({ param: t, type: e == null ? void 0 : e.type, modifier: s.modifier })
  }
  const l = { type: `${c}${s.array ?? ''}`, ...i, ...o, ...u }
  return sw.set(n, l), l
}
function Si(t, e = [], n = '', r = 0) {
  const s = t.trim().length
  for (let i = 0; i < s; i++) {
    const o = t[i],
      a = t.slice(i + 1)
    switch (o) {
      case ',':
        return r === 0 ? Si(a, [...e, n.trim()]) : Si(a, e, `${n}${o}`, r)
      case '(':
        return Si(a, e, `${n}${o}`, r + 1)
      case ')':
        return Si(a, e, `${n}${o}`, r - 1)
      default:
        return Si(a, e, `${n}${o}`, r)
    }
  }
  if (n === '') return e
  if (r !== 0) throw new l9({ current: n, depth: r })
  return e.push(n.trim()), e
}
function f3(t) {
  return (
    t === 'address' ||
    t === 'bool' ||
    t === 'function' ||
    t === 'string' ||
    r3.test(t) ||
    s3.test(t)
  )
}
const E9 =
  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/
function A9(t) {
  return (
    t === 'address' ||
    t === 'bool' ||
    t === 'function' ||
    t === 'string' ||
    t === 'tuple' ||
    r3.test(t) ||
    s3.test(t) ||
    E9.test(t)
  )
}
function _9(t, e) {
  return e || t === 'bytes' || t === 'string' || t === 'tuple'
}
function C9(t) {
  const e = {},
    n = t.length
  for (let o = 0; o < n; o++) {
    const a = t[o]
    if (!l3(a)) continue
    const c = KF(a)
    if (!c) throw new Ed({ signature: a, type: 'struct' })
    const u = c.properties.split(';'),
      l = [],
      d = u.length
    for (let h = 0; h < d; h++) {
      const y = u[h].trim()
      if (!y) continue
      const m = au(y, { type: 'struct' })
      l.push(m)
    }
    if (!l.length) throw new c9({ signature: a })
    e[c.name] = l
  }
  const r = {},
    s = Object.entries(e),
    i = s.length
  for (let o = 0; o < i; o++) {
    const [a, c] = s[o]
    r[a] = p3(c, e)
  }
  return r
}
const S9 = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/
function p3(t, e, n = new Set()) {
  const r = [],
    s = t.length
  for (let i = 0; i < s; i++) {
    const o = t[i]
    if (i3.test(o.type)) r.push(o)
    else {
      const c = ra(S9, o.type)
      if (!(c != null && c.type)) throw new o9({ abiParameter: o })
      const { array: u, type: l } = c
      if (l in e) {
        if (n.has(l)) throw new u9({ type: l })
        r.push({ ...o, type: `tuple${u ?? ''}`, components: p3(e[l] ?? [], e, new Set([...n, l])) })
      } else if (f3(l)) r.push(o)
      else throw new e9({ type: l })
    }
  }
  return r
}
function g3(t) {
  const e = C9(t),
    n = [],
    r = t.length
  for (let s = 0; s < r; s++) {
    const i = t[s]
    l3(i) || n.push(h9(i, e))
  }
  return n
}
function I9(t) {
  let e = !0,
    n = '',
    r = 0,
    s = '',
    i = !1
  for (let o = 0; o < t.length; o++) {
    const a = t[o]
    if ((['(', ')', ','].includes(a) && (e = !0), a === '(' && r++, a === ')' && r--, !!e)) {
      if (r === 0) {
        if (a === ' ' && ['event', 'function', ''].includes(s)) s = ''
        else if (((s += a), a === ')')) {
          i = !0
          break
        }
        continue
      }
      if (a === ' ') {
        t[o - 1] !== ',' && n !== ',' && n !== ',(' && ((n = ''), (e = !1))
        continue
      }
      ;(s += a), (n += a)
    }
  }
  if (!i) throw new Se('Unable to normalize signature.')
  return s
}
const x9 = t => {
  const e = typeof t == 'string' ? t : $F(t)
  return I9(e)
}
function m3(t) {
  return UF(x9(t))
}
const tA = m3,
  nA = t => Yh(m3(t), 0, 4)
function rA(t) {
  const { abi: e, args: n = [], name: r } = t,
    s = Yo(r, { strict: !1 }),
    i = e.filter(a =>
      s
        ? a.type === 'function'
          ? nA(a) === r
          : a.type === 'event'
            ? tA(a) === r
            : !1
        : 'name' in a && a.name === r
    )
  if (i.length === 0) return
  if (i.length === 1) return i[0]
  let o
  for (const a of i) {
    if (!('inputs' in a)) continue
    if (!n || n.length === 0) {
      if (!a.inputs || a.inputs.length === 0) return a
      continue
    }
    if (!a.inputs || a.inputs.length === 0 || a.inputs.length !== n.length) continue
    if (
      n.every((u, l) => {
        const d = 'inputs' in a && a.inputs[l]
        return d ? D1(u, d) : !1
      })
    ) {
      if (o && 'inputs' in o && o.inputs) {
        const u = y3(a.inputs, o.inputs, n)
        if (u) throw new OL({ abiItem: a, type: u[0] }, { abiItem: o, type: u[1] })
      }
      o = a
    }
  }
  return o || i[0]
}
function D1(t, e) {
  const n = typeof t,
    r = e.type
  switch (r) {
    case 'address':
      return Rr(t, { strict: !1 })
    case 'bool':
      return n === 'boolean'
    case 'function':
      return n === 'string'
    case 'string':
      return n === 'string'
    default:
      return r === 'tuple' && 'components' in e
        ? Object.values(e.components).every((s, i) => D1(Object.values(t)[i], s))
        : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(
              r
            )
          ? n === 'number' || n === 'bigint'
          : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r)
            ? n === 'string' || t instanceof Uint8Array
            : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r)
              ? Array.isArray(t) &&
                t.every(s => D1(s, { ...e, type: r.replace(/(\[[0-9]{0,}\])$/, '') }))
              : !1
  }
}
function y3(t, e, n) {
  for (const r in t) {
    const s = t[r],
      i = e[r]
    if (s.type === 'tuple' && i.type === 'tuple' && 'components' in s && 'components' in i)
      return y3(s.components, i.components, n[r])
    const o = [s.type, i.type]
    if (
      o.includes('address') && o.includes('bytes20')
        ? !0
        : o.includes('address') && o.includes('string')
          ? Rr(n[r], { strict: !1 })
          : o.includes('address') && o.includes('bytes')
            ? Rr(n[r], { strict: !1 })
            : !1
    )
      return o
  }
}
const iw = '/docs/contract/decodeFunctionResult'
function sp(t) {
  const { abi: e, args: n, functionName: r, data: s } = t
  let i = e[0]
  if (r) {
    const a = rA({ abi: e, args: n, name: r })
    if (!a) throw new om(r, { docsPath: iw })
    i = a
  }
  if (i.type !== 'function') throw new om(void 0, { docsPath: iw })
  if (!i.outputs) throw new kL(i.name, { docsPath: iw })
  const o = v0(i.outputs, s)
  if (o && o.length > 1) return o
  if (o && o.length === 1) return o[0]
}
const HC = '/docs/contract/encodeFunctionData'
function T9(t) {
  const { abi: e, args: n, functionName: r } = t
  let s = e[0]
  if (r) {
    const i = rA({ abi: e, args: n, name: r })
    if (!i) throw new om(r, { docsPath: HC })
    s = i
  }
  if (s.type !== 'function') throw new om(void 0, { docsPath: HC })
  return { abi: [s], functionName: nA(Ja(s)) }
}
function Ad(t) {
  const { args: e } = t,
    { abi: n, functionName: r } = (() => {
      var a
      return t.abi.length === 1 && (a = t.functionName) != null && a.startsWith('0x') ? t : T9(t)
    })(),
    s = n[0],
    i = r,
    o = 'inputs' in s && s.inputs ? TR(s.inputs, e ?? []) : void 0
  return na([i, o ?? '0x'])
}
function ip({ blockNumber: t, chain: e, contract: n }) {
  var s
  const r = (s = e == null ? void 0 : e.contracts) == null ? void 0 : s[n]
  if (!r) throw new E1({ chain: e, contract: { name: n } })
  if (t && r.blockCreated && r.blockCreated > t)
    throw new E1({ blockNumber: t, chain: e, contract: { name: n, blockCreated: r.blockCreated } })
  return r.address
}
const w3 = {
    1: 'An `assert` condition failed.',
    17: 'Arithmetic operation resulted in underflow or overflow.',
    18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',
    33: 'Attempted to convert to an invalid type.',
    34: 'Attempted to access a storage byte array that is incorrectly encoded.',
    49: 'Performed `.pop()` on an empty array',
    50: 'Array index is out of bounds.',
    65: 'Allocated too much memory or created an array which is too large.',
    81: 'Attempted to call a zero-initialized variable of internal function type.'
  },
  N9 = { inputs: [{ name: 'message', type: 'string' }], name: 'Error', type: 'error' },
  P9 = { inputs: [{ name: 'reason', type: 'uint256' }], name: 'Panic', type: 'error' }
function R9(t) {
  const { abi: e, data: n } = t,
    r = Yh(n, 0, 4)
  if (r === '0x') throw new d0()
  const i = [...(e || []), N9, P9].find(o => o.type === 'error' && r === nA(Ja(o)))
  if (!i) throw new lR(r, { docsPath: '/docs/contract/decodeErrorResult' })
  return {
    abiItem: i,
    args: 'inputs' in i && i.inputs && i.inputs.length > 0 ? v0(i.inputs, Yh(n, 4)) : void 0,
    errorName: i.name
  }
}
function b3({ abiItem: t, args: e, includeFunctionName: n = !0, includeName: r = !1 }) {
  if ('name' in t && 'inputs' in t && t.inputs)
    return `${n ? t.name : ''}(${t.inputs.map((s, i) => `${r && s.name ? `${s.name}: ` : ''}${typeof e[i] == 'object' ? oi(e[i]) : e[i]}`).join(', ')})`
}
class k9 extends Se {
  constructor(
    e,
    {
      account: n,
      docsPath: r,
      chain: s,
      data: i,
      gas: o,
      gasPrice: a,
      maxFeePerGas: c,
      maxPriorityFeePerGas: u,
      nonce: l,
      to: d,
      value: h,
      stateOverride: p
    }
  ) {
    var b
    const y = n ? go(n) : void 0
    let m = rp({
      from: y == null ? void 0 : y.address,
      to: d,
      value:
        typeof h < 'u' &&
        `${qE(h)} ${((b = s == null ? void 0 : s.nativeCurrency) == null ? void 0 : b.symbol) || 'ETH'}`,
      data: i,
      gas: o,
      gasPrice: typeof a < 'u' && `${As(a)} gwei`,
      maxFeePerGas: typeof c < 'u' && `${As(c)} gwei`,
      maxPriorityFeePerGas: typeof u < 'u' && `${As(u)} gwei`,
      nonce: l
    })
    p &&
      (m += `
${lF(p)}`),
      super(e.shortMessage, {
        cause: e,
        docsPath: r,
        metaMessages: [
          ...(e.metaMessages ? [...e.metaMessages, ' '] : []),
          'Raw Call Arguments:',
          m
        ].filter(Boolean),
        name: 'CallExecutionError'
      }),
      Object.defineProperty(this, 'cause', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.cause = e)
  }
}
class v3 extends Se {
  constructor(e, { abi: n, args: r, contractAddress: s, docsPath: i, functionName: o, sender: a }) {
    const c = rA({ abi: n, args: r, name: o }),
      u = c ? b3({ abiItem: c, args: r, includeFunctionName: !1, includeName: !1 }) : void 0,
      l = c ? Ja(c, { includeName: !0 }) : void 0,
      d = rp({
        address: s && G$(s),
        function: l,
        args:
          u &&
          u !== '()' &&
          `${[...Array((o == null ? void 0 : o.length) ?? 0).keys()].map(() => ' ').join('')}${u}`,
        sender: a
      })
    super(
      e.shortMessage || `An unknown error occurred while executing the contract function "${o}".`,
      {
        cause: e,
        docsPath: i,
        metaMessages: [
          ...(e.metaMessages ? [...e.metaMessages, ' '] : []),
          d && 'Contract Call:',
          d
        ].filter(Boolean),
        name: 'ContractFunctionExecutionError'
      }
    ),
      Object.defineProperty(this, 'abi', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'args', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'cause', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'contractAddress', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'formattedArgs', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'functionName', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'sender', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.abi = n),
      (this.args = r),
      (this.cause = e),
      (this.contractAddress = s),
      (this.functionName = o),
      (this.sender = a)
  }
}
class M1 extends Se {
  constructor({ abi: e, data: n, functionName: r, message: s }) {
    let i, o, a, c
    if (n && n !== '0x')
      try {
        o = R9({ abi: e, data: n })
        const { abiItem: l, errorName: d, args: h } = o
        if (d === 'Error') c = h[0]
        else if (d === 'Panic') {
          const [p] = h
          c = w3[p]
        } else {
          const p = l ? Ja(l, { includeName: !0 }) : void 0,
            y =
              l && h
                ? b3({ abiItem: l, args: h, includeFunctionName: !1, includeName: !1 })
                : void 0
          a = [
            p ? `Error: ${p}` : '',
            y && y !== '()'
              ? `       ${[...Array((d == null ? void 0 : d.length) ?? 0).keys()].map(() => ' ').join('')}${y}`
              : ''
          ]
        }
      } catch (l) {
        i = l
      }
    else s && (c = s)
    let u
    i instanceof lR &&
      ((u = i.signature),
      (a = [
        `Unable to decode signature "${u}" as it was not found on the provided ABI.`,
        'Make sure you are using the correct ABI and that the error exists on it.',
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${u}.`
      ])),
      super(
        (c && c !== 'execution reverted') || u
          ? [
              `The contract function "${r}" reverted with the following ${u ? 'signature' : 'reason'}:`,
              c || u
            ].join(`
`)
          : `The contract function "${r}" reverted.`,
        { cause: i, metaMessages: a, name: 'ContractFunctionRevertedError' }
      ),
      Object.defineProperty(this, 'data', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'raw', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'reason', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'signature', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.data = o),
      (this.raw = n),
      (this.reason = c),
      (this.signature = u)
  }
}
class O9 extends Se {
  constructor({ functionName: e }) {
    super(`The contract function "${e}" returned no data ("0x").`, {
      metaMessages: [
        'This could be due to any of the following:',
        `  - The contract does not have the function "${e}",`,
        '  - The parameters passed to the contract function may be invalid, or',
        '  - The address is not a contract.'
      ],
      name: 'ContractFunctionZeroDataError'
    })
  }
}
class B9 extends Se {
  constructor({ factory: e }) {
    super(`Deployment for counterfactual contract call failed${e ? ` for factory "${e}".` : ''}`, {
      metaMessages: [
        'Please ensure:',
        '- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).',
        '- The `factoryData` is a valid encoded function call for contract deployment function on the factory.'
      ],
      name: 'CounterfactualDeploymentFailedError'
    })
  }
}
class sA extends Se {
  constructor({ data: e, message: n }) {
    super(n || '', { name: 'RawContractError' }),
      Object.defineProperty(this, 'code', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 3
      }),
      Object.defineProperty(this, 'data', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.data = e)
  }
}
function iA(t, e) {
  var r, s, i, o, a, c
  if (!(t instanceof Se)) return !1
  const n = t.walk(u => u instanceof M1)
  return n instanceof M1
    ? !!(
        ((r = n.data) == null ? void 0 : r.errorName) === 'ResolverNotFound' ||
        ((s = n.data) == null ? void 0 : s.errorName) === 'ResolverWildcardNotSupported' ||
        ((i = n.data) == null ? void 0 : i.errorName) === 'ResolverNotContract' ||
        ((o = n.data) == null ? void 0 : o.errorName) === 'ResolverError' ||
        ((a = n.data) == null ? void 0 : a.errorName) === 'HttpError' ||
        ((c = n.reason) != null &&
          c.includes('Wildcard on non-extended resolvers is not supported')) ||
        (e === 'reverse' && n.reason === w3[50])
      )
    : !1
}
function E3(t) {
  if (t.length !== 66 || t.indexOf('[') !== 0 || t.indexOf(']') !== 65) return null
  const e = `0x${t.slice(1, 65)}`
  return Yo(e) ? e : null
}
function Tg(t) {
  let e = new Uint8Array(32).fill(0)
  if (!t) return br(e)
  const n = t.split('.')
  for (let r = n.length - 1; r >= 0; r -= 1) {
    const s = E3(n[r]),
      i = s ? np(s) : Xa(Yc(n[r]), 'bytes')
    e = Xa(su([e, i]), 'bytes')
  }
  return br(e)
}
function D9(t) {
  return `[${t.slice(2)}]`
}
function M9(t) {
  const e = new Uint8Array(32).fill(0)
  return t ? E3(t) || Xa(Yc(t)) : br(e)
}
function oA(t) {
  const e = t.replace(/^\.|\.$/gm, '')
  if (e.length === 0) return new Uint8Array(1)
  const n = new Uint8Array(Yc(e).byteLength + 2)
  let r = 0
  const s = e.split('.')
  for (let i = 0; i < s.length; i++) {
    let o = Yc(s[i])
    o.byteLength > 255 && (o = Yc(D9(M9(s[i])))),
      (n[r] = o.length),
      n.set(o, r + 1),
      (r += o.length + 1)
  }
  return n.byteLength !== r + 1 ? n.slice(0, r + 1) : n
}
const U9 = 3
function um(t, { abi: e, address: n, args: r, docsPath: s, functionName: i, sender: o }) {
  const a = t instanceof sA ? t : t instanceof Se ? t.walk(y => 'data' in y) || t.walk() : {},
    { code: c, data: u, details: l, message: d, shortMessage: h } = a,
    p =
      t instanceof d0
        ? new O9({ functionName: i })
        : [U9, ou.code].includes(c) && (u || l || d || h)
          ? new M1({
              abi: e,
              data: typeof u == 'object' ? u.data : u,
              functionName: i,
              message: a instanceof WE ? l : (h ?? d)
            })
          : t
  return new v3(p, { abi: e, args: r, contractAddress: n, docsPath: s, functionName: i, sender: o })
}
const L9 = '0x82ad56cb',
  $9 =
    '0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe',
  F9 =
    '0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe'
function j9(t, { docsPath: e, ...n }) {
  const r = (() => {
    const s = KE(t, n)
    return s instanceof m0 ? t : s
  })()
  return new k9(r, { docsPath: e, ...n })
}
function A3() {
  let t = () => {},
    e = () => {}
  return {
    promise: new Promise((r, s) => {
      ;(t = r), (e = s)
    }),
    resolve: t,
    reject: e
  }
}
const ow = new Map()
function _3({ fn: t, id: e, shouldSplitBatch: n, wait: r = 0, sort: s }) {
  const i = async () => {
      const l = c()
      o()
      const d = l.map(({ args: h }) => h)
      d.length !== 0 &&
        t(d)
          .then(h => {
            s && Array.isArray(h) && h.sort(s)
            for (let p = 0; p < l.length; p++) {
              const { resolve: y } = l[p]
              y == null || y([h[p], h])
            }
          })
          .catch(h => {
            for (let p = 0; p < l.length; p++) {
              const { reject: y } = l[p]
              y == null || y(h)
            }
          })
    },
    o = () => ow.delete(e),
    a = () => c().map(({ args: l }) => l),
    c = () => ow.get(e) || [],
    u = l => ow.set(e, [...c(), l])
  return {
    flush: o,
    async schedule(l) {
      const { promise: d, resolve: h, reject: p } = A3()
      return (
        (n == null ? void 0 : n([...a(), l])) && i(),
        c().length > 0
          ? (u({ args: l, resolve: h, reject: p }), d)
          : (u({ args: l, resolve: h, reject: p }), setTimeout(i, r), d)
      )
    }
  }
}
async function C3(t, e) {
  var D, W, U, w
  const {
      account: n = t.account,
      batch: r = !!((D = t.batch) != null && D.multicall),
      blockNumber: s,
      blockTag: i = 'latest',
      accessList: o,
      blobs: a,
      code: c,
      data: u,
      factory: l,
      factoryData: d,
      gas: h,
      gasPrice: p,
      maxFeePerBlobGas: y,
      maxFeePerGas: m,
      maxPriorityFeePerGas: b,
      nonce: I,
      to: x,
      value: _,
      stateOverride: R,
      ...N
    } = e,
    T = n ? go(n) : void 0
  if (c && (l || d))
    throw new Se('Cannot provide both `code` & `factory`/`factoryData` as parameters.')
  if (c && x) throw new Se('Cannot provide both `code` & `to` as parameters.')
  const M = c && u,
    H = l && d && x && u,
    B = M || H,
    $ = M ? z9({ code: c, data: u }) : H ? W9({ data: u, factory: l, factoryData: d, to: x }) : u
  try {
    w0(e)
    const A = (s ? Mt(s) : void 0) || i,
      P = HR(R),
      O =
        (w =
          (U = (W = t.chain) == null ? void 0 : W.formatters) == null
            ? void 0
            : U.transactionRequest) == null
          ? void 0
          : w.format,
      z = (O || QE)({
        ...VE(N, { format: O }),
        from: T == null ? void 0 : T.address,
        accessList: o,
        blobs: a,
        data: $,
        gas: h,
        gasPrice: p,
        maxFeePerBlobGas: y,
        maxFeePerGas: m,
        maxPriorityFeePerGas: b,
        nonce: I,
        to: B ? void 0 : x,
        value: _
      })
    if (r && H9({ request: z }) && !P)
      try {
        return await q9(t, { ...z, blockNumber: s, blockTag: i })
      } catch (E) {
        if (!(E instanceof BR) && !(E instanceof E1)) throw E
      }
    const j = await t.request({ method: 'eth_call', params: P ? [z, A, P] : [z, A] })
    return j === '0x' ? { data: void 0 } : { data: j }
  } catch (v) {
    const A = K9(v),
      { offchainLookup: P, offchainLookupSignature: O } = await qr(
        async () => {
          const { offchainLookup: F, offchainLookupSignature: z } = await import('./ClpiGfu_.js')
          return { offchainLookup: F, offchainLookupSignature: z }
        },
        [],
        import.meta.url
      )
    if (t.ccipRead !== !1 && (A == null ? void 0 : A.slice(0, 10)) === O && x)
      return { data: await P(t, { data: A, to: x }) }
    throw B && (A == null ? void 0 : A.slice(0, 10)) === '0x101bb98d'
      ? new B9({ factory: l })
      : j9(v, { ...e, account: T, chain: t.chain })
  }
}
function H9({ request: t }) {
  const { data: e, to: n, ...r } = t
  return !(!e || e.startsWith(L9) || !n || Object.values(r).filter(s => typeof s < 'u').length > 0)
}
async function q9(t, e) {
  var m
  const { batchSize: n = 1024, wait: r = 0 } =
      typeof ((m = t.batch) == null ? void 0 : m.multicall) == 'object' ? t.batch.multicall : {},
    { blockNumber: s, blockTag: i = 'latest', data: o, multicallAddress: a, to: c } = e
  let u = a
  if (!u) {
    if (!t.chain) throw new BR()
    u = ip({ blockNumber: s, chain: t.chain, contract: 'multicall3' })
  }
  const d = (s ? Mt(s) : void 0) || i,
    { schedule: h } = _3({
      id: `${t.uid}.${d}`,
      wait: r,
      shouldSplitBatch(b) {
        return b.reduce((x, { data: _ }) => x + (_.length - 2), 0) > n * 2
      },
      fn: async b => {
        const I = b.map(R => ({ allowFailure: !0, callData: R.data, target: R.to })),
          x = Ad({ abi: P1, args: [I], functionName: 'aggregate3' }),
          _ = await t.request({ method: 'eth_call', params: [{ data: x, to: u }, d] })
        return sp({ abi: P1, args: [I], functionName: 'aggregate3', data: _ || '0x' })
      }
    }),
    [{ returnData: p, success: y }] = await h({ data: o, to: c })
  if (!y) throw new sA({ data: p })
  return p === '0x' ? { data: void 0 } : { data: p }
}
function z9(t) {
  const { code: e, data: n } = t
  return NR({ abi: g3(['constructor(bytes, bytes)']), bytecode: $9, args: [e, n] })
}
function W9(t) {
  const { data: e, factory: n, factoryData: r, to: s } = t
  return NR({
    abi: g3(['constructor(address, bytes, address, bytes)']),
    bytecode: F9,
    args: [s, e, n, r]
  })
}
function K9(t) {
  var n
  if (!(t instanceof Se)) return
  const e = t.walk()
  return typeof (e == null ? void 0 : e.data) == 'object'
    ? (n = e.data) == null
      ? void 0
      : n.data
    : e.data
}
async function cu(t, e) {
  const { abi: n, address: r, args: s, functionName: i, ...o } = e,
    a = Ad({ abi: n, args: s, functionName: i })
  try {
    const { data: c } = await cn(t, C3, 'call')({ ...o, data: a, to: r })
    return sp({ abi: n, args: s, functionName: i, data: c || '0x' })
  } catch (c) {
    throw um(c, {
      abi: n,
      address: r,
      args: s,
      docsPath: '/docs/contract/readContract',
      functionName: i
    })
  }
}
async function V9(
  t,
  {
    blockNumber: e,
    blockTag: n,
    coinType: r,
    name: s,
    gatewayUrls: i,
    strict: o,
    universalResolverAddress: a
  }
) {
  let c = a
  if (!c) {
    if (!t.chain)
      throw new Error('client chain not configured. universalResolverAddress is required.')
    c = ip({ blockNumber: e, chain: t.chain, contract: 'ensUniversalResolver' })
  }
  try {
    const u = Ad({
        abi: $C,
        functionName: 'addr',
        ...(r != null ? { args: [Tg(s), BigInt(r)] } : { args: [Tg(s)] })
      }),
      l = {
        address: c,
        abi: n3,
        functionName: 'resolve',
        args: [wt(oA(s)), u],
        blockNumber: e,
        blockTag: n
      },
      d = cn(t, cu, 'readContract'),
      h = i ? await d({ ...l, args: [...l.args, i] }) : await d(l)
    if (h[0] === '0x') return null
    const p = sp({
      abi: $C,
      args: r != null ? [Tg(s), BigInt(r)] : void 0,
      functionName: 'addr',
      data: h[0]
    })
    return p === '0x' || io(p) === '0x00' ? null : p
  } catch (u) {
    if (o) throw u
    if (iA(u, 'resolve')) return null
    throw u
  }
}
class G9 extends Se {
  constructor({ data: e }) {
    super('Unable to extract image from metadata. The metadata may be malformed or invalid.', {
      metaMessages: [
        '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',
        '',
        `Provided data: ${JSON.stringify(e)}`
      ],
      name: 'EnsAvatarInvalidMetadataError'
    })
  }
}
class Hd extends Se {
  constructor({ reason: e }) {
    super(`ENS NFT avatar URI is invalid. ${e}`, { name: 'EnsAvatarInvalidNftUriError' })
  }
}
class aA extends Se {
  constructor({ uri: e }) {
    super(
      `Unable to resolve ENS avatar URI "${e}". The URI may be malformed, invalid, or does not respond with a valid image.`,
      { name: 'EnsAvatarUriResolutionError' }
    )
  }
}
class Q9 extends Se {
  constructor({ namespace: e }) {
    super(`ENS NFT avatar namespace "${e}" is not supported. Must be "erc721" or "erc1155".`, {
      name: 'EnsAvatarUnsupportedNamespaceError'
    })
  }
}
const Z9 =
    /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/,
  Y9 =
    /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/,
  J9 = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/,
  X9 = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/
async function e7(t) {
  try {
    const e = await fetch(t, { method: 'HEAD' })
    if (e.status === 200) {
      const n = e.headers.get('content-type')
      return n == null ? void 0 : n.startsWith('image/')
    }
    return !1
  } catch (e) {
    return (typeof e == 'object' && typeof e.response < 'u') || !globalThis.hasOwnProperty('Image')
      ? !1
      : new Promise(n => {
          const r = new Image()
          ;(r.onload = () => {
            n(!0)
          }),
            (r.onerror = () => {
              n(!1)
            }),
            (r.src = t)
        })
  }
}
function qC(t, e) {
  return t ? (t.endsWith('/') ? t.slice(0, -1) : t) : e
}
function S3({ uri: t, gatewayUrls: e }) {
  const n = J9.test(t)
  if (n) return { uri: t, isOnChain: !0, isEncoded: n }
  const r = qC(e == null ? void 0 : e.ipfs, 'https://ipfs.io'),
    s = qC(e == null ? void 0 : e.arweave, 'https://arweave.net'),
    i = t.match(Z9),
    {
      protocol: o,
      subpath: a,
      target: c,
      subtarget: u = ''
    } = (i == null ? void 0 : i.groups) || {},
    l = o === 'ipns:/' || a === 'ipns/',
    d = o === 'ipfs:/' || a === 'ipfs/' || Y9.test(t)
  if (t.startsWith('http') && !l && !d) {
    let p = t
    return (
      e != null &&
        e.arweave &&
        (p = t.replace(/https:\/\/arweave.net/g, e == null ? void 0 : e.arweave)),
      { uri: p, isOnChain: !1, isEncoded: !1 }
    )
  }
  if ((l || d) && c)
    return { uri: `${r}/${l ? 'ipns' : 'ipfs'}/${c}${u}`, isOnChain: !1, isEncoded: !1 }
  if (o === 'ar:/' && c) return { uri: `${s}/${c}${u || ''}`, isOnChain: !1, isEncoded: !1 }
  let h = t.replace(X9, '')
  if (
    (h.startsWith('<svg') && (h = `data:image/svg+xml;base64,${btoa(h)}`),
    h.startsWith('data:') || h.startsWith('{'))
  )
    return { uri: h, isOnChain: !0, isEncoded: !1 }
  throw new aA({ uri: t })
}
function I3(t) {
  if (typeof t != 'object' || (!('image' in t) && !('image_url' in t) && !('image_data' in t)))
    throw new G9({ data: t })
  return t.image || t.image_url || t.image_data
}
async function t7({ gatewayUrls: t, uri: e }) {
  try {
    const n = await fetch(e).then(s => s.json())
    return await cA({ gatewayUrls: t, uri: I3(n) })
  } catch {
    throw new aA({ uri: e })
  }
}
async function cA({ gatewayUrls: t, uri: e }) {
  const { uri: n, isOnChain: r } = S3({ uri: e, gatewayUrls: t })
  if (r || (await e7(n))) return n
  throw new aA({ uri: e })
}
function n7(t) {
  let e = t
  e.startsWith('did:nft:') && (e = e.replace('did:nft:', '').replace(/_/g, '/'))
  const [n, r, s] = e.split('/'),
    [i, o] = n.split(':'),
    [a, c] = r.split(':')
  if (!i || i.toLowerCase() !== 'eip155') throw new Hd({ reason: 'Only EIP-155 supported' })
  if (!o) throw new Hd({ reason: 'Chain ID not found' })
  if (!c) throw new Hd({ reason: 'Contract address not found' })
  if (!s) throw new Hd({ reason: 'Token ID not found' })
  if (!a) throw new Hd({ reason: 'ERC namespace not found' })
  return { chainID: Number.parseInt(o), namespace: a.toLowerCase(), contractAddress: c, tokenID: s }
}
async function r7(t, { nft: e }) {
  if (e.namespace === 'erc721')
    return cu(t, {
      address: e.contractAddress,
      abi: [
        {
          name: 'tokenURI',
          type: 'function',
          stateMutability: 'view',
          inputs: [{ name: 'tokenId', type: 'uint256' }],
          outputs: [{ name: '', type: 'string' }]
        }
      ],
      functionName: 'tokenURI',
      args: [BigInt(e.tokenID)]
    })
  if (e.namespace === 'erc1155')
    return cu(t, {
      address: e.contractAddress,
      abi: [
        {
          name: 'uri',
          type: 'function',
          stateMutability: 'view',
          inputs: [{ name: '_id', type: 'uint256' }],
          outputs: [{ name: '', type: 'string' }]
        }
      ],
      functionName: 'uri',
      args: [BigInt(e.tokenID)]
    })
  throw new Q9({ namespace: e.namespace })
}
async function s7(t, { gatewayUrls: e, record: n }) {
  return /eip155:/i.test(n) ? i7(t, { gatewayUrls: e, record: n }) : cA({ uri: n, gatewayUrls: e })
}
async function i7(t, { gatewayUrls: e, record: n }) {
  const r = n7(n),
    s = await r7(t, { nft: r }),
    { uri: i, isOnChain: o, isEncoded: a } = S3({ uri: s, gatewayUrls: e })
  if (o && (i.includes('data:application/json;base64,') || i.startsWith('{'))) {
    const u = a ? atob(i.replace('data:application/json;base64,', '')) : i,
      l = JSON.parse(u)
    return cA({ uri: I3(l), gatewayUrls: e })
  }
  let c = r.tokenID
  return (
    r.namespace === 'erc1155' && (c = c.replace('0x', '').padStart(64, '0')),
    t7({ gatewayUrls: e, uri: i.replace(/(?:0x)?{id}/, c) })
  )
}
async function o7(
  t,
  {
    blockNumber: e,
    blockTag: n,
    name: r,
    key: s,
    gatewayUrls: i,
    strict: o,
    universalResolverAddress: a
  }
) {
  let c = a
  if (!c) {
    if (!t.chain)
      throw new Error('client chain not configured. universalResolverAddress is required.')
    c = ip({ blockNumber: e, chain: t.chain, contract: 'ensUniversalResolver' })
  }
  try {
    const u = {
        address: c,
        abi: n3,
        functionName: 'resolve',
        args: [wt(oA(r)), Ad({ abi: LC, functionName: 'text', args: [Tg(r), s] })],
        blockNumber: e,
        blockTag: n
      },
      l = cn(t, cu, 'readContract'),
      d = i ? await l({ ...u, args: [...u.args, i] }) : await l(u)
    if (d[0] === '0x') return null
    const h = sp({ abi: LC, functionName: 'text', data: d[0] })
    return h === '' ? null : h
  } catch (u) {
    if (o) throw u
    if (iA(u, 'resolve')) return null
    throw u
  }
}
async function a7(
  t,
  {
    blockNumber: e,
    blockTag: n,
    assetGatewayUrls: r,
    name: s,
    gatewayUrls: i,
    strict: o,
    universalResolverAddress: a
  }
) {
  const c = await cn(
    t,
    o7,
    'getEnsText'
  )({
    blockNumber: e,
    blockTag: n,
    key: 'avatar',
    name: s,
    universalResolverAddress: a,
    gatewayUrls: i,
    strict: o
  })
  if (!c) return null
  try {
    return await s7(t, { record: c, gatewayUrls: r })
  } catch {
    return null
  }
}
async function c7(
  t,
  {
    address: e,
    blockNumber: n,
    blockTag: r,
    gatewayUrls: s,
    strict: i,
    universalResolverAddress: o
  }
) {
  let a = o
  if (!a) {
    if (!t.chain)
      throw new Error('client chain not configured. universalResolverAddress is required.')
    a = ip({ blockNumber: n, chain: t.chain, contract: 'ensUniversalResolver' })
  }
  const c = `${e.toLowerCase().substring(2)}.addr.reverse`
  try {
    const u = {
        address: a,
        abi: SF,
        functionName: 'reverse',
        args: [wt(oA(c))],
        blockNumber: n,
        blockTag: r
      },
      l = cn(t, cu, 'readContract'),
      [d, h] = s ? await l({ ...u, args: [...u.args, s] }) : await l(u)
    return e.toLowerCase() !== h.toLowerCase() ? null : d
  } catch (u) {
    if (i) throw u
    if (iA(u, 'reverse')) return null
    throw u
  }
}
function u7(t, { method: e }) {
  var r, s
  const n = {}
  return (
    t.transport.type === 'fallback' &&
      ((s = (r = t.transport).onResponse) == null ||
        s.call(r, ({ method: i, response: o, status: a, transport: c }) => {
          a === 'success' && e === i && (n[o] = c.request)
        })),
    i => n[i] || t.request
  )
}
async function l7(t) {
  const e = u7(t, { method: 'eth_newPendingTransactionFilter' }),
    n = await t.request({ method: 'eth_newPendingTransactionFilter' })
  return { id: n, request: e(n), type: 'transaction' }
}
const d7 = new Map(),
  h7 = new Map()
function f7(t) {
  const e = (s, i) => ({ clear: () => i.delete(s), get: () => i.get(s), set: o => i.set(s, o) }),
    n = e(t, d7),
    r = e(t, h7)
  return {
    clear: () => {
      n.clear(), r.clear()
    },
    promise: n,
    response: r
  }
}
async function p7(t, { cacheKey: e, cacheTime: n = Number.POSITIVE_INFINITY }) {
  const r = f7(e),
    s = r.response.get()
  if (s && n > 0 && new Date().getTime() - s.created.getTime() < n) return s.data
  let i = r.promise.get()
  i || ((i = t()), r.promise.set(i))
  try {
    const o = await i
    return r.response.set({ created: new Date(), data: o }), o
  } finally {
    r.promise.clear()
  }
}
const g7 = t => `blockNumber.${t}`
async function m7(t, { cacheTime: e = t.cacheTime } = {}) {
  const n = await p7(() => t.request({ method: 'eth_blockNumber' }), {
    cacheKey: g7(t.uid),
    cacheTime: e
  })
  return BigInt(n)
}
function y7(t, e) {
  if (!Rr(t, { strict: !1 })) throw new Cs({ address: t })
  if (!Rr(e, { strict: !1 })) throw new Cs({ address: e })
  return t.toLowerCase() === e.toLowerCase()
}
const zC = '/docs/contract/decodeEventLog'
function w7(t) {
  const { abi: e, data: n, strict: r, topics: s } = t,
    i = r ?? !0,
    [o, ...a] = s
  if (!o) throw new RL({ docsPath: zC })
  const c = e.length === 1 ? e[0] : e.find(m => m.type === 'event' && o === tA(Ja(m)))
  if (!(c && 'name' in c) || c.type !== 'event') throw new dR(o, { docsPath: zC })
  const { name: u, inputs: l } = c,
    d = l == null ? void 0 : l.some(m => !('name' in m && m.name))
  let h = d ? [] : {}
  const p = l.filter(m => 'indexed' in m && m.indexed)
  for (let m = 0; m < p.length; m++) {
    const b = p[m],
      I = a[m]
    if (!I) throw new hR({ abiItem: c, param: b })
    h[d ? m : b.name || m] = b7({ param: b, value: I })
  }
  const y = l.filter(m => !('indexed' in m && m.indexed))
  if (y.length > 0) {
    if (n && n !== '0x')
      try {
        const m = v0(y, n)
        if (m)
          if (d) h = [...h, ...m]
          else for (let b = 0; b < y.length; b++) h[y[b].name] = m[b]
      } catch (m) {
        if (i)
          throw m instanceof uR || m instanceof PR
            ? new b1({ abiItem: c, data: n, params: y, size: ir(n) })
            : m
      }
    else if (i) throw new b1({ abiItem: c, data: '0x', params: y, size: 0 })
  }
  return { eventName: u, args: Object.values(h).length > 0 ? h : void 0 }
}
function b7({ param: t, value: e }) {
  return t.type === 'string' ||
    t.type === 'bytes' ||
    t.type === 'tuple' ||
    t.type.match(/^(.*)\[(\d+)?\]$/)
    ? e
    : (v0([t], e) || [])[0]
}
function v7(t) {
  const { abi: e, args: n, logs: r, strict: s = !0 } = t,
    i = (() => {
      if (t.eventName) return Array.isArray(t.eventName) ? t.eventName : [t.eventName]
    })()
  return r
    .map(o => {
      var a
      try {
        const c = e.find(l => l.type === 'event' && o.topics[0] === tA(l))
        if (!c) return null
        const u = w7({ ...o, abi: [c], strict: s })
        return (i && !i.includes(u.eventName)) ||
          !E7({ args: u.args, inputs: c.inputs, matchArgs: n })
          ? null
          : { ...u, ...o }
      } catch (c) {
        let u, l
        if (c instanceof dR) return null
        if (c instanceof b1 || c instanceof hR) {
          if (s) return null
          ;(u = c.abiItem.name),
            (l = (a = c.abiItem.inputs) == null ? void 0 : a.some(d => !('name' in d && d.name)))
        }
        return { ...o, args: l ? [] : {}, eventName: u }
      }
    })
    .filter(Boolean)
}
function E7(t) {
  const { args: e, inputs: n, matchArgs: r } = t
  if (!r) return !0
  if (!e) return !1
  function s(i, o, a) {
    try {
      return i.type === 'address'
        ? y7(o, a)
        : i.type === 'string' || i.type === 'bytes'
          ? Xa(np(o)) === a
          : o === a
    } catch {
      return !1
    }
  }
  return Array.isArray(e) && Array.isArray(r)
    ? r.every((i, o) => {
        if (i == null) return !0
        const a = n[o]
        return a ? (Array.isArray(i) ? i : [i]).some(u => s(a, u, e[o])) : !1
      })
    : typeof e == 'object' && !Array.isArray(e) && typeof r == 'object' && !Array.isArray(r)
      ? Object.entries(r).every(([i, o]) => {
          if (o == null) return !0
          const a = n.find(u => u.name === i)
          return a ? (Array.isArray(o) ? o : [o]).some(u => s(a, u, e[i])) : !1
        })
      : !1
}
function x3(t, { args: e, eventName: n } = {}) {
  return {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    logIndex: t.logIndex ? Number(t.logIndex) : null,
    transactionHash: t.transactionHash ? t.transactionHash : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    ...(n ? { args: e, eventName: n } : {})
  }
}
async function A7(t, { filter: e }) {
  const n = 'strict' in e && e.strict,
    r = await e.request({ method: 'eth_getFilterChanges', params: [e.id] })
  if (typeof r[0] == 'string') return r
  const s = r.map(i => x3(i))
  return !('abi' in e) || !e.abi ? s : v7({ abi: e.abi, logs: s, strict: n })
}
async function T3(t, { blockHash: e, blockNumber: n, blockTag: r, hash: s, index: i }) {
  var l, d, h
  const o = r || 'latest',
    a = n !== void 0 ? Mt(n) : void 0
  let c = null
  if (
    (s
      ? (c = await t.request({ method: 'eth_getTransactionByHash', params: [s] }, { dedupe: !0 }))
      : e
        ? (c = await t.request(
            { method: 'eth_getTransactionByBlockHashAndIndex', params: [e, Mt(i)] },
            { dedupe: !0 }
          ))
        : (c = await t.request(
            { method: 'eth_getTransactionByBlockNumberAndIndex', params: [a || o, Mt(i)] },
            { dedupe: !!a }
          )),
    !c)
  )
    throw new DR({ blockHash: e, blockNumber: n, blockTag: o, hash: s, index: i })
  return (
    ((h = (d = (l = t.chain) == null ? void 0 : l.formatters) == null ? void 0 : d.transaction) ==
    null
      ? void 0
      : h.format) || b0
  )(c)
}
const _7 = { '0x0': 'reverted', '0x1': 'success' }
function N3(t) {
  const e = {
    ...t,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    contractAddress: t.contractAddress ? t.contractAddress : null,
    cumulativeGasUsed: t.cumulativeGasUsed ? BigInt(t.cumulativeGasUsed) : null,
    effectiveGasPrice: t.effectiveGasPrice ? BigInt(t.effectiveGasPrice) : null,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : null,
    logs: t.logs ? t.logs.map(n => x3(n)) : null,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? Ya(t.transactionIndex) : null,
    status: t.status ? _7[t.status] : null,
    type: t.type ? $R[t.type] || t.type : null
  }
  return (
    t.blobGasPrice && (e.blobGasPrice = BigInt(t.blobGasPrice)),
    t.blobGasUsed && (e.blobGasUsed = BigInt(t.blobGasUsed)),
    e
  )
}
const C7 = GE('transactionReceipt', N3)
async function WC(t, { hash: e }) {
  var s, i, o
  const n = await t.request({ method: 'eth_getTransactionReceipt', params: [e] }, { dedupe: !0 })
  if (!n) throw new MR({ hash: e })
  return (
    ((o =
      (i = (s = t.chain) == null ? void 0 : s.formatters) == null
        ? void 0
        : i.transactionReceipt) == null
      ? void 0
      : o.format) || N3
  )(n)
}
async function S7(t, e) {
  var b
  const {
      allowFailure: n = !0,
      batchSize: r,
      blockNumber: s,
      blockTag: i,
      multicallAddress: o,
      stateOverride: a
    } = e,
    c = e.contracts,
    u =
      r ??
      ((typeof ((b = t.batch) == null ? void 0 : b.multicall) == 'object' &&
        t.batch.multicall.batchSize) ||
        1024)
  let l = o
  if (!l) {
    if (!t.chain) throw new Error('client chain not configured. multicallAddress is required.')
    l = ip({ blockNumber: s, chain: t.chain, contract: 'multicall3' })
  }
  const d = [[]]
  let h = 0,
    p = 0
  for (let I = 0; I < c.length; I++) {
    const { abi: x, address: _, args: R, functionName: N } = c[I]
    try {
      const T = Ad({ abi: x, args: R, functionName: N })
      ;(p += (T.length - 2) / 2),
        u > 0 && p > u && d[h].length > 0 && (h++, (p = (T.length - 2) / 2), (d[h] = [])),
        (d[h] = [...d[h], { allowFailure: !0, callData: T, target: _ }])
    } catch (T) {
      const M = um(T, {
        abi: x,
        address: _,
        args: R,
        docsPath: '/docs/contract/multicall',
        functionName: N
      })
      if (!n) throw M
      d[h] = [...d[h], { allowFailure: !0, callData: '0x', target: _ }]
    }
  }
  const y = await Promise.allSettled(
      d.map(I =>
        cn(
          t,
          cu,
          'readContract'
        )({
          abi: P1,
          address: l,
          args: [I],
          blockNumber: s,
          blockTag: i,
          functionName: 'aggregate3',
          stateOverride: a
        })
      )
    ),
    m = []
  for (let I = 0; I < y.length; I++) {
    const x = y[I]
    if (x.status === 'rejected') {
      if (!n) throw x.reason
      for (let R = 0; R < d[I].length; R++)
        m.push({ status: 'failure', error: x.reason, result: void 0 })
      continue
    }
    const _ = x.value
    for (let R = 0; R < _.length; R++) {
      const { returnData: N, success: T } = _[R],
        { callData: M } = d[I][R],
        { abi: H, address: B, functionName: $, args: D } = c[m.length]
      try {
        if (M === '0x') throw new d0()
        if (!T) throw new sA({ data: N })
        const W = sp({ abi: H, args: D, data: N, functionName: $ })
        m.push(n ? { result: W, status: 'success' } : W)
      } catch (W) {
        const U = um(W, {
          abi: H,
          address: B,
          args: D,
          docsPath: '/docs/contract/multicall',
          functionName: $
        })
        if (!n) throw U
        m.push({ error: U, result: void 0, status: 'failure' })
      }
    }
  }
  if (m.length !== c.length) throw new Se('multicall results mismatch')
  return m
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const E0 = BigInt(0),
  A0 = BigInt(1),
  I7 = BigInt(2)
function uu(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function op(t) {
  if (!uu(t)) throw new Error('Uint8Array expected')
}
function Ko(t, e) {
  if (typeof e != 'boolean') throw new Error(t + ' boolean expected, got ' + e)
}
const x7 = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, '0'))
function lu(t) {
  op(t)
  let e = ''
  for (let n = 0; n < t.length; n++) e += x7[t[n]]
  return e
}
function pl(t) {
  const e = t.toString(16)
  return e.length & 1 ? '0' + e : e
}
function uA(t) {
  if (typeof t != 'string') throw new Error('hex string expected, got ' + typeof t)
  return t === '' ? E0 : BigInt('0x' + t)
}
const Eo = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }
function KC(t) {
  if (t >= Eo._0 && t <= Eo._9) return t - Eo._0
  if (t >= Eo.A && t <= Eo.F) return t - (Eo.A - 10)
  if (t >= Eo.a && t <= Eo.f) return t - (Eo.a - 10)
}
function Jl(t) {
  if (typeof t != 'string') throw new Error('hex string expected, got ' + typeof t)
  const e = t.length,
    n = e / 2
  if (e % 2) throw new Error('hex string expected, got unpadded hex of length ' + e)
  const r = new Uint8Array(n)
  for (let s = 0, i = 0; s < n; s++, i += 2) {
    const o = KC(t.charCodeAt(i)),
      a = KC(t.charCodeAt(i + 1))
    if (o === void 0 || a === void 0) {
      const c = t[i] + t[i + 1]
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + i)
    }
    r[s] = o * 16 + a
  }
  return r
}
function Jc(t) {
  return uA(lu(t))
}
function Pl(t) {
  return op(t), uA(lu(Uint8Array.from(t).reverse()))
}
function Xl(t, e) {
  return Jl(t.toString(16).padStart(e * 2, '0'))
}
function ff(t, e) {
  return Xl(t, e).reverse()
}
function T7(t) {
  return Jl(pl(t))
}
function Zn(t, e, n) {
  let r
  if (typeof e == 'string')
    try {
      r = Jl(e)
    } catch (i) {
      throw new Error(t + ' must be hex string or Uint8Array, cause: ' + i)
    }
  else if (uu(e)) r = Uint8Array.from(e)
  else throw new Error(t + ' must be hex string or Uint8Array')
  const s = r.length
  if (typeof n == 'number' && s !== n)
    throw new Error(t + ' of length ' + n + ' expected, got ' + s)
  return r
}
function du(...t) {
  let e = 0
  for (let r = 0; r < t.length; r++) {
    const s = t[r]
    op(s), (e += s.length)
  }
  const n = new Uint8Array(e)
  for (let r = 0, s = 0; r < t.length; r++) {
    const i = t[r]
    n.set(i, s), (s += i.length)
  }
  return n
}
function N7(t, e) {
  if (t.length !== e.length) return !1
  let n = 0
  for (let r = 0; r < t.length; r++) n |= t[r] ^ e[r]
  return n === 0
}
function P7(t) {
  if (typeof t != 'string') throw new Error('string expected')
  return new Uint8Array(new TextEncoder().encode(t))
}
const aw = t => typeof t == 'bigint' && E0 <= t
function _0(t, e, n) {
  return aw(t) && aw(e) && aw(n) && e <= t && t < n
}
function si(t, e, n, r) {
  if (!_0(e, n, r))
    throw new Error('expected valid ' + t + ': ' + n + ' <= n < ' + r + ', got ' + e)
}
function P3(t) {
  let e
  for (e = 0; t > E0; t >>= A0, e += 1);
  return e
}
function R7(t, e) {
  return (t >> BigInt(e)) & A0
}
function k7(t, e, n) {
  return t | ((n ? A0 : E0) << BigInt(e))
}
const lA = t => (I7 << BigInt(t - 1)) - A0,
  cw = t => new Uint8Array(t),
  VC = t => Uint8Array.from(t)
function R3(t, e, n) {
  if (typeof t != 'number' || t < 2) throw new Error('hashLen must be a number')
  if (typeof e != 'number' || e < 2) throw new Error('qByteLen must be a number')
  if (typeof n != 'function') throw new Error('hmacFn must be a function')
  let r = cw(t),
    s = cw(t),
    i = 0
  const o = () => {
      r.fill(1), s.fill(0), (i = 0)
    },
    a = (...d) => n(s, r, ...d),
    c = (d = cw()) => {
      ;(s = a(VC([0]), d)), (r = a()), d.length !== 0 && ((s = a(VC([1]), d)), (r = a()))
    },
    u = () => {
      if (i++ >= 1e3) throw new Error('drbg: tried 1000 values')
      let d = 0
      const h = []
      for (; d < e; ) {
        r = a()
        const p = r.slice()
        h.push(p), (d += r.length)
      }
      return du(...h)
    }
  return (d, h) => {
    o(), c(d)
    let p
    for (; !(p = h(u())); ) c()
    return o(), p
  }
}
const O7 = {
  bigint: t => typeof t == 'bigint',
  function: t => typeof t == 'function',
  boolean: t => typeof t == 'boolean',
  string: t => typeof t == 'string',
  stringOrUint8Array: t => typeof t == 'string' || uu(t),
  isSafeInteger: t => Number.isSafeInteger(t),
  array: t => Array.isArray(t),
  field: (t, e) => e.Fp.isValid(t),
  hash: t => typeof t == 'function' && Number.isSafeInteger(t.outputLen)
}
function _d(t, e, n = {}) {
  const r = (s, i, o) => {
    const a = O7[i]
    if (typeof a != 'function') throw new Error('invalid validator function')
    const c = t[s]
    if (!(o && c === void 0) && !a(c, t))
      throw new Error('param ' + String(s) + ' is invalid. Expected ' + i + ', got ' + c)
  }
  for (const [s, i] of Object.entries(e)) r(s, i, !1)
  for (const [s, i] of Object.entries(n)) r(s, i, !0)
  return t
}
const B7 = () => {
  throw new Error('not implemented')
}
function pf(t) {
  const e = new WeakMap()
  return (n, ...r) => {
    const s = e.get(n)
    if (s !== void 0) return s
    const i = t(n, ...r)
    return e.set(n, i), i
  }
}
const D7 = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        aInRange: si,
        abool: Ko,
        abytes: op,
        bitGet: R7,
        bitLen: P3,
        bitMask: lA,
        bitSet: k7,
        bytesToHex: lu,
        bytesToNumberBE: Jc,
        bytesToNumberLE: Pl,
        concatBytes: du,
        createHmacDrbg: R3,
        ensureBytes: Zn,
        equalBytes: N7,
        hexToBytes: Jl,
        hexToNumber: uA,
        inRange: _0,
        isBytes: uu,
        memoized: pf,
        notImplemented: B7,
        numberToBytesBE: Xl,
        numberToBytesLE: ff,
        numberToHexUnpadded: pl,
        numberToVarBytesBE: T7,
        utf8ToBytes: P7,
        validateObject: _d
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  qp = new h0(8192)
function M7(t, { enabled: e = !0, id: n }) {
  if (!e || !n) return t()
  if (qp.get(n)) return qp.get(n)
  const r = t().finally(() => qp.delete(n))
  return qp.set(n, r), r
}
async function lm(t) {
  return new Promise(e => setTimeout(e, t))
}
function dm(t, { delay: e = 100, retryCount: n = 2, shouldRetry: r = () => !0 } = {}) {
  return new Promise((s, i) => {
    const o = async ({ count: a = 0 } = {}) => {
      const c = async ({ error: u }) => {
        const l = typeof e == 'function' ? e({ count: a, error: u }) : e
        l && (await lm(l)), o({ count: a + 1 })
      }
      try {
        const u = await t()
        s(u)
      } catch (u) {
        if (a < n && (await r({ count: a, error: u }))) return c({ error: u })
        i(u)
      }
    }
    o()
  })
}
function U7(t, e = {}) {
  return async (n, r = {}) => {
    var d
    const {
        dedupe: s = !1,
        methods: i,
        retryDelay: o = 150,
        retryCount: a = 3,
        uid: c
      } = { ...e, ...r },
      { method: u } = n
    if ((d = i == null ? void 0 : i.exclude) != null && d.includes(u))
      throw new Uc(new Error('method not supported'), { method: u })
    if (i != null && i.include && !i.include.includes(u))
      throw new Uc(new Error('method not supported'), { method: u })
    const l = s ? u0(`${c}.${oi(n)}`) : void 0
    return M7(
      () =>
        dm(
          async () => {
            try {
              return await t(n)
            } catch (h) {
              const p = h
              switch (p.code) {
                case Xh.code:
                  throw new Xh(p)
                case ef.code:
                  throw new ef(p)
                case tf.code:
                  throw new tf(p, { method: n.method })
                case nf.code:
                  throw new nf(p)
                case ou.code:
                  throw new ou(p)
                case rf.code:
                  throw new rf(p)
                case sf.code:
                  throw new sf(p)
                case Ha.code:
                  throw new Ha(p)
                case Zl.code:
                  throw new Zl(p)
                case Uc.code:
                  throw new Uc(p, { method: n.method })
                case Yl.code:
                  throw new Yl(p)
                case of.code:
                  throw new of(p)
                case nr.code:
                  throw new nr(p)
                case af.code:
                  throw new af(p)
                case cf.code:
                  throw new cf(p)
                case uf.code:
                  throw new uf(p)
                case lf.code:
                  throw new lf(p)
                case ao.code:
                  throw new ao(p)
                case 5e3:
                  throw new nr(p)
                default:
                  throw h instanceof Se ? h : new Z$(p)
              }
            }
          },
          {
            delay: ({ count: h, error: p }) => {
              var y
              if (p && p instanceof Ph) {
                const m =
                  (y = p == null ? void 0 : p.headers) == null ? void 0 : y.get('Retry-After')
                if (m != null && m.match(/\d/)) return Number.parseInt(m) * 1e3
              }
              return ~~(1 << h) * o
            },
            retryCount: a,
            shouldRetry: ({ error: h }) => L7(h)
          }
        ),
      { enabled: s, id: l }
    )
  }
}
function L7(t) {
  return 'code' in t && typeof t.code == 'number'
    ? t.code === -1 || t.code === Yl.code || t.code === ou.code
    : t instanceof Ph && t.status
      ? t.status === 403 ||
        t.status === 408 ||
        t.status === 413 ||
        t.status === 429 ||
        t.status === 500 ||
        t.status === 502 ||
        t.status === 503 ||
        t.status === 504
      : !0
}
function dA(t) {
  return { formatters: void 0, fees: void 0, serializers: void 0, ...t }
}
function k3(t, { errorInstance: e = new Error('timed out'), timeout: n, signal: r }) {
  return new Promise((s, i) => {
    ;(async () => {
      let o
      try {
        const a = new AbortController()
        n > 0 &&
          (o = setTimeout(() => {
            r ? a.abort() : i(e)
          }, n)),
          s(await t({ signal: (a == null ? void 0 : a.signal) || null }))
      } catch (a) {
        ;(a == null ? void 0 : a.name) === 'AbortError' && i(e), i(a)
      } finally {
        clearTimeout(o)
      }
    })()
  })
}
function $7() {
  return {
    current: 0,
    take() {
      return this.current++
    },
    reset() {
      this.current = 0
    }
  }
}
const GC = $7()
function F7(t, e = {}) {
  return {
    async request(n) {
      var d
      const {
          body: r,
          onRequest: s = e.onRequest,
          onResponse: i = e.onResponse,
          timeout: o = e.timeout ?? 1e4
        } = n,
        a = { ...(e.fetchOptions ?? {}), ...(n.fetchOptions ?? {}) },
        { headers: c, method: u, signal: l } = a
      try {
        const h = await k3(
          async ({ signal: y }) => {
            const m = {
                ...a,
                body: Array.isArray(r)
                  ? oi(r.map(_ => ({ jsonrpc: '2.0', id: _.id ?? GC.take(), ..._ })))
                  : oi({ jsonrpc: '2.0', id: r.id ?? GC.take(), ...r }),
                headers: { 'Content-Type': 'application/json', ...c },
                method: u || 'POST',
                signal: l || (o > 0 ? y : null)
              },
              b = new Request(t, m),
              I = (await (s == null ? void 0 : s(b, m))) ?? { ...m, url: t }
            return await fetch(I.url ?? t, I)
          },
          { errorInstance: new RC({ body: r, url: t }), timeout: o, signal: !0 }
        )
        i && (await i(h))
        let p
        if ((d = h.headers.get('Content-Type')) != null && d.startsWith('application/json'))
          p = await h.json()
        else {
          p = await h.text()
          try {
            p = JSON.parse(p || '{}')
          } catch (y) {
            if (h.ok) throw y
            p = { error: p }
          }
        }
        if (!h.ok)
          throw new Ph({
            body: r,
            details: oi(p.error) || h.statusText,
            headers: h.headers,
            status: h.status,
            url: t
          })
        return p
      } catch (h) {
        throw h instanceof Ph || h instanceof RC ? h : new Ph({ body: r, cause: h, url: t })
      }
    }
  }
}
function j7(t) {
  const { authorizationList: e } = t
  if (e)
    for (const n of e) {
      const { contractAddress: r, chainId: s } = n
      if (!Rr(r)) throw new Cs({ address: r })
      if (s < 0) throw new g0({ chainId: s })
    }
  hA(t)
}
function H7(t) {
  const { blobVersionedHashes: e } = t
  if (e) {
    if (e.length === 0) throw new ZR()
    for (const n of e) {
      const r = ir(n),
        s = Ya(Yh(n, 0, 1))
      if (r !== 32) throw new EF({ hash: n, size: r })
      if (s !== QR) throw new AF({ hash: n, version: s })
    }
  }
  hA(t)
}
function hA(t) {
  const { chainId: e, maxPriorityFeePerGas: n, maxFeePerGas: r, to: s } = t
  if (e <= 0) throw new g0({ chainId: e })
  if (s && !Rr(s)) throw new Cs({ address: s })
  if (r && r > y0) throw new iu({ maxFeePerGas: r })
  if (n && r && n > r) throw new Jh({ maxFeePerGas: r, maxPriorityFeePerGas: n })
}
function q7(t) {
  const { chainId: e, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: s, to: i } = t
  if (e <= 0) throw new g0({ chainId: e })
  if (i && !Rr(i)) throw new Cs({ address: i })
  if (n || s)
    throw new Se(
      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.'
    )
  if (r && r > y0) throw new iu({ maxFeePerGas: r })
}
function z7(t) {
  const { chainId: e, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: s, to: i } = t
  if (i && !Rr(i)) throw new Cs({ address: i })
  if (typeof e < 'u' && e <= 0) throw new g0({ chainId: e })
  if (n || s)
    throw new Se(
      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.'
    )
  if (r && r > y0) throw new iu({ maxFeePerGas: r })
}
function W7(t) {
  if (!t || t.length === 0) return []
  const e = []
  for (const n of t) {
    const { contractAddress: r, chainId: s, nonce: i, ...o } = n
    e.push([s ? wt(s) : '0x', r, i ? wt(i) : '0x', ...ap({}, o)])
  }
  return e
}
function C0(t) {
  if (!t || t.length === 0) return []
  const e = []
  for (let n = 0; n < t.length; n++) {
    const { address: r, storageKeys: s } = t[n]
    for (let i = 0; i < s.length; i++)
      if (s[i].length - 2 !== 64) throw new W$({ storageKey: s[i] })
    if (!Rr(r, { strict: !1 })) throw new Cs({ address: r })
    e.push([r, s])
  }
  return e
}
function K7(t, e) {
  const n = JR(t)
  return n === 'eip1559'
    ? Q7(t, e)
    : n === 'eip2930'
      ? Z7(t, e)
      : n === 'eip4844'
        ? G7(t, e)
        : n === 'eip7702'
          ? V7(t, e)
          : Y7(t, e)
}
function V7(t, e) {
  const {
    authorizationList: n,
    chainId: r,
    gas: s,
    nonce: i,
    to: o,
    value: a,
    maxFeePerGas: c,
    maxPriorityFeePerGas: u,
    accessList: l,
    data: d
  } = t
  j7(t)
  const h = C0(l),
    p = W7(n)
  return na([
    '0x04',
    ec([
      wt(r),
      i ? wt(i) : '0x',
      u ? wt(u) : '0x',
      c ? wt(c) : '0x',
      s ? wt(s) : '0x',
      o ?? '0x',
      a ? wt(a) : '0x',
      d ?? '0x',
      h,
      p,
      ...ap(t, e)
    ])
  ])
}
function G7(t, e) {
  const {
    chainId: n,
    gas: r,
    nonce: s,
    to: i,
    value: o,
    maxFeePerBlobGas: a,
    maxFeePerGas: c,
    maxPriorityFeePerGas: u,
    accessList: l,
    data: d
  } = t
  H7(t)
  let h = t.blobVersionedHashes,
    p = t.sidecars
  if (t.blobs && (typeof h > 'u' || typeof p > 'u')) {
    const _ = typeof t.blobs[0] == 'string' ? t.blobs : t.blobs.map(T => br(T)),
      R = t.kzg,
      N = YE({ blobs: _, kzg: R })
    if ((typeof h > 'u' && (h = KR({ commitments: N })), typeof p > 'u')) {
      const T = JE({ blobs: _, commitments: N, kzg: R })
      p = YR({ blobs: _, commitments: N, proofs: T })
    }
  }
  const y = C0(l),
    m = [
      wt(n),
      s ? wt(s) : '0x',
      u ? wt(u) : '0x',
      c ? wt(c) : '0x',
      r ? wt(r) : '0x',
      i ?? '0x',
      o ? wt(o) : '0x',
      d ?? '0x',
      y,
      a ? wt(a) : '0x',
      h ?? [],
      ...ap(t, e)
    ],
    b = [],
    I = [],
    x = []
  if (p)
    for (let _ = 0; _ < p.length; _++) {
      const { blob: R, commitment: N, proof: T } = p[_]
      b.push(R), I.push(N), x.push(T)
    }
  return na(['0x03', ec(p ? [m, b, I, x] : m)])
}
function Q7(t, e) {
  const {
    chainId: n,
    gas: r,
    nonce: s,
    to: i,
    value: o,
    maxFeePerGas: a,
    maxPriorityFeePerGas: c,
    accessList: u,
    data: l
  } = t
  hA(t)
  const d = C0(u),
    h = [
      wt(n),
      s ? wt(s) : '0x',
      c ? wt(c) : '0x',
      a ? wt(a) : '0x',
      r ? wt(r) : '0x',
      i ?? '0x',
      o ? wt(o) : '0x',
      l ?? '0x',
      d,
      ...ap(t, e)
    ]
  return na(['0x02', ec(h)])
}
function Z7(t, e) {
  const { chainId: n, gas: r, data: s, nonce: i, to: o, value: a, accessList: c, gasPrice: u } = t
  q7(t)
  const l = C0(c),
    d = [
      wt(n),
      i ? wt(i) : '0x',
      u ? wt(u) : '0x',
      r ? wt(r) : '0x',
      o ?? '0x',
      a ? wt(a) : '0x',
      s ?? '0x',
      l,
      ...ap(t, e)
    ]
  return na(['0x01', ec(d)])
}
function Y7(t, e) {
  const { chainId: n = 0, gas: r, data: s, nonce: i, to: o, value: a, gasPrice: c } = t
  z7(t)
  let u = [
    i ? wt(i) : '0x',
    c ? wt(c) : '0x',
    r ? wt(r) : '0x',
    o ?? '0x',
    a ? wt(a) : '0x',
    s ?? '0x'
  ]
  if (e) {
    const l = (() => {
        if (e.v >= 35n) return (e.v - 35n) / 2n > 0 ? e.v : 27n + (e.v === 35n ? 0n : 1n)
        if (n > 0) return BigInt(n * 2) + BigInt(35n + e.v - 27n)
        const p = 27n + (e.v === 27n ? 0n : 1n)
        if (e.v !== p) throw new q$({ v: e.v })
        return p
      })(),
      d = io(e.r),
      h = io(e.s)
    u = [...u, wt(l), d === '0x00' ? '0x' : d, h === '0x00' ? '0x' : h]
  } else n > 0 && (u = [...u, wt(n), '0x', '0x'])
  return ec(u)
}
function ap(t, e) {
  const n = e ?? t,
    { v: r, yParity: s } = n
  if (typeof n.r > 'u') return []
  if (typeof n.s > 'u') return []
  if (typeof r > 'u' && typeof s > 'u') return []
  const i = io(n.r),
    o = io(n.s)
  return [
    typeof s == 'number'
      ? s
        ? wt(1)
        : '0x'
      : r === 0n
        ? '0x'
        : r === 1n
          ? wt(1)
          : r === 27n
            ? '0x'
            : wt(1),
    i === '0x00' ? '0x' : i,
    o === '0x00' ? '0x' : o
  ]
}
class J7 extends Se {
  constructor({ value: e }) {
    super(`Number \`${e}\` is not a valid decimal number.`, { name: 'InvalidDecimalNumberError' })
  }
}
function X7(t, e) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(t)) throw new J7({ value: t })
  let [n, r = '0'] = t.split('.')
  const s = n.startsWith('-')
  if ((s && (n = n.slice(1)), (r = r.replace(/(0+)$/, '')), e === 0))
    Math.round(+`.${r}`) === 1 && (n = `${BigInt(n) + 1n}`), (r = '')
  else if (r.length > e) {
    const [i, o, a] = [r.slice(0, e - 1), r.slice(e - 1, e), r.slice(e)],
      c = Math.round(+`${o}.${a}`)
    c > 9 ? (r = `${BigInt(i) + BigInt(1)}0`.padStart(i.length + 1, '0')) : (r = `${i}${c}`),
      r.length > e && ((r = r.slice(1)), (n = `${BigInt(n) + 1n}`)),
      (r = r.slice(0, e))
  } else r = r.padEnd(e, '0')
  return BigInt(`${s ? '-' : ''}${n}${r}`)
}
const uw = new Map(),
  QC = new Map()
let ej = 0
function hm(t, e, n) {
  const r = ++ej,
    s = () => uw.get(t) || [],
    i = () => {
      const l = s()
      uw.set(
        t,
        l.filter(d => d.id !== r)
      )
    },
    o = () => {
      const l = s()
      if (!l.some(h => h.id === r)) return
      const d = QC.get(t)
      l.length === 1 && d && d(), i()
    },
    a = s()
  if ((uw.set(t, [...a, { id: r, fns: e }]), a && a.length > 0)) return o
  const c = {}
  for (const l in e)
    c[l] = (...d) => {
      var p, y
      const h = s()
      if (h.length !== 0) for (const m of h) (y = (p = m.fns)[l]) == null || y.call(p, ...d)
    }
  const u = n(c)
  return typeof u == 'function' && QC.set(t, u), o
}
function O3(t, { emitOnBegin: e, initialWaitTime: n, interval: r }) {
  let s = !0
  const i = () => (s = !1)
  return (
    (async () => {
      let a
      e && (a = await t({ unpoll: i }))
      const c = (await (n == null ? void 0 : n(a))) ?? r
      await lm(c)
      const u = async () => {
        s && (await t({ unpoll: i }), await lm(r), u())
      }
      u()
    })(),
    i
  )
}
function tj(
  t,
  {
    emitOnBegin: e = !1,
    emitMissed: n = !1,
    onBlockNumber: r,
    onError: s,
    poll: i,
    pollingInterval: o = t.pollingInterval
  }
) {
  const a =
    typeof i < 'u'
      ? i
      : !(
          t.transport.type === 'webSocket' ||
          (t.transport.type === 'fallback' && t.transport.transports[0].config.type === 'webSocket')
        )
  let c
  return a
    ? (() => {
        const d = oi(['watchBlockNumber', t.uid, e, n, o])
        return hm(d, { onBlockNumber: r, onError: s }, h =>
          O3(
            async () => {
              var p
              try {
                const y = await cn(t, m7, 'getBlockNumber')({ cacheTime: 0 })
                if (c) {
                  if (y === c) return
                  if (y - c > 1 && n)
                    for (let m = c + 1n; m < y; m++) h.onBlockNumber(m, c), (c = m)
                }
                ;(!c || y > c) && (h.onBlockNumber(y, c), (c = y))
              } catch (y) {
                ;(p = h.onError) == null || p.call(h, y)
              }
            },
            { emitOnBegin: e, interval: o }
          )
        )
      })()
    : (() => {
        const d = oi(['watchBlockNumber', t.uid, e, n])
        return hm(d, { onBlockNumber: r, onError: s }, h => {
          let p = !0,
            y = () => (p = !1)
          return (
            (async () => {
              try {
                const m = (() => {
                    if (t.transport.type === 'fallback') {
                      const I = t.transport.transports.find(x => x.config.type === 'webSocket')
                      return I ? I.value : t.transport
                    }
                    return t.transport
                  })(),
                  { unsubscribe: b } = await m.subscribe({
                    params: ['newHeads'],
                    onData(I) {
                      var _
                      if (!p) return
                      const x = Ci((_ = I.result) == null ? void 0 : _.number)
                      h.onBlockNumber(x, c), (c = x)
                    },
                    onError(I) {
                      var x
                      ;(x = h.onError) == null || x.call(h, I)
                    }
                  })
                ;(y = b), p || y()
              } catch (m) {
                s == null || s(m)
              }
            })(),
            () => y()
          )
        })
      })()
}
async function nj(t, { filter: e }) {
  return e.request({ method: 'eth_uninstallFilter', params: [e.id] })
}
function rj(
  t,
  { batch: e = !0, onError: n, onTransactions: r, poll: s, pollingInterval: i = t.pollingInterval }
) {
  return (typeof s < 'u' ? s : t.transport.type !== 'webSocket')
    ? (() => {
        const u = oi(['watchPendingTransactions', t.uid, e, i])
        return hm(u, { onTransactions: r, onError: n }, l => {
          let d
          const h = O3(
            async () => {
              var p
              try {
                if (!d)
                  try {
                    d = await cn(t, l7, 'createPendingTransactionFilter')({})
                    return
                  } catch (m) {
                    throw (h(), m)
                  }
                const y = await cn(t, A7, 'getFilterChanges')({ filter: d })
                if (y.length === 0) return
                if (e) l.onTransactions(y)
                else for (const m of y) l.onTransactions([m])
              } catch (y) {
                ;(p = l.onError) == null || p.call(l, y)
              }
            },
            { emitOnBegin: !0, interval: i }
          )
          return async () => {
            d && (await cn(t, nj, 'uninstallFilter')({ filter: d })), h()
          }
        })
      })()
    : (() => {
        let u = !0,
          l = () => (u = !1)
        return (
          (async () => {
            try {
              const { unsubscribe: d } = await t.transport.subscribe({
                params: ['newPendingTransactions'],
                onData(h) {
                  if (!u) return
                  const p = h.result
                  r([p])
                },
                onError(h) {
                  n == null || n(h)
                }
              })
              ;(l = d), u || l()
            } catch (d) {
              n == null || n(d)
            }
          })(),
          () => l()
        )
      })()
}
async function sj(
  t,
  {
    confirmations: e = 1,
    hash: n,
    onReplaced: r,
    pollingInterval: s = t.pollingInterval,
    retryCount: i = 6,
    retryDelay: o = ({ count: c }) => ~~(1 << c) * 200,
    timeout: a = 18e4
  }
) {
  const c = oi(['waitForTransactionReceipt', t.uid, n])
  let u,
    l,
    d,
    h = !1
  const { promise: p, resolve: y, reject: m } = A3(),
    b = a ? setTimeout(() => m(new V$({ hash: n })), a) : void 0,
    I = hm(c, { onReplaced: r, resolve: y, reject: m }, x => {
      const _ = cn(
        t,
        tj,
        'watchBlockNumber'
      )({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: s,
        async onBlockNumber(R) {
          const N = M => {
            clearTimeout(b), _(), M(), I()
          }
          let T = R
          if (!h)
            try {
              if (d) {
                if (e > 1 && (!d.blockNumber || T - d.blockNumber + 1n < e)) return
                N(() => x.resolve(d))
                return
              }
              if (
                (u ||
                  ((h = !0),
                  await dm(
                    async () => {
                      ;(u = await cn(t, T3, 'getTransaction')({ hash: n })),
                        u.blockNumber && (T = u.blockNumber)
                    },
                    { delay: o, retryCount: i }
                  ),
                  (h = !1)),
                (d = await cn(t, WC, 'getTransactionReceipt')({ hash: n })),
                e > 1 && (!d.blockNumber || T - d.blockNumber + 1n < e))
              )
                return
              N(() => x.resolve(d))
            } catch (M) {
              if (M instanceof DR || M instanceof MR) {
                if (!u) {
                  h = !1
                  return
                }
                try {
                  ;(l = u), (h = !0)
                  const H = await dm(
                    () => cn(t, df, 'getBlock')({ blockNumber: T, includeTransactions: !0 }),
                    { delay: o, retryCount: i, shouldRetry: ({ error: D }) => D instanceof LR }
                  )
                  h = !1
                  const B = H.transactions.find(
                    ({ from: D, nonce: W }) => D === l.from && W === l.nonce
                  )
                  if (
                    !B ||
                    ((d = await cn(t, WC, 'getTransactionReceipt')({ hash: B.hash })),
                    e > 1 && (!d.blockNumber || T - d.blockNumber + 1n < e))
                  )
                    return
                  let $ = 'replaced'
                  B.to === l.to && B.value === l.value && B.input === l.input
                    ? ($ = 'repriced')
                    : B.from === B.to && B.value === 0n && ($ = 'cancelled'),
                    N(() => {
                      var D
                      ;(D = x.onReplaced) == null ||
                        D.call(x, {
                          reason: $,
                          replacedTransaction: l,
                          transaction: B,
                          transactionReceipt: d
                        }),
                        x.resolve(d)
                    })
                } catch (H) {
                  N(() => x.reject(H))
                }
              } else N(() => x.reject(M))
            }
        }
      })
    })
  return p
}
async function ij(t, { account: e = t.account, message: n }) {
  if (!e) throw new jE({ docsPath: '/docs/actions/wallet/signMessage' })
  const r = go(e)
  if (r.signMessage) return r.signMessage({ message: n })
  const s = typeof n == 'string' ? u0(n) : n.raw instanceof Uint8Array ? wt(n.raw) : n.raw
  return t.request({ method: 'personal_sign', params: [s, r.address] }, { retryCount: 0 })
}
class B3 extends DE {
  constructor(e, n) {
    super(), (this.finished = !1), (this.destroyed = !1), FL(e)
    const r = f0(n)
    if (((this.iHash = e.create()), typeof this.iHash.update != 'function'))
      throw new Error('Expected instance of class which extends utils.Hash')
    ;(this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen)
    const s = this.blockLen,
      i = new Uint8Array(s)
    i.set(r.length > s ? e.create().update(r).digest() : r)
    for (let o = 0; o < i.length; o++) i[o] ^= 54
    this.iHash.update(i), (this.oHash = e.create())
    for (let o = 0; o < i.length; o++) i[o] ^= 106
    this.oHash.update(i), i.fill(0)
  }
  update(e) {
    return Ql(this), this.iHash.update(e), this
  }
  digestInto(e) {
    Ql(this),
      wd(e, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(e),
      this.oHash.update(e),
      this.oHash.digestInto(e),
      this.destroy()
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen)
    return this.digestInto(e), e
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}))
    const { oHash: n, iHash: r, finished: s, destroyed: i, blockLen: o, outputLen: a } = this
    return (
      (e = e),
      (e.finished = s),
      (e.destroyed = i),
      (e.blockLen = o),
      (e.outputLen = a),
      (e.oHash = n._cloneInto(e.oHash)),
      (e.iHash = r._cloneInto(e.iHash)),
      e
    )
  }
  destroy() {
    ;(this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy()
  }
}
const D3 = (t, e, n) => new B3(t, e).update(n).digest()
D3.create = (t, e) => new B3(t, e)
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const pr = BigInt(0),
  Dn = BigInt(1),
  Nc = BigInt(2),
  oj = BigInt(3),
  U1 = BigInt(4),
  ZC = BigInt(5),
  YC = BigInt(8)
function Nn(t, e) {
  const n = t % e
  return n >= pr ? n : e + n
}
function aj(t, e, n) {
  if (e < pr) throw new Error('invalid exponent, negatives unsupported')
  if (n <= pr) throw new Error('invalid modulus')
  if (n === Dn) return pr
  let r = Dn
  for (; e > pr; ) e & Dn && (r = (r * t) % n), (t = (t * t) % n), (e >>= Dn)
  return r
}
function Fn(t, e, n) {
  let r = t
  for (; e-- > pr; ) (r *= r), (r %= n)
  return r
}
function L1(t, e) {
  if (t === pr) throw new Error('invert: expected non-zero number')
  if (e <= pr) throw new Error('invert: expected positive modulus, got ' + e)
  let n = Nn(t, e),
    r = e,
    s = pr,
    i = Dn
  for (; n !== pr; ) {
    const a = r / n,
      c = r % n,
      u = s - i * a
    ;(r = n), (n = c), (s = i), (i = u)
  }
  if (r !== Dn) throw new Error('invert: does not exist')
  return Nn(s, e)
}
function cj(t) {
  const e = (t - Dn) / Nc
  let n, r, s
  for (n = t - Dn, r = 0; n % Nc === pr; n /= Nc, r++);
  for (s = Nc; s < t && aj(s, e, t) !== t - Dn; s++)
    if (s > 1e3) throw new Error('Cannot find square root: likely non-prime P')
  if (r === 1) {
    const o = (t + Dn) / U1
    return function (c, u) {
      const l = c.pow(u, o)
      if (!c.eql(c.sqr(l), u)) throw new Error('Cannot find square root')
      return l
    }
  }
  const i = (n + Dn) / Nc
  return function (a, c) {
    if (a.pow(c, e) === a.neg(a.ONE)) throw new Error('Cannot find square root')
    let u = r,
      l = a.pow(a.mul(a.ONE, s), n),
      d = a.pow(c, i),
      h = a.pow(c, n)
    for (; !a.eql(h, a.ONE); ) {
      if (a.eql(h, a.ZERO)) return a.ZERO
      let p = 1
      for (let m = a.sqr(h); p < u && !a.eql(m, a.ONE); p++) m = a.sqr(m)
      const y = a.pow(l, Dn << BigInt(u - p - 1))
      ;(l = a.sqr(y)), (d = a.mul(d, y)), (h = a.mul(h, l)), (u = p)
    }
    return d
  }
}
function uj(t) {
  if (t % U1 === oj) {
    const e = (t + Dn) / U1
    return function (r, s) {
      const i = r.pow(s, e)
      if (!r.eql(r.sqr(i), s)) throw new Error('Cannot find square root')
      return i
    }
  }
  if (t % YC === ZC) {
    const e = (t - ZC) / YC
    return function (r, s) {
      const i = r.mul(s, Nc),
        o = r.pow(i, e),
        a = r.mul(s, o),
        c = r.mul(r.mul(a, Nc), o),
        u = r.mul(a, r.sub(c, r.ONE))
      if (!r.eql(r.sqr(u), s)) throw new Error('Cannot find square root')
      return u
    }
  }
  return cj(t)
}
const lj = (t, e) => (Nn(t, e) & Dn) === Dn,
  dj = [
    'create',
    'isValid',
    'is0',
    'neg',
    'inv',
    'sqrt',
    'sqr',
    'eql',
    'add',
    'sub',
    'mul',
    'pow',
    'div',
    'addN',
    'subN',
    'mulN',
    'sqrN'
  ]
function hj(t) {
  const e = { ORDER: 'bigint', MASK: 'bigint', BYTES: 'isSafeInteger', BITS: 'isSafeInteger' },
    n = dj.reduce((r, s) => ((r[s] = 'function'), r), e)
  return _d(t, n)
}
function fj(t, e, n) {
  if (n < pr) throw new Error('invalid exponent, negatives unsupported')
  if (n === pr) return t.ONE
  if (n === Dn) return e
  let r = t.ONE,
    s = e
  for (; n > pr; ) n & Dn && (r = t.mul(r, s)), (s = t.sqr(s)), (n >>= Dn)
  return r
}
function pj(t, e) {
  const n = new Array(e.length),
    r = e.reduce((i, o, a) => (t.is0(o) ? i : ((n[a] = i), t.mul(i, o))), t.ONE),
    s = t.inv(r)
  return e.reduceRight((i, o, a) => (t.is0(o) ? i : ((n[a] = t.mul(i, n[a])), t.mul(i, o))), s), n
}
function M3(t, e) {
  const n = e !== void 0 ? e : t.toString(2).length,
    r = Math.ceil(n / 8)
  return { nBitLength: n, nByteLength: r }
}
function S0(t, e, n = !1, r = {}) {
  if (t <= pr) throw new Error('invalid field: expected ORDER > 0, got ' + t)
  const { nBitLength: s, nByteLength: i } = M3(t, e)
  if (i > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes')
  let o
  const a = Object.freeze({
    ORDER: t,
    isLE: n,
    BITS: s,
    BYTES: i,
    MASK: lA(s),
    ZERO: pr,
    ONE: Dn,
    create: c => Nn(c, t),
    isValid: c => {
      if (typeof c != 'bigint')
        throw new Error('invalid field element: expected bigint, got ' + typeof c)
      return pr <= c && c < t
    },
    is0: c => c === pr,
    isOdd: c => (c & Dn) === Dn,
    neg: c => Nn(-c, t),
    eql: (c, u) => c === u,
    sqr: c => Nn(c * c, t),
    add: (c, u) => Nn(c + u, t),
    sub: (c, u) => Nn(c - u, t),
    mul: (c, u) => Nn(c * u, t),
    pow: (c, u) => fj(a, c, u),
    div: (c, u) => Nn(c * L1(u, t), t),
    sqrN: c => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: c => L1(c, t),
    sqrt: r.sqrt || (c => (o || (o = uj(t)), o(a, c))),
    invertBatch: c => pj(a, c),
    cmov: (c, u, l) => (l ? u : c),
    toBytes: c => (n ? ff(c, i) : Xl(c, i)),
    fromBytes: c => {
      if (c.length !== i)
        throw new Error('Field.fromBytes: expected ' + i + ' bytes, got ' + c.length)
      return n ? Pl(c) : Jc(c)
    }
  })
  return Object.freeze(a)
}
function U3(t) {
  if (typeof t != 'bigint') throw new Error('field order must be bigint')
  const e = t.toString(2).length
  return Math.ceil(e / 8)
}
function L3(t) {
  const e = U3(t)
  return e + Math.ceil(e / 2)
}
function gj(t, e, n = !1) {
  const r = t.length,
    s = U3(e),
    i = L3(e)
  if (r < 16 || r < i || r > 1024)
    throw new Error('expected ' + i + '-1024 bytes of input, got ' + r)
  const o = n ? Pl(t) : Jc(t),
    a = Nn(o, e - Dn) + Dn
  return n ? ff(a, s) : Xl(a, s)
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const JC = BigInt(0),
  zp = BigInt(1)
function lw(t, e) {
  const n = e.negate()
  return t ? n : e
}
function $3(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e)
    throw new Error('invalid window size, expected [1..' + e + '], got W=' + t)
}
function dw(t, e) {
  $3(t, e)
  const n = Math.ceil(e / t) + 1,
    r = 2 ** (t - 1)
  return { windows: n, windowSize: r }
}
function mj(t, e) {
  if (!Array.isArray(t)) throw new Error('array expected')
  t.forEach((n, r) => {
    if (!(n instanceof e)) throw new Error('invalid point at index ' + r)
  })
}
function yj(t, e) {
  if (!Array.isArray(t)) throw new Error('array of scalars expected')
  t.forEach((n, r) => {
    if (!e.isValid(n)) throw new Error('invalid scalar at index ' + r)
  })
}
const hw = new WeakMap(),
  F3 = new WeakMap()
function fw(t) {
  return F3.get(t) || 1
}
function j3(t, e) {
  return {
    constTimeNegate: lw,
    hasPrecomputes(n) {
      return fw(n) !== 1
    },
    unsafeLadder(n, r, s = t.ZERO) {
      let i = n
      for (; r > JC; ) r & zp && (s = s.add(i)), (i = i.double()), (r >>= zp)
      return s
    },
    precomputeWindow(n, r) {
      const { windows: s, windowSize: i } = dw(r, e),
        o = []
      let a = n,
        c = a
      for (let u = 0; u < s; u++) {
        ;(c = a), o.push(c)
        for (let l = 1; l < i; l++) (c = c.add(a)), o.push(c)
        a = c.double()
      }
      return o
    },
    wNAF(n, r, s) {
      const { windows: i, windowSize: o } = dw(n, e)
      let a = t.ZERO,
        c = t.BASE
      const u = BigInt(2 ** n - 1),
        l = 2 ** n,
        d = BigInt(n)
      for (let h = 0; h < i; h++) {
        const p = h * o
        let y = Number(s & u)
        ;(s >>= d), y > o && ((y -= l), (s += zp))
        const m = p,
          b = p + Math.abs(y) - 1,
          I = h % 2 !== 0,
          x = y < 0
        y === 0 ? (c = c.add(lw(I, r[m]))) : (a = a.add(lw(x, r[b])))
      }
      return { p: a, f: c }
    },
    wNAFUnsafe(n, r, s, i = t.ZERO) {
      const { windows: o, windowSize: a } = dw(n, e),
        c = BigInt(2 ** n - 1),
        u = 2 ** n,
        l = BigInt(n)
      for (let d = 0; d < o; d++) {
        const h = d * a
        if (s === JC) break
        let p = Number(s & c)
        if (((s >>= l), p > a && ((p -= u), (s += zp)), p === 0)) continue
        let y = r[h + Math.abs(p) - 1]
        p < 0 && (y = y.negate()), (i = i.add(y))
      }
      return i
    },
    getPrecomputes(n, r, s) {
      let i = hw.get(r)
      return i || ((i = this.precomputeWindow(r, n)), n !== 1 && hw.set(r, s(i))), i
    },
    wNAFCached(n, r, s) {
      const i = fw(n)
      return this.wNAF(i, this.getPrecomputes(i, n, s), r)
    },
    wNAFCachedUnsafe(n, r, s, i) {
      const o = fw(n)
      return o === 1
        ? this.unsafeLadder(n, r, i)
        : this.wNAFUnsafe(o, this.getPrecomputes(o, n, s), r, i)
    },
    setWindowSize(n, r) {
      $3(r, e), F3.set(n, r), hw.delete(n)
    }
  }
}
function H3(t, e, n, r) {
  if ((mj(n, t), yj(r, e), n.length !== r.length))
    throw new Error('arrays of points and scalars must have equal length')
  const s = t.ZERO,
    i = P3(BigInt(n.length)),
    o = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1,
    a = (1 << o) - 1,
    c = new Array(a + 1).fill(s),
    u = Math.floor((e.BITS - 1) / o) * o
  let l = s
  for (let d = u; d >= 0; d -= o) {
    c.fill(s)
    for (let p = 0; p < r.length; p++) {
      const y = r[p],
        m = Number((y >> BigInt(d)) & BigInt(a))
      c[m] = c[m].add(n[p])
    }
    let h = s
    for (let p = c.length - 1, y = s; p > 0; p--) (y = y.add(c[p])), (h = h.add(y))
    if (((l = l.add(h)), d !== 0)) for (let p = 0; p < o; p++) l = l.double()
  }
  return l
}
function fA(t) {
  return (
    hj(t.Fp),
    _d(
      t,
      { n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field' },
      { nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger' }
    ),
    Object.freeze({ ...M3(t.n, t.nBitLength), ...t, p: t.Fp.ORDER })
  )
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function XC(t) {
  t.lowS !== void 0 && Ko('lowS', t.lowS), t.prehash !== void 0 && Ko('prehash', t.prehash)
}
function wj(t) {
  const e = fA(t)
  _d(
    e,
    { a: 'field', b: 'field' },
    {
      allowedPrivateKeyLengths: 'array',
      wrapPrivateKey: 'boolean',
      isTorsionFree: 'function',
      clearCofactor: 'function',
      allowInfinityPoint: 'boolean',
      fromBytes: 'function',
      toBytes: 'function'
    }
  )
  const { endo: n, Fp: r, a: s } = e
  if (n) {
    if (!r.eql(s, r.ZERO))
      throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0')
    if (typeof n != 'object' || typeof n.beta != 'bigint' || typeof n.splitScalar != 'function')
      throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function')
  }
  return Object.freeze({ ...e })
}
const { bytesToNumberBE: bj, hexToBytes: vj } = D7
class Ej extends Error {
  constructor(e = '') {
    super(e)
  }
}
const Uo = {
    Err: Ej,
    _tlv: {
      encode: (t, e) => {
        const { Err: n } = Uo
        if (t < 0 || t > 256) throw new n('tlv.encode: wrong tag')
        if (e.length & 1) throw new n('tlv.encode: unpadded data')
        const r = e.length / 2,
          s = pl(r)
        if ((s.length / 2) & 128) throw new n('tlv.encode: long form length too big')
        const i = r > 127 ? pl((s.length / 2) | 128) : ''
        return pl(t) + i + s + e
      },
      decode(t, e) {
        const { Err: n } = Uo
        let r = 0
        if (t < 0 || t > 256) throw new n('tlv.encode: wrong tag')
        if (e.length < 2 || e[r++] !== t) throw new n('tlv.decode: wrong tlv')
        const s = e[r++],
          i = !!(s & 128)
        let o = 0
        if (!i) o = s
        else {
          const c = s & 127
          if (!c) throw new n('tlv.decode(long): indefinite length not supported')
          if (c > 4) throw new n('tlv.decode(long): byte length is too big')
          const u = e.subarray(r, r + c)
          if (u.length !== c) throw new n('tlv.decode: length bytes not complete')
          if (u[0] === 0) throw new n('tlv.decode(long): zero leftmost byte')
          for (const l of u) o = (o << 8) | l
          if (((r += c), o < 128)) throw new n('tlv.decode(long): not minimal encoding')
        }
        const a = e.subarray(r, r + o)
        if (a.length !== o) throw new n('tlv.decode: wrong value length')
        return { v: a, l: e.subarray(r + o) }
      }
    },
    _int: {
      encode(t) {
        const { Err: e } = Uo
        if (t < Fo) throw new e('integer: negative integers are not allowed')
        let n = pl(t)
        if ((Number.parseInt(n[0], 16) & 8 && (n = '00' + n), n.length & 1))
          throw new e('unexpected DER parsing assertion: unpadded hex')
        return n
      },
      decode(t) {
        const { Err: e } = Uo
        if (t[0] & 128) throw new e('invalid signature integer: negative')
        if (t[0] === 0 && !(t[1] & 128))
          throw new e('invalid signature integer: unnecessary leading zero')
        return bj(t)
      }
    },
    toSig(t) {
      const { Err: e, _int: n, _tlv: r } = Uo,
        s = typeof t == 'string' ? vj(t) : t
      op(s)
      const { v: i, l: o } = r.decode(48, s)
      if (o.length) throw new e('invalid signature: left bytes after parsing')
      const { v: a, l: c } = r.decode(2, i),
        { v: u, l } = r.decode(2, c)
      if (l.length) throw new e('invalid signature: left bytes after parsing')
      return { r: n.decode(a), s: n.decode(u) }
    },
    hexFromSig(t) {
      const { _tlv: e, _int: n } = Uo,
        r = e.encode(2, n.encode(t.r)),
        s = e.encode(2, n.encode(t.s)),
        i = r + s
      return e.encode(48, i)
    }
  },
  Fo = BigInt(0),
  lr = BigInt(1)
BigInt(2)
const eS = BigInt(3)
BigInt(4)
function Aj(t) {
  const e = wj(t),
    { Fp: n } = e,
    r = S0(e.n, e.nBitLength),
    s =
      e.toBytes ||
      ((m, b, I) => {
        const x = b.toAffine()
        return du(Uint8Array.from([4]), n.toBytes(x.x), n.toBytes(x.y))
      }),
    i =
      e.fromBytes ||
      (m => {
        const b = m.subarray(1),
          I = n.fromBytes(b.subarray(0, n.BYTES)),
          x = n.fromBytes(b.subarray(n.BYTES, 2 * n.BYTES))
        return { x: I, y: x }
      })
  function o(m) {
    const { a: b, b: I } = e,
      x = n.sqr(m),
      _ = n.mul(x, m)
    return n.add(n.add(_, n.mul(m, b)), I)
  }
  if (!n.eql(n.sqr(e.Gy), o(e.Gx))) throw new Error('bad generator point: equation left != right')
  function a(m) {
    return _0(m, lr, e.n)
  }
  function c(m) {
    const { allowedPrivateKeyLengths: b, nByteLength: I, wrapPrivateKey: x, n: _ } = e
    if (b && typeof m != 'bigint') {
      if ((uu(m) && (m = lu(m)), typeof m != 'string' || !b.includes(m.length)))
        throw new Error('invalid private key')
      m = m.padStart(I * 2, '0')
    }
    let R
    try {
      R = typeof m == 'bigint' ? m : Jc(Zn('private key', m, I))
    } catch {
      throw new Error('invalid private key, expected hex or ' + I + ' bytes, got ' + typeof m)
    }
    return x && (R = Nn(R, _)), si('private key', R, lr, _), R
  }
  function u(m) {
    if (!(m instanceof h)) throw new Error('ProjectivePoint expected')
  }
  const l = pf((m, b) => {
      const { px: I, py: x, pz: _ } = m
      if (n.eql(_, n.ONE)) return { x: I, y: x }
      const R = m.is0()
      b == null && (b = R ? n.ONE : n.inv(_))
      const N = n.mul(I, b),
        T = n.mul(x, b),
        M = n.mul(_, b)
      if (R) return { x: n.ZERO, y: n.ZERO }
      if (!n.eql(M, n.ONE)) throw new Error('invZ was invalid')
      return { x: N, y: T }
    }),
    d = pf(m => {
      if (m.is0()) {
        if (e.allowInfinityPoint && !n.is0(m.py)) return
        throw new Error('bad point: ZERO')
      }
      const { x: b, y: I } = m.toAffine()
      if (!n.isValid(b) || !n.isValid(I)) throw new Error('bad point: x or y not FE')
      const x = n.sqr(I),
        _ = o(b)
      if (!n.eql(x, _)) throw new Error('bad point: equation left != right')
      if (!m.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup')
      return !0
    })
  class h {
    constructor(b, I, x) {
      if (((this.px = b), (this.py = I), (this.pz = x), b == null || !n.isValid(b)))
        throw new Error('x required')
      if (I == null || !n.isValid(I)) throw new Error('y required')
      if (x == null || !n.isValid(x)) throw new Error('z required')
      Object.freeze(this)
    }
    static fromAffine(b) {
      const { x: I, y: x } = b || {}
      if (!b || !n.isValid(I) || !n.isValid(x)) throw new Error('invalid affine point')
      if (b instanceof h) throw new Error('projective point not allowed')
      const _ = R => n.eql(R, n.ZERO)
      return _(I) && _(x) ? h.ZERO : new h(I, x, n.ONE)
    }
    get x() {
      return this.toAffine().x
    }
    get y() {
      return this.toAffine().y
    }
    static normalizeZ(b) {
      const I = n.invertBatch(b.map(x => x.pz))
      return b.map((x, _) => x.toAffine(I[_])).map(h.fromAffine)
    }
    static fromHex(b) {
      const I = h.fromAffine(i(Zn('pointHex', b)))
      return I.assertValidity(), I
    }
    static fromPrivateKey(b) {
      return h.BASE.multiply(c(b))
    }
    static msm(b, I) {
      return H3(h, r, b, I)
    }
    _setWindowSize(b) {
      y.setWindowSize(this, b)
    }
    assertValidity() {
      d(this)
    }
    hasEvenY() {
      const { y: b } = this.toAffine()
      if (n.isOdd) return !n.isOdd(b)
      throw new Error("Field doesn't support isOdd")
    }
    equals(b) {
      u(b)
      const { px: I, py: x, pz: _ } = this,
        { px: R, py: N, pz: T } = b,
        M = n.eql(n.mul(I, T), n.mul(R, _)),
        H = n.eql(n.mul(x, T), n.mul(N, _))
      return M && H
    }
    negate() {
      return new h(this.px, n.neg(this.py), this.pz)
    }
    double() {
      const { a: b, b: I } = e,
        x = n.mul(I, eS),
        { px: _, py: R, pz: N } = this
      let T = n.ZERO,
        M = n.ZERO,
        H = n.ZERO,
        B = n.mul(_, _),
        $ = n.mul(R, R),
        D = n.mul(N, N),
        W = n.mul(_, R)
      return (
        (W = n.add(W, W)),
        (H = n.mul(_, N)),
        (H = n.add(H, H)),
        (T = n.mul(b, H)),
        (M = n.mul(x, D)),
        (M = n.add(T, M)),
        (T = n.sub($, M)),
        (M = n.add($, M)),
        (M = n.mul(T, M)),
        (T = n.mul(W, T)),
        (H = n.mul(x, H)),
        (D = n.mul(b, D)),
        (W = n.sub(B, D)),
        (W = n.mul(b, W)),
        (W = n.add(W, H)),
        (H = n.add(B, B)),
        (B = n.add(H, B)),
        (B = n.add(B, D)),
        (B = n.mul(B, W)),
        (M = n.add(M, B)),
        (D = n.mul(R, N)),
        (D = n.add(D, D)),
        (B = n.mul(D, W)),
        (T = n.sub(T, B)),
        (H = n.mul(D, $)),
        (H = n.add(H, H)),
        (H = n.add(H, H)),
        new h(T, M, H)
      )
    }
    add(b) {
      u(b)
      const { px: I, py: x, pz: _ } = this,
        { px: R, py: N, pz: T } = b
      let M = n.ZERO,
        H = n.ZERO,
        B = n.ZERO
      const $ = e.a,
        D = n.mul(e.b, eS)
      let W = n.mul(I, R),
        U = n.mul(x, N),
        w = n.mul(_, T),
        v = n.add(I, x),
        A = n.add(R, N)
      ;(v = n.mul(v, A)), (A = n.add(W, U)), (v = n.sub(v, A)), (A = n.add(I, _))
      let P = n.add(R, T)
      return (
        (A = n.mul(A, P)),
        (P = n.add(W, w)),
        (A = n.sub(A, P)),
        (P = n.add(x, _)),
        (M = n.add(N, T)),
        (P = n.mul(P, M)),
        (M = n.add(U, w)),
        (P = n.sub(P, M)),
        (B = n.mul($, A)),
        (M = n.mul(D, w)),
        (B = n.add(M, B)),
        (M = n.sub(U, B)),
        (B = n.add(U, B)),
        (H = n.mul(M, B)),
        (U = n.add(W, W)),
        (U = n.add(U, W)),
        (w = n.mul($, w)),
        (A = n.mul(D, A)),
        (U = n.add(U, w)),
        (w = n.sub(W, w)),
        (w = n.mul($, w)),
        (A = n.add(A, w)),
        (W = n.mul(U, A)),
        (H = n.add(H, W)),
        (W = n.mul(P, A)),
        (M = n.mul(v, M)),
        (M = n.sub(M, W)),
        (W = n.mul(v, U)),
        (B = n.mul(P, B)),
        (B = n.add(B, W)),
        new h(M, H, B)
      )
    }
    subtract(b) {
      return this.add(b.negate())
    }
    is0() {
      return this.equals(h.ZERO)
    }
    wNAF(b) {
      return y.wNAFCached(this, b, h.normalizeZ)
    }
    multiplyUnsafe(b) {
      const { endo: I, n: x } = e
      si('scalar', b, Fo, x)
      const _ = h.ZERO
      if (b === Fo) return _
      if (this.is0() || b === lr) return this
      if (!I || y.hasPrecomputes(this)) return y.wNAFCachedUnsafe(this, b, h.normalizeZ)
      let { k1neg: R, k1: N, k2neg: T, k2: M } = I.splitScalar(b),
        H = _,
        B = _,
        $ = this
      for (; N > Fo || M > Fo; )
        N & lr && (H = H.add($)), M & lr && (B = B.add($)), ($ = $.double()), (N >>= lr), (M >>= lr)
      return (
        R && (H = H.negate()),
        T && (B = B.negate()),
        (B = new h(n.mul(B.px, I.beta), B.py, B.pz)),
        H.add(B)
      )
    }
    multiply(b) {
      const { endo: I, n: x } = e
      si('scalar', b, lr, x)
      let _, R
      if (I) {
        const { k1neg: N, k1: T, k2neg: M, k2: H } = I.splitScalar(b)
        let { p: B, f: $ } = this.wNAF(T),
          { p: D, f: W } = this.wNAF(H)
        ;(B = y.constTimeNegate(N, B)),
          (D = y.constTimeNegate(M, D)),
          (D = new h(n.mul(D.px, I.beta), D.py, D.pz)),
          (_ = B.add(D)),
          (R = $.add(W))
      } else {
        const { p: N, f: T } = this.wNAF(b)
        ;(_ = N), (R = T)
      }
      return h.normalizeZ([_, R])[0]
    }
    multiplyAndAddUnsafe(b, I, x) {
      const _ = h.BASE,
        R = (T, M) => (M === Fo || M === lr || !T.equals(_) ? T.multiplyUnsafe(M) : T.multiply(M)),
        N = R(this, I).add(R(b, x))
      return N.is0() ? void 0 : N
    }
    toAffine(b) {
      return l(this, b)
    }
    isTorsionFree() {
      const { h: b, isTorsionFree: I } = e
      if (b === lr) return !0
      if (I) return I(h, this)
      throw new Error('isTorsionFree() has not been declared for the elliptic curve')
    }
    clearCofactor() {
      const { h: b, clearCofactor: I } = e
      return b === lr ? this : I ? I(h, this) : this.multiplyUnsafe(e.h)
    }
    toRawBytes(b = !0) {
      return Ko('isCompressed', b), this.assertValidity(), s(h, this, b)
    }
    toHex(b = !0) {
      return Ko('isCompressed', b), lu(this.toRawBytes(b))
    }
  }
  ;(h.BASE = new h(e.Gx, e.Gy, n.ONE)), (h.ZERO = new h(n.ZERO, n.ONE, n.ZERO))
  const p = e.nBitLength,
    y = j3(h, e.endo ? Math.ceil(p / 2) : p)
  return {
    CURVE: e,
    ProjectivePoint: h,
    normPrivateKeyToScalar: c,
    weierstrassEquation: o,
    isWithinCurveOrder: a
  }
}
function _j(t) {
  const e = fA(t)
  return (
    _d(
      e,
      { hash: 'hash', hmac: 'function', randomBytes: 'function' },
      { bits2int: 'function', bits2int_modN: 'function', lowS: 'boolean' }
    ),
    Object.freeze({ lowS: !0, ...e })
  )
}
function Cj(t) {
  const e = _j(t),
    { Fp: n, n: r } = e,
    s = n.BYTES + 1,
    i = 2 * n.BYTES + 1
  function o(w) {
    return Nn(w, r)
  }
  function a(w) {
    return L1(w, r)
  }
  const {
      ProjectivePoint: c,
      normPrivateKeyToScalar: u,
      weierstrassEquation: l,
      isWithinCurveOrder: d
    } = Aj({
      ...e,
      toBytes(w, v, A) {
        const P = v.toAffine(),
          O = n.toBytes(P.x),
          F = du
        return (
          Ko('isCompressed', A),
          A
            ? F(Uint8Array.from([v.hasEvenY() ? 2 : 3]), O)
            : F(Uint8Array.from([4]), O, n.toBytes(P.y))
        )
      },
      fromBytes(w) {
        const v = w.length,
          A = w[0],
          P = w.subarray(1)
        if (v === s && (A === 2 || A === 3)) {
          const O = Jc(P)
          if (!_0(O, lr, n.ORDER)) throw new Error('Point is not on curve')
          const F = l(O)
          let z
          try {
            z = n.sqrt(F)
          } catch (C) {
            const L = C instanceof Error ? ': ' + C.message : ''
            throw new Error('Point is not on curve' + L)
          }
          const j = (z & lr) === lr
          return ((A & 1) === 1) !== j && (z = n.neg(z)), { x: O, y: z }
        } else if (v === i && A === 4) {
          const O = n.fromBytes(P.subarray(0, n.BYTES)),
            F = n.fromBytes(P.subarray(n.BYTES, 2 * n.BYTES))
          return { x: O, y: F }
        } else {
          const O = s,
            F = i
          throw new Error(
            'invalid Point, expected length of ' + O + ', or uncompressed ' + F + ', got ' + v
          )
        }
      }
    }),
    h = w => lu(Xl(w, e.nByteLength))
  function p(w) {
    const v = r >> lr
    return w > v
  }
  function y(w) {
    return p(w) ? o(-w) : w
  }
  const m = (w, v, A) => Jc(w.slice(v, A))
  class b {
    constructor(v, A, P) {
      ;(this.r = v), (this.s = A), (this.recovery = P), this.assertValidity()
    }
    static fromCompact(v) {
      const A = e.nByteLength
      return (v = Zn('compactSignature', v, A * 2)), new b(m(v, 0, A), m(v, A, 2 * A))
    }
    static fromDER(v) {
      const { r: A, s: P } = Uo.toSig(Zn('DER', v))
      return new b(A, P)
    }
    assertValidity() {
      si('r', this.r, lr, r), si('s', this.s, lr, r)
    }
    addRecoveryBit(v) {
      return new b(this.r, this.s, v)
    }
    recoverPublicKey(v) {
      const { r: A, s: P, recovery: O } = this,
        F = T(Zn('msgHash', v))
      if (O == null || ![0, 1, 2, 3].includes(O)) throw new Error('recovery id invalid')
      const z = O === 2 || O === 3 ? A + e.n : A
      if (z >= n.ORDER) throw new Error('recovery id 2 or 3 invalid')
      const j = (O & 1) === 0 ? '02' : '03',
        E = c.fromHex(j + h(z)),
        C = a(z),
        L = o(-F * C),
        K = o(P * C),
        ee = c.BASE.multiplyAndAddUnsafe(E, L, K)
      if (!ee) throw new Error('point at infinify')
      return ee.assertValidity(), ee
    }
    hasHighS() {
      return p(this.s)
    }
    normalizeS() {
      return this.hasHighS() ? new b(this.r, o(-this.s), this.recovery) : this
    }
    toDERRawBytes() {
      return Jl(this.toDERHex())
    }
    toDERHex() {
      return Uo.hexFromSig({ r: this.r, s: this.s })
    }
    toCompactRawBytes() {
      return Jl(this.toCompactHex())
    }
    toCompactHex() {
      return h(this.r) + h(this.s)
    }
  }
  const I = {
    isValidPrivateKey(w) {
      try {
        return u(w), !0
      } catch {
        return !1
      }
    },
    normPrivateKeyToScalar: u,
    randomPrivateKey: () => {
      const w = L3(e.n)
      return gj(e.randomBytes(w), e.n)
    },
    precompute(w = 8, v = c.BASE) {
      return v._setWindowSize(w), v.multiply(BigInt(3)), v
    }
  }
  function x(w, v = !0) {
    return c.fromPrivateKey(w).toRawBytes(v)
  }
  function _(w) {
    const v = uu(w),
      A = typeof w == 'string',
      P = (v || A) && w.length
    return v ? P === s || P === i : A ? P === 2 * s || P === 2 * i : w instanceof c
  }
  function R(w, v, A = !0) {
    if (_(w)) throw new Error('first arg must be private key')
    if (!_(v)) throw new Error('second arg must be public key')
    return c.fromHex(v).multiply(u(w)).toRawBytes(A)
  }
  const N =
      e.bits2int ||
      function (w) {
        if (w.length > 8192) throw new Error('input is too large')
        const v = Jc(w),
          A = w.length * 8 - e.nBitLength
        return A > 0 ? v >> BigInt(A) : v
      },
    T =
      e.bits2int_modN ||
      function (w) {
        return o(N(w))
      },
    M = lA(e.nBitLength)
  function H(w) {
    return si('num < 2^' + e.nBitLength, w, Fo, M), Xl(w, e.nByteLength)
  }
  function B(w, v, A = $) {
    if (['recovered', 'canonical'].some(fe => fe in A))
      throw new Error('sign() legacy options not supported')
    const { hash: P, randomBytes: O } = e
    let { lowS: F, prehash: z, extraEntropy: j } = A
    F == null && (F = !0), (w = Zn('msgHash', w)), XC(A), z && (w = Zn('prehashed msgHash', P(w)))
    const E = T(w),
      C = u(v),
      L = [H(C), H(E)]
    if (j != null && j !== !1) {
      const fe = j === !0 ? O(n.BYTES) : j
      L.push(Zn('extraEntropy', fe))
    }
    const K = du(...L),
      ee = E
    function oe(fe) {
      const ve = N(fe)
      if (!d(ve)) return
      const tt = a(ve),
        Ge = c.BASE.multiply(ve).toAffine(),
        nt = o(Ge.x)
      if (nt === Fo) return
      const Z = o(tt * o(ee + nt * C))
      if (Z === Fo) return
      let X = (Ge.x === nt ? 0 : 2) | Number(Ge.y & lr),
        ie = Z
      return F && p(Z) && ((ie = y(Z)), (X ^= 1)), new b(nt, ie, X)
    }
    return { seed: K, k2sig: oe }
  }
  const $ = { lowS: e.lowS, prehash: !1 },
    D = { lowS: e.lowS, prehash: !1 }
  function W(w, v, A = $) {
    const { seed: P, k2sig: O } = B(w, v, A),
      F = e
    return R3(F.hash.outputLen, F.nByteLength, F.hmac)(P, O)
  }
  c.BASE._setWindowSize(8)
  function U(w, v, A, P = D) {
    var X
    const O = w
    ;(v = Zn('msgHash', v)), (A = Zn('publicKey', A))
    const { lowS: F, prehash: z, format: j } = P
    if ((XC(P), 'strict' in P)) throw new Error('options.strict was renamed to lowS')
    if (j !== void 0 && j !== 'compact' && j !== 'der')
      throw new Error('format must be compact or der')
    const E = typeof O == 'string' || uu(O),
      C =
        !E &&
        !j &&
        typeof O == 'object' &&
        O !== null &&
        typeof O.r == 'bigint' &&
        typeof O.s == 'bigint'
    if (!E && !C)
      throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance')
    let L, K
    try {
      if ((C && (L = new b(O.r, O.s)), E)) {
        try {
          j !== 'compact' && (L = b.fromDER(O))
        } catch (ie) {
          if (!(ie instanceof Uo.Err)) throw ie
        }
        !L && j !== 'der' && (L = b.fromCompact(O))
      }
      K = c.fromHex(A)
    } catch {
      return !1
    }
    if (!L || (F && L.hasHighS())) return !1
    z && (v = e.hash(v))
    const { r: ee, s: oe } = L,
      fe = T(v),
      ve = a(oe),
      tt = o(fe * ve),
      Ge = o(ee * ve),
      nt = (X = c.BASE.multiplyAndAddUnsafe(K, tt, Ge)) == null ? void 0 : X.toAffine()
    return nt ? o(nt.x) === ee : !1
  }
  return {
    CURVE: e,
    getPublicKey: x,
    getSharedSecret: R,
    sign: W,
    verify: U,
    ProjectivePoint: c,
    Signature: b,
    utils: I
  }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function Sj(t) {
  return { hash: t, hmac: (e, ...n) => D3(t, e, a$(...n)), randomBytes: vR }
}
function Ij(t, e) {
  const n = r => Cj({ ...t, ...Sj(r) })
  return { ...n(e), create: n }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const q3 = BigInt(
    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'
  ),
  tS = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
  xj = BigInt(1),
  $1 = BigInt(2),
  nS = (t, e) => (t + e / $1) / e
function Tj(t) {
  const e = q3,
    n = BigInt(3),
    r = BigInt(6),
    s = BigInt(11),
    i = BigInt(22),
    o = BigInt(23),
    a = BigInt(44),
    c = BigInt(88),
    u = (t * t * t) % e,
    l = (u * u * t) % e,
    d = (Fn(l, n, e) * l) % e,
    h = (Fn(d, n, e) * l) % e,
    p = (Fn(h, $1, e) * u) % e,
    y = (Fn(p, s, e) * p) % e,
    m = (Fn(y, i, e) * y) % e,
    b = (Fn(m, a, e) * m) % e,
    I = (Fn(b, c, e) * b) % e,
    x = (Fn(I, a, e) * m) % e,
    _ = (Fn(x, n, e) * l) % e,
    R = (Fn(_, o, e) * y) % e,
    N = (Fn(R, r, e) * u) % e,
    T = Fn(N, $1, e)
  if (!F1.eql(F1.sqr(T), t)) throw new Error('Cannot find square root')
  return T
}
const F1 = S0(q3, void 0, void 0, { sqrt: Tj }),
  I0 = Ij(
    {
      a: BigInt(0),
      b: BigInt(7),
      Fp: F1,
      n: tS,
      Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
      Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
      h: BigInt(1),
      lowS: !0,
      endo: {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: t => {
          const e = tS,
            n = BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
            r = -xj * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'),
            s = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),
            i = n,
            o = BigInt('0x100000000000000000000000000000000'),
            a = nS(i * t, e),
            c = nS(-r * t, e)
          let u = Nn(t - a * n - c * s, e),
            l = Nn(-a * r - c * i, e)
          const d = u > o,
            h = l > o
          if ((d && (u = e - u), h && (l = e - l), u > o || l > o))
            throw new Error('splitScalar: Endomorphism failed, k=' + t)
          return { k1neg: d, k1: u, k2neg: h, k2: l }
        }
      }
    },
    cm
  )
BigInt(0)
I0.ProjectivePoint
const z3 = Object.freeze(
  Object.defineProperty({ __proto__: null, secp256k1: I0 }, Symbol.toStringTag, { value: 'Module' })
)
async function Nj(t, e) {
  const {
    abi: n,
    account: r = t.account,
    address: s,
    args: i,
    dataSuffix: o,
    functionName: a,
    ...c
  } = e
  if (typeof r > 'u') throw new jE({ docsPath: '/docs/contract/writeContract' })
  const u = r ? go(r) : null,
    l = Ad({ abi: n, args: i, functionName: a })
  try {
    return await cn(
      t,
      e3,
      'sendTransaction'
    )({ data: `${l}${o ? o.replace('0x', '') : ''}`, to: s, account: u, ...c })
  } catch (d) {
    throw um(d, {
      abi: n,
      address: s,
      args: i,
      docsPath: '/docs/contract/writeContract',
      functionName: a,
      sender: u == null ? void 0 : u.address
    })
  }
}
function cs(t, e, n) {
  const r = t[e.name]
  if (typeof r == 'function') return r
  const s = t[n]
  return typeof s == 'function' ? s : i => e(t, i)
}
const Ng = '2.16.7',
  Pj = () => `@wagmi/core@${Ng}`
var W3 = function (t, e, n, r) {
    if (n === 'a' && !r) throw new TypeError('Private accessor was defined without a getter')
    if (typeof e == 'function' ? t !== e || !r : !e.has(t))
      throw new TypeError(
        'Cannot read private member from an object whose class did not declare it'
      )
    return n === 'm' ? r : n === 'a' ? r.call(t) : r ? r.value : e.get(t)
  },
  fm,
  K3
let lc = class j1 extends Error {
  get docsBaseUrl() {
    return 'https://wagmi.sh/core'
  }
  get version() {
    return Pj()
  }
  constructor(e, n = {}) {
    var i
    super(),
      fm.add(this),
      Object.defineProperty(this, 'details', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'docsPath', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'metaMessages', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'shortMessage', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'WagmiCoreError'
      })
    const r =
        n.cause instanceof j1
          ? n.cause.details
          : (i = n.cause) != null && i.message
            ? n.cause.message
            : n.details,
      s = (n.cause instanceof j1 && n.cause.docsPath) || n.docsPath
    ;(this.message = [
      e || 'An error occurred.',
      '',
      ...(n.metaMessages ? [...n.metaMessages, ''] : []),
      ...(s ? [`Docs: ${this.docsBaseUrl}${s}.html${n.docsSlug ? `#${n.docsSlug}` : ''}`] : []),
      ...(r ? [`Details: ${r}`] : []),
      `Version: ${this.version}`
    ].join(`
`)),
      n.cause && (this.cause = n.cause),
      (this.details = r),
      (this.docsPath = s),
      (this.metaMessages = n.metaMessages),
      (this.shortMessage = e)
  }
  walk(e) {
    return W3(this, fm, 'm', K3).call(this, this, e)
  }
}
;(fm = new WeakSet()),
  (K3 = function t(e, n) {
    return n != null && n(e) ? e : e.cause ? W3(this, fm, 'm', t).call(this, e.cause, n) : e
  })
class gf extends lc {
  constructor() {
    super('Chain not configured.'),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ChainNotConfiguredError'
      })
  }
}
class Rj extends lc {
  constructor() {
    super('Connector already connected.'),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ConnectorAlreadyConnectedError'
      })
  }
}
class kj extends lc {
  constructor() {
    super('Connector not connected.'),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ConnectorNotConnectedError'
      })
  }
}
class Oj extends lc {
  constructor({ address: e, connector: n }) {
    super(`Account "${e}" not found for connector "${n.name}".`),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ConnectorAccountNotFoundError'
      })
  }
}
class Bj extends lc {
  constructor({ connectionChainId: e, connectorChainId: n }) {
    super(
      `The current chain of the connector (id: ${n}) does not match the connection's chain (id: ${e}).`,
      { metaMessages: [`Current Chain ID:  ${n}`, `Expected Chain ID: ${e}`] }
    ),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ConnectorChainMismatchError'
      })
  }
}
class Dj extends lc {
  constructor({ connector: e }) {
    super(`Connector "${e.name}" unavailable while reconnecting.`, {
      details: [
        'During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.',
        'All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.',
        'This error commonly occurs for connectors that asynchronously inject after reconnection has already started.'
      ].join(' ')
    }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ConnectorUnavailableReconnectingError'
      })
  }
}
async function rS(t, e) {
  var r
  let n
  if (
    (typeof e.connector == 'function'
      ? (n = t._internal.connectors.setup(e.connector))
      : (n = e.connector),
    n.uid === t.state.current)
  )
    throw new Rj()
  try {
    t.setState(c => ({ ...c, status: 'connecting' })),
      n.emitter.emit('message', { type: 'connecting' })
    const { connector: s, ...i } = e,
      o = await n.connect(i),
      a = o.accounts
    return (
      n.emitter.off('connect', t._internal.events.connect),
      n.emitter.on('change', t._internal.events.change),
      n.emitter.on('disconnect', t._internal.events.disconnect),
      await ((r = t.storage) == null ? void 0 : r.setItem('recentConnectorId', n.id)),
      t.setState(c => ({
        ...c,
        connections: new Map(c.connections).set(n.uid, {
          accounts: a,
          chainId: o.chainId,
          connector: n
        }),
        current: n.uid,
        status: 'connected'
      })),
      { accounts: a, chainId: o.chainId }
    )
  } catch (s) {
    throw (t.setState(i => ({ ...i, status: i.current ? 'connected' : 'disconnected' })), s)
  }
}
const H1 = 256
let Wp = H1,
  Kp
function V3(t = 11) {
  if (!Kp || Wp + t > H1 * 2) {
    ;(Kp = ''), (Wp = 0)
    for (let e = 0; e < H1; e++) Kp += ((256 + Math.random() * 256) | 0).toString(16).substring(1)
  }
  return Kp.substring(Wp, Wp++ + t)
}
function G3(t) {
  const {
      batch: e,
      cacheTime: n = t.pollingInterval ?? 4e3,
      ccipRead: r,
      key: s = 'base',
      name: i = 'Base Client',
      pollingInterval: o = 4e3,
      type: a = 'base'
    } = t,
    c = t.chain,
    u = t.account ? go(t.account) : void 0,
    { config: l, request: d, value: h } = t.transport({ chain: c, pollingInterval: o }),
    p = { ...l, ...h },
    y = {
      account: u,
      batch: e,
      cacheTime: n,
      ccipRead: r,
      chain: c,
      key: s,
      name: i,
      pollingInterval: o,
      request: d,
      transport: p,
      type: a,
      uid: V3()
    }
  function m(b) {
    return I => {
      const x = I(b)
      for (const R in y) delete x[R]
      const _ = { ...b, ...x }
      return Object.assign(_, { extend: m(_) })
    }
  }
  return Object.assign(y, { extend: m(y) })
}
function pA(
  {
    key: t,
    methods: e,
    name: n,
    request: r,
    retryCount: s = 3,
    retryDelay: i = 150,
    timeout: o,
    type: a
  },
  c
) {
  const u = V3()
  return {
    config: {
      key: t,
      methods: e,
      name: n,
      request: r,
      retryCount: s,
      retryDelay: i,
      timeout: o,
      type: a
    },
    request: U7(r, { methods: e, retryCount: s, retryDelay: i, uid: u }),
    value: c
  }
}
function Mj(t, e = {}) {
  const { key: n = 'custom', methods: r, name: s = 'Custom Provider', retryDelay: i } = e
  return ({ retryCount: o }) =>
    pA({
      key: n,
      methods: r,
      name: s,
      request: t.request.bind(t),
      retryCount: e.retryCount ?? o,
      retryDelay: i,
      type: 'custom'
    })
}
function sS(t, e = {}) {
  const {
    key: n = 'fallback',
    name: r = 'Fallback',
    rank: s = !1,
    shouldThrow: i = Uj,
    retryCount: o,
    retryDelay: a
  } = e
  return ({ chain: c, pollingInterval: u = 4e3, timeout: l, ...d }) => {
    let h = t,
      p = () => {}
    const y = pA(
      {
        key: n,
        name: r,
        async request({ method: m, params: b }) {
          let I
          const x = async (_ = 0) => {
            const R = h[_]({ ...d, chain: c, retryCount: 0, timeout: l })
            try {
              const N = await R.request({ method: m, params: b })
              return p({ method: m, params: b, response: N, transport: R, status: 'success' }), N
            } catch (N) {
              if (
                (p({ error: N, method: m, params: b, transport: R, status: 'error' }),
                i(N) ||
                  _ === h.length - 1 ||
                  (I ??
                    (I = h.slice(_ + 1).some(T => {
                      const { include: M, exclude: H } = T({ chain: c }).config.methods || {}
                      return M ? M.includes(m) : H ? !H.includes(m) : !0
                    })),
                  !I))
              )
                throw N
              return x(_ + 1)
            }
          }
          return x()
        },
        retryCount: o,
        retryDelay: a,
        type: 'fallback'
      },
      { onResponse: m => (p = m), transports: h.map(m => m({ chain: c, retryCount: 0 })) }
    )
    if (s) {
      const m = typeof s == 'object' ? s : {}
      Lj({
        chain: c,
        interval: m.interval ?? u,
        onTransports: b => (h = b),
        ping: m.ping,
        sampleCount: m.sampleCount,
        timeout: m.timeout,
        transports: h,
        weights: m.weights
      })
    }
    return y
  }
}
function Uj(t) {
  return !!(
    'code' in t &&
    typeof t.code == 'number' &&
    (t.code === Zl.code || t.code === nr.code || Mc.nodeMessage.test(t.message) || t.code === 5e3)
  )
}
function Lj({
  chain: t,
  interval: e = 4e3,
  onTransports: n,
  ping: r,
  sampleCount: s = 10,
  timeout: i = 1e3,
  transports: o,
  weights: a = {}
}) {
  const { stability: c = 0.7, latency: u = 0.3 } = a,
    l = [],
    d = async () => {
      const h = await Promise.all(
        o.map(async m => {
          const b = m({ chain: t, retryCount: 0, timeout: i }),
            I = Date.now()
          let x, _
          try {
            await (r ? r({ transport: b }) : b.request({ method: 'net_listening' })), (_ = 1)
          } catch {
            _ = 0
          } finally {
            x = Date.now()
          }
          return { latency: x - I, success: _ }
        })
      )
      l.push(h), l.length > s && l.shift()
      const p = Math.max(...l.map(m => Math.max(...m.map(({ latency: b }) => b)))),
        y = o
          .map((m, b) => {
            const I = l.map(T => T[b].latency),
              _ = 1 - I.reduce((T, M) => T + M, 0) / I.length / p,
              R = l.map(T => T[b].success),
              N = R.reduce((T, M) => T + M, 0) / R.length
            return N === 0 ? [0, b] : [u * _ + c * N, b]
          })
          .sort((m, b) => b[0] - m[0])
      n(y.map(([, m]) => o[m])), await lm(e), d()
    }
  d()
}
class $j extends Se {
  constructor() {
    super(
      'No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.',
      { docsPath: '/docs/clients/intro', name: 'UrlRequiredError' }
    )
  }
}
function Vp(t, e = {}) {
  const {
    batch: n,
    fetchOptions: r,
    key: s = 'http',
    methods: i,
    name: o = 'HTTP JSON-RPC',
    onFetchRequest: a,
    onFetchResponse: c,
    retryDelay: u,
    raw: l
  } = e
  return ({ chain: d, retryCount: h, timeout: p }) => {
    const { batchSize: y = 1e3, wait: m = 0 } = typeof n == 'object' ? n : {},
      b = e.retryCount ?? h,
      I = p ?? e.timeout ?? 1e4,
      x = t || (d == null ? void 0 : d.rpcUrls.default.http[0])
    if (!x) throw new $j()
    const _ = F7(x, { fetchOptions: r, onRequest: a, onResponse: c, timeout: I })
    return pA(
      {
        key: s,
        methods: i,
        name: o,
        async request({ method: R, params: N }) {
          const T = { method: R, params: N },
            { schedule: M } = _3({
              id: x,
              wait: m,
              shouldSplitBatch(D) {
                return D.length > y
              },
              fn: D => _.request({ body: D }),
              sort: (D, W) => D.id - W.id
            }),
            H = async D => (n ? M(D) : [await _.request({ body: D })]),
            [{ error: B, result: $ }] = await H(T)
          if (l) return { error: B, result: $ }
          if (B) throw new WE({ body: T, error: B, url: x })
          return $
        },
        retryCount: b,
        retryDelay: u,
        timeout: I,
        type: 'http'
      },
      { fetchOptions: r, url: x }
    )
  }
}
async function x0(t, e = {}) {
  let n
  if (e.connector) {
    const { connector: u } = e
    if (t.state.status === 'reconnecting' && !u.getAccounts && !u.getChainId)
      throw new Dj({ connector: u })
    const [l, d] = await Promise.all([
      u.getAccounts().catch(h => {
        if (e.account === null) return []
        throw h
      }),
      u.getChainId()
    ])
    n = { accounts: l, chainId: d, connector: u }
  } else n = t.state.connections.get(t.state.current)
  if (!n) throw new kj()
  const r = e.chainId ?? n.chainId,
    s = await n.connector.getChainId()
  if (s !== n.chainId) throw new Bj({ connectionChainId: n.chainId, connectorChainId: s })
  const i = n.connector
  if (i.getClient) return i.getClient({ chainId: r })
  const o = go(e.account ?? n.accounts[0])
  if (
    (o && (o.address = Dc(o.address)),
    e.account && !n.accounts.some(u => u.toLowerCase() === o.address.toLowerCase()))
  )
    throw new Oj({ address: o.address, connector: i })
  const a = t.chains.find(u => u.id === r),
    c = await n.connector.getProvider({ chainId: r })
  return G3({
    account: o,
    chain: a,
    name: 'Connector Client',
    transport: u => Mj(c)({ ...u, retryCount: 0 })
  })
}
async function Fj(t, e = {}) {
  var s, i
  let n
  if (e.connector) n = e.connector
  else {
    const { connections: o, current: a } = t.state,
      c = o.get(a)
    n = c == null ? void 0 : c.connector
  }
  const r = t.state.connections
  n &&
    (await n.disconnect(),
    n.emitter.off('change', t._internal.events.change),
    n.emitter.off('disconnect', t._internal.events.disconnect),
    n.emitter.on('connect', t._internal.events.connect),
    r.delete(n.uid)),
    t.setState(o => {
      if (r.size === 0)
        return { ...o, connections: new Map(), current: null, status: 'disconnected' }
      const a = r.values().next().value
      return { ...o, connections: new Map(r), current: a.connector.uid }
    })
  {
    const o = t.state.current
    if (!o) return
    const a = (s = t.state.connections.get(o)) == null ? void 0 : s.connector
    if (!a) return
    await ((i = t.storage) == null ? void 0 : i.setItem('recentConnectorId', a.id))
  }
}
async function jj(t, e) {
  const { chainId: n, connector: r, ...s } = e
  let i
  e.account
    ? (i = e.account)
    : (i = (await x0(t, { account: e.account, chainId: n, connector: r })).account)
  const o = t.getClient({ chainId: n })
  return cs(o, zR, 'estimateGas')({ ...s, account: i })
}
function Q3(t) {
  return typeof t == 'number' ? t : t === 'wei' ? 0 : Math.abs(j$[t])
}
function pm(t) {
  const e = t.state.current,
    n = t.state.connections.get(e),
    r = n == null ? void 0 : n.accounts,
    s = r == null ? void 0 : r[0],
    i = t.chains.find(a => a.id === (n == null ? void 0 : n.chainId)),
    o = t.state.status
  switch (o) {
    case 'connected':
      return {
        address: s,
        addresses: r,
        chain: i,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !0,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !1,
        status: o
      }
    case 'reconnecting':
      return {
        address: s,
        addresses: r,
        chain: i,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !!s,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !0,
        status: o
      }
    case 'connecting':
      return {
        address: s,
        addresses: r,
        chain: i,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !1,
        isConnecting: !0,
        isDisconnected: !1,
        isReconnecting: !1,
        status: o
      }
    case 'disconnected':
      return {
        address: void 0,
        addresses: void 0,
        chain: void 0,
        chainId: void 0,
        connector: void 0,
        isConnected: !1,
        isConnecting: !1,
        isDisconnected: !0,
        isReconnecting: !1,
        status: o
      }
  }
}
async function Hj(t, e) {
  const { allowFailure: n = !0, chainId: r, contracts: s, ...i } = e,
    o = t.getClient({ chainId: r })
  return cs(o, S7, 'multicall')({ allowFailure: n, contracts: s, ...i })
}
function qj(t, e) {
  const { chainId: n, ...r } = e,
    s = t.getClient({ chainId: n })
  return cs(s, cu, 'readContract')(r)
}
async function zj(t, e) {
  var a
  const { allowFailure: n = !0, blockNumber: r, blockTag: s, ...i } = e,
    o = e.contracts
  try {
    const c = {}
    for (const [h, p] of o.entries()) {
      const y = p.chainId ?? t.state.chainId
      c[y] || (c[y] = []), (a = c[y]) == null || a.push({ contract: p, index: h })
    }
    const u = () =>
        Object.entries(c).map(([h, p]) =>
          Hj(t, {
            ...i,
            allowFailure: n,
            blockNumber: r,
            blockTag: s,
            chainId: Number.parseInt(h),
            contracts: p.map(({ contract: y }) => y)
          })
        ),
      l = (await Promise.all(u())).flat(),
      d = Object.values(c).flatMap(h => h.map(({ index: p }) => p))
    return l.reduce((h, p, y) => (h && (h[d[y]] = p), h), [])
  } catch (c) {
    if (c instanceof v3) throw c
    const u = () => o.map(l => qj(t, { ...l, blockNumber: r, blockTag: s }))
    return n
      ? (await Promise.allSettled(u())).map(l =>
          l.status === 'fulfilled'
            ? { result: l.value, status: 'success' }
            : { error: l.reason, result: void 0, status: 'failure' }
        )
      : await Promise.all(u())
  }
}
async function Wj(t, e) {
  const { address: n, blockNumber: r, blockTag: s, chainId: i, token: o, unit: a = 'ether' } = e
  if (o)
    try {
      return await iS(t, { balanceAddress: n, chainId: i, symbolType: 'string', tokenAddress: o })
    } catch (h) {
      if (h.name === 'ContractFunctionExecutionError') {
        const p = await iS(t, {
            balanceAddress: n,
            chainId: i,
            symbolType: 'bytes32',
            tokenAddress: o
          }),
          y = aR(io(p.symbol, { dir: 'right' }))
        return { ...p, symbol: y }
      }
      throw h
    }
  const c = t.getClient({ chainId: i }),
    l = await cs(
      c,
      qR,
      'getBalance'
    )(r ? { address: n, blockNumber: r } : { address: n, blockTag: s }),
    d = t.chains.find(h => h.id === i) ?? c.chain
  return {
    decimals: d.nativeCurrency.decimals,
    formatted: bd(l, Q3(a)),
    symbol: d.nativeCurrency.symbol,
    value: l
  }
}
async function iS(t, e) {
  const { balanceAddress: n, chainId: r, symbolType: s, tokenAddress: i, unit: o } = e,
    a = {
      abi: [
        {
          type: 'function',
          name: 'balanceOf',
          stateMutability: 'view',
          inputs: [{ type: 'address' }],
          outputs: [{ type: 'uint256' }]
        },
        {
          type: 'function',
          name: 'decimals',
          stateMutability: 'view',
          inputs: [],
          outputs: [{ type: 'uint8' }]
        },
        {
          type: 'function',
          name: 'symbol',
          stateMutability: 'view',
          inputs: [],
          outputs: [{ type: s }]
        }
      ],
      address: i
    },
    [c, u, l] = await zj(t, {
      allowFailure: !1,
      contracts: [
        { ...a, functionName: 'balanceOf', args: [n], chainId: r },
        { ...a, functionName: 'decimals', chainId: r },
        { ...a, functionName: 'symbol', chainId: r }
      ]
    }),
    d = bd(c ?? '0', Q3(o ?? u))
  return { decimals: u, formatted: d, symbol: l, value: c }
}
function gm(t, e) {
  if (t === e) return !0
  if (t && e && typeof t == 'object' && typeof e == 'object') {
    if (t.constructor !== e.constructor) return !1
    let n, r
    if (Array.isArray(t) && Array.isArray(e)) {
      if (((n = t.length), n !== e.length)) return !1
      for (r = n; r-- !== 0; ) if (!gm(t[r], e[r])) return !1
      return !0
    }
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === e.valueOf()
    if (t.toString !== Object.prototype.toString) return t.toString() === e.toString()
    const s = Object.keys(t)
    if (((n = s.length), n !== Object.keys(e).length)) return !1
    for (r = n; r-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(e, s[r])) return !1
    for (r = n; r-- !== 0; ) {
      const i = s[r]
      if (i && !gm(t[i], e[i])) return !1
    }
    return !0
  }
  return t !== t && e !== e
}
let Gp = []
function gc(t) {
  const e = [...t.state.connections.values()]
  return t.state.status === 'reconnecting' || gm(Gp, e) ? Gp : ((Gp = e), e)
}
function Kj(t, e) {
  const { chainId: n, ...r } = e,
    s = t.getClient({ chainId: n })
  return cs(s, V9, 'getEnsAddress')(r)
}
function Vj(t, e) {
  const { chainId: n, ...r } = e,
    s = t.getClient({ chainId: n })
  return cs(s, a7, 'getEnsAvatar')(r)
}
function Gj(t, e) {
  const { chainId: n, ...r } = e,
    s = t.getClient({ chainId: n })
  return cs(s, c7, 'getEnsName')(r)
}
async function Qj(t, e) {
  const { account: n, chainId: r, ...s } = e,
    i = n ?? pm(t).address,
    o = t.getClient({ chainId: r })
  return cs(o, eA, 'prepareTransactionRequest')({ ...s, ...(i ? { account: i } : {}) })
}
let pw = !1
async function q1(t, e = {}) {
  var u, l
  if (pw) return []
  ;(pw = !0), t.setState(d => ({ ...d, status: d.current ? 'reconnecting' : 'connecting' }))
  const n = []
  if ((u = e.connectors) != null && u.length)
    for (const d of e.connectors) {
      let h
      typeof d == 'function' ? (h = t._internal.connectors.setup(d)) : (h = d), n.push(h)
    }
  else n.push(...t.connectors)
  let r
  try {
    r = await ((l = t.storage) == null ? void 0 : l.getItem('recentConnectorId'))
  } catch {}
  const s = {}
  for (const [, d] of t.state.connections) s[d.connector.id] = 1
  r && (s[r] = 0)
  const i = Object.keys(s).length > 0 ? [...n].sort((d, h) => (s[d.id] ?? 10) - (s[h.id] ?? 10)) : n
  let o = !1
  const a = [],
    c = []
  for (const d of i) {
    const h = await d.getProvider().catch(() => {})
    if (!h || c.some(m => m === h) || !(await d.isAuthorized())) continue
    const y = await d.connect({ isReconnecting: !0 }).catch(() => null)
    y &&
      (d.emitter.off('connect', t._internal.events.connect),
      d.emitter.on('change', t._internal.events.change),
      d.emitter.on('disconnect', t._internal.events.disconnect),
      t.setState(m => {
        const b = new Map(o ? m.connections : new Map()).set(d.uid, {
          accounts: y.accounts,
          chainId: y.chainId,
          connector: d
        })
        return { ...m, current: o ? m.current : d.uid, connections: b }
      }),
      a.push({ accounts: y.accounts, chainId: y.chainId, connector: d }),
      c.push(h),
      (o = !0))
  }
  return (
    (t.state.status === 'reconnecting' || t.state.status === 'connecting') &&
      (o
        ? t.setState(d => ({ ...d, status: 'connected' }))
        : t.setState(d => ({
            ...d,
            connections: new Map(),
            current: null,
            status: 'disconnected'
          }))),
    (pw = !1),
    a
  )
}
async function Zj(t, e) {
  const { account: n, chainId: r, connector: s, ...i } = e
  let o
  return (
    typeof n == 'object' && (n == null ? void 0 : n.type) === 'local'
      ? (o = t.getClient({ chainId: r }))
      : (o = await x0(t, { account: n ?? void 0, chainId: r, connector: s })),
    await cs(
      o,
      e3,
      'sendTransaction'
    )({ ...i, ...(n ? { account: n } : {}), chain: r ? { id: r } : null, gas: i.gas ?? void 0 })
  )
}
async function Yj(t, e) {
  const { account: n, connector: r, ...s } = e
  let i
  return (
    typeof n == 'object' && n.type === 'local'
      ? (i = t.getClient())
      : (i = await x0(t, { account: n, connector: r })),
    cs(i, ij, 'signMessage')({ ...s, ...(n ? { account: n } : {}) })
  )
}
class Aa extends lc {
  constructor() {
    super('Provider not found.'),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'ProviderNotFoundError'
      })
  }
}
class Jj extends lc {
  constructor({ connector: e }) {
    super(`"${e.name}" does not support programmatic chain switching.`),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'SwitchChainNotSupportedError'
      })
  }
}
async function oS(t, e) {
  var o
  const { addEthereumChainParameter: n, chainId: r } = e,
    s = t.state.connections.get(((o = e.connector) == null ? void 0 : o.uid) ?? t.state.current)
  if (s) {
    const a = s.connector
    if (!a.switchChain) throw new Jj({ connector: a })
    return await a.switchChain({ addEthereumChainParameter: n, chainId: r })
  }
  const i = t.chains.find(a => a.id === r)
  if (!i) throw new gf()
  return t.setState(a => ({ ...a, chainId: r })), i
}
function Xj(t, e) {
  const { onChange: n } = e
  return t.subscribe(() => pm(t), n, {
    equalityFn(r, s) {
      const { connector: i, ...o } = r,
        { connector: a, ...c } = s
      return (
        gm(o, c) &&
        (i == null ? void 0 : i.id) === (a == null ? void 0 : a.id) &&
        (i == null ? void 0 : i.uid) === (a == null ? void 0 : a.uid)
      )
    }
  })
}
function eH(t, e) {
  const { onChange: n } = e
  return t._internal.connectors.subscribe((r, s) => {
    n(Object.values(r), s)
  })
}
function tH(t, e) {
  const { syncConnectedChain: n = t._internal.syncConnectedChain, ...r } = e
  let s
  const i = c => {
      s && s()
      const u = t.getClient({ chainId: c })
      return (s = cs(u, rj, 'watchPendingTransactions')(r)), s
    },
    o = i(e.chainId)
  let a
  return (
    n &&
      !e.chainId &&
      (a = t.subscribe(
        ({ chainId: c }) => c,
        async c => i(c)
      )),
    () => {
      o == null || o(), a == null || a()
    }
  )
}
async function nH(t, e) {
  const { chainId: n, timeout: r = 0, ...s } = e,
    i = t.getClient({ chainId: n }),
    a = await cs(i, sj, 'waitForTransactionReceipt')({ ...s, timeout: r })
  if (a.status === 'reverted') {
    const u = await cs(i, T3, 'getTransaction')({ hash: a.transactionHash }),
      d = await cs(
        i,
        C3,
        'call'
      )({
        ...u,
        data: u.input,
        gasPrice: u.type !== 'eip1559' ? u.gasPrice : void 0,
        maxFeePerGas: u.type === 'eip1559' ? u.maxFeePerGas : void 0,
        maxPriorityFeePerGas: u.type === 'eip1559' ? u.maxPriorityFeePerGas : void 0
      }),
      h = d != null && d.data ? aR(`0x${d.data.substring(138)}`) : 'unknown reason'
    throw new Error(h)
  }
  return { ...a, chainId: i.chain.id }
}
async function rH(t, e) {
  const { account: n, chainId: r, connector: s, ...i } = e
  let o
  return (
    typeof n == 'object' && (n == null ? void 0 : n.type) === 'local'
      ? (o = t.getClient({ chainId: r }))
      : (o = await x0(t, { account: n ?? void 0, chainId: r, connector: s })),
    await cs(
      o,
      Nj,
      'writeContract'
    )({ ...i, ...(n ? { account: n } : {}), chain: r ? { id: r } : null })
  )
}
function Bge(t) {
  return t
}
T0.type = 'injected'
function T0(t = {}) {
  const { shimDisconnect: e = !0, unstable_shimAsyncInject: n } = t
  function r() {
    const c = t.target
    if (typeof c == 'function') {
      const u = c()
      if (u) return u
    }
    return typeof c == 'object'
      ? c
      : typeof c == 'string'
        ? {
            ...(sH[c] ?? {
              id: c,
              name: `${c[0].toUpperCase()}${c.slice(1)}`,
              provider: `is${c[0].toUpperCase()}${c.slice(1)}`
            })
          }
        : {
            id: 'injected',
            name: 'Injected',
            provider(u) {
              return u == null ? void 0 : u.ethereum
            }
          }
  }
  let s, i, o, a
  return c => ({
    get icon() {
      return r().icon
    },
    get id() {
      return r().id
    },
    get name() {
      return r().name
    },
    get supportsSimulation() {
      return !0
    },
    type: T0.type,
    async setup() {
      const u = await this.getProvider()
      u != null &&
        u.on &&
        t.target &&
        (o || ((o = this.onConnect.bind(this)), u.on('connect', o)),
        s || ((s = this.onAccountsChanged.bind(this)), u.on('accountsChanged', s)))
    },
    async connect({ chainId: u, isReconnecting: l } = {}) {
      var p, y, m, b, I, x
      const d = await this.getProvider()
      if (!d) throw new Aa()
      let h = []
      if (l) h = await this.getAccounts().catch(() => [])
      else if (e)
        try {
          ;(h =
            (b =
              (m =
                (y =
                  (p = (
                    await d.request({
                      method: 'wallet_requestPermissions',
                      params: [{ eth_accounts: {} }]
                    })
                  )[0]) == null
                    ? void 0
                    : p.caveats) == null
                  ? void 0
                  : y[0]) == null
                ? void 0
                : m.value) == null
              ? void 0
              : b.map(R => Dc(R))),
            h.length > 0 && (h = await this.getAccounts())
        } catch (_) {
          const R = _
          if (R.code === nr.code) throw new nr(R)
          if (R.code === Ha.code) throw R
        }
      try {
        !(h != null && h.length) &&
          !l &&
          (h = (await d.request({ method: 'eth_requestAccounts' })).map(N => Dc(N))),
          o && (d.removeListener('connect', o), (o = void 0)),
          s || ((s = this.onAccountsChanged.bind(this)), d.on('accountsChanged', s)),
          i || ((i = this.onChainChanged.bind(this)), d.on('chainChanged', i)),
          a || ((a = this.onDisconnect.bind(this)), d.on('disconnect', a))
        let _ = await this.getChainId()
        if (u && _ !== u) {
          const R = await this.switchChain({ chainId: u }).catch(N => {
            if (N.code === nr.code) throw N
            return { id: _ }
          })
          _ = (R == null ? void 0 : R.id) ?? _
        }
        return (
          e && (await ((I = c.storage) == null ? void 0 : I.removeItem(`${this.id}.disconnected`))),
          t.target ||
            (await ((x = c.storage) == null ? void 0 : x.setItem('injected.connected', !0))),
          { accounts: h, chainId: _ }
        )
      } catch (_) {
        const R = _
        throw R.code === nr.code ? new nr(R) : R.code === Ha.code ? new Ha(R) : R
      }
    },
    async disconnect() {
      var l, d
      const u = await this.getProvider()
      if (!u) throw new Aa()
      i && (u.removeListener('chainChanged', i), (i = void 0)),
        a && (u.removeListener('disconnect', a), (a = void 0)),
        o || ((o = this.onConnect.bind(this)), u.on('connect', o))
      try {
        await k3(
          () => u.request({ method: 'wallet_revokePermissions', params: [{ eth_accounts: {} }] }),
          { timeout: 100 }
        )
      } catch {}
      e && (await ((l = c.storage) == null ? void 0 : l.setItem(`${this.id}.disconnected`, !0))),
        t.target || (await ((d = c.storage) == null ? void 0 : d.removeItem('injected.connected')))
    },
    async getAccounts() {
      const u = await this.getProvider()
      if (!u) throw new Aa()
      return (await u.request({ method: 'eth_accounts' })).map(d => Dc(d))
    },
    async getChainId() {
      const u = await this.getProvider()
      if (!u) throw new Aa()
      const l = await u.request({ method: 'eth_chainId' })
      return Number(l)
    },
    async getProvider() {
      if (typeof window > 'u') return
      let u
      const l = r()
      return (
        typeof l.provider == 'function'
          ? (u = l.provider(window))
          : typeof l.provider == 'string'
            ? (u = Pg(window, l.provider))
            : (u = l.provider),
        u &&
          !u.removeListener &&
          ('off' in u && typeof u.off == 'function'
            ? (u.removeListener = u.off)
            : (u.removeListener = () => {})),
        u
      )
    },
    async isAuthorized() {
      var u, l
      try {
        if (
          (e &&
            (await ((u = c.storage) == null ? void 0 : u.getItem(`${this.id}.disconnected`)))) ||
          (!t.target &&
            !(await ((l = c.storage) == null ? void 0 : l.getItem('injected.connected'))))
        )
          return !1
        if (!(await this.getProvider())) {
          if (n !== void 0 && n !== !1) {
            const y = async () => (
                typeof window < 'u' && window.removeEventListener('ethereum#initialized', y),
                !!(await this.getProvider())
              ),
              m = typeof n == 'number' ? n : 1e3
            if (
              await Promise.race([
                ...(typeof window < 'u'
                  ? [
                      new Promise(I =>
                        window.addEventListener('ethereum#initialized', () => I(y()), { once: !0 })
                      )
                    ]
                  : []),
                new Promise(I => setTimeout(() => I(y()), m))
              ])
            )
              return !0
          }
          throw new Aa()
        }
        return !!(await dm(() => this.getAccounts())).length
      } catch {
        return !1
      }
    },
    async switchChain({ addEthereumChainParameter: u, chainId: l }) {
      var y, m, b, I
      const d = await this.getProvider()
      if (!d) throw new Aa()
      const h = c.chains.find(x => x.id === l)
      if (!h) throw new ao(new gf())
      const p = new Promise(x => {
        const _ = R => {
          'chainId' in R && R.chainId === l && (c.emitter.off('change', _), x())
        }
        c.emitter.on('change', _)
      })
      try {
        return (
          await Promise.all([
            d
              .request({ method: 'wallet_switchEthereumChain', params: [{ chainId: Mt(l) }] })
              .then(async () => {
                ;(await this.getChainId()) === l && c.emitter.emit('change', { chainId: l })
              }),
            p
          ]),
          h
        )
      } catch (x) {
        const _ = x
        if (
          _.code === 4902 ||
          ((m = (y = _ == null ? void 0 : _.data) == null ? void 0 : y.originalError) == null
            ? void 0
            : m.code) === 4902
        )
          try {
            const { default: R, ...N } = h.blockExplorers ?? {}
            let T
            u != null && u.blockExplorerUrls
              ? (T = u.blockExplorerUrls)
              : R && (T = [R.url, ...Object.values(N).map(B => B.url)])
            let M
            ;(b = u == null ? void 0 : u.rpcUrls) != null && b.length
              ? (M = u.rpcUrls)
              : (M = [((I = h.rpcUrls.default) == null ? void 0 : I.http[0]) ?? ''])
            const H = {
              blockExplorerUrls: T,
              chainId: Mt(l),
              chainName: (u == null ? void 0 : u.chainName) ?? h.name,
              iconUrls: u == null ? void 0 : u.iconUrls,
              nativeCurrency: (u == null ? void 0 : u.nativeCurrency) ?? h.nativeCurrency,
              rpcUrls: M
            }
            return (
              await Promise.all([
                d.request({ method: 'wallet_addEthereumChain', params: [H] }).then(async () => {
                  if ((await this.getChainId()) === l) c.emitter.emit('change', { chainId: l })
                  else throw new nr(new Error('User rejected switch after adding network.'))
                }),
                p
              ]),
              h
            )
          } catch (R) {
            throw new nr(R)
          }
        throw _.code === nr.code ? new nr(_) : new ao(_)
      }
    },
    async onAccountsChanged(u) {
      var l
      if (u.length === 0) this.onDisconnect()
      else if (c.emitter.listenerCount('connect')) {
        const d = (await this.getChainId()).toString()
        this.onConnect({ chainId: d }),
          e && (await ((l = c.storage) == null ? void 0 : l.removeItem(`${this.id}.disconnected`)))
      } else c.emitter.emit('change', { accounts: u.map(d => Dc(d)) })
    },
    onChainChanged(u) {
      const l = Number(u)
      c.emitter.emit('change', { chainId: l })
    },
    async onConnect(u) {
      const l = await this.getAccounts()
      if (l.length === 0) return
      const d = Number(u.chainId)
      c.emitter.emit('connect', { accounts: l, chainId: d })
      const h = await this.getProvider()
      h &&
        (o && (h.removeListener('connect', o), (o = void 0)),
        s || ((s = this.onAccountsChanged.bind(this)), h.on('accountsChanged', s)),
        i || ((i = this.onChainChanged.bind(this)), h.on('chainChanged', i)),
        a || ((a = this.onDisconnect.bind(this)), h.on('disconnect', a)))
    },
    async onDisconnect(u) {
      const l = await this.getProvider()
      ;(u && u.code === 1013 && l && (await this.getAccounts()).length) ||
        (c.emitter.emit('disconnect'),
        l &&
          (i && (l.removeListener('chainChanged', i), (i = void 0)),
          a && (l.removeListener('disconnect', a), (a = void 0)),
          o || ((o = this.onConnect.bind(this)), l.on('connect', o))))
    }
  })
}
const sH = {
  coinbaseWallet: {
    id: 'coinbaseWallet',
    name: 'Coinbase Wallet',
    provider(t) {
      return t != null && t.coinbaseWalletExtension
        ? t.coinbaseWalletExtension
        : Pg(t, 'isCoinbaseWallet')
    }
  },
  metaMask: {
    id: 'metaMask',
    name: 'MetaMask',
    provider(t) {
      return Pg(t, e => {
        if (!e.isMetaMask || (e.isBraveWallet && !e._events && !e._state)) return !1
        const n = [
          'isApexWallet',
          'isAvalanche',
          'isBitKeep',
          'isBlockWallet',
          'isKuCoinWallet',
          'isMathWallet',
          'isOkxWallet',
          'isOKExWallet',
          'isOneInchIOSWallet',
          'isOneInchAndroidWallet',
          'isOpera',
          'isPhantom',
          'isPortal',
          'isRabby',
          'isTokenPocket',
          'isTokenary',
          'isUniswapWallet',
          'isZerion'
        ]
        for (const r of n) if (e[r]) return !1
        return !0
      })
    }
  },
  phantom: {
    id: 'phantom',
    name: 'Phantom',
    provider(t) {
      var e, n
      return (e = t == null ? void 0 : t.phantom) != null && e.ethereum
        ? (n = t.phantom) == null
          ? void 0
          : n.ethereum
        : Pg(t, 'isPhantom')
    }
  }
}
function Pg(t, e) {
  function n(s) {
    return typeof e == 'function' ? e(s) : typeof e == 'string' ? s[e] : !0
  }
  const r = t.ethereum
  if (r != null && r.providers) return r.providers.find(s => n(s))
  if (r && n(r)) return r
}
function iH(t) {
  if (typeof window > 'u') return
  const e = n => t(n.detail)
  return (
    window.addEventListener('eip6963:announceProvider', e),
    window.dispatchEvent(new CustomEvent('eip6963:requestProvider')),
    () => window.removeEventListener('eip6963:announceProvider', e)
  )
}
function oH() {
  const t = new Set()
  let e = []
  const n = () =>
    iH(s => {
      e.some(({ info: i }) => i.uuid === s.info.uuid) ||
        ((e = [...e, s]), t.forEach(i => i(e, { added: [s] })))
    })
  let r = n()
  return {
    _listeners() {
      return t
    },
    clear() {
      t.forEach(s => s([], { removed: [...e] })), (e = [])
    },
    destroy() {
      this.clear(), t.clear(), r == null || r()
    },
    findProvider({ rdns: s }) {
      return e.find(i => i.info.rdns === s)
    },
    getProviders() {
      return e
    },
    reset() {
      this.clear(), r == null || r(), (r = n())
    },
    subscribe(s, { emitImmediately: i } = {}) {
      return t.add(s), i && s(e, { added: e }), () => t.delete(s)
    }
  }
}
const aH = t => (e, n, r) => {
    const s = r.subscribe
    return (
      (r.subscribe = (o, a, c) => {
        let u = o
        if (a) {
          const l = (c == null ? void 0 : c.equalityFn) || Object.is
          let d = o(r.getState())
          ;(u = h => {
            const p = o(h)
            if (!l(d, p)) {
              const y = d
              a((d = p), y)
            }
          }),
            c != null && c.fireImmediately && a(d, d)
        }
        return s(u)
      }),
      t(e, n, r)
    )
  },
  cH = aH
function uH(t, e) {
  let n
  try {
    n = t()
  } catch {
    return
  }
  return {
    getItem: s => {
      var i
      const o = c => (c === null ? null : JSON.parse(c, void 0)),
        a = (i = n.getItem(s)) != null ? i : null
      return a instanceof Promise ? a.then(o) : o(a)
    },
    setItem: (s, i) => n.setItem(s, JSON.stringify(i, void 0)),
    removeItem: s => n.removeItem(s)
  }
}
const z1 = t => e => {
    try {
      const n = t(e)
      return n instanceof Promise
        ? n
        : {
            then(r) {
              return z1(r)(n)
            },
            catch(r) {
              return this
            }
          }
    } catch (n) {
      return {
        then(r) {
          return this
        },
        catch(r) {
          return z1(r)(n)
        }
      }
    }
  },
  lH = (t, e) => (n, r, s) => {
    let i = {
        storage: uH(() => localStorage),
        partialize: m => m,
        version: 0,
        merge: (m, b) => ({ ...b, ...m }),
        ...e
      },
      o = !1
    const a = new Set(),
      c = new Set()
    let u = i.storage
    if (!u)
      return t(
        (...m) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${i.name}', the given storage is currently unavailable.`
          ),
            n(...m)
        },
        r,
        s
      )
    const l = () => {
        const m = i.partialize({ ...r() })
        return u.setItem(i.name, { state: m, version: i.version })
      },
      d = s.setState
    s.setState = (m, b) => {
      d(m, b), l()
    }
    const h = t(
      (...m) => {
        n(...m), l()
      },
      r,
      s
    )
    s.getInitialState = () => h
    let p
    const y = () => {
      var m, b
      if (!u) return
      ;(o = !1),
        a.forEach(x => {
          var _
          return x((_ = r()) != null ? _ : h)
        })
      const I =
        ((b = i.onRehydrateStorage) == null ? void 0 : b.call(i, (m = r()) != null ? m : h)) ||
        void 0
      return z1(u.getItem.bind(u))(i.name)
        .then(x => {
          if (x)
            if (typeof x.version == 'number' && x.version !== i.version) {
              if (i.migrate) return [!0, i.migrate(x.state, x.version)]
              console.error(
                "State loaded from storage couldn't be migrated since no migrate function was provided"
              )
            } else return [!1, x.state]
          return [!1, void 0]
        })
        .then(x => {
          var _
          const [R, N] = x
          if (((p = i.merge(N, (_ = r()) != null ? _ : h)), n(p, !0), R)) return l()
        })
        .then(() => {
          I == null || I(p, void 0), (p = r()), (o = !0), c.forEach(x => x(p))
        })
        .catch(x => {
          I == null || I(void 0, x)
        })
    }
    return (
      (s.persist = {
        setOptions: m => {
          ;(i = { ...i, ...m }), m.storage && (u = m.storage)
        },
        clearStorage: () => {
          u == null || u.removeItem(i.name)
        },
        getOptions: () => i,
        rehydrate: () => y(),
        hasHydrated: () => o,
        onHydrate: m => (
          a.add(m),
          () => {
            a.delete(m)
          }
        ),
        onFinishHydration: m => (
          c.add(m),
          () => {
            c.delete(m)
          }
        )
      }),
      i.skipHydration || y(),
      p || h
    )
  },
  dH = lH,
  aS = t => {
    let e
    const n = new Set(),
      r = (u, l) => {
        const d = typeof u == 'function' ? u(e) : u
        if (!Object.is(d, e)) {
          const h = e
          ;(e = (l ?? (typeof d != 'object' || d === null)) ? d : Object.assign({}, e, d)),
            n.forEach(p => p(e, h))
        }
      },
      s = () => e,
      a = {
        setState: r,
        getState: s,
        getInitialState: () => c,
        subscribe: u => (n.add(u), () => n.delete(u))
      },
      c = (e = t(r, s, a))
    return a
  },
  gw = t => (t ? aS(t) : aS)
var Yi =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
      ? window
      : typeof global < 'u'
        ? global
        : typeof self < 'u'
          ? self
          : {}
function _u(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t
}
function N0(t) {
  if (Object.prototype.hasOwnProperty.call(t, '__esModule')) return t
  var e = t.default
  if (typeof e == 'function') {
    var n = function r() {
      return this instanceof r
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments)
    }
    n.prototype = e.prototype
  } else n = {}
  return (
    Object.defineProperty(n, '__esModule', { value: !0 }),
    Object.keys(t).forEach(function (r) {
      var s = Object.getOwnPropertyDescriptor(t, r)
      Object.defineProperty(
        n,
        r,
        s.get
          ? s
          : {
              enumerable: !0,
              get: function () {
                return t[r]
              }
            }
      )
    }),
    n
  )
}
var mw = { exports: {} },
  cS
function hH() {
  return (
    cS ||
      ((cS = 1),
      (function (t) {
        var e = Object.prototype.hasOwnProperty,
          n = '~'
        function r() {}
        Object.create && ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1))
        function s(c, u, l) {
          ;(this.fn = c), (this.context = u), (this.once = l || !1)
        }
        function i(c, u, l, d, h) {
          if (typeof l != 'function') throw new TypeError('The listener must be a function')
          var p = new s(l, d || c, h),
            y = n ? n + u : u
          return (
            c._events[y]
              ? c._events[y].fn
                ? (c._events[y] = [c._events[y], p])
                : c._events[y].push(p)
              : ((c._events[y] = p), c._eventsCount++),
            c
          )
        }
        function o(c, u) {
          --c._eventsCount === 0 ? (c._events = new r()) : delete c._events[u]
        }
        function a() {
          ;(this._events = new r()), (this._eventsCount = 0)
        }
        ;(a.prototype.eventNames = function () {
          var u = [],
            l,
            d
          if (this._eventsCount === 0) return u
          for (d in (l = this._events)) e.call(l, d) && u.push(n ? d.slice(1) : d)
          return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(l)) : u
        }),
          (a.prototype.listeners = function (u) {
            var l = n ? n + u : u,
              d = this._events[l]
            if (!d) return []
            if (d.fn) return [d.fn]
            for (var h = 0, p = d.length, y = new Array(p); h < p; h++) y[h] = d[h].fn
            return y
          }),
          (a.prototype.listenerCount = function (u) {
            var l = n ? n + u : u,
              d = this._events[l]
            return d ? (d.fn ? 1 : d.length) : 0
          }),
          (a.prototype.emit = function (u, l, d, h, p, y) {
            var m = n ? n + u : u
            if (!this._events[m]) return !1
            var b = this._events[m],
              I = arguments.length,
              x,
              _
            if (b.fn) {
              switch ((b.once && this.removeListener(u, b.fn, void 0, !0), I)) {
                case 1:
                  return b.fn.call(b.context), !0
                case 2:
                  return b.fn.call(b.context, l), !0
                case 3:
                  return b.fn.call(b.context, l, d), !0
                case 4:
                  return b.fn.call(b.context, l, d, h), !0
                case 5:
                  return b.fn.call(b.context, l, d, h, p), !0
                case 6:
                  return b.fn.call(b.context, l, d, h, p, y), !0
              }
              for (_ = 1, x = new Array(I - 1); _ < I; _++) x[_ - 1] = arguments[_]
              b.fn.apply(b.context, x)
            } else {
              var R = b.length,
                N
              for (_ = 0; _ < R; _++)
                switch ((b[_].once && this.removeListener(u, b[_].fn, void 0, !0), I)) {
                  case 1:
                    b[_].fn.call(b[_].context)
                    break
                  case 2:
                    b[_].fn.call(b[_].context, l)
                    break
                  case 3:
                    b[_].fn.call(b[_].context, l, d)
                    break
                  case 4:
                    b[_].fn.call(b[_].context, l, d, h)
                    break
                  default:
                    if (!x) for (N = 1, x = new Array(I - 1); N < I; N++) x[N - 1] = arguments[N]
                    b[_].fn.apply(b[_].context, x)
                }
            }
            return !0
          }),
          (a.prototype.on = function (u, l, d) {
            return i(this, u, l, d, !1)
          }),
          (a.prototype.once = function (u, l, d) {
            return i(this, u, l, d, !0)
          }),
          (a.prototype.removeListener = function (u, l, d, h) {
            var p = n ? n + u : u
            if (!this._events[p]) return this
            if (!l) return o(this, p), this
            var y = this._events[p]
            if (y.fn) y.fn === l && (!h || y.once) && (!d || y.context === d) && o(this, p)
            else {
              for (var m = 0, b = [], I = y.length; m < I; m++)
                (y[m].fn !== l || (h && !y[m].once) || (d && y[m].context !== d)) && b.push(y[m])
              b.length ? (this._events[p] = b.length === 1 ? b[0] : b) : o(this, p)
            }
            return this
          }),
          (a.prototype.removeAllListeners = function (u) {
            var l
            return (
              u
                ? ((l = n ? n + u : u), this._events[l] && o(this, l))
                : ((this._events = new r()), (this._eventsCount = 0)),
              this
            )
          }),
          (a.prototype.off = a.prototype.removeListener),
          (a.prototype.addListener = a.prototype.on),
          (a.prefixed = n),
          (a.EventEmitter = a),
          (t.exports = a)
      })(mw)),
    mw.exports
  )
}
var fH = hH()
const gA = _u(fH)
class pH {
  constructor(e) {
    Object.defineProperty(this, 'uid', {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }),
      Object.defineProperty(this, '_emitter', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: new gA()
      })
  }
  on(e, n) {
    this._emitter.on(e, n)
  }
  once(e, n) {
    this._emitter.once(e, n)
  }
  off(e, n) {
    this._emitter.off(e, n)
  }
  emit(e, ...n) {
    const r = n[0]
    this._emitter.emit(e, { uid: this.uid, ...r })
  }
  listenerCount(e) {
    return this._emitter.listenerCount(e)
  }
}
function gH(t) {
  return new pH(t)
}
function mH(t, e) {
  return JSON.parse(t, (n, r) => {
    let s = r
    return (
      (s == null ? void 0 : s.__type) === 'bigint' && (s = BigInt(s.value)),
      (s == null ? void 0 : s.__type) === 'Map' && (s = new Map(s.value)),
      (e == null ? void 0 : e(n, s)) ?? s
    )
  })
}
function uS(t, e) {
  return t.slice(0, e).join('.') || '.'
}
function lS(t, e) {
  const { length: n } = t
  for (let r = 0; r < n; ++r) if (t[r] === e) return r + 1
  return 0
}
function yH(t, e) {
  const n = typeof t == 'function',
    r = typeof e == 'function',
    s = [],
    i = []
  return function (a, c) {
    if (typeof c == 'object')
      if (s.length) {
        const u = lS(s, this)
        u === 0 ? (s[s.length] = this) : (s.splice(u), i.splice(u)), (i[i.length] = a)
        const l = lS(s, c)
        if (l !== 0) return r ? e.call(this, a, c, uS(i, l)) : `[ref=${uS(i, l)}]`
      } else (s[0] = c), (i[0] = a)
    return n ? t.call(this, a, c) : c
  }
}
function wH(t, e, n, r) {
  return JSON.stringify(
    t,
    yH((s, i) => {
      let o = i
      return (
        typeof o == 'bigint' && (o = { __type: 'bigint', value: i.toString() }),
        o instanceof Map && (o = { __type: 'Map', value: Array.from(i.entries()) }),
        (e == null ? void 0 : e(s, o)) ?? o
      )
    }, r),
    n ?? void 0
  )
}
function bH(t) {
  const { deserialize: e = mH, key: n = 'wagmi', serialize: r = wH, storage: s = Z3 } = t
  function i(o) {
    return o instanceof Promise ? o.then(a => a).catch(() => null) : o
  }
  return {
    ...s,
    key: n,
    async getItem(o, a) {
      const c = s.getItem(`${n}.${o}`),
        u = await i(c)
      return u ? (e(u) ?? null) : (a ?? null)
    },
    async setItem(o, a) {
      const c = `${n}.${o}`
      a === null ? await i(s.removeItem(c)) : await i(s.setItem(c, r(a)))
    },
    async removeItem(o) {
      await i(s.removeItem(`${n}.${o}`))
    }
  }
}
const Z3 = { getItem: () => null, setItem: () => {}, removeItem: () => {} }
function vH() {
  const t = typeof window < 'u' && window.localStorage ? window.localStorage : Z3
  return {
    getItem(e) {
      return t.getItem(e)
    },
    removeItem(e) {
      t.removeItem(e)
    },
    setItem(e, n) {
      try {
        t.setItem(e, n)
      } catch {}
    }
  }
}
const W1 = 256
let Qp = W1,
  Zp
function EH(t = 11) {
  if (!Zp || Qp + t > W1 * 2) {
    ;(Zp = ''), (Qp = 0)
    for (let e = 0; e < W1; e++) Zp += ((256 + Math.random() * 256) | 0).toString(16).substring(1)
  }
  return Zp.substring(Qp, Qp++ + t)
}
function AH(t) {
  const {
      multiInjectedProviderDiscovery: e = !0,
      storage: n = bH({ storage: vH() }),
      syncConnectedChain: r = !0,
      ssr: s = !1,
      ...i
    } = t,
    o = typeof window < 'u' && e ? oH() : void 0,
    a = gw(() => i.chains),
    c = gw(() => {
      const N = [],
        T = new Set()
      for (const M of i.connectors ?? []) {
        const H = u(M)
        if ((N.push(H), !s && H.rdns)) {
          const B = typeof H.rdns == 'string' ? [H.rdns] : H.rdns
          for (const $ of B) T.add($)
        }
      }
      if (!s && o) {
        const M = o.getProviders()
        for (const H of M) T.has(H.info.rdns) || N.push(u(l(H)))
      }
      return N
    })
  function u(N) {
    var H
    const T = gH(EH()),
      M = {
        ...N({ emitter: T, chains: a.getState(), storage: n, transports: i.transports }),
        emitter: T,
        uid: T.uid
      }
    return T.on('connect', _), (H = M.setup) == null || H.call(M), M
  }
  function l(N) {
    const { info: T } = N,
      M = N.provider
    return T0({ target: { ...T, id: T.rdns, provider: M } })
  }
  const d = new Map()
  function h(N = {}) {
    const T = N.chainId ?? b.getState().chainId,
      M = a.getState().find(B => B.id === T)
    if (N.chainId && !M) throw new gf()
    {
      const B = d.get(b.getState().chainId)
      if (B && !M) return B
      if (!M) throw new gf()
    }
    {
      const B = d.get(T)
      if (B) return B
    }
    let H
    if (i.client) H = i.client({ chain: M })
    else {
      const B = M.id,
        $ = a.getState().map(U => U.id),
        D = {},
        W = Object.entries(i)
      for (const [U, w] of W)
        if (!(U === 'chains' || U === 'client' || U === 'connectors' || U === 'transports'))
          if (typeof w == 'object')
            if (B in w) D[U] = w[B]
            else {
              if ($.some(A => A in w)) continue
              D[U] = w
            }
          else D[U] = w
      H = G3({
        ...D,
        chain: M,
        batch: D.batch ?? { multicall: !0 },
        transport: U => i.transports[B]({ ...U, connectors: c })
      })
    }
    return d.set(T, H), H
  }
  function p() {
    return {
      chainId: a.getState()[0].id,
      connections: new Map(),
      current: null,
      status: 'disconnected'
    }
  }
  let y
  const m = '0.0.0-canary-'
  Ng.startsWith(m)
    ? (y = Number.parseInt(Ng.replace(m, '')))
    : (y = Number.parseInt(Ng.split('.')[0] ?? '0'))
  const b = gw(
    cH(
      n
        ? dH(p, {
            migrate(N, T) {
              if (T === y) return N
              const M = p(),
                H = I(N, M.chainId)
              return { ...M, chainId: H }
            },
            name: 'store',
            partialize(N) {
              return {
                connections: {
                  __type: 'Map',
                  value: Array.from(N.connections.entries()).map(([T, M]) => {
                    const { id: H, name: B, type: $, uid: D } = M.connector
                    return [T, { ...M, connector: { id: H, name: B, type: $, uid: D } }]
                  })
                },
                chainId: N.chainId,
                current: N.current
              }
            },
            merge(N, T) {
              typeof N == 'object' && N && 'status' in N && delete N.status
              const M = I(N, T.chainId)
              return { ...T, ...N, chainId: M }
            },
            skipHydration: s,
            storage: n,
            version: y
          })
        : p
    )
  )
  b.setState(p())
  function I(N, T) {
    return N &&
      typeof N == 'object' &&
      'chainId' in N &&
      typeof N.chainId == 'number' &&
      a.getState().some(M => M.id === N.chainId)
      ? N.chainId
      : T
  }
  r &&
    b.subscribe(
      ({ connections: N, current: T }) => {
        var M
        return T ? ((M = N.get(T)) == null ? void 0 : M.chainId) : void 0
      },
      N => {
        if (a.getState().some(M => M.id === N))
          return b.setState(M => ({ ...M, chainId: N ?? M.chainId }))
      }
    ),
    o == null ||
      o.subscribe(N => {
        const T = new Set(),
          M = new Set()
        for (const B of c.getState())
          if ((T.add(B.id), B.rdns)) {
            const $ = typeof B.rdns == 'string' ? [B.rdns] : B.rdns
            for (const D of $) M.add(D)
          }
        const H = []
        for (const B of N) {
          if (M.has(B.info.rdns)) continue
          const $ = u(l(B))
          T.has($.id) || H.push($)
        }
        ;(n && !b.persist.hasHydrated()) || c.setState(B => [...B, ...H], !0)
      })
  function x(N) {
    b.setState(T => {
      const M = T.connections.get(N.uid)
      return M
        ? {
            ...T,
            connections: new Map(T.connections).set(N.uid, {
              accounts: N.accounts ?? M.accounts,
              chainId: N.chainId ?? M.chainId,
              connector: M.connector
            })
          }
        : T
    })
  }
  function _(N) {
    b.getState().status === 'connecting' ||
      b.getState().status === 'reconnecting' ||
      b.setState(T => {
        const M = c.getState().find(H => H.uid === N.uid)
        return M
          ? (M.emitter.listenerCount('connect') && M.emitter.off('connect', x),
            M.emitter.listenerCount('change') || M.emitter.on('change', x),
            M.emitter.listenerCount('disconnect') || M.emitter.on('disconnect', R),
            {
              ...T,
              connections: new Map(T.connections).set(N.uid, {
                accounts: N.accounts,
                chainId: N.chainId,
                connector: M
              }),
              current: N.uid,
              status: 'connected'
            })
          : T
      })
  }
  function R(N) {
    b.setState(T => {
      const M = T.connections.get(N.uid)
      if (M) {
        const B = M.connector
        B.emitter.listenerCount('change') && M.connector.emitter.off('change', x),
          B.emitter.listenerCount('disconnect') && M.connector.emitter.off('disconnect', R),
          B.emitter.listenerCount('connect') || M.connector.emitter.on('connect', _)
      }
      if ((T.connections.delete(N.uid), T.connections.size === 0))
        return { ...T, connections: new Map(), current: null, status: 'disconnected' }
      const H = T.connections.values().next().value
      return { ...T, connections: new Map(T.connections), current: H.connector.uid }
    })
  }
  return {
    get chains() {
      return a.getState()
    },
    get connectors() {
      return c.getState()
    },
    storage: n,
    getClient: h,
    get state() {
      return b.getState()
    },
    setState(N) {
      let T
      typeof N == 'function' ? (T = N(b.getState())) : (T = N)
      const M = p()
      typeof T != 'object' && (T = M),
        Object.keys(M).some(B => !(B in T)) && (T = M),
        b.setState(T, !0)
    },
    subscribe(N, T, M) {
      return b.subscribe(N, T, M ? { ...M, fireImmediately: M.emitImmediately } : void 0)
    },
    _internal: {
      mipd: o,
      store: b,
      ssr: !!s,
      syncConnectedChain: r,
      transports: i.transports,
      chains: {
        setState(N) {
          const T = typeof N == 'function' ? N(a.getState()) : N
          if (T.length !== 0) return a.setState(T, !0)
        },
        subscribe(N) {
          return a.subscribe(N)
        }
      },
      connectors: {
        providerDetailToConnector: l,
        setup: u,
        setState(N) {
          return c.setState(typeof N == 'function' ? N(c.getState()) : N, !0)
        },
        subscribe(N) {
          return c.subscribe(N)
        }
      },
      events: { change: x, connect: _, disconnect: R }
    }
  }
}
function _H(t, e) {
  const { initialState: n, reconnectOnMount: r } = e
  return (
    n &&
      !t._internal.store.persist.hasHydrated() &&
      t.setState({
        ...n,
        chainId: t.chains.some(s => s.id === n.chainId) ? n.chainId : t.chains[0].id,
        connections: r ? n.connections : new Map(),
        status: r ? 'reconnecting' : 'disconnected'
      }),
    {
      async onMount() {
        t._internal.ssr &&
          (await t._internal.store.persist.rehydrate(),
          t._internal.mipd &&
            t._internal.connectors.setState(s => {
              var c
              const i = new Set()
              for (const u of s ?? [])
                if (u.rdns) {
                  const l = Array.isArray(u.rdns) ? u.rdns : [u.rdns]
                  for (const d of l) i.add(d)
                }
              const o = [],
                a = ((c = t._internal.mipd) == null ? void 0 : c.getProviders()) ?? []
              for (const u of a) {
                if (i.has(u.info.rdns)) continue
                const l = t._internal.connectors.providerDetailToConnector(u),
                  d = t._internal.connectors.setup(l)
                o.push(d)
              }
              return [...s, ...o]
            })),
          r ? q1(t) : t.storage && t.setState(s => ({ ...s, connections: new Map() }))
      }
    }
  )
}
const CH = Symbol(),
  SH = {
    install(t, e) {
      const { config: n, reconnectOnMount: r = !0 } = e
      t.provide(CH, n)
      const { onMount: s } = _H(n, { ...e, reconnectOnMount: r })
      s()
    }
  }
var yw = {},
  qd = {},
  dS
function P0() {
  if (dS) return qd
  ;(dS = 1), (qd.byteLength = a), (qd.toByteArray = u), (qd.fromByteArray = h)
  for (
    var t = [],
      e = [],
      n = typeof Uint8Array < 'u' ? Uint8Array : Array,
      r = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
      s = 0,
      i = r.length;
    s < i;
    ++s
  )
    (t[s] = r[s]), (e[r.charCodeAt(s)] = s)
  ;(e[45] = 62), (e[95] = 63)
  function o(p) {
    var y = p.length
    if (y % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4')
    var m = p.indexOf('=')
    m === -1 && (m = y)
    var b = m === y ? 0 : 4 - (m % 4)
    return [m, b]
  }
  function a(p) {
    var y = o(p),
      m = y[0],
      b = y[1]
    return ((m + b) * 3) / 4 - b
  }
  function c(p, y, m) {
    return ((y + m) * 3) / 4 - m
  }
  function u(p) {
    var y,
      m = o(p),
      b = m[0],
      I = m[1],
      x = new n(c(p, b, I)),
      _ = 0,
      R = I > 0 ? b - 4 : b,
      N
    for (N = 0; N < R; N += 4)
      (y =
        (e[p.charCodeAt(N)] << 18) |
        (e[p.charCodeAt(N + 1)] << 12) |
        (e[p.charCodeAt(N + 2)] << 6) |
        e[p.charCodeAt(N + 3)]),
        (x[_++] = (y >> 16) & 255),
        (x[_++] = (y >> 8) & 255),
        (x[_++] = y & 255)
    return (
      I === 2 &&
        ((y = (e[p.charCodeAt(N)] << 2) | (e[p.charCodeAt(N + 1)] >> 4)), (x[_++] = y & 255)),
      I === 1 &&
        ((y =
          (e[p.charCodeAt(N)] << 10) |
          (e[p.charCodeAt(N + 1)] << 4) |
          (e[p.charCodeAt(N + 2)] >> 2)),
        (x[_++] = (y >> 8) & 255),
        (x[_++] = y & 255)),
      x
    )
  }
  function l(p) {
    return t[(p >> 18) & 63] + t[(p >> 12) & 63] + t[(p >> 6) & 63] + t[p & 63]
  }
  function d(p, y, m) {
    for (var b, I = [], x = y; x < m; x += 3)
      (b = ((p[x] << 16) & 16711680) + ((p[x + 1] << 8) & 65280) + (p[x + 2] & 255)), I.push(l(b))
    return I.join('')
  }
  function h(p) {
    for (var y, m = p.length, b = m % 3, I = [], x = 16383, _ = 0, R = m - b; _ < R; _ += x)
      I.push(d(p, _, _ + x > R ? R : _ + x))
    return (
      b === 1
        ? ((y = p[m - 1]), I.push(t[y >> 2] + t[(y << 4) & 63] + '=='))
        : b === 2 &&
          ((y = (p[m - 2] << 8) + p[m - 1]),
          I.push(t[y >> 10] + t[(y >> 4) & 63] + t[(y << 2) & 63] + '=')),
      I.join('')
    )
  }
  return qd
}
var Yp = {}
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var hS
function Y3() {
  return (
    hS ||
      ((hS = 1),
      (Yp.read = function (t, e, n, r, s) {
        var i,
          o,
          a = s * 8 - r - 1,
          c = (1 << a) - 1,
          u = c >> 1,
          l = -7,
          d = n ? s - 1 : 0,
          h = n ? -1 : 1,
          p = t[e + d]
        for (
          d += h, i = p & ((1 << -l) - 1), p >>= -l, l += a;
          l > 0;
          i = i * 256 + t[e + d], d += h, l -= 8
        );
        for (
          o = i & ((1 << -l) - 1), i >>= -l, l += r;
          l > 0;
          o = o * 256 + t[e + d], d += h, l -= 8
        );
        if (i === 0) i = 1 - u
        else {
          if (i === c) return o ? NaN : (p ? -1 : 1) * (1 / 0)
          ;(o = o + Math.pow(2, r)), (i = i - u)
        }
        return (p ? -1 : 1) * o * Math.pow(2, i - r)
      }),
      (Yp.write = function (t, e, n, r, s, i) {
        var o,
          a,
          c,
          u = i * 8 - s - 1,
          l = (1 << u) - 1,
          d = l >> 1,
          h = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
          p = r ? 0 : i - 1,
          y = r ? 1 : -1,
          m = e < 0 || (e === 0 && 1 / e < 0) ? 1 : 0
        for (
          e = Math.abs(e),
            isNaN(e) || e === 1 / 0
              ? ((a = isNaN(e) ? 1 : 0), (o = l))
              : ((o = Math.floor(Math.log(e) / Math.LN2)),
                e * (c = Math.pow(2, -o)) < 1 && (o--, (c *= 2)),
                o + d >= 1 ? (e += h / c) : (e += h * Math.pow(2, 1 - d)),
                e * c >= 2 && (o++, (c /= 2)),
                o + d >= l
                  ? ((a = 0), (o = l))
                  : o + d >= 1
                    ? ((a = (e * c - 1) * Math.pow(2, s)), (o = o + d))
                    : ((a = e * Math.pow(2, d - 1) * Math.pow(2, s)), (o = 0)));
          s >= 8;
          t[n + p] = a & 255, p += y, a /= 256, s -= 8
        );
        for (o = (o << s) | a, u += s; u > 0; t[n + p] = o & 255, p += y, o /= 256, u -= 8);
        t[n + p - y] |= m * 128
      })),
    Yp
  )
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var fS
function J3() {
  return (
    fS ||
      ((fS = 1),
      (function (t) {
        const e = P0(),
          n = Y3(),
          r =
            typeof Symbol == 'function' && typeof Symbol.for == 'function'
              ? Symbol.for('nodejs.util.inspect.custom')
              : null
        ;(t.Buffer = a), (t.SlowBuffer = x), (t.INSPECT_MAX_BYTES = 50)
        const s = 2147483647
        ;(t.kMaxLength = s),
          (a.TYPED_ARRAY_SUPPORT = i()),
          !a.TYPED_ARRAY_SUPPORT &&
            typeof console < 'u' &&
            typeof console.error == 'function' &&
            console.error(
              'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
            )
        function i() {
          try {
            const S = new Uint8Array(1),
              f = {
                foo: function () {
                  return 42
                }
              }
            return (
              Object.setPrototypeOf(f, Uint8Array.prototype),
              Object.setPrototypeOf(S, f),
              S.foo() === 42
            )
          } catch {
            return !1
          }
        }
        Object.defineProperty(a.prototype, 'parent', {
          enumerable: !0,
          get: function () {
            if (a.isBuffer(this)) return this.buffer
          }
        }),
          Object.defineProperty(a.prototype, 'offset', {
            enumerable: !0,
            get: function () {
              if (a.isBuffer(this)) return this.byteOffset
            }
          })
        function o(S) {
          if (S > s) throw new RangeError('The value "' + S + '" is invalid for option "size"')
          const f = new Uint8Array(S)
          return Object.setPrototypeOf(f, a.prototype), f
        }
        function a(S, f, g) {
          if (typeof S == 'number') {
            if (typeof f == 'string')
              throw new TypeError(
                'The "string" argument must be of type string. Received type number'
              )
            return d(S)
          }
          return c(S, f, g)
        }
        a.poolSize = 8192
        function c(S, f, g) {
          if (typeof S == 'string') return h(S, f)
          if (ArrayBuffer.isView(S)) return y(S)
          if (S == null)
            throw new TypeError(
              'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
                typeof S
            )
          if (
            he(S, ArrayBuffer) ||
            (S && he(S.buffer, ArrayBuffer)) ||
            (typeof SharedArrayBuffer < 'u' &&
              (he(S, SharedArrayBuffer) || (S && he(S.buffer, SharedArrayBuffer))))
          )
            return m(S, f, g)
          if (typeof S == 'number')
            throw new TypeError(
              'The "value" argument must not be of type number. Received type number'
            )
          const k = S.valueOf && S.valueOf()
          if (k != null && k !== S) return a.from(k, f, g)
          const q = b(S)
          if (q) return q
          if (
            typeof Symbol < 'u' &&
            Symbol.toPrimitive != null &&
            typeof S[Symbol.toPrimitive] == 'function'
          )
            return a.from(S[Symbol.toPrimitive]('string'), f, g)
          throw new TypeError(
            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
              typeof S
          )
        }
        ;(a.from = function (S, f, g) {
          return c(S, f, g)
        }),
          Object.setPrototypeOf(a.prototype, Uint8Array.prototype),
          Object.setPrototypeOf(a, Uint8Array)
        function u(S) {
          if (typeof S != 'number') throw new TypeError('"size" argument must be of type number')
          if (S < 0) throw new RangeError('The value "' + S + '" is invalid for option "size"')
        }
        function l(S, f, g) {
          return (
            u(S),
            S <= 0
              ? o(S)
              : f !== void 0
                ? typeof g == 'string'
                  ? o(S).fill(f, g)
                  : o(S).fill(f)
                : o(S)
          )
        }
        a.alloc = function (S, f, g) {
          return l(S, f, g)
        }
        function d(S) {
          return u(S), o(S < 0 ? 0 : I(S) | 0)
        }
        ;(a.allocUnsafe = function (S) {
          return d(S)
        }),
          (a.allocUnsafeSlow = function (S) {
            return d(S)
          })
        function h(S, f) {
          if (((typeof f != 'string' || f === '') && (f = 'utf8'), !a.isEncoding(f)))
            throw new TypeError('Unknown encoding: ' + f)
          const g = _(S, f) | 0
          let k = o(g)
          const q = k.write(S, f)
          return q !== g && (k = k.slice(0, q)), k
        }
        function p(S) {
          const f = S.length < 0 ? 0 : I(S.length) | 0,
            g = o(f)
          for (let k = 0; k < f; k += 1) g[k] = S[k] & 255
          return g
        }
        function y(S) {
          if (he(S, Uint8Array)) {
            const f = new Uint8Array(S)
            return m(f.buffer, f.byteOffset, f.byteLength)
          }
          return p(S)
        }
        function m(S, f, g) {
          if (f < 0 || S.byteLength < f)
            throw new RangeError('"offset" is outside of buffer bounds')
          if (S.byteLength < f + (g || 0))
            throw new RangeError('"length" is outside of buffer bounds')
          let k
          return (
            f === void 0 && g === void 0
              ? (k = new Uint8Array(S))
              : g === void 0
                ? (k = new Uint8Array(S, f))
                : (k = new Uint8Array(S, f, g)),
            Object.setPrototypeOf(k, a.prototype),
            k
          )
        }
        function b(S) {
          if (a.isBuffer(S)) {
            const f = I(S.length) | 0,
              g = o(f)
            return g.length === 0 || S.copy(g, 0, 0, f), g
          }
          if (S.length !== void 0) return typeof S.length != 'number' || Ne(S.length) ? o(0) : p(S)
          if (S.type === 'Buffer' && Array.isArray(S.data)) return p(S.data)
        }
        function I(S) {
          if (S >= s)
            throw new RangeError(
              'Attempt to allocate Buffer larger than maximum size: 0x' + s.toString(16) + ' bytes'
            )
          return S | 0
        }
        function x(S) {
          return +S != S && (S = 0), a.alloc(+S)
        }
        ;(a.isBuffer = function (f) {
          return f != null && f._isBuffer === !0 && f !== a.prototype
        }),
          (a.compare = function (f, g) {
            if (
              (he(f, Uint8Array) && (f = a.from(f, f.offset, f.byteLength)),
              he(g, Uint8Array) && (g = a.from(g, g.offset, g.byteLength)),
              !a.isBuffer(f) || !a.isBuffer(g))
            )
              throw new TypeError(
                'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
              )
            if (f === g) return 0
            let k = f.length,
              q = g.length
            for (let V = 0, Y = Math.min(k, q); V < Y; ++V)
              if (f[V] !== g[V]) {
                ;(k = f[V]), (q = g[V])
                break
              }
            return k < q ? -1 : q < k ? 1 : 0
          }),
          (a.isEncoding = function (f) {
            switch (String(f).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'latin1':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return !0
              default:
                return !1
            }
          }),
          (a.concat = function (f, g) {
            if (!Array.isArray(f))
              throw new TypeError('"list" argument must be an Array of Buffers')
            if (f.length === 0) return a.alloc(0)
            let k
            if (g === void 0) for (g = 0, k = 0; k < f.length; ++k) g += f[k].length
            const q = a.allocUnsafe(g)
            let V = 0
            for (k = 0; k < f.length; ++k) {
              let Y = f[k]
              if (he(Y, Uint8Array))
                V + Y.length > q.length
                  ? (a.isBuffer(Y) || (Y = a.from(Y)), Y.copy(q, V))
                  : Uint8Array.prototype.set.call(q, Y, V)
              else if (a.isBuffer(Y)) Y.copy(q, V)
              else throw new TypeError('"list" argument must be an Array of Buffers')
              V += Y.length
            }
            return q
          })
        function _(S, f) {
          if (a.isBuffer(S)) return S.length
          if (ArrayBuffer.isView(S) || he(S, ArrayBuffer)) return S.byteLength
          if (typeof S != 'string')
            throw new TypeError(
              'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                typeof S
            )
          const g = S.length,
            k = arguments.length > 2 && arguments[2] === !0
          if (!k && g === 0) return 0
          let q = !1
          for (;;)
            switch (f) {
              case 'ascii':
              case 'latin1':
              case 'binary':
                return g
              case 'utf8':
              case 'utf-8':
                return ue(S).length
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return g * 2
              case 'hex':
                return g >>> 1
              case 'base64':
                return we(S).length
              default:
                if (q) return k ? -1 : ue(S).length
                ;(f = ('' + f).toLowerCase()), (q = !0)
            }
        }
        a.byteLength = _
        function R(S, f, g) {
          let k = !1
          if (
            ((f === void 0 || f < 0) && (f = 0),
            f > this.length ||
              ((g === void 0 || g > this.length) && (g = this.length), g <= 0) ||
              ((g >>>= 0), (f >>>= 0), g <= f))
          )
            return ''
          for (S || (S = 'utf8'); ; )
            switch (S) {
              case 'hex':
                return F(this, f, g)
              case 'utf8':
              case 'utf-8':
                return w(this, f, g)
              case 'ascii':
                return P(this, f, g)
              case 'latin1':
              case 'binary':
                return O(this, f, g)
              case 'base64':
                return U(this, f, g)
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return z(this, f, g)
              default:
                if (k) throw new TypeError('Unknown encoding: ' + S)
                ;(S = (S + '').toLowerCase()), (k = !0)
            }
        }
        a.prototype._isBuffer = !0
        function N(S, f, g) {
          const k = S[f]
          ;(S[f] = S[g]), (S[g] = k)
        }
        ;(a.prototype.swap16 = function () {
          const f = this.length
          if (f % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')
          for (let g = 0; g < f; g += 2) N(this, g, g + 1)
          return this
        }),
          (a.prototype.swap32 = function () {
            const f = this.length
            if (f % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')
            for (let g = 0; g < f; g += 4) N(this, g, g + 3), N(this, g + 1, g + 2)
            return this
          }),
          (a.prototype.swap64 = function () {
            const f = this.length
            if (f % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')
            for (let g = 0; g < f; g += 8)
              N(this, g, g + 7), N(this, g + 1, g + 6), N(this, g + 2, g + 5), N(this, g + 3, g + 4)
            return this
          }),
          (a.prototype.toString = function () {
            const f = this.length
            return f === 0 ? '' : arguments.length === 0 ? w(this, 0, f) : R.apply(this, arguments)
          }),
          (a.prototype.toLocaleString = a.prototype.toString),
          (a.prototype.equals = function (f) {
            if (!a.isBuffer(f)) throw new TypeError('Argument must be a Buffer')
            return this === f ? !0 : a.compare(this, f) === 0
          }),
          (a.prototype.inspect = function () {
            let f = ''
            const g = t.INSPECT_MAX_BYTES
            return (
              (f = this.toString('hex', 0, g)
                .replace(/(.{2})/g, '$1 ')
                .trim()),
              this.length > g && (f += ' ... '),
              '<Buffer ' + f + '>'
            )
          }),
          r && (a.prototype[r] = a.prototype.inspect),
          (a.prototype.compare = function (f, g, k, q, V) {
            if ((he(f, Uint8Array) && (f = a.from(f, f.offset, f.byteLength)), !a.isBuffer(f)))
              throw new TypeError(
                'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                  typeof f
              )
            if (
              (g === void 0 && (g = 0),
              k === void 0 && (k = f ? f.length : 0),
              q === void 0 && (q = 0),
              V === void 0 && (V = this.length),
              g < 0 || k > f.length || q < 0 || V > this.length)
            )
              throw new RangeError('out of range index')
            if (q >= V && g >= k) return 0
            if (q >= V) return -1
            if (g >= k) return 1
            if (((g >>>= 0), (k >>>= 0), (q >>>= 0), (V >>>= 0), this === f)) return 0
            let Y = V - q,
              ke = k - g
            const Ve = Math.min(Y, ke),
              Oe = this.slice(q, V),
              st = f.slice(g, k)
            for (let Ue = 0; Ue < Ve; ++Ue)
              if (Oe[Ue] !== st[Ue]) {
                ;(Y = Oe[Ue]), (ke = st[Ue])
                break
              }
            return Y < ke ? -1 : ke < Y ? 1 : 0
          })
        function T(S, f, g, k, q) {
          if (S.length === 0) return -1
          if (
            (typeof g == 'string'
              ? ((k = g), (g = 0))
              : g > 2147483647
                ? (g = 2147483647)
                : g < -2147483648 && (g = -2147483648),
            (g = +g),
            Ne(g) && (g = q ? 0 : S.length - 1),
            g < 0 && (g = S.length + g),
            g >= S.length)
          ) {
            if (q) return -1
            g = S.length - 1
          } else if (g < 0)
            if (q) g = 0
            else return -1
          if ((typeof f == 'string' && (f = a.from(f, k)), a.isBuffer(f)))
            return f.length === 0 ? -1 : M(S, f, g, k, q)
          if (typeof f == 'number')
            return (
              (f = f & 255),
              typeof Uint8Array.prototype.indexOf == 'function'
                ? q
                  ? Uint8Array.prototype.indexOf.call(S, f, g)
                  : Uint8Array.prototype.lastIndexOf.call(S, f, g)
                : M(S, [f], g, k, q)
            )
          throw new TypeError('val must be string, number or Buffer')
        }
        function M(S, f, g, k, q) {
          let V = 1,
            Y = S.length,
            ke = f.length
          if (
            k !== void 0 &&
            ((k = String(k).toLowerCase()),
            k === 'ucs2' || k === 'ucs-2' || k === 'utf16le' || k === 'utf-16le')
          ) {
            if (S.length < 2 || f.length < 2) return -1
            ;(V = 2), (Y /= 2), (ke /= 2), (g /= 2)
          }
          function Ve(st, Ue) {
            return V === 1 ? st[Ue] : st.readUInt16BE(Ue * V)
          }
          let Oe
          if (q) {
            let st = -1
            for (Oe = g; Oe < Y; Oe++)
              if (Ve(S, Oe) === Ve(f, st === -1 ? 0 : Oe - st)) {
                if ((st === -1 && (st = Oe), Oe - st + 1 === ke)) return st * V
              } else st !== -1 && (Oe -= Oe - st), (st = -1)
          } else
            for (g + ke > Y && (g = Y - ke), Oe = g; Oe >= 0; Oe--) {
              let st = !0
              for (let Ue = 0; Ue < ke; Ue++)
                if (Ve(S, Oe + Ue) !== Ve(f, Ue)) {
                  st = !1
                  break
                }
              if (st) return Oe
            }
          return -1
        }
        ;(a.prototype.includes = function (f, g, k) {
          return this.indexOf(f, g, k) !== -1
        }),
          (a.prototype.indexOf = function (f, g, k) {
            return T(this, f, g, k, !0)
          }),
          (a.prototype.lastIndexOf = function (f, g, k) {
            return T(this, f, g, k, !1)
          })
        function H(S, f, g, k) {
          g = Number(g) || 0
          const q = S.length - g
          k ? ((k = Number(k)), k > q && (k = q)) : (k = q)
          const V = f.length
          k > V / 2 && (k = V / 2)
          let Y
          for (Y = 0; Y < k; ++Y) {
            const ke = parseInt(f.substr(Y * 2, 2), 16)
            if (Ne(ke)) return Y
            S[g + Y] = ke
          }
          return Y
        }
        function B(S, f, g, k) {
          return ge(ue(f, S.length - g), S, g, k)
        }
        function $(S, f, g, k) {
          return ge(de(f), S, g, k)
        }
        function D(S, f, g, k) {
          return ge(we(f), S, g, k)
        }
        function W(S, f, g, k) {
          return ge(Te(f, S.length - g), S, g, k)
        }
        ;(a.prototype.write = function (f, g, k, q) {
          if (g === void 0) (q = 'utf8'), (k = this.length), (g = 0)
          else if (k === void 0 && typeof g == 'string') (q = g), (k = this.length), (g = 0)
          else if (isFinite(g))
            (g = g >>> 0),
              isFinite(k) ? ((k = k >>> 0), q === void 0 && (q = 'utf8')) : ((q = k), (k = void 0))
          else
            throw new Error(
              'Buffer.write(string, encoding, offset[, length]) is no longer supported'
            )
          const V = this.length - g
          if (
            ((k === void 0 || k > V) && (k = V),
            (f.length > 0 && (k < 0 || g < 0)) || g > this.length)
          )
            throw new RangeError('Attempt to write outside buffer bounds')
          q || (q = 'utf8')
          let Y = !1
          for (;;)
            switch (q) {
              case 'hex':
                return H(this, f, g, k)
              case 'utf8':
              case 'utf-8':
                return B(this, f, g, k)
              case 'ascii':
              case 'latin1':
              case 'binary':
                return $(this, f, g, k)
              case 'base64':
                return D(this, f, g, k)
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return W(this, f, g, k)
              default:
                if (Y) throw new TypeError('Unknown encoding: ' + q)
                ;(q = ('' + q).toLowerCase()), (Y = !0)
            }
        }),
          (a.prototype.toJSON = function () {
            return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) }
          })
        function U(S, f, g) {
          return f === 0 && g === S.length ? e.fromByteArray(S) : e.fromByteArray(S.slice(f, g))
        }
        function w(S, f, g) {
          g = Math.min(S.length, g)
          const k = []
          let q = f
          for (; q < g; ) {
            const V = S[q]
            let Y = null,
              ke = V > 239 ? 4 : V > 223 ? 3 : V > 191 ? 2 : 1
            if (q + ke <= g) {
              let Ve, Oe, st, Ue
              switch (ke) {
                case 1:
                  V < 128 && (Y = V)
                  break
                case 2:
                  ;(Ve = S[q + 1]),
                    (Ve & 192) === 128 && ((Ue = ((V & 31) << 6) | (Ve & 63)), Ue > 127 && (Y = Ue))
                  break
                case 3:
                  ;(Ve = S[q + 1]),
                    (Oe = S[q + 2]),
                    (Ve & 192) === 128 &&
                      (Oe & 192) === 128 &&
                      ((Ue = ((V & 15) << 12) | ((Ve & 63) << 6) | (Oe & 63)),
                      Ue > 2047 && (Ue < 55296 || Ue > 57343) && (Y = Ue))
                  break
                case 4:
                  ;(Ve = S[q + 1]),
                    (Oe = S[q + 2]),
                    (st = S[q + 3]),
                    (Ve & 192) === 128 &&
                      (Oe & 192) === 128 &&
                      (st & 192) === 128 &&
                      ((Ue = ((V & 15) << 18) | ((Ve & 63) << 12) | ((Oe & 63) << 6) | (st & 63)),
                      Ue > 65535 && Ue < 1114112 && (Y = Ue))
              }
            }
            Y === null
              ? ((Y = 65533), (ke = 1))
              : Y > 65535 &&
                ((Y -= 65536), k.push(((Y >>> 10) & 1023) | 55296), (Y = 56320 | (Y & 1023))),
              k.push(Y),
              (q += ke)
          }
          return A(k)
        }
        const v = 4096
        function A(S) {
          const f = S.length
          if (f <= v) return String.fromCharCode.apply(String, S)
          let g = '',
            k = 0
          for (; k < f; ) g += String.fromCharCode.apply(String, S.slice(k, (k += v)))
          return g
        }
        function P(S, f, g) {
          let k = ''
          g = Math.min(S.length, g)
          for (let q = f; q < g; ++q) k += String.fromCharCode(S[q] & 127)
          return k
        }
        function O(S, f, g) {
          let k = ''
          g = Math.min(S.length, g)
          for (let q = f; q < g; ++q) k += String.fromCharCode(S[q])
          return k
        }
        function F(S, f, g) {
          const k = S.length
          ;(!f || f < 0) && (f = 0), (!g || g < 0 || g > k) && (g = k)
          let q = ''
          for (let V = f; V < g; ++V) q += _e[S[V]]
          return q
        }
        function z(S, f, g) {
          const k = S.slice(f, g)
          let q = ''
          for (let V = 0; V < k.length - 1; V += 2) q += String.fromCharCode(k[V] + k[V + 1] * 256)
          return q
        }
        a.prototype.slice = function (f, g) {
          const k = this.length
          ;(f = ~~f),
            (g = g === void 0 ? k : ~~g),
            f < 0 ? ((f += k), f < 0 && (f = 0)) : f > k && (f = k),
            g < 0 ? ((g += k), g < 0 && (g = 0)) : g > k && (g = k),
            g < f && (g = f)
          const q = this.subarray(f, g)
          return Object.setPrototypeOf(q, a.prototype), q
        }
        function j(S, f, g) {
          if (S % 1 !== 0 || S < 0) throw new RangeError('offset is not uint')
          if (S + f > g) throw new RangeError('Trying to access beyond buffer length')
        }
        ;(a.prototype.readUintLE = a.prototype.readUIntLE =
          function (f, g, k) {
            ;(f = f >>> 0), (g = g >>> 0), k || j(f, g, this.length)
            let q = this[f],
              V = 1,
              Y = 0
            for (; ++Y < g && (V *= 256); ) q += this[f + Y] * V
            return q
          }),
          (a.prototype.readUintBE = a.prototype.readUIntBE =
            function (f, g, k) {
              ;(f = f >>> 0), (g = g >>> 0), k || j(f, g, this.length)
              let q = this[f + --g],
                V = 1
              for (; g > 0 && (V *= 256); ) q += this[f + --g] * V
              return q
            }),
          (a.prototype.readUint8 = a.prototype.readUInt8 =
            function (f, g) {
              return (f = f >>> 0), g || j(f, 1, this.length), this[f]
            }),
          (a.prototype.readUint16LE = a.prototype.readUInt16LE =
            function (f, g) {
              return (f = f >>> 0), g || j(f, 2, this.length), this[f] | (this[f + 1] << 8)
            }),
          (a.prototype.readUint16BE = a.prototype.readUInt16BE =
            function (f, g) {
              return (f = f >>> 0), g || j(f, 2, this.length), (this[f] << 8) | this[f + 1]
            }),
          (a.prototype.readUint32LE = a.prototype.readUInt32LE =
            function (f, g) {
              return (
                (f = f >>> 0),
                g || j(f, 4, this.length),
                (this[f] | (this[f + 1] << 8) | (this[f + 2] << 16)) + this[f + 3] * 16777216
              )
            }),
          (a.prototype.readUint32BE = a.prototype.readUInt32BE =
            function (f, g) {
              return (
                (f = f >>> 0),
                g || j(f, 4, this.length),
                this[f] * 16777216 + ((this[f + 1] << 16) | (this[f + 2] << 8) | this[f + 3])
              )
            }),
          (a.prototype.readBigUInt64LE = Be(function (f) {
            ;(f = f >>> 0), Z(f, 'offset')
            const g = this[f],
              k = this[f + 7]
            ;(g === void 0 || k === void 0) && X(f, this.length - 8)
            const q = g + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24,
              V = this[++f] + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + k * 2 ** 24
            return BigInt(q) + (BigInt(V) << BigInt(32))
          })),
          (a.prototype.readBigUInt64BE = Be(function (f) {
            ;(f = f >>> 0), Z(f, 'offset')
            const g = this[f],
              k = this[f + 7]
            ;(g === void 0 || k === void 0) && X(f, this.length - 8)
            const q = g * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f],
              V = this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + k
            return (BigInt(q) << BigInt(32)) + BigInt(V)
          })),
          (a.prototype.readIntLE = function (f, g, k) {
            ;(f = f >>> 0), (g = g >>> 0), k || j(f, g, this.length)
            let q = this[f],
              V = 1,
              Y = 0
            for (; ++Y < g && (V *= 256); ) q += this[f + Y] * V
            return (V *= 128), q >= V && (q -= Math.pow(2, 8 * g)), q
          }),
          (a.prototype.readIntBE = function (f, g, k) {
            ;(f = f >>> 0), (g = g >>> 0), k || j(f, g, this.length)
            let q = g,
              V = 1,
              Y = this[f + --q]
            for (; q > 0 && (V *= 256); ) Y += this[f + --q] * V
            return (V *= 128), Y >= V && (Y -= Math.pow(2, 8 * g)), Y
          }),
          (a.prototype.readInt8 = function (f, g) {
            return (
              (f = f >>> 0),
              g || j(f, 1, this.length),
              this[f] & 128 ? (255 - this[f] + 1) * -1 : this[f]
            )
          }),
          (a.prototype.readInt16LE = function (f, g) {
            ;(f = f >>> 0), g || j(f, 2, this.length)
            const k = this[f] | (this[f + 1] << 8)
            return k & 32768 ? k | 4294901760 : k
          }),
          (a.prototype.readInt16BE = function (f, g) {
            ;(f = f >>> 0), g || j(f, 2, this.length)
            const k = this[f + 1] | (this[f] << 8)
            return k & 32768 ? k | 4294901760 : k
          }),
          (a.prototype.readInt32LE = function (f, g) {
            return (
              (f = f >>> 0),
              g || j(f, 4, this.length),
              this[f] | (this[f + 1] << 8) | (this[f + 2] << 16) | (this[f + 3] << 24)
            )
          }),
          (a.prototype.readInt32BE = function (f, g) {
            return (
              (f = f >>> 0),
              g || j(f, 4, this.length),
              (this[f] << 24) | (this[f + 1] << 16) | (this[f + 2] << 8) | this[f + 3]
            )
          }),
          (a.prototype.readBigInt64LE = Be(function (f) {
            ;(f = f >>> 0), Z(f, 'offset')
            const g = this[f],
              k = this[f + 7]
            ;(g === void 0 || k === void 0) && X(f, this.length - 8)
            const q = this[f + 4] + this[f + 5] * 2 ** 8 + this[f + 6] * 2 ** 16 + (k << 24)
            return (
              (BigInt(q) << BigInt(32)) +
              BigInt(g + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24)
            )
          })),
          (a.prototype.readBigInt64BE = Be(function (f) {
            ;(f = f >>> 0), Z(f, 'offset')
            const g = this[f],
              k = this[f + 7]
            ;(g === void 0 || k === void 0) && X(f, this.length - 8)
            const q = (g << 24) + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f]
            return (
              (BigInt(q) << BigInt(32)) +
              BigInt(this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + k)
            )
          })),
          (a.prototype.readFloatLE = function (f, g) {
            return (f = f >>> 0), g || j(f, 4, this.length), n.read(this, f, !0, 23, 4)
          }),
          (a.prototype.readFloatBE = function (f, g) {
            return (f = f >>> 0), g || j(f, 4, this.length), n.read(this, f, !1, 23, 4)
          }),
          (a.prototype.readDoubleLE = function (f, g) {
            return (f = f >>> 0), g || j(f, 8, this.length), n.read(this, f, !0, 52, 8)
          }),
          (a.prototype.readDoubleBE = function (f, g) {
            return (f = f >>> 0), g || j(f, 8, this.length), n.read(this, f, !1, 52, 8)
          })
        function E(S, f, g, k, q, V) {
          if (!a.isBuffer(S)) throw new TypeError('"buffer" argument must be a Buffer instance')
          if (f > q || f < V) throw new RangeError('"value" argument is out of bounds')
          if (g + k > S.length) throw new RangeError('Index out of range')
        }
        ;(a.prototype.writeUintLE = a.prototype.writeUIntLE =
          function (f, g, k, q) {
            if (((f = +f), (g = g >>> 0), (k = k >>> 0), !q)) {
              const ke = Math.pow(2, 8 * k) - 1
              E(this, f, g, k, ke, 0)
            }
            let V = 1,
              Y = 0
            for (this[g] = f & 255; ++Y < k && (V *= 256); ) this[g + Y] = (f / V) & 255
            return g + k
          }),
          (a.prototype.writeUintBE = a.prototype.writeUIntBE =
            function (f, g, k, q) {
              if (((f = +f), (g = g >>> 0), (k = k >>> 0), !q)) {
                const ke = Math.pow(2, 8 * k) - 1
                E(this, f, g, k, ke, 0)
              }
              let V = k - 1,
                Y = 1
              for (this[g + V] = f & 255; --V >= 0 && (Y *= 256); ) this[g + V] = (f / Y) & 255
              return g + k
            }),
          (a.prototype.writeUint8 = a.prototype.writeUInt8 =
            function (f, g, k) {
              return (
                (f = +f), (g = g >>> 0), k || E(this, f, g, 1, 255, 0), (this[g] = f & 255), g + 1
              )
            }),
          (a.prototype.writeUint16LE = a.prototype.writeUInt16LE =
            function (f, g, k) {
              return (
                (f = +f),
                (g = g >>> 0),
                k || E(this, f, g, 2, 65535, 0),
                (this[g] = f & 255),
                (this[g + 1] = f >>> 8),
                g + 2
              )
            }),
          (a.prototype.writeUint16BE = a.prototype.writeUInt16BE =
            function (f, g, k) {
              return (
                (f = +f),
                (g = g >>> 0),
                k || E(this, f, g, 2, 65535, 0),
                (this[g] = f >>> 8),
                (this[g + 1] = f & 255),
                g + 2
              )
            }),
          (a.prototype.writeUint32LE = a.prototype.writeUInt32LE =
            function (f, g, k) {
              return (
                (f = +f),
                (g = g >>> 0),
                k || E(this, f, g, 4, 4294967295, 0),
                (this[g + 3] = f >>> 24),
                (this[g + 2] = f >>> 16),
                (this[g + 1] = f >>> 8),
                (this[g] = f & 255),
                g + 4
              )
            }),
          (a.prototype.writeUint32BE = a.prototype.writeUInt32BE =
            function (f, g, k) {
              return (
                (f = +f),
                (g = g >>> 0),
                k || E(this, f, g, 4, 4294967295, 0),
                (this[g] = f >>> 24),
                (this[g + 1] = f >>> 16),
                (this[g + 2] = f >>> 8),
                (this[g + 3] = f & 255),
                g + 4
              )
            })
        function C(S, f, g, k, q) {
          nt(f, k, q, S, g, 7)
          let V = Number(f & BigInt(4294967295))
          ;(S[g++] = V),
            (V = V >> 8),
            (S[g++] = V),
            (V = V >> 8),
            (S[g++] = V),
            (V = V >> 8),
            (S[g++] = V)
          let Y = Number((f >> BigInt(32)) & BigInt(4294967295))
          return (
            (S[g++] = Y),
            (Y = Y >> 8),
            (S[g++] = Y),
            (Y = Y >> 8),
            (S[g++] = Y),
            (Y = Y >> 8),
            (S[g++] = Y),
            g
          )
        }
        function L(S, f, g, k, q) {
          nt(f, k, q, S, g, 7)
          let V = Number(f & BigInt(4294967295))
          ;(S[g + 7] = V),
            (V = V >> 8),
            (S[g + 6] = V),
            (V = V >> 8),
            (S[g + 5] = V),
            (V = V >> 8),
            (S[g + 4] = V)
          let Y = Number((f >> BigInt(32)) & BigInt(4294967295))
          return (
            (S[g + 3] = Y),
            (Y = Y >> 8),
            (S[g + 2] = Y),
            (Y = Y >> 8),
            (S[g + 1] = Y),
            (Y = Y >> 8),
            (S[g] = Y),
            g + 8
          )
        }
        ;(a.prototype.writeBigUInt64LE = Be(function (f, g = 0) {
          return C(this, f, g, BigInt(0), BigInt('0xffffffffffffffff'))
        })),
          (a.prototype.writeBigUInt64BE = Be(function (f, g = 0) {
            return L(this, f, g, BigInt(0), BigInt('0xffffffffffffffff'))
          })),
          (a.prototype.writeIntLE = function (f, g, k, q) {
            if (((f = +f), (g = g >>> 0), !q)) {
              const Ve = Math.pow(2, 8 * k - 1)
              E(this, f, g, k, Ve - 1, -Ve)
            }
            let V = 0,
              Y = 1,
              ke = 0
            for (this[g] = f & 255; ++V < k && (Y *= 256); )
              f < 0 && ke === 0 && this[g + V - 1] !== 0 && (ke = 1),
                (this[g + V] = (((f / Y) >> 0) - ke) & 255)
            return g + k
          }),
          (a.prototype.writeIntBE = function (f, g, k, q) {
            if (((f = +f), (g = g >>> 0), !q)) {
              const Ve = Math.pow(2, 8 * k - 1)
              E(this, f, g, k, Ve - 1, -Ve)
            }
            let V = k - 1,
              Y = 1,
              ke = 0
            for (this[g + V] = f & 255; --V >= 0 && (Y *= 256); )
              f < 0 && ke === 0 && this[g + V + 1] !== 0 && (ke = 1),
                (this[g + V] = (((f / Y) >> 0) - ke) & 255)
            return g + k
          }),
          (a.prototype.writeInt8 = function (f, g, k) {
            return (
              (f = +f),
              (g = g >>> 0),
              k || E(this, f, g, 1, 127, -128),
              f < 0 && (f = 255 + f + 1),
              (this[g] = f & 255),
              g + 1
            )
          }),
          (a.prototype.writeInt16LE = function (f, g, k) {
            return (
              (f = +f),
              (g = g >>> 0),
              k || E(this, f, g, 2, 32767, -32768),
              (this[g] = f & 255),
              (this[g + 1] = f >>> 8),
              g + 2
            )
          }),
          (a.prototype.writeInt16BE = function (f, g, k) {
            return (
              (f = +f),
              (g = g >>> 0),
              k || E(this, f, g, 2, 32767, -32768),
              (this[g] = f >>> 8),
              (this[g + 1] = f & 255),
              g + 2
            )
          }),
          (a.prototype.writeInt32LE = function (f, g, k) {
            return (
              (f = +f),
              (g = g >>> 0),
              k || E(this, f, g, 4, 2147483647, -2147483648),
              (this[g] = f & 255),
              (this[g + 1] = f >>> 8),
              (this[g + 2] = f >>> 16),
              (this[g + 3] = f >>> 24),
              g + 4
            )
          }),
          (a.prototype.writeInt32BE = function (f, g, k) {
            return (
              (f = +f),
              (g = g >>> 0),
              k || E(this, f, g, 4, 2147483647, -2147483648),
              f < 0 && (f = 4294967295 + f + 1),
              (this[g] = f >>> 24),
              (this[g + 1] = f >>> 16),
              (this[g + 2] = f >>> 8),
              (this[g + 3] = f & 255),
              g + 4
            )
          }),
          (a.prototype.writeBigInt64LE = Be(function (f, g = 0) {
            return C(this, f, g, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
          })),
          (a.prototype.writeBigInt64BE = Be(function (f, g = 0) {
            return L(this, f, g, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
          }))
        function K(S, f, g, k, q, V) {
          if (g + k > S.length) throw new RangeError('Index out of range')
          if (g < 0) throw new RangeError('Index out of range')
        }
        function ee(S, f, g, k, q) {
          return (f = +f), (g = g >>> 0), q || K(S, f, g, 4), n.write(S, f, g, k, 23, 4), g + 4
        }
        ;(a.prototype.writeFloatLE = function (f, g, k) {
          return ee(this, f, g, !0, k)
        }),
          (a.prototype.writeFloatBE = function (f, g, k) {
            return ee(this, f, g, !1, k)
          })
        function oe(S, f, g, k, q) {
          return (f = +f), (g = g >>> 0), q || K(S, f, g, 8), n.write(S, f, g, k, 52, 8), g + 8
        }
        ;(a.prototype.writeDoubleLE = function (f, g, k) {
          return oe(this, f, g, !0, k)
        }),
          (a.prototype.writeDoubleBE = function (f, g, k) {
            return oe(this, f, g, !1, k)
          }),
          (a.prototype.copy = function (f, g, k, q) {
            if (!a.isBuffer(f)) throw new TypeError('argument should be a Buffer')
            if (
              (k || (k = 0),
              !q && q !== 0 && (q = this.length),
              g >= f.length && (g = f.length),
              g || (g = 0),
              q > 0 && q < k && (q = k),
              q === k || f.length === 0 || this.length === 0)
            )
              return 0
            if (g < 0) throw new RangeError('targetStart out of bounds')
            if (k < 0 || k >= this.length) throw new RangeError('Index out of range')
            if (q < 0) throw new RangeError('sourceEnd out of bounds')
            q > this.length && (q = this.length), f.length - g < q - k && (q = f.length - g + k)
            const V = q - k
            return (
              this === f && typeof Uint8Array.prototype.copyWithin == 'function'
                ? this.copyWithin(g, k, q)
                : Uint8Array.prototype.set.call(f, this.subarray(k, q), g),
              V
            )
          }),
          (a.prototype.fill = function (f, g, k, q) {
            if (typeof f == 'string') {
              if (
                (typeof g == 'string'
                  ? ((q = g), (g = 0), (k = this.length))
                  : typeof k == 'string' && ((q = k), (k = this.length)),
                q !== void 0 && typeof q != 'string')
              )
                throw new TypeError('encoding must be a string')
              if (typeof q == 'string' && !a.isEncoding(q))
                throw new TypeError('Unknown encoding: ' + q)
              if (f.length === 1) {
                const Y = f.charCodeAt(0)
                ;((q === 'utf8' && Y < 128) || q === 'latin1') && (f = Y)
              }
            } else typeof f == 'number' ? (f = f & 255) : typeof f == 'boolean' && (f = Number(f))
            if (g < 0 || this.length < g || this.length < k)
              throw new RangeError('Out of range index')
            if (k <= g) return this
            ;(g = g >>> 0), (k = k === void 0 ? this.length : k >>> 0), f || (f = 0)
            let V
            if (typeof f == 'number') for (V = g; V < k; ++V) this[V] = f
            else {
              const Y = a.isBuffer(f) ? f : a.from(f, q),
                ke = Y.length
              if (ke === 0)
                throw new TypeError('The value "' + f + '" is invalid for argument "value"')
              for (V = 0; V < k - g; ++V) this[V + g] = Y[V % ke]
            }
            return this
          })
        const fe = {}
        function ve(S, f, g) {
          fe[S] = class extends g {
            constructor() {
              super(),
                Object.defineProperty(this, 'message', {
                  value: f.apply(this, arguments),
                  writable: !0,
                  configurable: !0
                }),
                (this.name = `${this.name} [${S}]`),
                this.stack,
                delete this.name
            }
            get code() {
              return S
            }
            set code(q) {
              Object.defineProperty(this, 'code', {
                configurable: !0,
                enumerable: !0,
                value: q,
                writable: !0
              })
            }
            toString() {
              return `${this.name} [${S}]: ${this.message}`
            }
          }
        }
        ve(
          'ERR_BUFFER_OUT_OF_BOUNDS',
          function (S) {
            return S
              ? `${S} is outside of buffer bounds`
              : 'Attempt to access memory outside buffer bounds'
          },
          RangeError
        ),
          ve(
            'ERR_INVALID_ARG_TYPE',
            function (S, f) {
              return `The "${S}" argument must be of type number. Received type ${typeof f}`
            },
            TypeError
          ),
          ve(
            'ERR_OUT_OF_RANGE',
            function (S, f, g) {
              let k = `The value of "${S}" is out of range.`,
                q = g
              return (
                Number.isInteger(g) && Math.abs(g) > 2 ** 32
                  ? (q = tt(String(g)))
                  : typeof g == 'bigint' &&
                    ((q = String(g)),
                    (g > BigInt(2) ** BigInt(32) || g < -(BigInt(2) ** BigInt(32))) && (q = tt(q)),
                    (q += 'n')),
                (k += ` It must be ${f}. Received ${q}`),
                k
              )
            },
            RangeError
          )
        function tt(S) {
          let f = '',
            g = S.length
          const k = S[0] === '-' ? 1 : 0
          for (; g >= k + 4; g -= 3) f = `_${S.slice(g - 3, g)}${f}`
          return `${S.slice(0, g)}${f}`
        }
        function Ge(S, f, g) {
          Z(f, 'offset'), (S[f] === void 0 || S[f + g] === void 0) && X(f, S.length - (g + 1))
        }
        function nt(S, f, g, k, q, V) {
          if (S > g || S < f) {
            const Y = typeof f == 'bigint' ? 'n' : ''
            let ke
            throw (
              (f === 0 || f === BigInt(0)
                ? (ke = `>= 0${Y} and < 2${Y} ** ${(V + 1) * 8}${Y}`)
                : (ke = `>= -(2${Y} ** ${(V + 1) * 8 - 1}${Y}) and < 2 ** ${(V + 1) * 8 - 1}${Y}`),
              new fe.ERR_OUT_OF_RANGE('value', ke, S))
            )
          }
          Ge(k, q, V)
        }
        function Z(S, f) {
          if (typeof S != 'number') throw new fe.ERR_INVALID_ARG_TYPE(f, 'number', S)
        }
        function X(S, f, g) {
          throw Math.floor(S) !== S
            ? (Z(S, g), new fe.ERR_OUT_OF_RANGE('offset', 'an integer', S))
            : f < 0
              ? new fe.ERR_BUFFER_OUT_OF_BOUNDS()
              : new fe.ERR_OUT_OF_RANGE('offset', `>= 0 and <= ${f}`, S)
        }
        const ie = /[^+/0-9A-Za-z-_]/g
        function be(S) {
          if (((S = S.split('=')[0]), (S = S.trim().replace(ie, '')), S.length < 2)) return ''
          for (; S.length % 4 !== 0; ) S = S + '='
          return S
        }
        function ue(S, f) {
          f = f || 1 / 0
          let g
          const k = S.length
          let q = null
          const V = []
          for (let Y = 0; Y < k; ++Y) {
            if (((g = S.charCodeAt(Y)), g > 55295 && g < 57344)) {
              if (!q) {
                if (g > 56319) {
                  ;(f -= 3) > -1 && V.push(239, 191, 189)
                  continue
                } else if (Y + 1 === k) {
                  ;(f -= 3) > -1 && V.push(239, 191, 189)
                  continue
                }
                q = g
                continue
              }
              if (g < 56320) {
                ;(f -= 3) > -1 && V.push(239, 191, 189), (q = g)
                continue
              }
              g = (((q - 55296) << 10) | (g - 56320)) + 65536
            } else q && (f -= 3) > -1 && V.push(239, 191, 189)
            if (((q = null), g < 128)) {
              if ((f -= 1) < 0) break
              V.push(g)
            } else if (g < 2048) {
              if ((f -= 2) < 0) break
              V.push((g >> 6) | 192, (g & 63) | 128)
            } else if (g < 65536) {
              if ((f -= 3) < 0) break
              V.push((g >> 12) | 224, ((g >> 6) & 63) | 128, (g & 63) | 128)
            } else if (g < 1114112) {
              if ((f -= 4) < 0) break
              V.push((g >> 18) | 240, ((g >> 12) & 63) | 128, ((g >> 6) & 63) | 128, (g & 63) | 128)
            } else throw new Error('Invalid code point')
          }
          return V
        }
        function de(S) {
          const f = []
          for (let g = 0; g < S.length; ++g) f.push(S.charCodeAt(g) & 255)
          return f
        }
        function Te(S, f) {
          let g, k, q
          const V = []
          for (let Y = 0; Y < S.length && !((f -= 2) < 0); ++Y)
            (g = S.charCodeAt(Y)), (k = g >> 8), (q = g % 256), V.push(q), V.push(k)
          return V
        }
        function we(S) {
          return e.toByteArray(be(S))
        }
        function ge(S, f, g, k) {
          let q
          for (q = 0; q < k && !(q + g >= f.length || q >= S.length); ++q) f[q + g] = S[q]
          return q
        }
        function he(S, f) {
          return (
            S instanceof f ||
            (S != null &&
              S.constructor != null &&
              S.constructor.name != null &&
              S.constructor.name === f.name)
          )
        }
        function Ne(S) {
          return S !== S
        }
        const _e = (function () {
          const S = '0123456789abcdef',
            f = new Array(256)
          for (let g = 0; g < 16; ++g) {
            const k = g * 16
            for (let q = 0; q < 16; ++q) f[k + q] = S[g] + S[q]
          }
          return f
        })()
        function Be(S) {
          return typeof BigInt > 'u' ? $e : S
        }
        function $e() {
          throw new Error('BigInt not supported')
        }
      })(yw)),
    yw
  )
}
var Nt = J3()
const IH = Symbol(),
  pS = Object.getPrototypeOf,
  K1 = new WeakMap(),
  xH = t => t && (K1.has(t) ? K1.get(t) : pS(t) === Object.prototype || pS(t) === Array.prototype),
  TH = t => (xH(t) && t[IH]) || null,
  gS = (t, e = !0) => {
    K1.set(t, e)
  },
  mm = {},
  ww = t => typeof t == 'object' && t !== null,
  _a = new WeakMap(),
  mh = new WeakSet(),
  NH = (
    t = Object.is,
    e = (u, l) => new Proxy(u, l),
    n = u =>
      ww(u) &&
      !mh.has(u) &&
      (Array.isArray(u) || !(Symbol.iterator in u)) &&
      !(u instanceof WeakMap) &&
      !(u instanceof WeakSet) &&
      !(u instanceof Error) &&
      !(u instanceof Number) &&
      !(u instanceof Date) &&
      !(u instanceof String) &&
      !(u instanceof RegExp) &&
      !(u instanceof ArrayBuffer),
    r = u => {
      switch (u.status) {
        case 'fulfilled':
          return u.value
        case 'rejected':
          throw u.reason
        default:
          throw u
      }
    },
    s = new WeakMap(),
    i = (u, l, d = r) => {
      const h = s.get(u)
      if ((h == null ? void 0 : h[0]) === l) return h[1]
      const p = Array.isArray(u) ? [] : Object.create(Object.getPrototypeOf(u))
      return (
        gS(p, !0),
        s.set(u, [l, p]),
        Reflect.ownKeys(u).forEach(y => {
          if (Object.getOwnPropertyDescriptor(p, y)) return
          const m = Reflect.get(u, y),
            { enumerable: b } = Reflect.getOwnPropertyDescriptor(u, y),
            I = { value: m, enumerable: b, configurable: !0 }
          if (mh.has(m)) gS(m, !1)
          else if (m instanceof Promise) delete I.value, (I.get = () => d(m))
          else if (_a.has(m)) {
            const [x, _] = _a.get(m)
            I.value = i(x, _(), d)
          }
          Object.defineProperty(p, y, I)
        }),
        Object.preventExtensions(p)
      )
    },
    o = new WeakMap(),
    a = [1, 1],
    c = u => {
      if (!ww(u)) throw new Error('object required')
      const l = o.get(u)
      if (l) return l
      let d = a[0]
      const h = new Set(),
        p = (B, $ = ++a[0]) => {
          d !== $ && ((d = $), h.forEach(D => D(B, $)))
        }
      let y = a[1]
      const m = (B = ++a[1]) => (
          y !== B &&
            !h.size &&
            ((y = B),
            I.forEach(([$]) => {
              const D = $[1](B)
              D > d && (d = D)
            })),
          d
        ),
        b = B => ($, D) => {
          const W = [...$]
          ;(W[1] = [B, ...W[1]]), p(W, D)
        },
        I = new Map(),
        x = (B, $) => {
          if ((mm ? 'production' : void 0) !== 'production' && I.has(B))
            throw new Error('prop listener already exists')
          if (h.size) {
            const D = $[3](b(B))
            I.set(B, [$, D])
          } else I.set(B, [$])
        },
        _ = B => {
          var $
          const D = I.get(B)
          D && (I.delete(B), ($ = D[1]) == null || $.call(D))
        },
        R = B => (
          h.add(B),
          h.size === 1 &&
            I.forEach(([D, W], U) => {
              if ((mm ? 'production' : void 0) !== 'production' && W)
                throw new Error('remove already exists')
              const w = D[3](b(U))
              I.set(U, [D, w])
            }),
          () => {
            h.delete(B),
              h.size === 0 &&
                I.forEach(([D, W], U) => {
                  W && (W(), I.set(U, [D]))
                })
          }
        ),
        N = Array.isArray(u) ? [] : Object.create(Object.getPrototypeOf(u)),
        M = e(N, {
          deleteProperty(B, $) {
            const D = Reflect.get(B, $)
            _($)
            const W = Reflect.deleteProperty(B, $)
            return W && p(['delete', [$], D]), W
          },
          set(B, $, D, W) {
            const U = Reflect.has(B, $),
              w = Reflect.get(B, $, W)
            if (U && (t(w, D) || (o.has(D) && t(w, o.get(D))))) return !0
            _($), ww(D) && (D = TH(D) || D)
            let v = D
            if (D instanceof Promise)
              D.then(A => {
                ;(D.status = 'fulfilled'), (D.value = A), p(['resolve', [$], A])
              }).catch(A => {
                ;(D.status = 'rejected'), (D.reason = A), p(['reject', [$], A])
              })
            else {
              !_a.has(D) && n(D) && (v = c(D))
              const A = !mh.has(v) && _a.get(v)
              A && x($, A)
            }
            return Reflect.set(B, $, v, W), p(['set', [$], D, w]), !0
          }
        })
      o.set(u, M)
      const H = [N, m, i, R]
      return (
        _a.set(M, H),
        Reflect.ownKeys(u).forEach(B => {
          const $ = Object.getOwnPropertyDescriptor(u, B)
          'value' in $ && ((M[B] = u[B]), delete $.value, delete $.writable),
            Object.defineProperty(N, B, $)
        }),
        M
      )
    }
  ) => [c, _a, mh, t, e, n, r, s, i, o, a],
  [PH] = NH()
function xn(t = {}) {
  return PH(t)
}
function Qr(t, e, n) {
  const r = _a.get(t)
  ;(mm ? 'production' : void 0) !== 'production' && !r && console.warn('Please use proxy object')
  let s
  const i = [],
    o = r[3]
  let a = !1
  const u = o(l => {
    i.push(l),
      s ||
        (s = Promise.resolve().then(() => {
          ;(s = void 0), a && e(i.splice(0))
        }))
  })
  return (
    (a = !0),
    () => {
      ;(a = !1), u()
    }
  )
}
function mf(t, e) {
  const n = _a.get(t)
  ;(mm ? 'production' : void 0) !== 'production' && !n && console.warn('Please use proxy object')
  const [r, s, i] = n
  return i(r, s(), e)
}
function tc(t) {
  return mh.add(t), t
}
function Yr(t, e, n, r) {
  let s = t[e]
  return Qr(t, () => {
    const i = t[e]
    Object.is(s, i) || n((s = i))
  })
}
function RH(t) {
  const e = xn({
    data: Array.from([]),
    has(n) {
      return this.data.some(r => r[0] === n)
    },
    set(n, r) {
      const s = this.data.find(i => i[0] === n)
      return s ? (s[1] = r) : this.data.push([n, r]), this
    },
    get(n) {
      var r
      return (r = this.data.find(s => s[0] === n)) == null ? void 0 : r[1]
    },
    delete(n) {
      const r = this.data.findIndex(s => s[0] === n)
      return r === -1 ? !1 : (this.data.splice(r, 1), !0)
    },
    clear() {
      this.data.splice(0)
    },
    get size() {
      return this.data.length
    },
    toJSON() {
      return new Map(this.data)
    },
    forEach(n) {
      this.data.forEach(r => {
        n(r[1], r[0], this)
      })
    },
    keys() {
      return this.data.map(n => n[0]).values()
    },
    values() {
      return this.data.map(n => n[1]).values()
    },
    entries() {
      return new Map(this.data).entries()
    },
    get [Symbol.toStringTag]() {
      return 'Map'
    },
    [Symbol.iterator]() {
      return this.entries()
    }
  })
  return (
    Object.defineProperties(e, {
      data: { enumerable: !1 },
      size: { enumerable: !1 },
      toJSON: { enumerable: !1 }
    }),
    Object.seal(e),
    e
  )
}
const yf = {
  caipNetworkIdToNumber(t) {
    return t ? Number(t.split(':')[1]) : void 0
  },
  parseEvmChainId(t) {
    return typeof t == 'string' ? this.caipNetworkIdToNumber(t) : t
  },
  getNetworksByNamespace(t, e) {
    return (t == null ? void 0 : t.filter(n => n.chainNamespace === e)) || []
  },
  getFirstNetworkByNamespace(t, e) {
    return this.getNetworksByNamespace(t, e)[0]
  }
}
var kH = 20,
  OH = 1,
  Cd = 1e6,
  BH = 1e6,
  DH = -7,
  MH = 21,
  UH = !1,
  cp = '[big.js] ',
  Cu = cp + 'Invalid ',
  R0 = Cu + 'decimal places',
  LH = Cu + 'rounding mode',
  X3 = cp + 'Division by zero',
  sn = {},
  to = void 0,
  $H = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i
function ek() {
  function t(e) {
    var n = this
    if (!(n instanceof t)) return e === to ? ek() : new t(e)
    if (e instanceof t) (n.s = e.s), (n.e = e.e), (n.c = e.c.slice())
    else {
      if (typeof e != 'string') {
        if (t.strict === !0 && typeof e != 'bigint') throw TypeError(Cu + 'value')
        e = e === 0 && 1 / e < 0 ? '-0' : String(e)
      }
      FH(n, e)
    }
    n.constructor = t
  }
  return (
    (t.prototype = sn),
    (t.DP = kH),
    (t.RM = OH),
    (t.NE = DH),
    (t.PE = MH),
    (t.strict = UH),
    (t.roundDown = 0),
    (t.roundHalfUp = 1),
    (t.roundHalfEven = 2),
    (t.roundUp = 3),
    t
  )
}
function FH(t, e) {
  var n, r, s
  if (!$H.test(e)) throw Error(Cu + 'number')
  for (
    t.s = e.charAt(0) == '-' ? ((e = e.slice(1)), -1) : 1,
      (n = e.indexOf('.')) > -1 && (e = e.replace('.', '')),
      (r = e.search(/e/i)) > 0
        ? (n < 0 && (n = r), (n += +e.slice(r + 1)), (e = e.substring(0, r)))
        : n < 0 && (n = e.length),
      s = e.length,
      r = 0;
    r < s && e.charAt(r) == '0';

  )
    ++r
  if (r == s) t.c = [(t.e = 0)]
  else {
    for (; s > 0 && e.charAt(--s) == '0'; );
    for (t.e = n - r - 1, t.c = [], n = 0; r <= s; ) t.c[n++] = +e.charAt(r++)
  }
  return t
}
function Su(t, e, n, r) {
  var s = t.c
  if ((n === to && (n = t.constructor.RM), n !== 0 && n !== 1 && n !== 2 && n !== 3))
    throw Error(LH)
  if (e < 1)
    (r =
      (n === 3 && (r || !!s[0])) ||
      (e === 0 &&
        ((n === 1 && s[0] >= 5) || (n === 2 && (s[0] > 5 || (s[0] === 5 && (r || s[1] !== to))))))),
      (s.length = 1),
      r ? ((t.e = t.e - e + 1), (s[0] = 1)) : (s[0] = t.e = 0)
  else if (e < s.length) {
    if (
      ((r =
        (n === 1 && s[e] >= 5) ||
        (n === 2 && (s[e] > 5 || (s[e] === 5 && (r || s[e + 1] !== to || s[e - 1] & 1)))) ||
        (n === 3 && (r || !!s[0]))),
      (s.length = e),
      r)
    ) {
      for (; ++s[--e] > 9; )
        if (((s[e] = 0), e === 0)) {
          ++t.e, s.unshift(1)
          break
        }
    }
    for (e = s.length; !s[--e]; ) s.pop()
  }
  return t
}
function Iu(t, e, n) {
  var r = t.e,
    s = t.c.join(''),
    i = s.length
  if (e) s = s.charAt(0) + (i > 1 ? '.' + s.slice(1) : '') + (r < 0 ? 'e' : 'e+') + r
  else if (r < 0) {
    for (; ++r; ) s = '0' + s
    s = '0.' + s
  } else if (r > 0)
    if (++r > i) for (r -= i; r--; ) s += '0'
    else r < i && (s = s.slice(0, r) + '.' + s.slice(r))
  else i > 1 && (s = s.charAt(0) + '.' + s.slice(1))
  return t.s < 0 && n ? '-' + s : s
}
sn.abs = function () {
  var t = new this.constructor(this)
  return (t.s = 1), t
}
sn.cmp = function (t) {
  var e,
    n = this,
    r = n.c,
    s = (t = new n.constructor(t)).c,
    i = n.s,
    o = t.s,
    a = n.e,
    c = t.e
  if (!r[0] || !s[0]) return r[0] ? i : s[0] ? -o : 0
  if (i != o) return i
  if (((e = i < 0), a != c)) return (a > c) ^ e ? 1 : -1
  for (o = (a = r.length) < (c = s.length) ? a : c, i = -1; ++i < o; )
    if (r[i] != s[i]) return (r[i] > s[i]) ^ e ? 1 : -1
  return a == c ? 0 : (a > c) ^ e ? 1 : -1
}
sn.div = function (t) {
  var e = this,
    n = e.constructor,
    r = e.c,
    s = (t = new n(t)).c,
    i = e.s == t.s ? 1 : -1,
    o = n.DP
  if (o !== ~~o || o < 0 || o > Cd) throw Error(R0)
  if (!s[0]) throw Error(X3)
  if (!r[0]) return (t.s = i), (t.c = [(t.e = 0)]), t
  var a,
    c,
    u,
    l,
    d,
    h = s.slice(),
    p = (a = s.length),
    y = r.length,
    m = r.slice(0, a),
    b = m.length,
    I = t,
    x = (I.c = []),
    _ = 0,
    R = o + (I.e = e.e - t.e) + 1
  for (I.s = i, i = R < 0 ? 0 : R, h.unshift(0); b++ < a; ) m.push(0)
  do {
    for (u = 0; u < 10; u++) {
      if (a != (b = m.length)) l = a > b ? 1 : -1
      else
        for (d = -1, l = 0; ++d < a; )
          if (s[d] != m[d]) {
            l = s[d] > m[d] ? 1 : -1
            break
          }
      if (l < 0) {
        for (c = b == a ? s : h; b; ) {
          if (m[--b] < c[b]) {
            for (d = b; d && !m[--d]; ) m[d] = 9
            --m[d], (m[b] += 10)
          }
          m[b] -= c[b]
        }
        for (; !m[0]; ) m.shift()
      } else break
    }
    ;(x[_++] = l ? u : ++u), m[0] && l ? (m[b] = r[p] || 0) : (m = [r[p]])
  } while ((p++ < y || m[0] !== to) && i--)
  return !x[0] && _ != 1 && (x.shift(), I.e--, R--), _ > R && Su(I, R, n.RM, m[0] !== to), I
}
sn.eq = function (t) {
  return this.cmp(t) === 0
}
sn.gt = function (t) {
  return this.cmp(t) > 0
}
sn.gte = function (t) {
  return this.cmp(t) > -1
}
sn.lt = function (t) {
  return this.cmp(t) < 0
}
sn.lte = function (t) {
  return this.cmp(t) < 1
}
sn.minus = sn.sub = function (t) {
  var e,
    n,
    r,
    s,
    i = this,
    o = i.constructor,
    a = i.s,
    c = (t = new o(t)).s
  if (a != c) return (t.s = -c), i.plus(t)
  var u = i.c.slice(),
    l = i.e,
    d = t.c,
    h = t.e
  if (!u[0] || !d[0]) return d[0] ? (t.s = -c) : u[0] ? (t = new o(i)) : (t.s = 1), t
  if ((a = l - h)) {
    for ((s = a < 0) ? ((a = -a), (r = u)) : ((h = l), (r = d)), r.reverse(), c = a; c--; )
      r.push(0)
    r.reverse()
  } else
    for (n = ((s = u.length < d.length) ? u : d).length, a = c = 0; c < n; c++)
      if (u[c] != d[c]) {
        s = u[c] < d[c]
        break
      }
  if ((s && ((r = u), (u = d), (d = r), (t.s = -t.s)), (c = (n = d.length) - (e = u.length)) > 0))
    for (; c--; ) u[e++] = 0
  for (c = e; n > a; ) {
    if (u[--n] < d[n]) {
      for (e = n; e && !u[--e]; ) u[e] = 9
      --u[e], (u[n] += 10)
    }
    u[n] -= d[n]
  }
  for (; u[--c] === 0; ) u.pop()
  for (; u[0] === 0; ) u.shift(), --h
  return u[0] || ((t.s = 1), (u = [(h = 0)])), (t.c = u), (t.e = h), t
}
sn.mod = function (t) {
  var e,
    n = this,
    r = n.constructor,
    s = n.s,
    i = (t = new r(t)).s
  if (!t.c[0]) throw Error(X3)
  return (
    (n.s = t.s = 1),
    (e = t.cmp(n) == 1),
    (n.s = s),
    (t.s = i),
    e
      ? new r(n)
      : ((s = r.DP),
        (i = r.RM),
        (r.DP = r.RM = 0),
        (n = n.div(t)),
        (r.DP = s),
        (r.RM = i),
        this.minus(n.times(t)))
  )
}
sn.neg = function () {
  var t = new this.constructor(this)
  return (t.s = -t.s), t
}
sn.plus = sn.add = function (t) {
  var e,
    n,
    r,
    s = this,
    i = s.constructor
  if (((t = new i(t)), s.s != t.s)) return (t.s = -t.s), s.minus(t)
  var o = s.e,
    a = s.c,
    c = t.e,
    u = t.c
  if (!a[0] || !u[0]) return u[0] || (a[0] ? (t = new i(s)) : (t.s = s.s)), t
  if (((a = a.slice()), (e = o - c))) {
    for (e > 0 ? ((c = o), (r = u)) : ((e = -e), (r = a)), r.reverse(); e--; ) r.push(0)
    r.reverse()
  }
  for (a.length - u.length < 0 && ((r = u), (u = a), (a = r)), e = u.length, n = 0; e; a[e] %= 10)
    n = ((a[--e] = a[e] + u[e] + n) / 10) | 0
  for (n && (a.unshift(n), ++c), e = a.length; a[--e] === 0; ) a.pop()
  return (t.c = a), (t.e = c), t
}
sn.pow = function (t) {
  var e = this,
    n = new e.constructor('1'),
    r = n,
    s = t < 0
  if (t !== ~~t || t < -1e6 || t > BH) throw Error(Cu + 'exponent')
  for (s && (t = -t); t & 1 && (r = r.times(e)), (t >>= 1), !!t; ) e = e.times(e)
  return s ? n.div(r) : r
}
sn.prec = function (t, e) {
  if (t !== ~~t || t < 1 || t > Cd) throw Error(Cu + 'precision')
  return Su(new this.constructor(this), t, e)
}
sn.round = function (t, e) {
  if (t === to) t = 0
  else if (t !== ~~t || t < -1e6 || t > Cd) throw Error(R0)
  return Su(new this.constructor(this), t + this.e + 1, e)
}
sn.sqrt = function () {
  var t,
    e,
    n,
    r = this,
    s = r.constructor,
    i = r.s,
    o = r.e,
    a = new s('0.5')
  if (!r.c[0]) return new s(r)
  if (i < 0) throw Error(cp + 'No square root')
  ;(i = Math.sqrt(+Iu(r, !0, !0))),
    i === 0 || i === 1 / 0
      ? ((e = r.c.join('')),
        (e.length + o) & 1 || (e += '0'),
        (i = Math.sqrt(e)),
        (o = (((o + 1) / 2) | 0) - (o < 0 || o & 1)),
        (t = new s((i == 1 / 0 ? '5e' : (i = i.toExponential()).slice(0, i.indexOf('e') + 1)) + o)))
      : (t = new s(i + '')),
    (o = t.e + (s.DP += 4))
  do (n = t), (t = a.times(n.plus(r.div(n))))
  while (n.c.slice(0, o).join('') !== t.c.slice(0, o).join(''))
  return Su(t, (s.DP -= 4) + t.e + 1, s.RM)
}
sn.times = sn.mul = function (t) {
  var e,
    n = this,
    r = n.constructor,
    s = n.c,
    i = (t = new r(t)).c,
    o = s.length,
    a = i.length,
    c = n.e,
    u = t.e
  if (((t.s = n.s == t.s ? 1 : -1), !s[0] || !i[0])) return (t.c = [(t.e = 0)]), t
  for (
    t.e = c + u,
      o < a && ((e = s), (s = i), (i = e), (u = o), (o = a), (a = u)),
      e = new Array((u = o + a));
    u--;

  )
    e[u] = 0
  for (c = a; c--; ) {
    for (a = 0, u = o + c; u > c; )
      (a = e[u] + i[c] * s[u - c - 1] + a), (e[u--] = a % 10), (a = (a / 10) | 0)
    e[u] = a
  }
  for (a ? ++t.e : e.shift(), c = e.length; !e[--c]; ) e.pop()
  return (t.c = e), t
}
sn.toExponential = function (t, e) {
  var n = this,
    r = n.c[0]
  if (t !== to) {
    if (t !== ~~t || t < 0 || t > Cd) throw Error(R0)
    for (n = Su(new n.constructor(n), ++t, e); n.c.length < t; ) n.c.push(0)
  }
  return Iu(n, !0, !!r)
}
sn.toFixed = function (t, e) {
  var n = this,
    r = n.c[0]
  if (t !== to) {
    if (t !== ~~t || t < 0 || t > Cd) throw Error(R0)
    for (n = Su(new n.constructor(n), t + n.e + 1, e), t = t + n.e + 1; n.c.length < t; )
      n.c.push(0)
  }
  return Iu(n, !1, !!r)
}
sn[Symbol.for('nodejs.util.inspect.custom')] =
  sn.toJSON =
  sn.toString =
    function () {
      var t = this,
        e = t.constructor
      return Iu(t, t.e <= e.NE || t.e >= e.PE, !!t.c[0])
    }
sn.toNumber = function () {
  var t = +Iu(this, !0, !0)
  if (this.constructor.strict === !0 && !this.eq(t.toString()))
    throw Error(cp + 'Imprecise conversion')
  return t
}
sn.toPrecision = function (t, e) {
  var n = this,
    r = n.constructor,
    s = n.c[0]
  if (t !== to) {
    if (t !== ~~t || t < 1 || t > Cd) throw Error(Cu + 'precision')
    for (n = Su(new r(n), t, e); n.c.length < t; ) n.c.push(0)
  }
  return Iu(n, t <= n.e || n.e <= r.NE || n.e >= r.PE, !!s)
}
sn.valueOf = function () {
  var t = this,
    e = t.constructor
  if (e.strict === !0) throw Error(cp + 'valueOf disallowed')
  return Iu(t, t.e <= e.NE || t.e >= e.PE, !0)
}
var zd = ek()
const Jp = {
    bigNumber(t) {
      return t ? new zd(t) : new zd(0)
    },
    multiply(t, e) {
      if (t === void 0 || e === void 0) return new zd(0)
      const n = new zd(t),
        r = new zd(e)
      return n.times(r)
    },
    formatNumberToLocalString(t, e = 2) {
      return t === void 0
        ? '0.00'
        : typeof t == 'number'
          ? t.toLocaleString('en-US', { maximumFractionDigits: e, minimumFractionDigits: e })
          : parseFloat(t).toLocaleString('en-US', {
              maximumFractionDigits: e,
              minimumFractionDigits: e
            })
    },
    parseLocalStringToNumber(t) {
      return t === void 0 ? 0 : parseFloat(t.replace(/,/gu, ''))
    }
  },
  jH = [
    {
      type: 'function',
      name: 'transfer',
      stateMutability: 'nonpayable',
      inputs: [
        { name: '_to', type: 'address' },
        { name: '_value', type: 'uint256' }
      ],
      outputs: [{ name: '', type: 'bool' }]
    },
    {
      type: 'function',
      name: 'transferFrom',
      stateMutability: 'nonpayable',
      inputs: [
        { name: '_from', type: 'address' },
        { name: '_to', type: 'address' },
        { name: '_value', type: 'uint256' }
      ],
      outputs: [{ name: '', type: 'bool' }]
    }
  ],
  HH = [
    {
      type: 'function',
      name: 'approve',
      stateMutability: 'nonpayable',
      inputs: [
        { name: 'spender', type: 'address' },
        { name: 'amount', type: 'uint256' }
      ],
      outputs: [{ type: 'bool' }]
    }
  ],
  qH = [
    {
      type: 'function',
      name: 'transfer',
      stateMutability: 'nonpayable',
      inputs: [
        { name: 'recipient', type: 'address' },
        { name: 'amount', type: 'uint256' }
      ],
      outputs: []
    },
    {
      type: 'function',
      name: 'transferFrom',
      stateMutability: 'nonpayable',
      inputs: [
        { name: 'sender', type: 'address' },
        { name: 'recipient', type: 'address' },
        { name: 'amount', type: 'uint256' }
      ],
      outputs: [{ name: '', type: 'bool' }]
    }
  ],
  Ae = {
    WC_NAME_SUFFIX: '.reown.id',
    WC_NAME_SUFFIX_LEGACY: '.wcn.id',
    BLOCKCHAIN_API_RPC_URL: 'https://rpc.walletconnect.org',
    PULSE_API_URL: 'https://pulse.walletconnect.org',
    W3M_API_URL: 'https://api.web3modal.org',
    CONNECTOR_ID: {
      WALLET_CONNECT: 'walletConnect',
      INJECTED: 'injected',
      WALLET_STANDARD: 'announced',
      COINBASE: 'coinbaseWallet',
      COINBASE_SDK: 'coinbaseWalletSDK',
      SAFE: 'safe',
      LEDGER: 'ledger',
      OKX: 'okx',
      EIP6963: 'eip6963',
      AUTH: 'ID_AUTH'
    },
    CONNECTOR_NAMES: { AUTH: 'Auth' },
    AUTH_CONNECTOR_SUPPORTED_CHAINS: ['eip155', 'solana'],
    LIMITS: { PENDING_TRANSACTIONS: 99 },
    CHAIN: { EVM: 'eip155', SOLANA: 'solana', POLKADOT: 'polkadot', BITCOIN: 'bip122' },
    CHAIN_NAME_MAP: {
      eip155: 'EVM Networks',
      solana: 'Solana',
      polkadot: 'Polkadot',
      bip122: 'Bitcoin'
    },
    ADAPTER_TYPES: {
      BITCOIN: 'bitcoin',
      SOLANA: 'solana',
      WAGMI: 'wagmi',
      ETHERS: 'ethers',
      ETHERS5: 'ethers5'
    },
    USDT_CONTRACT_ADDRESSES: [
      '0xdac17f958d2ee523a2206206994597c13d831ec7',
      '0xc2132d05d31c914a87c6611c10748aeb04b58e8f',
      '0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7',
      '0x919C1c267BC06a7039e03fcc2eF738525769109c',
      '0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e',
      '0x55d398326f99059fF775485246999027B3197955',
      '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9'
    ],
    HTTP_STATUS_CODES: { SERVICE_UNAVAILABLE: 503, FORBIDDEN: 403 },
    UNSUPPORTED_NETWORK_NAME: 'Unknown Network'
  },
  zH = {
    getERC20Abi: t => (Ae.USDT_CONTRACT_ADDRESSES.includes(t) ? qH : jH),
    getSwapAbi: () => HH
  },
  Bo = {
    validateCaipAddress(t) {
      var e
      if (((e = t.split(':')) == null ? void 0 : e.length) !== 3)
        throw new Error('Invalid CAIP Address')
      return t
    },
    parseCaipAddress(t) {
      const e = t.split(':')
      if (e.length !== 3) throw new Error(`Invalid CAIP-10 address: ${t}`)
      const [n, r, s] = e
      if (!n || !r || !s) throw new Error(`Invalid CAIP-10 address: ${t}`)
      return { chainNamespace: n, chainId: r, address: s }
    },
    parseCaipNetworkId(t) {
      const e = t.split(':')
      if (e.length !== 2) throw new Error(`Invalid CAIP-2 network id: ${t}`)
      const [n, r] = e
      if (!n || !r) throw new Error(`Invalid CAIP-2 network id: ${t}`)
      return { chainNamespace: n, chainId: r }
    }
  },
  Rt = {
    WALLET_ID: '@appkit/wallet_id',
    WALLET_NAME: '@appkit/wallet_name',
    SOLANA_WALLET: '@appkit/solana_wallet',
    SOLANA_CAIP_CHAIN: '@appkit/solana_caip_chain',
    ACTIVE_CAIP_NETWORK_ID: '@appkit/active_caip_network_id',
    CONNECTED_SOCIAL: '@appkit/connected_social',
    CONNECTED_SOCIAL_USERNAME: '@appkit-wallet/SOCIAL_USERNAME',
    RECENT_WALLETS: '@appkit/recent_wallets',
    DEEPLINK_CHOICE: 'WALLETCONNECT_DEEPLINK_CHOICE',
    ACTIVE_NAMESPACE: '@appkit/active_namespace',
    CONNECTED_NAMESPACES: '@appkit/connected_namespaces',
    CONNECTION_STATUS: '@appkit/connection_status',
    SIWX_AUTH_TOKEN: '@appkit/siwx-auth-token',
    SIWX_NONCE_TOKEN: '@appkit/siwx-nonce-token',
    TELEGRAM_SOCIAL_PROVIDER: '@appkit/social_provider',
    NATIVE_BALANCE_CACHE: '@appkit/native_balance_cache',
    PORTFOLIO_CACHE: '@appkit/portfolio_cache',
    ENS_CACHE: '@appkit/ens_cache',
    IDENTITY_CACHE: '@appkit/identity_cache',
    PREFERRED_ACCOUNT_TYPES: '@appkit/preferred_account_types'
  }
function bw(t) {
  if (!t) throw new Error('Namespace is required for CONNECTED_CONNECTOR_ID')
  return `@appkit/${t}:connected_connector_id`
}
const St = {
  setItem(t, e) {
    yh() && e !== void 0 && localStorage.setItem(t, e)
  },
  getItem(t) {
    if (yh()) return localStorage.getItem(t) || void 0
  },
  removeItem(t) {
    yh() && localStorage.removeItem(t)
  },
  clear() {
    yh() && localStorage.clear()
  }
}
function yh() {
  return typeof window < 'u' && typeof localStorage < 'u'
}
function zo(t, e) {
  return e === 'light'
    ? {
        '--w3m-accent': (t == null ? void 0 : t['--w3m-accent']) || 'hsla(231, 100%, 70%, 1)',
        '--w3m-background': '#fff'
      }
    : {
        '--w3m-accent': (t == null ? void 0 : t['--w3m-accent']) || 'hsla(230, 100%, 67%, 1)',
        '--w3m-background': '#121313'
      }
}
function WH(t) {
  return (
    (t == null ? void 0 : t.endsWith(Ae.WC_NAME_SUFFIX_LEGACY)) ||
    (t == null ? void 0 : t.endsWith(Ae.WC_NAME_SUFFIX))
  )
}
var mS = {}
const vw =
    (typeof process < 'u' && typeof mS < 'u' ? mS.NEXT_PUBLIC_SECURE_SITE_ORIGIN : void 0) ||
    'https://secure.walletconnect.org',
  Mge = [
    { label: 'Coinbase', name: 'coinbase', feeRange: '1-2%', url: '', supportedChains: ['eip155'] },
    {
      label: 'Meld.io',
      name: 'meld',
      feeRange: '1-2%',
      url: 'https://meldcrypto.com',
      supportedChains: ['eip155', 'solana']
    }
  ],
  Uge = 'WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU',
  gr = {
    FOUR_MINUTES_MS: 24e4,
    TEN_SEC_MS: 1e4,
    FIVE_SEC_MS: 5e3,
    THREE_SEC_MS: 3e3,
    ONE_SEC_MS: 1e3,
    SECURE_SITE: vw,
    SECURE_SITE_DASHBOARD: `${vw}/dashboard`,
    SECURE_SITE_FAVICON: `${vw}/images/favicon.png`,
    RESTRICTED_TIMEZONES: [
      'ASIA/SHANGHAI',
      'ASIA/URUMQI',
      'ASIA/CHONGQING',
      'ASIA/HARBIN',
      'ASIA/KASHGAR',
      'ASIA/MACAU',
      'ASIA/HONG_KONG',
      'ASIA/MACAO',
      'ASIA/BEIJING',
      'ASIA/HARBIN'
    ],
    WC_COINBASE_PAY_SDK_CHAINS: [
      'ethereum',
      'arbitrum',
      'polygon',
      'berachain',
      'avalanche-c-chain',
      'optimism',
      'celo',
      'base'
    ],
    WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: 'ethereum',
    WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
      Ethereum: 'ethereum',
      'Arbitrum One': 'arbitrum',
      Polygon: 'polygon',
      Berachain: 'berachain',
      Avalanche: 'avalanche-c-chain',
      'OP Mainnet': 'optimism',
      Celo: 'celo',
      Base: 'base'
    },
    WC_COINBASE_ONRAMP_APP_ID: 'bf18c88d-495a-463b-b249-0b9d3656cf5e',
    SWAP_SUGGESTED_TOKENS: [
      'ETH',
      'UNI',
      '1INCH',
      'AAVE',
      'SOL',
      'ADA',
      'AVAX',
      'DOT',
      'LINK',
      'NITRO',
      'GAIA',
      'MILK',
      'TRX',
      'NEAR',
      'GNO',
      'WBTC',
      'DAI',
      'WETH',
      'USDC',
      'USDT',
      'ARB',
      'BAL',
      'BICO',
      'CRV',
      'ENS',
      'MATIC',
      'OP'
    ],
    SWAP_POPULAR_TOKENS: [
      'ETH',
      'UNI',
      '1INCH',
      'AAVE',
      'SOL',
      'ADA',
      'AVAX',
      'DOT',
      'LINK',
      'NITRO',
      'GAIA',
      'MILK',
      'TRX',
      'NEAR',
      'GNO',
      'WBTC',
      'DAI',
      'WETH',
      'USDC',
      'USDT',
      'ARB',
      'BAL',
      'BICO',
      'CRV',
      'ENS',
      'MATIC',
      'OP',
      'METAL',
      'DAI',
      'CHAMP',
      'WOLF',
      'SALE',
      'BAL',
      'BUSD',
      'MUST',
      'BTCpx',
      'ROUTE',
      'HEX',
      'WELT',
      'amDAI',
      'VSQ',
      'VISION',
      'AURUM',
      'pSP',
      'SNX',
      'VC',
      'LINK',
      'CHP',
      'amUSDT',
      'SPHERE',
      'FOX',
      'GIDDY',
      'GFC',
      'OMEN',
      'OX_OLD',
      'DE',
      'WNT'
    ],
    BALANCE_SUPPORTED_CHAINS: ['eip155', 'solana'],
    SWAP_SUPPORTED_NETWORKS: [
      'eip155:1',
      'eip155:42161',
      'eip155:10',
      'eip155:324',
      'eip155:8453',
      'eip155:56',
      'eip155:137',
      'eip155:100',
      'eip155:43114',
      'eip155:250',
      'eip155:8217',
      'eip155:1313161554'
    ],
    NAMES_SUPPORTED_CHAIN_NAMESPACES: ['eip155'],
    ONRAMP_SUPPORTED_CHAIN_NAMESPACES: ['eip155', 'solana'],
    ACTIVITY_ENABLED_CHAIN_NAMESPACES: ['eip155'],
    NATIVE_TOKEN_ADDRESS: {
      eip155: '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee',
      solana: 'So11111111111111111111111111111111111111111',
      polkadot: '0x',
      bip122: '0x'
    },
    CONVERT_SLIPPAGE_TOLERANCE: 1,
    CONNECT_LABELS: { MOBILE: 'Open and continue in a new browser tab' },
    DEFAULT_FEATURES: {
      swaps: !0,
      onramp: !0,
      receive: !0,
      send: !0,
      email: !0,
      emailShowWallets: !0,
      socials: ['google', 'x', 'discord', 'farcaster', 'github', 'apple', 'facebook'],
      connectorTypeOrder: [
        'walletConnect',
        'recent',
        'injected',
        'featured',
        'custom',
        'external',
        'recommended'
      ],
      history: !0,
      analytics: !0,
      allWallets: !0,
      legalCheckbox: !1,
      smartSessions: !1,
      collapseWallets: !1,
      walletFeaturesOrder: ['onramp', 'swaps', 'receive', 'send'],
      connectMethodsOrder: void 0
    },
    DEFAULT_ACCOUNT_TYPES: {
      bip122: 'payment',
      eip155: 'smartAccount',
      polkadot: 'eoa',
      solana: 'eoa'
    },
    ADAPTER_TYPES: {
      UNIVERSAL: 'universal',
      SOLANA: 'solana',
      WAGMI: 'wagmi',
      ETHERS: 'ethers',
      ETHERS5: 'ethers5',
      BITCOIN: 'bitcoin'
    }
  },
  Ke = {
    cacheExpiry: { portfolio: 3e4, nativeBalance: 3e4, ens: 3e5, identity: 3e5 },
    isCacheExpired(t, e) {
      return Date.now() - t > e
    },
    getActiveNetworkProps() {
      const t = Ke.getActiveNamespace(),
        e = Ke.getActiveCaipNetworkId(),
        n = e ? e.split(':')[1] : void 0,
        r = n ? (isNaN(Number(n)) ? n : Number(n)) : void 0
      return { namespace: t, caipNetworkId: e, chainId: r }
    },
    setWalletConnectDeepLink({ name: t, href: e }) {
      try {
        St.setItem(Rt.DEEPLINK_CHOICE, JSON.stringify({ href: e, name: t }))
      } catch {
        console.info('Unable to set WalletConnect deep link')
      }
    },
    getWalletConnectDeepLink() {
      try {
        const t = St.getItem(Rt.DEEPLINK_CHOICE)
        if (t) return JSON.parse(t)
      } catch {
        console.info('Unable to get WalletConnect deep link')
      }
    },
    deleteWalletConnectDeepLink() {
      try {
        St.removeItem(Rt.DEEPLINK_CHOICE)
      } catch {
        console.info('Unable to delete WalletConnect deep link')
      }
    },
    setActiveNamespace(t) {
      try {
        St.setItem(Rt.ACTIVE_NAMESPACE, t)
      } catch {
        console.info('Unable to set active namespace')
      }
    },
    setActiveCaipNetworkId(t) {
      try {
        St.setItem(Rt.ACTIVE_CAIP_NETWORK_ID, t), Ke.setActiveNamespace(t.split(':')[0])
      } catch {
        console.info('Unable to set active caip network id')
      }
    },
    getActiveCaipNetworkId() {
      try {
        return St.getItem(Rt.ACTIVE_CAIP_NETWORK_ID)
      } catch {
        console.info('Unable to get active caip network id')
        return
      }
    },
    deleteActiveCaipNetworkId() {
      try {
        St.removeItem(Rt.ACTIVE_CAIP_NETWORK_ID)
      } catch {
        console.info('Unable to delete active caip network id')
      }
    },
    deleteConnectedConnectorId(t) {
      try {
        const e = bw(t)
        St.removeItem(e)
      } catch {
        console.info('Unable to delete connected connector id')
      }
    },
    setAppKitRecent(t) {
      try {
        const e = Ke.getRecentWallets()
        e.find(r => r.id === t.id) ||
          (e.unshift(t), e.length > 2 && e.pop(), St.setItem(Rt.RECENT_WALLETS, JSON.stringify(e)))
      } catch {
        console.info('Unable to set AppKit recent')
      }
    },
    getRecentWallets() {
      try {
        const t = St.getItem(Rt.RECENT_WALLETS)
        return t ? JSON.parse(t) : []
      } catch {
        console.info('Unable to get AppKit recent')
      }
      return []
    },
    setConnectedConnectorId(t, e) {
      try {
        const n = bw(t)
        St.setItem(n, e)
      } catch {
        console.info('Unable to set Connected Connector Id')
      }
    },
    getActiveNamespace() {
      try {
        return St.getItem(Rt.ACTIVE_NAMESPACE)
      } catch {
        console.info('Unable to get active namespace')
      }
    },
    getConnectedConnectorId(t) {
      if (t)
        try {
          const e = bw(t)
          return St.getItem(e)
        } catch {
          console.info('Unable to get connected connector id in namespace ', t)
        }
    },
    setConnectedSocialProvider(t) {
      try {
        St.setItem(Rt.CONNECTED_SOCIAL, t)
      } catch {
        console.info('Unable to set connected social provider')
      }
    },
    getConnectedSocialProvider() {
      try {
        return St.getItem(Rt.CONNECTED_SOCIAL)
      } catch {
        console.info('Unable to get connected social provider')
      }
    },
    deleteConnectedSocialProvider() {
      try {
        St.removeItem(Rt.CONNECTED_SOCIAL)
      } catch {
        console.info('Unable to delete connected social provider')
      }
    },
    getConnectedSocialUsername() {
      try {
        return St.getItem(Rt.CONNECTED_SOCIAL_USERNAME)
      } catch {
        console.info('Unable to get connected social username')
      }
    },
    getStoredActiveCaipNetworkId() {
      var n
      const t = St.getItem(Rt.ACTIVE_CAIP_NETWORK_ID)
      return (n = t == null ? void 0 : t.split(':')) == null ? void 0 : n[1]
    },
    setConnectionStatus(t) {
      try {
        St.setItem(Rt.CONNECTION_STATUS, t)
      } catch {
        console.info('Unable to set connection status')
      }
    },
    getConnectionStatus() {
      try {
        return St.getItem(Rt.CONNECTION_STATUS)
      } catch {
        return
      }
    },
    getConnectedNamespaces() {
      try {
        const t = St.getItem(Rt.CONNECTED_NAMESPACES)
        return t != null && t.length ? t.split(',') : []
      } catch {
        return []
      }
    },
    setConnectedNamespaces(t) {
      try {
        const e = Array.from(new Set(t))
        St.setItem(Rt.CONNECTED_NAMESPACES, e.join(','))
      } catch {
        console.info('Unable to set namespaces in storage')
      }
    },
    addConnectedNamespace(t) {
      try {
        const e = Ke.getConnectedNamespaces()
        e.includes(t) || (e.push(t), Ke.setConnectedNamespaces(e))
      } catch {
        console.info('Unable to add connected namespace')
      }
    },
    removeConnectedNamespace(t) {
      try {
        const e = Ke.getConnectedNamespaces(),
          n = e.indexOf(t)
        n > -1 && (e.splice(n, 1), Ke.setConnectedNamespaces(e))
      } catch {
        console.info('Unable to remove connected namespace')
      }
    },
    getTelegramSocialProvider() {
      try {
        return St.getItem(Rt.TELEGRAM_SOCIAL_PROVIDER)
      } catch {
        return console.info('Unable to get telegram social provider'), null
      }
    },
    setTelegramSocialProvider(t) {
      try {
        St.setItem(Rt.TELEGRAM_SOCIAL_PROVIDER, t)
      } catch {
        console.info('Unable to set telegram social provider')
      }
    },
    removeTelegramSocialProvider() {
      try {
        St.removeItem(Rt.TELEGRAM_SOCIAL_PROVIDER)
      } catch {
        console.info('Unable to remove telegram social provider')
      }
    },
    getBalanceCache() {
      let t = {}
      try {
        const e = St.getItem(Rt.PORTFOLIO_CACHE)
        t = e ? JSON.parse(e) : {}
      } catch {
        console.info('Unable to get balance cache')
      }
      return t
    },
    removeAddressFromBalanceCache(t) {
      try {
        const e = Ke.getBalanceCache()
        St.setItem(Rt.PORTFOLIO_CACHE, JSON.stringify({ ...e, [t]: void 0 }))
      } catch {
        console.info('Unable to remove address from balance cache', t)
      }
    },
    getBalanceCacheForCaipAddress(t) {
      try {
        const n = Ke.getBalanceCache()[t]
        if (n && !this.isCacheExpired(n.timestamp, this.cacheExpiry.portfolio)) return n.balance
        Ke.removeAddressFromBalanceCache(t)
      } catch {
        console.info('Unable to get balance cache for address', t)
      }
    },
    updateBalanceCache(t) {
      try {
        const e = Ke.getBalanceCache()
        ;(e[t.caipAddress] = t), St.setItem(Rt.PORTFOLIO_CACHE, JSON.stringify(e))
      } catch {
        console.info('Unable to update balance cache', t)
      }
    },
    getNativeBalanceCache() {
      let t = {}
      try {
        const e = St.getItem(Rt.NATIVE_BALANCE_CACHE)
        t = e ? JSON.parse(e) : {}
      } catch {
        console.info('Unable to get balance cache')
      }
      return t
    },
    removeAddressFromNativeBalanceCache(t) {
      try {
        const e = Ke.getBalanceCache()
        St.setItem(Rt.NATIVE_BALANCE_CACHE, JSON.stringify({ ...e, [t]: void 0 }))
      } catch {
        console.info('Unable to remove address from balance cache', t)
      }
    },
    getNativeBalanceCacheForCaipAddress(t) {
      try {
        const n = Ke.getNativeBalanceCache()[t]
        if (n && !this.isCacheExpired(n.timestamp, this.cacheExpiry.nativeBalance)) return n
        console.info('Discarding cache for address', t), Ke.removeAddressFromBalanceCache(t)
      } catch {
        console.info('Unable to get balance cache for address', t)
      }
    },
    updateNativeBalanceCache(t) {
      try {
        const e = Ke.getNativeBalanceCache()
        ;(e[t.caipAddress] = t), St.setItem(Rt.NATIVE_BALANCE_CACHE, JSON.stringify(e))
      } catch {
        console.info('Unable to update balance cache', t)
      }
    },
    getEnsCache() {
      let t = {}
      try {
        const e = St.getItem(Rt.ENS_CACHE)
        t = e ? JSON.parse(e) : {}
      } catch {
        console.info('Unable to get ens name cache')
      }
      return t
    },
    getEnsFromCacheForAddress(t) {
      try {
        const n = Ke.getEnsCache()[t]
        if (n && !this.isCacheExpired(n.timestamp, this.cacheExpiry.ens)) return n.ens
        Ke.removeEnsFromCache(t)
      } catch {
        console.info('Unable to get ens name from cache', t)
      }
    },
    updateEnsCache(t) {
      try {
        const e = Ke.getEnsCache()
        ;(e[t.address] = t), St.setItem(Rt.ENS_CACHE, JSON.stringify(e))
      } catch {
        console.info('Unable to update ens name cache', t)
      }
    },
    removeEnsFromCache(t) {
      try {
        const e = Ke.getEnsCache()
        St.setItem(Rt.ENS_CACHE, JSON.stringify({ ...e, [t]: void 0 }))
      } catch {
        console.info('Unable to remove ens name from cache', t)
      }
    },
    getIdentityCache() {
      let t = {}
      try {
        const e = St.getItem(Rt.IDENTITY_CACHE)
        t = e ? JSON.parse(e) : {}
      } catch {
        console.info('Unable to get identity cache')
      }
      return t
    },
    getIdentityFromCacheForAddress(t) {
      try {
        const n = Ke.getIdentityCache()[t]
        if (n && !this.isCacheExpired(n.timestamp, this.cacheExpiry.identity)) return n.identity
        Ke.removeIdentityFromCache(t)
      } catch {
        console.info('Unable to get identity from cache', t)
      }
    },
    updateIdentityCache(t) {
      try {
        const e = Ke.getIdentityCache()
        ;(e[t.address] = { identity: t.identity, timestamp: t.timestamp }),
          St.setItem(Rt.IDENTITY_CACHE, JSON.stringify(e))
      } catch {
        console.info('Unable to update identity cache', t)
      }
    },
    removeIdentityFromCache(t) {
      try {
        const e = Ke.getIdentityCache()
        St.setItem(Rt.IDENTITY_CACHE, JSON.stringify({ ...e, [t]: void 0 }))
      } catch {
        console.info('Unable to remove identity from cache', t)
      }
    },
    clearAddressCache() {
      try {
        St.removeItem(Rt.PORTFOLIO_CACHE),
          St.removeItem(Rt.NATIVE_BALANCE_CACHE),
          St.removeItem(Rt.ENS_CACHE),
          St.removeItem(Rt.IDENTITY_CACHE)
      } catch {
        console.info('Unable to clear address cache')
      }
    },
    setPreferredAccountTypes(t) {
      try {
        St.setItem(Rt.PREFERRED_ACCOUNT_TYPES, JSON.stringify(t))
      } catch {
        console.info('Unable to set preferred account types', t)
      }
    },
    getPreferredAccountTypes() {
      try {
        const t = St.getItem(Rt.PREFERRED_ACCOUNT_TYPES)
        return JSON.parse(t)
      } catch {
        console.info('Unable to get preferred account types')
      }
    }
  },
  dt = {
    isMobile() {
      var t
      return this.isClient()
        ? !!(
            ((t = window == null ? void 0 : window.matchMedia('(pointer:coarse)')) != null &&
              t.matches) ||
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)
          )
        : !1
    },
    checkCaipNetwork(t, e = '') {
      return t == null ? void 0 : t.caipNetworkId.toLocaleLowerCase().includes(e.toLowerCase())
    },
    isAndroid() {
      if (!this.isMobile()) return !1
      const t = window == null ? void 0 : window.navigator.userAgent.toLowerCase()
      return dt.isMobile() && t.includes('android')
    },
    isIos() {
      if (!this.isMobile()) return !1
      const t = window == null ? void 0 : window.navigator.userAgent.toLowerCase()
      return t.includes('iphone') || t.includes('ipad')
    },
    isSafari() {
      return this.isClient()
        ? (window == null ? void 0 : window.navigator.userAgent.toLowerCase()).includes('safari')
        : !1
    },
    isClient() {
      return typeof window < 'u'
    },
    isPairingExpired(t) {
      return t ? t - Date.now() <= gr.TEN_SEC_MS : !0
    },
    isAllowedRetry(t, e = gr.ONE_SEC_MS) {
      return Date.now() - t >= e
    },
    copyToClopboard(t) {
      navigator.clipboard.writeText(t)
    },
    isIframe() {
      try {
        return (window == null ? void 0 : window.self) !== (window == null ? void 0 : window.top)
      } catch {
        return !1
      }
    },
    getPairingExpiry() {
      return Date.now() + gr.FOUR_MINUTES_MS
    },
    getNetworkId(t) {
      return t == null ? void 0 : t.split(':')[1]
    },
    getPlainAddress(t) {
      return t == null ? void 0 : t.split(':')[2]
    },
    async wait(t) {
      return new Promise(e => {
        setTimeout(e, t)
      })
    },
    debounce(t, e = 500) {
      let n
      return (...r) => {
        function s() {
          t(...r)
        }
        n && clearTimeout(n), (n = setTimeout(s, e))
      }
    },
    isHttpUrl(t) {
      return t.startsWith('http://') || t.startsWith('https://')
    },
    formatNativeUrl(t, e) {
      if (dt.isHttpUrl(t)) return this.formatUniversalUrl(t, e)
      let n = t
      n.includes('://') || ((n = t.replaceAll('/', '').replaceAll(':', '')), (n = `${n}://`)),
        n.endsWith('/') || (n = `${n}/`),
        this.isTelegram() && this.isAndroid() && (e = encodeURIComponent(e))
      const r = encodeURIComponent(e)
      return { redirect: `${n}wc?uri=${r}`, href: n }
    },
    formatUniversalUrl(t, e) {
      if (!dt.isHttpUrl(t)) return this.formatNativeUrl(t, e)
      let n = t
      n.endsWith('/') || (n = `${n}/`)
      const r = encodeURIComponent(e)
      return { redirect: `${n}wc?uri=${r}`, href: n }
    },
    getOpenTargetForPlatform(t) {
      return t === 'popupWindow'
        ? t
        : this.isTelegram()
          ? Ke.getTelegramSocialProvider()
            ? '_top'
            : '_blank'
          : t
    },
    openHref(t, e, n) {
      window == null || window.open(t, this.getOpenTargetForPlatform(e), n || 'noreferrer noopener')
    },
    returnOpenHref(t, e, n) {
      return window == null
        ? void 0
        : window.open(t, this.getOpenTargetForPlatform(e), n || 'noreferrer noopener')
    },
    isTelegram() {
      return (
        typeof window < 'u' &&
        (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto)
      )
    },
    async preloadImage(t) {
      const e = new Promise((n, r) => {
        const s = new Image()
        ;(s.onload = n), (s.onerror = r), (s.crossOrigin = 'anonymous'), (s.src = t)
      })
      return Promise.race([e, dt.wait(2e3)])
    },
    formatBalance(t, e) {
      let n = '0.000'
      if (typeof t == 'string') {
        const r = Number(t)
        if (r) {
          const s = Math.floor(r * 1e3) / 1e3
          s && (n = s.toString())
        }
      }
      return `${n}${e ? ` ${e}` : ''}`
    },
    formatBalance2(t, e) {
      var r
      let n
      if (t === '0') n = '0'
      else if (typeof t == 'string') {
        const s = Number(t)
        s && (n = (r = s.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null ? void 0 : r[0])
      }
      return { value: n ?? '0', rest: n === '0' ? '000' : '', symbol: e }
    },
    getApiUrl() {
      return Ae.W3M_API_URL
    },
    getBlockchainApiUrl() {
      return Ae.BLOCKCHAIN_API_RPC_URL
    },
    getAnalyticsUrl() {
      return Ae.PULSE_API_URL
    },
    getUUID() {
      return crypto != null && crypto.randomUUID
        ? crypto.randomUUID()
        : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, t => {
            const e = (Math.random() * 16) | 0
            return (t === 'x' ? e : (e & 3) | 8).toString(16)
          })
    },
    parseError(t) {
      var e, n
      return typeof t == 'string'
        ? t
        : typeof ((n = (e = t == null ? void 0 : t.issues) == null ? void 0 : e[0]) == null
              ? void 0
              : n.message) == 'string'
          ? t.issues[0].message
          : t instanceof Error
            ? t.message
            : 'Unknown error'
    },
    sortRequestedNetworks(t, e = []) {
      const n = {}
      return (
        e &&
          t &&
          (t.forEach((r, s) => {
            n[r] = s
          }),
          e.sort((r, s) => {
            const i = n[r.id],
              o = n[s.id]
            return i !== void 0 && o !== void 0 ? i - o : i !== void 0 ? -1 : o !== void 0 ? 1 : 0
          })),
        e
      )
    },
    calculateBalance(t) {
      let e = 0
      for (const n of t) e += n.value ?? 0
      return e
    },
    formatTokenBalance(t) {
      const e = t.toFixed(2),
        [n, r] = e.split('.')
      return { dollars: n, pennies: r }
    },
    isAddress(t, e = 'eip155') {
      switch (e) {
        case 'eip155':
          if (/^(?:0x)?[0-9a-f]{40}$/iu.test(t)) {
            if (/^(?:0x)?[0-9a-f]{40}$/iu.test(t) || /^(?:0x)?[0-9A-F]{40}$/iu.test(t)) return !0
          } else return !1
          return !1
        case 'solana':
          return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(t)
        default:
          return !1
      }
    },
    uniqueBy(t, e) {
      const n = new Set()
      return t.filter(r => {
        const s = r[e]
        return n.has(s) ? !1 : (n.add(s), !0)
      })
    },
    generateSdkVersion(t, e, n) {
      const s = t.length === 0 ? gr.ADAPTER_TYPES.UNIVERSAL : t.map(i => i.adapterType).join(',')
      return `${e}-${s}-${n}`
    },
    createAccount(t, e, n, r, s) {
      return { namespace: t, address: e, type: n, publicKey: r, path: s }
    },
    isCaipAddress(t) {
      if (typeof t != 'string') return !1
      const e = t.split(':'),
        n = e[0]
      return e.filter(Boolean).length === 3 && n in Ae.CHAIN_NAME_MAP
    },
    isMac() {
      const t = window == null ? void 0 : window.navigator.userAgent.toLowerCase()
      return t.includes('macintosh') && !t.includes('safari')
    },
    formatTelegramSocialLoginUrl(t) {
      const e = `--${encodeURIComponent(window == null ? void 0 : window.location.href)}`,
        n = 'state='
      if (new URL(t).host === 'auth.magic.link') {
        const s = 'provider_authorization_url=',
          i = t.substring(t.indexOf(s) + s.length),
          o = this.injectIntoUrl(decodeURIComponent(i), n, e)
        return t.replace(i, encodeURIComponent(o))
      }
      return this.injectIntoUrl(t, n, e)
    },
    injectIntoUrl(t, e, n) {
      const r = t.indexOf(e)
      if (r === -1) throw new Error(`${e} parameter not found in the URL: ${t}`)
      const s = t.indexOf('&', r),
        i = e.length,
        o = s !== -1 ? s : t.length,
        a = t.substring(0, r + i),
        c = t.substring(r + i, o),
        u = t.substring(s),
        l = c + n
      return a + l + u
    }
  }
async function Wd(...t) {
  const e = await fetch(...t)
  if (!e.ok) throw new Error(`HTTP status code: ${e.status}`, { cause: e })
  return e
}
class k0 {
  constructor({ baseUrl: e, clientId: n }) {
    ;(this.baseUrl = e), (this.clientId = n)
  }
  async get({ headers: e, signal: n, cache: r, ...s }) {
    const i = this.createUrl(s)
    return (await Wd(i, { method: 'GET', headers: e, signal: n, cache: r })).json()
  }
  async getBlob({ headers: e, signal: n, ...r }) {
    const s = this.createUrl(r)
    return (await Wd(s, { method: 'GET', headers: e, signal: n })).blob()
  }
  async post({ body: e, headers: n, signal: r, ...s }) {
    const i = this.createUrl(s)
    return (
      await Wd(i, { method: 'POST', headers: n, body: e ? JSON.stringify(e) : void 0, signal: r })
    ).json()
  }
  async put({ body: e, headers: n, signal: r, ...s }) {
    const i = this.createUrl(s)
    return (
      await Wd(i, { method: 'PUT', headers: n, body: e ? JSON.stringify(e) : void 0, signal: r })
    ).json()
  }
  async delete({ body: e, headers: n, signal: r, ...s }) {
    const i = this.createUrl(s)
    return (
      await Wd(i, { method: 'DELETE', headers: n, body: e ? JSON.stringify(e) : void 0, signal: r })
    ).json()
  }
  createUrl({ path: e, params: n }) {
    const r = new URL(e, this.baseUrl)
    return (
      n &&
        Object.entries(n).forEach(([s, i]) => {
          i && r.searchParams.append(s, i)
        }),
      this.clientId && r.searchParams.append('clientId', this.clientId),
      r
    )
  }
}
const KH = {
    handleSolanaDeeplinkRedirect(t) {
      if (ne.state.activeChain === Ae.CHAIN.SOLANA) {
        const e = window.location.href,
          n = encodeURIComponent(e)
        if (t === 'Phantom' && !('phantom' in window)) {
          const r = e.startsWith('https') ? 'https' : 'http',
            s = e.split('/')[2],
            i = encodeURIComponent(`${r}://${s}`)
          window.location.href = `https://phantom.app/ul/browse/${n}?ref=${i}`
        }
        t === 'Coinbase Wallet' &&
          !('coinbaseSolana' in window) &&
          (window.location.href = `https://go.cb-w.com/dapp?cb_url=${n}`)
      }
    }
  },
  xs = xn({
    walletImages: {},
    networkImages: {},
    chainImages: {},
    connectorImages: {},
    tokenImages: {},
    currencyImages: {}
  }),
  _i = {
    state: xs,
    subscribeNetworkImages(t) {
      return Qr(xs.networkImages, () => t(xs.networkImages))
    },
    subscribeKey(t, e) {
      return Yr(xs, t, e)
    },
    subscribe(t) {
      return Qr(xs, () => t(xs))
    },
    setWalletImage(t, e) {
      xs.walletImages[t] = e
    },
    setNetworkImage(t, e) {
      xs.networkImages[t] = e
    },
    setChainImage(t, e) {
      xs.chainImages[t] = e
    },
    setConnectorImage(t, e) {
      xs.connectorImages = { ...xs.connectorImages, [t]: e }
    },
    setTokenImage(t, e) {
      xs.tokenImages[t] = e
    },
    setCurrencyImage(t, e) {
      xs.currencyImages[t] = e
    }
  },
  VH = {
    eip155: 'ba0ba0cd-17c6-4806-ad93-f9d174f17900',
    solana: 'a1b58899-f671-4276-6a5e-56ca5bd59700',
    polkadot: '',
    bip122: '0b4838db-0161-4ffe-022d-532bf03dba00'
  },
  Ew = xn({ networkImagePromises: {} }),
  tk = {
    async fetchWalletImage(t) {
      if (t) return await yt._fetchWalletImage(t), this.getWalletImageById(t)
    },
    async fetchNetworkImage(t) {
      if (!t) return
      const e = this.getNetworkImageById(t)
      return (
        e ||
        (Ew.networkImagePromises[t] || (Ew.networkImagePromises[t] = yt._fetchNetworkImage(t)),
        await Ew.networkImagePromises[t],
        this.getNetworkImageById(t))
      )
    },
    getWalletImageById(t) {
      if (t) return _i.state.walletImages[t]
    },
    getWalletImage(t) {
      if (t != null && t.image_url) return t == null ? void 0 : t.image_url
      if (t != null && t.image_id) return _i.state.walletImages[t.image_id]
    },
    getNetworkImage(t) {
      var e, n, r
      if ((e = t == null ? void 0 : t.assets) != null && e.imageUrl)
        return (n = t == null ? void 0 : t.assets) == null ? void 0 : n.imageUrl
      if ((r = t == null ? void 0 : t.assets) != null && r.imageId)
        return _i.state.networkImages[t.assets.imageId]
    },
    getNetworkImageById(t) {
      if (t) return _i.state.networkImages[t]
    },
    getConnectorImage(t) {
      if (t != null && t.imageUrl) return t.imageUrl
      if (t != null && t.imageId) return _i.state.connectorImages[t.imageId]
    },
    getChainImage(t) {
      return _i.state.networkImages[VH[t]]
    }
  },
  GH = {
    getFeatureValue(t, e) {
      const n = e == null ? void 0 : e[t]
      return n === void 0 ? gr.DEFAULT_FEATURES[t] : n
    },
    filterSocialsByPlatform(t) {
      if (!t || !t.length) return t
      if (dt.isTelegram()) {
        if (dt.isIos()) return t.filter(e => e !== 'google')
        if (dt.isMac()) return t.filter(e => e !== 'x')
        if (dt.isAndroid()) return t.filter(e => !['facebook', 'x'].includes(e))
      }
      return t
    }
  },
  ft = xn({
    features: gr.DEFAULT_FEATURES,
    projectId: '',
    sdkType: 'appkit',
    sdkVersion: 'html-wagmi-undefined',
    defaultAccountTypes: {
      solana: 'eoa',
      bip122: 'payment',
      polkadot: 'eoa',
      eip155: 'smartAccount'
    },
    enableNetworkSwitch: !0
  }),
  Pe = {
    state: ft,
    subscribeKey(t, e) {
      return Yr(ft, t, e)
    },
    setOptions(t) {
      Object.assign(ft, t)
    },
    setFeatures(t) {
      if (!t) return
      ft.features || (ft.features = gr.DEFAULT_FEATURES)
      const e = { ...ft.features, ...t }
      ;(ft.features = e),
        ft.features.socials &&
          (ft.features.socials = GH.filterSocialsByPlatform(ft.features.socials))
    },
    setProjectId(t) {
      ft.projectId = t
    },
    setCustomRpcUrls(t) {
      ft.customRpcUrls = t
    },
    setAllWallets(t) {
      ft.allWallets = t
    },
    setIncludeWalletIds(t) {
      ft.includeWalletIds = t
    },
    setExcludeWalletIds(t) {
      ft.excludeWalletIds = t
    },
    setFeaturedWalletIds(t) {
      ft.featuredWalletIds = t
    },
    setTokens(t) {
      ft.tokens = t
    },
    setTermsConditionsUrl(t) {
      ft.termsConditionsUrl = t
    },
    setPrivacyPolicyUrl(t) {
      ft.privacyPolicyUrl = t
    },
    setCustomWallets(t) {
      ft.customWallets = t
    },
    setIsSiweEnabled(t) {
      ft.isSiweEnabled = t
    },
    setIsUniversalProvider(t) {
      ft.isUniversalProvider = t
    },
    setSdkVersion(t) {
      ft.sdkVersion = t
    },
    setMetadata(t) {
      ft.metadata = t
    },
    setDisableAppend(t) {
      ft.disableAppend = t
    },
    setEIP6963Enabled(t) {
      ft.enableEIP6963 = t
    },
    setDebug(t) {
      ft.debug = t
    },
    setEnableWalletConnect(t) {
      ft.enableWalletConnect = t
    },
    setEnableWalletGuide(t) {
      ft.enableWalletGuide = t
    },
    setEnableAuthLogger(t) {
      ft.enableAuthLogger = t
    },
    setEnableWallets(t) {
      ft.enableWallets = t
    },
    setHasMultipleAddresses(t) {
      ft.hasMultipleAddresses = t
    },
    setSIWX(t) {
      ft.siwx = t
    },
    setConnectMethodsOrder(t) {
      ft.features = { ...ft.features, connectMethodsOrder: t }
    },
    setWalletFeaturesOrder(t) {
      ft.features = { ...ft.features, walletFeaturesOrder: t }
    },
    setSocialsOrder(t) {
      ft.features = { ...ft.features, socials: t }
    },
    setCollapseWallets(t) {
      ft.features = { ...ft.features, collapseWallets: t }
    },
    setEnableEmbedded(t) {
      ft.enableEmbedded = t
    },
    setAllowUnsupportedChain(t) {
      ft.allowUnsupportedChain = t
    },
    setManualWCControl(t) {
      ft.manualWCControl = t
    },
    setEnableNetworkSwitch(t) {
      ft.enableNetworkSwitch = t
    },
    setDefaultAccountTypes(t = {}) {
      Object.entries(t).forEach(([e, n]) => {
        n && (ft.defaultAccountTypes[e] = n)
      })
    },
    setUniversalProviderConfigOverride(t) {
      ft.universalProviderConfigOverride = t
    },
    getUniversalProviderConfigOverride() {
      return ft.universalProviderConfigOverride
    },
    getSnapshot() {
      return mf(ft)
    }
  },
  aa = xn({ message: '', variant: 'info', open: !1 }),
  qa = {
    state: aa,
    subscribeKey(t, e) {
      return Yr(aa, t, e)
    },
    open(t, e) {
      const { debug: n } = Pe.state,
        { shortMessage: r, longMessage: s } = t
      n && ((aa.message = r), (aa.variant = e), (aa.open = !0)),
        s && console.error(typeof s == 'function' ? s() : s)
    },
    close() {
      ;(aa.open = !1), (aa.message = ''), (aa.variant = 'info')
    }
  },
  QH = dt.getAnalyticsUrl(),
  ZH = new k0({ baseUrl: QH, clientId: null }),
  YH = ['MODAL_CREATED'],
  Ao = xn({
    timestamp: Date.now(),
    reportedErrors: {},
    data: { type: 'track', event: 'MODAL_CREATED' }
  }),
  gn = {
    state: Ao,
    subscribe(t) {
      return Qr(Ao, () => t(Ao))
    },
    getSdkProperties() {
      const { projectId: t, sdkType: e, sdkVersion: n } = Pe.state
      return { projectId: t, st: e, sv: n || 'html-wagmi-4.2.2' }
    },
    async _sendAnalyticsEvent(t) {
      try {
        const e = Ye.state.address
        if (YH.includes(t.data.event) || typeof window > 'u') return
        await ZH.post({
          path: '/e',
          params: gn.getSdkProperties(),
          body: {
            eventId: dt.getUUID(),
            url: window.location.href,
            domain: window.location.hostname,
            timestamp: t.timestamp,
            props: { ...t.data, address: e }
          }
        }),
          (Ao.reportedErrors.FORBIDDEN = !1)
      } catch (e) {
        e instanceof Error &&
          e.cause instanceof Response &&
          e.cause.status === Ae.HTTP_STATUS_CODES.FORBIDDEN &&
          !Ao.reportedErrors.FORBIDDEN &&
          (qa.open(
            {
              shortMessage: 'Invalid App Configuration',
              longMessage: `Origin ${yh() ? window.origin : 'uknown'} not found on Allowlist - update configuration on cloud.reown.com`
            },
            'error'
          ),
          (Ao.reportedErrors.FORBIDDEN = !0))
      }
    },
    sendEvent(t) {
      var e
      ;(Ao.timestamp = Date.now()),
        (Ao.data = t),
        (e = Pe.state.features) != null && e.analytics && gn._sendAnalyticsEvent(Ao)
    }
  },
  JH = [
    '1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79',
    'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa',
    'a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393'
  ],
  XH = dt.getApiUrl(),
  Vs = new k0({ baseUrl: XH, clientId: null }),
  eq = 40,
  yS = 4,
  tq = 20,
  Tt = xn({
    promises: {},
    page: 1,
    count: 0,
    featured: [],
    allFeatured: [],
    recommended: [],
    allRecommended: [],
    wallets: [],
    filteredWallets: [],
    search: [],
    isAnalyticsEnabled: !1,
    excludedWallets: [],
    isFetchingRecommendedWallets: !1
  }),
  yt = {
    state: Tt,
    subscribeKey(t, e) {
      return Yr(Tt, t, e)
    },
    _getSdkProperties() {
      const { projectId: t, sdkType: e, sdkVersion: n } = Pe.state
      return { projectId: t, st: e || 'appkit', sv: n || 'html-wagmi-4.2.2' }
    },
    _filterOutExtensions(t) {
      return Pe.state.isUniversalProvider
        ? t.filter(e => !!(e.mobile_link || e.desktop_link || e.webapp_link))
        : t
    },
    async _fetchWalletImage(t) {
      const e = `${Vs.baseUrl}/getWalletImage/${t}`,
        n = await Vs.getBlob({ path: e, params: yt._getSdkProperties() })
      _i.setWalletImage(t, URL.createObjectURL(n))
    },
    async _fetchNetworkImage(t) {
      const e = `${Vs.baseUrl}/public/getAssetImage/${t}`,
        n = await Vs.getBlob({ path: e, params: yt._getSdkProperties() })
      _i.setNetworkImage(t, URL.createObjectURL(n))
    },
    async _fetchConnectorImage(t) {
      const e = `${Vs.baseUrl}/public/getAssetImage/${t}`,
        n = await Vs.getBlob({ path: e, params: yt._getSdkProperties() })
      _i.setConnectorImage(t, URL.createObjectURL(n))
    },
    async _fetchCurrencyImage(t) {
      const e = `${Vs.baseUrl}/public/getCurrencyImage/${t}`,
        n = await Vs.getBlob({ path: e, params: yt._getSdkProperties() })
      _i.setCurrencyImage(t, URL.createObjectURL(n))
    },
    async _fetchTokenImage(t) {
      const e = `${Vs.baseUrl}/public/getTokenImage/${t}`,
        n = await Vs.getBlob({ path: e, params: yt._getSdkProperties() })
      _i.setTokenImage(t, URL.createObjectURL(n))
    },
    async fetchNetworkImages() {
      const t = ne.getAllRequestedCaipNetworks(),
        e =
          t == null
            ? void 0
            : t
                .map(({ assets: n }) => (n == null ? void 0 : n.imageId))
                .filter(Boolean)
                .filter(n => !tk.getNetworkImageById(n))
      e && (await Promise.allSettled(e.map(n => yt._fetchNetworkImage(n))))
    },
    async fetchConnectorImages() {
      const { connectors: t } = Et.state,
        e = t.map(({ imageId: n }) => n).filter(Boolean)
      await Promise.allSettled(e.map(n => yt._fetchConnectorImage(n)))
    },
    async fetchCurrencyImages(t = []) {
      await Promise.allSettled(t.map(e => yt._fetchCurrencyImage(e)))
    },
    async fetchTokenImages(t = []) {
      await Promise.allSettled(t.map(e => yt._fetchTokenImage(e)))
    },
    async fetchWallets(t) {
      var r, s
      const e = t.exclude ?? []
      return (
        yt._getSdkProperties().sv.startsWith('html-core-') && e.push(...JH),
        await Vs.get({
          path: '/getWallets',
          params: {
            ...yt._getSdkProperties(),
            ...t,
            page: String(t.page),
            entries: String(t.entries),
            include: (r = t.include) == null ? void 0 : r.join(','),
            exclude: (s = t.exclude) == null ? void 0 : s.join(',')
          }
        })
      )
    },
    async fetchFeaturedWallets() {
      const { featuredWalletIds: t } = Pe.state
      if (t != null && t.length) {
        const e = {
            ...yt._getSdkProperties(),
            page: 1,
            entries: (t == null ? void 0 : t.length) ?? yS,
            include: t
          },
          { data: n } = await yt.fetchWallets(e)
        n.sort((s, i) => t.indexOf(s.id) - t.indexOf(i.id))
        const r = n.map(s => s.image_id).filter(Boolean)
        await Promise.allSettled(r.map(s => yt._fetchWalletImage(s))),
          (Tt.featured = n),
          (Tt.allFeatured = n)
      }
    },
    async fetchRecommendedWallets() {
      try {
        Tt.isFetchingRecommendedWallets = !0
        const { includeWalletIds: t, excludeWalletIds: e, featuredWalletIds: n } = Pe.state,
          r = [...(e ?? []), ...(n ?? [])].filter(Boolean),
          s = ne.getRequestedCaipNetworkIds().join(','),
          i = { page: 1, entries: yS, include: t, exclude: r, chains: s },
          { data: o, count: a } = await yt.fetchWallets(i),
          c = Ke.getRecentWallets(),
          u = o.map(d => d.image_id).filter(Boolean),
          l = c.map(d => d.image_id).filter(Boolean)
        await Promise.allSettled([...u, ...l].map(d => yt._fetchWalletImage(d))),
          (Tt.recommended = o),
          (Tt.allRecommended = o),
          (Tt.count = a ?? 0)
      } catch {
      } finally {
        Tt.isFetchingRecommendedWallets = !1
      }
    },
    async fetchWalletsByPage({ page: t }) {
      const { includeWalletIds: e, excludeWalletIds: n, featuredWalletIds: r } = Pe.state,
        s = ne.getRequestedCaipNetworkIds().join(','),
        i = [...Tt.recommended.map(({ id: l }) => l), ...(n ?? []), ...(r ?? [])].filter(Boolean),
        o = { page: t, entries: eq, include: e, exclude: i, chains: s },
        { data: a, count: c } = await yt.fetchWallets(o),
        u = a
          .slice(0, tq)
          .map(l => l.image_id)
          .filter(Boolean)
      await Promise.allSettled(u.map(l => yt._fetchWalletImage(l))),
        (Tt.wallets = dt.uniqueBy([...Tt.wallets, ...yt._filterOutExtensions(a)], 'id')),
        (Tt.count = c > Tt.count ? c : Tt.count),
        (Tt.page = t)
    },
    async initializeExcludedWallets({ ids: t }) {
      const e = ne.getRequestedCaipNetworkIds().join(','),
        n = { page: 1, entries: t.length, include: t, chains: e },
        { data: r } = await yt.fetchWallets(n)
      r &&
        r.forEach(s => {
          Tt.excludedWallets.push({ rdns: s.rdns, name: s.name })
        })
    },
    async searchWallet({ search: t, badge: e }) {
      const { includeWalletIds: n, excludeWalletIds: r } = Pe.state,
        s = ne.getRequestedCaipNetworkIds().join(',')
      Tt.search = []
      const i = {
          page: 1,
          entries: 100,
          search: t == null ? void 0 : t.trim(),
          badge_type: e,
          include: n,
          exclude: r,
          chains: s
        },
        { data: o } = await yt.fetchWallets(i)
      gn.sendEvent({
        type: 'track',
        event: 'SEARCH_WALLET',
        properties: { badge: e ?? '', search: t ?? '' }
      })
      const a = o.map(c => c.image_id).filter(Boolean)
      await Promise.allSettled([...a.map(c => yt._fetchWalletImage(c)), dt.wait(300)]),
        (Tt.search = yt._filterOutExtensions(o))
    },
    initPromise(t, e) {
      const n = Tt.promises[t]
      return n || (Tt.promises[t] = e())
    },
    prefetch({
      fetchConnectorImages: t = !0,
      fetchFeaturedWallets: e = !0,
      fetchRecommendedWallets: n = !0,
      fetchNetworkImages: r = !0
    } = {}) {
      const s = [
        t && yt.initPromise('connectorImages', yt.fetchConnectorImages),
        e && yt.initPromise('featuredWallets', yt.fetchFeaturedWallets),
        n && yt.initPromise('recommendedWallets', yt.fetchRecommendedWallets),
        r && yt.initPromise('networkImages', yt.fetchNetworkImages)
      ].filter(Boolean)
      return Promise.allSettled(s)
    },
    prefetchAnalyticsConfig() {
      var t
      ;(t = Pe.state.features) != null && t.analytics && yt.fetchAnalyticsConfig()
    },
    async fetchAnalyticsConfig() {
      try {
        const { isAnalyticsEnabled: t } = await Vs.get({
          path: '/getAnalyticsConfig',
          params: yt._getSdkProperties()
        })
        Pe.setFeatures({ analytics: t })
      } catch {
        Pe.setFeatures({ analytics: !1 })
      }
    },
    filterByNamespaces(t) {
      if (!(t != null && t.length)) {
        ;(Tt.featured = Tt.allFeatured), (Tt.recommended = Tt.allRecommended)
        return
      }
      const e = ne.getRequestedCaipNetworkIds().join(',')
      ;(Tt.featured = Tt.allFeatured.filter(n => {
        var r
        return (r = n.chains) == null ? void 0 : r.some(s => e.includes(s))
      })),
        (Tt.recommended = Tt.allRecommended.filter(n => {
          var r
          return (r = n.chains) == null ? void 0 : r.some(s => e.includes(s))
        })),
        (Tt.filteredWallets = Tt.wallets.filter(n => {
          var r
          return (r = n.chains) == null ? void 0 : r.some(s => e.includes(s))
        }))
    },
    setFilterByNamespace(t) {
      if (!t) {
        ;(Tt.featured = Tt.allFeatured), (Tt.recommended = Tt.allRecommended)
        return
      }
      const e = ne.getRequestedCaipNetworkIds().join(',')
      ;(Tt.featured = Tt.allFeatured.filter(n => {
        var r
        return (r = n.chains) == null ? void 0 : r.some(s => e.includes(s))
      })),
        (Tt.recommended = Tt.allRecommended.filter(n => {
          var r
          return (r = n.chains) == null ? void 0 : r.some(s => e.includes(s))
        })),
        (Tt.filteredWallets = Tt.wallets.filter(n => {
          var r
          return (r = n.chains) == null ? void 0 : r.some(s => e.includes(s))
        }))
    }
  },
  Xt = xn({ view: 'Connect', history: ['Connect'], transactionStack: [] }),
  nn = {
    state: Xt,
    subscribeKey(t, e) {
      return Yr(Xt, t, e)
    },
    pushTransactionStack(t) {
      Xt.transactionStack.push(t)
    },
    popTransactionStack(t) {
      var n, r
      const e = Xt.transactionStack.pop()
      if (e)
        if (t) this.goBack(), (n = e == null ? void 0 : e.onCancel) == null || n.call(e)
        else {
          if (e.goBack) this.goBack()
          else if (e.replace) {
            const i = Xt.history.indexOf('ConnectingSiwe')
            i > 0 ? this.goBackToIndex(i - 1) : (Kn.close(!0), (Xt.history = []))
          } else e.view && this.reset(e.view)
          ;(r = e == null ? void 0 : e.onSuccess) == null || r.call(e)
        }
    },
    push(t, e) {
      t !== Xt.view && ((Xt.view = t), Xt.history.push(t), (Xt.data = e))
    },
    reset(t, e) {
      ;(Xt.view = t), (Xt.history = [t]), (Xt.data = e)
    },
    replace(t, e) {
      Xt.history.at(-1) === t ||
        ((Xt.view = t), (Xt.history[Xt.history.length - 1] = t), (Xt.data = e))
    },
    goBack() {
      var e
      const t = !ne.state.activeCaipAddress && this.state.view === 'ConnectingFarcaster'
      if (Xt.history.length > 1 && !Xt.history.includes('UnsupportedChain')) {
        Xt.history.pop()
        const [n] = Xt.history.slice(-1)
        n && (Xt.view = n)
      } else Kn.close()
      ;(e = Xt.data) != null && e.wallet && (Xt.data.wallet = void 0),
        setTimeout(() => {
          var n, r, s
          if (t) {
            Ye.setFarcasterUrl(void 0, ne.state.activeChain)
            const i = Et.getAuthConnector()
            ;(n = i == null ? void 0 : i.provider) == null || n.reload()
            const o = mf(Pe.state)
            ;(s = (r = i == null ? void 0 : i.provider) == null ? void 0 : r.syncDappData) ==
              null ||
              s.call(r, {
                metadata: o.metadata,
                sdkVersion: o.sdkVersion,
                projectId: o.projectId,
                sdkType: o.sdkType
              })
          }
        }, 100)
    },
    goBackToIndex(t) {
      if (Xt.history.length > 1) {
        Xt.history = Xt.history.slice(0, t + 1)
        const [e] = Xt.history.slice(-1)
        e && (Xt.view = e)
      }
    }
  },
  _o = xn({ themeMode: 'dark', themeVariables: {}, w3mThemeVariables: void 0 }),
  zr = {
    state: _o,
    subscribe(t) {
      return Qr(_o, () => t(_o))
    },
    setThemeMode(t) {
      _o.themeMode = t
      try {
        const e = Et.getAuthConnector()
        if (e) {
          const n = zr.getSnapshot().themeVariables
          e.provider.syncTheme({ themeMode: t, themeVariables: n, w3mThemeVariables: zo(n, t) })
        }
      } catch {
        console.info('Unable to sync theme to auth connector')
      }
    },
    setThemeVariables(t) {
      _o.themeVariables = { ..._o.themeVariables, ...t }
      try {
        const e = Et.getAuthConnector()
        if (e) {
          const n = zr.getSnapshot().themeVariables
          e.provider.syncTheme({
            themeVariables: n,
            w3mThemeVariables: zo(_o.themeVariables, _o.themeMode)
          })
        }
      } catch {
        console.info('Unable to sync theme to auth connector')
      }
    },
    getSnapshot() {
      return mf(_o)
    }
  },
  nk = { eip155: void 0, solana: void 0, polkadot: void 0, bip122: void 0 },
  Qt = xn({
    allConnectors: [],
    connectors: [],
    activeConnector: void 0,
    filterByNamespace: void 0,
    activeConnectorIds: { ...nk },
    filterByNamespaceMap: { eip155: !0, solana: !0, polkadot: !0, bip122: !0 }
  }),
  Et = {
    state: Qt,
    subscribe(t) {
      return Qr(Qt, () => {
        t(Qt)
      })
    },
    subscribeKey(t, e) {
      return Yr(Qt, t, e)
    },
    initialize(t) {
      t.forEach(e => {
        const n = Ke.getConnectedConnectorId(e)
        n && this.setConnectorId(n, e)
      })
    },
    setActiveConnector(t) {
      t && (Qt.activeConnector = tc(t))
    },
    setConnectors(t) {
      t
        .filter(
          n =>
            !Qt.allConnectors.some(
              r =>
                r.id === n.id &&
                this.getConnectorName(r.name) === this.getConnectorName(n.name) &&
                r.chain === n.chain
            )
        )
        .forEach(n => {
          n.type !== 'MULTI_CHAIN' && Qt.allConnectors.push(tc(n))
        }),
        (Qt.connectors = this.mergeMultiChainConnectors(Qt.allConnectors))
    },
    updateAdapter(t, e) {
      Qt.filterByNamespaceMap[t] = e
      const n = [],
        r = [],
        s = Object.values(Qt.filterByNamespaceMap).every(i => i)
      Object.keys(Qt.filterByNamespaceMap).forEach(i => {
        Qt.filterByNamespaceMap[i] &&
          (r.push(i), n.push(...Qt.allConnectors.filter(o => o.chain === i)))
      }),
        (Qt.connectors = this.mergeMultiChainConnectors(n)),
        s ? (yt.state.filteredWallets = []) : yt.filterByNamespaces(r)
    },
    mergeMultiChainConnectors(t) {
      const e = this.generateConnectorMapByName(t),
        n = []
      return (
        e.forEach(r => {
          const s = r[0],
            i = (s == null ? void 0 : s.id) === Ae.CONNECTOR_ID.AUTH
          r.length > 1 && s
            ? n.push({
                name: s.name,
                imageUrl: s.imageUrl,
                imageId: s.imageId,
                connectors: [...r],
                type: i ? 'AUTH' : 'MULTI_CHAIN',
                chain: 'eip155',
                id: (s == null ? void 0 : s.id) || ''
              })
            : s && n.push(s)
        }),
        n
      )
    },
    generateConnectorMapByName(t) {
      const e = new Map()
      return (
        t.forEach(n => {
          const { name: r } = n,
            s = this.getConnectorName(r)
          if (!s) return
          const i = e.get(s) || []
          i.find(a => a.chain === n.chain) || i.push(n), e.set(s, i)
        }),
        e
      )
    },
    getConnectorName(t) {
      return t && ({ 'Trust Wallet': 'Trust' }[t] || t)
    },
    getUniqueConnectorsByName(t) {
      const e = []
      return (
        t.forEach(n => {
          e.find(r => r.chain === n.chain) || e.push(n)
        }),
        e
      )
    },
    addConnector(t) {
      var e, n, r
      if (t.id === Ae.CONNECTOR_ID.AUTH) {
        const s = t,
          i = mf(Pe.state),
          o = zr.getSnapshot().themeMode,
          a = zr.getSnapshot().themeVariables
        ;(n = (e = s == null ? void 0 : s.provider) == null ? void 0 : e.syncDappData) == null ||
          n.call(e, {
            metadata: i.metadata,
            sdkVersion: i.sdkVersion,
            projectId: i.projectId,
            sdkType: i.sdkType
          }),
          (r = s == null ? void 0 : s.provider) == null ||
            r.syncTheme({ themeMode: o, themeVariables: a, w3mThemeVariables: zo(a, o) }),
          this.setConnectors([t])
      } else this.setConnectors([t])
    },
    getAuthConnector(t) {
      var r
      const e = t || ne.state.activeChain,
        n = Qt.connectors.find(s => s.id === Ae.CONNECTOR_ID.AUTH)
      if (n)
        return (r = n == null ? void 0 : n.connectors) != null && r.length
          ? n.connectors.find(i => i.chain === e)
          : n
    },
    getAnnouncedConnectorRdns() {
      return Qt.connectors
        .filter(t => t.type === 'ANNOUNCED')
        .map(t => {
          var e
          return (e = t.info) == null ? void 0 : e.rdns
        })
    },
    getConnectorById(t) {
      return Qt.allConnectors.find(e => e.id === t)
    },
    getConnector(t, e) {
      return Qt.allConnectors
        .filter(r => r.chain === ne.state.activeChain)
        .find(r => {
          var s
          return r.explorerId === t || ((s = r.info) == null ? void 0 : s.rdns) === e
        })
    },
    syncIfAuthConnector(t) {
      var i, o
      if (t.id !== 'ID_AUTH') return
      const e = t,
        n = mf(Pe.state),
        r = zr.getSnapshot().themeMode,
        s = zr.getSnapshot().themeVariables
      ;(o = (i = e == null ? void 0 : e.provider) == null ? void 0 : i.syncDappData) == null ||
        o.call(i, {
          metadata: n.metadata,
          sdkVersion: n.sdkVersion,
          sdkType: n.sdkType,
          projectId: n.projectId
        }),
        e.provider.syncTheme({ themeMode: r, themeVariables: s, w3mThemeVariables: zo(s, r) })
    },
    getConnectorsByNamespace(t) {
      const e = Qt.allConnectors.filter(n => n.chain === t)
      return this.mergeMultiChainConnectors(e)
    },
    selectWalletConnector(t) {
      const e = Et.getConnector(t.id, t.rdns)
      ne.state.activeChain === Ae.CHAIN.SOLANA &&
        KH.handleSolanaDeeplinkRedirect((e == null ? void 0 : e.name) || t.name || ''),
        e
          ? nn.push('ConnectingExternal', { connector: e })
          : nn.push('ConnectingWalletConnect', { wallet: t })
    },
    getConnectors(t) {
      return t ? this.getConnectorsByNamespace(t) : this.mergeMultiChainConnectors(Qt.allConnectors)
    },
    setFilterByNamespace(t) {
      ;(Qt.filterByNamespace = t),
        (Qt.connectors = this.getConnectors(t)),
        yt.setFilterByNamespace(t)
    },
    setConnectorId(t, e) {
      t &&
        ((Qt.activeConnectorIds = { ...Qt.activeConnectorIds, [e]: t }),
        Ke.setConnectedConnectorId(e, t))
    },
    removeConnectorId(t) {
      ;(Qt.activeConnectorIds = { ...Qt.activeConnectorIds, [t]: void 0 }),
        Ke.deleteConnectedConnectorId(t)
    },
    getConnectorId(t) {
      if (t) return Qt.activeConnectorIds[t]
    },
    isConnected(t) {
      return t ? !!Qt.activeConnectorIds[t] : Object.values(Qt.activeConnectorIds).some(e => !!e)
    },
    resetConnectorIds() {
      Qt.activeConnectorIds = { ...nk }
    }
  }
function Xp(t, e) {
  return Et.getConnectorId(t) === e
}
function nq(t) {
  const e = Array.from(ne.state.chains.keys())
  let n = []
  return (
    t
      ? (n.push([t, ne.state.chains.get(t)]),
        Xp(t, Ae.CONNECTOR_ID.WALLET_CONNECT)
          ? e.forEach(r => {
              r !== t &&
                Xp(r, Ae.CONNECTOR_ID.WALLET_CONNECT) &&
                n.push([r, ne.state.chains.get(r)])
            })
          : Xp(t, Ae.CONNECTOR_ID.AUTH) &&
            e.forEach(r => {
              r !== t && Xp(r, Ae.CONNECTOR_ID.AUTH) && n.push([r, ne.state.chains.get(r)])
            }))
      : (n = Array.from(ne.state.chains.entries())),
    n
  )
}
var eg = { exports: {} },
  wS
function rq() {
  if (wS) return eg.exports
  wS = 1
  var t = typeof Reflect == 'object' ? Reflect : null,
    e =
      t && typeof t.apply == 'function'
        ? t.apply
        : function (N, T, M) {
            return Function.prototype.apply.call(N, T, M)
          },
    n
  t && typeof t.ownKeys == 'function'
    ? (n = t.ownKeys)
    : Object.getOwnPropertySymbols
      ? (n = function (N) {
          return Object.getOwnPropertyNames(N).concat(Object.getOwnPropertySymbols(N))
        })
      : (n = function (N) {
          return Object.getOwnPropertyNames(N)
        })
  function r(R) {
    console && console.warn && console.warn(R)
  }
  var s =
    Number.isNaN ||
    function (N) {
      return N !== N
    }
  function i() {
    i.init.call(this)
  }
  ;(eg.exports = i),
    (eg.exports.once = I),
    (i.EventEmitter = i),
    (i.prototype._events = void 0),
    (i.prototype._eventsCount = 0),
    (i.prototype._maxListeners = void 0)
  var o = 10
  function a(R) {
    if (typeof R != 'function')
      throw new TypeError(
        'The "listener" argument must be of type Function. Received type ' + typeof R
      )
  }
  Object.defineProperty(i, 'defaultMaxListeners', {
    enumerable: !0,
    get: function () {
      return o
    },
    set: function (R) {
      if (typeof R != 'number' || R < 0 || s(R))
        throw new RangeError(
          'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
            R +
            '.'
        )
      o = R
    }
  }),
    (i.init = function () {
      ;(this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) &&
        ((this._events = Object.create(null)), (this._eventsCount = 0)),
        (this._maxListeners = this._maxListeners || void 0)
    }),
    (i.prototype.setMaxListeners = function (N) {
      if (typeof N != 'number' || N < 0 || s(N))
        throw new RangeError(
          'The value of "n" is out of range. It must be a non-negative number. Received ' + N + '.'
        )
      return (this._maxListeners = N), this
    })
  function c(R) {
    return R._maxListeners === void 0 ? i.defaultMaxListeners : R._maxListeners
  }
  ;(i.prototype.getMaxListeners = function () {
    return c(this)
  }),
    (i.prototype.emit = function (N) {
      for (var T = [], M = 1; M < arguments.length; M++) T.push(arguments[M])
      var H = N === 'error',
        B = this._events
      if (B !== void 0) H = H && B.error === void 0
      else if (!H) return !1
      if (H) {
        var $
        if ((T.length > 0 && ($ = T[0]), $ instanceof Error)) throw $
        var D = new Error('Unhandled error.' + ($ ? ' (' + $.message + ')' : ''))
        throw ((D.context = $), D)
      }
      var W = B[N]
      if (W === void 0) return !1
      if (typeof W == 'function') e(W, this, T)
      else for (var U = W.length, w = y(W, U), M = 0; M < U; ++M) e(w[M], this, T)
      return !0
    })
  function u(R, N, T, M) {
    var H, B, $
    if (
      (a(T),
      (B = R._events),
      B === void 0
        ? ((B = R._events = Object.create(null)), (R._eventsCount = 0))
        : (B.newListener !== void 0 &&
            (R.emit('newListener', N, T.listener ? T.listener : T), (B = R._events)),
          ($ = B[N])),
      $ === void 0)
    )
      ($ = B[N] = T), ++R._eventsCount
    else if (
      (typeof $ == 'function' ? ($ = B[N] = M ? [T, $] : [$, T]) : M ? $.unshift(T) : $.push(T),
      (H = c(R)),
      H > 0 && $.length > H && !$.warned)
    ) {
      $.warned = !0
      var D = new Error(
        'Possible EventEmitter memory leak detected. ' +
          $.length +
          ' ' +
          String(N) +
          ' listeners added. Use emitter.setMaxListeners() to increase limit'
      )
      ;(D.name = 'MaxListenersExceededWarning'),
        (D.emitter = R),
        (D.type = N),
        (D.count = $.length),
        r(D)
    }
    return R
  }
  ;(i.prototype.addListener = function (N, T) {
    return u(this, N, T, !1)
  }),
    (i.prototype.on = i.prototype.addListener),
    (i.prototype.prependListener = function (N, T) {
      return u(this, N, T, !0)
    })
  function l() {
    if (!this.fired)
      return (
        this.target.removeListener(this.type, this.wrapFn),
        (this.fired = !0),
        arguments.length === 0
          ? this.listener.call(this.target)
          : this.listener.apply(this.target, arguments)
      )
  }
  function d(R, N, T) {
    var M = { fired: !1, wrapFn: void 0, target: R, type: N, listener: T },
      H = l.bind(M)
    return (H.listener = T), (M.wrapFn = H), H
  }
  ;(i.prototype.once = function (N, T) {
    return a(T), this.on(N, d(this, N, T)), this
  }),
    (i.prototype.prependOnceListener = function (N, T) {
      return a(T), this.prependListener(N, d(this, N, T)), this
    }),
    (i.prototype.removeListener = function (N, T) {
      var M, H, B, $, D
      if ((a(T), (H = this._events), H === void 0)) return this
      if (((M = H[N]), M === void 0)) return this
      if (M === T || M.listener === T)
        --this._eventsCount === 0
          ? (this._events = Object.create(null))
          : (delete H[N], H.removeListener && this.emit('removeListener', N, M.listener || T))
      else if (typeof M != 'function') {
        for (B = -1, $ = M.length - 1; $ >= 0; $--)
          if (M[$] === T || M[$].listener === T) {
            ;(D = M[$].listener), (B = $)
            break
          }
        if (B < 0) return this
        B === 0 ? M.shift() : m(M, B),
          M.length === 1 && (H[N] = M[0]),
          H.removeListener !== void 0 && this.emit('removeListener', N, D || T)
      }
      return this
    }),
    (i.prototype.off = i.prototype.removeListener),
    (i.prototype.removeAllListeners = function (N) {
      var T, M, H
      if (((M = this._events), M === void 0)) return this
      if (M.removeListener === void 0)
        return (
          arguments.length === 0
            ? ((this._events = Object.create(null)), (this._eventsCount = 0))
            : M[N] !== void 0 &&
              (--this._eventsCount === 0 ? (this._events = Object.create(null)) : delete M[N]),
          this
        )
      if (arguments.length === 0) {
        var B = Object.keys(M),
          $
        for (H = 0; H < B.length; ++H)
          ($ = B[H]), $ !== 'removeListener' && this.removeAllListeners($)
        return (
          this.removeAllListeners('removeListener'),
          (this._events = Object.create(null)),
          (this._eventsCount = 0),
          this
        )
      }
      if (((T = M[N]), typeof T == 'function')) this.removeListener(N, T)
      else if (T !== void 0) for (H = T.length - 1; H >= 0; H--) this.removeListener(N, T[H])
      return this
    })
  function h(R, N, T) {
    var M = R._events
    if (M === void 0) return []
    var H = M[N]
    return H === void 0
      ? []
      : typeof H == 'function'
        ? T
          ? [H.listener || H]
          : [H]
        : T
          ? b(H)
          : y(H, H.length)
  }
  ;(i.prototype.listeners = function (N) {
    return h(this, N, !0)
  }),
    (i.prototype.rawListeners = function (N) {
      return h(this, N, !1)
    }),
    (i.listenerCount = function (R, N) {
      return typeof R.listenerCount == 'function' ? R.listenerCount(N) : p.call(R, N)
    }),
    (i.prototype.listenerCount = p)
  function p(R) {
    var N = this._events
    if (N !== void 0) {
      var T = N[R]
      if (typeof T == 'function') return 1
      if (T !== void 0) return T.length
    }
    return 0
  }
  i.prototype.eventNames = function () {
    return this._eventsCount > 0 ? n(this._events) : []
  }
  function y(R, N) {
    for (var T = new Array(N), M = 0; M < N; ++M) T[M] = R[M]
    return T
  }
  function m(R, N) {
    for (; N + 1 < R.length; N++) R[N] = R[N + 1]
    R.pop()
  }
  function b(R) {
    for (var N = new Array(R.length), T = 0; T < N.length; ++T) N[T] = R[T].listener || R[T]
    return N
  }
  function I(R, N) {
    return new Promise(function (T, M) {
      function H($) {
        R.removeListener(N, B), M($)
      }
      function B() {
        typeof R.removeListener == 'function' && R.removeListener('error', H),
          T([].slice.call(arguments))
      }
      _(R, N, B, { once: !0 }), N !== 'error' && x(R, H, { once: !0 })
    })
  }
  function x(R, N, T) {
    typeof R.on == 'function' && _(R, 'error', N, T)
  }
  function _(R, N, T, M) {
    if (typeof R.on == 'function') M.once ? R.once(N, T) : R.on(N, T)
    else if (typeof R.addEventListener == 'function')
      R.addEventListener(N, function H(B) {
        M.once && R.removeEventListener(N, H), T(B)
      })
    else
      throw new TypeError(
        'The "emitter" argument must be of type EventEmitter. Received type ' + typeof R
      )
  }
  return eg.exports
}
var ui = rq()
const mA = _u(ui)
var Aw = {}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var V1 = function (
  t,
  e
) {
  return (
    (V1 =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (n, r) {
          n.__proto__ = r
        }) ||
      function (n, r) {
        for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s])
      }),
    V1(t, e)
  )
}
function sq(t, e) {
  V1(t, e)
  function n() {
    this.constructor = t
  }
  t.prototype = e === null ? Object.create(e) : ((n.prototype = e.prototype), new n())
}
var G1 = function () {
  return (
    (G1 =
      Object.assign ||
      function (e) {
        for (var n, r = 1, s = arguments.length; r < s; r++) {
          n = arguments[r]
          for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
      }),
    G1.apply(this, arguments)
  )
}
function iq(t, e) {
  var n = {}
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
  if (t != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var s = 0, r = Object.getOwnPropertySymbols(t); s < r.length; s++)
      e.indexOf(r[s]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[s]) &&
        (n[r[s]] = t[r[s]])
  return n
}
function oq(t, e, n, r) {
  var s = arguments.length,
    i = s < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, n)) : r,
    o
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
    i = Reflect.decorate(t, e, n, r)
  else
    for (var a = t.length - 1; a >= 0; a--)
      (o = t[a]) && (i = (s < 3 ? o(i) : s > 3 ? o(e, n, i) : o(e, n)) || i)
  return s > 3 && i && Object.defineProperty(e, n, i), i
}
function aq(t, e) {
  return function (n, r) {
    e(n, r, t)
  }
}
function cq(t, e) {
  if (typeof Reflect == 'object' && typeof Reflect.metadata == 'function')
    return Reflect.metadata(t, e)
}
function uq(t, e, n, r) {
  function s(i) {
    return i instanceof n
      ? i
      : new n(function (o) {
          o(i)
        })
  }
  return new (n || (n = Promise))(function (i, o) {
    function a(l) {
      try {
        u(r.next(l))
      } catch (d) {
        o(d)
      }
    }
    function c(l) {
      try {
        u(r.throw(l))
      } catch (d) {
        o(d)
      }
    }
    function u(l) {
      l.done ? i(l.value) : s(l.value).then(a, c)
    }
    u((r = r.apply(t, e || [])).next())
  })
}
function lq(t, e) {
  var n = {
      label: 0,
      sent: function () {
        if (i[0] & 1) throw i[1]
        return i[1]
      },
      trys: [],
      ops: []
    },
    r,
    s,
    i,
    o
  return (
    (o = { next: a(0), throw: a(1), return: a(2) }),
    typeof Symbol == 'function' &&
      (o[Symbol.iterator] = function () {
        return this
      }),
    o
  )
  function a(u) {
    return function (l) {
      return c([u, l])
    }
  }
  function c(u) {
    if (r) throw new TypeError('Generator is already executing.')
    for (; n; )
      try {
        if (
          ((r = 1),
          s &&
            (i =
              u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) &&
            !(i = i.call(s, u[1])).done)
        )
          return i
        switch (((s = 0), i && (u = [u[0] & 2, i.value]), u[0])) {
          case 0:
          case 1:
            i = u
            break
          case 4:
            return n.label++, { value: u[1], done: !1 }
          case 5:
            n.label++, (s = u[1]), (u = [0])
            continue
          case 7:
            ;(u = n.ops.pop()), n.trys.pop()
            continue
          default:
            if (
              ((i = n.trys), !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2))
            ) {
              n = 0
              continue
            }
            if (u[0] === 3 && (!i || (u[1] > i[0] && u[1] < i[3]))) {
              n.label = u[1]
              break
            }
            if (u[0] === 6 && n.label < i[1]) {
              ;(n.label = i[1]), (i = u)
              break
            }
            if (i && n.label < i[2]) {
              ;(n.label = i[2]), n.ops.push(u)
              break
            }
            i[2] && n.ops.pop(), n.trys.pop()
            continue
        }
        u = e.call(t, n)
      } catch (l) {
        ;(u = [6, l]), (s = 0)
      } finally {
        r = i = 0
      }
    if (u[0] & 5) throw u[1]
    return { value: u[0] ? u[1] : void 0, done: !0 }
  }
}
function dq(t, e, n, r) {
  r === void 0 && (r = n), (t[r] = e[n])
}
function hq(t, e) {
  for (var n in t) n !== 'default' && !e.hasOwnProperty(n) && (e[n] = t[n])
}
function Q1(t) {
  var e = typeof Symbol == 'function' && Symbol.iterator,
    n = e && t[e],
    r = 0
  if (n) return n.call(t)
  if (t && typeof t.length == 'number')
    return {
      next: function () {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
      }
    }
  throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
}
function rk(t, e) {
  var n = typeof Symbol == 'function' && t[Symbol.iterator]
  if (!n) return t
  var r = n.call(t),
    s,
    i = [],
    o
  try {
    for (; (e === void 0 || e-- > 0) && !(s = r.next()).done; ) i.push(s.value)
  } catch (a) {
    o = { error: a }
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r)
    } finally {
      if (o) throw o.error
    }
  }
  return i
}
function fq() {
  for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(rk(arguments[e]))
  return t
}
function pq() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length
  for (var r = Array(t), s = 0, e = 0; e < n; e++)
    for (var i = arguments[e], o = 0, a = i.length; o < a; o++, s++) r[s] = i[o]
  return r
}
function wf(t) {
  return this instanceof wf ? ((this.v = t), this) : new wf(t)
}
function gq(t, e, n) {
  if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.')
  var r = n.apply(t, e || []),
    s,
    i = []
  return (
    (s = {}),
    o('next'),
    o('throw'),
    o('return'),
    (s[Symbol.asyncIterator] = function () {
      return this
    }),
    s
  )
  function o(h) {
    r[h] &&
      (s[h] = function (p) {
        return new Promise(function (y, m) {
          i.push([h, p, y, m]) > 1 || a(h, p)
        })
      })
  }
  function a(h, p) {
    try {
      c(r[h](p))
    } catch (y) {
      d(i[0][3], y)
    }
  }
  function c(h) {
    h.value instanceof wf ? Promise.resolve(h.value.v).then(u, l) : d(i[0][2], h)
  }
  function u(h) {
    a('next', h)
  }
  function l(h) {
    a('throw', h)
  }
  function d(h, p) {
    h(p), i.shift(), i.length && a(i[0][0], i[0][1])
  }
}
function mq(t) {
  var e, n
  return (
    (e = {}),
    r('next'),
    r('throw', function (s) {
      throw s
    }),
    r('return'),
    (e[Symbol.iterator] = function () {
      return this
    }),
    e
  )
  function r(s, i) {
    e[s] = t[s]
      ? function (o) {
          return (n = !n) ? { value: wf(t[s](o)), done: s === 'return' } : i ? i(o) : o
        }
      : i
  }
}
function yq(t) {
  if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.')
  var e = t[Symbol.asyncIterator],
    n
  return e
    ? e.call(t)
    : ((t = typeof Q1 == 'function' ? Q1(t) : t[Symbol.iterator]()),
      (n = {}),
      r('next'),
      r('throw'),
      r('return'),
      (n[Symbol.asyncIterator] = function () {
        return this
      }),
      n)
  function r(i) {
    n[i] =
      t[i] &&
      function (o) {
        return new Promise(function (a, c) {
          ;(o = t[i](o)), s(a, c, o.done, o.value)
        })
      }
  }
  function s(i, o, a, c) {
    Promise.resolve(c).then(function (u) {
      i({ value: u, done: a })
    }, o)
  }
}
function wq(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, 'raw', { value: e }) : (t.raw = e), t
}
function bq(t) {
  if (t && t.__esModule) return t
  var e = {}
  if (t != null) for (var n in t) Object.hasOwnProperty.call(t, n) && (e[n] = t[n])
  return (e.default = t), e
}
function vq(t) {
  return t && t.__esModule ? t : { default: t }
}
function Eq(t, e) {
  if (!e.has(t)) throw new TypeError('attempted to get private field on non-instance')
  return e.get(t)
}
function Aq(t, e, n) {
  if (!e.has(t)) throw new TypeError('attempted to set private field on non-instance')
  return e.set(t, n), n
}
const _q = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        get __assign() {
          return G1
        },
        __asyncDelegator: mq,
        __asyncGenerator: gq,
        __asyncValues: yq,
        __await: wf,
        __awaiter: uq,
        __classPrivateFieldGet: Eq,
        __classPrivateFieldSet: Aq,
        __createBinding: dq,
        __decorate: oq,
        __exportStar: hq,
        __extends: sq,
        __generator: lq,
        __importDefault: vq,
        __importStar: bq,
        __makeTemplateObject: wq,
        __metadata: cq,
        __param: aq,
        __read: rk,
        __rest: iq,
        __spread: fq,
        __spreadArrays: pq,
        __values: Q1
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  up = N0(_q)
var _w = {},
  Kd = {},
  bS
function Cq() {
  if (bS) return Kd
  ;(bS = 1), Object.defineProperty(Kd, '__esModule', { value: !0 }), (Kd.delay = void 0)
  function t(e) {
    return new Promise(n => {
      setTimeout(() => {
        n(!0)
      }, e)
    })
  }
  return (Kd.delay = t), Kd
}
var mc = {},
  Cw = {},
  yc = {},
  vS
function Sq() {
  return (
    vS ||
      ((vS = 1),
      Object.defineProperty(yc, '__esModule', { value: !0 }),
      (yc.ONE_THOUSAND = yc.ONE_HUNDRED = void 0),
      (yc.ONE_HUNDRED = 100),
      (yc.ONE_THOUSAND = 1e3)),
    yc
  )
}
var Sw = {},
  ES
function Iq() {
  return (
    ES ||
      ((ES = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 }),
          (t.ONE_YEAR =
            t.FOUR_WEEKS =
            t.THREE_WEEKS =
            t.TWO_WEEKS =
            t.ONE_WEEK =
            t.THIRTY_DAYS =
            t.SEVEN_DAYS =
            t.FIVE_DAYS =
            t.THREE_DAYS =
            t.ONE_DAY =
            t.TWENTY_FOUR_HOURS =
            t.TWELVE_HOURS =
            t.SIX_HOURS =
            t.THREE_HOURS =
            t.ONE_HOUR =
            t.SIXTY_MINUTES =
            t.THIRTY_MINUTES =
            t.TEN_MINUTES =
            t.FIVE_MINUTES =
            t.ONE_MINUTE =
            t.SIXTY_SECONDS =
            t.THIRTY_SECONDS =
            t.TEN_SECONDS =
            t.FIVE_SECONDS =
            t.ONE_SECOND =
              void 0),
          (t.ONE_SECOND = 1),
          (t.FIVE_SECONDS = 5),
          (t.TEN_SECONDS = 10),
          (t.THIRTY_SECONDS = 30),
          (t.SIXTY_SECONDS = 60),
          (t.ONE_MINUTE = t.SIXTY_SECONDS),
          (t.FIVE_MINUTES = t.ONE_MINUTE * 5),
          (t.TEN_MINUTES = t.ONE_MINUTE * 10),
          (t.THIRTY_MINUTES = t.ONE_MINUTE * 30),
          (t.SIXTY_MINUTES = t.ONE_MINUTE * 60),
          (t.ONE_HOUR = t.SIXTY_MINUTES),
          (t.THREE_HOURS = t.ONE_HOUR * 3),
          (t.SIX_HOURS = t.ONE_HOUR * 6),
          (t.TWELVE_HOURS = t.ONE_HOUR * 12),
          (t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24),
          (t.ONE_DAY = t.TWENTY_FOUR_HOURS),
          (t.THREE_DAYS = t.ONE_DAY * 3),
          (t.FIVE_DAYS = t.ONE_DAY * 5),
          (t.SEVEN_DAYS = t.ONE_DAY * 7),
          (t.THIRTY_DAYS = t.ONE_DAY * 30),
          (t.ONE_WEEK = t.SEVEN_DAYS),
          (t.TWO_WEEKS = t.ONE_WEEK * 2),
          (t.THREE_WEEKS = t.ONE_WEEK * 3),
          (t.FOUR_WEEKS = t.ONE_WEEK * 4),
          (t.ONE_YEAR = t.ONE_DAY * 365)
      })(Sw)),
    Sw
  )
}
var AS
function sk() {
  return (
    AS ||
      ((AS = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 })
        const e = up
        e.__exportStar(Sq(), t), e.__exportStar(Iq(), t)
      })(Cw)),
    Cw
  )
}
var _S
function xq() {
  if (_S) return mc
  ;(_S = 1),
    Object.defineProperty(mc, '__esModule', { value: !0 }),
    (mc.fromMiliseconds = mc.toMiliseconds = void 0)
  const t = sk()
  function e(r) {
    return r * t.ONE_THOUSAND
  }
  mc.toMiliseconds = e
  function n(r) {
    return Math.floor(r / t.ONE_THOUSAND)
  }
  return (mc.fromMiliseconds = n), mc
}
var CS
function Tq() {
  return (
    CS ||
      ((CS = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 })
        const e = up
        e.__exportStar(Cq(), t), e.__exportStar(xq(), t)
      })(_w)),
    _w
  )
}
var $u = {},
  SS
function Nq() {
  if (SS) return $u
  ;(SS = 1), Object.defineProperty($u, '__esModule', { value: !0 }), ($u.Watch = void 0)
  class t {
    constructor() {
      this.timestamps = new Map()
    }
    start(n) {
      if (this.timestamps.has(n)) throw new Error(`Watch already started for label: ${n}`)
      this.timestamps.set(n, { started: Date.now() })
    }
    stop(n) {
      const r = this.get(n)
      if (typeof r.elapsed < 'u') throw new Error(`Watch already stopped for label: ${n}`)
      const s = Date.now() - r.started
      this.timestamps.set(n, { started: r.started, elapsed: s })
    }
    get(n) {
      const r = this.timestamps.get(n)
      if (typeof r > 'u') throw new Error(`No timestamp found for label: ${n}`)
      return r
    }
    elapsed(n) {
      const r = this.get(n)
      return r.elapsed || Date.now() - r.started
    }
  }
  return ($u.Watch = t), ($u.default = t), $u
}
var Iw = {},
  Vd = {},
  IS
function Pq() {
  if (IS) return Vd
  ;(IS = 1), Object.defineProperty(Vd, '__esModule', { value: !0 }), (Vd.IWatch = void 0)
  class t {}
  return (Vd.IWatch = t), Vd
}
var xS
function Rq() {
  return (
    xS ||
      ((xS = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 }), up.__exportStar(Pq(), t)
      })(Iw)),
    Iw
  )
}
var TS
function kq() {
  return (
    TS ||
      ((TS = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 })
        const e = up
        e.__exportStar(Tq(), t),
          e.__exportStar(Nq(), t),
          e.__exportStar(Rq(), t),
          e.__exportStar(sk(), t)
      })(Aw)),
    Aw
  )
}
var Me = kq()
class xu {}
let Oq = class extends xu {
  constructor(e) {
    super()
  }
}
const NS = Me.FIVE_SECONDS,
  Sd = { pulse: 'heartbeat_pulse' }
let Bq = class ik extends Oq {
  constructor(e) {
    super(e),
      (this.events = new ui.EventEmitter()),
      (this.interval = NS),
      (this.interval = (e == null ? void 0 : e.interval) || NS)
  }
  static async init(e) {
    const n = new ik(e)
    return await n.init(), n
  }
  async init() {
    await this.initialize()
  }
  stop() {
    clearInterval(this.intervalRef)
  }
  on(e, n) {
    this.events.on(e, n)
  }
  once(e, n) {
    this.events.once(e, n)
  }
  off(e, n) {
    this.events.off(e, n)
  }
  removeListener(e, n) {
    this.events.removeListener(e, n)
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), Me.toMiliseconds(this.interval))
  }
  pulse() {
    this.events.emit(Sd.pulse)
  }
}
function Dq(t) {
  return !t || typeof t.then != 'function' ? Promise.resolve(t) : t
}
function ur(t, ...e) {
  try {
    return Dq(t(...e))
  } catch (n) {
    return Promise.reject(n)
  }
}
function Mq(t) {
  const e = typeof t
  return t === null || (e !== 'object' && e !== 'function')
}
function Uq(t) {
  const e = Object.getPrototypeOf(t)
  return !e || e.isPrototypeOf(Object)
}
function Rg(t) {
  if (Mq(t)) return String(t)
  if (Uq(t) || Array.isArray(t)) return JSON.stringify(t)
  if (typeof t.toJSON == 'function') return Rg(t.toJSON())
  throw new Error('[unstorage] Cannot stringify value!')
}
const Z1 = 'base64:'
function Lq(t) {
  return typeof t == 'string' ? t : Z1 + jq(t)
}
function $q(t) {
  return typeof t != 'string' || !t.startsWith(Z1) ? t : Fq(t.slice(Z1.length))
}
function Fq(t) {
  return globalThis.Buffer
    ? Buffer.from(t, 'base64')
    : Uint8Array.from(globalThis.atob(t), e => e.codePointAt(0))
}
function jq(t) {
  return globalThis.Buffer
    ? Buffer.from(t).toString('base64')
    : globalThis.btoa(String.fromCodePoint(...t))
}
function ys(t) {
  var e
  return (
    (t &&
      ((e = t.split('?')[0]) == null
        ? void 0
        : e.replace(/[/\\]/g, ':').replace(/:+/g, ':').replace(/^:|:$/g, ''))) ||
    ''
  )
}
function Hq(...t) {
  return ys(t.join(':'))
}
function tg(t) {
  return (t = ys(t)), t ? t + ':' : ''
}
function qq(t, e) {
  if (e === void 0) return !0
  let n = 0,
    r = t.indexOf(':')
  for (; r > -1; ) n++, (r = t.indexOf(':', r + 1))
  return n <= e
}
function zq(t, e) {
  return e ? t.startsWith(e) && t[t.length - 1] !== '$' : t[t.length - 1] !== '$'
}
const Wq = 'memory',
  Kq = () => {
    const t = new Map()
    return {
      name: Wq,
      getInstance: () => t,
      hasItem(e) {
        return t.has(e)
      },
      getItem(e) {
        return t.get(e) ?? null
      },
      getItemRaw(e) {
        return t.get(e) ?? null
      },
      setItem(e, n) {
        t.set(e, n)
      },
      setItemRaw(e, n) {
        t.set(e, n)
      },
      removeItem(e) {
        t.delete(e)
      },
      getKeys() {
        return [...t.keys()]
      },
      clear() {
        t.clear()
      },
      dispose() {
        t.clear()
      }
    }
  }
function Vq(t = {}) {
  const e = {
      mounts: { '': t.driver || Kq() },
      mountpoints: [''],
      watching: !1,
      watchListeners: [],
      unwatch: {}
    },
    n = u => {
      for (const l of e.mountpoints)
        if (u.startsWith(l)) return { base: l, relativeKey: u.slice(l.length), driver: e.mounts[l] }
      return { base: '', relativeKey: u, driver: e.mounts[''] }
    },
    r = (u, l) =>
      e.mountpoints
        .filter(d => d.startsWith(u) || (l && u.startsWith(d)))
        .map(d => ({
          relativeBase: u.length > d.length ? u.slice(d.length) : void 0,
          mountpoint: d,
          driver: e.mounts[d]
        })),
    s = (u, l) => {
      if (e.watching) {
        l = ys(l)
        for (const d of e.watchListeners) d(u, l)
      }
    },
    i = async () => {
      if (!e.watching) {
        e.watching = !0
        for (const u in e.mounts) e.unwatch[u] = await PS(e.mounts[u], s, u)
      }
    },
    o = async () => {
      if (e.watching) {
        for (const u in e.unwatch) await e.unwatch[u]()
        ;(e.unwatch = {}), (e.watching = !1)
      }
    },
    a = (u, l, d) => {
      const h = new Map(),
        p = y => {
          let m = h.get(y.base)
          return m || ((m = { driver: y.driver, base: y.base, items: [] }), h.set(y.base, m)), m
        }
      for (const y of u) {
        const m = typeof y == 'string',
          b = ys(m ? y : y.key),
          I = m ? void 0 : y.value,
          x = m || !y.options ? l : { ...l, ...y.options },
          _ = n(b)
        p(_).items.push({ key: b, value: I, relativeKey: _.relativeKey, options: x })
      }
      return Promise.all([...h.values()].map(y => d(y))).then(y => y.flat())
    },
    c = {
      hasItem(u, l = {}) {
        u = ys(u)
        const { relativeKey: d, driver: h } = n(u)
        return ur(h.hasItem, d, l)
      },
      getItem(u, l = {}) {
        u = ys(u)
        const { relativeKey: d, driver: h } = n(u)
        return ur(h.getItem, d, l).then(p => Bc(p))
      },
      getItems(u, l = {}) {
        return a(u, l, d =>
          d.driver.getItems
            ? ur(
                d.driver.getItems,
                d.items.map(h => ({ key: h.relativeKey, options: h.options })),
                l
              ).then(h => h.map(p => ({ key: Hq(d.base, p.key), value: Bc(p.value) })))
            : Promise.all(
                d.items.map(h =>
                  ur(d.driver.getItem, h.relativeKey, h.options).then(p => ({
                    key: h.key,
                    value: Bc(p)
                  }))
                )
              )
        )
      },
      getItemRaw(u, l = {}) {
        u = ys(u)
        const { relativeKey: d, driver: h } = n(u)
        return h.getItemRaw ? ur(h.getItemRaw, d, l) : ur(h.getItem, d, l).then(p => $q(p))
      },
      async setItem(u, l, d = {}) {
        if (l === void 0) return c.removeItem(u)
        u = ys(u)
        const { relativeKey: h, driver: p } = n(u)
        p.setItem && (await ur(p.setItem, h, Rg(l), d), p.watch || s('update', u))
      },
      async setItems(u, l) {
        await a(u, l, async d => {
          if (d.driver.setItems)
            return ur(
              d.driver.setItems,
              d.items.map(h => ({ key: h.relativeKey, value: Rg(h.value), options: h.options })),
              l
            )
          d.driver.setItem &&
            (await Promise.all(
              d.items.map(h => ur(d.driver.setItem, h.relativeKey, Rg(h.value), h.options))
            ))
        })
      },
      async setItemRaw(u, l, d = {}) {
        if (l === void 0) return c.removeItem(u, d)
        u = ys(u)
        const { relativeKey: h, driver: p } = n(u)
        if (p.setItemRaw) await ur(p.setItemRaw, h, l, d)
        else if (p.setItem) await ur(p.setItem, h, Lq(l), d)
        else return
        p.watch || s('update', u)
      },
      async removeItem(u, l = {}) {
        typeof l == 'boolean' && (l = { removeMeta: l }), (u = ys(u))
        const { relativeKey: d, driver: h } = n(u)
        h.removeItem &&
          (await ur(h.removeItem, d, l),
          (l.removeMeta || l.removeMata) && (await ur(h.removeItem, d + '$', l)),
          h.watch || s('remove', u))
      },
      async getMeta(u, l = {}) {
        typeof l == 'boolean' && (l = { nativeOnly: l }), (u = ys(u))
        const { relativeKey: d, driver: h } = n(u),
          p = Object.create(null)
        if ((h.getMeta && Object.assign(p, await ur(h.getMeta, d, l)), !l.nativeOnly)) {
          const y = await ur(h.getItem, d + '$', l).then(m => Bc(m))
          y &&
            typeof y == 'object' &&
            (typeof y.atime == 'string' && (y.atime = new Date(y.atime)),
            typeof y.mtime == 'string' && (y.mtime = new Date(y.mtime)),
            Object.assign(p, y))
        }
        return p
      },
      setMeta(u, l, d = {}) {
        return this.setItem(u + '$', l, d)
      },
      removeMeta(u, l = {}) {
        return this.removeItem(u + '$', l)
      },
      async getKeys(u, l = {}) {
        var b
        u = tg(u)
        const d = r(u, !0)
        let h = []
        const p = []
        let y = !0
        for (const I of d) {
          ;((b = I.driver.flags) != null && b.maxDepth) || (y = !1)
          const x = await ur(I.driver.getKeys, I.relativeBase, l)
          for (const _ of x) {
            const R = I.mountpoint + ys(_)
            h.some(N => R.startsWith(N)) || p.push(R)
          }
          h = [I.mountpoint, ...h.filter(_ => !_.startsWith(I.mountpoint))]
        }
        const m = l.maxDepth !== void 0 && !y
        return p.filter(I => (!m || qq(I, l.maxDepth)) && zq(I, u))
      },
      async clear(u, l = {}) {
        ;(u = tg(u)),
          await Promise.all(
            r(u, !1).map(async d => {
              if (d.driver.clear) return ur(d.driver.clear, d.relativeBase, l)
              if (d.driver.removeItem) {
                const h = await d.driver.getKeys(d.relativeBase || '', l)
                return Promise.all(h.map(p => d.driver.removeItem(p, l)))
              }
            })
          )
      },
      async dispose() {
        await Promise.all(Object.values(e.mounts).map(u => RS(u)))
      },
      async watch(u) {
        return (
          await i(),
          e.watchListeners.push(u),
          async () => {
            ;(e.watchListeners = e.watchListeners.filter(l => l !== u)),
              e.watchListeners.length === 0 && (await o())
          }
        )
      },
      async unwatch() {
        ;(e.watchListeners = []), await o()
      },
      mount(u, l) {
        if (((u = tg(u)), u && e.mounts[u])) throw new Error(`already mounted at ${u}`)
        return (
          u && (e.mountpoints.push(u), e.mountpoints.sort((d, h) => h.length - d.length)),
          (e.mounts[u] = l),
          e.watching &&
            Promise.resolve(PS(l, s, u))
              .then(d => {
                e.unwatch[u] = d
              })
              .catch(console.error),
          c
        )
      },
      async unmount(u, l = !0) {
        var d, h
        ;(u = tg(u)),
          !(!u || !e.mounts[u]) &&
            (e.watching &&
              u in e.unwatch &&
              ((h = (d = e.unwatch)[u]) == null || h.call(d), delete e.unwatch[u]),
            l && (await RS(e.mounts[u])),
            (e.mountpoints = e.mountpoints.filter(p => p !== u)),
            delete e.mounts[u])
      },
      getMount(u = '') {
        u = ys(u) + ':'
        const l = n(u)
        return { driver: l.driver, base: l.base }
      },
      getMounts(u = '', l = {}) {
        return (u = ys(u)), r(u, l.parents).map(h => ({ driver: h.driver, base: h.mountpoint }))
      },
      keys: (u, l = {}) => c.getKeys(u, l),
      get: (u, l = {}) => c.getItem(u, l),
      set: (u, l, d = {}) => c.setItem(u, l, d),
      has: (u, l = {}) => c.hasItem(u, l),
      del: (u, l = {}) => c.removeItem(u, l),
      remove: (u, l = {}) => c.removeItem(u, l)
    }
  return c
}
function PS(t, e, n) {
  return t.watch ? t.watch((r, s) => e(r, n + s)) : () => {}
}
async function RS(t) {
  typeof t.dispose == 'function' && (await ur(t.dispose))
}
function Tu(t) {
  return new Promise((e, n) => {
    ;(t.oncomplete = t.onsuccess = () => e(t.result)), (t.onabort = t.onerror = () => n(t.error))
  })
}
function ok(t, e) {
  const n = indexedDB.open(t)
  n.onupgradeneeded = () => n.result.createObjectStore(e)
  const r = Tu(n)
  return (s, i) => r.then(o => i(o.transaction(e, s).objectStore(e)))
}
let xw
function lp() {
  return xw || (xw = ok('keyval-store', 'keyval')), xw
}
function kS(t, e = lp()) {
  return e('readonly', n => Tu(n.get(t)))
}
function Gq(t, e, n = lp()) {
  return n('readwrite', r => (r.put(e, t), Tu(r.transaction)))
}
function Qq(t, e = lp()) {
  return e('readwrite', n => (n.delete(t), Tu(n.transaction)))
}
function Zq(t = lp()) {
  return t('readwrite', e => (e.clear(), Tu(e.transaction)))
}
function Yq(t, e) {
  return (
    (t.openCursor().onsuccess = function () {
      this.result && (e(this.result), this.result.continue())
    }),
    Tu(t.transaction)
  )
}
function Jq(t = lp()) {
  return t('readonly', e => {
    if (e.getAllKeys) return Tu(e.getAllKeys())
    const n = []
    return Yq(e, r => n.push(r.key)).then(() => n)
  })
}
const Xq = t => JSON.stringify(t, (e, n) => (typeof n == 'bigint' ? n.toString() + 'n' : n)),
  ez = t => {
    const e =
        /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
      n = t.replace(e, '$1"$2n"$3')
    return JSON.parse(n, (r, s) =>
      typeof s == 'string' && s.match(/^\d+n$/) ? BigInt(s.substring(0, s.length - 1)) : s
    )
  }
function hu(t) {
  if (typeof t != 'string') throw new Error(`Cannot safe json parse value of type ${typeof t}`)
  try {
    return ez(t)
  } catch {
    return t
  }
}
function Jo(t) {
  return typeof t == 'string' ? t : Xq(t) || ''
}
const tz = 'idb-keyval'
var nz = (t = {}) => {
  const e = t.base && t.base.length > 0 ? `${t.base}:` : '',
    n = s => e + s
  let r
  return (
    t.dbName && t.storeName && (r = ok(t.dbName, t.storeName)),
    {
      name: tz,
      options: t,
      async hasItem(s) {
        return !(typeof (await kS(n(s), r)) > 'u')
      },
      async getItem(s) {
        return (await kS(n(s), r)) ?? null
      },
      setItem(s, i) {
        return Gq(n(s), i, r)
      },
      removeItem(s) {
        return Qq(n(s), r)
      },
      getKeys() {
        return Jq(r)
      },
      clear() {
        return Zq(r)
      }
    }
  )
}
const rz = 'WALLET_CONNECT_V2_INDEXED_DB',
  sz = 'keyvaluestorage'
let iz = class {
  constructor() {
    this.indexedDb = Vq({ driver: nz({ dbName: rz, storeName: sz }) })
  }
  async getKeys() {
    return this.indexedDb.getKeys()
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(e => [
      e.key,
      e.value
    ])
  }
  async getItem(e) {
    const n = await this.indexedDb.getItem(e)
    if (n !== null) return n
  }
  async setItem(e, n) {
    await this.indexedDb.setItem(e, Jo(n))
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e)
  }
}
var Tw =
    typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
        ? window
        : typeof global < 'u'
          ? global
          : typeof self < 'u'
            ? self
            : {},
  kg = { exports: {} }
;(function () {
  let t
  function e() {}
  ;(t = e),
    (t.prototype.getItem = function (n) {
      return this.hasOwnProperty(n) ? String(this[n]) : null
    }),
    (t.prototype.setItem = function (n, r) {
      this[n] = String(r)
    }),
    (t.prototype.removeItem = function (n) {
      delete this[n]
    }),
    (t.prototype.clear = function () {
      const n = this
      Object.keys(n).forEach(function (r) {
        ;(n[r] = void 0), delete n[r]
      })
    }),
    (t.prototype.key = function (n) {
      return (n = n || 0), Object.keys(this)[n]
    }),
    t.prototype.__defineGetter__('length', function () {
      return Object.keys(this).length
    }),
    typeof Tw < 'u' && Tw.localStorage
      ? (kg.exports = Tw.localStorage)
      : typeof window < 'u' && window.localStorage
        ? (kg.exports = window.localStorage)
        : (kg.exports = new e())
})()
function oz(t) {
  var e
  return [t[0], hu((e = t[1]) != null ? e : '')]
}
let az = class {
  constructor() {
    this.localStorage = kg.exports
  }
  async getKeys() {
    return Object.keys(this.localStorage)
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(oz)
  }
  async getItem(e) {
    const n = this.localStorage.getItem(e)
    if (n !== null) return hu(n)
  }
  async setItem(e, n) {
    this.localStorage.setItem(e, Jo(n))
  }
  async removeItem(e) {
    this.localStorage.removeItem(e)
  }
}
const cz = 'wc_storage_version',
  OS = 1,
  uz = async (t, e, n) => {
    const r = cz,
      s = await e.getItem(r)
    if (s && s >= OS) {
      n(e)
      return
    }
    const i = await t.getKeys()
    if (!i.length) {
      n(e)
      return
    }
    const o = []
    for (; i.length; ) {
      const a = i.shift()
      if (!a) continue
      const c = a.toLowerCase()
      if (
        c.includes('wc@') ||
        c.includes('walletconnect') ||
        c.includes('wc_') ||
        c.includes('wallet_connect')
      ) {
        const u = await t.getItem(a)
        await e.setItem(a, u), o.push(a)
      }
    }
    await e.setItem(r, OS), n(e), lz(t, o)
  },
  lz = async (t, e) => {
    e.length &&
      e.forEach(async n => {
        await t.removeItem(n)
      })
  }
let dz = class {
  constructor() {
    ;(this.initialized = !1),
      (this.setInitialized = n => {
        ;(this.storage = n), (this.initialized = !0)
      })
    const e = new az()
    this.storage = e
    try {
      const n = new iz()
      uz(e, n, this.setInitialized)
    } catch {
      this.initialized = !0
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys()
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries()
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e)
  }
  async setItem(e, n) {
    return await this.initialize(), this.storage.setItem(e, n)
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e)
  }
  async initialize() {
    this.initialized ||
      (await new Promise(e => {
        const n = setInterval(() => {
          this.initialized && (clearInterval(n), e())
        }, 20)
      }))
  }
}
var Nw, BS
function hz() {
  if (BS) return Nw
  BS = 1
  function t(n) {
    try {
      return JSON.stringify(n)
    } catch {
      return '"[Circular]"'
    }
  }
  Nw = e
  function e(n, r, s) {
    var i = (s && s.stringify) || t,
      o = 1
    if (typeof n == 'object' && n !== null) {
      var a = r.length + o
      if (a === 1) return n
      var c = new Array(a)
      c[0] = i(n)
      for (var u = 1; u < a; u++) c[u] = i(r[u])
      return c.join(' ')
    }
    if (typeof n != 'string') return n
    var l = r.length
    if (l === 0) return n
    for (var d = '', h = 1 - o, p = -1, y = (n && n.length) || 0, m = 0; m < y; ) {
      if (n.charCodeAt(m) === 37 && m + 1 < y) {
        switch (((p = p > -1 ? p : 0), n.charCodeAt(m + 1))) {
          case 100:
          case 102:
            if (h >= l || r[h] == null) break
            p < m && (d += n.slice(p, m)), (d += Number(r[h])), (p = m + 2), m++
            break
          case 105:
            if (h >= l || r[h] == null) break
            p < m && (d += n.slice(p, m)), (d += Math.floor(Number(r[h]))), (p = m + 2), m++
            break
          case 79:
          case 111:
          case 106:
            if (h >= l || r[h] === void 0) break
            p < m && (d += n.slice(p, m))
            var b = typeof r[h]
            if (b === 'string') {
              ;(d += "'" + r[h] + "'"), (p = m + 2), m++
              break
            }
            if (b === 'function') {
              ;(d += r[h].name || '<anonymous>'), (p = m + 2), m++
              break
            }
            ;(d += i(r[h])), (p = m + 2), m++
            break
          case 115:
            if (h >= l) break
            p < m && (d += n.slice(p, m)), (d += String(r[h])), (p = m + 2), m++
            break
          case 37:
            p < m && (d += n.slice(p, m)), (d += '%'), (p = m + 2), m++, h--
            break
        }
        ++h
      }
      ++m
    }
    return p === -1 ? n : (p < y && (d += n.slice(p)), d)
  }
  return Nw
}
var Pw, DS
function fz() {
  if (DS) return Pw
  DS = 1
  const t = hz()
  Pw = s
  const e = N().console || {},
    n = {
      mapHttpRequest: y,
      mapHttpResponse: y,
      wrapRequestSerializer: m,
      wrapResponseSerializer: m,
      wrapErrorSerializer: m,
      req: y,
      res: y,
      err: h
    }
  function r(T, M) {
    return Array.isArray(T)
      ? T.filter(function (B) {
          return B !== '!stdSerializers.err'
        })
      : T === !0
        ? Object.keys(M)
        : !1
  }
  function s(T) {
    ;(T = T || {}), (T.browser = T.browser || {})
    const M = T.browser.transmit
    if (M && typeof M.send != 'function')
      throw Error('pino: transmit option must have a send function')
    const H = T.browser.write || e
    T.browser.write && (T.browser.asObject = !0)
    const B = T.serializers || {},
      $ = r(T.browser.serialize, B)
    let D = T.browser.serialize
    Array.isArray(T.browser.serialize) &&
      T.browser.serialize.indexOf('!stdSerializers.err') > -1 &&
      (D = !1)
    const W = ['error', 'fatal', 'warn', 'info', 'debug', 'trace']
    typeof H == 'function' && (H.error = H.fatal = H.warn = H.info = H.debug = H.trace = H),
      T.enabled === !1 && (T.level = 'silent')
    const U = T.level || 'info',
      w = Object.create(H)
    w.log || (w.log = b),
      Object.defineProperty(w, 'levelVal', { get: A }),
      Object.defineProperty(w, 'level', { get: P, set: O })
    const v = {
      transmit: M,
      serialize: $,
      asObject: T.browser.asObject,
      levels: W,
      timestamp: p(T)
    }
    ;(w.levels = s.levels),
      (w.level = U),
      (w.setMaxListeners =
        w.getMaxListeners =
        w.emit =
        w.addListener =
        w.on =
        w.prependListener =
        w.once =
        w.prependOnceListener =
        w.removeListener =
        w.removeAllListeners =
        w.listeners =
        w.listenerCount =
        w.eventNames =
        w.write =
        w.flush =
          b),
      (w.serializers = B),
      (w._serialize = $),
      (w._stdErrSerialize = D),
      (w.child = F),
      M && (w._logEvent = d())
    function A() {
      return this.level === 'silent' ? 1 / 0 : this.levels.values[this.level]
    }
    function P() {
      return this._level
    }
    function O(z) {
      if (z !== 'silent' && !this.levels.values[z]) throw Error('unknown level ' + z)
      ;(this._level = z),
        i(v, w, 'error', 'log'),
        i(v, w, 'fatal', 'error'),
        i(v, w, 'warn', 'error'),
        i(v, w, 'info', 'log'),
        i(v, w, 'debug', 'log'),
        i(v, w, 'trace', 'log')
    }
    function F(z, j) {
      if (!z) throw new Error('missing bindings for child Pino')
      ;(j = j || {}), $ && z.serializers && (j.serializers = z.serializers)
      const E = j.serializers
      if ($ && E) {
        var C = Object.assign({}, B, E),
          L = T.browser.serialize === !0 ? Object.keys(C) : $
        delete z.serializers, c([z], L, C, this._stdErrSerialize)
      }
      function K(ee) {
        ;(this._childLevel = (ee._childLevel | 0) + 1),
          (this.error = u(ee, z, 'error')),
          (this.fatal = u(ee, z, 'fatal')),
          (this.warn = u(ee, z, 'warn')),
          (this.info = u(ee, z, 'info')),
          (this.debug = u(ee, z, 'debug')),
          (this.trace = u(ee, z, 'trace')),
          C && ((this.serializers = C), (this._serialize = L)),
          M && (this._logEvent = d([].concat(ee._logEvent.bindings, z)))
      }
      return (K.prototype = this), new K(this)
    }
    return w
  }
  ;(s.levels = {
    values: { fatal: 60, error: 50, warn: 40, info: 30, debug: 20, trace: 10 },
    labels: { 10: 'trace', 20: 'debug', 30: 'info', 40: 'warn', 50: 'error', 60: 'fatal' }
  }),
    (s.stdSerializers = n),
    (s.stdTimeFunctions = Object.assign({}, { nullTime: I, epochTime: x, unixTime: _, isoTime: R }))
  function i(T, M, H, B) {
    const $ = Object.getPrototypeOf(M)
    ;(M[H] = M.levelVal > M.levels.values[H] ? b : $[H] ? $[H] : e[H] || e[B] || b), o(T, M, H)
  }
  function o(T, M, H) {
    ;(!T.transmit && M[H] === b) ||
      (M[H] = (function (B) {
        return function () {
          const D = T.timestamp(),
            W = new Array(arguments.length),
            U = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this
          for (var w = 0; w < W.length; w++) W[w] = arguments[w]
          if (
            (T.serialize &&
              !T.asObject &&
              c(W, this._serialize, this.serializers, this._stdErrSerialize),
            T.asObject ? B.call(U, a(this, H, W, D)) : B.apply(U, W),
            T.transmit)
          ) {
            const v = T.transmit.level || M.level,
              A = s.levels.values[v],
              P = s.levels.values[H]
            if (P < A) return
            l(
              this,
              {
                ts: D,
                methodLevel: H,
                methodValue: P,
                transmitValue: s.levels.values[T.transmit.level || M.level],
                send: T.transmit.send,
                val: M.levelVal
              },
              W
            )
          }
        }
      })(M[H]))
  }
  function a(T, M, H, B) {
    T._serialize && c(H, T._serialize, T.serializers, T._stdErrSerialize)
    const $ = H.slice()
    let D = $[0]
    const W = {}
    B && (W.time = B), (W.level = s.levels.values[M])
    let U = (T._childLevel | 0) + 1
    if ((U < 1 && (U = 1), D !== null && typeof D == 'object')) {
      for (; U-- && typeof $[0] == 'object'; ) Object.assign(W, $.shift())
      D = $.length ? t($.shift(), $) : void 0
    } else typeof D == 'string' && (D = t($.shift(), $))
    return D !== void 0 && (W.msg = D), W
  }
  function c(T, M, H, B) {
    for (const $ in T)
      if (B && T[$] instanceof Error) T[$] = s.stdSerializers.err(T[$])
      else if (typeof T[$] == 'object' && !Array.isArray(T[$]))
        for (const D in T[$]) M && M.indexOf(D) > -1 && D in H && (T[$][D] = H[D](T[$][D]))
  }
  function u(T, M, H) {
    return function () {
      const B = new Array(1 + arguments.length)
      B[0] = M
      for (var $ = 1; $ < B.length; $++) B[$] = arguments[$ - 1]
      return T[H].apply(this, B)
    }
  }
  function l(T, M, H) {
    const B = M.send,
      $ = M.ts,
      D = M.methodLevel,
      W = M.methodValue,
      U = M.val,
      w = T._logEvent.bindings
    c(
      H,
      T._serialize || Object.keys(T.serializers),
      T.serializers,
      T._stdErrSerialize === void 0 ? !0 : T._stdErrSerialize
    ),
      (T._logEvent.ts = $),
      (T._logEvent.messages = H.filter(function (v) {
        return w.indexOf(v) === -1
      })),
      (T._logEvent.level.label = D),
      (T._logEvent.level.value = W),
      B(D, T._logEvent, U),
      (T._logEvent = d(w))
  }
  function d(T) {
    return { ts: 0, messages: [], bindings: T || [], level: { label: '', value: 0 } }
  }
  function h(T) {
    const M = { type: T.constructor.name, msg: T.message, stack: T.stack }
    for (const H in T) M[H] === void 0 && (M[H] = T[H])
    return M
  }
  function p(T) {
    return typeof T.timestamp == 'function' ? T.timestamp : T.timestamp === !1 ? I : x
  }
  function y() {
    return {}
  }
  function m(T) {
    return T
  }
  function b() {}
  function I() {
    return !1
  }
  function x() {
    return Date.now()
  }
  function _() {
    return Math.round(Date.now() / 1e3)
  }
  function R() {
    return new Date(Date.now()).toISOString()
  }
  function N() {
    function T(M) {
      return typeof M < 'u' && M
    }
    try {
      return (
        typeof globalThis < 'u' ||
          Object.defineProperty(Object.prototype, 'globalThis', {
            get: function () {
              return delete Object.prototype.globalThis, (this.globalThis = this)
            },
            configurable: !0
          }),
        globalThis
      )
    } catch {
      return T(self) || T(window) || T(this) || {}
    }
  }
  return Pw
}
var ol = fz()
const dp = _u(ol),
  pz = { level: 'info' },
  hp = 'custom_context',
  yA = 1e3 * 1024
let gz = class {
    constructor(e) {
      ;(this.nodeValue = e),
        (this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length),
        (this.next = null)
    }
    get value() {
      return this.nodeValue
    }
    get size() {
      return this.sizeInBytes
    }
  },
  MS = class {
    constructor(e) {
      ;(this.head = null),
        (this.tail = null),
        (this.lengthInNodes = 0),
        (this.maxSizeInBytes = e),
        (this.sizeInBytes = 0)
    }
    append(e) {
      const n = new gz(e)
      if (n.size > this.maxSizeInBytes)
        throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${n.size}`)
      for (; this.size + n.size > this.maxSizeInBytes; ) this.shift()
      this.head
        ? (this.tail && (this.tail.next = n), (this.tail = n))
        : ((this.head = n), (this.tail = n)),
        this.lengthInNodes++,
        (this.sizeInBytes += n.size)
    }
    shift() {
      if (!this.head) return
      const e = this.head
      ;(this.head = this.head.next),
        this.head || (this.tail = null),
        this.lengthInNodes--,
        (this.sizeInBytes -= e.size)
    }
    toArray() {
      const e = []
      let n = this.head
      for (; n !== null; ) e.push(n.value), (n = n.next)
      return e
    }
    get length() {
      return this.lengthInNodes
    }
    get size() {
      return this.sizeInBytes
    }
    toOrderedArray() {
      return Array.from(this)
    }
    [Symbol.iterator]() {
      let e = this.head
      return {
        next: () => {
          if (!e) return { done: !0, value: null }
          const n = e.value
          return (e = e.next), { done: !1, value: n }
        }
      }
    }
  },
  ak = class {
    constructor(e, n = yA) {
      ;(this.level = e ?? 'error'),
        (this.levelValue = ol.levels.values[this.level]),
        (this.MAX_LOG_SIZE_IN_BYTES = n),
        (this.logs = new MS(this.MAX_LOG_SIZE_IN_BYTES))
    }
    forwardToConsole(e, n) {
      n === ol.levels.values.error
        ? console.error(e)
        : n === ol.levels.values.warn
          ? console.warn(e)
          : n === ol.levels.values.debug
            ? console.debug(e)
            : n === ol.levels.values.trace
              ? console.trace(e)
              : console.log(e)
    }
    appendToLogs(e) {
      this.logs.append(Jo({ timestamp: new Date().toISOString(), log: e }))
      const n = typeof e == 'string' ? JSON.parse(e).level : e.level
      n >= this.levelValue && this.forwardToConsole(e, n)
    }
    getLogs() {
      return this.logs
    }
    clearLogs() {
      this.logs = new MS(this.MAX_LOG_SIZE_IN_BYTES)
    }
    getLogArray() {
      return Array.from(this.logs)
    }
    logsToBlob(e) {
      const n = this.getLogArray()
      return n.push(Jo({ extraMetadata: e })), new Blob(n, { type: 'application/json' })
    }
  },
  mz = class {
    constructor(e, n = yA) {
      this.baseChunkLogger = new ak(e, n)
    }
    write(e) {
      this.baseChunkLogger.appendToLogs(e)
    }
    getLogs() {
      return this.baseChunkLogger.getLogs()
    }
    clearLogs() {
      this.baseChunkLogger.clearLogs()
    }
    getLogArray() {
      return this.baseChunkLogger.getLogArray()
    }
    logsToBlob(e) {
      return this.baseChunkLogger.logsToBlob(e)
    }
    downloadLogsBlobInBrowser(e) {
      const n = URL.createObjectURL(this.logsToBlob(e)),
        r = document.createElement('a')
      ;(r.href = n),
        (r.download = `walletconnect-logs-${new Date().toISOString()}.txt`),
        document.body.appendChild(r),
        r.click(),
        document.body.removeChild(r),
        URL.revokeObjectURL(n)
    }
  },
  yz = class {
    constructor(e, n = yA) {
      this.baseChunkLogger = new ak(e, n)
    }
    write(e) {
      this.baseChunkLogger.appendToLogs(e)
    }
    getLogs() {
      return this.baseChunkLogger.getLogs()
    }
    clearLogs() {
      this.baseChunkLogger.clearLogs()
    }
    getLogArray() {
      return this.baseChunkLogger.getLogArray()
    }
    logsToBlob(e) {
      return this.baseChunkLogger.logsToBlob(e)
    }
  }
var wz = Object.defineProperty,
  bz = Object.defineProperties,
  vz = Object.getOwnPropertyDescriptors,
  US = Object.getOwnPropertySymbols,
  Ez = Object.prototype.hasOwnProperty,
  Az = Object.prototype.propertyIsEnumerable,
  LS = (t, e, n) =>
    e in t ? wz(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  ym = (t, e) => {
    for (var n in e || (e = {})) Ez.call(e, n) && LS(t, n, e[n])
    if (US) for (var n of US(e)) Az.call(e, n) && LS(t, n, e[n])
    return t
  },
  wm = (t, e) => bz(t, vz(e))
function Id(t) {
  return wm(ym({}, t), { level: (t == null ? void 0 : t.level) || pz.level })
}
function _z(t, e = hp) {
  return t[e] || ''
}
function Cz(t, e, n = hp) {
  return (t[n] = e), t
}
function Is(t, e = hp) {
  let n = ''
  return typeof t.bindings > 'u' ? (n = _z(t, e)) : (n = t.bindings().context || ''), n
}
function Sz(t, e, n = hp) {
  const r = Is(t, n)
  return r.trim() ? `${r}/${e}` : e
}
function Jr(t, e, n = hp) {
  const r = Sz(t, e, n),
    s = t.child({ context: r })
  return Cz(s, r, n)
}
function Iz(t) {
  var e, n
  const r = new mz((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes)
  return {
    logger: dp(
      wm(ym({}, t.opts), {
        level: 'trace',
        browser: wm(ym({}, (n = t.opts) == null ? void 0 : n.browser), { write: s => r.write(s) })
      })
    ),
    chunkLoggerController: r
  }
}
function xz(t) {
  var e
  const n = new yz((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes)
  return { logger: dp(wm(ym({}, t.opts), { level: 'trace' }), n), chunkLoggerController: n }
}
function wA(t) {
  return typeof t.loggerOverride < 'u' && typeof t.loggerOverride != 'string'
    ? { logger: t.loggerOverride, chunkLoggerController: null }
    : typeof window < 'u'
      ? Iz(t)
      : xz(t)
}
var Tz = Object.defineProperty,
  Nz = (t, e, n) =>
    e in t ? Tz(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  $S = (t, e, n) => Nz(t, typeof e != 'symbol' ? e + '' : e, n)
let Pz = class extends xu {
  constructor(e) {
    super(), (this.opts = e), $S(this, 'protocol', 'wc'), $S(this, 'version', 2)
  }
}
var Rz = Object.defineProperty,
  kz = (t, e, n) =>
    e in t ? Rz(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Oz = (t, e, n) => kz(t, e + '', n)
let Bz = class extends xu {
    constructor(e, n) {
      super(), (this.core = e), (this.logger = n), Oz(this, 'records', new Map())
    }
  },
  Dz = class {
    constructor(e, n) {
      ;(this.logger = e), (this.core = n)
    }
  },
  Mz = class extends xu {
    constructor(e, n) {
      super(), (this.relayer = e), (this.logger = n)
    }
  },
  Uz = class extends xu {
    constructor(e) {
      super()
    }
  },
  Lz = class {
    constructor(e, n, r, s) {
      ;(this.core = e), (this.logger = n), (this.name = r)
    }
  },
  $z = class extends xu {
    constructor(e, n) {
      super(), (this.relayer = e), (this.logger = n)
    }
  },
  Fz = class extends xu {
    constructor(e, n) {
      super(), (this.core = e), (this.logger = n)
    }
  },
  jz = class {
    constructor(e, n, r) {
      ;(this.core = e), (this.logger = n), (this.store = r)
    }
  },
  Hz = class {
    constructor(e, n) {
      ;(this.projectId = e), (this.logger = n)
    }
  },
  qz = class {
    constructor(e, n, r) {
      ;(this.core = e), (this.logger = n), (this.telemetryEnabled = r)
    }
  }
var zz = Object.defineProperty,
  Wz = (t, e, n) =>
    e in t ? zz(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  FS = (t, e, n) => Wz(t, typeof e != 'symbol' ? e + '' : e, n)
let Kz = class {
    constructor(e) {
      ;(this.opts = e), FS(this, 'protocol', 'wc'), FS(this, 'version', 2)
    }
  },
  Vz = class {
    constructor(e) {
      this.client = e
    }
  }
function Gz(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function ck(t, ...e) {
  if (!Gz(t)) throw new Error('Uint8Array expected')
  if (e.length > 0 && !e.includes(t.length))
    throw new Error('Uint8Array expected of length ' + e + ', got length=' + t.length)
}
function jS(t, e = !0) {
  if (t.destroyed) throw new Error('Hash instance has been destroyed')
  if (e && t.finished) throw new Error('Hash#digest() has already been called')
}
function Qz(t, e) {
  ck(t)
  const n = e.outputLen
  if (t.length < n) throw new Error('digestInto() expects output buffer of length at least ' + n)
}
const Fu = typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Rw = t =>
  new DataView(t.buffer, t.byteOffset, t.byteLength)
function Zz(t) {
  if (typeof t != 'string') throw new Error('utf8ToBytes expected string, got ' + typeof t)
  return new Uint8Array(new TextEncoder().encode(t))
}
function uk(t) {
  return typeof t == 'string' && (t = Zz(t)), ck(t), t
}
let Yz = class {
  clone() {
    return this._cloneInto()
  }
}
function Jz(t) {
  const e = r => t().update(uk(r)).digest(),
    n = t()
  return (e.outputLen = n.outputLen), (e.blockLen = n.blockLen), (e.create = () => t()), e
}
function lk(t = 32) {
  if (Fu && typeof Fu.getRandomValues == 'function') return Fu.getRandomValues(new Uint8Array(t))
  if (Fu && typeof Fu.randomBytes == 'function') return Fu.randomBytes(t)
  throw new Error('crypto.getRandomValues must be defined')
}
function Xz(t, e, n, r) {
  if (typeof t.setBigUint64 == 'function') return t.setBigUint64(e, n, r)
  const s = BigInt(32),
    i = BigInt(4294967295),
    o = Number((n >> s) & i),
    a = Number(n & i),
    c = r ? 4 : 0,
    u = r ? 0 : 4
  t.setUint32(e + c, o, r), t.setUint32(e + u, a, r)
}
let eW = class extends Yz {
  constructor(e, n, r, s) {
    super(),
      (this.blockLen = e),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = s),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(e)),
      (this.view = Rw(this.buffer))
  }
  update(e) {
    jS(this)
    const { view: n, buffer: r, blockLen: s } = this
    e = uk(e)
    const i = e.length
    for (let o = 0; o < i; ) {
      const a = Math.min(s - this.pos, i - o)
      if (a === s) {
        const c = Rw(e)
        for (; s <= i - o; o += s) this.process(c, o)
        continue
      }
      r.set(e.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === s && (this.process(n, 0), (this.pos = 0))
    }
    return (this.length += e.length), this.roundClean(), this
  }
  digestInto(e) {
    jS(this), Qz(e, this), (this.finished = !0)
    const { buffer: n, view: r, blockLen: s, isLE: i } = this
    let { pos: o } = this
    ;(n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > s - o && (this.process(r, 0), (o = 0))
    for (let d = o; d < s; d++) n[d] = 0
    Xz(r, s - 8, BigInt(this.length * 8), i), this.process(r, 0)
    const a = Rw(e),
      c = this.outputLen
    if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit')
    const u = c / 4,
      l = this.get()
    if (u > l.length) throw new Error('_sha2: outputLen bigger than state')
    for (let d = 0; d < u; d++) a.setUint32(4 * d, l[d], i)
  }
  digest() {
    const { buffer: e, outputLen: n } = this
    this.digestInto(e)
    const r = e.slice(0, n)
    return this.destroy(), r
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get())
    const { blockLen: n, buffer: r, length: s, finished: i, destroyed: o, pos: a } = this
    return (
      (e.length = s), (e.pos = a), (e.finished = i), (e.destroyed = o), s % n && e.buffer.set(r), e
    )
  }
}
const ng = BigInt(2 ** 32 - 1),
  Y1 = BigInt(32)
function dk(t, e = !1) {
  return e
    ? { h: Number(t & ng), l: Number((t >> Y1) & ng) }
    : { h: Number((t >> Y1) & ng) | 0, l: Number(t & ng) | 0 }
}
function tW(t, e = !1) {
  let n = new Uint32Array(t.length),
    r = new Uint32Array(t.length)
  for (let s = 0; s < t.length; s++) {
    const { h: i, l: o } = dk(t[s], e)
    ;[n[s], r[s]] = [i, o]
  }
  return [n, r]
}
const nW = (t, e) => (BigInt(t >>> 0) << Y1) | BigInt(e >>> 0),
  rW = (t, e, n) => t >>> n,
  sW = (t, e, n) => (t << (32 - n)) | (e >>> n),
  iW = (t, e, n) => (t >>> n) | (e << (32 - n)),
  oW = (t, e, n) => (t << (32 - n)) | (e >>> n),
  aW = (t, e, n) => (t << (64 - n)) | (e >>> (n - 32)),
  cW = (t, e, n) => (t >>> (n - 32)) | (e << (64 - n)),
  uW = (t, e) => e,
  lW = (t, e) => t,
  dW = (t, e, n) => (t << n) | (e >>> (32 - n)),
  hW = (t, e, n) => (e << n) | (t >>> (32 - n)),
  fW = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
  pW = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n))
function gW(t, e, n, r) {
  const s = (e >>> 0) + (r >>> 0)
  return { h: (t + n + ((s / 2 ** 32) | 0)) | 0, l: s | 0 }
}
const mW = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),
  yW = (t, e, n, r) => (e + n + r + ((t / 2 ** 32) | 0)) | 0,
  wW = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
  bW = (t, e, n, r, s) => (e + n + r + s + ((t / 2 ** 32) | 0)) | 0,
  vW = (t, e, n, r, s) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0),
  EW = (t, e, n, r, s, i) => (e + n + r + s + i + ((t / 2 ** 32) | 0)) | 0,
  Ot = {
    fromBig: dk,
    split: tW,
    toBig: nW,
    shrSH: rW,
    shrSL: sW,
    rotrSH: iW,
    rotrSL: oW,
    rotrBH: aW,
    rotrBL: cW,
    rotr32H: uW,
    rotr32L: lW,
    rotlSH: dW,
    rotlSL: hW,
    rotlBH: fW,
    rotlBL: pW,
    add: gW,
    add3L: mW,
    add3H: yW,
    add4L: wW,
    add4H: bW,
    add5H: EW,
    add5L: vW
  },
  [AW, _W] = Ot.split(
    [
      '0x428a2f98d728ae22',
      '0x7137449123ef65cd',
      '0xb5c0fbcfec4d3b2f',
      '0xe9b5dba58189dbbc',
      '0x3956c25bf348b538',
      '0x59f111f1b605d019',
      '0x923f82a4af194f9b',
      '0xab1c5ed5da6d8118',
      '0xd807aa98a3030242',
      '0x12835b0145706fbe',
      '0x243185be4ee4b28c',
      '0x550c7dc3d5ffb4e2',
      '0x72be5d74f27b896f',
      '0x80deb1fe3b1696b1',
      '0x9bdc06a725c71235',
      '0xc19bf174cf692694',
      '0xe49b69c19ef14ad2',
      '0xefbe4786384f25e3',
      '0x0fc19dc68b8cd5b5',
      '0x240ca1cc77ac9c65',
      '0x2de92c6f592b0275',
      '0x4a7484aa6ea6e483',
      '0x5cb0a9dcbd41fbd4',
      '0x76f988da831153b5',
      '0x983e5152ee66dfab',
      '0xa831c66d2db43210',
      '0xb00327c898fb213f',
      '0xbf597fc7beef0ee4',
      '0xc6e00bf33da88fc2',
      '0xd5a79147930aa725',
      '0x06ca6351e003826f',
      '0x142929670a0e6e70',
      '0x27b70a8546d22ffc',
      '0x2e1b21385c26c926',
      '0x4d2c6dfc5ac42aed',
      '0x53380d139d95b3df',
      '0x650a73548baf63de',
      '0x766a0abb3c77b2a8',
      '0x81c2c92e47edaee6',
      '0x92722c851482353b',
      '0xa2bfe8a14cf10364',
      '0xa81a664bbc423001',
      '0xc24b8b70d0f89791',
      '0xc76c51a30654be30',
      '0xd192e819d6ef5218',
      '0xd69906245565a910',
      '0xf40e35855771202a',
      '0x106aa07032bbd1b8',
      '0x19a4c116b8d2d0c8',
      '0x1e376c085141ab53',
      '0x2748774cdf8eeb99',
      '0x34b0bcb5e19b48a8',
      '0x391c0cb3c5c95a63',
      '0x4ed8aa4ae3418acb',
      '0x5b9cca4f7763e373',
      '0x682e6ff3d6b2b8a3',
      '0x748f82ee5defb2fc',
      '0x78a5636f43172f60',
      '0x84c87814a1f0ab72',
      '0x8cc702081a6439ec',
      '0x90befffa23631e28',
      '0xa4506cebde82bde9',
      '0xbef9a3f7b2c67915',
      '0xc67178f2e372532b',
      '0xca273eceea26619c',
      '0xd186b8c721c0c207',
      '0xeada7dd6cde0eb1e',
      '0xf57d4f7fee6ed178',
      '0x06f067aa72176fba',
      '0x0a637dc5a2c898a6',
      '0x113f9804bef90dae',
      '0x1b710b35131c471b',
      '0x28db77f523047d84',
      '0x32caab7b40c72493',
      '0x3c9ebe0a15c9bebc',
      '0x431d67c49c100d4c',
      '0x4cc5d4becb3e42b6',
      '0x597f299cfc657e2a',
      '0x5fcb6fab3ad6faec',
      '0x6c44198c4a475817'
    ].map(t => BigInt(t))
  ),
  ca = new Uint32Array(80),
  ua = new Uint32Array(80)
let CW = class extends eW {
  constructor() {
    super(128, 64, 16, !1),
      (this.Ah = 1779033703),
      (this.Al = -205731576),
      (this.Bh = -1150833019),
      (this.Bl = -2067093701),
      (this.Ch = 1013904242),
      (this.Cl = -23791573),
      (this.Dh = -1521486534),
      (this.Dl = 1595750129),
      (this.Eh = 1359893119),
      (this.El = -1377402159),
      (this.Fh = -1694144372),
      (this.Fl = 725511199),
      (this.Gh = 528734635),
      (this.Gl = -79577749),
      (this.Hh = 1541459225),
      (this.Hl = 327033209)
  }
  get() {
    const {
      Ah: e,
      Al: n,
      Bh: r,
      Bl: s,
      Ch: i,
      Cl: o,
      Dh: a,
      Dl: c,
      Eh: u,
      El: l,
      Fh: d,
      Fl: h,
      Gh: p,
      Gl: y,
      Hh: m,
      Hl: b
    } = this
    return [e, n, r, s, i, o, a, c, u, l, d, h, p, y, m, b]
  }
  set(e, n, r, s, i, o, a, c, u, l, d, h, p, y, m, b) {
    ;(this.Ah = e | 0),
      (this.Al = n | 0),
      (this.Bh = r | 0),
      (this.Bl = s | 0),
      (this.Ch = i | 0),
      (this.Cl = o | 0),
      (this.Dh = a | 0),
      (this.Dl = c | 0),
      (this.Eh = u | 0),
      (this.El = l | 0),
      (this.Fh = d | 0),
      (this.Fl = h | 0),
      (this.Gh = p | 0),
      (this.Gl = y | 0),
      (this.Hh = m | 0),
      (this.Hl = b | 0)
  }
  process(e, n) {
    for (let _ = 0; _ < 16; _++, n += 4) (ca[_] = e.getUint32(n)), (ua[_] = e.getUint32((n += 4)))
    for (let _ = 16; _ < 80; _++) {
      const R = ca[_ - 15] | 0,
        N = ua[_ - 15] | 0,
        T = Ot.rotrSH(R, N, 1) ^ Ot.rotrSH(R, N, 8) ^ Ot.shrSH(R, N, 7),
        M = Ot.rotrSL(R, N, 1) ^ Ot.rotrSL(R, N, 8) ^ Ot.shrSL(R, N, 7),
        H = ca[_ - 2] | 0,
        B = ua[_ - 2] | 0,
        $ = Ot.rotrSH(H, B, 19) ^ Ot.rotrBH(H, B, 61) ^ Ot.shrSH(H, B, 6),
        D = Ot.rotrSL(H, B, 19) ^ Ot.rotrBL(H, B, 61) ^ Ot.shrSL(H, B, 6),
        W = Ot.add4L(M, D, ua[_ - 7], ua[_ - 16]),
        U = Ot.add4H(W, T, $, ca[_ - 7], ca[_ - 16])
      ;(ca[_] = U | 0), (ua[_] = W | 0)
    }
    let {
      Ah: r,
      Al: s,
      Bh: i,
      Bl: o,
      Ch: a,
      Cl: c,
      Dh: u,
      Dl: l,
      Eh: d,
      El: h,
      Fh: p,
      Fl: y,
      Gh: m,
      Gl: b,
      Hh: I,
      Hl: x
    } = this
    for (let _ = 0; _ < 80; _++) {
      const R = Ot.rotrSH(d, h, 14) ^ Ot.rotrSH(d, h, 18) ^ Ot.rotrBH(d, h, 41),
        N = Ot.rotrSL(d, h, 14) ^ Ot.rotrSL(d, h, 18) ^ Ot.rotrBL(d, h, 41),
        T = (d & p) ^ (~d & m),
        M = (h & y) ^ (~h & b),
        H = Ot.add5L(x, N, M, _W[_], ua[_]),
        B = Ot.add5H(H, I, R, T, AW[_], ca[_]),
        $ = H | 0,
        D = Ot.rotrSH(r, s, 28) ^ Ot.rotrBH(r, s, 34) ^ Ot.rotrBH(r, s, 39),
        W = Ot.rotrSL(r, s, 28) ^ Ot.rotrBL(r, s, 34) ^ Ot.rotrBL(r, s, 39),
        U = (r & i) ^ (r & a) ^ (i & a),
        w = (s & o) ^ (s & c) ^ (o & c)
      ;(I = m | 0),
        (x = b | 0),
        (m = p | 0),
        (b = y | 0),
        (p = d | 0),
        (y = h | 0),
        ({ h: d, l: h } = Ot.add(u | 0, l | 0, B | 0, $ | 0)),
        (u = a | 0),
        (l = c | 0),
        (a = i | 0),
        (c = o | 0),
        (i = r | 0),
        (o = s | 0)
      const v = Ot.add3L($, W, w)
      ;(r = Ot.add3H(v, B, D, U)), (s = v | 0)
    }
    ;({ h: r, l: s } = Ot.add(this.Ah | 0, this.Al | 0, r | 0, s | 0)),
      ({ h: i, l: o } = Ot.add(this.Bh | 0, this.Bl | 0, i | 0, o | 0)),
      ({ h: a, l: c } = Ot.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0)),
      ({ h: u, l } = Ot.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0)),
      ({ h: d, l: h } = Ot.add(this.Eh | 0, this.El | 0, d | 0, h | 0)),
      ({ h: p, l: y } = Ot.add(this.Fh | 0, this.Fl | 0, p | 0, y | 0)),
      ({ h: m, l: b } = Ot.add(this.Gh | 0, this.Gl | 0, m | 0, b | 0)),
      ({ h: I, l: x } = Ot.add(this.Hh | 0, this.Hl | 0, I | 0, x | 0)),
      this.set(r, s, i, o, a, c, u, l, d, h, p, y, m, b, I, x)
  }
  roundClean() {
    ca.fill(0), ua.fill(0)
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  }
}
const SW = Jz(() => new CW())
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const bA = BigInt(0),
  hk = BigInt(1),
  IW = BigInt(2)
function vA(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function EA(t) {
  if (!vA(t)) throw new Error('Uint8Array expected')
}
function kw(t, e) {
  if (typeof e != 'boolean') throw new Error(t + ' boolean expected, got ' + e)
}
const xW = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, '0'))
function AA(t) {
  EA(t)
  let e = ''
  for (let n = 0; n < t.length; n++) e += xW[t[n]]
  return e
}
function fk(t) {
  if (typeof t != 'string') throw new Error('hex string expected, got ' + typeof t)
  return t === '' ? bA : BigInt('0x' + t)
}
const Co = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }
function HS(t) {
  if (t >= Co._0 && t <= Co._9) return t - Co._0
  if (t >= Co.A && t <= Co.F) return t - (Co.A - 10)
  if (t >= Co.a && t <= Co.f) return t - (Co.a - 10)
}
function pk(t) {
  if (typeof t != 'string') throw new Error('hex string expected, got ' + typeof t)
  const e = t.length,
    n = e / 2
  if (e % 2) throw new Error('hex string expected, got unpadded hex of length ' + e)
  const r = new Uint8Array(n)
  for (let s = 0, i = 0; s < n; s++, i += 2) {
    const o = HS(t.charCodeAt(i)),
      a = HS(t.charCodeAt(i + 1))
    if (o === void 0 || a === void 0) {
      const c = t[i] + t[i + 1]
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + i)
    }
    r[s] = o * 16 + a
  }
  return r
}
function TW(t) {
  return fk(AA(t))
}
function Og(t) {
  return EA(t), fk(AA(Uint8Array.from(t).reverse()))
}
function gk(t, e) {
  return pk(t.toString(16).padStart(e * 2, '0'))
}
function J1(t, e) {
  return gk(t, e).reverse()
}
function So(t, e, n) {
  let r
  if (typeof e == 'string')
    try {
      r = pk(e)
    } catch (i) {
      throw new Error(t + ' must be hex string or Uint8Array, cause: ' + i)
    }
  else if (vA(e)) r = Uint8Array.from(e)
  else throw new Error(t + ' must be hex string or Uint8Array')
  const s = r.length
  if (typeof n == 'number' && s !== n)
    throw new Error(t + ' of length ' + n + ' expected, got ' + s)
  return r
}
function qS(...t) {
  let e = 0
  for (let r = 0; r < t.length; r++) {
    const s = t[r]
    EA(s), (e += s.length)
  }
  const n = new Uint8Array(e)
  for (let r = 0, s = 0; r < t.length; r++) {
    const i = t[r]
    n.set(i, s), (s += i.length)
  }
  return n
}
const Ow = t => typeof t == 'bigint' && bA <= t
function NW(t, e, n) {
  return Ow(t) && Ow(e) && Ow(n) && e <= t && t < n
}
function Gd(t, e, n, r) {
  if (!NW(e, n, r))
    throw new Error('expected valid ' + t + ': ' + n + ' <= n < ' + r + ', got ' + e)
}
function PW(t) {
  let e
  for (e = 0; t > bA; t >>= hk, e += 1);
  return e
}
const RW = t => (IW << BigInt(t - 1)) - hk,
  kW = {
    bigint: t => typeof t == 'bigint',
    function: t => typeof t == 'function',
    boolean: t => typeof t == 'boolean',
    string: t => typeof t == 'string',
    stringOrUint8Array: t => typeof t == 'string' || vA(t),
    isSafeInteger: t => Number.isSafeInteger(t),
    array: t => Array.isArray(t),
    field: (t, e) => e.Fp.isValid(t),
    hash: t => typeof t == 'function' && Number.isSafeInteger(t.outputLen)
  }
function _A(t, e, n = {}) {
  const r = (s, i, o) => {
    const a = kW[i]
    if (typeof a != 'function') throw new Error('invalid validator function')
    const c = t[s]
    if (!(o && c === void 0) && !a(c, t))
      throw new Error('param ' + String(s) + ' is invalid. Expected ' + i + ', got ' + c)
  }
  for (const [s, i] of Object.entries(e)) r(s, i, !1)
  for (const [s, i] of Object.entries(n)) r(s, i, !0)
  return t
}
function zS(t) {
  const e = new WeakMap()
  return (n, ...r) => {
    const s = e.get(n)
    if (s !== void 0) return s
    const i = t(n, ...r)
    return e.set(n, i), i
  }
}
const mr = BigInt(0),
  zn = BigInt(1),
  Pc = BigInt(2),
  OW = BigInt(3),
  X1 = BigInt(4),
  WS = BigInt(5),
  KS = BigInt(8)
function rr(t, e) {
  const n = t % e
  return n >= mr ? n : e + n
}
function BW(t, e, n) {
  if (e < mr) throw new Error('invalid exponent, negatives unsupported')
  if (n <= mr) throw new Error('invalid modulus')
  if (n === zn) return mr
  let r = zn
  for (; e > mr; ) e & zn && (r = (r * t) % n), (t = (t * t) % n), (e >>= zn)
  return r
}
function Li(t, e, n) {
  let r = t
  for (; e-- > mr; ) (r *= r), (r %= n)
  return r
}
function VS(t, e) {
  if (t === mr) throw new Error('invert: expected non-zero number')
  if (e <= mr) throw new Error('invert: expected positive modulus, got ' + e)
  let n = rr(t, e),
    r = e,
    s = mr,
    i = zn
  for (; n !== mr; ) {
    const o = r / n,
      a = r % n,
      c = s - i * o
    ;(r = n), (n = a), (s = i), (i = c)
  }
  if (r !== zn) throw new Error('invert: does not exist')
  return rr(s, e)
}
function DW(t) {
  const e = (t - zn) / Pc
  let n, r, s
  for (n = t - zn, r = 0; n % Pc === mr; n /= Pc, r++);
  for (s = Pc; s < t && BW(s, e, t) !== t - zn; s++)
    if (s > 1e3) throw new Error('Cannot find square root: likely non-prime P')
  if (r === 1) {
    const o = (t + zn) / X1
    return function (a, c) {
      const u = a.pow(c, o)
      if (!a.eql(a.sqr(u), c)) throw new Error('Cannot find square root')
      return u
    }
  }
  const i = (n + zn) / Pc
  return function (o, a) {
    if (o.pow(a, e) === o.neg(o.ONE)) throw new Error('Cannot find square root')
    let c = r,
      u = o.pow(o.mul(o.ONE, s), n),
      l = o.pow(a, i),
      d = o.pow(a, n)
    for (; !o.eql(d, o.ONE); ) {
      if (o.eql(d, o.ZERO)) return o.ZERO
      let h = 1
      for (let y = o.sqr(d); h < c && !o.eql(y, o.ONE); h++) y = o.sqr(y)
      const p = o.pow(u, zn << BigInt(c - h - 1))
      ;(u = o.sqr(p)), (l = o.mul(l, p)), (d = o.mul(d, u)), (c = h)
    }
    return l
  }
}
function MW(t) {
  if (t % X1 === OW) {
    const e = (t + zn) / X1
    return function (n, r) {
      const s = n.pow(r, e)
      if (!n.eql(n.sqr(s), r)) throw new Error('Cannot find square root')
      return s
    }
  }
  if (t % KS === WS) {
    const e = (t - WS) / KS
    return function (n, r) {
      const s = n.mul(r, Pc),
        i = n.pow(s, e),
        o = n.mul(r, i),
        a = n.mul(n.mul(o, Pc), i),
        c = n.mul(o, n.sub(a, n.ONE))
      if (!n.eql(n.sqr(c), r)) throw new Error('Cannot find square root')
      return c
    }
  }
  return DW(t)
}
const UW = (t, e) => (rr(t, e) & zn) === zn,
  LW = [
    'create',
    'isValid',
    'is0',
    'neg',
    'inv',
    'sqrt',
    'sqr',
    'eql',
    'add',
    'sub',
    'mul',
    'pow',
    'div',
    'addN',
    'subN',
    'mulN',
    'sqrN'
  ]
function $W(t) {
  const e = { ORDER: 'bigint', MASK: 'bigint', BYTES: 'isSafeInteger', BITS: 'isSafeInteger' },
    n = LW.reduce((r, s) => ((r[s] = 'function'), r), e)
  return _A(t, n)
}
function FW(t, e, n) {
  if (n < mr) throw new Error('invalid exponent, negatives unsupported')
  if (n === mr) return t.ONE
  if (n === zn) return e
  let r = t.ONE,
    s = e
  for (; n > mr; ) n & zn && (r = t.mul(r, s)), (s = t.sqr(s)), (n >>= zn)
  return r
}
function jW(t, e) {
  const n = new Array(e.length),
    r = e.reduce((i, o, a) => (t.is0(o) ? i : ((n[a] = i), t.mul(i, o))), t.ONE),
    s = t.inv(r)
  return e.reduceRight((i, o, a) => (t.is0(o) ? i : ((n[a] = t.mul(i, n[a])), t.mul(i, o))), s), n
}
function mk(t, e) {
  const n = e !== void 0 ? e : t.toString(2).length,
    r = Math.ceil(n / 8)
  return { nBitLength: n, nByteLength: r }
}
function yk(t, e, n = !1, r = {}) {
  if (t <= mr) throw new Error('invalid field: expected ORDER > 0, got ' + t)
  const { nBitLength: s, nByteLength: i } = mk(t, e)
  if (i > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes')
  let o
  const a = Object.freeze({
    ORDER: t,
    isLE: n,
    BITS: s,
    BYTES: i,
    MASK: RW(s),
    ZERO: mr,
    ONE: zn,
    create: c => rr(c, t),
    isValid: c => {
      if (typeof c != 'bigint')
        throw new Error('invalid field element: expected bigint, got ' + typeof c)
      return mr <= c && c < t
    },
    is0: c => c === mr,
    isOdd: c => (c & zn) === zn,
    neg: c => rr(-c, t),
    eql: (c, u) => c === u,
    sqr: c => rr(c * c, t),
    add: (c, u) => rr(c + u, t),
    sub: (c, u) => rr(c - u, t),
    mul: (c, u) => rr(c * u, t),
    pow: (c, u) => FW(a, c, u),
    div: (c, u) => rr(c * VS(u, t), t),
    sqrN: c => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: c => VS(c, t),
    sqrt: r.sqrt || (c => (o || (o = MW(t)), o(a, c))),
    invertBatch: c => jW(a, c),
    cmov: (c, u, l) => (l ? u : c),
    toBytes: c => (n ? J1(c, i) : gk(c, i)),
    fromBytes: c => {
      if (c.length !== i)
        throw new Error('Field.fromBytes: expected ' + i + ' bytes, got ' + c.length)
      return n ? Og(c) : TW(c)
    }
  })
  return Object.freeze(a)
}
const GS = BigInt(0),
  rg = BigInt(1)
function Bw(t, e) {
  const n = e.negate()
  return t ? n : e
}
function wk(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e)
    throw new Error('invalid window size, expected [1..' + e + '], got W=' + t)
}
function Dw(t, e) {
  wk(t, e)
  const n = Math.ceil(e / t) + 1,
    r = 2 ** (t - 1)
  return { windows: n, windowSize: r }
}
function HW(t, e) {
  if (!Array.isArray(t)) throw new Error('array expected')
  t.forEach((n, r) => {
    if (!(n instanceof e)) throw new Error('invalid point at index ' + r)
  })
}
function qW(t, e) {
  if (!Array.isArray(t)) throw new Error('array of scalars expected')
  t.forEach((n, r) => {
    if (!e.isValid(n)) throw new Error('invalid scalar at index ' + r)
  })
}
const Mw = new WeakMap(),
  bk = new WeakMap()
function Uw(t) {
  return bk.get(t) || 1
}
function zW(t, e) {
  return {
    constTimeNegate: Bw,
    hasPrecomputes(n) {
      return Uw(n) !== 1
    },
    unsafeLadder(n, r, s = t.ZERO) {
      let i = n
      for (; r > GS; ) r & rg && (s = s.add(i)), (i = i.double()), (r >>= rg)
      return s
    },
    precomputeWindow(n, r) {
      const { windows: s, windowSize: i } = Dw(r, e),
        o = []
      let a = n,
        c = a
      for (let u = 0; u < s; u++) {
        ;(c = a), o.push(c)
        for (let l = 1; l < i; l++) (c = c.add(a)), o.push(c)
        a = c.double()
      }
      return o
    },
    wNAF(n, r, s) {
      const { windows: i, windowSize: o } = Dw(n, e)
      let a = t.ZERO,
        c = t.BASE
      const u = BigInt(2 ** n - 1),
        l = 2 ** n,
        d = BigInt(n)
      for (let h = 0; h < i; h++) {
        const p = h * o
        let y = Number(s & u)
        ;(s >>= d), y > o && ((y -= l), (s += rg))
        const m = p,
          b = p + Math.abs(y) - 1,
          I = h % 2 !== 0,
          x = y < 0
        y === 0 ? (c = c.add(Bw(I, r[m]))) : (a = a.add(Bw(x, r[b])))
      }
      return { p: a, f: c }
    },
    wNAFUnsafe(n, r, s, i = t.ZERO) {
      const { windows: o, windowSize: a } = Dw(n, e),
        c = BigInt(2 ** n - 1),
        u = 2 ** n,
        l = BigInt(n)
      for (let d = 0; d < o; d++) {
        const h = d * a
        if (s === GS) break
        let p = Number(s & c)
        if (((s >>= l), p > a && ((p -= u), (s += rg)), p === 0)) continue
        let y = r[h + Math.abs(p) - 1]
        p < 0 && (y = y.negate()), (i = i.add(y))
      }
      return i
    },
    getPrecomputes(n, r, s) {
      let i = Mw.get(r)
      return i || ((i = this.precomputeWindow(r, n)), n !== 1 && Mw.set(r, s(i))), i
    },
    wNAFCached(n, r, s) {
      const i = Uw(n)
      return this.wNAF(i, this.getPrecomputes(i, n, s), r)
    },
    wNAFCachedUnsafe(n, r, s, i) {
      const o = Uw(n)
      return o === 1
        ? this.unsafeLadder(n, r, i)
        : this.wNAFUnsafe(o, this.getPrecomputes(o, n, s), r, i)
    },
    setWindowSize(n, r) {
      wk(r, e), bk.set(n, r), Mw.delete(n)
    }
  }
}
function WW(t, e, n, r) {
  if ((HW(n, t), qW(r, e), n.length !== r.length))
    throw new Error('arrays of points and scalars must have equal length')
  const s = t.ZERO,
    i = PW(BigInt(n.length)),
    o = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1,
    a = (1 << o) - 1,
    c = new Array(a + 1).fill(s),
    u = Math.floor((e.BITS - 1) / o) * o
  let l = s
  for (let d = u; d >= 0; d -= o) {
    c.fill(s)
    for (let p = 0; p < r.length; p++) {
      const y = r[p],
        m = Number((y >> BigInt(d)) & BigInt(a))
      c[m] = c[m].add(n[p])
    }
    let h = s
    for (let p = c.length - 1, y = s; p > 0; p--) (y = y.add(c[p])), (h = h.add(y))
    if (((l = l.add(h)), d !== 0)) for (let p = 0; p < o; p++) l = l.double()
  }
  return l
}
function KW(t) {
  return (
    $W(t.Fp),
    _A(
      t,
      { n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field' },
      { nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger' }
    ),
    Object.freeze({ ...mk(t.n, t.nBitLength), ...t, p: t.Fp.ORDER })
  )
}
const fi = BigInt(0),
  hs = BigInt(1),
  sg = BigInt(2),
  VW = BigInt(8),
  GW = { zip215: !0 }
function QW(t) {
  const e = KW(t)
  return (
    _A(
      t,
      { hash: 'function', a: 'bigint', d: 'bigint', randomBytes: 'function' },
      {
        adjustScalarBytes: 'function',
        domain: 'function',
        uvRatio: 'function',
        mapToCurve: 'function'
      }
    ),
    Object.freeze({ ...e })
  )
}
function ZW(t) {
  const e = QW(t),
    { Fp: n, n: r, prehash: s, hash: i, randomBytes: o, nByteLength: a, h: c } = e,
    u = sg << (BigInt(a * 8) - hs),
    l = n.create,
    d = yk(e.n, e.nBitLength),
    h =
      e.uvRatio ||
      ((v, A) => {
        try {
          return { isValid: !0, value: n.sqrt(v * n.inv(A)) }
        } catch {
          return { isValid: !1, value: fi }
        }
      }),
    p = e.adjustScalarBytes || (v => v),
    y =
      e.domain ||
      ((v, A, P) => {
        if ((kw('phflag', P), A.length || P)) throw new Error('Contexts/pre-hash are not supported')
        return v
      })
  function m(v, A) {
    Gd('coordinate ' + v, A, fi, u)
  }
  function b(v) {
    if (!(v instanceof _)) throw new Error('ExtendedPoint expected')
  }
  const I = zS((v, A) => {
      const { ex: P, ey: O, ez: F } = v,
        z = v.is0()
      A == null && (A = z ? VW : n.inv(F))
      const j = l(P * A),
        E = l(O * A),
        C = l(F * A)
      if (z) return { x: fi, y: hs }
      if (C !== hs) throw new Error('invZ was invalid')
      return { x: j, y: E }
    }),
    x = zS(v => {
      const { a: A, d: P } = e
      if (v.is0()) throw new Error('bad point: ZERO')
      const { ex: O, ey: F, ez: z, et: j } = v,
        E = l(O * O),
        C = l(F * F),
        L = l(z * z),
        K = l(L * L),
        ee = l(E * A),
        oe = l(L * l(ee + C)),
        fe = l(K + l(P * l(E * C)))
      if (oe !== fe) throw new Error('bad point: equation left != right (1)')
      const ve = l(O * F),
        tt = l(z * j)
      if (ve !== tt) throw new Error('bad point: equation left != right (2)')
      return !0
    })
  class _ {
    constructor(A, P, O, F) {
      ;(this.ex = A),
        (this.ey = P),
        (this.ez = O),
        (this.et = F),
        m('x', A),
        m('y', P),
        m('z', O),
        m('t', F),
        Object.freeze(this)
    }
    get x() {
      return this.toAffine().x
    }
    get y() {
      return this.toAffine().y
    }
    static fromAffine(A) {
      if (A instanceof _) throw new Error('extended point not allowed')
      const { x: P, y: O } = A || {}
      return m('x', P), m('y', O), new _(P, O, hs, l(P * O))
    }
    static normalizeZ(A) {
      const P = n.invertBatch(A.map(O => O.ez))
      return A.map((O, F) => O.toAffine(P[F])).map(_.fromAffine)
    }
    static msm(A, P) {
      return WW(_, d, A, P)
    }
    _setWindowSize(A) {
      T.setWindowSize(this, A)
    }
    assertValidity() {
      x(this)
    }
    equals(A) {
      b(A)
      const { ex: P, ey: O, ez: F } = this,
        { ex: z, ey: j, ez: E } = A,
        C = l(P * E),
        L = l(z * F),
        K = l(O * E),
        ee = l(j * F)
      return C === L && K === ee
    }
    is0() {
      return this.equals(_.ZERO)
    }
    negate() {
      return new _(l(-this.ex), this.ey, this.ez, l(-this.et))
    }
    double() {
      const { a: A } = e,
        { ex: P, ey: O, ez: F } = this,
        z = l(P * P),
        j = l(O * O),
        E = l(sg * l(F * F)),
        C = l(A * z),
        L = P + O,
        K = l(l(L * L) - z - j),
        ee = C + j,
        oe = ee - E,
        fe = C - j,
        ve = l(K * oe),
        tt = l(ee * fe),
        Ge = l(K * fe),
        nt = l(oe * ee)
      return new _(ve, tt, nt, Ge)
    }
    add(A) {
      b(A)
      const { a: P, d: O } = e,
        { ex: F, ey: z, ez: j, et: E } = this,
        { ex: C, ey: L, ez: K, et: ee } = A
      if (P === BigInt(-1)) {
        const Te = l((z - F) * (L + C)),
          we = l((z + F) * (L - C)),
          ge = l(we - Te)
        if (ge === fi) return this.double()
        const he = l(j * sg * ee),
          Ne = l(E * sg * K),
          _e = Ne + he,
          Be = we + Te,
          $e = Ne - he,
          S = l(_e * ge),
          f = l(Be * $e),
          g = l(_e * $e),
          k = l(ge * Be)
        return new _(S, f, k, g)
      }
      const oe = l(F * C),
        fe = l(z * L),
        ve = l(E * O * ee),
        tt = l(j * K),
        Ge = l((F + z) * (C + L) - oe - fe),
        nt = tt - ve,
        Z = tt + ve,
        X = l(fe - P * oe),
        ie = l(Ge * nt),
        be = l(Z * X),
        ue = l(Ge * X),
        de = l(nt * Z)
      return new _(ie, be, de, ue)
    }
    subtract(A) {
      return this.add(A.negate())
    }
    wNAF(A) {
      return T.wNAFCached(this, A, _.normalizeZ)
    }
    multiply(A) {
      const P = A
      Gd('scalar', P, hs, r)
      const { p: O, f: F } = this.wNAF(P)
      return _.normalizeZ([O, F])[0]
    }
    multiplyUnsafe(A, P = _.ZERO) {
      const O = A
      return (
        Gd('scalar', O, fi, r),
        O === fi ? N : this.is0() || O === hs ? this : T.wNAFCachedUnsafe(this, O, _.normalizeZ, P)
      )
    }
    isSmallOrder() {
      return this.multiplyUnsafe(c).is0()
    }
    isTorsionFree() {
      return T.unsafeLadder(this, r).is0()
    }
    toAffine(A) {
      return I(this, A)
    }
    clearCofactor() {
      const { h: A } = e
      return A === hs ? this : this.multiplyUnsafe(A)
    }
    static fromHex(A, P = !1) {
      const { d: O, a: F } = e,
        z = n.BYTES
      ;(A = So('pointHex', A, z)), kw('zip215', P)
      const j = A.slice(),
        E = A[z - 1]
      j[z - 1] = E & -129
      const C = Og(j),
        L = P ? u : n.ORDER
      Gd('pointHex.y', C, fi, L)
      const K = l(C * C),
        ee = l(K - hs),
        oe = l(O * K - F)
      let { isValid: fe, value: ve } = h(ee, oe)
      if (!fe) throw new Error('Point.fromHex: invalid y coordinate')
      const tt = (ve & hs) === hs,
        Ge = (E & 128) !== 0
      if (!P && ve === fi && Ge) throw new Error('Point.fromHex: x=0 and x_0=1')
      return Ge !== tt && (ve = l(-ve)), _.fromAffine({ x: ve, y: C })
    }
    static fromPrivateKey(A) {
      return B(A).point
    }
    toRawBytes() {
      const { x: A, y: P } = this.toAffine(),
        O = J1(P, n.BYTES)
      return (O[O.length - 1] |= A & hs ? 128 : 0), O
    }
    toHex() {
      return AA(this.toRawBytes())
    }
  }
  ;(_.BASE = new _(e.Gx, e.Gy, hs, l(e.Gx * e.Gy))), (_.ZERO = new _(fi, hs, hs, fi))
  const { BASE: R, ZERO: N } = _,
    T = zW(_, a * 8)
  function M(v) {
    return rr(v, r)
  }
  function H(v) {
    return M(Og(v))
  }
  function B(v) {
    const A = n.BYTES
    v = So('private key', v, A)
    const P = So('hashed private key', i(v), 2 * A),
      O = p(P.slice(0, A)),
      F = P.slice(A, 2 * A),
      z = H(O),
      j = R.multiply(z),
      E = j.toRawBytes()
    return { head: O, prefix: F, scalar: z, point: j, pointBytes: E }
  }
  function $(v) {
    return B(v).pointBytes
  }
  function D(v = new Uint8Array(), ...A) {
    const P = qS(...A)
    return H(i(y(P, So('context', v), !!s)))
  }
  function W(v, A, P = {}) {
    ;(v = So('message', v)), s && (v = s(v))
    const { prefix: O, scalar: F, pointBytes: z } = B(A),
      j = D(P.context, O, v),
      E = R.multiply(j).toRawBytes(),
      C = D(P.context, E, z, v),
      L = M(j + C * F)
    Gd('signature.s', L, fi, r)
    const K = qS(E, J1(L, n.BYTES))
    return So('result', K, n.BYTES * 2)
  }
  const U = GW
  function w(v, A, P, O = U) {
    const { context: F, zip215: z } = O,
      j = n.BYTES
    ;(v = So('signature', v, 2 * j)),
      (A = So('message', A)),
      (P = So('publicKey', P, j)),
      z !== void 0 && kw('zip215', z),
      s && (A = s(A))
    const E = Og(v.slice(j, 2 * j))
    let C, L, K
    try {
      ;(C = _.fromHex(P, z)), (L = _.fromHex(v.slice(0, j), z)), (K = R.multiplyUnsafe(E))
    } catch {
      return !1
    }
    if (!z && C.isSmallOrder()) return !1
    const ee = D(F, L.toRawBytes(), C.toRawBytes(), A)
    return L.add(C.multiplyUnsafe(ee)).subtract(K).clearCofactor().equals(_.ZERO)
  }
  return (
    R._setWindowSize(8),
    {
      CURVE: e,
      getPublicKey: $,
      sign: W,
      verify: w,
      ExtendedPoint: _,
      utils: {
        getExtendedPublicKey: B,
        randomPrivateKey: () => o(n.BYTES),
        precompute(v = 8, A = _.BASE) {
          return A._setWindowSize(v), A.multiply(BigInt(3)), A
        }
      }
    }
  )
}
BigInt(0), BigInt(1)
const CA = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),
  QS = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752')
BigInt(0)
const YW = BigInt(1),
  ZS = BigInt(2)
BigInt(3)
const JW = BigInt(5),
  XW = BigInt(8)
function eK(t) {
  const e = BigInt(10),
    n = BigInt(20),
    r = BigInt(40),
    s = BigInt(80),
    i = CA,
    o = (((t * t) % i) * t) % i,
    a = (Li(o, ZS, i) * o) % i,
    c = (Li(a, YW, i) * t) % i,
    u = (Li(c, JW, i) * c) % i,
    l = (Li(u, e, i) * u) % i,
    d = (Li(l, n, i) * l) % i,
    h = (Li(d, r, i) * d) % i,
    p = (Li(h, s, i) * h) % i,
    y = (Li(p, s, i) * h) % i,
    m = (Li(y, e, i) * u) % i
  return { pow_p_5_8: (Li(m, ZS, i) * t) % i, b2: o }
}
function tK(t) {
  return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t
}
function nK(t, e) {
  const n = CA,
    r = rr(e * e * e, n),
    s = rr(r * r * e, n),
    i = eK(t * s).pow_p_5_8
  let o = rr(t * r * i, n)
  const a = rr(e * o * o, n),
    c = o,
    u = rr(o * QS, n),
    l = a === t,
    d = a === rr(-t, n),
    h = a === rr(-t * QS, n)
  return (
    l && (o = c), (d || h) && (o = u), UW(o, n) && (o = rr(-o, n)), { isValid: l || d, value: o }
  )
}
const rK = yk(CA, void 0, !0),
  sK = {
    a: BigInt(-1),
    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
    Fp: rK,
    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),
    h: XW,
    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),
    hash: SW,
    randomBytes: lk,
    adjustScalarBytes: tK,
    uvRatio: nK
  },
  vk = ZW(sK),
  iK = 'EdDSA',
  oK = 'JWT',
  bm = '.',
  O0 = 'base64url',
  Ek = 'utf8',
  Ak = 'utf8',
  aK = ':',
  cK = 'did',
  uK = 'key',
  YS = 'base58btc',
  lK = 'z',
  dK = 'K36',
  hK = 32
function SA(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t
}
function _k(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? SA(globalThis.Buffer.allocUnsafe(t))
    : new Uint8Array(t)
}
function Ck(t, e) {
  e || (e = t.reduce((s, i) => s + i.length, 0))
  const n = _k(e)
  let r = 0
  for (const s of t) n.set(s, r), (r += s.length)
  return SA(n)
}
function fK(t, e) {
  if (t.length >= 255) throw new TypeError('Alphabet too long')
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255
  for (var s = 0; s < t.length; s++) {
    var i = t.charAt(s),
      o = i.charCodeAt(0)
    if (n[o] !== 255) throw new TypeError(i + ' is ambiguous')
    n[o] = s
  }
  var a = t.length,
    c = t.charAt(0),
    u = Math.log(a) / Math.log(256),
    l = Math.log(256) / Math.log(a)
  function d(y) {
    if (
      (y instanceof Uint8Array ||
        (ArrayBuffer.isView(y)
          ? (y = new Uint8Array(y.buffer, y.byteOffset, y.byteLength))
          : Array.isArray(y) && (y = Uint8Array.from(y))),
      !(y instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (y.length === 0) return ''
    for (var m = 0, b = 0, I = 0, x = y.length; I !== x && y[I] === 0; ) I++, m++
    for (var _ = ((x - I) * l + 1) >>> 0, R = new Uint8Array(_); I !== x; ) {
      for (var N = y[I], T = 0, M = _ - 1; (N !== 0 || T < b) && M !== -1; M--, T++)
        (N += (256 * R[M]) >>> 0), (R[M] = N % a >>> 0), (N = (N / a) >>> 0)
      if (N !== 0) throw new Error('Non-zero carry')
      ;(b = T), I++
    }
    for (var H = _ - b; H !== _ && R[H] === 0; ) H++
    for (var B = c.repeat(m); H < _; ++H) B += t.charAt(R[H])
    return B
  }
  function h(y) {
    if (typeof y != 'string') throw new TypeError('Expected String')
    if (y.length === 0) return new Uint8Array()
    var m = 0
    if (y[m] !== ' ') {
      for (var b = 0, I = 0; y[m] === c; ) b++, m++
      for (var x = ((y.length - m) * u + 1) >>> 0, _ = new Uint8Array(x); y[m]; ) {
        var R = n[y.charCodeAt(m)]
        if (R === 255) return
        for (var N = 0, T = x - 1; (R !== 0 || N < I) && T !== -1; T--, N++)
          (R += (a * _[T]) >>> 0), (_[T] = R % 256 >>> 0), (R = (R / 256) >>> 0)
        if (R !== 0) throw new Error('Non-zero carry')
        ;(I = N), m++
      }
      if (y[m] !== ' ') {
        for (var M = x - I; M !== x && _[M] === 0; ) M++
        for (var H = new Uint8Array(b + (x - M)), B = b; M !== x; ) H[B++] = _[M++]
        return H
      }
    }
  }
  function p(y) {
    var m = h(y)
    if (m) return m
    throw new Error(`Non-${e} character`)
  }
  return { encode: d, decodeUnsafe: h, decode: p }
}
var pK = fK,
  gK = pK
const Sk = t => {
    if (t instanceof Uint8Array && t.constructor.name === 'Uint8Array') return t
    if (t instanceof ArrayBuffer) return new Uint8Array(t)
    if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
    throw new Error('Unknown type, must be binary type')
  },
  mK = t => new TextEncoder().encode(t),
  yK = t => new TextDecoder().decode(t)
let wK = class {
    constructor(e, n, r) {
      ;(this.name = e), (this.prefix = n), (this.baseEncode = r)
    }
    encode(e) {
      if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
      throw Error('Unknown type, must be binary type')
    }
  },
  bK = class {
    constructor(e, n, r) {
      if (((this.name = e), (this.prefix = n), n.codePointAt(0) === void 0))
        throw new Error('Invalid prefix character')
      ;(this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = r)
    }
    decode(e) {
      if (typeof e == 'string') {
        if (e.codePointAt(0) !== this.prefixCodePoint)
          throw Error(
            `Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`
          )
        return this.baseDecode(e.slice(this.prefix.length))
      } else throw Error('Can only multibase decode strings')
    }
    or(e) {
      return Ik(this, e)
    }
  },
  vK = class {
    constructor(e) {
      this.decoders = e
    }
    or(e) {
      return Ik(this, e)
    }
    decode(e) {
      const n = e[0],
        r = this.decoders[n]
      if (r) return r.decode(e)
      throw RangeError(
        `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
      )
    }
  }
const Ik = (t, e) =>
  new vK({ ...(t.decoders || { [t.prefix]: t }), ...(e.decoders || { [e.prefix]: e }) })
let EK = class {
  constructor(e, n, r, s) {
    ;(this.name = e),
      (this.prefix = n),
      (this.baseEncode = r),
      (this.baseDecode = s),
      (this.encoder = new wK(e, n, r)),
      (this.decoder = new bK(e, n, s))
  }
  encode(e) {
    return this.encoder.encode(e)
  }
  decode(e) {
    return this.decoder.decode(e)
  }
}
const B0 = ({ name: t, prefix: e, encode: n, decode: r }) => new EK(t, e, n, r),
  fp = ({ prefix: t, name: e, alphabet: n }) => {
    const { encode: r, decode: s } = gK(n, e)
    return B0({ prefix: t, name: e, encode: r, decode: i => Sk(s(i)) })
  },
  AK = (t, e, n, r) => {
    const s = {}
    for (let l = 0; l < e.length; ++l) s[e[l]] = l
    let i = t.length
    for (; t[i - 1] === '='; ) --i
    const o = new Uint8Array(((i * n) / 8) | 0)
    let a = 0,
      c = 0,
      u = 0
    for (let l = 0; l < i; ++l) {
      const d = s[t[l]]
      if (d === void 0) throw new SyntaxError(`Non-${r} character`)
      ;(c = (c << n) | d), (a += n), a >= 8 && ((a -= 8), (o[u++] = 255 & (c >> a)))
    }
    if (a >= n || 255 & (c << (8 - a))) throw new SyntaxError('Unexpected end of data')
    return o
  },
  _K = (t, e, n) => {
    const r = e[e.length - 1] === '=',
      s = (1 << n) - 1
    let i = '',
      o = 0,
      a = 0
    for (let c = 0; c < t.length; ++c)
      for (a = (a << 8) | t[c], o += 8; o > n; ) (o -= n), (i += e[s & (a >> o)])
    if ((o && (i += e[s & (a << (n - o))]), r)) for (; (i.length * n) & 7; ) i += '='
    return i
  },
  kr = ({ name: t, prefix: e, bitsPerChar: n, alphabet: r }) =>
    B0({
      prefix: e,
      name: t,
      encode(s) {
        return _K(s, r, n)
      },
      decode(s) {
        return AK(s, r, n, t)
      }
    }),
  CK = B0({ prefix: '\0', name: 'identity', encode: t => yK(t), decode: t => mK(t) })
var SK = Object.freeze({ __proto__: null, identity: CK })
const IK = kr({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 })
var xK = Object.freeze({ __proto__: null, base2: IK })
const TK = kr({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 })
var NK = Object.freeze({ __proto__: null, base8: TK })
const PK = fp({ prefix: '9', name: 'base10', alphabet: '0123456789' })
var RK = Object.freeze({ __proto__: null, base10: PK })
const kK = kr({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 }),
  OK = kr({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 })
var BK = Object.freeze({ __proto__: null, base16: kK, base16upper: OK })
const DK = kr({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
  }),
  MK = kr({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
  }),
  UK = kr({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
  }),
  LK = kr({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
  }),
  $K = kr({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
  }),
  FK = kr({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
  }),
  jK = kr({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
  }),
  HK = kr({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
  }),
  qK = kr({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
  })
var zK = Object.freeze({
  __proto__: null,
  base32: DK,
  base32upper: MK,
  base32pad: UK,
  base32padupper: LK,
  base32hex: $K,
  base32hexupper: FK,
  base32hexpad: jK,
  base32hexpadupper: HK,
  base32z: qK
})
const WK = fp({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' }),
  KK = fp({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' })
var VK = Object.freeze({ __proto__: null, base36: WK, base36upper: KK })
const GK = fp({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
  }),
  QK = fp({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
  })
var ZK = Object.freeze({ __proto__: null, base58btc: GK, base58flickr: QK })
const YK = kr({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
  }),
  JK = kr({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
  }),
  XK = kr({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
  }),
  eV = kr({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
  })
var tV = Object.freeze({
  __proto__: null,
  base64: YK,
  base64pad: JK,
  base64url: XK,
  base64urlpad: eV
})
const xk = Array.from(
    ''
  ),
  nV = xk.reduce((t, e, n) => ((t[n] = e), t), []),
  rV = xk.reduce((t, e, n) => ((t[e.codePointAt(0)] = n), t), [])
function sV(t) {
  return t.reduce((e, n) => ((e += nV[n]), e), '')
}
function iV(t) {
  const e = []
  for (const n of t) {
    const r = rV[n.codePointAt(0)]
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`)
    e.push(r)
  }
  return new Uint8Array(e)
}
const oV = B0({ prefix: '', name: 'base256emoji', encode: sV, decode: iV })
var aV = Object.freeze({ __proto__: null, base256emoji: oV }),
  cV = Tk,
  JS = 128,
  uV = -128,
  lV = Math.pow(2, 31)
function Tk(t, e, n) {
  ;(e = e || []), (n = n || 0)
  for (var r = n; t >= lV; ) (e[n++] = (t & 255) | JS), (t /= 128)
  for (; t & uV; ) (e[n++] = (t & 255) | JS), (t >>>= 7)
  return (e[n] = t | 0), (Tk.bytes = n - r + 1), e
}
var dV = ev,
  hV = 128,
  XS = 127
function ev(t, r) {
  var n = 0,
    r = r || 0,
    s = 0,
    i = r,
    o,
    a = t.length
  do {
    if (i >= a) throw ((ev.bytes = 0), new RangeError('Could not decode varint'))
    ;(o = t[i++]), (n += s < 28 ? (o & XS) << s : (o & XS) * Math.pow(2, s)), (s += 7)
  } while (o >= hV)
  return (ev.bytes = i - r), n
}
var fV = Math.pow(2, 7),
  pV = Math.pow(2, 14),
  gV = Math.pow(2, 21),
  mV = Math.pow(2, 28),
  yV = Math.pow(2, 35),
  wV = Math.pow(2, 42),
  bV = Math.pow(2, 49),
  vV = Math.pow(2, 56),
  EV = Math.pow(2, 63),
  AV = function (t) {
    return t < fV
      ? 1
      : t < pV
        ? 2
        : t < gV
          ? 3
          : t < mV
            ? 4
            : t < yV
              ? 5
              : t < wV
                ? 6
                : t < bV
                  ? 7
                  : t < vV
                    ? 8
                    : t < EV
                      ? 9
                      : 10
  },
  _V = { encode: cV, decode: dV, encodingLength: AV },
  Nk = _V
const eI = (t, e, n = 0) => (Nk.encode(t, e, n), e),
  tI = t => Nk.encodingLength(t),
  tv = (t, e) => {
    const n = e.byteLength,
      r = tI(t),
      s = r + tI(n),
      i = new Uint8Array(s + n)
    return eI(t, i, 0), eI(n, i, r), i.set(e, s), new CV(t, n, e, i)
  }
let CV = class {
  constructor(e, n, r, s) {
    ;(this.code = e), (this.size = n), (this.digest = r), (this.bytes = s)
  }
}
const Pk = ({ name: t, code: e, encode: n }) => new SV(t, e, n)
let SV = class {
  constructor(e, n, r) {
    ;(this.name = e), (this.code = n), (this.encode = r)
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const n = this.encode(e)
      return n instanceof Uint8Array ? tv(this.code, n) : n.then(r => tv(this.code, r))
    } else throw Error('Unknown type, must be binary type')
  }
}
const Rk = t => async e => new Uint8Array(await crypto.subtle.digest(t, e)),
  IV = Pk({ name: 'sha2-256', code: 18, encode: Rk('SHA-256') }),
  xV = Pk({ name: 'sha2-512', code: 19, encode: Rk('SHA-512') })
var TV = Object.freeze({ __proto__: null, sha256: IV, sha512: xV })
const kk = 0,
  NV = 'identity',
  Ok = Sk,
  PV = t => tv(kk, Ok(t)),
  RV = { code: kk, name: NV, encode: Ok, digest: PV }
var kV = Object.freeze({ __proto__: null, identity: RV })
new TextEncoder(), new TextDecoder()
const nI = { ...SK, ...xK, ...NK, ...RK, ...BK, ...zK, ...VK, ...ZK, ...tV, ...aV }
;({ ...TV, ...kV })
function Bk(t, e, n, r) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: n }, decoder: { decode: r } }
}
const rI = Bk(
    'utf8',
    'u',
    t => 'u' + new TextDecoder('utf8').decode(t),
    t => new TextEncoder().encode(t.substring(1))
  ),
  Lw = Bk(
    'ascii',
    'a',
    t => {
      let e = 'a'
      for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n])
      return e
    },
    t => {
      t = t.substring(1)
      const e = _k(t.length)
      for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n)
      return e
    }
  ),
  Dk = { utf8: rI, 'utf-8': rI, hex: nI.base16, latin1: Lw, ascii: Lw, binary: Lw, ...nI }
function D0(t, e = 'utf8') {
  const n = Dk[e]
  if (!n) throw new Error(`Unsupported encoding "${e}"`)
  return (e === 'utf8' || e === 'utf-8') &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString('utf8')
    : n.encoder.encode(t).substring(1)
}
function xd(t, e = 'utf8') {
  const n = Dk[e]
  if (!n) throw new Error(`Unsupported encoding "${e}"`)
  return (e === 'utf8' || e === 'utf-8') &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? SA(globalThis.Buffer.from(t, 'utf-8'))
    : n.decoder.decode(`${n.prefix}${t}`)
}
function sI(t) {
  return hu(D0(xd(t, O0), Ek))
}
function vm(t) {
  return D0(xd(Jo(t), Ek), O0)
}
function Mk(t) {
  const e = xd(dK, YS),
    n = lK + D0(Ck([e, t]), YS)
  return [cK, uK, n].join(aK)
}
function OV(t) {
  return D0(t, O0)
}
function BV(t) {
  return xd(t, O0)
}
function DV(t) {
  return xd([vm(t.header), vm(t.payload)].join(bm), Ak)
}
function MV(t) {
  return [vm(t.header), vm(t.payload), OV(t.signature)].join(bm)
}
function nv(t) {
  const e = t.split(bm),
    n = sI(e[0]),
    r = sI(e[1]),
    s = BV(e[2]),
    i = xd(e.slice(0, 2).join(bm), Ak)
  return { header: n, payload: r, signature: s, data: i }
}
function iI(t = lk(hK)) {
  const e = vk.getPublicKey(t)
  return { secretKey: Ck([t, e]), publicKey: e }
}
async function UV(t, e, n, r, s = Me.fromMiliseconds(Date.now())) {
  const i = { alg: iK, typ: oK },
    o = Mk(r.publicKey),
    a = s + n,
    c = { iss: o, sub: t, aud: e, iat: s, exp: a },
    u = DV({ header: i, payload: c }),
    l = vk.sign(u, r.secretKey.slice(0, 32))
  return MV({ header: i, payload: c, signature: l })
}
var oI = function (t, e, n) {
    if (n || arguments.length === 2)
      for (var r = 0, s = e.length, i; r < s; r++)
        (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)), (i[r] = e[r]))
    return t.concat(i || Array.prototype.slice.call(e))
  },
  LV = (function () {
    function t(e, n, r) {
      ;(this.name = e), (this.version = n), (this.os = r), (this.type = 'browser')
    }
    return t
  })(),
  $V = (function () {
    function t(e) {
      ;(this.version = e), (this.type = 'node'), (this.name = 'node'), (this.os = process.platform)
    }
    return t
  })(),
  FV = (function () {
    function t(e, n, r, s) {
      ;(this.name = e),
        (this.version = n),
        (this.os = r),
        (this.bot = s),
        (this.type = 'bot-device')
    }
    return t
  })(),
  jV = (function () {
    function t() {
      ;(this.type = 'bot'),
        (this.bot = !0),
        (this.name = 'bot'),
        (this.version = null),
        (this.os = null)
    }
    return t
  })(),
  HV = (function () {
    function t() {
      ;(this.type = 'react-native'),
        (this.name = 'react-native'),
        (this.version = null),
        (this.os = null)
    }
    return t
  })(),
  qV =
    /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
  zV = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
  aI = 3,
  WV = [
    ['aol', /AOLShield\/([0-9\._]+)/],
    ['edge', /Edge\/([0-9\._]+)/],
    ['edge-ios', /EdgiOS\/([0-9\._]+)/],
    ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
    ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
    ['samsung', /SamsungBrowser\/([0-9\.]+)/],
    ['silk', /\bSilk\/([0-9._-]+)\b/],
    ['miui', /MiuiBrowser\/([0-9\.]+)$/],
    ['beaker', /BeakerBrowser\/([0-9\.]+)/],
    ['edge-chromium', /EdgA?\/([0-9\.]+)/],
    ['chromium-webview', /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
    ['fxios', /FxiOS\/([0-9\.]+)/],
    ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
    ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
    ['pie', /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
    [
      'pie',
      /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/
    ],
    ['netfront', /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
    ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ['android', /Android\s([0-9\.]+)/],
    ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9\._]+).*Safari/],
    ['facebook', /FB[AS]V\/([0-9\.]+)/],
    ['instagram', /Instagram\s([0-9\.]+)/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ['curl', /^curl\/([0-9\.]+)$/],
    ['searchbot', qV]
  ],
  cI = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Windows CE', /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\/2/]
  ]
function KV(t) {
  return typeof document > 'u' && typeof navigator < 'u' && navigator.product === 'ReactNative'
    ? new HV()
    : typeof navigator < 'u'
      ? GV(navigator.userAgent)
      : ZV()
}
function VV(t) {
  return (
    t !== '' &&
    WV.reduce(function (e, n) {
      var r = n[0],
        s = n[1]
      if (e) return e
      var i = s.exec(t)
      return !!i && [r, i]
    }, !1)
  )
}
function GV(t) {
  var e = VV(t)
  if (!e) return null
  var n = e[0],
    r = e[1]
  if (n === 'searchbot') return new jV()
  var s = r[1] && r[1].split('.').join('_').split('_').slice(0, 3)
  s ? s.length < aI && (s = oI(oI([], s, !0), YV(aI - s.length), !0)) : (s = [])
  var i = s.join('.'),
    o = QV(t),
    a = zV.exec(t)
  return a && a[1] ? new FV(n, i, o, a[1]) : new LV(n, i, o)
}
function QV(t) {
  for (var e = 0, n = cI.length; e < n; e++) {
    var r = cI[e],
      s = r[0],
      i = r[1],
      o = i.exec(t)
    if (o) return s
  }
  return null
}
function ZV() {
  var t = typeof process < 'u' && process.version
  return t ? new $V(process.version.slice(1)) : null
}
function YV(t) {
  for (var e = [], n = 0; n < t; n++) e.push('0')
  return e
}
var dn = {},
  uI
function Uk() {
  if (uI) return dn
  ;(uI = 1),
    Object.defineProperty(dn, '__esModule', { value: !0 }),
    (dn.getLocalStorage =
      dn.getLocalStorageOrThrow =
      dn.getCrypto =
      dn.getCryptoOrThrow =
      dn.getLocation =
      dn.getLocationOrThrow =
      dn.getNavigator =
      dn.getNavigatorOrThrow =
      dn.getDocument =
      dn.getDocumentOrThrow =
      dn.getFromWindowOrThrow =
      dn.getFromWindow =
        void 0)
  function t(h) {
    let p
    return typeof window < 'u' && typeof window[h] < 'u' && (p = window[h]), p
  }
  dn.getFromWindow = t
  function e(h) {
    const p = t(h)
    if (!p) throw new Error(`${h} is not defined in Window`)
    return p
  }
  dn.getFromWindowOrThrow = e
  function n() {
    return e('document')
  }
  dn.getDocumentOrThrow = n
  function r() {
    return t('document')
  }
  dn.getDocument = r
  function s() {
    return e('navigator')
  }
  dn.getNavigatorOrThrow = s
  function i() {
    return t('navigator')
  }
  dn.getNavigator = i
  function o() {
    return e('location')
  }
  dn.getLocationOrThrow = o
  function a() {
    return t('location')
  }
  dn.getLocation = a
  function c() {
    return e('crypto')
  }
  dn.getCryptoOrThrow = c
  function u() {
    return t('crypto')
  }
  dn.getCrypto = u
  function l() {
    return e('localStorage')
  }
  dn.getLocalStorageOrThrow = l
  function d() {
    return t('localStorage')
  }
  return (dn.getLocalStorage = d), dn
}
var fu = Uk(),
  Qd = {},
  lI
function JV() {
  if (lI) return Qd
  ;(lI = 1), Object.defineProperty(Qd, '__esModule', { value: !0 }), (Qd.getWindowMetadata = void 0)
  const t = Uk()
  function e() {
    let n, r
    try {
      ;(n = t.getDocumentOrThrow()), (r = t.getLocationOrThrow())
    } catch {
      return null
    }
    function s() {
      const p = n.getElementsByTagName('link'),
        y = []
      for (let m = 0; m < p.length; m++) {
        const b = p[m],
          I = b.getAttribute('rel')
        if (I && I.toLowerCase().indexOf('icon') > -1) {
          const x = b.getAttribute('href')
          if (x)
            if (
              x.toLowerCase().indexOf('https:') === -1 &&
              x.toLowerCase().indexOf('http:') === -1 &&
              x.indexOf('//') !== 0
            ) {
              let _ = r.protocol + '//' + r.host
              if (x.indexOf('/') === 0) _ += x
              else {
                const R = r.pathname.split('/')
                R.pop()
                const N = R.join('/')
                _ += N + '/' + x
              }
              y.push(_)
            } else if (x.indexOf('//') === 0) {
              const _ = r.protocol + x
              y.push(_)
            } else y.push(x)
        }
      }
      return y
    }
    function i(...p) {
      const y = n.getElementsByTagName('meta')
      for (let m = 0; m < y.length; m++) {
        const b = y[m],
          I = ['itemprop', 'property', 'name']
            .map(x => b.getAttribute(x))
            .filter(x => (x ? p.includes(x) : !1))
        if (I.length && I) {
          const x = b.getAttribute('content')
          if (x) return x
        }
      }
      return ''
    }
    function o() {
      let p = i('name', 'og:site_name', 'og:title', 'twitter:title')
      return p || (p = n.title), p
    }
    function a() {
      return i('description', 'og:description', 'twitter:description', 'keywords')
    }
    const c = o(),
      u = a(),
      l = r.origin,
      d = s()
    return { description: u, url: l, icons: d, name: c }
  }
  return (Qd.getWindowMetadata = e), Qd
}
var XV = JV()
function bf(t, { strict: e = !0 } = {}) {
  return !t || typeof t != 'string' ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith('0x')
}
function dI(t) {
  return bf(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length
}
const Lk = '2.23.2'
let Zd = {
  getDocsUrl: ({ docsBaseUrl: t, docsPath: e = '', docsSlug: n }) =>
    e ? `${t ?? 'https://viem.sh'}${e}${n ? `#${n}` : ''}` : void 0,
  version: `viem@${Lk}`
}
class pu extends Error {
  constructor(e, n = {}) {
    var a
    const r = (() => {
        var c
        return n.cause instanceof pu
          ? n.cause.details
          : (c = n.cause) != null && c.message
            ? n.cause.message
            : n.details
      })(),
      s = (n.cause instanceof pu && n.cause.docsPath) || n.docsPath,
      i = (a = Zd.getDocsUrl) == null ? void 0 : a.call(Zd, { ...n, docsPath: s }),
      o = [
        e || 'An error occurred.',
        '',
        ...(n.metaMessages ? [...n.metaMessages, ''] : []),
        ...(i ? [`Docs: ${i}`] : []),
        ...(r ? [`Details: ${r}`] : []),
        ...(Zd.version ? [`Version: ${Zd.version}`] : [])
      ].join(`
`)
    super(o, n.cause ? { cause: n.cause } : void 0),
      Object.defineProperty(this, 'details', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'docsPath', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'metaMessages', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'shortMessage', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'version', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, 'name', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 'BaseError'
      }),
      (this.details = r),
      (this.docsPath = s),
      (this.metaMessages = n.metaMessages),
      (this.name = n.name ?? this.name),
      (this.shortMessage = e),
      (this.version = Lk)
  }
  walk(e) {
    return $k(this, e)
  }
}
function $k(t, e) {
  return e != null && e(t)
    ? t
    : t && typeof t == 'object' && 'cause' in t && t.cause !== void 0
      ? $k(t.cause, e)
      : e
        ? null
        : t
}
class Fk extends pu {
  constructor({ size: e, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${e}) exceeds padding size (${n}).`,
      { name: 'SizeExceedsPaddingSizeError' }
    )
  }
}
function Td(t, { dir: e, size: n = 32 } = {}) {
  return typeof t == 'string' ? eG(t, { dir: e, size: n }) : tG(t, { dir: e, size: n })
}
function eG(t, { dir: e, size: n = 32 } = {}) {
  if (n === null) return t
  const r = t.replace('0x', '')
  if (r.length > n * 2) throw new Fk({ size: Math.ceil(r.length / 2), targetSize: n, type: 'hex' })
  return `0x${r[e === 'right' ? 'padEnd' : 'padStart'](n * 2, '0')}`
}
function tG(t, { dir: e, size: n = 32 } = {}) {
  if (n === null) return t
  if (t.length > n) throw new Fk({ size: t.length, targetSize: n, type: 'bytes' })
  const r = new Uint8Array(n)
  for (let s = 0; s < n; s++) {
    const i = e === 'right'
    r[i ? s : n - s - 1] = t[i ? s : t.length - s - 1]
  }
  return r
}
class nG extends pu {
  constructor({ max: e, min: n, signed: r, size: s, value: i }) {
    super(
      `Number "${i}" is not in safe ${s ? `${s * 8}-bit ${r ? 'signed' : 'unsigned'} ` : ''}integer range ${e ? `(${n} to ${e})` : `(above ${n})`}`,
      { name: 'IntegerOutOfRangeError' }
    )
  }
}
class rG extends pu {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${e} bytes.`, { name: 'SizeOverflowError' })
  }
}
function Nd(t, { size: e }) {
  if (dI(t) > e) throw new rG({ givenSize: dI(t), maxSize: e })
}
function rv(t, e = {}) {
  const { signed: n } = e
  e.size && Nd(t, { size: e.size })
  const r = BigInt(t)
  if (!n) return r
  const s = (t.length - 2) / 2,
    i = (1n << (BigInt(s) * 8n - 1n)) - 1n
  return r <= i ? r : r - BigInt(`0x${'f'.padStart(s * 2, 'f')}`) - 1n
}
function sG(t, e = {}) {
  return Number(rv(t, e))
}
const iG = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, '0'))
function sv(t, e = {}) {
  return typeof t == 'number' || typeof t == 'bigint'
    ? Hk(t, e)
    : typeof t == 'string'
      ? cG(t, e)
      : typeof t == 'boolean'
        ? oG(t, e)
        : jk(t, e)
}
function oG(t, e = {}) {
  const n = `0x${Number(t)}`
  return typeof e.size == 'number' ? (Nd(n, { size: e.size }), Td(n, { size: e.size })) : n
}
function jk(t, e = {}) {
  let n = ''
  for (let s = 0; s < t.length; s++) n += iG[t[s]]
  const r = `0x${n}`
  return typeof e.size == 'number'
    ? (Nd(r, { size: e.size }), Td(r, { dir: 'right', size: e.size }))
    : r
}
function Hk(t, e = {}) {
  const { signed: n, size: r } = e,
    s = BigInt(t)
  let i
  r
    ? n
      ? (i = (1n << (BigInt(r) * 8n - 1n)) - 1n)
      : (i = 2n ** (BigInt(r) * 8n) - 1n)
    : typeof t == 'number' && (i = BigInt(Number.MAX_SAFE_INTEGER))
  const o = typeof i == 'bigint' && n ? -i - 1n : 0
  if ((i && s > i) || s < o) {
    const c = typeof t == 'bigint' ? 'n' : ''
    throw new nG({
      max: i ? `${i}${c}` : void 0,
      min: `${o}${c}`,
      signed: n,
      size: r,
      value: `${t}${c}`
    })
  }
  const a = `0x${(n && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`
  return r ? Td(a, { size: r }) : a
}
const aG = new TextEncoder()
function cG(t, e = {}) {
  const n = aG.encode(t)
  return jk(n, e)
}
const uG = new TextEncoder()
function lG(t, e = {}) {
  return typeof t == 'number' || typeof t == 'bigint'
    ? hG(t, e)
    : typeof t == 'boolean'
      ? dG(t, e)
      : bf(t)
        ? qk(t, e)
        : zk(t, e)
}
function dG(t, e = {}) {
  const n = new Uint8Array(1)
  return (
    (n[0] = Number(t)),
    typeof e.size == 'number' ? (Nd(n, { size: e.size }), Td(n, { size: e.size })) : n
  )
}
const Io = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 }
function hI(t) {
  if (t >= Io.zero && t <= Io.nine) return t - Io.zero
  if (t >= Io.A && t <= Io.F) return t - (Io.A - 10)
  if (t >= Io.a && t <= Io.f) return t - (Io.a - 10)
}
function qk(t, e = {}) {
  let n = t
  e.size && (Nd(n, { size: e.size }), (n = Td(n, { dir: 'right', size: e.size })))
  let r = n.slice(2)
  r.length % 2 && (r = `0${r}`)
  const s = r.length / 2,
    i = new Uint8Array(s)
  for (let o = 0, a = 0; o < s; o++) {
    const c = hI(r.charCodeAt(a++)),
      u = hI(r.charCodeAt(a++))
    if (c === void 0 || u === void 0)
      throw new pu(`Invalid byte sequence ("${r[a - 2]}${r[a - 1]}" in "${r}").`)
    i[o] = c * 16 + u
  }
  return i
}
function hG(t, e) {
  const n = Hk(t, e)
  return qk(n)
}
function zk(t, e = {}) {
  const n = uG.encode(t)
  return typeof e.size == 'number'
    ? (Nd(n, { size: e.size }), Td(n, { dir: 'right', size: e.size }))
    : n
}
function Wk(t, e) {
  const n = e || 'hex',
    r = CR(bf(t, { strict: !1 }) ? lG(t) : t)
  return n === 'bytes' ? r : sv(r)
}
class fG extends Map {
  constructor(e) {
    super(),
      Object.defineProperty(this, 'maxSize', {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }),
      (this.maxSize = e)
  }
  get(e) {
    const n = super.get(e)
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n
  }
  set(e, n) {
    if ((super.set(e, n), this.maxSize && this.size > this.maxSize)) {
      const r = this.keys().next().value
      r && this.delete(r)
    }
    return this
  }
}
const $w = new fG(8192)
function pG(t, e) {
  if ($w.has(`${t}.${e}`)) return $w.get(`${t}.${e}`)
  const n = t.substring(2).toLowerCase(),
    r = Wk(zk(n), 'bytes'),
    s = n.split('')
  for (let o = 0; o < 40; o += 2)
    r[o >> 1] >> 4 >= 8 && s[o] && (s[o] = s[o].toUpperCase()),
      (r[o >> 1] & 15) >= 8 && s[o + 1] && (s[o + 1] = s[o + 1].toUpperCase())
  const i = `0x${s.join('')}`
  return $w.set(`${t}.${e}`, i), i
}
function gG(t) {
  const e = Wk(`0x${t.substring(4)}`).substring(26)
  return pG(`0x${e}`)
}
async function mG({ hash: t, signature: e }) {
  const n = bf(t) ? t : sv(t),
    { secp256k1: r } = await qr(
      async () => {
        const { secp256k1: o } = await Promise.resolve().then(() => z3)
        return { secp256k1: o }
      },
      void 0,
      import.meta.url
    )
  return `0x${(() => {
    if (typeof e == 'object' && 'r' in e && 's' in e) {
      const { r: u, s: l, v: d, yParity: h } = e,
        p = Number(h ?? d),
        y = fI(p)
      return new r.Signature(rv(u), rv(l)).addRecoveryBit(y)
    }
    const o = bf(e) ? e : sv(e),
      a = sG(`0x${o.slice(130)}`),
      c = fI(a)
    return r.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(c)
  })()
    .recoverPublicKey(n.substring(2))
    .toHex(!1)}`
}
function fI(t) {
  if (t === 0 || t === 1) return t
  if (t === 27) return 0
  if (t === 28) return 1
  throw new Error('Invalid yParityOrV value')
}
async function yG({ hash: t, signature: e }) {
  return gG(await mG({ hash: t, signature: e }))
}
function wG(t) {
  if (t.length >= 255) throw new TypeError('Alphabet too long')
  const e = new Uint8Array(256)
  for (let u = 0; u < e.length; u++) e[u] = 255
  for (let u = 0; u < t.length; u++) {
    const l = t.charAt(u),
      d = l.charCodeAt(0)
    if (e[d] !== 255) throw new TypeError(l + ' is ambiguous')
    e[d] = u
  }
  const n = t.length,
    r = t.charAt(0),
    s = Math.log(n) / Math.log(256),
    i = Math.log(256) / Math.log(n)
  function o(u) {
    if (
      (u instanceof Uint8Array ||
        (ArrayBuffer.isView(u)
          ? (u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength))
          : Array.isArray(u) && (u = Uint8Array.from(u))),
      !(u instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (u.length === 0) return ''
    let l = 0,
      d = 0,
      h = 0
    const p = u.length
    for (; h !== p && u[h] === 0; ) h++, l++
    const y = ((p - h) * i + 1) >>> 0,
      m = new Uint8Array(y)
    for (; h !== p; ) {
      let x = u[h],
        _ = 0
      for (let R = y - 1; (x !== 0 || _ < d) && R !== -1; R--, _++)
        (x += (256 * m[R]) >>> 0), (m[R] = x % n >>> 0), (x = (x / n) >>> 0)
      if (x !== 0) throw new Error('Non-zero carry')
      ;(d = _), h++
    }
    let b = y - d
    for (; b !== y && m[b] === 0; ) b++
    let I = r.repeat(l)
    for (; b < y; ++b) I += t.charAt(m[b])
    return I
  }
  function a(u) {
    if (typeof u != 'string') throw new TypeError('Expected String')
    if (u.length === 0) return new Uint8Array()
    let l = 0,
      d = 0,
      h = 0
    for (; u[l] === r; ) d++, l++
    const p = ((u.length - l) * s + 1) >>> 0,
      y = new Uint8Array(p)
    for (; l < u.length; ) {
      const x = u.charCodeAt(l)
      if (x > 255) return
      let _ = e[x]
      if (_ === 255) return
      let R = 0
      for (let N = p - 1; (_ !== 0 || R < h) && N !== -1; N--, R++)
        (_ += (n * y[N]) >>> 0), (y[N] = _ % 256 >>> 0), (_ = (_ / 256) >>> 0)
      if (_ !== 0) throw new Error('Non-zero carry')
      ;(h = R), l++
    }
    let m = p - h
    for (; m !== p && y[m] === 0; ) m++
    const b = new Uint8Array(d + (p - m))
    let I = d
    for (; m !== p; ) b[I++] = y[m++]
    return b
  }
  function c(u) {
    const l = a(u)
    if (l) return l
    throw new Error('Non-base' + n + ' character')
  }
  return { encode: o, decodeUnsafe: a, decode: c }
}
var bG = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
const vs = wG(bG)
function Kk(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? globalThis.Buffer.allocUnsafe(t)
    : new Uint8Array(t)
}
function Rh(t, e) {
  e || (e = t.reduce((s, i) => s + i.length, 0))
  const n = Kk(e)
  let r = 0
  for (const s of t) n.set(s, r), (r += s.length)
  return n
}
function vG(t, e) {
  if (t.length >= 255) throw new TypeError('Alphabet too long')
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255
  for (var s = 0; s < t.length; s++) {
    var i = t.charAt(s),
      o = i.charCodeAt(0)
    if (n[o] !== 255) throw new TypeError(i + ' is ambiguous')
    n[o] = s
  }
  var a = t.length,
    c = t.charAt(0),
    u = Math.log(a) / Math.log(256),
    l = Math.log(256) / Math.log(a)
  function d(y) {
    if (
      (y instanceof Uint8Array ||
        (ArrayBuffer.isView(y)
          ? (y = new Uint8Array(y.buffer, y.byteOffset, y.byteLength))
          : Array.isArray(y) && (y = Uint8Array.from(y))),
      !(y instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (y.length === 0) return ''
    for (var m = 0, b = 0, I = 0, x = y.length; I !== x && y[I] === 0; ) I++, m++
    for (var _ = ((x - I) * l + 1) >>> 0, R = new Uint8Array(_); I !== x; ) {
      for (var N = y[I], T = 0, M = _ - 1; (N !== 0 || T < b) && M !== -1; M--, T++)
        (N += (256 * R[M]) >>> 0), (R[M] = N % a >>> 0), (N = (N / a) >>> 0)
      if (N !== 0) throw new Error('Non-zero carry')
      ;(b = T), I++
    }
    for (var H = _ - b; H !== _ && R[H] === 0; ) H++
    for (var B = c.repeat(m); H < _; ++H) B += t.charAt(R[H])
    return B
  }
  function h(y) {
    if (typeof y != 'string') throw new TypeError('Expected String')
    if (y.length === 0) return new Uint8Array()
    var m = 0
    if (y[m] !== ' ') {
      for (var b = 0, I = 0; y[m] === c; ) b++, m++
      for (var x = ((y.length - m) * u + 1) >>> 0, _ = new Uint8Array(x); y[m]; ) {
        var R = n[y.charCodeAt(m)]
        if (R === 255) return
        for (var N = 0, T = x - 1; (R !== 0 || N < I) && T !== -1; T--, N++)
          (R += (a * _[T]) >>> 0), (_[T] = R % 256 >>> 0), (R = (R / 256) >>> 0)
        if (R !== 0) throw new Error('Non-zero carry')
        ;(I = N), m++
      }
      if (y[m] !== ' ') {
        for (var M = x - I; M !== x && _[M] === 0; ) M++
        for (var H = new Uint8Array(b + (x - M)), B = b; M !== x; ) H[B++] = _[M++]
        return H
      }
    }
  }
  function p(y) {
    var m = h(y)
    if (m) return m
    throw new Error(`Non-${e} character`)
  }
  return { encode: d, decodeUnsafe: h, decode: p }
}
var EG = vG,
  AG = EG
const _G = t => {
    if (t instanceof Uint8Array && t.constructor.name === 'Uint8Array') return t
    if (t instanceof ArrayBuffer) return new Uint8Array(t)
    if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
    throw new Error('Unknown type, must be binary type')
  },
  CG = t => new TextEncoder().encode(t),
  SG = t => new TextDecoder().decode(t)
class IG {
  constructor(e, n, r) {
    ;(this.name = e), (this.prefix = n), (this.baseEncode = r)
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
    throw Error('Unknown type, must be binary type')
  }
}
class xG {
  constructor(e, n, r) {
    if (((this.name = e), (this.prefix = n), n.codePointAt(0) === void 0))
      throw new Error('Invalid prefix character')
    ;(this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = r)
  }
  decode(e) {
    if (typeof e == 'string') {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(
          `Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`
        )
      return this.baseDecode(e.slice(this.prefix.length))
    } else throw Error('Can only multibase decode strings')
  }
  or(e) {
    return Vk(this, e)
  }
}
class TG {
  constructor(e) {
    this.decoders = e
  }
  or(e) {
    return Vk(this, e)
  }
  decode(e) {
    const n = e[0],
      r = this.decoders[n]
    if (r) return r.decode(e)
    throw RangeError(
      `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
    )
  }
}
const Vk = (t, e) =>
  new TG({ ...(t.decoders || { [t.prefix]: t }), ...(e.decoders || { [e.prefix]: e }) })
class NG {
  constructor(e, n, r, s) {
    ;(this.name = e),
      (this.prefix = n),
      (this.baseEncode = r),
      (this.baseDecode = s),
      (this.encoder = new IG(e, n, r)),
      (this.decoder = new xG(e, n, s))
  }
  encode(e) {
    return this.encoder.encode(e)
  }
  decode(e) {
    return this.decoder.decode(e)
  }
}
const M0 = ({ name: t, prefix: e, encode: n, decode: r }) => new NG(t, e, n, r),
  pp = ({ prefix: t, name: e, alphabet: n }) => {
    const { encode: r, decode: s } = AG(n, e)
    return M0({ prefix: t, name: e, encode: r, decode: i => _G(s(i)) })
  },
  PG = (t, e, n, r) => {
    const s = {}
    for (let l = 0; l < e.length; ++l) s[e[l]] = l
    let i = t.length
    for (; t[i - 1] === '='; ) --i
    const o = new Uint8Array(((i * n) / 8) | 0)
    let a = 0,
      c = 0,
      u = 0
    for (let l = 0; l < i; ++l) {
      const d = s[t[l]]
      if (d === void 0) throw new SyntaxError(`Non-${r} character`)
      ;(c = (c << n) | d), (a += n), a >= 8 && ((a -= 8), (o[u++] = 255 & (c >> a)))
    }
    if (a >= n || 255 & (c << (8 - a))) throw new SyntaxError('Unexpected end of data')
    return o
  },
  RG = (t, e, n) => {
    const r = e[e.length - 1] === '=',
      s = (1 << n) - 1
    let i = '',
      o = 0,
      a = 0
    for (let c = 0; c < t.length; ++c)
      for (a = (a << 8) | t[c], o += 8; o > n; ) (o -= n), (i += e[s & (a >> o)])
    if ((o && (i += e[s & (a << (n - o))]), r)) for (; (i.length * n) & 7; ) i += '='
    return i
  },
  Or = ({ name: t, prefix: e, bitsPerChar: n, alphabet: r }) =>
    M0({
      prefix: e,
      name: t,
      encode(s) {
        return RG(s, r, n)
      },
      decode(s) {
        return PG(s, r, n, t)
      }
    }),
  kG = M0({ prefix: '\0', name: 'identity', encode: t => SG(t), decode: t => CG(t) }),
  OG = Object.freeze(
    Object.defineProperty({ __proto__: null, identity: kG }, Symbol.toStringTag, {
      value: 'Module'
    })
  ),
  BG = Or({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }),
  DG = Object.freeze(
    Object.defineProperty({ __proto__: null, base2: BG }, Symbol.toStringTag, { value: 'Module' })
  ),
  MG = Or({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }),
  UG = Object.freeze(
    Object.defineProperty({ __proto__: null, base8: MG }, Symbol.toStringTag, { value: 'Module' })
  ),
  LG = pp({ prefix: '9', name: 'base10', alphabet: '0123456789' }),
  $G = Object.freeze(
    Object.defineProperty({ __proto__: null, base10: LG }, Symbol.toStringTag, { value: 'Module' })
  ),
  FG = Or({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 }),
  jG = Or({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 }),
  HG = Object.freeze(
    Object.defineProperty({ __proto__: null, base16: FG, base16upper: jG }, Symbol.toStringTag, {
      value: 'Module'
    })
  ),
  qG = Or({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
  }),
  zG = Or({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
  }),
  WG = Or({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
  }),
  KG = Or({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
  }),
  VG = Or({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
  }),
  GG = Or({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
  }),
  QG = Or({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
  }),
  ZG = Or({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
  }),
  YG = Or({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
  }),
  JG = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base32: qG,
        base32hex: VG,
        base32hexpad: QG,
        base32hexpadupper: ZG,
        base32hexupper: GG,
        base32pad: WG,
        base32padupper: KG,
        base32upper: zG,
        base32z: YG
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  XG = pp({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' }),
  eQ = pp({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' }),
  tQ = Object.freeze(
    Object.defineProperty({ __proto__: null, base36: XG, base36upper: eQ }, Symbol.toStringTag, {
      value: 'Module'
    })
  ),
  nQ = pp({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
  }),
  rQ = pp({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
  }),
  sQ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base58btc: nQ, base58flickr: rQ },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  iQ = Or({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
  }),
  oQ = Or({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
  }),
  aQ = Or({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
  }),
  cQ = Or({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
  }),
  uQ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base64: iQ, base64pad: oQ, base64url: aQ, base64urlpad: cQ },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Gk = Array.from(
    ''
  ),
  lQ = Gk.reduce((t, e, n) => ((t[n] = e), t), []),
  dQ = Gk.reduce((t, e, n) => ((t[e.codePointAt(0)] = n), t), [])
function hQ(t) {
  return t.reduce((e, n) => ((e += lQ[n]), e), '')
}
function fQ(t) {
  const e = []
  for (const n of t) {
    const r = dQ[n.codePointAt(0)]
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`)
    e.push(r)
  }
  return new Uint8Array(e)
}
const pQ = M0({ prefix: '', name: 'base256emoji', encode: hQ, decode: fQ }),
  gQ = Object.freeze(
    Object.defineProperty({ __proto__: null, base256emoji: pQ }, Symbol.toStringTag, {
      value: 'Module'
    })
  )
new TextEncoder()
new TextDecoder()
const pI = { ...OG, ...DG, ...UG, ...$G, ...HG, ...JG, ...tQ, ...sQ, ...uQ, ...gQ }
function Qk(t, e, n, r) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: n }, decoder: { decode: r } }
}
const gI = Qk(
    'utf8',
    'u',
    t => 'u' + new TextDecoder('utf8').decode(t),
    t => new TextEncoder().encode(t.substring(1))
  ),
  Fw = Qk(
    'ascii',
    'a',
    t => {
      let e = 'a'
      for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n])
      return e
    },
    t => {
      t = t.substring(1)
      const e = Kk(t.length)
      for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n)
      return e
    }
  ),
  Zk = { utf8: gI, 'utf-8': gI, hex: pI.base16, latin1: Fw, ascii: Fw, binary: Fw, ...pI }
function ii(t, e = 'utf8') {
  const n = Zk[e]
  if (!n) throw new Error(`Unsupported encoding "${e}"`)
  return (e === 'utf8' || e === 'utf-8') &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t, 'utf8')
    : n.decoder.decode(`${n.prefix}${t}`)
}
function _s(t, e = 'utf8') {
  const n = Zk[e]
  if (!n) throw new Error(`Unsupported encoding "${e}"`)
  return (e === 'utf8' || e === 'utf-8') &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString('utf8')
    : n.encoder.encode(t).substring(1)
}
const mQ = {
  waku: {
    publish: 'waku_publish',
    batchPublish: 'waku_batchPublish',
    subscribe: 'waku_subscribe',
    batchSubscribe: 'waku_batchSubscribe',
    subscription: 'waku_subscription',
    unsubscribe: 'waku_unsubscribe',
    batchUnsubscribe: 'waku_batchUnsubscribe',
    batchFetchMessages: 'waku_batchFetchMessages'
  },
  irn: {
    publish: 'irn_publish',
    batchPublish: 'irn_batchPublish',
    subscribe: 'irn_subscribe',
    batchSubscribe: 'irn_batchSubscribe',
    subscription: 'irn_subscription',
    unsubscribe: 'irn_unsubscribe',
    batchUnsubscribe: 'irn_batchUnsubscribe',
    batchFetchMessages: 'irn_batchFetchMessages'
  },
  iridium: {
    publish: 'iridium_publish',
    batchPublish: 'iridium_batchPublish',
    subscribe: 'iridium_subscribe',
    batchSubscribe: 'iridium_batchSubscribe',
    subscription: 'iridium_subscription',
    unsubscribe: 'iridium_unsubscribe',
    batchUnsubscribe: 'iridium_batchUnsubscribe',
    batchFetchMessages: 'iridium_batchFetchMessages'
  }
}
var yQ = {}
const wQ = ':'
function Rl(t) {
  const [e, n] = t.split(wQ)
  return { namespace: e, reference: n }
}
function Yk(t, e) {
  return t.includes(':') ? [t] : e.chains || []
}
var bQ = Object.defineProperty,
  vQ = Object.defineProperties,
  EQ = Object.getOwnPropertyDescriptors,
  mI = Object.getOwnPropertySymbols,
  AQ = Object.prototype.hasOwnProperty,
  _Q = Object.prototype.propertyIsEnumerable,
  yI = (t, e, n) =>
    e in t ? bQ(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  wI = (t, e) => {
    for (var n in e || (e = {})) AQ.call(e, n) && yI(t, n, e[n])
    if (mI) for (var n of mI(e)) _Q.call(e, n) && yI(t, n, e[n])
    return t
  },
  CQ = (t, e) => vQ(t, EQ(e))
const SQ = 'ReactNative',
  qs = { reactNative: 'react-native', node: 'node', browser: 'browser', unknown: 'unknown' },
  IQ = 'js'
function Em() {
  return typeof process < 'u' && typeof process.versions < 'u' && typeof process.versions.node < 'u'
}
function dc() {
  return !fu.getDocument() && !!fu.getNavigator() && navigator.product === SQ
}
function xQ() {
  return (
    dc() &&
    typeof global < 'u' &&
    typeof (global == null ? void 0 : global.Platform) < 'u' &&
    (global == null ? void 0 : global.Platform.OS) === 'android'
  )
}
function TQ() {
  return (
    dc() &&
    typeof global < 'u' &&
    typeof (global == null ? void 0 : global.Platform) < 'u' &&
    (global == null ? void 0 : global.Platform.OS) === 'ios'
  )
}
function gp() {
  return !Em() && !!fu.getNavigator() && !!fu.getDocument()
}
function mp() {
  return dc() ? qs.reactNative : Em() ? qs.node : gp() ? qs.browser : qs.unknown
}
function bI() {
  var t
  try {
    return dc() &&
      typeof global < 'u' &&
      typeof (global == null ? void 0 : global.Application) < 'u'
      ? (t = global.Application) == null
        ? void 0
        : t.applicationId
      : void 0
  } catch {
    return
  }
}
function NQ(t, e) {
  const n = new URLSearchParams(t)
  for (const r of Object.keys(e).sort())
    if (e.hasOwnProperty(r)) {
      const s = e[r]
      s !== void 0 && n.set(r, s)
    }
  return n.toString()
}
function PQ(t) {
  var e, n
  const r = Jk()
  try {
    return (
      t != null &&
        t.url &&
        r.url &&
        t.url !== r.url &&
        (console.warn(
          `The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r.url}. This is probably unintended and can lead to issues.`
        ),
        (t.url = r.url)),
      (e = t == null ? void 0 : t.icons) != null &&
        e.length &&
        t.icons.length > 0 &&
        (t.icons = t.icons.filter(s => s !== '')),
      CQ(wI(wI({}, r), t), {
        url: (t == null ? void 0 : t.url) || r.url,
        name: (t == null ? void 0 : t.name) || r.name,
        description: (t == null ? void 0 : t.description) || r.description,
        icons:
          (n = t == null ? void 0 : t.icons) != null && n.length && t.icons.length > 0
            ? t.icons
            : r.icons
      })
    )
  } catch (s) {
    return console.warn('Error populating app metadata', s), t || r
  }
}
function Jk() {
  return XV.getWindowMetadata() || { name: '', description: '', url: '', icons: [''] }
}
function RQ() {
  if (
    mp() === qs.reactNative &&
    typeof global < 'u' &&
    typeof (global == null ? void 0 : global.Platform) < 'u'
  ) {
    const { OS: n, Version: r } = global.Platform
    return [n, r].join('-')
  }
  const t = KV()
  if (t === null) return 'unknown'
  const e = t.os ? t.os.replace(' ', '').toLowerCase() : 'unknown'
  return t.type === 'browser' ? [e, t.name, t.version].join('-') : [e, t.version].join('-')
}
function kQ() {
  var t
  const e = mp()
  return e === qs.browser
    ? [e, ((t = fu.getLocation()) == null ? void 0 : t.host) || 'unknown'].join(':')
    : e
}
function Xk(t, e, n) {
  const r = RQ(),
    s = kQ()
  return [[t, e].join('-'), [IQ, n].join('-'), r, s].join('/')
}
function OQ({
  protocol: t,
  version: e,
  relayUrl: n,
  sdkVersion: r,
  auth: s,
  projectId: i,
  useOnCloseEvent: o,
  bundleId: a,
  packageName: c
}) {
  const u = n.split('?'),
    l = Xk(t, e, r),
    d = {
      auth: s,
      ua: l,
      projectId: i,
      useOnCloseEvent: o,
      packageName: c || void 0,
      bundleId: a || void 0
    },
    h = NQ(u[1] || '', d)
  return u[0] + '?' + h
}
function Lc(t, e) {
  return t.filter(n => e.includes(n)).length === t.length
}
function iv(t) {
  return Object.fromEntries(t.entries())
}
function ov(t) {
  return new Map(Object.entries(t))
}
function Ic(t = Me.FIVE_MINUTES, e) {
  const n = Me.toMiliseconds(t || Me.FIVE_MINUTES)
  let r, s, i, o
  return {
    resolve: a => {
      i && r && (clearTimeout(i), r(a), (o = Promise.resolve(a)))
    },
    reject: a => {
      i && s && (clearTimeout(i), s(a))
    },
    done: () =>
      new Promise((a, c) => {
        if (o) return a(o)
        ;(i = setTimeout(() => {
          const u = new Error(e)
          ;(o = Promise.reject(u)), c(u)
        }, n)),
          (r = a),
          (s = c)
      })
  }
}
function Ma(t, e, n) {
  return new Promise(async (r, s) => {
    const i = setTimeout(() => s(new Error(n)), e)
    try {
      const o = await t
      r(o)
    } catch (o) {
      s(o)
    }
    clearTimeout(i)
  })
}
function eO(t, e) {
  if (typeof e == 'string' && e.startsWith(`${t}:`)) return e
  if (t.toLowerCase() === 'topic') {
    if (typeof e != 'string')
      throw new Error('Value must be "string" for expirer target type: topic')
    return `topic:${e}`
  } else if (t.toLowerCase() === 'id') {
    if (typeof e != 'number') throw new Error('Value must be "number" for expirer target type: id')
    return `id:${e}`
  }
  throw new Error(`Unknown expirer target type: ${t}`)
}
function BQ(t) {
  return eO('topic', t)
}
function DQ(t) {
  return eO('id', t)
}
function tO(t) {
  const [e, n] = t.split(':'),
    r = { id: void 0, topic: void 0 }
  if (e === 'topic' && typeof n == 'string') r.topic = n
  else if (e === 'id' && Number.isInteger(Number(n))) r.id = Number(n)
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n}`)
  return r
}
function tr(t, e) {
  return Me.fromMiliseconds(Date.now() + Me.toMiliseconds(t))
}
function Ca(t) {
  return Date.now() >= Me.toMiliseconds(t)
}
function en(t, e) {
  return `${t}${e ? `:${e}` : ''}`
}
function Bg(t = [], e = []) {
  return [...new Set([...t, ...e])]
}
async function MQ({ id: t, topic: e, wcDeepLink: n }) {
  var r
  try {
    if (!n) return
    const s = typeof n == 'string' ? JSON.parse(n) : n,
      i = s == null ? void 0 : s.href
    if (typeof i != 'string') return
    const o = UQ(i, t, e),
      a = mp()
    if (a === qs.browser) {
      if (!((r = fu.getDocument()) != null && r.hasFocus())) {
        console.warn('Document does not have focus, skipping deeplink.')
        return
      }
      LQ(o)
    } else
      a === qs.reactNative &&
        typeof (global == null ? void 0 : global.Linking) < 'u' &&
        (await globalThis.Linking.openURL(o))
  } catch (s) {
    console.error(s)
  }
}
function UQ(t, e, n) {
  const r = `requestId=${e}&sessionTopic=${n}`
  t.endsWith('/') && (t = t.slice(0, -1))
  let s = `${t}`
  if (t.startsWith('https://t.me')) {
    const i = t.includes('?') ? '&startapp=' : '?startapp='
    s = `${s}${i}${HQ(r, !0)}`
  } else s = `${s}/wc?${r}`
  return s
}
function LQ(t) {
  let e = '_self'
  jQ()
    ? (e = '_top')
    : (FQ() || t.startsWith('https://') || t.startsWith('http://')) && (e = '_blank'),
    window.open(t, e, 'noreferrer noopener')
}
async function $Q(t, e) {
  let n = ''
  try {
    if (gp() && ((n = localStorage.getItem(e)), n)) return n
    n = await t.getItem(e)
  } catch (r) {
    console.error(r)
  }
  return n
}
function vI(t, e) {
  if (!t.includes(e)) return null
  const n = t.split(/([&,?,=])/),
    r = n.indexOf(e)
  return n[r + 2]
}
function EI() {
  return typeof crypto < 'u' && crypto != null && crypto.randomUUID
    ? crypto.randomUUID()
    : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, t => {
        const e = (Math.random() * 16) | 0
        return (t === 'x' ? e : (e & 3) | 8).toString(16)
      })
}
function IA() {
  return typeof process < 'u' && yQ.IS_VITEST === 'true'
}
function FQ() {
  return (
    typeof window < 'u' &&
    (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto)
  )
}
function jQ() {
  try {
    return window.self !== window.top
  } catch {
    return !1
  }
}
function HQ(t, e = !1) {
  const n = Buffer.from(t).toString('base64')
  return e ? n.replace(/[=]/g, '') : n
}
function nO(t) {
  return Buffer.from(t, 'base64').toString('utf-8')
}
function qQ(t) {
  return new Promise(e => setTimeout(e, t))
}
function vf(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error('positive integer expected, got ' + t)
}
function zQ(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function yp(t, ...e) {
  if (!zQ(t)) throw new Error('Uint8Array expected')
  if (e.length > 0 && !e.includes(t.length))
    throw new Error('Uint8Array expected of length ' + e + ', got length=' + t.length)
}
function xA(t) {
  if (typeof t != 'function' || typeof t.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor')
  vf(t.outputLen), vf(t.blockLen)
}
function ed(t, e = !0) {
  if (t.destroyed) throw new Error('Hash instance has been destroyed')
  if (e && t.finished) throw new Error('Hash#digest() has already been called')
}
function rO(t, e) {
  yp(t)
  const n = e.outputLen
  if (t.length < n) throw new Error('digestInto() expects output buffer of length at least ' + n)
}
const ig = BigInt(2 ** 32 - 1),
  AI = BigInt(32)
function WQ(t, e = !1) {
  return e
    ? { h: Number(t & ig), l: Number((t >> AI) & ig) }
    : { h: Number((t >> AI) & ig) | 0, l: Number(t & ig) | 0 }
}
function KQ(t, e = !1) {
  let n = new Uint32Array(t.length),
    r = new Uint32Array(t.length)
  for (let s = 0; s < t.length; s++) {
    const { h: i, l: o } = WQ(t[s], e)
    ;[n[s], r[s]] = [i, o]
  }
  return [n, r]
}
const VQ = (t, e, n) => (t << n) | (e >>> (32 - n)),
  GQ = (t, e, n) => (e << n) | (t >>> (32 - n)),
  QQ = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
  ZQ = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n)),
  ju = typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0
function YQ(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4))
}
function jw(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength)
}
function $i(t, e) {
  return (t << (32 - e)) | (t >>> e)
}
const _I = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68
function JQ(t) {
  return ((t << 24) & 4278190080) | ((t << 8) & 16711680) | ((t >>> 8) & 65280) | ((t >>> 24) & 255)
}
function CI(t) {
  for (let e = 0; e < t.length; e++) t[e] = JQ(t[e])
}
function XQ(t) {
  if (typeof t != 'string') throw new Error('utf8ToBytes expected string, got ' + typeof t)
  return new Uint8Array(new TextEncoder().encode(t))
}
function td(t) {
  return typeof t == 'string' && (t = XQ(t)), yp(t), t
}
function eZ(...t) {
  let e = 0
  for (let r = 0; r < t.length; r++) {
    const s = t[r]
    yp(s), (e += s.length)
  }
  const n = new Uint8Array(e)
  for (let r = 0, s = 0; r < t.length; r++) {
    const i = t[r]
    n.set(i, s), (s += i.length)
  }
  return n
}
let TA = class {
  clone() {
    return this._cloneInto()
  }
}
function sO(t) {
  const e = r => t().update(td(r)).digest(),
    n = t()
  return (e.outputLen = n.outputLen), (e.blockLen = n.blockLen), (e.create = () => t()), e
}
function Pd(t = 32) {
  if (ju && typeof ju.getRandomValues == 'function') return ju.getRandomValues(new Uint8Array(t))
  if (ju && typeof ju.randomBytes == 'function') return ju.randomBytes(t)
  throw new Error('crypto.getRandomValues must be defined')
}
const iO = [],
  oO = [],
  aO = [],
  tZ = BigInt(0),
  Yd = BigInt(1),
  nZ = BigInt(2),
  rZ = BigInt(7),
  sZ = BigInt(256),
  iZ = BigInt(113)
for (let t = 0, e = Yd, n = 1, r = 0; t < 24; t++) {
  ;([n, r] = [r, (2 * n + 3 * r) % 5]),
    iO.push(2 * (5 * r + n)),
    oO.push((((t + 1) * (t + 2)) / 2) % 64)
  let s = tZ
  for (let i = 0; i < 7; i++)
    (e = ((e << Yd) ^ ((e >> rZ) * iZ)) % sZ), e & nZ && (s ^= Yd << ((Yd << BigInt(i)) - Yd))
  aO.push(s)
}
const [oZ, aZ] = KQ(aO, !0),
  SI = (t, e, n) => (n > 32 ? QQ(t, e, n) : VQ(t, e, n)),
  II = (t, e, n) => (n > 32 ? ZQ(t, e, n) : GQ(t, e, n))
function cZ(t, e = 24) {
  const n = new Uint32Array(10)
  for (let r = 24 - e; r < 24; r++) {
    for (let o = 0; o < 10; o++) n[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40]
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10,
        c = (o + 2) % 10,
        u = n[c],
        l = n[c + 1],
        d = SI(u, l, 1) ^ n[a],
        h = II(u, l, 1) ^ n[a + 1]
      for (let p = 0; p < 50; p += 10) (t[o + p] ^= d), (t[o + p + 1] ^= h)
    }
    let s = t[2],
      i = t[3]
    for (let o = 0; o < 24; o++) {
      const a = oO[o],
        c = SI(s, i, a),
        u = II(s, i, a),
        l = iO[o]
      ;(s = t[l]), (i = t[l + 1]), (t[l] = c), (t[l + 1] = u)
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) n[a] = t[o + a]
      for (let a = 0; a < 10; a++) t[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10]
    }
    ;(t[0] ^= oZ[r]), (t[1] ^= aZ[r])
  }
  n.fill(0)
}
let uZ = class cO extends TA {
  constructor(e, n, r, s = !1, i = 24) {
    if (
      (super(),
      (this.blockLen = e),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = s),
      (this.rounds = i),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      vf(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error('Sha3 supports only keccak-f1600 function')
    ;(this.state = new Uint8Array(200)), (this.state32 = YQ(this.state))
  }
  keccak() {
    _I || CI(this.state32),
      cZ(this.state32, this.rounds),
      _I || CI(this.state32),
      (this.posOut = 0),
      (this.pos = 0)
  }
  update(e) {
    ed(this)
    const { blockLen: n, state: r } = this
    e = td(e)
    const s = e.length
    for (let i = 0; i < s; ) {
      const o = Math.min(n - this.pos, s - i)
      for (let a = 0; a < o; a++) r[this.pos++] ^= e[i++]
      this.pos === n && this.keccak()
    }
    return this
  }
  finish() {
    if (this.finished) return
    this.finished = !0
    const { state: e, suffix: n, pos: r, blockLen: s } = this
    ;(e[r] ^= n), (n & 128) !== 0 && r === s - 1 && this.keccak(), (e[s - 1] ^= 128), this.keccak()
  }
  writeInto(e) {
    ed(this, !1), yp(e), this.finish()
    const n = this.state,
      { blockLen: r } = this
    for (let s = 0, i = e.length; s < i; ) {
      this.posOut >= r && this.keccak()
      const o = Math.min(r - this.posOut, i - s)
      e.set(n.subarray(this.posOut, this.posOut + o), s), (this.posOut += o), (s += o)
    }
    return e
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error('XOF is not possible for this instance')
    return this.writeInto(e)
  }
  xof(e) {
    return vf(e), this.xofInto(new Uint8Array(e))
  }
  digestInto(e) {
    if ((rO(e, this), this.finished)) throw new Error('digest() was already called')
    return this.writeInto(e), this.destroy(), e
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen))
  }
  destroy() {
    ;(this.destroyed = !0), this.state.fill(0)
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: s, rounds: i, enableXOF: o } = this
    return (
      e || (e = new cO(n, r, s, o, i)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = i),
      (e.suffix = r),
      (e.outputLen = s),
      (e.enableXOF = o),
      (e.destroyed = this.destroyed),
      e
    )
  }
}
const lZ = (t, e, n) => sO(() => new uZ(e, t, n)),
  dZ = lZ(1, 136, 256 / 8),
  hZ = 'https://rpc.walletconnect.org/v1'
function uO(t) {
  const e = `Ethereum Signed Message:
${t.length}`,
    n = new TextEncoder().encode(e + t)
  return '0x' + Buffer.from(dZ(n)).toString('hex')
}
async function fZ(t, e, n, r, s, i) {
  switch (n.t) {
    case 'eip191':
      return await pZ(t, e, n.s)
    case 'eip1271':
      return await gZ(t, e, n.s, r, s, i)
    default:
      throw new Error(
        `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n.t}`
      )
  }
}
async function pZ(t, e, n) {
  return (await yG({ hash: uO(e), signature: n })).toLowerCase() === t.toLowerCase()
}
async function gZ(t, e, n, r, s, i) {
  const o = Rl(r)
  if (!o.namespace || !o.reference)
    throw new Error(
      `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`
    )
  try {
    const a = '0x1626ba7e',
      c = '0000000000000000000000000000000000000000000000000000000000000040',
      u = '0000000000000000000000000000000000000000000000000000000000000041',
      l = n.substring(2),
      d = uO(e).substring(2),
      h = a + d + c + u + l,
      p = await fetch(`${i || hZ}/?chainId=${r}&projectId=${s}`, {
        method: 'POST',
        body: JSON.stringify({
          id: mZ(),
          jsonrpc: '2.0',
          method: 'eth_call',
          params: [{ to: t, data: h }, 'latest']
        })
      }),
      { result: y } = await p.json()
    return y ? y.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1
  } catch (a) {
    return console.error('isValidEip1271Signature: ', a), !1
  }
}
function mZ() {
  return Date.now() + Math.floor(Math.random() * 1e3)
}
function yZ(t) {
  const e = atob(t),
    n = new Uint8Array(e.length)
  for (let o = 0; o < e.length; o++) n[o] = e.charCodeAt(o)
  const r = n[0]
  if (r === 0) throw new Error('No signatures found')
  const s = 1 + r * 64
  if (n.length < s) throw new Error('Transaction data too short for claimed signature count')
  if (n.length < 100) throw new Error('Transaction too short')
  const i = Buffer.from(t, 'base64').slice(1, 65)
  return vs.encode(i)
}
var wZ = Object.defineProperty,
  bZ = Object.defineProperties,
  vZ = Object.getOwnPropertyDescriptors,
  xI = Object.getOwnPropertySymbols,
  EZ = Object.prototype.hasOwnProperty,
  AZ = Object.prototype.propertyIsEnumerable,
  TI = (t, e, n) =>
    e in t ? wZ(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  _Z = (t, e) => {
    for (var n in e || (e = {})) EZ.call(e, n) && TI(t, n, e[n])
    if (xI) for (var n of xI(e)) AZ.call(e, n) && TI(t, n, e[n])
    return t
  },
  CZ = (t, e) => bZ(t, vZ(e))
const SZ = 'did:pkh:',
  NA = t => (t == null ? void 0 : t.split(':')),
  IZ = t => {
    const e = t && NA(t)
    if (e) return t.includes(SZ) ? e[3] : e[1]
  },
  av = t => {
    const e = t && NA(t)
    if (e) return e[2] + ':' + e[3]
  },
  Am = t => {
    const e = t && NA(t)
    if (e) return e.pop()
  }
async function NI(t) {
  const { cacao: e, projectId: n } = t,
    { s: r, p: s } = e,
    i = lO(s, s.iss),
    o = Am(s.iss)
  return await fZ(o, i, r, av(s.iss), n)
}
const lO = (t, e) => {
  const n = `${t.domain} wants you to sign in with your Ethereum account:`,
    r = Am(e)
  if (!t.aud && !t.uri)
    throw new Error('Either `aud` or `uri` is required to construct the message')
  let s = t.statement || void 0
  const i = `URI: ${t.aud || t.uri}`,
    o = `Version: ${t.version}`,
    a = `Chain ID: ${IZ(e)}`,
    c = `Nonce: ${t.nonce}`,
    u = `Issued At: ${t.iat}`,
    l = t.exp ? `Expiration Time: ${t.exp}` : void 0,
    d = t.nbf ? `Not Before: ${t.nbf}` : void 0,
    h = t.requestId ? `Request ID: ${t.requestId}` : void 0,
    p = t.resources
      ? `Resources:${t.resources
          .map(
            m => `
- ${m}`
          )
          .join('')}`
      : void 0,
    y = Dg(t.resources)
  if (y) {
    const m = Ef(y)
    s = DZ(s, m)
  }
  return [n, r, '', s, '', i, o, a, c, u, l, d, h, p].filter(m => m != null).join(`
`)
}
function xZ(t) {
  return Buffer.from(JSON.stringify(t)).toString('base64')
}
function TZ(t) {
  return JSON.parse(Buffer.from(t, 'base64').toString('utf-8'))
}
function gu(t) {
  if (!t) throw new Error('No recap provided, value is undefined')
  if (!t.att) throw new Error('No `att` property found')
  const e = Object.keys(t.att)
  if (!(e != null && e.length)) throw new Error('No resources found in `att` property')
  e.forEach(n => {
    const r = t.att[n]
    if (Array.isArray(r)) throw new Error(`Resource must be an object: ${n}`)
    if (typeof r != 'object') throw new Error(`Resource must be an object: ${n}`)
    if (!Object.keys(r).length) throw new Error(`Resource object is empty: ${n}`)
    Object.keys(r).forEach(s => {
      const i = r[s]
      if (!Array.isArray(i))
        throw new Error(`Ability limits ${s} must be an array of objects, found: ${i}`)
      if (!i.length) throw new Error(`Value of ${s} is empty array, must be an array with objects`)
      i.forEach(o => {
        if (typeof o != 'object')
          throw new Error(`Ability limits (${s}) must be an array of objects, found: ${o}`)
      })
    })
  })
}
function NZ(t, e, n, r = {}) {
  return n == null || n.sort((s, i) => s.localeCompare(i)), { att: { [t]: PZ(e, n, r) } }
}
function PZ(t, e, n = {}) {
  e = e == null ? void 0 : e.sort((s, i) => s.localeCompare(i))
  const r = e.map(s => ({ [`${t}/${s}`]: [n] }))
  return Object.assign({}, ...r)
}
function dO(t) {
  return gu(t), `urn:recap:${xZ(t).replace(/=/g, '')}`
}
function Ef(t) {
  const e = TZ(t.replace('urn:recap:', ''))
  return gu(e), e
}
function RZ(t, e, n) {
  const r = NZ(t, e, n)
  return dO(r)
}
function kZ(t) {
  return t && t.includes('urn:recap:')
}
function OZ(t, e) {
  const n = Ef(t),
    r = Ef(e),
    s = BZ(n, r)
  return dO(s)
}
function BZ(t, e) {
  gu(t), gu(e)
  const n = Object.keys(t.att)
      .concat(Object.keys(e.att))
      .sort((s, i) => s.localeCompare(i)),
    r = { att: {} }
  return (
    n.forEach(s => {
      var i, o
      Object.keys(((i = t.att) == null ? void 0 : i[s]) || {})
        .concat(Object.keys(((o = e.att) == null ? void 0 : o[s]) || {}))
        .sort((a, c) => a.localeCompare(c))
        .forEach(a => {
          var c, u
          r.att[s] = CZ(_Z({}, r.att[s]), {
            [a]:
              ((c = t.att[s]) == null ? void 0 : c[a]) || ((u = e.att[s]) == null ? void 0 : u[a])
          })
        })
    }),
    r
  )
}
function DZ(t = '', e) {
  gu(e)
  const n = 'I further authorize the stated URI to perform the following actions on my behalf: '
  if (t.includes(n)) return t
  const r = []
  let s = 0
  Object.keys(e.att).forEach(a => {
    const c = Object.keys(e.att[a]).map(d => ({
      ability: d.split('/')[0],
      action: d.split('/')[1]
    }))
    c.sort((d, h) => d.action.localeCompare(h.action))
    const u = {}
    c.forEach(d => {
      u[d.ability] || (u[d.ability] = []), u[d.ability].push(d.action)
    })
    const l = Object.keys(u).map(d => (s++, `(${s}) '${d}': '${u[d].join("', '")}' for '${a}'.`))
    r.push(l.join(', ').replace('.,', '.'))
  })
  const i = r.join(' '),
    o = `${n}${i}`
  return `${t ? t + ' ' : ''}${o}`
}
function PI(t) {
  var e
  const n = Ef(t)
  gu(n)
  const r = (e = n.att) == null ? void 0 : e.eip155
  return r ? Object.keys(r).map(s => s.split('/')[1]) : []
}
function RI(t) {
  const e = Ef(t)
  gu(e)
  const n = []
  return (
    Object.values(e.att).forEach(r => {
      Object.values(r).forEach(s => {
        var i
        ;(i = s == null ? void 0 : s[0]) != null && i.chains && n.push(s[0].chains)
      })
    }),
    [...new Set(n.flat())]
  )
}
function Dg(t) {
  if (!t) return
  const e = t == null ? void 0 : t[t.length - 1]
  return kZ(e) ? e : void 0
}
function Hw(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error('positive integer expected, got ' + t)
}
function hO(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function Ms(t, ...e) {
  if (!hO(t)) throw new Error('Uint8Array expected')
  if (e.length > 0 && !e.includes(t.length))
    throw new Error('Uint8Array expected of length ' + e + ', got length=' + t.length)
}
function kI(t, e = !0) {
  if (t.destroyed) throw new Error('Hash instance has been destroyed')
  if (e && t.finished) throw new Error('Hash#digest() has already been called')
}
function MZ(t, e) {
  Ms(t)
  const n = e.outputLen
  if (t.length < n) throw new Error('digestInto() expects output buffer of length at least ' + n)
}
function OI(t) {
  if (typeof t != 'boolean') throw new Error(`boolean expected, not ${t}`)
}
const za = t => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),
  UZ = t => new DataView(t.buffer, t.byteOffset, t.byteLength),
  LZ = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68
if (!LZ) throw new Error('Non little-endian hardware is not supported')
function $Z(t) {
  if (typeof t != 'string') throw new Error('string expected')
  return new Uint8Array(new TextEncoder().encode(t))
}
function cv(t) {
  if (typeof t == 'string') t = $Z(t)
  else if (hO(t)) t = uv(t)
  else throw new Error('Uint8Array expected, got ' + typeof t)
  return t
}
function FZ(t, e) {
  if (e == null || typeof e != 'object') throw new Error('options must be defined')
  return Object.assign(t, e)
}
function jZ(t, e) {
  if (t.length !== e.length) return !1
  let n = 0
  for (let r = 0; r < t.length; r++) n |= t[r] ^ e[r]
  return n === 0
}
const HZ = (t, e) => {
  function n(r, ...s) {
    if ((Ms(r), t.nonceLength !== void 0)) {
      const u = s[0]
      if (!u) throw new Error('nonce / iv required')
      t.varSizeNonce ? Ms(u) : Ms(u, t.nonceLength)
    }
    const i = t.tagLength
    i && s[1] !== void 0 && Ms(s[1])
    const o = e(r, ...s),
      a = (u, l) => {
        if (l !== void 0) {
          if (u !== 2) throw new Error('cipher output not supported')
          Ms(l)
        }
      }
    let c = !1
    return {
      encrypt(u, l) {
        if (c) throw new Error('cannot encrypt() twice with same key + nonce')
        return (c = !0), Ms(u), a(o.encrypt.length, l), o.encrypt(u, l)
      },
      decrypt(u, l) {
        if ((Ms(u), i && u.length < i))
          throw new Error('invalid ciphertext length: smaller than tagLength=' + i)
        return a(o.decrypt.length, l), o.decrypt(u, l)
      }
    }
  }
  return Object.assign(n, t), n
}
function BI(t, e, n = !0) {
  if (e === void 0) return new Uint8Array(t)
  if (e.length !== t) throw new Error('invalid output length, expected ' + t + ', got: ' + e.length)
  if (n && !qZ(e)) throw new Error('invalid output, must be aligned')
  return e
}
function DI(t, e, n, r) {
  if (typeof t.setBigUint64 == 'function') return t.setBigUint64(e, n, r)
  const s = BigInt(32),
    i = BigInt(4294967295),
    o = Number((n >> s) & i),
    a = Number(n & i)
  t.setUint32(e + 4, o, r), t.setUint32(e + 0, a, r)
}
function qZ(t) {
  return t.byteOffset % 4 === 0
}
function uv(t) {
  return Uint8Array.from(t)
}
function nd(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0)
}
const fO = t => Uint8Array.from(t.split('').map(e => e.charCodeAt(0))),
  zZ = fO('expand 16-byte k'),
  WZ = fO('expand 32-byte k'),
  KZ = za(zZ),
  VZ = za(WZ)
function Wt(t, e) {
  return (t << e) | (t >>> (32 - e))
}
function lv(t) {
  return t.byteOffset % 4 === 0
}
const og = 64,
  GZ = 16,
  pO = 2 ** 32 - 1,
  MI = new Uint32Array()
function QZ(t, e, n, r, s, i, o, a) {
  const c = s.length,
    u = new Uint8Array(og),
    l = za(u),
    d = lv(s) && lv(i),
    h = d ? za(s) : MI,
    p = d ? za(i) : MI
  for (let y = 0; y < c; o++) {
    if ((t(e, n, r, l, o, a), o >= pO)) throw new Error('arx: counter overflow')
    const m = Math.min(og, c - y)
    if (d && m === og) {
      const b = y / 4
      if (y % 4 !== 0) throw new Error('arx: invalid block position')
      for (let I = 0, x; I < GZ; I++) (x = b + I), (p[x] = h[x] ^ l[I])
      y += og
      continue
    }
    for (let b = 0, I; b < m; b++) (I = y + b), (i[I] = s[I] ^ u[b])
    y += m
  }
}
function ZZ(t, e) {
  const {
    allowShortKeys: n,
    extendNonceFn: r,
    counterLength: s,
    counterRight: i,
    rounds: o
  } = FZ({ allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 }, e)
  if (typeof t != 'function') throw new Error('core must be a function')
  return (
    Hw(s),
    Hw(o),
    OI(i),
    OI(n),
    (a, c, u, l, d = 0) => {
      Ms(a), Ms(c), Ms(u)
      const h = u.length
      if ((l === void 0 && (l = new Uint8Array(h)), Ms(l), Hw(d), d < 0 || d >= pO))
        throw new Error('arx: counter overflow')
      if (l.length < h) throw new Error(`arx: output (${l.length}) is shorter than data (${h})`)
      const p = []
      let y = a.length,
        m,
        b
      if (y === 32) p.push((m = uv(a))), (b = VZ)
      else if (y === 16 && n) (m = new Uint8Array(32)), m.set(a), m.set(a, 16), (b = KZ), p.push(m)
      else throw new Error(`arx: invalid 32-byte key, got length=${y}`)
      lv(c) || p.push((c = uv(c)))
      const I = za(m)
      if (r) {
        if (c.length !== 24) throw new Error('arx: extended nonce must be 24 bytes')
        r(b, I, za(c.subarray(0, 16)), I), (c = c.subarray(16))
      }
      const x = 16 - s
      if (x !== c.length) throw new Error(`arx: nonce must be ${x} or 16 bytes`)
      if (x !== 12) {
        const R = new Uint8Array(12)
        R.set(c, i ? 0 : 12 - c.length), (c = R), p.push(c)
      }
      const _ = za(c)
      return QZ(t, b, I, _, u, l, d, o), nd(...p), l
    }
  )
}
const Er = (t, e) => (t[e++] & 255) | ((t[e++] & 255) << 8)
class YZ {
  constructor(e) {
    ;(this.blockLen = 16),
      (this.outputLen = 16),
      (this.buffer = new Uint8Array(16)),
      (this.r = new Uint16Array(10)),
      (this.h = new Uint16Array(10)),
      (this.pad = new Uint16Array(8)),
      (this.pos = 0),
      (this.finished = !1),
      (e = cv(e)),
      Ms(e, 32)
    const n = Er(e, 0),
      r = Er(e, 2),
      s = Er(e, 4),
      i = Er(e, 6),
      o = Er(e, 8),
      a = Er(e, 10),
      c = Er(e, 12),
      u = Er(e, 14)
    ;(this.r[0] = n & 8191),
      (this.r[1] = ((n >>> 13) | (r << 3)) & 8191),
      (this.r[2] = ((r >>> 10) | (s << 6)) & 7939),
      (this.r[3] = ((s >>> 7) | (i << 9)) & 8191),
      (this.r[4] = ((i >>> 4) | (o << 12)) & 255),
      (this.r[5] = (o >>> 1) & 8190),
      (this.r[6] = ((o >>> 14) | (a << 2)) & 8191),
      (this.r[7] = ((a >>> 11) | (c << 5)) & 8065),
      (this.r[8] = ((c >>> 8) | (u << 8)) & 8191),
      (this.r[9] = (u >>> 5) & 127)
    for (let l = 0; l < 8; l++) this.pad[l] = Er(e, 16 + 2 * l)
  }
  process(e, n, r = !1) {
    const s = r ? 0 : 2048,
      { h: i, r: o } = this,
      a = o[0],
      c = o[1],
      u = o[2],
      l = o[3],
      d = o[4],
      h = o[5],
      p = o[6],
      y = o[7],
      m = o[8],
      b = o[9],
      I = Er(e, n + 0),
      x = Er(e, n + 2),
      _ = Er(e, n + 4),
      R = Er(e, n + 6),
      N = Er(e, n + 8),
      T = Er(e, n + 10),
      M = Er(e, n + 12),
      H = Er(e, n + 14)
    let B = i[0] + (I & 8191),
      $ = i[1] + (((I >>> 13) | (x << 3)) & 8191),
      D = i[2] + (((x >>> 10) | (_ << 6)) & 8191),
      W = i[3] + (((_ >>> 7) | (R << 9)) & 8191),
      U = i[4] + (((R >>> 4) | (N << 12)) & 8191),
      w = i[5] + ((N >>> 1) & 8191),
      v = i[6] + (((N >>> 14) | (T << 2)) & 8191),
      A = i[7] + (((T >>> 11) | (M << 5)) & 8191),
      P = i[8] + (((M >>> 8) | (H << 8)) & 8191),
      O = i[9] + ((H >>> 5) | s),
      F = 0,
      z = F + B * a + $ * (5 * b) + D * (5 * m) + W * (5 * y) + U * (5 * p)
    ;(F = z >>> 13),
      (z &= 8191),
      (z += w * (5 * h) + v * (5 * d) + A * (5 * l) + P * (5 * u) + O * (5 * c)),
      (F += z >>> 13),
      (z &= 8191)
    let j = F + B * c + $ * a + D * (5 * b) + W * (5 * m) + U * (5 * y)
    ;(F = j >>> 13),
      (j &= 8191),
      (j += w * (5 * p) + v * (5 * h) + A * (5 * d) + P * (5 * l) + O * (5 * u)),
      (F += j >>> 13),
      (j &= 8191)
    let E = F + B * u + $ * c + D * a + W * (5 * b) + U * (5 * m)
    ;(F = E >>> 13),
      (E &= 8191),
      (E += w * (5 * y) + v * (5 * p) + A * (5 * h) + P * (5 * d) + O * (5 * l)),
      (F += E >>> 13),
      (E &= 8191)
    let C = F + B * l + $ * u + D * c + W * a + U * (5 * b)
    ;(F = C >>> 13),
      (C &= 8191),
      (C += w * (5 * m) + v * (5 * y) + A * (5 * p) + P * (5 * h) + O * (5 * d)),
      (F += C >>> 13),
      (C &= 8191)
    let L = F + B * d + $ * l + D * u + W * c + U * a
    ;(F = L >>> 13),
      (L &= 8191),
      (L += w * (5 * b) + v * (5 * m) + A * (5 * y) + P * (5 * p) + O * (5 * h)),
      (F += L >>> 13),
      (L &= 8191)
    let K = F + B * h + $ * d + D * l + W * u + U * c
    ;(F = K >>> 13),
      (K &= 8191),
      (K += w * a + v * (5 * b) + A * (5 * m) + P * (5 * y) + O * (5 * p)),
      (F += K >>> 13),
      (K &= 8191)
    let ee = F + B * p + $ * h + D * d + W * l + U * u
    ;(F = ee >>> 13),
      (ee &= 8191),
      (ee += w * c + v * a + A * (5 * b) + P * (5 * m) + O * (5 * y)),
      (F += ee >>> 13),
      (ee &= 8191)
    let oe = F + B * y + $ * p + D * h + W * d + U * l
    ;(F = oe >>> 13),
      (oe &= 8191),
      (oe += w * u + v * c + A * a + P * (5 * b) + O * (5 * m)),
      (F += oe >>> 13),
      (oe &= 8191)
    let fe = F + B * m + $ * y + D * p + W * h + U * d
    ;(F = fe >>> 13),
      (fe &= 8191),
      (fe += w * l + v * u + A * c + P * a + O * (5 * b)),
      (F += fe >>> 13),
      (fe &= 8191)
    let ve = F + B * b + $ * m + D * y + W * p + U * h
    ;(F = ve >>> 13),
      (ve &= 8191),
      (ve += w * d + v * l + A * u + P * c + O * a),
      (F += ve >>> 13),
      (ve &= 8191),
      (F = ((F << 2) + F) | 0),
      (F = (F + z) | 0),
      (z = F & 8191),
      (F = F >>> 13),
      (j += F),
      (i[0] = z),
      (i[1] = j),
      (i[2] = E),
      (i[3] = C),
      (i[4] = L),
      (i[5] = K),
      (i[6] = ee),
      (i[7] = oe),
      (i[8] = fe),
      (i[9] = ve)
  }
  finalize() {
    const { h: e, pad: n } = this,
      r = new Uint16Array(10)
    let s = e[1] >>> 13
    e[1] &= 8191
    for (let a = 2; a < 10; a++) (e[a] += s), (s = e[a] >>> 13), (e[a] &= 8191)
    ;(e[0] += s * 5),
      (s = e[0] >>> 13),
      (e[0] &= 8191),
      (e[1] += s),
      (s = e[1] >>> 13),
      (e[1] &= 8191),
      (e[2] += s),
      (r[0] = e[0] + 5),
      (s = r[0] >>> 13),
      (r[0] &= 8191)
    for (let a = 1; a < 10; a++) (r[a] = e[a] + s), (s = r[a] >>> 13), (r[a] &= 8191)
    r[9] -= 8192
    let i = (s ^ 1) - 1
    for (let a = 0; a < 10; a++) r[a] &= i
    i = ~i
    for (let a = 0; a < 10; a++) e[a] = (e[a] & i) | r[a]
    ;(e[0] = (e[0] | (e[1] << 13)) & 65535),
      (e[1] = ((e[1] >>> 3) | (e[2] << 10)) & 65535),
      (e[2] = ((e[2] >>> 6) | (e[3] << 7)) & 65535),
      (e[3] = ((e[3] >>> 9) | (e[4] << 4)) & 65535),
      (e[4] = ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14)) & 65535),
      (e[5] = ((e[6] >>> 2) | (e[7] << 11)) & 65535),
      (e[6] = ((e[7] >>> 5) | (e[8] << 8)) & 65535),
      (e[7] = ((e[8] >>> 8) | (e[9] << 5)) & 65535)
    let o = e[0] + n[0]
    e[0] = o & 65535
    for (let a = 1; a < 8; a++) (o = (((e[a] + n[a]) | 0) + (o >>> 16)) | 0), (e[a] = o & 65535)
    nd(r)
  }
  update(e) {
    kI(this)
    const { buffer: n, blockLen: r } = this
    e = cv(e)
    const s = e.length
    for (let i = 0; i < s; ) {
      const o = Math.min(r - this.pos, s - i)
      if (o === r) {
        for (; r <= s - i; i += r) this.process(e, i)
        continue
      }
      n.set(e.subarray(i, i + o), this.pos),
        (this.pos += o),
        (i += o),
        this.pos === r && (this.process(n, 0, !1), (this.pos = 0))
    }
    return this
  }
  destroy() {
    nd(this.h, this.r, this.buffer, this.pad)
  }
  digestInto(e) {
    kI(this), MZ(e, this), (this.finished = !0)
    const { buffer: n, h: r } = this
    let { pos: s } = this
    if (s) {
      for (n[s++] = 1; s < 16; s++) n[s] = 0
      this.process(n, 0, !0)
    }
    this.finalize()
    let i = 0
    for (let o = 0; o < 8; o++) (e[i++] = r[o] >>> 0), (e[i++] = r[o] >>> 8)
    return e
  }
  digest() {
    const { buffer: e, outputLen: n } = this
    this.digestInto(e)
    const r = e.slice(0, n)
    return this.destroy(), r
  }
}
function JZ(t) {
  const e = (r, s) => t(s).update(cv(r)).digest(),
    n = t(new Uint8Array(32))
  return (e.outputLen = n.outputLen), (e.blockLen = n.blockLen), (e.create = r => t(r)), e
}
const XZ = JZ(t => new YZ(t))
function eY(t, e, n, r, s, i = 20) {
  let o = t[0],
    a = t[1],
    c = t[2],
    u = t[3],
    l = e[0],
    d = e[1],
    h = e[2],
    p = e[3],
    y = e[4],
    m = e[5],
    b = e[6],
    I = e[7],
    x = s,
    _ = n[0],
    R = n[1],
    N = n[2],
    T = o,
    M = a,
    H = c,
    B = u,
    $ = l,
    D = d,
    W = h,
    U = p,
    w = y,
    v = m,
    A = b,
    P = I,
    O = x,
    F = _,
    z = R,
    j = N
  for (let C = 0; C < i; C += 2)
    (T = (T + $) | 0),
      (O = Wt(O ^ T, 16)),
      (w = (w + O) | 0),
      ($ = Wt($ ^ w, 12)),
      (T = (T + $) | 0),
      (O = Wt(O ^ T, 8)),
      (w = (w + O) | 0),
      ($ = Wt($ ^ w, 7)),
      (M = (M + D) | 0),
      (F = Wt(F ^ M, 16)),
      (v = (v + F) | 0),
      (D = Wt(D ^ v, 12)),
      (M = (M + D) | 0),
      (F = Wt(F ^ M, 8)),
      (v = (v + F) | 0),
      (D = Wt(D ^ v, 7)),
      (H = (H + W) | 0),
      (z = Wt(z ^ H, 16)),
      (A = (A + z) | 0),
      (W = Wt(W ^ A, 12)),
      (H = (H + W) | 0),
      (z = Wt(z ^ H, 8)),
      (A = (A + z) | 0),
      (W = Wt(W ^ A, 7)),
      (B = (B + U) | 0),
      (j = Wt(j ^ B, 16)),
      (P = (P + j) | 0),
      (U = Wt(U ^ P, 12)),
      (B = (B + U) | 0),
      (j = Wt(j ^ B, 8)),
      (P = (P + j) | 0),
      (U = Wt(U ^ P, 7)),
      (T = (T + D) | 0),
      (j = Wt(j ^ T, 16)),
      (A = (A + j) | 0),
      (D = Wt(D ^ A, 12)),
      (T = (T + D) | 0),
      (j = Wt(j ^ T, 8)),
      (A = (A + j) | 0),
      (D = Wt(D ^ A, 7)),
      (M = (M + W) | 0),
      (O = Wt(O ^ M, 16)),
      (P = (P + O) | 0),
      (W = Wt(W ^ P, 12)),
      (M = (M + W) | 0),
      (O = Wt(O ^ M, 8)),
      (P = (P + O) | 0),
      (W = Wt(W ^ P, 7)),
      (H = (H + U) | 0),
      (F = Wt(F ^ H, 16)),
      (w = (w + F) | 0),
      (U = Wt(U ^ w, 12)),
      (H = (H + U) | 0),
      (F = Wt(F ^ H, 8)),
      (w = (w + F) | 0),
      (U = Wt(U ^ w, 7)),
      (B = (B + $) | 0),
      (z = Wt(z ^ B, 16)),
      (v = (v + z) | 0),
      ($ = Wt($ ^ v, 12)),
      (B = (B + $) | 0),
      (z = Wt(z ^ B, 8)),
      (v = (v + z) | 0),
      ($ = Wt($ ^ v, 7))
  let E = 0
  ;(r[E++] = (o + T) | 0),
    (r[E++] = (a + M) | 0),
    (r[E++] = (c + H) | 0),
    (r[E++] = (u + B) | 0),
    (r[E++] = (l + $) | 0),
    (r[E++] = (d + D) | 0),
    (r[E++] = (h + W) | 0),
    (r[E++] = (p + U) | 0),
    (r[E++] = (y + w) | 0),
    (r[E++] = (m + v) | 0),
    (r[E++] = (b + A) | 0),
    (r[E++] = (I + P) | 0),
    (r[E++] = (x + O) | 0),
    (r[E++] = (_ + F) | 0),
    (r[E++] = (R + z) | 0),
    (r[E++] = (N + j) | 0)
}
const tY = ZZ(eY, { counterRight: !1, counterLength: 4, allowShortKeys: !1 }),
  nY = new Uint8Array(16),
  UI = (t, e) => {
    t.update(e)
    const n = e.length % 16
    n && t.update(nY.subarray(n))
  },
  rY = new Uint8Array(32)
function LI(t, e, n, r, s) {
  const i = t(e, n, rY),
    o = XZ.create(i)
  s && UI(o, s), UI(o, r)
  const a = new Uint8Array(16),
    c = UZ(a)
  DI(c, 0, BigInt(s ? s.length : 0), !0), DI(c, 8, BigInt(r.length), !0), o.update(a)
  const u = o.digest()
  return nd(i, a), u
}
const sY = t => (e, n, r) => ({
    encrypt(s, i) {
      const o = s.length
      ;(i = BI(o + 16, i, !1)), i.set(s)
      const a = i.subarray(0, -16)
      t(e, n, a, a, 1)
      const c = LI(t, e, n, a, r)
      return i.set(c, o), nd(c), i
    },
    decrypt(s, i) {
      i = BI(s.length - 16, i, !1)
      const o = s.subarray(0, -16),
        a = s.subarray(-16),
        c = LI(t, e, n, o, r)
      if (!jZ(a, c)) throw new Error('invalid tag')
      return i.set(s.subarray(0, -16)), t(e, n, i, i, 1), nd(c), i
    }
  }),
  gO = HZ({ blockSize: 64, nonceLength: 12, tagLength: 16 }, sY(tY))
let mO = class extends TA {
  constructor(e, n) {
    super(), (this.finished = !1), (this.destroyed = !1), xA(e)
    const r = td(n)
    if (((this.iHash = e.create()), typeof this.iHash.update != 'function'))
      throw new Error('Expected instance of class which extends utils.Hash')
    ;(this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen)
    const s = this.blockLen,
      i = new Uint8Array(s)
    i.set(r.length > s ? e.create().update(r).digest() : r)
    for (let o = 0; o < i.length; o++) i[o] ^= 54
    this.iHash.update(i), (this.oHash = e.create())
    for (let o = 0; o < i.length; o++) i[o] ^= 106
    this.oHash.update(i), i.fill(0)
  }
  update(e) {
    return ed(this), this.iHash.update(e), this
  }
  digestInto(e) {
    ed(this),
      yp(e, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(e),
      this.oHash.update(e),
      this.oHash.digestInto(e),
      this.destroy()
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen)
    return this.digestInto(e), e
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}))
    const { oHash: n, iHash: r, finished: s, destroyed: i, blockLen: o, outputLen: a } = this
    return (
      (e = e),
      (e.finished = s),
      (e.destroyed = i),
      (e.blockLen = o),
      (e.outputLen = a),
      (e.oHash = n._cloneInto(e.oHash)),
      (e.iHash = r._cloneInto(e.iHash)),
      e
    )
  }
  destroy() {
    ;(this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy()
  }
}
const U0 = (t, e, n) => new mO(t, e).update(n).digest()
U0.create = (t, e) => new mO(t, e)
function iY(t, e, n) {
  return xA(t), n === void 0 && (n = new Uint8Array(t.outputLen)), U0(t, td(n), td(e))
}
const qw = new Uint8Array([0]),
  $I = new Uint8Array()
function oY(t, e, n, r = 32) {
  if ((xA(t), vf(r), r > 255 * t.outputLen)) throw new Error('Length should be <= 255*HashLen')
  const s = Math.ceil(r / t.outputLen)
  n === void 0 && (n = $I)
  const i = new Uint8Array(s * t.outputLen),
    o = U0.create(t, e),
    a = o._cloneInto(),
    c = new Uint8Array(o.outputLen)
  for (let u = 0; u < s; u++)
    (qw[0] = u + 1),
      a
        .update(u === 0 ? $I : c)
        .update(n)
        .update(qw)
        .digestInto(c),
      i.set(c, t.outputLen * u),
      o._cloneInto(a)
  return o.destroy(), a.destroy(), c.fill(0), qw.fill(0), i.slice(0, r)
}
const aY = (t, e, n, r, s) => oY(t, iY(t, e, n), r, s)
function cY(t, e, n, r) {
  if (typeof t.setBigUint64 == 'function') return t.setBigUint64(e, n, r)
  const s = BigInt(32),
    i = BigInt(4294967295),
    o = Number((n >> s) & i),
    a = Number(n & i),
    c = r ? 4 : 0,
    u = r ? 0 : 4
  t.setUint32(e + c, o, r), t.setUint32(e + u, a, r)
}
function uY(t, e, n) {
  return (t & e) ^ (~t & n)
}
function lY(t, e, n) {
  return (t & e) ^ (t & n) ^ (e & n)
}
let dY = class extends TA {
  constructor(e, n, r, s) {
    super(),
      (this.blockLen = e),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = s),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(e)),
      (this.view = jw(this.buffer))
  }
  update(e) {
    ed(this)
    const { view: n, buffer: r, blockLen: s } = this
    e = td(e)
    const i = e.length
    for (let o = 0; o < i; ) {
      const a = Math.min(s - this.pos, i - o)
      if (a === s) {
        const c = jw(e)
        for (; s <= i - o; o += s) this.process(c, o)
        continue
      }
      r.set(e.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === s && (this.process(n, 0), (this.pos = 0))
    }
    return (this.length += e.length), this.roundClean(), this
  }
  digestInto(e) {
    ed(this), rO(e, this), (this.finished = !0)
    const { buffer: n, view: r, blockLen: s, isLE: i } = this
    let { pos: o } = this
    ;(n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > s - o && (this.process(r, 0), (o = 0))
    for (let d = o; d < s; d++) n[d] = 0
    cY(r, s - 8, BigInt(this.length * 8), i), this.process(r, 0)
    const a = jw(e),
      c = this.outputLen
    if (c % 4) throw new Error('_sha2: outputLen should be aligned to 32bit')
    const u = c / 4,
      l = this.get()
    if (u > l.length) throw new Error('_sha2: outputLen bigger than state')
    for (let d = 0; d < u; d++) a.setUint32(4 * d, l[d], i)
  }
  digest() {
    const { buffer: e, outputLen: n } = this
    this.digestInto(e)
    const r = e.slice(0, n)
    return this.destroy(), r
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get())
    const { blockLen: n, buffer: r, length: s, finished: i, destroyed: o, pos: a } = this
    return (
      (e.length = s), (e.pos = a), (e.finished = i), (e.destroyed = o), s % n && e.buffer.set(r), e
    )
  }
}
const hY = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
    3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
    2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
    1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298
  ]),
  la = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225
  ]),
  da = new Uint32Array(64)
class fY extends dY {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = la[0] | 0),
      (this.B = la[1] | 0),
      (this.C = la[2] | 0),
      (this.D = la[3] | 0),
      (this.E = la[4] | 0),
      (this.F = la[5] | 0),
      (this.G = la[6] | 0),
      (this.H = la[7] | 0)
  }
  get() {
    const { A: e, B: n, C: r, D: s, E: i, F: o, G: a, H: c } = this
    return [e, n, r, s, i, o, a, c]
  }
  set(e, n, r, s, i, o, a, c) {
    ;(this.A = e | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = s | 0),
      (this.E = i | 0),
      (this.F = o | 0),
      (this.G = a | 0),
      (this.H = c | 0)
  }
  process(e, n) {
    for (let d = 0; d < 16; d++, n += 4) da[d] = e.getUint32(n, !1)
    for (let d = 16; d < 64; d++) {
      const h = da[d - 15],
        p = da[d - 2],
        y = $i(h, 7) ^ $i(h, 18) ^ (h >>> 3),
        m = $i(p, 17) ^ $i(p, 19) ^ (p >>> 10)
      da[d] = (m + da[d - 7] + y + da[d - 16]) | 0
    }
    let { A: r, B: s, C: i, D: o, E: a, F: c, G: u, H: l } = this
    for (let d = 0; d < 64; d++) {
      const h = $i(a, 6) ^ $i(a, 11) ^ $i(a, 25),
        p = (l + h + uY(a, c, u) + hY[d] + da[d]) | 0,
        y = (($i(r, 2) ^ $i(r, 13) ^ $i(r, 22)) + lY(r, s, i)) | 0
      ;(l = u), (u = c), (c = a), (a = (o + p) | 0), (o = i), (i = s), (s = r), (r = (p + y) | 0)
    }
    ;(r = (r + this.A) | 0),
      (s = (s + this.B) | 0),
      (i = (i + this.C) | 0),
      (o = (o + this.D) | 0),
      (a = (a + this.E) | 0),
      (c = (c + this.F) | 0),
      (u = (u + this.G) | 0),
      (l = (l + this.H) | 0),
      this.set(r, s, i, o, a, c, u, l)
  }
  roundClean() {
    da.fill(0)
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
  }
}
const wp = sO(() => new fY())
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const L0 = BigInt(0),
  $0 = BigInt(1),
  pY = BigInt(2)
function mu(t) {
  return t instanceof Uint8Array || (ArrayBuffer.isView(t) && t.constructor.name === 'Uint8Array')
}
function bp(t) {
  if (!mu(t)) throw new Error('Uint8Array expected')
}
function rd(t, e) {
  if (typeof e != 'boolean') throw new Error(t + ' boolean expected, got ' + e)
}
const gY = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, '0'))
function sd(t) {
  bp(t)
  let e = ''
  for (let n = 0; n < t.length; n++) e += gY[t[n]]
  return e
}
function gl(t) {
  const e = t.toString(16)
  return e.length & 1 ? '0' + e : e
}
function PA(t) {
  if (typeof t != 'string') throw new Error('hex string expected, got ' + typeof t)
  return t === '' ? L0 : BigInt('0x' + t)
}
const xo = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }
function FI(t) {
  if (t >= xo._0 && t <= xo._9) return t - xo._0
  if (t >= xo.A && t <= xo.F) return t - (xo.A - 10)
  if (t >= xo.a && t <= xo.f) return t - (xo.a - 10)
}
function id(t) {
  if (typeof t != 'string') throw new Error('hex string expected, got ' + typeof t)
  const e = t.length,
    n = e / 2
  if (e % 2) throw new Error('hex string expected, got unpadded hex of length ' + e)
  const r = new Uint8Array(n)
  for (let s = 0, i = 0; s < n; s++, i += 2) {
    const o = FI(t.charCodeAt(i)),
      a = FI(t.charCodeAt(i + 1))
    if (o === void 0 || a === void 0) {
      const c = t[i] + t[i + 1]
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + i)
    }
    r[s] = o * 16 + a
  }
  return r
}
function Xc(t) {
  return PA(sd(t))
}
function Af(t) {
  return bp(t), PA(sd(Uint8Array.from(t).reverse()))
}
function od(t, e) {
  return id(t.toString(16).padStart(e * 2, '0'))
}
function F0(t, e) {
  return od(t, e).reverse()
}
function mY(t) {
  return id(gl(t))
}
function Ds(t, e, n) {
  let r
  if (typeof e == 'string')
    try {
      r = id(e)
    } catch (i) {
      throw new Error(t + ' must be hex string or Uint8Array, cause: ' + i)
    }
  else if (mu(e)) r = Uint8Array.from(e)
  else throw new Error(t + ' must be hex string or Uint8Array')
  const s = r.length
  if (typeof n == 'number' && s !== n)
    throw new Error(t + ' of length ' + n + ' expected, got ' + s)
  return r
}
function _f(...t) {
  let e = 0
  for (let r = 0; r < t.length; r++) {
    const s = t[r]
    bp(s), (e += s.length)
  }
  const n = new Uint8Array(e)
  for (let r = 0, s = 0; r < t.length; r++) {
    const i = t[r]
    n.set(i, s), (s += i.length)
  }
  return n
}
function yY(t, e) {
  if (t.length !== e.length) return !1
  let n = 0
  for (let r = 0; r < t.length; r++) n |= t[r] ^ e[r]
  return n === 0
}
function wY(t) {
  if (typeof t != 'string') throw new Error('string expected')
  return new Uint8Array(new TextEncoder().encode(t))
}
const zw = t => typeof t == 'bigint' && L0 <= t
function j0(t, e, n) {
  return zw(t) && zw(e) && zw(n) && e <= t && t < n
}
function Vo(t, e, n, r) {
  if (!j0(e, n, r))
    throw new Error('expected valid ' + t + ': ' + n + ' <= n < ' + r + ', got ' + e)
}
function yO(t) {
  let e
  for (e = 0; t > L0; t >>= $0, e += 1);
  return e
}
function bY(t, e) {
  return (t >> BigInt(e)) & $0
}
function vY(t, e, n) {
  return t | ((n ? $0 : L0) << BigInt(e))
}
const RA = t => (pY << BigInt(t - 1)) - $0,
  Ww = t => new Uint8Array(t),
  jI = t => Uint8Array.from(t)
function wO(t, e, n) {
  if (typeof t != 'number' || t < 2) throw new Error('hashLen must be a number')
  if (typeof e != 'number' || e < 2) throw new Error('qByteLen must be a number')
  if (typeof n != 'function') throw new Error('hmacFn must be a function')
  let r = Ww(t),
    s = Ww(t),
    i = 0
  const o = () => {
      r.fill(1), s.fill(0), (i = 0)
    },
    a = (...l) => n(s, r, ...l),
    c = (l = Ww()) => {
      ;(s = a(jI([0]), l)), (r = a()), l.length !== 0 && ((s = a(jI([1]), l)), (r = a()))
    },
    u = () => {
      if (i++ >= 1e3) throw new Error('drbg: tried 1000 values')
      let l = 0
      const d = []
      for (; l < e; ) {
        r = a()
        const h = r.slice()
        d.push(h), (l += r.length)
      }
      return _f(...d)
    }
  return (l, d) => {
    o(), c(l)
    let h
    for (; !(h = d(u())); ) c()
    return o(), h
  }
}
const EY = {
  bigint: t => typeof t == 'bigint',
  function: t => typeof t == 'function',
  boolean: t => typeof t == 'boolean',
  string: t => typeof t == 'string',
  stringOrUint8Array: t => typeof t == 'string' || mu(t),
  isSafeInteger: t => Number.isSafeInteger(t),
  array: t => Array.isArray(t),
  field: (t, e) => e.Fp.isValid(t),
  hash: t => typeof t == 'function' && Number.isSafeInteger(t.outputLen)
}
function Rd(t, e, n = {}) {
  const r = (s, i, o) => {
    const a = EY[i]
    if (typeof a != 'function') throw new Error('invalid validator function')
    const c = t[s]
    if (!(o && c === void 0) && !a(c, t))
      throw new Error('param ' + String(s) + ' is invalid. Expected ' + i + ', got ' + c)
  }
  for (const [s, i] of Object.entries(e)) r(s, i, !1)
  for (const [s, i] of Object.entries(n)) r(s, i, !0)
  return t
}
const AY = () => {
  throw new Error('not implemented')
}
function dv(t) {
  const e = new WeakMap()
  return (n, ...r) => {
    const s = e.get(n)
    if (s !== void 0) return s
    const i = t(n, ...r)
    return e.set(n, i), i
  }
}
var _Y = Object.freeze({
  __proto__: null,
  isBytes: mu,
  abytes: bp,
  abool: rd,
  bytesToHex: sd,
  numberToHexUnpadded: gl,
  hexToNumber: PA,
  hexToBytes: id,
  bytesToNumberBE: Xc,
  bytesToNumberLE: Af,
  numberToBytesBE: od,
  numberToBytesLE: F0,
  numberToVarBytesBE: mY,
  ensureBytes: Ds,
  concatBytes: _f,
  equalBytes: yY,
  utf8ToBytes: wY,
  inRange: j0,
  aInRange: Vo,
  bitLen: yO,
  bitGet: bY,
  bitSet: vY,
  bitMask: RA,
  createHmacDrbg: wO,
  validateObject: Rd,
  notImplemented: AY,
  memoized: dv
})
const yr = BigInt(0),
  Wn = BigInt(1),
  Rc = BigInt(2),
  CY = BigInt(3),
  hv = BigInt(4),
  HI = BigInt(5),
  qI = BigInt(8)
function bs(t, e) {
  const n = t % e
  return n >= yr ? n : e + n
}
function bO(t, e, n) {
  if (e < yr) throw new Error('invalid exponent, negatives unsupported')
  if (n <= yr) throw new Error('invalid modulus')
  if (n === Wn) return yr
  let r = Wn
  for (; e > yr; ) e & Wn && (r = (r * t) % n), (t = (t * t) % n), (e >>= Wn)
  return r
}
function wi(t, e, n) {
  let r = t
  for (; e-- > yr; ) (r *= r), (r %= n)
  return r
}
function fv(t, e) {
  if (t === yr) throw new Error('invert: expected non-zero number')
  if (e <= yr) throw new Error('invert: expected positive modulus, got ' + e)
  let n = bs(t, e),
    r = e,
    s = yr,
    i = Wn
  for (; n !== yr; ) {
    const o = r / n,
      a = r % n,
      c = s - i * o
    ;(r = n), (n = a), (s = i), (i = c)
  }
  if (r !== Wn) throw new Error('invert: does not exist')
  return bs(s, e)
}
function SY(t) {
  const e = (t - Wn) / Rc
  let n, r, s
  for (n = t - Wn, r = 0; n % Rc === yr; n /= Rc, r++);
  for (s = Rc; s < t && bO(s, e, t) !== t - Wn; s++)
    if (s > 1e3) throw new Error('Cannot find square root: likely non-prime P')
  if (r === 1) {
    const o = (t + Wn) / hv
    return function (a, c) {
      const u = a.pow(c, o)
      if (!a.eql(a.sqr(u), c)) throw new Error('Cannot find square root')
      return u
    }
  }
  const i = (n + Wn) / Rc
  return function (o, a) {
    if (o.pow(a, e) === o.neg(o.ONE)) throw new Error('Cannot find square root')
    let c = r,
      u = o.pow(o.mul(o.ONE, s), n),
      l = o.pow(a, i),
      d = o.pow(a, n)
    for (; !o.eql(d, o.ONE); ) {
      if (o.eql(d, o.ZERO)) return o.ZERO
      let h = 1
      for (let y = o.sqr(d); h < c && !o.eql(y, o.ONE); h++) y = o.sqr(y)
      const p = o.pow(u, Wn << BigInt(c - h - 1))
      ;(u = o.sqr(p)), (l = o.mul(l, p)), (d = o.mul(d, u)), (c = h)
    }
    return l
  }
}
function IY(t) {
  if (t % hv === CY) {
    const e = (t + Wn) / hv
    return function (n, r) {
      const s = n.pow(r, e)
      if (!n.eql(n.sqr(s), r)) throw new Error('Cannot find square root')
      return s
    }
  }
  if (t % qI === HI) {
    const e = (t - HI) / qI
    return function (n, r) {
      const s = n.mul(r, Rc),
        i = n.pow(s, e),
        o = n.mul(r, i),
        a = n.mul(n.mul(o, Rc), i),
        c = n.mul(o, n.sub(a, n.ONE))
      if (!n.eql(n.sqr(c), r)) throw new Error('Cannot find square root')
      return c
    }
  }
  return SY(t)
}
const xY = [
  'create',
  'isValid',
  'is0',
  'neg',
  'inv',
  'sqrt',
  'sqr',
  'eql',
  'add',
  'sub',
  'mul',
  'pow',
  'div',
  'addN',
  'subN',
  'mulN',
  'sqrN'
]
function TY(t) {
  const e = { ORDER: 'bigint', MASK: 'bigint', BYTES: 'isSafeInteger', BITS: 'isSafeInteger' },
    n = xY.reduce((r, s) => ((r[s] = 'function'), r), e)
  return Rd(t, n)
}
function NY(t, e, n) {
  if (n < yr) throw new Error('invalid exponent, negatives unsupported')
  if (n === yr) return t.ONE
  if (n === Wn) return e
  let r = t.ONE,
    s = e
  for (; n > yr; ) n & Wn && (r = t.mul(r, s)), (s = t.sqr(s)), (n >>= Wn)
  return r
}
function PY(t, e) {
  const n = new Array(e.length),
    r = e.reduce((i, o, a) => (t.is0(o) ? i : ((n[a] = i), t.mul(i, o))), t.ONE),
    s = t.inv(r)
  return e.reduceRight((i, o, a) => (t.is0(o) ? i : ((n[a] = t.mul(i, n[a])), t.mul(i, o))), s), n
}
function vO(t, e) {
  const n = e !== void 0 ? e : t.toString(2).length,
    r = Math.ceil(n / 8)
  return { nBitLength: n, nByteLength: r }
}
function EO(t, e, n = !1, r = {}) {
  if (t <= yr) throw new Error('invalid field: expected ORDER > 0, got ' + t)
  const { nBitLength: s, nByteLength: i } = vO(t, e)
  if (i > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes')
  let o
  const a = Object.freeze({
    ORDER: t,
    isLE: n,
    BITS: s,
    BYTES: i,
    MASK: RA(s),
    ZERO: yr,
    ONE: Wn,
    create: c => bs(c, t),
    isValid: c => {
      if (typeof c != 'bigint')
        throw new Error('invalid field element: expected bigint, got ' + typeof c)
      return yr <= c && c < t
    },
    is0: c => c === yr,
    isOdd: c => (c & Wn) === Wn,
    neg: c => bs(-c, t),
    eql: (c, u) => c === u,
    sqr: c => bs(c * c, t),
    add: (c, u) => bs(c + u, t),
    sub: (c, u) => bs(c - u, t),
    mul: (c, u) => bs(c * u, t),
    pow: (c, u) => NY(a, c, u),
    div: (c, u) => bs(c * fv(u, t), t),
    sqrN: c => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: c => fv(c, t),
    sqrt: r.sqrt || (c => (o || (o = IY(t)), o(a, c))),
    invertBatch: c => PY(a, c),
    cmov: (c, u, l) => (l ? u : c),
    toBytes: c => (n ? F0(c, i) : od(c, i)),
    fromBytes: c => {
      if (c.length !== i)
        throw new Error('Field.fromBytes: expected ' + i + ' bytes, got ' + c.length)
      return n ? Af(c) : Xc(c)
    }
  })
  return Object.freeze(a)
}
function AO(t) {
  if (typeof t != 'bigint') throw new Error('field order must be bigint')
  const e = t.toString(2).length
  return Math.ceil(e / 8)
}
function _O(t) {
  const e = AO(t)
  return e + Math.ceil(e / 2)
}
function RY(t, e, n = !1) {
  const r = t.length,
    s = AO(e),
    i = _O(e)
  if (r < 16 || r < i || r > 1024)
    throw new Error('expected ' + i + '-1024 bytes of input, got ' + r)
  const o = n ? Af(t) : Xc(t),
    a = bs(o, e - Wn) + Wn
  return n ? F0(a, s) : od(a, s)
}
const zI = BigInt(0),
  ag = BigInt(1)
function Kw(t, e) {
  const n = e.negate()
  return t ? n : e
}
function CO(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e)
    throw new Error('invalid window size, expected [1..' + e + '], got W=' + t)
}
function Vw(t, e) {
  CO(t, e)
  const n = Math.ceil(e / t) + 1,
    r = 2 ** (t - 1)
  return { windows: n, windowSize: r }
}
function kY(t, e) {
  if (!Array.isArray(t)) throw new Error('array expected')
  t.forEach((n, r) => {
    if (!(n instanceof e)) throw new Error('invalid point at index ' + r)
  })
}
function OY(t, e) {
  if (!Array.isArray(t)) throw new Error('array of scalars expected')
  t.forEach((n, r) => {
    if (!e.isValid(n)) throw new Error('invalid scalar at index ' + r)
  })
}
const Gw = new WeakMap(),
  SO = new WeakMap()
function Qw(t) {
  return SO.get(t) || 1
}
function BY(t, e) {
  return {
    constTimeNegate: Kw,
    hasPrecomputes(n) {
      return Qw(n) !== 1
    },
    unsafeLadder(n, r, s = t.ZERO) {
      let i = n
      for (; r > zI; ) r & ag && (s = s.add(i)), (i = i.double()), (r >>= ag)
      return s
    },
    precomputeWindow(n, r) {
      const { windows: s, windowSize: i } = Vw(r, e),
        o = []
      let a = n,
        c = a
      for (let u = 0; u < s; u++) {
        ;(c = a), o.push(c)
        for (let l = 1; l < i; l++) (c = c.add(a)), o.push(c)
        a = c.double()
      }
      return o
    },
    wNAF(n, r, s) {
      const { windows: i, windowSize: o } = Vw(n, e)
      let a = t.ZERO,
        c = t.BASE
      const u = BigInt(2 ** n - 1),
        l = 2 ** n,
        d = BigInt(n)
      for (let h = 0; h < i; h++) {
        const p = h * o
        let y = Number(s & u)
        ;(s >>= d), y > o && ((y -= l), (s += ag))
        const m = p,
          b = p + Math.abs(y) - 1,
          I = h % 2 !== 0,
          x = y < 0
        y === 0 ? (c = c.add(Kw(I, r[m]))) : (a = a.add(Kw(x, r[b])))
      }
      return { p: a, f: c }
    },
    wNAFUnsafe(n, r, s, i = t.ZERO) {
      const { windows: o, windowSize: a } = Vw(n, e),
        c = BigInt(2 ** n - 1),
        u = 2 ** n,
        l = BigInt(n)
      for (let d = 0; d < o; d++) {
        const h = d * a
        if (s === zI) break
        let p = Number(s & c)
        if (((s >>= l), p > a && ((p -= u), (s += ag)), p === 0)) continue
        let y = r[h + Math.abs(p) - 1]
        p < 0 && (y = y.negate()), (i = i.add(y))
      }
      return i
    },
    getPrecomputes(n, r, s) {
      let i = Gw.get(r)
      return i || ((i = this.precomputeWindow(r, n)), n !== 1 && Gw.set(r, s(i))), i
    },
    wNAFCached(n, r, s) {
      const i = Qw(n)
      return this.wNAF(i, this.getPrecomputes(i, n, s), r)
    },
    wNAFCachedUnsafe(n, r, s, i) {
      const o = Qw(n)
      return o === 1
        ? this.unsafeLadder(n, r, i)
        : this.wNAFUnsafe(o, this.getPrecomputes(o, n, s), r, i)
    },
    setWindowSize(n, r) {
      CO(r, e), SO.set(n, r), Gw.delete(n)
    }
  }
}
function DY(t, e, n, r) {
  if ((kY(n, t), OY(r, e), n.length !== r.length))
    throw new Error('arrays of points and scalars must have equal length')
  const s = t.ZERO,
    i = yO(BigInt(n.length)),
    o = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1,
    a = (1 << o) - 1,
    c = new Array(a + 1).fill(s),
    u = Math.floor((e.BITS - 1) / o) * o
  let l = s
  for (let d = u; d >= 0; d -= o) {
    c.fill(s)
    for (let p = 0; p < r.length; p++) {
      const y = r[p],
        m = Number((y >> BigInt(d)) & BigInt(a))
      c[m] = c[m].add(n[p])
    }
    let h = s
    for (let p = c.length - 1, y = s; p > 0; p--) (y = y.add(c[p])), (h = h.add(y))
    if (((l = l.add(h)), d !== 0)) for (let p = 0; p < o; p++) l = l.double()
  }
  return l
}
function IO(t) {
  return (
    TY(t.Fp),
    Rd(
      t,
      { n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field' },
      { nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger' }
    ),
    Object.freeze({ ...vO(t.n, t.nBitLength), ...t, p: t.Fp.ORDER })
  )
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8)
const Hu = BigInt(0),
  Zw = BigInt(1)
function MY(t) {
  return (
    Rd(
      t,
      { a: 'bigint' },
      {
        montgomeryBits: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
        adjustScalarBytes: 'function',
        domain: 'function',
        powPminus2: 'function',
        Gu: 'bigint'
      }
    ),
    Object.freeze({ ...t })
  )
}
function UY(t) {
  const e = MY(t),
    { P: n } = e,
    r = x => bs(x, n),
    s = e.montgomeryBits,
    i = Math.ceil(s / 8),
    o = e.nByteLength,
    a = e.adjustScalarBytes || (x => x),
    c = e.powPminus2 || (x => bO(x, n - BigInt(2), n))
  function u(x, _, R) {
    const N = r(x * (_ - R))
    return (_ = r(_ - N)), (R = r(R + N)), [_, R]
  }
  const l = (e.a - BigInt(2)) / BigInt(4)
  function d(x, _) {
    Vo('u', x, Hu, n), Vo('scalar', _, Hu, n)
    const R = _,
      N = x
    let T = Zw,
      M = Hu,
      H = x,
      B = Zw,
      $ = Hu,
      D
    for (let U = BigInt(s - 1); U >= Hu; U--) {
      const w = (R >> U) & Zw
      ;($ ^= w),
        (D = u($, T, H)),
        (T = D[0]),
        (H = D[1]),
        (D = u($, M, B)),
        (M = D[0]),
        (B = D[1]),
        ($ = w)
      const v = T + M,
        A = r(v * v),
        P = T - M,
        O = r(P * P),
        F = A - O,
        z = H + B,
        j = H - B,
        E = r(j * v),
        C = r(z * P),
        L = E + C,
        K = E - C
      ;(H = r(L * L)), (B = r(N * r(K * K))), (T = r(A * O)), (M = r(F * (A + r(l * F))))
    }
    ;(D = u($, T, H)), (T = D[0]), (H = D[1]), (D = u($, M, B)), (M = D[0]), (B = D[1])
    const W = c(M)
    return r(T * W)
  }
  function h(x) {
    return F0(r(x), i)
  }
  function p(x) {
    const _ = Ds('u coordinate', x, i)
    return o === 32 && (_[31] &= 127), Af(_)
  }
  function y(x) {
    const _ = Ds('scalar', x),
      R = _.length
    if (R !== i && R !== o) {
      let N = '' + i + ' or ' + o
      throw new Error('invalid scalar, expected ' + N + ' bytes, got ' + R)
    }
    return Af(a(_))
  }
  function m(x, _) {
    const R = p(_),
      N = y(x),
      T = d(R, N)
    if (T === Hu) throw new Error('invalid private or public key received')
    return h(T)
  }
  const b = h(e.Gu)
  function I(x) {
    return m(x, b)
  }
  return {
    scalarMult: m,
    scalarMultBase: I,
    getSharedSecret: (x, _) => m(x, _),
    getPublicKey: x => I(x),
    utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) },
    GuBytes: b
  }
}
const pv = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949')
BigInt(0)
const LY = BigInt(1),
  WI = BigInt(2),
  $Y = BigInt(3),
  FY = BigInt(5)
BigInt(8)
function jY(t) {
  const e = BigInt(10),
    n = BigInt(20),
    r = BigInt(40),
    s = BigInt(80),
    i = pv,
    o = (((t * t) % i) * t) % i,
    a = (wi(o, WI, i) * o) % i,
    c = (wi(a, LY, i) * t) % i,
    u = (wi(c, FY, i) * c) % i,
    l = (wi(u, e, i) * u) % i,
    d = (wi(l, n, i) * l) % i,
    h = (wi(d, r, i) * d) % i,
    p = (wi(h, s, i) * h) % i,
    y = (wi(p, s, i) * h) % i,
    m = (wi(y, e, i) * u) % i
  return { pow_p_5_8: (wi(m, WI, i) * t) % i, b2: o }
}
function HY(t) {
  return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t
}
const gv = UY({
  P: pv,
  a: BigInt(486662),
  montgomeryBits: 255,
  nByteLength: 32,
  Gu: BigInt(9),
  powPminus2: t => {
    const e = pv,
      { pow_p_5_8: n, b2: r } = jY(t)
    return bs(wi(n, $Y, e) * r, e)
  },
  adjustScalarBytes: HY,
  randomBytes: Pd
})
function KI(t) {
  t.lowS !== void 0 && rd('lowS', t.lowS), t.prehash !== void 0 && rd('prehash', t.prehash)
}
function qY(t) {
  const e = IO(t)
  Rd(
    e,
    { a: 'field', b: 'field' },
    {
      allowedPrivateKeyLengths: 'array',
      wrapPrivateKey: 'boolean',
      isTorsionFree: 'function',
      clearCofactor: 'function',
      allowInfinityPoint: 'boolean',
      fromBytes: 'function',
      toBytes: 'function'
    }
  )
  const { endo: n, Fp: r, a: s } = e
  if (n) {
    if (!r.eql(s, r.ZERO))
      throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0')
    if (typeof n != 'object' || typeof n.beta != 'bigint' || typeof n.splitScalar != 'function')
      throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function')
  }
  return Object.freeze({ ...e })
}
const { bytesToNumberBE: zY, hexToBytes: WY } = _Y
class KY extends Error {
  constructor(e = '') {
    super(e)
  }
}
const Lo = {
    Err: KY,
    _tlv: {
      encode: (t, e) => {
        const { Err: n } = Lo
        if (t < 0 || t > 256) throw new n('tlv.encode: wrong tag')
        if (e.length & 1) throw new n('tlv.encode: unpadded data')
        const r = e.length / 2,
          s = gl(r)
        if ((s.length / 2) & 128) throw new n('tlv.encode: long form length too big')
        const i = r > 127 ? gl((s.length / 2) | 128) : ''
        return gl(t) + i + s + e
      },
      decode(t, e) {
        const { Err: n } = Lo
        let r = 0
        if (t < 0 || t > 256) throw new n('tlv.encode: wrong tag')
        if (e.length < 2 || e[r++] !== t) throw new n('tlv.decode: wrong tlv')
        const s = e[r++],
          i = !!(s & 128)
        let o = 0
        if (!i) o = s
        else {
          const c = s & 127
          if (!c) throw new n('tlv.decode(long): indefinite length not supported')
          if (c > 4) throw new n('tlv.decode(long): byte length is too big')
          const u = e.subarray(r, r + c)
          if (u.length !== c) throw new n('tlv.decode: length bytes not complete')
          if (u[0] === 0) throw new n('tlv.decode(long): zero leftmost byte')
          for (const l of u) o = (o << 8) | l
          if (((r += c), o < 128)) throw new n('tlv.decode(long): not minimal encoding')
        }
        const a = e.subarray(r, r + o)
        if (a.length !== o) throw new n('tlv.decode: wrong value length')
        return { v: a, l: e.subarray(r + o) }
      }
    },
    _int: {
      encode(t) {
        const { Err: e } = Lo
        if (t < jo) throw new e('integer: negative integers are not allowed')
        let n = gl(t)
        if ((Number.parseInt(n[0], 16) & 8 && (n = '00' + n), n.length & 1))
          throw new e('unexpected DER parsing assertion: unpadded hex')
        return n
      },
      decode(t) {
        const { Err: e } = Lo
        if (t[0] & 128) throw new e('invalid signature integer: negative')
        if (t[0] === 0 && !(t[1] & 128))
          throw new e('invalid signature integer: unnecessary leading zero')
        return zY(t)
      }
    },
    toSig(t) {
      const { Err: e, _int: n, _tlv: r } = Lo,
        s = typeof t == 'string' ? WY(t) : t
      bp(s)
      const { v: i, l: o } = r.decode(48, s)
      if (o.length) throw new e('invalid signature: left bytes after parsing')
      const { v: a, l: c } = r.decode(2, i),
        { v: u, l } = r.decode(2, c)
      if (l.length) throw new e('invalid signature: left bytes after parsing')
      return { r: n.decode(a), s: n.decode(u) }
    },
    hexFromSig(t) {
      const { _tlv: e, _int: n } = Lo,
        r = e.encode(2, n.encode(t.r)),
        s = e.encode(2, n.encode(t.s)),
        i = r + s
      return e.encode(48, i)
    }
  },
  jo = BigInt(0),
  dr = BigInt(1)
BigInt(2)
const VI = BigInt(3)
BigInt(4)
function VY(t) {
  const e = qY(t),
    { Fp: n } = e,
    r = EO(e.n, e.nBitLength),
    s =
      e.toBytes ||
      ((m, b, I) => {
        const x = b.toAffine()
        return _f(Uint8Array.from([4]), n.toBytes(x.x), n.toBytes(x.y))
      }),
    i =
      e.fromBytes ||
      (m => {
        const b = m.subarray(1),
          I = n.fromBytes(b.subarray(0, n.BYTES)),
          x = n.fromBytes(b.subarray(n.BYTES, 2 * n.BYTES))
        return { x: I, y: x }
      })
  function o(m) {
    const { a: b, b: I } = e,
      x = n.sqr(m),
      _ = n.mul(x, m)
    return n.add(n.add(_, n.mul(m, b)), I)
  }
  if (!n.eql(n.sqr(e.Gy), o(e.Gx))) throw new Error('bad generator point: equation left != right')
  function a(m) {
    return j0(m, dr, e.n)
  }
  function c(m) {
    const { allowedPrivateKeyLengths: b, nByteLength: I, wrapPrivateKey: x, n: _ } = e
    if (b && typeof m != 'bigint') {
      if ((mu(m) && (m = sd(m)), typeof m != 'string' || !b.includes(m.length)))
        throw new Error('invalid private key')
      m = m.padStart(I * 2, '0')
    }
    let R
    try {
      R = typeof m == 'bigint' ? m : Xc(Ds('private key', m, I))
    } catch {
      throw new Error('invalid private key, expected hex or ' + I + ' bytes, got ' + typeof m)
    }
    return x && (R = bs(R, _)), Vo('private key', R, dr, _), R
  }
  function u(m) {
    if (!(m instanceof h)) throw new Error('ProjectivePoint expected')
  }
  const l = dv((m, b) => {
      const { px: I, py: x, pz: _ } = m
      if (n.eql(_, n.ONE)) return { x: I, y: x }
      const R = m.is0()
      b == null && (b = R ? n.ONE : n.inv(_))
      const N = n.mul(I, b),
        T = n.mul(x, b),
        M = n.mul(_, b)
      if (R) return { x: n.ZERO, y: n.ZERO }
      if (!n.eql(M, n.ONE)) throw new Error('invZ was invalid')
      return { x: N, y: T }
    }),
    d = dv(m => {
      if (m.is0()) {
        if (e.allowInfinityPoint && !n.is0(m.py)) return
        throw new Error('bad point: ZERO')
      }
      const { x: b, y: I } = m.toAffine()
      if (!n.isValid(b) || !n.isValid(I)) throw new Error('bad point: x or y not FE')
      const x = n.sqr(I),
        _ = o(b)
      if (!n.eql(x, _)) throw new Error('bad point: equation left != right')
      if (!m.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup')
      return !0
    })
  class h {
    constructor(b, I, x) {
      if (((this.px = b), (this.py = I), (this.pz = x), b == null || !n.isValid(b)))
        throw new Error('x required')
      if (I == null || !n.isValid(I)) throw new Error('y required')
      if (x == null || !n.isValid(x)) throw new Error('z required')
      Object.freeze(this)
    }
    static fromAffine(b) {
      const { x: I, y: x } = b || {}
      if (!b || !n.isValid(I) || !n.isValid(x)) throw new Error('invalid affine point')
      if (b instanceof h) throw new Error('projective point not allowed')
      const _ = R => n.eql(R, n.ZERO)
      return _(I) && _(x) ? h.ZERO : new h(I, x, n.ONE)
    }
    get x() {
      return this.toAffine().x
    }
    get y() {
      return this.toAffine().y
    }
    static normalizeZ(b) {
      const I = n.invertBatch(b.map(x => x.pz))
      return b.map((x, _) => x.toAffine(I[_])).map(h.fromAffine)
    }
    static fromHex(b) {
      const I = h.fromAffine(i(Ds('pointHex', b)))
      return I.assertValidity(), I
    }
    static fromPrivateKey(b) {
      return h.BASE.multiply(c(b))
    }
    static msm(b, I) {
      return DY(h, r, b, I)
    }
    _setWindowSize(b) {
      y.setWindowSize(this, b)
    }
    assertValidity() {
      d(this)
    }
    hasEvenY() {
      const { y: b } = this.toAffine()
      if (n.isOdd) return !n.isOdd(b)
      throw new Error("Field doesn't support isOdd")
    }
    equals(b) {
      u(b)
      const { px: I, py: x, pz: _ } = this,
        { px: R, py: N, pz: T } = b,
        M = n.eql(n.mul(I, T), n.mul(R, _)),
        H = n.eql(n.mul(x, T), n.mul(N, _))
      return M && H
    }
    negate() {
      return new h(this.px, n.neg(this.py), this.pz)
    }
    double() {
      const { a: b, b: I } = e,
        x = n.mul(I, VI),
        { px: _, py: R, pz: N } = this
      let T = n.ZERO,
        M = n.ZERO,
        H = n.ZERO,
        B = n.mul(_, _),
        $ = n.mul(R, R),
        D = n.mul(N, N),
        W = n.mul(_, R)
      return (
        (W = n.add(W, W)),
        (H = n.mul(_, N)),
        (H = n.add(H, H)),
        (T = n.mul(b, H)),
        (M = n.mul(x, D)),
        (M = n.add(T, M)),
        (T = n.sub($, M)),
        (M = n.add($, M)),
        (M = n.mul(T, M)),
        (T = n.mul(W, T)),
        (H = n.mul(x, H)),
        (D = n.mul(b, D)),
        (W = n.sub(B, D)),
        (W = n.mul(b, W)),
        (W = n.add(W, H)),
        (H = n.add(B, B)),
        (B = n.add(H, B)),
        (B = n.add(B, D)),
        (B = n.mul(B, W)),
        (M = n.add(M, B)),
        (D = n.mul(R, N)),
        (D = n.add(D, D)),
        (B = n.mul(D, W)),
        (T = n.sub(T, B)),
        (H = n.mul(D, $)),
        (H = n.add(H, H)),
        (H = n.add(H, H)),
        new h(T, M, H)
      )
    }
    add(b) {
      u(b)
      const { px: I, py: x, pz: _ } = this,
        { px: R, py: N, pz: T } = b
      let M = n.ZERO,
        H = n.ZERO,
        B = n.ZERO
      const $ = e.a,
        D = n.mul(e.b, VI)
      let W = n.mul(I, R),
        U = n.mul(x, N),
        w = n.mul(_, T),
        v = n.add(I, x),
        A = n.add(R, N)
      ;(v = n.mul(v, A)), (A = n.add(W, U)), (v = n.sub(v, A)), (A = n.add(I, _))
      let P = n.add(R, T)
      return (
        (A = n.mul(A, P)),
        (P = n.add(W, w)),
        (A = n.sub(A, P)),
        (P = n.add(x, _)),
        (M = n.add(N, T)),
        (P = n.mul(P, M)),
        (M = n.add(U, w)),
        (P = n.sub(P, M)),
        (B = n.mul($, A)),
        (M = n.mul(D, w)),
        (B = n.add(M, B)),
        (M = n.sub(U, B)),
        (B = n.add(U, B)),
        (H = n.mul(M, B)),
        (U = n.add(W, W)),
        (U = n.add(U, W)),
        (w = n.mul($, w)),
        (A = n.mul(D, A)),
        (U = n.add(U, w)),
        (w = n.sub(W, w)),
        (w = n.mul($, w)),
        (A = n.add(A, w)),
        (W = n.mul(U, A)),
        (H = n.add(H, W)),
        (W = n.mul(P, A)),
        (M = n.mul(v, M)),
        (M = n.sub(M, W)),
        (W = n.mul(v, U)),
        (B = n.mul(P, B)),
        (B = n.add(B, W)),
        new h(M, H, B)
      )
    }
    subtract(b) {
      return this.add(b.negate())
    }
    is0() {
      return this.equals(h.ZERO)
    }
    wNAF(b) {
      return y.wNAFCached(this, b, h.normalizeZ)
    }
    multiplyUnsafe(b) {
      const { endo: I, n: x } = e
      Vo('scalar', b, jo, x)
      const _ = h.ZERO
      if (b === jo) return _
      if (this.is0() || b === dr) return this
      if (!I || y.hasPrecomputes(this)) return y.wNAFCachedUnsafe(this, b, h.normalizeZ)
      let { k1neg: R, k1: N, k2neg: T, k2: M } = I.splitScalar(b),
        H = _,
        B = _,
        $ = this
      for (; N > jo || M > jo; )
        N & dr && (H = H.add($)), M & dr && (B = B.add($)), ($ = $.double()), (N >>= dr), (M >>= dr)
      return (
        R && (H = H.negate()),
        T && (B = B.negate()),
        (B = new h(n.mul(B.px, I.beta), B.py, B.pz)),
        H.add(B)
      )
    }
    multiply(b) {
      const { endo: I, n: x } = e
      Vo('scalar', b, dr, x)
      let _, R
      if (I) {
        const { k1neg: N, k1: T, k2neg: M, k2: H } = I.splitScalar(b)
        let { p: B, f: $ } = this.wNAF(T),
          { p: D, f: W } = this.wNAF(H)
        ;(B = y.constTimeNegate(N, B)),
          (D = y.constTimeNegate(M, D)),
          (D = new h(n.mul(D.px, I.beta), D.py, D.pz)),
          (_ = B.add(D)),
          (R = $.add(W))
      } else {
        const { p: N, f: T } = this.wNAF(b)
        ;(_ = N), (R = T)
      }
      return h.normalizeZ([_, R])[0]
    }
    multiplyAndAddUnsafe(b, I, x) {
      const _ = h.BASE,
        R = (T, M) => (M === jo || M === dr || !T.equals(_) ? T.multiplyUnsafe(M) : T.multiply(M)),
        N = R(this, I).add(R(b, x))
      return N.is0() ? void 0 : N
    }
    toAffine(b) {
      return l(this, b)
    }
    isTorsionFree() {
      const { h: b, isTorsionFree: I } = e
      if (b === dr) return !0
      if (I) return I(h, this)
      throw new Error('isTorsionFree() has not been declared for the elliptic curve')
    }
    clearCofactor() {
      const { h: b, clearCofactor: I } = e
      return b === dr ? this : I ? I(h, this) : this.multiplyUnsafe(e.h)
    }
    toRawBytes(b = !0) {
      return rd('isCompressed', b), this.assertValidity(), s(h, this, b)
    }
    toHex(b = !0) {
      return rd('isCompressed', b), sd(this.toRawBytes(b))
    }
  }
  ;(h.BASE = new h(e.Gx, e.Gy, n.ONE)), (h.ZERO = new h(n.ZERO, n.ONE, n.ZERO))
  const p = e.nBitLength,
    y = BY(h, e.endo ? Math.ceil(p / 2) : p)
  return {
    CURVE: e,
    ProjectivePoint: h,
    normPrivateKeyToScalar: c,
    weierstrassEquation: o,
    isWithinCurveOrder: a
  }
}
function GY(t) {
  const e = IO(t)
  return (
    Rd(
      e,
      { hash: 'hash', hmac: 'function', randomBytes: 'function' },
      { bits2int: 'function', bits2int_modN: 'function', lowS: 'boolean' }
    ),
    Object.freeze({ lowS: !0, ...e })
  )
}
function QY(t) {
  const e = GY(t),
    { Fp: n, n: r } = e,
    s = n.BYTES + 1,
    i = 2 * n.BYTES + 1
  function o(w) {
    return bs(w, r)
  }
  function a(w) {
    return fv(w, r)
  }
  const {
      ProjectivePoint: c,
      normPrivateKeyToScalar: u,
      weierstrassEquation: l,
      isWithinCurveOrder: d
    } = VY({
      ...e,
      toBytes(w, v, A) {
        const P = v.toAffine(),
          O = n.toBytes(P.x),
          F = _f
        return (
          rd('isCompressed', A),
          A
            ? F(Uint8Array.from([v.hasEvenY() ? 2 : 3]), O)
            : F(Uint8Array.from([4]), O, n.toBytes(P.y))
        )
      },
      fromBytes(w) {
        const v = w.length,
          A = w[0],
          P = w.subarray(1)
        if (v === s && (A === 2 || A === 3)) {
          const O = Xc(P)
          if (!j0(O, dr, n.ORDER)) throw new Error('Point is not on curve')
          const F = l(O)
          let z
          try {
            z = n.sqrt(F)
          } catch (E) {
            const C = E instanceof Error ? ': ' + E.message : ''
            throw new Error('Point is not on curve' + C)
          }
          const j = (z & dr) === dr
          return ((A & 1) === 1) !== j && (z = n.neg(z)), { x: O, y: z }
        } else if (v === i && A === 4) {
          const O = n.fromBytes(P.subarray(0, n.BYTES)),
            F = n.fromBytes(P.subarray(n.BYTES, 2 * n.BYTES))
          return { x: O, y: F }
        } else {
          const O = s,
            F = i
          throw new Error(
            'invalid Point, expected length of ' + O + ', or uncompressed ' + F + ', got ' + v
          )
        }
      }
    }),
    h = w => sd(od(w, e.nByteLength))
  function p(w) {
    const v = r >> dr
    return w > v
  }
  function y(w) {
    return p(w) ? o(-w) : w
  }
  const m = (w, v, A) => Xc(w.slice(v, A))
  class b {
    constructor(v, A, P) {
      ;(this.r = v), (this.s = A), (this.recovery = P), this.assertValidity()
    }
    static fromCompact(v) {
      const A = e.nByteLength
      return (v = Ds('compactSignature', v, A * 2)), new b(m(v, 0, A), m(v, A, 2 * A))
    }
    static fromDER(v) {
      const { r: A, s: P } = Lo.toSig(Ds('DER', v))
      return new b(A, P)
    }
    assertValidity() {
      Vo('r', this.r, dr, r), Vo('s', this.s, dr, r)
    }
    addRecoveryBit(v) {
      return new b(this.r, this.s, v)
    }
    recoverPublicKey(v) {
      const { r: A, s: P, recovery: O } = this,
        F = T(Ds('msgHash', v))
      if (O == null || ![0, 1, 2, 3].includes(O)) throw new Error('recovery id invalid')
      const z = O === 2 || O === 3 ? A + e.n : A
      if (z >= n.ORDER) throw new Error('recovery id 2 or 3 invalid')
      const j = (O & 1) === 0 ? '02' : '03',
        E = c.fromHex(j + h(z)),
        C = a(z),
        L = o(-F * C),
        K = o(P * C),
        ee = c.BASE.multiplyAndAddUnsafe(E, L, K)
      if (!ee) throw new Error('point at infinify')
      return ee.assertValidity(), ee
    }
    hasHighS() {
      return p(this.s)
    }
    normalizeS() {
      return this.hasHighS() ? new b(this.r, o(-this.s), this.recovery) : this
    }
    toDERRawBytes() {
      return id(this.toDERHex())
    }
    toDERHex() {
      return Lo.hexFromSig({ r: this.r, s: this.s })
    }
    toCompactRawBytes() {
      return id(this.toCompactHex())
    }
    toCompactHex() {
      return h(this.r) + h(this.s)
    }
  }
  const I = {
    isValidPrivateKey(w) {
      try {
        return u(w), !0
      } catch {
        return !1
      }
    },
    normPrivateKeyToScalar: u,
    randomPrivateKey: () => {
      const w = _O(e.n)
      return RY(e.randomBytes(w), e.n)
    },
    precompute(w = 8, v = c.BASE) {
      return v._setWindowSize(w), v.multiply(BigInt(3)), v
    }
  }
  function x(w, v = !0) {
    return c.fromPrivateKey(w).toRawBytes(v)
  }
  function _(w) {
    const v = mu(w),
      A = typeof w == 'string',
      P = (v || A) && w.length
    return v ? P === s || P === i : A ? P === 2 * s || P === 2 * i : w instanceof c
  }
  function R(w, v, A = !0) {
    if (_(w)) throw new Error('first arg must be private key')
    if (!_(v)) throw new Error('second arg must be public key')
    return c.fromHex(v).multiply(u(w)).toRawBytes(A)
  }
  const N =
      e.bits2int ||
      function (w) {
        if (w.length > 8192) throw new Error('input is too large')
        const v = Xc(w),
          A = w.length * 8 - e.nBitLength
        return A > 0 ? v >> BigInt(A) : v
      },
    T =
      e.bits2int_modN ||
      function (w) {
        return o(N(w))
      },
    M = RA(e.nBitLength)
  function H(w) {
    return Vo('num < 2^' + e.nBitLength, w, jo, M), od(w, e.nByteLength)
  }
  function B(w, v, A = $) {
    if (['recovered', 'canonical'].some(fe => fe in A))
      throw new Error('sign() legacy options not supported')
    const { hash: P, randomBytes: O } = e
    let { lowS: F, prehash: z, extraEntropy: j } = A
    F == null && (F = !0), (w = Ds('msgHash', w)), KI(A), z && (w = Ds('prehashed msgHash', P(w)))
    const E = T(w),
      C = u(v),
      L = [H(C), H(E)]
    if (j != null && j !== !1) {
      const fe = j === !0 ? O(n.BYTES) : j
      L.push(Ds('extraEntropy', fe))
    }
    const K = _f(...L),
      ee = E
    function oe(fe) {
      const ve = N(fe)
      if (!d(ve)) return
      const tt = a(ve),
        Ge = c.BASE.multiply(ve).toAffine(),
        nt = o(Ge.x)
      if (nt === jo) return
      const Z = o(tt * o(ee + nt * C))
      if (Z === jo) return
      let X = (Ge.x === nt ? 0 : 2) | Number(Ge.y & dr),
        ie = Z
      return F && p(Z) && ((ie = y(Z)), (X ^= 1)), new b(nt, ie, X)
    }
    return { seed: K, k2sig: oe }
  }
  const $ = { lowS: e.lowS, prehash: !1 },
    D = { lowS: e.lowS, prehash: !1 }
  function W(w, v, A = $) {
    const { seed: P, k2sig: O } = B(w, v, A),
      F = e
    return wO(F.hash.outputLen, F.nByteLength, F.hmac)(P, O)
  }
  c.BASE._setWindowSize(8)
  function U(w, v, A, P = D) {
    var Z
    const O = w
    ;(v = Ds('msgHash', v)), (A = Ds('publicKey', A))
    const { lowS: F, prehash: z, format: j } = P
    if ((KI(P), 'strict' in P)) throw new Error('options.strict was renamed to lowS')
    if (j !== void 0 && j !== 'compact' && j !== 'der')
      throw new Error('format must be compact or der')
    const E = typeof O == 'string' || mu(O),
      C =
        !E &&
        !j &&
        typeof O == 'object' &&
        O !== null &&
        typeof O.r == 'bigint' &&
        typeof O.s == 'bigint'
    if (!E && !C)
      throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance')
    let L, K
    try {
      if ((C && (L = new b(O.r, O.s)), E)) {
        try {
          j !== 'compact' && (L = b.fromDER(O))
        } catch (X) {
          if (!(X instanceof Lo.Err)) throw X
        }
        !L && j !== 'der' && (L = b.fromCompact(O))
      }
      K = c.fromHex(A)
    } catch {
      return !1
    }
    if (!L || (F && L.hasHighS())) return !1
    z && (v = e.hash(v))
    const { r: ee, s: oe } = L,
      fe = T(v),
      ve = a(oe),
      tt = o(fe * ve),
      Ge = o(ee * ve),
      nt = (Z = c.BASE.multiplyAndAddUnsafe(K, tt, Ge)) == null ? void 0 : Z.toAffine()
    return nt ? o(nt.x) === ee : !1
  }
  return {
    CURVE: e,
    getPublicKey: x,
    getSharedSecret: R,
    sign: W,
    verify: U,
    ProjectivePoint: c,
    Signature: b,
    utils: I
  }
}
function ZY(t) {
  return { hash: t, hmac: (e, ...n) => U0(t, e, eZ(...n)), randomBytes: Pd }
}
function YY(t, e) {
  const n = r => QY({ ...t, ...ZY(r) })
  return { ...n(e), create: n }
}
const xO = EO(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff')),
  JY = xO.create(BigInt('-3')),
  XY = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
  eJ = YY(
    {
      a: JY,
      b: XY,
      Fp: xO,
      n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
      Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
      Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
      h: BigInt(1),
      lowS: !1
    },
    wp
  ),
  TO = 'base10',
  us = 'base16',
  Ii = 'base64pad',
  Ta = 'base64url',
  vp = 'utf8',
  NO = 0,
  Go = 1,
  Ep = 2,
  tJ = 0,
  GI = 1,
  kh = 12,
  kA = 32
function nJ() {
  const t = gv.utils.randomPrivateKey(),
    e = gv.getPublicKey(t)
  return { privateKey: _s(t, us), publicKey: _s(e, us) }
}
function mv() {
  const t = Pd(kA)
  return _s(t, us)
}
function rJ(t, e) {
  const n = gv.getSharedSecret(ii(t, us), ii(e, us)),
    r = aY(wp, n, void 0, void 0, kA)
  return _s(r, us)
}
function Mg(t) {
  const e = wp(ii(t, us))
  return _s(e, us)
}
function Ji(t) {
  const e = wp(ii(t, vp))
  return _s(e, us)
}
function PO(t) {
  return ii(`${t}`, TO)
}
function yu(t) {
  return Number(_s(t, TO))
}
function RO(t) {
  return t.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '')
}
function kO(t) {
  const e = t.replace(/-/g, '+').replace(/_/g, '/'),
    n = (4 - (e.length % 4)) % 4
  return e + '='.repeat(n)
}
function sJ(t) {
  const e = PO(typeof t.type < 'u' ? t.type : NO)
  if (yu(e) === Go && typeof t.senderPublicKey > 'u')
    throw new Error('Missing sender public key for type 1 envelope')
  const n = typeof t.senderPublicKey < 'u' ? ii(t.senderPublicKey, us) : void 0,
    r = typeof t.iv < 'u' ? ii(t.iv, us) : Pd(kh),
    s = ii(t.symKey, us),
    i = gO(s, r).encrypt(ii(t.message, vp)),
    o = OO({ type: e, sealed: i, iv: r, senderPublicKey: n })
  return t.encoding === Ta ? RO(o) : o
}
function iJ(t) {
  const e = ii(t.symKey, us),
    { sealed: n, iv: r } = Cf({ encoded: t.encoded, encoding: t.encoding }),
    s = gO(e, r).decrypt(n)
  if (s === null) throw new Error('Failed to decrypt')
  return _s(s, vp)
}
function oJ(t, e) {
  const n = PO(Ep),
    r = Pd(kh),
    s = ii(t, vp),
    i = OO({ type: n, sealed: s, iv: r })
  return e === Ta ? RO(i) : i
}
function aJ(t, e) {
  const { sealed: n } = Cf({ encoded: t, encoding: e })
  return _s(n, vp)
}
function OO(t) {
  if (yu(t.type) === Ep) return _s(Rh([t.type, t.sealed]), Ii)
  if (yu(t.type) === Go) {
    if (typeof t.senderPublicKey > 'u')
      throw new Error('Missing sender public key for type 1 envelope')
    return _s(Rh([t.type, t.senderPublicKey, t.iv, t.sealed]), Ii)
  }
  return _s(Rh([t.type, t.iv, t.sealed]), Ii)
}
function Cf(t) {
  const e = (t.encoding || Ii) === Ta ? kO(t.encoded) : t.encoded,
    n = ii(e, Ii),
    r = n.slice(tJ, GI),
    s = GI
  if (yu(r) === Go) {
    const c = s + kA,
      u = c + kh,
      l = n.slice(s, c),
      d = n.slice(c, u),
      h = n.slice(u)
    return { type: r, sealed: h, iv: d, senderPublicKey: l }
  }
  if (yu(r) === Ep) {
    const c = n.slice(s),
      u = Pd(kh)
    return { type: r, sealed: c, iv: u }
  }
  const i = s + kh,
    o = n.slice(s, i),
    a = n.slice(i)
  return { type: r, sealed: a, iv: o }
}
function cJ(t, e) {
  const n = Cf({ encoded: t, encoding: e == null ? void 0 : e.encoding })
  return BO({
    type: yu(n.type),
    senderPublicKey: typeof n.senderPublicKey < 'u' ? _s(n.senderPublicKey, us) : void 0,
    receiverPublicKey: e == null ? void 0 : e.receiverPublicKey
  })
}
function BO(t) {
  const e = (t == null ? void 0 : t.type) || NO
  if (e === Go) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > 'u')
      throw new Error('missing sender public key')
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > 'u')
      throw new Error('missing receiver public key')
  }
  return {
    type: e,
    senderPublicKey: t == null ? void 0 : t.senderPublicKey,
    receiverPublicKey: t == null ? void 0 : t.receiverPublicKey
  }
}
function QI(t) {
  return (
    t.type === Go && typeof t.senderPublicKey == 'string' && typeof t.receiverPublicKey == 'string'
  )
}
function ZI(t) {
  return t.type === Ep
}
function uJ(t) {
  const e = Buffer.from(t.x, 'base64'),
    n = Buffer.from(t.y, 'base64')
  return Rh([new Uint8Array([4]), e, n])
}
function lJ(t, e) {
  const [n, r, s] = t.split('.'),
    i = Buffer.from(kO(s), 'base64')
  if (i.length !== 64) throw new Error('Invalid signature length')
  const o = i.slice(0, 32),
    a = i.slice(32, 64),
    c = `${n}.${r}`,
    u = wp(c),
    l = uJ(e)
  if (!eJ.verify(Rh([o, a]), u, l)) throw new Error('Invalid signature')
  return nv(t).payload
}
const dJ = 'irn'
function _m(t) {
  return (t == null ? void 0 : t.relay) || { protocol: dJ }
}
function wh(t) {
  const e = mQ[t]
  if (typeof e > 'u') throw new Error(`Relay Protocol not supported: ${t}`)
  return e
}
function hJ(t, e = '-') {
  const n = {},
    r = 'relay' + e
  return (
    Object.keys(t).forEach(s => {
      if (s.startsWith(r)) {
        const i = s.replace(r, ''),
          o = t[s]
        n[i] = o
      }
    }),
    n
  )
}
function YI(t) {
  if (!t.includes('wc:')) {
    const u = nO(t)
    u != null && u.includes('wc:') && (t = u)
  }
  ;(t = t.includes('wc://') ? t.replace('wc://', '') : t),
    (t = t.includes('wc:') ? t.replace('wc:', '') : t)
  const e = t.indexOf(':'),
    n = t.indexOf('?') !== -1 ? t.indexOf('?') : void 0,
    r = t.substring(0, e),
    s = t.substring(e + 1, n).split('@'),
    i = typeof n < 'u' ? t.substring(n) : '',
    o = new URLSearchParams(i),
    a = {}
  o.forEach((u, l) => {
    a[l] = u
  })
  const c = typeof a.methods == 'string' ? a.methods.split(',') : void 0
  return {
    protocol: r,
    topic: fJ(s[0]),
    version: parseInt(s[1], 10),
    symKey: a.symKey,
    relay: hJ(a),
    methods: c,
    expiryTimestamp: a.expiryTimestamp ? parseInt(a.expiryTimestamp, 10) : void 0
  }
}
function fJ(t) {
  return t.startsWith('//') ? t.substring(2) : t
}
function pJ(t, e = '-') {
  const n = 'relay',
    r = {}
  return (
    Object.keys(t).forEach(s => {
      const i = s,
        o = n + e + i
      t[i] && (r[o] = t[i])
    }),
    r
  )
}
function JI(t) {
  const e = new URLSearchParams(),
    n = pJ(t.relay)
  Object.keys(n)
    .sort()
    .forEach(s => {
      e.set(s, n[s])
    }),
    e.set('symKey', t.symKey),
    t.expiryTimestamp && e.set('expiryTimestamp', t.expiryTimestamp.toString()),
    t.methods && e.set('methods', t.methods.join(','))
  const r = e.toString()
  return `${t.protocol}:${t.topic}@${t.version}?${r}`
}
function cg(t, e, n) {
  return `${t}?wc_ev=${n}&topic=${e}`
}
function kd(t) {
  const e = []
  return (
    t.forEach(n => {
      const [r, s] = n.split(':')
      e.push(`${r}:${s}`)
    }),
    e
  )
}
function gJ(t) {
  const e = []
  return (
    Object.values(t).forEach(n => {
      e.push(...kd(n.accounts))
    }),
    e
  )
}
function mJ(t, e) {
  const n = []
  return (
    Object.values(t).forEach(r => {
      kd(r.accounts).includes(e) && n.push(...r.methods)
    }),
    n
  )
}
function yJ(t, e) {
  const n = []
  return (
    Object.values(t).forEach(r => {
      kd(r.accounts).includes(e) && n.push(...r.events)
    }),
    n
  )
}
function OA(t) {
  return t.includes(':')
}
function bh(t) {
  return OA(t) ? t.split(':')[0] : t
}
function wJ(t) {
  const e = {}
  return (
    t == null ||
      t.forEach(n => {
        var r
        const [s, i] = n.split(':')
        e[s] || (e[s] = { accounts: [], chains: [], events: [], methods: [] }),
          e[s].accounts.push(n),
          (r = e[s].chains) == null || r.push(`${s}:${i}`)
      }),
    e
  )
}
function XI(t, e) {
  e = e.map(r => r.replace('did:pkh:', ''))
  const n = wJ(e)
  for (const [r, s] of Object.entries(n))
    s.methods ? (s.methods = Bg(s.methods, t)) : (s.methods = t),
      (s.events = ['chainChanged', 'accountsChanged'])
  return n
}
const bJ = {
    INVALID_METHOD: { message: 'Invalid method.', code: 1001 },
    INVALID_EVENT: { message: 'Invalid event.', code: 1002 },
    INVALID_UPDATE_REQUEST: { message: 'Invalid update request.', code: 1003 },
    INVALID_EXTEND_REQUEST: { message: 'Invalid extend request.', code: 1004 },
    INVALID_SESSION_SETTLE_REQUEST: { message: 'Invalid session settle request.', code: 1005 },
    UNAUTHORIZED_METHOD: { message: 'Unauthorized method.', code: 3001 },
    UNAUTHORIZED_EVENT: { message: 'Unauthorized event.', code: 3002 },
    UNAUTHORIZED_UPDATE_REQUEST: { message: 'Unauthorized update request.', code: 3003 },
    UNAUTHORIZED_EXTEND_REQUEST: { message: 'Unauthorized extend request.', code: 3004 },
    USER_REJECTED: { message: 'User rejected.', code: 5e3 },
    USER_REJECTED_CHAINS: { message: 'User rejected chains.', code: 5001 },
    USER_REJECTED_METHODS: { message: 'User rejected methods.', code: 5002 },
    USER_REJECTED_EVENTS: { message: 'User rejected events.', code: 5003 },
    UNSUPPORTED_CHAINS: { message: 'Unsupported chains.', code: 5100 },
    UNSUPPORTED_METHODS: { message: 'Unsupported methods.', code: 5101 },
    UNSUPPORTED_EVENTS: { message: 'Unsupported events.', code: 5102 },
    UNSUPPORTED_ACCOUNTS: { message: 'Unsupported accounts.', code: 5103 },
    UNSUPPORTED_NAMESPACE_KEY: { message: 'Unsupported namespace key.', code: 5104 },
    USER_DISCONNECTED: { message: 'User disconnected.', code: 6e3 },
    SESSION_SETTLEMENT_FAILED: { message: 'Session settlement failed.', code: 7e3 },
    WC_METHOD_UNSUPPORTED: { message: 'Unsupported wc_ method.', code: 10001 }
  },
  vJ = {
    NOT_INITIALIZED: { message: 'Not initialized.', code: 1 },
    NO_MATCHING_KEY: { message: 'No matching key.', code: 2 },
    RESTORE_WILL_OVERRIDE: { message: 'Restore will override.', code: 3 },
    RESUBSCRIBED: { message: 'Resubscribed.', code: 4 },
    MISSING_OR_INVALID: { message: 'Missing or invalid.', code: 5 },
    EXPIRED: { message: 'Expired.', code: 6 },
    UNKNOWN_TYPE: { message: 'Unknown type.', code: 7 },
    MISMATCHED_TOPIC: { message: 'Mismatched topic.', code: 8 },
    NON_CONFORMING_NAMESPACES: { message: 'Non conforming namespaces.', code: 9 }
  }
function Le(t, e) {
  const { message: n, code: r } = vJ[t]
  return { message: e ? `${n} ${e}` : n, code: r }
}
function an(t, e) {
  const { message: n, code: r } = bJ[t]
  return { message: e ? `${n} ${e}` : n, code: r }
}
function Wa(t, e) {
  return !!Array.isArray(t)
}
function Sf(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length
}
function xr(t) {
  return typeof t > 'u'
}
function Yn(t, e) {
  return e && xr(t) ? !0 : typeof t == 'string' && !!t.trim().length
}
function BA(t, e) {
  return e && xr(t) ? !0 : typeof t == 'number' && !isNaN(t)
}
function EJ(t, e) {
  const { requiredNamespaces: n } = e,
    r = Object.keys(t.namespaces),
    s = Object.keys(n)
  let i = !0
  return Lc(s, r)
    ? (r.forEach(o => {
        const { accounts: a, methods: c, events: u } = t.namespaces[o],
          l = kd(a),
          d = n[o]
        ;(!Lc(Yk(o, d), l) || !Lc(d.methods, c) || !Lc(d.events, u)) && (i = !1)
      }),
      i)
    : !1
}
function Cm(t) {
  return Yn(t, !1) && t.includes(':') ? t.split(':').length === 2 : !1
}
function AJ(t) {
  if (Yn(t, !1) && t.includes(':')) {
    const e = t.split(':')
    if (e.length === 3) {
      const n = e[0] + ':' + e[1]
      return !!e[2] && Cm(n)
    }
  }
  return !1
}
function _J(t) {
  function e(n) {
    try {
      return typeof new URL(n) < 'u'
    } catch {
      return !1
    }
  }
  try {
    if (Yn(t, !1)) {
      if (e(t)) return !0
      const n = nO(t)
      return e(n)
    }
  } catch {}
  return !1
}
function CJ(t) {
  var e
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey
}
function SJ(t) {
  return t == null ? void 0 : t.topic
}
function IJ(t, e) {
  let n = null
  return (
    Yn(t == null ? void 0 : t.publicKey, !1) ||
      (n = Le('MISSING_OR_INVALID', `${e} controller public key should be a string`)),
    n
  )
}
function e2(t) {
  let e = !0
  return Wa(t) ? t.length && (e = t.every(n => Yn(n, !1))) : (e = !1), e
}
function xJ(t, e, n) {
  let r = null
  return (
    Wa(e) && e.length
      ? e.forEach(s => {
          r ||
            Cm(s) ||
            (r = an(
              'UNSUPPORTED_CHAINS',
              `${n}, chain ${s} should be a string and conform to "namespace:chainId" format`
            ))
        })
      : Cm(t) ||
        (r = an(
          'UNSUPPORTED_CHAINS',
          `${n}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`
        )),
    r
  )
}
function TJ(t, e, n) {
  let r = null
  return (
    Object.entries(t).forEach(([s, i]) => {
      if (r) return
      const o = xJ(s, Yk(s, i), `${e} ${n}`)
      o && (r = o)
    }),
    r
  )
}
function NJ(t, e) {
  let n = null
  return (
    Wa(t)
      ? t.forEach(r => {
          n ||
            AJ(r) ||
            (n = an(
              'UNSUPPORTED_ACCOUNTS',
              `${e}, account ${r} should be a string and conform to "namespace:chainId:address" format`
            ))
        })
      : (n = an(
          'UNSUPPORTED_ACCOUNTS',
          `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`
        )),
    n
  )
}
function PJ(t, e) {
  let n = null
  return (
    Object.values(t).forEach(r => {
      if (n) return
      const s = NJ(r == null ? void 0 : r.accounts, `${e} namespace`)
      s && (n = s)
    }),
    n
  )
}
function RJ(t, e) {
  let n = null
  return (
    e2(t == null ? void 0 : t.methods)
      ? e2(t == null ? void 0 : t.events) ||
        (n = an(
          'UNSUPPORTED_EVENTS',
          `${e}, events should be an array of strings or empty array for no events`
        ))
      : (n = an(
          'UNSUPPORTED_METHODS',
          `${e}, methods should be an array of strings or empty array for no methods`
        )),
    n
  )
}
function DO(t, e) {
  let n = null
  return (
    Object.values(t).forEach(r => {
      if (n) return
      const s = RJ(r, `${e}, namespace`)
      s && (n = s)
    }),
    n
  )
}
function kJ(t, e, n) {
  let r = null
  if (t && Sf(t)) {
    const s = DO(t, e)
    s && (r = s)
    const i = TJ(t, e, n)
    i && (r = i)
  } else r = Le('MISSING_OR_INVALID', `${e}, ${n} should be an object with data`)
  return r
}
function Yw(t, e) {
  let n = null
  if (t && Sf(t)) {
    const r = DO(t, e)
    r && (n = r)
    const s = PJ(t, e)
    s && (n = s)
  } else n = Le('MISSING_OR_INVALID', `${e}, namespaces should be an object with data`)
  return n
}
function MO(t) {
  return Yn(t.protocol, !0)
}
function OJ(t, e) {
  let n = !1
  return (
    t
      ? t &&
        Wa(t) &&
        t.length &&
        t.forEach(r => {
          n = MO(r)
        })
      : (n = !0),
    n
  )
}
function BJ(t) {
  return typeof t == 'number'
}
function ws(t) {
  return typeof t < 'u' && typeof t !== null
}
function DJ(t) {
  return !(
    !t ||
    typeof t != 'object' ||
    !t.code ||
    !BA(t.code, !1) ||
    !t.message ||
    !Yn(t.message, !1)
  )
}
function MJ(t) {
  return !(xr(t) || !Yn(t.method, !1))
}
function UJ(t) {
  return !(xr(t) || (xr(t.result) && xr(t.error)) || !BA(t.id, !1) || !Yn(t.jsonrpc, !1))
}
function LJ(t) {
  return !(xr(t) || !Yn(t.name, !1))
}
function t2(t, e) {
  return !(!Cm(e) || !gJ(t).includes(e))
}
function $J(t, e, n) {
  return Yn(n, !1) ? mJ(t, e).includes(n) : !1
}
function FJ(t, e, n) {
  return Yn(n, !1) ? yJ(t, e).includes(n) : !1
}
function n2(t, e, n) {
  let r = null
  const s = jJ(t),
    i = HJ(e),
    o = Object.keys(s),
    a = Object.keys(i),
    c = r2(Object.keys(t)),
    u = r2(Object.keys(e)),
    l = c.filter(d => !u.includes(d))
  return (
    l.length &&
      (r = Le(
        'NON_CONFORMING_NAMESPACES',
        `${n} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l.toString()}
      Received: ${Object.keys(e).toString()}`
      )),
    Lc(o, a) ||
      (r = Le(
        'NON_CONFORMING_NAMESPACES',
        `${n} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`
      )),
    Object.keys(e).forEach(d => {
      if (!d.includes(':') || r) return
      const h = kd(e[d].accounts)
      h.includes(d) ||
        (r = Le(
          'NON_CONFORMING_NAMESPACES',
          `${n} namespaces accounts don't satisfy namespace accounts for ${d}
        Required: ${d}
        Approved: ${h.toString()}`
        ))
    }),
    o.forEach(d => {
      r ||
        (Lc(s[d].methods, i[d].methods)
          ? Lc(s[d].events, i[d].events) ||
            (r = Le(
              'NON_CONFORMING_NAMESPACES',
              `${n} namespaces events don't satisfy namespace events for ${d}`
            ))
          : (r = Le(
              'NON_CONFORMING_NAMESPACES',
              `${n} namespaces methods don't satisfy namespace methods for ${d}`
            )))
    }),
    r
  )
}
function jJ(t) {
  const e = {}
  return (
    Object.keys(t).forEach(n => {
      var r
      n.includes(':')
        ? (e[n] = t[n])
        : (r = t[n].chains) == null ||
          r.forEach(s => {
            e[s] = { methods: t[n].methods, events: t[n].events }
          })
    }),
    e
  )
}
function r2(t) {
  return [...new Set(t.map(e => (e.includes(':') ? e.split(':')[0] : e)))]
}
function HJ(t) {
  const e = {}
  return (
    Object.keys(t).forEach(n => {
      if (n.includes(':')) e[n] = t[n]
      else {
        const r = kd(t[n].accounts)
        r == null ||
          r.forEach(s => {
            e[s] = {
              accounts: t[n].accounts.filter(i => i.includes(`${s}:`)),
              methods: t[n].methods,
              events: t[n].events
            }
          })
      }
    }),
    e
  )
}
function qJ(t, e) {
  return BA(t, !1) && t <= e.max && t >= e.min
}
function s2() {
  const t = mp()
  return new Promise(e => {
    switch (t) {
      case qs.browser:
        e(zJ())
        break
      case qs.reactNative:
        e(WJ())
        break
      case qs.node:
        e(KJ())
        break
      default:
        e(!0)
    }
  })
}
function zJ() {
  return gp() && (navigator == null ? void 0 : navigator.onLine)
}
async function WJ() {
  if (dc() && typeof global < 'u' && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch())
    return t == null ? void 0 : t.isConnected
  }
  return !0
}
function KJ() {
  return !0
}
function VJ(t) {
  switch (mp()) {
    case qs.browser:
      GJ(t)
      break
    case qs.reactNative:
      QJ(t)
      break
  }
}
function GJ(t) {
  !dc() &&
    gp() &&
    (window.addEventListener('online', () => t(!0)),
    window.addEventListener('offline', () => t(!1)))
}
function QJ(t) {
  dc() &&
    typeof global < 'u' &&
    global != null &&
    global.NetInfo &&
    (global == null || global.NetInfo.addEventListener(e => t(e == null ? void 0 : e.isConnected)))
}
const Jw = {}
class Jd {
  static get(e) {
    return Jw[e]
  }
  static set(e, n) {
    Jw[e] = n
  }
  static delete(e) {
    delete Jw[e]
  }
}
const ZJ = 'PARSE_ERROR',
  YJ = 'INVALID_REQUEST',
  JJ = 'METHOD_NOT_FOUND',
  XJ = 'INVALID_PARAMS',
  UO = 'INTERNAL_ERROR',
  DA = 'SERVER_ERROR',
  eX = [-32700, -32600, -32601, -32602, -32603],
  Oh = {
    [ZJ]: { code: -32700, message: 'Parse error' },
    [YJ]: { code: -32600, message: 'Invalid Request' },
    [JJ]: { code: -32601, message: 'Method not found' },
    [XJ]: { code: -32602, message: 'Invalid params' },
    [UO]: { code: -32603, message: 'Internal error' },
    [DA]: { code: -32e3, message: 'Server error' }
  },
  LO = DA
function tX(t) {
  return eX.includes(t)
}
function i2(t) {
  return Object.keys(Oh).includes(t) ? Oh[t] : Oh[LO]
}
function nX(t) {
  const e = Object.values(Oh).find(n => n.code === t)
  return e || Oh[LO]
}
function $O(t, e, n) {
  return t.message.includes('getaddrinfo ENOTFOUND') || t.message.includes('connect ECONNREFUSED')
    ? new Error(`Unavailable ${n} RPC url at ${e}`)
    : t
}
var Xw = {},
  To = {},
  o2
function rX() {
  if (o2) return To
  ;(o2 = 1),
    Object.defineProperty(To, '__esModule', { value: !0 }),
    (To.isBrowserCryptoAvailable = To.getSubtleCrypto = To.getBrowerCrypto = void 0)
  function t() {
    return (Yi == null ? void 0 : Yi.crypto) || (Yi == null ? void 0 : Yi.msCrypto) || {}
  }
  To.getBrowerCrypto = t
  function e() {
    const r = t()
    return r.subtle || r.webkitSubtle
  }
  To.getSubtleCrypto = e
  function n() {
    return !!t() && !!e()
  }
  return (To.isBrowserCryptoAvailable = n), To
}
var No = {},
  a2
function sX() {
  if (a2) return No
  ;(a2 = 1),
    Object.defineProperty(No, '__esModule', { value: !0 }),
    (No.isBrowser = No.isNode = No.isReactNative = void 0)
  function t() {
    return typeof document > 'u' && typeof navigator < 'u' && navigator.product === 'ReactNative'
  }
  No.isReactNative = t
  function e() {
    return (
      typeof process < 'u' && typeof process.versions < 'u' && typeof process.versions.node < 'u'
    )
  }
  No.isNode = e
  function n() {
    return !t() && !e()
  }
  return (No.isBrowser = n), No
}
var c2
function iX() {
  return (
    c2 ||
      ((c2 = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 })
        const e = up
        e.__exportStar(rX(), t), e.__exportStar(sX(), t)
      })(Xw)),
    Xw
  )
}
var oX = iX()
function Wi(t = 3) {
  const e = Date.now() * Math.pow(10, t),
    n = Math.floor(Math.random() * Math.pow(10, t))
  return e + n
}
function $c(t = 6) {
  return BigInt(Wi(t))
}
function Ua(t, e, n) {
  return { id: n || Wi(), jsonrpc: '2.0', method: t, params: e }
}
function H0(t, e) {
  return { id: t, jsonrpc: '2.0', result: e }
}
function q0(t, e, n) {
  return { id: t, jsonrpc: '2.0', error: aX(e) }
}
function aX(t, e) {
  return typeof t > 'u'
    ? i2(UO)
    : (typeof t == 'string' && (t = Object.assign(Object.assign({}, i2(DA)), { message: t })),
      tX(t.code) && (t = nX(t.code)),
      t)
}
let cX = class {},
  uX = class extends cX {
    constructor() {
      super()
    }
  },
  lX = class extends uX {
    constructor(e) {
      super()
    }
  }
const dX = '^https?:',
  hX = '^wss?:'
function fX(t) {
  const e = t.match(new RegExp(/^\w+:/, 'gi'))
  if (!(!e || !e.length)) return e[0]
}
function FO(t, e) {
  const n = fX(t)
  return typeof n > 'u' ? !1 : new RegExp(e).test(n)
}
function u2(t) {
  return FO(t, dX)
}
function l2(t) {
  return FO(t, hX)
}
function pX(t) {
  return new RegExp('wss?://localhost(:d{2,5})?').test(t)
}
function jO(t) {
  return typeof t == 'object' && 'id' in t && 'jsonrpc' in t && t.jsonrpc === '2.0'
}
function MA(t) {
  return jO(t) && 'method' in t
}
function z0(t) {
  return jO(t) && (Ki(t) || ri(t))
}
function Ki(t) {
  return 'result' in t
}
function ri(t) {
  return 'error' in t
}
let li = class extends lX {
  constructor(e) {
    super(e),
      (this.events = new ui.EventEmitter()),
      (this.hasRegisteredEventListeners = !1),
      (this.connection = this.setConnection(e)),
      this.connection.connected && this.registerEventListeners()
  }
  async connect(e = this.connection) {
    await this.open(e)
  }
  async disconnect() {
    await this.close()
  }
  on(e, n) {
    this.events.on(e, n)
  }
  once(e, n) {
    this.events.once(e, n)
  }
  off(e, n) {
    this.events.off(e, n)
  }
  removeListener(e, n) {
    this.events.removeListener(e, n)
  }
  async request(e, n) {
    return this.requestStrict(Ua(e.method, e.params || [], e.id || $c().toString()), n)
  }
  async requestStrict(e, n) {
    return new Promise(async (r, s) => {
      if (!this.connection.connected)
        try {
          await this.open()
        } catch (i) {
          s(i)
        }
      this.events.on(`${e.id}`, i => {
        ri(i) ? s(i.error) : r(i.result)
      })
      try {
        await this.connection.send(e, n)
      } catch (i) {
        s(i)
      }
    })
  }
  setConnection(e = this.connection) {
    return e
  }
  onPayload(e) {
    this.events.emit('payload', e),
      z0(e)
        ? this.events.emit(`${e.id}`, e)
        : this.events.emit('message', { type: e.method, data: e.params })
  }
  onClose(e) {
    e &&
      e.code === 3e3 &&
      this.events.emit(
        'error',
        new Error(
          `WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ''}`
        )
      ),
      this.events.emit('disconnect')
  }
  async open(e = this.connection) {
    ;(this.connection === e && this.connection.connected) ||
      (this.connection.connected && this.close(),
      typeof e == 'string' && (await this.connection.open(e), (e = this.connection)),
      (this.connection = this.setConnection(e)),
      await this.connection.open(),
      this.registerEventListeners(),
      this.events.emit('connect'))
  }
  async close() {
    await this.connection.close()
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners ||
      (this.connection.on('payload', e => this.onPayload(e)),
      this.connection.on('close', e => this.onClose(e)),
      this.connection.on('error', e => this.events.emit('error', e)),
      this.connection.on('register_error', e => this.onClose()),
      (this.hasRegisteredEventListeners = !0))
  }
}
const gX = () =>
    typeof WebSocket < 'u'
      ? WebSocket
      : typeof global < 'u' && typeof globalThis.WebSocket < 'u'
        ? global.WebSocket
        : typeof window < 'u' && typeof window.WebSocket < 'u'
          ? window.WebSocket
          : typeof self < 'u' && typeof self.WebSocket < 'u'
            ? self.WebSocket
            : require('ws'),
  mX = () =>
    typeof WebSocket < 'u' ||
    (typeof global < 'u' && typeof globalThis.WebSocket < 'u') ||
    (typeof window < 'u' && typeof window.WebSocket < 'u') ||
    (typeof self < 'u' && typeof self.WebSocket < 'u'),
  d2 = t => t.split('?')[0],
  h2 = 10,
  yX = gX()
let wX = class {
  constructor(e) {
    if (((this.url = e), (this.events = new ui.EventEmitter()), (this.registering = !1), !l2(e)))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`)
    this.url = e
  }
  get connected() {
    return typeof this.socket < 'u'
  }
  get connecting() {
    return this.registering
  }
  on(e, n) {
    this.events.on(e, n)
  }
  once(e, n) {
    this.events.once(e, n)
  }
  off(e, n) {
    this.events.off(e, n)
  }
  removeListener(e, n) {
    this.events.removeListener(e, n)
  }
  async open(e = this.url) {
    await this.register(e)
  }
  async close() {
    return new Promise((e, n) => {
      if (typeof this.socket > 'u') {
        n(new Error('Connection already closed'))
        return
      }
      ;(this.socket.onclose = r => {
        this.onClose(r), e()
      }),
        this.socket.close()
    })
  }
  async send(e) {
    typeof this.socket > 'u' && (this.socket = await this.register())
    try {
      this.socket.send(Jo(e))
    } catch (n) {
      this.onError(e.id, n)
    }
  }
  register(e = this.url) {
    if (!l2(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`)
    if (this.registering) {
      const n = this.events.getMaxListeners()
      return (
        (this.events.listenerCount('register_error') >= n ||
          this.events.listenerCount('open') >= n) &&
          this.events.setMaxListeners(n + 1),
        new Promise((r, s) => {
          this.events.once('register_error', i => {
            this.resetMaxListeners(), s(i)
          }),
            this.events.once('open', () => {
              if ((this.resetMaxListeners(), typeof this.socket > 'u'))
                return s(new Error('WebSocket connection is missing or invalid'))
              r(this.socket)
            })
        })
      )
    }
    return (
      (this.url = e),
      (this.registering = !0),
      new Promise((n, r) => {
        const s = oX.isReactNative() ? void 0 : { rejectUnauthorized: !pX(e) },
          i = new yX(e, [], s)
        mX()
          ? (i.onerror = o => {
              const a = o
              r(this.emitError(a.error))
            })
          : i.on('error', o => {
              r(this.emitError(o))
            }),
          (i.onopen = () => {
            this.onOpen(i), n(i)
          })
      })
    )
  }
  onOpen(e) {
    ;(e.onmessage = n => this.onPayload(n)),
      (e.onclose = n => this.onClose(n)),
      (this.socket = e),
      (this.registering = !1),
      this.events.emit('open')
  }
  onClose(e) {
    ;(this.socket = void 0), (this.registering = !1), this.events.emit('close', e)
  }
  onPayload(e) {
    if (typeof e.data > 'u') return
    const n = typeof e.data == 'string' ? hu(e.data) : e.data
    this.events.emit('payload', n)
  }
  onError(e, n) {
    const r = this.parseError(n),
      s = r.message || r.toString(),
      i = q0(e, s)
    this.events.emit('payload', i)
  }
  parseError(e, n = this.url) {
    return $O(e, d2(n), 'WS')
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h2 && this.events.setMaxListeners(h2)
  }
  emitError(e) {
    const n = this.parseError(
      new Error(
        (e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${d2(this.url)}`
      )
    )
    return this.events.emit('register_error', n), n
  }
}
var bX = {}
const HO = 'wc',
  qO = 2,
  yv = 'core',
  co = `${HO}@2:${yv}:`,
  vX = { logger: 'error' },
  EX = { database: ':memory:' },
  AX = 'crypto',
  f2 = 'client_ed25519_seed',
  _X = Me.ONE_DAY,
  CX = 'keychain',
  SX = '0.3',
  IX = 'messages',
  xX = '0.3',
  p2 = Me.SIX_HOURS,
  TX = 'publisher',
  zO = 'irn',
  NX = 'error',
  WO = 'wss://relay.walletconnect.org',
  PX = 'relayer',
  hr = {
    message: 'relayer_message',
    message_ack: 'relayer_message_ack',
    connect: 'relayer_connect',
    disconnect: 'relayer_disconnect',
    error: 'relayer_error',
    connection_stalled: 'relayer_connection_stalled',
    transport_closed: 'relayer_transport_closed',
    publish: 'relayer_publish'
  },
  RX = '_subscription',
  Gs = { payload: 'payload', connect: 'connect', disconnect: 'disconnect', error: 'error' },
  kX = 0.1,
  wv = '2.19.2',
  Sn = { link_mode: 'link_mode', relay: 'relay' },
  Ug = { inbound: 'inbound', outbound: 'outbound' },
  OX = '0.3',
  BX = 'WALLETCONNECT_CLIENT_ID',
  g2 = 'WALLETCONNECT_LINK_MODE_APPS',
  ks = {
    created: 'subscription_created',
    deleted: 'subscription_deleted',
    expired: 'subscription_expired',
    disabled: 'subscription_disabled',
    sync: 'subscription_sync',
    resubscribed: 'subscription_resubscribed'
  },
  DX = 'subscription',
  MX = '0.3',
  UX = 'pairing',
  LX = '0.3',
  Xd = {
    wc_pairingDelete: {
      req: { ttl: Me.ONE_DAY, prompt: !1, tag: 1e3 },
      res: { ttl: Me.ONE_DAY, prompt: !1, tag: 1001 }
    },
    wc_pairingPing: {
      req: { ttl: Me.THIRTY_SECONDS, prompt: !1, tag: 1002 },
      res: { ttl: Me.THIRTY_SECONDS, prompt: !1, tag: 1003 }
    },
    unregistered_method: {
      req: { ttl: Me.ONE_DAY, prompt: !1, tag: 0 },
      res: { ttl: Me.ONE_DAY, prompt: !1, tag: 0 }
    }
  },
  kc = {
    create: 'pairing_create',
    expire: 'pairing_expire',
    delete: 'pairing_delete',
    ping: 'pairing_ping'
  },
  pi = {
    created: 'history_created',
    updated: 'history_updated',
    deleted: 'history_deleted',
    sync: 'history_sync'
  },
  $X = 'history',
  FX = '0.3',
  jX = 'expirer',
  ti = {
    created: 'expirer_created',
    deleted: 'expirer_deleted',
    expired: 'expirer_expired',
    sync: 'expirer_sync'
  },
  HX = '0.3',
  qX = 'verify-api',
  zX = 'https://verify.walletconnect.com',
  KO = 'https://verify.walletconnect.org',
  Bh = KO,
  WX = `${Bh}/v3`,
  KX = [zX, KO],
  VX = 'echo',
  GX = 'https://echo.walletconnect.com',
  qi = {
    pairing_started: 'pairing_started',
    pairing_uri_validation_success: 'pairing_uri_validation_success',
    pairing_uri_not_expired: 'pairing_uri_not_expired',
    store_new_pairing: 'store_new_pairing',
    subscribing_pairing_topic: 'subscribing_pairing_topic',
    subscribe_pairing_topic_success: 'subscribe_pairing_topic_success',
    existing_pairing: 'existing_pairing',
    pairing_not_expired: 'pairing_not_expired',
    emit_inactive_pairing: 'emit_inactive_pairing',
    emit_session_proposal: 'emit_session_proposal',
    subscribing_to_pairing_topic: 'subscribing_to_pairing_topic'
  },
  Do = {
    no_wss_connection: 'no_wss_connection',
    no_internet_connection: 'no_internet_connection',
    malformed_pairing_uri: 'malformed_pairing_uri',
    active_pairing_already_exists: 'active_pairing_already_exists',
    subscribe_pairing_topic_failure: 'subscribe_pairing_topic_failure',
    pairing_expired: 'pairing_expired',
    proposal_expired: 'proposal_expired',
    proposal_listener_not_found: 'proposal_listener_not_found'
  },
  gi = {
    session_approve_started: 'session_approve_started',
    proposal_not_expired: 'proposal_not_expired',
    session_namespaces_validation_success: 'session_namespaces_validation_success',
    create_session_topic: 'create_session_topic',
    subscribing_session_topic: 'subscribing_session_topic',
    subscribe_session_topic_success: 'subscribe_session_topic_success',
    publishing_session_approve: 'publishing_session_approve',
    session_approve_publish_success: 'session_approve_publish_success',
    store_session: 'store_session',
    publishing_session_settle: 'publishing_session_settle',
    session_settle_publish_success: 'session_settle_publish_success'
  },
  wc = {
    no_internet_connection: 'no_internet_connection',
    no_wss_connection: 'no_wss_connection',
    proposal_expired: 'proposal_expired',
    subscribe_session_topic_failure: 'subscribe_session_topic_failure',
    session_approve_publish_failure: 'session_approve_publish_failure',
    session_settle_publish_failure: 'session_settle_publish_failure',
    session_approve_namespace_validation_failure: 'session_approve_namespace_validation_failure',
    proposal_not_found: 'proposal_not_found'
  },
  bc = {
    authenticated_session_approve_started: 'authenticated_session_approve_started',
    create_authenticated_session_topic: 'create_authenticated_session_topic',
    cacaos_verified: 'cacaos_verified',
    store_authenticated_session: 'store_authenticated_session',
    subscribing_authenticated_session_topic: 'subscribing_authenticated_session_topic',
    subscribe_authenticated_session_topic_success: 'subscribe_authenticated_session_topic_success',
    publishing_authenticated_session_approve: 'publishing_authenticated_session_approve'
  },
  eh = {
    no_internet_connection: 'no_internet_connection',
    invalid_cacao: 'invalid_cacao',
    subscribe_authenticated_session_topic_failure: 'subscribe_authenticated_session_topic_failure',
    authenticated_session_approve_publish_failure: 'authenticated_session_approve_publish_failure',
    authenticated_session_pending_request_not_found:
      'authenticated_session_pending_request_not_found'
  },
  QX = 0.1,
  ZX = 'event-client',
  YX = 86400,
  JX = 'https://pulse.walletconnect.org/batch'
function XX(t, e) {
  if (t.length >= 255) throw new TypeError('Alphabet too long')
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255
  for (var s = 0; s < t.length; s++) {
    var i = t.charAt(s),
      o = i.charCodeAt(0)
    if (n[o] !== 255) throw new TypeError(i + ' is ambiguous')
    n[o] = s
  }
  var a = t.length,
    c = t.charAt(0),
    u = Math.log(a) / Math.log(256),
    l = Math.log(256) / Math.log(a)
  function d(y) {
    if (
      (y instanceof Uint8Array ||
        (ArrayBuffer.isView(y)
          ? (y = new Uint8Array(y.buffer, y.byteOffset, y.byteLength))
          : Array.isArray(y) && (y = Uint8Array.from(y))),
      !(y instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (y.length === 0) return ''
    for (var m = 0, b = 0, I = 0, x = y.length; I !== x && y[I] === 0; ) I++, m++
    for (var _ = ((x - I) * l + 1) >>> 0, R = new Uint8Array(_); I !== x; ) {
      for (var N = y[I], T = 0, M = _ - 1; (N !== 0 || T < b) && M !== -1; M--, T++)
        (N += (256 * R[M]) >>> 0), (R[M] = N % a >>> 0), (N = (N / a) >>> 0)
      if (N !== 0) throw new Error('Non-zero carry')
      ;(b = T), I++
    }
    for (var H = _ - b; H !== _ && R[H] === 0; ) H++
    for (var B = c.repeat(m); H < _; ++H) B += t.charAt(R[H])
    return B
  }
  function h(y) {
    if (typeof y != 'string') throw new TypeError('Expected String')
    if (y.length === 0) return new Uint8Array()
    var m = 0
    if (y[m] !== ' ') {
      for (var b = 0, I = 0; y[m] === c; ) b++, m++
      for (var x = ((y.length - m) * u + 1) >>> 0, _ = new Uint8Array(x); y[m]; ) {
        var R = n[y.charCodeAt(m)]
        if (R === 255) return
        for (var N = 0, T = x - 1; (R !== 0 || N < I) && T !== -1; T--, N++)
          (R += (a * _[T]) >>> 0), (_[T] = R % 256 >>> 0), (R = (R / 256) >>> 0)
        if (R !== 0) throw new Error('Non-zero carry')
        ;(I = N), m++
      }
      if (y[m] !== ' ') {
        for (var M = x - I; M !== x && _[M] === 0; ) M++
        for (var H = new Uint8Array(b + (x - M)), B = b; M !== x; ) H[B++] = _[M++]
        return H
      }
    }
  }
  function p(y) {
    var m = h(y)
    if (m) return m
    throw new Error(`Non-${e} character`)
  }
  return { encode: d, decodeUnsafe: h, decode: p }
}
var eee = XX,
  tee = eee
const VO = t => {
    if (t instanceof Uint8Array && t.constructor.name === 'Uint8Array') return t
    if (t instanceof ArrayBuffer) return new Uint8Array(t)
    if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
    throw new Error('Unknown type, must be binary type')
  },
  nee = t => new TextEncoder().encode(t),
  ree = t => new TextDecoder().decode(t)
class see {
  constructor(e, n, r) {
    ;(this.name = e), (this.prefix = n), (this.baseEncode = r)
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
    throw Error('Unknown type, must be binary type')
  }
}
class iee {
  constructor(e, n, r) {
    if (((this.name = e), (this.prefix = n), n.codePointAt(0) === void 0))
      throw new Error('Invalid prefix character')
    ;(this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = r)
  }
  decode(e) {
    if (typeof e == 'string') {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(
          `Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`
        )
      return this.baseDecode(e.slice(this.prefix.length))
    } else throw Error('Can only multibase decode strings')
  }
  or(e) {
    return GO(this, e)
  }
}
class oee {
  constructor(e) {
    this.decoders = e
  }
  or(e) {
    return GO(this, e)
  }
  decode(e) {
    const n = e[0],
      r = this.decoders[n]
    if (r) return r.decode(e)
    throw RangeError(
      `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
    )
  }
}
const GO = (t, e) =>
  new oee({ ...(t.decoders || { [t.prefix]: t }), ...(e.decoders || { [e.prefix]: e }) })
class aee {
  constructor(e, n, r, s) {
    ;(this.name = e),
      (this.prefix = n),
      (this.baseEncode = r),
      (this.baseDecode = s),
      (this.encoder = new see(e, n, r)),
      (this.decoder = new iee(e, n, s))
  }
  encode(e) {
    return this.encoder.encode(e)
  }
  decode(e) {
    return this.decoder.decode(e)
  }
}
const W0 = ({ name: t, prefix: e, encode: n, decode: r }) => new aee(t, e, n, r),
  Ap = ({ prefix: t, name: e, alphabet: n }) => {
    const { encode: r, decode: s } = tee(n, e)
    return W0({ prefix: t, name: e, encode: r, decode: i => VO(s(i)) })
  },
  cee = (t, e, n, r) => {
    const s = {}
    for (let l = 0; l < e.length; ++l) s[e[l]] = l
    let i = t.length
    for (; t[i - 1] === '='; ) --i
    const o = new Uint8Array(((i * n) / 8) | 0)
    let a = 0,
      c = 0,
      u = 0
    for (let l = 0; l < i; ++l) {
      const d = s[t[l]]
      if (d === void 0) throw new SyntaxError(`Non-${r} character`)
      ;(c = (c << n) | d), (a += n), a >= 8 && ((a -= 8), (o[u++] = 255 & (c >> a)))
    }
    if (a >= n || 255 & (c << (8 - a))) throw new SyntaxError('Unexpected end of data')
    return o
  },
  uee = (t, e, n) => {
    const r = e[e.length - 1] === '=',
      s = (1 << n) - 1
    let i = '',
      o = 0,
      a = 0
    for (let c = 0; c < t.length; ++c)
      for (a = (a << 8) | t[c], o += 8; o > n; ) (o -= n), (i += e[s & (a >> o)])
    if ((o && (i += e[s & (a << (n - o))]), r)) for (; (i.length * n) & 7; ) i += '='
    return i
  },
  Br = ({ name: t, prefix: e, bitsPerChar: n, alphabet: r }) =>
    W0({
      prefix: e,
      name: t,
      encode(s) {
        return uee(s, r, n)
      },
      decode(s) {
        return cee(s, r, n, t)
      }
    }),
  lee = W0({ prefix: '\0', name: 'identity', encode: t => ree(t), decode: t => nee(t) })
var dee = Object.freeze({ __proto__: null, identity: lee })
const hee = Br({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 })
var fee = Object.freeze({ __proto__: null, base2: hee })
const pee = Br({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 })
var gee = Object.freeze({ __proto__: null, base8: pee })
const mee = Ap({ prefix: '9', name: 'base10', alphabet: '0123456789' })
var yee = Object.freeze({ __proto__: null, base10: mee })
const wee = Br({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 }),
  bee = Br({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 })
var vee = Object.freeze({ __proto__: null, base16: wee, base16upper: bee })
const Eee = Br({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
  }),
  Aee = Br({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
  }),
  _ee = Br({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
  }),
  Cee = Br({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
  }),
  See = Br({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
  }),
  Iee = Br({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
  }),
  xee = Br({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
  }),
  Tee = Br({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
  }),
  Nee = Br({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
  })
var Pee = Object.freeze({
  __proto__: null,
  base32: Eee,
  base32upper: Aee,
  base32pad: _ee,
  base32padupper: Cee,
  base32hex: See,
  base32hexupper: Iee,
  base32hexpad: xee,
  base32hexpadupper: Tee,
  base32z: Nee
})
const Ree = Ap({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' }),
  kee = Ap({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' })
var Oee = Object.freeze({ __proto__: null, base36: Ree, base36upper: kee })
const Bee = Ap({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
  }),
  Dee = Ap({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
  })
var Mee = Object.freeze({ __proto__: null, base58btc: Bee, base58flickr: Dee })
const Uee = Br({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
  }),
  Lee = Br({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
  }),
  $ee = Br({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
  }),
  Fee = Br({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
  })
var jee = Object.freeze({
  __proto__: null,
  base64: Uee,
  base64pad: Lee,
  base64url: $ee,
  base64urlpad: Fee
})
const QO = Array.from(
    ''
  ),
  Hee = QO.reduce((t, e, n) => ((t[n] = e), t), []),
  qee = QO.reduce((t, e, n) => ((t[e.codePointAt(0)] = n), t), [])
function zee(t) {
  return t.reduce((e, n) => ((e += Hee[n]), e), '')
}
function Wee(t) {
  const e = []
  for (const n of t) {
    const r = qee[n.codePointAt(0)]
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`)
    e.push(r)
  }
  return new Uint8Array(e)
}
const Kee = W0({ prefix: '', name: 'base256emoji', encode: zee, decode: Wee })
var Vee = Object.freeze({ __proto__: null, base256emoji: Kee }),
  Gee = ZO,
  m2 = 128,
  Qee = -128,
  Zee = Math.pow(2, 31)
function ZO(t, e, n) {
  ;(e = e || []), (n = n || 0)
  for (var r = n; t >= Zee; ) (e[n++] = (t & 255) | m2), (t /= 128)
  for (; t & Qee; ) (e[n++] = (t & 255) | m2), (t >>>= 7)
  return (e[n] = t | 0), (ZO.bytes = n - r + 1), e
}
var Yee = bv,
  Jee = 128,
  y2 = 127
function bv(t, r) {
  var n = 0,
    r = r || 0,
    s = 0,
    i = r,
    o,
    a = t.length
  do {
    if (i >= a) throw ((bv.bytes = 0), new RangeError('Could not decode varint'))
    ;(o = t[i++]), (n += s < 28 ? (o & y2) << s : (o & y2) * Math.pow(2, s)), (s += 7)
  } while (o >= Jee)
  return (bv.bytes = i - r), n
}
var Xee = Math.pow(2, 7),
  ete = Math.pow(2, 14),
  tte = Math.pow(2, 21),
  nte = Math.pow(2, 28),
  rte = Math.pow(2, 35),
  ste = Math.pow(2, 42),
  ite = Math.pow(2, 49),
  ote = Math.pow(2, 56),
  ate = Math.pow(2, 63),
  cte = function (t) {
    return t < Xee
      ? 1
      : t < ete
        ? 2
        : t < tte
          ? 3
          : t < nte
            ? 4
            : t < rte
              ? 5
              : t < ste
                ? 6
                : t < ite
                  ? 7
                  : t < ote
                    ? 8
                    : t < ate
                      ? 9
                      : 10
  },
  ute = { encode: Gee, decode: Yee, encodingLength: cte },
  YO = ute
const w2 = (t, e, n = 0) => (YO.encode(t, e, n), e),
  b2 = t => YO.encodingLength(t),
  vv = (t, e) => {
    const n = e.byteLength,
      r = b2(t),
      s = r + b2(n),
      i = new Uint8Array(s + n)
    return w2(t, i, 0), w2(n, i, r), i.set(e, s), new lte(t, n, e, i)
  }
let lte = class {
  constructor(e, n, r, s) {
    ;(this.code = e), (this.size = n), (this.digest = r), (this.bytes = s)
  }
}
const JO = ({ name: t, code: e, encode: n }) => new dte(t, e, n)
class dte {
  constructor(e, n, r) {
    ;(this.name = e), (this.code = n), (this.encode = r)
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const n = this.encode(e)
      return n instanceof Uint8Array ? vv(this.code, n) : n.then(r => vv(this.code, r))
    } else throw Error('Unknown type, must be binary type')
  }
}
const XO = t => async e => new Uint8Array(await crypto.subtle.digest(t, e)),
  hte = JO({ name: 'sha2-256', code: 18, encode: XO('SHA-256') }),
  fte = JO({ name: 'sha2-512', code: 19, encode: XO('SHA-512') })
var pte = Object.freeze({ __proto__: null, sha256: hte, sha512: fte })
const e8 = 0,
  gte = 'identity',
  t8 = VO,
  mte = t => vv(e8, t8(t)),
  yte = { code: e8, name: gte, encode: t8, digest: mte }
var wte = Object.freeze({ __proto__: null, identity: yte })
new TextEncoder(), new TextDecoder()
const v2 = { ...dee, ...fee, ...gee, ...yee, ...vee, ...Pee, ...Oee, ...Mee, ...jee, ...Vee }
;({ ...pte, ...wte })
function bte(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? globalThis.Buffer.allocUnsafe(t)
    : new Uint8Array(t)
}
function n8(t, e, n, r) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: n }, decoder: { decode: r } }
}
const E2 = n8(
    'utf8',
    'u',
    t => 'u' + new TextDecoder('utf8').decode(t),
    t => new TextEncoder().encode(t.substring(1))
  ),
  eb = n8(
    'ascii',
    'a',
    t => {
      let e = 'a'
      for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n])
      return e
    },
    t => {
      t = t.substring(1)
      const e = bte(t.length)
      for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n)
      return e
    }
  ),
  vte = { utf8: E2, 'utf-8': E2, hex: v2.base16, latin1: eb, ascii: eb, binary: eb, ...v2 }
function Ete(t, e = 'utf8') {
  const n = vte[e]
  if (!n) throw new Error(`Unsupported encoding "${e}"`)
  return (e === 'utf8' || e === 'utf-8') &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t, 'utf8')
    : n.decoder.decode(`${n.prefix}${t}`)
}
var Ate = Object.defineProperty,
  _te = (t, e, n) =>
    e in t ? Ate(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Fi = (t, e, n) => _te(t, typeof e != 'symbol' ? e + '' : e, n)
class Cte {
  constructor(e, n) {
    ;(this.core = e),
      (this.logger = n),
      Fi(this, 'keychain', new Map()),
      Fi(this, 'name', CX),
      Fi(this, 'version', SX),
      Fi(this, 'initialized', !1),
      Fi(this, 'storagePrefix', co),
      Fi(this, 'init', async () => {
        if (!this.initialized) {
          const r = await this.getKeyChain()
          typeof r < 'u' && (this.keychain = r), (this.initialized = !0)
        }
      }),
      Fi(this, 'has', r => (this.isInitialized(), this.keychain.has(r))),
      Fi(this, 'set', async (r, s) => {
        this.isInitialized(), this.keychain.set(r, s), await this.persist()
      }),
      Fi(this, 'get', r => {
        this.isInitialized()
        const s = this.keychain.get(r)
        if (typeof s > 'u') {
          const { message: i } = Le('NO_MATCHING_KEY', `${this.name}: ${r}`)
          throw new Error(i)
        }
        return s
      }),
      Fi(this, 'del', async r => {
        this.isInitialized(), this.keychain.delete(r), await this.persist()
      }),
      (this.core = e),
      (this.logger = Jr(n, this.name))
  }
  get context() {
    return Is(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, iv(e))
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey)
    return typeof e < 'u' ? ov(e) : void 0
  }
  async persist() {
    await this.setKeyChain(this.keychain)
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Le('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
}
var Ste = Object.defineProperty,
  Ite = (t, e, n) =>
    e in t ? Ste(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Ar = (t, e, n) => Ite(t, typeof e != 'symbol' ? e + '' : e, n)
class xte {
  constructor(e, n, r) {
    ;(this.core = e),
      (this.logger = n),
      Ar(this, 'name', AX),
      Ar(this, 'keychain'),
      Ar(this, 'randomSessionIdentifier', mv()),
      Ar(this, 'initialized', !1),
      Ar(this, 'init', async () => {
        this.initialized || (await this.keychain.init(), (this.initialized = !0))
      }),
      Ar(this, 'hasKeys', s => (this.isInitialized(), this.keychain.has(s))),
      Ar(this, 'getClientId', async () => {
        this.isInitialized()
        const s = await this.getClientSeed(),
          i = iI(s)
        return Mk(i.publicKey)
      }),
      Ar(this, 'generateKeyPair', () => {
        this.isInitialized()
        const s = nJ()
        return this.setPrivateKey(s.publicKey, s.privateKey)
      }),
      Ar(this, 'signJWT', async s => {
        this.isInitialized()
        const i = await this.getClientSeed(),
          o = iI(i),
          a = this.randomSessionIdentifier
        return await UV(a, s, _X, o)
      }),
      Ar(this, 'generateSharedKey', (s, i, o) => {
        this.isInitialized()
        const a = this.getPrivateKey(s),
          c = rJ(a, i)
        return this.setSymKey(c, o)
      }),
      Ar(this, 'setSymKey', async (s, i) => {
        this.isInitialized()
        const o = i || Mg(s)
        return await this.keychain.set(o, s), o
      }),
      Ar(this, 'deleteKeyPair', async s => {
        this.isInitialized(), await this.keychain.del(s)
      }),
      Ar(this, 'deleteSymKey', async s => {
        this.isInitialized(), await this.keychain.del(s)
      }),
      Ar(this, 'encode', async (s, i, o) => {
        this.isInitialized()
        const a = BO(o),
          c = Jo(i)
        if (ZI(a)) return oJ(c, o == null ? void 0 : o.encoding)
        if (QI(a)) {
          const h = a.senderPublicKey,
            p = a.receiverPublicKey
          s = await this.generateSharedKey(h, p)
        }
        const u = this.getSymKey(s),
          { type: l, senderPublicKey: d } = a
        return sJ({
          type: l,
          symKey: u,
          message: c,
          senderPublicKey: d,
          encoding: o == null ? void 0 : o.encoding
        })
      }),
      Ar(this, 'decode', async (s, i, o) => {
        this.isInitialized()
        const a = cJ(i, o)
        if (ZI(a)) {
          const c = aJ(i, o == null ? void 0 : o.encoding)
          return hu(c)
        }
        if (QI(a)) {
          const c = a.receiverPublicKey,
            u = a.senderPublicKey
          s = await this.generateSharedKey(c, u)
        }
        try {
          const c = this.getSymKey(s),
            u = iJ({ symKey: c, encoded: i, encoding: o == null ? void 0 : o.encoding })
          return hu(u)
        } catch (c) {
          this.logger.error(
            `Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`
          ),
            this.logger.error(c)
        }
      }),
      Ar(this, 'getPayloadType', (s, i = Ii) => {
        const o = Cf({ encoded: s, encoding: i })
        return yu(o.type)
      }),
      Ar(this, 'getPayloadSenderPublicKey', (s, i = Ii) => {
        const o = Cf({ encoded: s, encoding: i })
        return o.senderPublicKey ? _s(o.senderPublicKey, us) : void 0
      }),
      (this.core = e),
      (this.logger = Jr(n, this.name)),
      (this.keychain = r || new Cte(this.core, this.logger))
  }
  get context() {
    return Is(this.logger)
  }
  async setPrivateKey(e, n) {
    return await this.keychain.set(e, n), e
  }
  getPrivateKey(e) {
    return this.keychain.get(e)
  }
  async getClientSeed() {
    let e = ''
    try {
      e = this.keychain.get(f2)
    } catch {
      ;(e = mv()), await this.keychain.set(f2, e)
    }
    return Ete(e, 'base16')
  }
  getSymKey(e) {
    return this.keychain.get(e)
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Le('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
}
var Tte = Object.defineProperty,
  Nte = Object.defineProperties,
  Pte = Object.getOwnPropertyDescriptors,
  A2 = Object.getOwnPropertySymbols,
  Rte = Object.prototype.hasOwnProperty,
  kte = Object.prototype.propertyIsEnumerable,
  Ev = (t, e, n) =>
    e in t ? Tte(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Ote = (t, e) => {
    for (var n in e || (e = {})) Rte.call(e, n) && Ev(t, n, e[n])
    if (A2) for (var n of A2(e)) kte.call(e, n) && Ev(t, n, e[n])
    return t
  },
  Bte = (t, e) => Nte(t, Pte(e)),
  Ts = (t, e, n) => Ev(t, typeof e != 'symbol' ? e + '' : e, n)
class Dte extends Dz {
  constructor(e, n) {
    super(e, n),
      (this.logger = e),
      (this.core = n),
      Ts(this, 'messages', new Map()),
      Ts(this, 'messagesWithoutClientAck', new Map()),
      Ts(this, 'name', IX),
      Ts(this, 'version', xX),
      Ts(this, 'initialized', !1),
      Ts(this, 'storagePrefix', co),
      Ts(this, 'init', async () => {
        if (!this.initialized) {
          this.logger.trace('Initialized')
          try {
            const r = await this.getRelayerMessages()
            typeof r < 'u' && (this.messages = r)
            const s = await this.getRelayerMessagesWithoutClientAck()
            typeof s < 'u' && (this.messagesWithoutClientAck = s),
              this.logger.debug(`Successfully Restored records for ${this.name}`),
              this.logger.trace({ type: 'method', method: 'restore', size: this.messages.size })
          } catch (r) {
            this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(r)
          } finally {
            this.initialized = !0
          }
        }
      }),
      Ts(this, 'set', async (r, s, i) => {
        this.isInitialized()
        const o = Ji(s)
        let a = this.messages.get(r)
        if ((typeof a > 'u' && (a = {}), typeof a[o] < 'u')) return o
        if (((a[o] = s), this.messages.set(r, a), i === Ug.inbound)) {
          const c = this.messagesWithoutClientAck.get(r) || {}
          this.messagesWithoutClientAck.set(r, Bte(Ote({}, c), { [o]: s }))
        }
        return await this.persist(), o
      }),
      Ts(this, 'get', r => {
        this.isInitialized()
        let s = this.messages.get(r)
        return typeof s > 'u' && (s = {}), s
      }),
      Ts(this, 'getWithoutAck', r => {
        this.isInitialized()
        const s = {}
        for (const i of r) {
          const o = this.messagesWithoutClientAck.get(i) || {}
          s[i] = Object.values(o)
        }
        return s
      }),
      Ts(this, 'has', (r, s) => {
        this.isInitialized()
        const i = this.get(r),
          o = Ji(s)
        return typeof i[o] < 'u'
      }),
      Ts(this, 'ack', async (r, s) => {
        this.isInitialized()
        const i = this.messagesWithoutClientAck.get(r)
        if (typeof i > 'u') return
        const o = Ji(s)
        delete i[o],
          Object.keys(i).length === 0
            ? this.messagesWithoutClientAck.delete(r)
            : this.messagesWithoutClientAck.set(r, i),
          await this.persist()
      }),
      Ts(this, 'del', async r => {
        this.isInitialized(),
          this.messages.delete(r),
          this.messagesWithoutClientAck.delete(r),
          await this.persist()
      }),
      (this.logger = Jr(e, this.name)),
      (this.core = n)
  }
  get context() {
    return Is(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
  }
  get storageKeyWithoutClientAck() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      '//' +
      this.name +
      '_withoutClientAck'
    )
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, iv(e))
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, iv(e))
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey)
    return typeof e < 'u' ? ov(e) : void 0
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck)
    return typeof e < 'u' ? ov(e) : void 0
  }
  async persist() {
    await this.setRelayerMessages(this.messages),
      await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Le('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
}
var Mte = Object.defineProperty,
  Ute = Object.defineProperties,
  Lte = Object.getOwnPropertyDescriptors,
  _2 = Object.getOwnPropertySymbols,
  $te = Object.prototype.hasOwnProperty,
  Fte = Object.prototype.propertyIsEnumerable,
  Av = (t, e, n) =>
    e in t ? Mte(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  ug = (t, e) => {
    for (var n in e || (e = {})) $te.call(e, n) && Av(t, n, e[n])
    if (_2) for (var n of _2(e)) Fte.call(e, n) && Av(t, n, e[n])
    return t
  },
  tb = (t, e) => Ute(t, Lte(e)),
  mi = (t, e, n) => Av(t, typeof e != 'symbol' ? e + '' : e, n)
class jte extends Mz {
  constructor(e, n) {
    super(e, n),
      (this.relayer = e),
      (this.logger = n),
      mi(this, 'events', new ui.EventEmitter()),
      mi(this, 'name', TX),
      mi(this, 'queue', new Map()),
      mi(this, 'publishTimeout', Me.toMiliseconds(Me.ONE_MINUTE)),
      mi(this, 'initialPublishTimeout', Me.toMiliseconds(Me.ONE_SECOND * 15)),
      mi(this, 'needsTransportRestart', !1),
      mi(this, 'publish', async (r, s, i) => {
        var o
        this.logger.debug('Publishing Payload'),
          this.logger.trace({
            type: 'method',
            method: 'publish',
            params: { topic: r, message: s, opts: i }
          })
        const a = (i == null ? void 0 : i.ttl) || p2,
          c = _m(i),
          u = (i == null ? void 0 : i.prompt) || !1,
          l = (i == null ? void 0 : i.tag) || 0,
          d = (i == null ? void 0 : i.id) || $c().toString(),
          h = {
            topic: r,
            message: s,
            opts: {
              ttl: a,
              relay: c,
              prompt: u,
              tag: l,
              id: d,
              attestation: i == null ? void 0 : i.attestation,
              tvf: i == null ? void 0 : i.tvf
            }
          },
          p = `Failed to publish payload, please try again. id:${d} tag:${l}`
        try {
          const y = new Promise(async m => {
            const b = ({ id: x }) => {
              h.opts.id === x &&
                (this.removeRequestFromQueue(x),
                this.relayer.events.removeListener(hr.publish, b),
                m(h))
            }
            this.relayer.events.on(hr.publish, b)
            const I = Ma(
              new Promise((x, _) => {
                this.rpcPublish({
                  topic: r,
                  message: s,
                  ttl: a,
                  prompt: u,
                  tag: l,
                  id: d,
                  attestation: i == null ? void 0 : i.attestation,
                  tvf: i == null ? void 0 : i.tvf
                })
                  .then(x)
                  .catch(R => {
                    this.logger.warn(R, R == null ? void 0 : R.message), _(R)
                  })
              }),
              this.initialPublishTimeout,
              `Failed initial publish, retrying.... id:${d} tag:${l}`
            )
            try {
              await I, this.events.removeListener(hr.publish, b)
            } catch (x) {
              this.queue.set(d, tb(ug({}, h), { attempt: 1 })),
                this.logger.warn(x, x == null ? void 0 : x.message)
            }
          })
          this.logger.trace({
            type: 'method',
            method: 'publish',
            params: { id: d, topic: r, message: s, opts: i }
          }),
            await Ma(y, this.publishTimeout, p)
        } catch (y) {
          if (
            (this.logger.debug('Failed to Publish Payload'),
            this.logger.error(y),
            (o = i == null ? void 0 : i.internal) != null && o.throwOnFailedPublish)
          )
            throw y
        } finally {
          this.queue.delete(d)
        }
      }),
      mi(this, 'on', (r, s) => {
        this.events.on(r, s)
      }),
      mi(this, 'once', (r, s) => {
        this.events.once(r, s)
      }),
      mi(this, 'off', (r, s) => {
        this.events.off(r, s)
      }),
      mi(this, 'removeListener', (r, s) => {
        this.events.removeListener(r, s)
      }),
      (this.relayer = e),
      (this.logger = Jr(n, this.name)),
      this.registerEventListeners()
  }
  get context() {
    return Is(this.logger)
  }
  async rpcPublish(e) {
    var n, r, s, i
    const {
        topic: o,
        message: a,
        ttl: c = p2,
        prompt: u,
        tag: l,
        id: d,
        attestation: h,
        tvf: p
      } = e,
      y = {
        method: wh(_m().protocol).publish,
        params: ug({ topic: o, message: a, ttl: c, prompt: u, tag: l, attestation: h }, p),
        id: d
      }
    xr((n = y.params) == null ? void 0 : n.prompt) && ((r = y.params) == null || delete r.prompt),
      xr((s = y.params) == null ? void 0 : s.tag) && ((i = y.params) == null || delete i.tag),
      this.logger.debug('Outgoing Relay Payload'),
      this.logger.trace({ type: 'message', direction: 'outgoing', request: y })
    const m = await this.relayer.request(y)
    return (
      this.relayer.events.emit(hr.publish, e),
      this.logger.debug('Successfully Published Payload'),
      m
    )
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e)
  }
  checkQueue() {
    this.queue.forEach(async (e, n) => {
      const r = e.attempt + 1
      this.queue.set(n, tb(ug({}, e), { attempt: r }))
      const { topic: s, message: i, opts: o, attestation: a } = e
      this.logger.warn(
        {},
        `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${r}`
      ),
        await this.rpcPublish(
          tb(ug({}, e), {
            topic: s,
            message: i,
            ttl: o.ttl,
            prompt: o.prompt,
            tag: o.tag,
            id: o.id,
            attestation: a,
            tvf: o.tvf
          })
        ),
        this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`)
    })
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Sd.pulse, () => {
      if (this.needsTransportRestart) {
        ;(this.needsTransportRestart = !1), this.relayer.events.emit(hr.connection_stalled)
        return
      }
      this.checkQueue()
    }),
      this.relayer.on(hr.message_ack, e => {
        this.removeRequestFromQueue(e.id.toString())
      })
  }
}
var Hte = Object.defineProperty,
  qte = (t, e, n) =>
    e in t ? Hte(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  qu = (t, e, n) => qte(t, typeof e != 'symbol' ? e + '' : e, n)
class zte {
  constructor() {
    qu(this, 'map', new Map()),
      qu(this, 'set', (e, n) => {
        const r = this.get(e)
        this.exists(e, n) || this.map.set(e, [...r, n])
      }),
      qu(this, 'get', e => this.map.get(e) || []),
      qu(this, 'exists', (e, n) => this.get(e).includes(n)),
      qu(this, 'delete', (e, n) => {
        if (typeof n > 'u') {
          this.map.delete(e)
          return
        }
        if (!this.map.has(e)) return
        const r = this.get(e)
        if (!this.exists(e, n)) return
        const s = r.filter(i => i !== n)
        if (!s.length) {
          this.map.delete(e)
          return
        }
        this.map.set(e, s)
      }),
      qu(this, 'clear', () => {
        this.map.clear()
      })
  }
  get topics() {
    return Array.from(this.map.keys())
  }
}
var Wte = Object.defineProperty,
  Kte = Object.defineProperties,
  Vte = Object.getOwnPropertyDescriptors,
  C2 = Object.getOwnPropertySymbols,
  Gte = Object.prototype.hasOwnProperty,
  Qte = Object.prototype.propertyIsEnumerable,
  _v = (t, e, n) =>
    e in t ? Wte(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  th = (t, e) => {
    for (var n in e || (e = {})) Gte.call(e, n) && _v(t, n, e[n])
    if (C2) for (var n of C2(e)) Qte.call(e, n) && _v(t, n, e[n])
    return t
  },
  nb = (t, e) => Kte(t, Vte(e)),
  hn = (t, e, n) => _v(t, typeof e != 'symbol' ? e + '' : e, n)
class Zte extends $z {
  constructor(e, n) {
    super(e, n),
      (this.relayer = e),
      (this.logger = n),
      hn(this, 'subscriptions', new Map()),
      hn(this, 'topicMap', new zte()),
      hn(this, 'events', new ui.EventEmitter()),
      hn(this, 'name', DX),
      hn(this, 'version', MX),
      hn(this, 'pending', new Map()),
      hn(this, 'cached', []),
      hn(this, 'initialized', !1),
      hn(this, 'storagePrefix', co),
      hn(this, 'subscribeTimeout', Me.toMiliseconds(Me.ONE_MINUTE)),
      hn(this, 'initialSubscribeTimeout', Me.toMiliseconds(Me.ONE_SECOND * 15)),
      hn(this, 'clientId'),
      hn(this, 'batchSubscribeTopicsLimit', 500),
      hn(this, 'init', async () => {
        this.initialized ||
          (this.logger.trace('Initialized'), this.registerEventListeners(), await this.restore()),
          (this.initialized = !0)
      }),
      hn(this, 'subscribe', async (r, s) => {
        this.isInitialized(),
          this.logger.debug('Subscribing Topic'),
          this.logger.trace({ type: 'method', method: 'subscribe', params: { topic: r, opts: s } })
        try {
          const i = _m(s),
            o = { topic: r, relay: i, transportType: s == null ? void 0 : s.transportType }
          this.pending.set(r, o)
          const a = await this.rpcSubscribe(r, i, s)
          return (
            typeof a == 'string' &&
              (this.onSubscribe(a, o),
              this.logger.debug('Successfully Subscribed Topic'),
              this.logger.trace({
                type: 'method',
                method: 'subscribe',
                params: { topic: r, opts: s }
              })),
            a
          )
        } catch (i) {
          throw (this.logger.debug('Failed to Subscribe Topic'), this.logger.error(i), i)
        }
      }),
      hn(this, 'unsubscribe', async (r, s) => {
        this.isInitialized(),
          typeof (s == null ? void 0 : s.id) < 'u'
            ? await this.unsubscribeById(r, s.id, s)
            : await this.unsubscribeByTopic(r, s)
      }),
      hn(
        this,
        'isSubscribed',
        r =>
          new Promise(s => {
            s(this.topicMap.topics.includes(r))
          })
      ),
      hn(
        this,
        'isKnownTopic',
        r =>
          new Promise(s => {
            s(
              this.topicMap.topics.includes(r) ||
                this.pending.has(r) ||
                this.cached.some(i => i.topic === r)
            )
          })
      ),
      hn(this, 'on', (r, s) => {
        this.events.on(r, s)
      }),
      hn(this, 'once', (r, s) => {
        this.events.once(r, s)
      }),
      hn(this, 'off', (r, s) => {
        this.events.off(r, s)
      }),
      hn(this, 'removeListener', (r, s) => {
        this.events.removeListener(r, s)
      }),
      hn(this, 'start', async () => {
        await this.onConnect()
      }),
      hn(this, 'stop', async () => {
        await this.onDisconnect()
      }),
      hn(this, 'restart', async () => {
        await this.restore(), await this.onRestart()
      }),
      hn(this, 'checkPending', async () => {
        if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return
        const r = []
        this.pending.forEach(s => {
          r.push(s)
        }),
          await this.batchSubscribe(r)
      }),
      hn(this, 'registerEventListeners', () => {
        this.relayer.core.heartbeat.on(Sd.pulse, async () => {
          await this.checkPending()
        }),
          this.events.on(ks.created, async r => {
            const s = ks.created
            this.logger.info(`Emitting ${s}`),
              this.logger.debug({ type: 'event', event: s, data: r }),
              await this.persist()
          }),
          this.events.on(ks.deleted, async r => {
            const s = ks.deleted
            this.logger.info(`Emitting ${s}`),
              this.logger.debug({ type: 'event', event: s, data: r }),
              await this.persist()
          })
      }),
      (this.relayer = e),
      (this.logger = Jr(n, this.name)),
      (this.clientId = '')
  }
  get context() {
    return Is(this.logger)
  }
  get storageKey() {
    return (
      this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + '//' + this.name
    )
  }
  get length() {
    return this.subscriptions.size
  }
  get ids() {
    return Array.from(this.subscriptions.keys())
  }
  get values() {
    return Array.from(this.subscriptions.values())
  }
  get topics() {
    return this.topicMap.topics
  }
  get hasAnyTopics() {
    return (
      this.topicMap.topics.length > 0 ||
      this.pending.size > 0 ||
      this.cached.length > 0 ||
      this.subscriptions.size > 0
    )
  }
  hasSubscription(e, n) {
    let r = !1
    try {
      r = this.getSubscription(e).topic === n
    } catch {}
    return r
  }
  reset() {
    ;(this.cached = []), (this.initialized = !0)
  }
  onDisable() {
    ;(this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear()
  }
  async unsubscribeByTopic(e, n) {
    const r = this.topicMap.get(e)
    await Promise.all(r.map(async s => await this.unsubscribeById(e, s, n)))
  }
  async unsubscribeById(e, n, r) {
    this.logger.debug('Unsubscribing Topic'),
      this.logger.trace({
        type: 'method',
        method: 'unsubscribe',
        params: { topic: e, id: n, opts: r }
      })
    try {
      const s = _m(r)
      await this.restartToComplete({ topic: e, id: n, relay: s }),
        await this.rpcUnsubscribe(e, n, s)
      const i = an('USER_DISCONNECTED', `${this.name}, ${e}`)
      await this.onUnsubscribe(e, n, i),
        this.logger.debug('Successfully Unsubscribed Topic'),
        this.logger.trace({
          type: 'method',
          method: 'unsubscribe',
          params: { topic: e, id: n, opts: r }
        })
    } catch (s) {
      throw (this.logger.debug('Failed to Unsubscribe Topic'), this.logger.error(s), s)
    }
  }
  async rpcSubscribe(e, n, r) {
    var s
    ;(!r || (r == null ? void 0 : r.transportType) === Sn.relay) &&
      (await this.restartToComplete({ topic: e, id: e, relay: n }))
    const i = { method: wh(n.protocol).subscribe, params: { topic: e } }
    this.logger.debug('Outgoing Relay Payload'),
      this.logger.trace({ type: 'payload', direction: 'outgoing', request: i })
    const o = (s = r == null ? void 0 : r.internal) == null ? void 0 : s.throwOnFailedPublish
    try {
      const a = await this.getSubscriptionId(e)
      if ((r == null ? void 0 : r.transportType) === Sn.link_mode)
        return (
          setTimeout(() => {
            ;(this.relayer.connected || this.relayer.connecting) &&
              this.relayer.request(i).catch(l => this.logger.warn(l))
          }, Me.toMiliseconds(Me.ONE_SECOND)),
          a
        )
      const c = new Promise(async l => {
          const d = h => {
            h.topic === e && (this.events.removeListener(ks.created, d), l(h.id))
          }
          this.events.on(ks.created, d)
          try {
            const h = await Ma(
              new Promise((p, y) => {
                this.relayer
                  .request(i)
                  .catch(m => {
                    this.logger.warn(m, m == null ? void 0 : m.message), y(m)
                  })
                  .then(p)
              }),
              this.initialSubscribeTimeout,
              `Subscribing to ${e} failed, please try again`
            )
            this.events.removeListener(ks.created, d), l(h)
          } catch {}
        }),
        u = await Ma(c, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`)
      if (!u && o) throw new Error(`Subscribing to ${e} failed, please try again`)
      return u ? a : null
    } catch (a) {
      if (
        (this.logger.debug('Outgoing Relay Subscribe Payload stalled'),
        this.relayer.events.emit(hr.connection_stalled),
        o)
      )
        throw a
    }
    return null
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return
    const n = e[0].relay,
      r = { method: wh(n.protocol).batchSubscribe, params: { topics: e.map(s => s.topic) } }
    this.logger.debug('Outgoing Relay Payload'),
      this.logger.trace({ type: 'payload', direction: 'outgoing', request: r })
    try {
      await await Ma(
        new Promise(s => {
          this.relayer
            .request(r)
            .catch(i => this.logger.warn(i))
            .then(s)
        }),
        this.subscribeTimeout,
        'rpcBatchSubscribe failed, please try again'
      )
    } catch {
      this.relayer.events.emit(hr.connection_stalled)
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return
    const n = e[0].relay,
      r = { method: wh(n.protocol).batchFetchMessages, params: { topics: e.map(i => i.topic) } }
    this.logger.debug('Outgoing Relay Payload'),
      this.logger.trace({ type: 'payload', direction: 'outgoing', request: r })
    let s
    try {
      s = await await Ma(
        new Promise((i, o) => {
          this.relayer
            .request(r)
            .catch(a => {
              this.logger.warn(a), o(a)
            })
            .then(i)
        }),
        this.subscribeTimeout,
        'rpcBatchFetchMessages failed, please try again'
      )
    } catch {
      this.relayer.events.emit(hr.connection_stalled)
    }
    return s
  }
  rpcUnsubscribe(e, n, r) {
    const s = { method: wh(r.protocol).unsubscribe, params: { topic: e, id: n } }
    return (
      this.logger.debug('Outgoing Relay Payload'),
      this.logger.trace({ type: 'payload', direction: 'outgoing', request: s }),
      this.relayer.request(s)
    )
  }
  onSubscribe(e, n) {
    this.setSubscription(e, nb(th({}, n), { id: e })), this.pending.delete(n.topic)
  }
  onBatchSubscribe(e) {
    e.length &&
      e.forEach(n => {
        this.setSubscription(n.id, th({}, n)), this.pending.delete(n.topic)
      })
  }
  async onUnsubscribe(e, n, r) {
    this.events.removeAllListeners(n),
      this.hasSubscription(n, e) && this.deleteSubscription(n, r),
      await this.relayer.messages.del(e)
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e)
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey)
  }
  setSubscription(e, n) {
    this.logger.debug('Setting subscription'),
      this.logger.trace({ type: 'method', method: 'setSubscription', id: e, subscription: n }),
      this.addSubscription(e, n)
  }
  addSubscription(e, n) {
    this.subscriptions.set(e, th({}, n)),
      this.topicMap.set(n.topic, e),
      this.events.emit(ks.created, n)
  }
  getSubscription(e) {
    this.logger.debug('Getting subscription'),
      this.logger.trace({ type: 'method', method: 'getSubscription', id: e })
    const n = this.subscriptions.get(e)
    if (!n) {
      const { message: r } = Le('NO_MATCHING_KEY', `${this.name}: ${e}`)
      throw new Error(r)
    }
    return n
  }
  deleteSubscription(e, n) {
    this.logger.debug('Deleting subscription'),
      this.logger.trace({ type: 'method', method: 'deleteSubscription', id: e, reason: n })
    const r = this.getSubscription(e)
    this.subscriptions.delete(e),
      this.topicMap.delete(r.topic, e),
      this.events.emit(ks.deleted, nb(th({}, r), { reason: n }))
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(ks.sync)
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached],
        n = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit)
      for (let r = 0; r < n; r++) {
        const s = e.splice(0, this.batchSubscribeTopicsLimit)
        await this.batchSubscribe(s)
      }
    }
    this.events.emit(ks.resubscribed)
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions()
      if (typeof e > 'u' || !e.length) return
      if (this.subscriptions.size) {
        const { message: n } = Le('RESTORE_WILL_OVERRIDE', this.name)
        throw (
          (this.logger.error(n),
          this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),
          new Error(n))
        )
      }
      ;(this.cached = e),
        this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),
        this.logger.trace({ type: 'method', method: 'restore', subscriptions: this.values })
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e)
    }
  }
  async batchSubscribe(e) {
    e.length &&
      (await this.rpcBatchSubscribe(e),
      this.onBatchSubscribe(
        await Promise.all(
          e.map(async n => nb(th({}, n), { id: await this.getSubscriptionId(n.topic) }))
        )
      ))
  }
  async batchFetchMessages(e) {
    if (!e.length) return
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`)
    const n = await this.rpcBatchFetchMessages(e)
    n &&
      n.messages &&
      (await qQ(Me.toMiliseconds(Me.ONE_SECOND)),
      await this.relayer.handleBatchMessageEvents(n.messages))
  }
  async onConnect() {
    await this.restart(), this.reset()
  }
  onDisconnect() {
    this.onDisable()
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Le('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected &&
      !this.relayer.connecting &&
      (this.cached.push(e), await this.relayer.transportOpen())
  }
  async getClientId() {
    return (
      this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId
    )
  }
  async getSubscriptionId(e) {
    return Ji(e + (await this.getClientId()))
  }
}
var Yte = Object.defineProperty,
  S2 = Object.getOwnPropertySymbols,
  Jte = Object.prototype.hasOwnProperty,
  Xte = Object.prototype.propertyIsEnumerable,
  Cv = (t, e, n) =>
    e in t ? Yte(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  I2 = (t, e) => {
    for (var n in e || (e = {})) Jte.call(e, n) && Cv(t, n, e[n])
    if (S2) for (var n of S2(e)) Xte.call(e, n) && Cv(t, n, e[n])
    return t
  },
  Kt = (t, e, n) => Cv(t, typeof e != 'symbol' ? e + '' : e, n)
class ene extends Uz {
  constructor(e) {
    super(e),
      Kt(this, 'protocol', 'wc'),
      Kt(this, 'version', 2),
      Kt(this, 'core'),
      Kt(this, 'logger'),
      Kt(this, 'events', new ui.EventEmitter()),
      Kt(this, 'provider'),
      Kt(this, 'messages'),
      Kt(this, 'subscriber'),
      Kt(this, 'publisher'),
      Kt(this, 'name', PX),
      Kt(this, 'transportExplicitlyClosed', !1),
      Kt(this, 'initialized', !1),
      Kt(this, 'connectionAttemptInProgress', !1),
      Kt(this, 'relayUrl'),
      Kt(this, 'projectId'),
      Kt(this, 'packageName'),
      Kt(this, 'bundleId'),
      Kt(this, 'hasExperiencedNetworkDisruption', !1),
      Kt(this, 'pingTimeout'),
      Kt(this, 'heartBeatTimeout', Me.toMiliseconds(Me.THIRTY_SECONDS + Me.FIVE_SECONDS)),
      Kt(this, 'reconnectTimeout'),
      Kt(this, 'connectPromise'),
      Kt(this, 'reconnectInProgress', !1),
      Kt(this, 'requestsInFlight', []),
      Kt(this, 'connectTimeout', Me.toMiliseconds(Me.ONE_SECOND * 15)),
      Kt(this, 'request', async n => {
        var r, s
        this.logger.debug('Publishing Request Payload')
        const i = n.id || $c().toString()
        await this.toEstablishConnection()
        try {
          this.logger.trace(
            { id: i, method: n.method, topic: (r = n.params) == null ? void 0 : r.topic },
            'relayer.request - publishing...'
          )
          const o = `${i}:${((s = n.params) == null ? void 0 : s.tag) || ''}`
          this.requestsInFlight.push(o)
          const a = await this.provider.request(n)
          return (this.requestsInFlight = this.requestsInFlight.filter(c => c !== o)), a
        } catch (o) {
          throw (this.logger.debug(`Failed to Publish Request: ${i}`), o)
        }
      }),
      Kt(this, 'resetPingTimeout', () => {
        Em() &&
          (clearTimeout(this.pingTimeout),
          (this.pingTimeout = setTimeout(() => {
            var n, r, s, i
            try {
              this.logger.debug({}, 'pingTimeout: Connection stalled, terminating...'),
                (i =
                  (s =
                    (r = (n = this.provider) == null ? void 0 : n.connection) == null
                      ? void 0
                      : r.socket) == null
                    ? void 0
                    : s.terminate) == null || i.call(s)
            } catch (o) {
              this.logger.warn(o, o == null ? void 0 : o.message)
            }
          }, this.heartBeatTimeout)))
      }),
      Kt(this, 'onPayloadHandler', n => {
        this.onProviderPayload(n), this.resetPingTimeout()
      }),
      Kt(this, 'onConnectHandler', () => {
        this.logger.warn({}, 'Relayer connected '),
          this.startPingTimeout(),
          this.events.emit(hr.connect)
      }),
      Kt(this, 'onDisconnectHandler', () => {
        this.logger.warn({}, 'Relayer disconnected '),
          (this.requestsInFlight = []),
          this.onProviderDisconnect()
      }),
      Kt(this, 'onProviderErrorHandler', n => {
        this.logger.fatal(`Fatal socket error: ${n.message}`),
          this.events.emit(hr.error, n),
          this.logger.fatal('Fatal socket error received, closing transport'),
          this.transportClose()
      }),
      Kt(this, 'registerProviderListeners', () => {
        this.provider.on(Gs.payload, this.onPayloadHandler),
          this.provider.on(Gs.connect, this.onConnectHandler),
          this.provider.on(Gs.disconnect, this.onDisconnectHandler),
          this.provider.on(Gs.error, this.onProviderErrorHandler)
      }),
      (this.core = e.core),
      (this.logger =
        typeof e.logger < 'u' && typeof e.logger != 'string'
          ? Jr(e.logger, this.name)
          : dp(Id({ level: e.logger || NX }))),
      (this.messages = new Dte(this.logger, e.core)),
      (this.subscriber = new Zte(this, this.logger)),
      (this.publisher = new jte(this, this.logger)),
      (this.relayUrl = (e == null ? void 0 : e.relayUrl) || WO),
      (this.projectId = e.projectId),
      xQ() ? (this.packageName = bI()) : TQ() && (this.bundleId = bI()),
      (this.provider = {})
  }
  async init() {
    if (
      (this.logger.trace('Initialized'),
      this.registerEventListeners(),
      await Promise.all([this.messages.init(), this.subscriber.init()]),
      (this.initialized = !0),
      this.subscriber.hasAnyTopics)
    )
      try {
        await this.transportOpen()
      } catch (e) {
        this.logger.warn(e, e == null ? void 0 : e.message)
      }
  }
  get context() {
    return Is(this.logger)
  }
  get connected() {
    var e, n, r
    return (
      ((r =
        (n = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : n.socket) ==
      null
        ? void 0
        : r.readyState) === 1 || !1
    )
  }
  get connecting() {
    var e, n, r
    return (
      ((r =
        (n = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : n.socket) ==
      null
        ? void 0
        : r.readyState) === 0 ||
      this.connectPromise !== void 0 ||
      !1
    )
  }
  async publish(e, n, r) {
    this.isInitialized(),
      await this.publisher.publish(e, n, r),
      await this.recordMessageEvent(
        { topic: e, message: n, publishedAt: Date.now(), transportType: Sn.relay },
        Ug.outbound
      )
  }
  async subscribe(e, n) {
    var r, s, i
    this.isInitialized(),
      (!(n != null && n.transportType) || (n == null ? void 0 : n.transportType) === 'relay') &&
        (await this.toEstablishConnection())
    const o =
      typeof ((r = n == null ? void 0 : n.internal) == null ? void 0 : r.throwOnFailedPublish) > 'u'
        ? !0
        : (s = n == null ? void 0 : n.internal) == null
          ? void 0
          : s.throwOnFailedPublish
    let a = ((i = this.subscriber.topicMap.get(e)) == null ? void 0 : i[0]) || '',
      c
    const u = l => {
      l.topic === e && (this.subscriber.off(ks.created, u), c())
    }
    return (
      await Promise.all([
        new Promise(l => {
          ;(c = l), this.subscriber.on(ks.created, u)
        }),
        new Promise(async (l, d) => {
          ;(a =
            (await this.subscriber
              .subscribe(e, I2({ internal: { throwOnFailedPublish: o } }, n))
              .catch(h => {
                o && d(h)
              })) || a),
            l()
        })
      ]),
      a
    )
  }
  async unsubscribe(e, n) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, n)
  }
  on(e, n) {
    this.events.on(e, n)
  }
  once(e, n) {
    this.events.once(e, n)
  }
  off(e, n) {
    this.events.off(e, n)
  }
  removeListener(e, n) {
    this.events.removeListener(e, n)
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected)
      ? await Ma(this.provider.disconnect(), 2e3, 'provider.disconnect()').catch(() =>
          this.onProviderDisconnect()
        )
      : this.onProviderDisconnect()
  }
  async transportClose() {
    ;(this.transportExplicitlyClosed = !0), await this.transportDisconnect()
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn(
        'Starting WS connection skipped because the client has no topics to work with.'
      )
      return
    }
    if (
      (this.connectPromise
        ? (this.logger.debug({}, 'Waiting for existing connection attempt to resolve...'),
          await this.connectPromise,
          this.logger.debug({}, 'Existing connection attempt resolved'))
        : ((this.connectPromise = new Promise(async (n, r) => {
            await this.connect(e)
              .then(n)
              .catch(r)
              .finally(() => {
                this.connectPromise = void 0
              })
          })),
          await this.connectPromise),
      !this.connected)
    )
      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`)
  }
  async restartTransport(e) {
    this.logger.debug({}, 'Restarting transport...'),
      !this.connectionAttemptInProgress &&
        ((this.relayUrl = e || this.relayUrl),
        await this.confirmOnlineStateOrThrow(),
        await this.transportClose(),
        await this.transportOpen())
  }
  async confirmOnlineStateOrThrow() {
    if (!(await s2()))
      throw new Error('No internet connection detected. Please restart your network and try again.')
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace('Batch message events is empty. Ignoring...')
      return
    }
    const n = e.sort((r, s) => r.publishedAt - s.publishedAt)
    this.logger.debug(`Batch of ${n.length} message events sorted`)
    for (const r of n)
      try {
        await this.onMessageEvent(r)
      } catch (s) {
        this.logger.warn(
          s,
          'Error while processing batch message event: ' + (s == null ? void 0 : s.message)
        )
      }
    this.logger.trace(`Batch of ${n.length} message events processed`)
  }
  async onLinkMessageEvent(e, n) {
    const { topic: r } = e
    if (!n.sessionExists) {
      const s = tr(Me.FIVE_MINUTES),
        i = { topic: r, expiry: s, relay: { protocol: 'irn' }, active: !1 }
      await this.core.pairing.pairings.set(r, i)
    }
    this.events.emit(hr.message, e), await this.recordMessageEvent(e, Ug.inbound)
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(),
      e && e !== this.relayUrl && ((this.relayUrl = e), await this.transportDisconnect()),
      (this.connectionAttemptInProgress = !0),
      (this.transportExplicitlyClosed = !1)
    let n = 1
    for (; n < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${n}...`),
          await this.createProvider(),
          await new Promise(async (r, s) => {
            const i = () => {
              s(new Error('Connection interrupted while trying to subscribe'))
            }
            this.provider.once(Gs.disconnect, i),
              await Ma(
                new Promise((o, a) => {
                  this.provider.connect().then(o).catch(a)
                }),
                this.connectTimeout,
                `Socket stalled when trying to connect to ${this.relayUrl}`
              )
                .catch(o => {
                  s(o)
                })
                .finally(() => {
                  this.provider.off(Gs.disconnect, i), clearTimeout(this.reconnectTimeout)
                }),
              await new Promise(async (o, a) => {
                const c = () => {
                  a(new Error('Connection interrupted while trying to subscribe'))
                }
                this.provider.once(Gs.disconnect, c),
                  await this.subscriber
                    .start()
                    .then(o)
                    .catch(a)
                    .finally(() => {
                      this.provider.off(Gs.disconnect, c)
                    })
              }),
              (this.hasExperiencedNetworkDisruption = !1),
              r()
          })
      } catch (r) {
        await this.subscriber.stop()
        const s = r
        this.logger.warn({}, s.message), (this.hasExperiencedNetworkDisruption = !0)
      } finally {
        this.connectionAttemptInProgress = !1
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${n}`)
        break
      }
      await new Promise(r => setTimeout(r, Me.toMiliseconds(n * 1))), n++
    }
  }
  startPingTimeout() {
    var e, n, r, s, i
    if (Em())
      try {
        ;(n = (e = this.provider) == null ? void 0 : e.connection) != null &&
          n.socket &&
          ((i =
            (s = (r = this.provider) == null ? void 0 : r.connection) == null
              ? void 0
              : s.socket) == null ||
            i.on('ping', () => {
              this.resetPingTimeout()
            })),
          this.resetPingTimeout()
      } catch (o) {
        this.logger.warn(o, o == null ? void 0 : o.message)
      }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners()
    const e = await this.core.crypto.signJWT(this.relayUrl)
    ;(this.provider = new li(
      new wX(
        OQ({
          sdkVersion: wv,
          protocol: this.protocol,
          version: this.version,
          relayUrl: this.relayUrl,
          projectId: this.projectId,
          auth: e,
          useOnCloseEvent: !0,
          bundleId: this.bundleId,
          packageName: this.packageName
        })
      )
    )),
      this.registerProviderListeners()
  }
  async recordMessageEvent(e, n) {
    const { topic: r, message: s } = e
    await this.messages.set(r, s, n)
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: n, message: r } = e
    if (!r || r.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${r}`), !0
    if (!(await this.subscriber.isKnownTopic(n)))
      return this.logger.warn(`Ignoring message for unknown topic ${n}`), !0
    const s = this.messages.has(n, r)
    return s && this.logger.warn(`Ignoring duplicate message: ${r}`), s
  }
  async onProviderPayload(e) {
    if (
      (this.logger.debug('Incoming Relay Payload'),
      this.logger.trace({ type: 'payload', direction: 'incoming', payload: e }),
      MA(e))
    ) {
      if (!e.method.endsWith(RX)) return
      const n = e.params,
        { topic: r, message: s, publishedAt: i, attestation: o } = n.data,
        a = { topic: r, message: s, publishedAt: i, transportType: Sn.relay, attestation: o }
      this.logger.debug('Emitting Relayer Payload'),
        this.logger.trace(I2({ type: 'event', event: n.id }, a)),
        this.events.emit(n.id, a),
        await this.acknowledgePayload(e),
        await this.onMessageEvent(a)
    } else z0(e) && this.events.emit(hr.message_ack, e)
  }
  async onMessageEvent(e) {
    ;(await this.shouldIgnoreMessageEvent(e)) ||
      (await this.recordMessageEvent(e, Ug.inbound), this.events.emit(hr.message, e))
  }
  async acknowledgePayload(e) {
    const n = H0(e.id, !0)
    await this.provider.connection.send(n)
  }
  unregisterProviderListeners() {
    this.provider.off(Gs.payload, this.onPayloadHandler),
      this.provider.off(Gs.connect, this.onConnectHandler),
      this.provider.off(Gs.disconnect, this.onDisconnectHandler),
      this.provider.off(Gs.error, this.onProviderErrorHandler),
      clearTimeout(this.pingTimeout)
  }
  async registerEventListeners() {
    let e = await s2()
    VJ(async n => {
      e !== n &&
        ((e = n),
        n
          ? await this.transportOpen().catch(r =>
              this.logger.error(r, r == null ? void 0 : r.message)
            )
          : ((this.hasExperiencedNetworkDisruption = !0),
            await this.transportDisconnect(),
            (this.transportExplicitlyClosed = !1)))
    })
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout),
      this.events.emit(hr.disconnect),
      (this.connectionAttemptInProgress = !1),
      !this.reconnectInProgress &&
        ((this.reconnectInProgress = !0),
        await this.subscriber.stop(),
        this.subscriber.hasAnyTopics &&
          (this.transportExplicitlyClosed ||
            (this.reconnectTimeout = setTimeout(async () => {
              await this.transportOpen().catch(e =>
                this.logger.error(e, e == null ? void 0 : e.message)
              ),
                (this.reconnectTimeout = void 0),
                (this.reconnectInProgress = !1)
            }, Me.toMiliseconds(kX)))))
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Le('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (await this.connect())
  }
}
function tne() {}
function x2(t) {
  if (!t || typeof t != 'object') return !1
  const e = Object.getPrototypeOf(t)
  return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null
    ? Object.prototype.toString.call(t) === '[object Object]'
    : !1
}
function T2(t) {
  return Object.getOwnPropertySymbols(t).filter(e =>
    Object.prototype.propertyIsEnumerable.call(t, e)
  )
}
function N2(t) {
  return t == null
    ? t === void 0
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(t)
}
const nne = '[object RegExp]',
  rne = '[object String]',
  sne = '[object Number]',
  ine = '[object Boolean]',
  P2 = '[object Arguments]',
  one = '[object Symbol]',
  ane = '[object Date]',
  cne = '[object Map]',
  une = '[object Set]',
  lne = '[object Array]',
  dne = '[object Function]',
  hne = '[object ArrayBuffer]',
  rb = '[object Object]',
  fne = '[object Error]',
  pne = '[object DataView]',
  gne = '[object Uint8Array]',
  mne = '[object Uint8ClampedArray]',
  yne = '[object Uint16Array]',
  wne = '[object Uint32Array]',
  bne = '[object BigUint64Array]',
  vne = '[object Int8Array]',
  Ene = '[object Int16Array]',
  Ane = '[object Int32Array]',
  _ne = '[object BigInt64Array]',
  Cne = '[object Float32Array]',
  Sne = '[object Float64Array]'
function Ine(t, e) {
  return t === e || (Number.isNaN(t) && Number.isNaN(e))
}
function xne(t, e, n) {
  return vh(t, e, void 0, void 0, void 0, void 0, n)
}
function vh(t, e, n, r, s, i, o) {
  const a = o(t, e, n, r, s, i)
  if (a !== void 0) return a
  if (typeof t == typeof e)
    switch (typeof t) {
      case 'bigint':
      case 'string':
      case 'boolean':
      case 'symbol':
      case 'undefined':
        return t === e
      case 'number':
        return t === e || Object.is(t, e)
      case 'function':
        return t === e
      case 'object':
        return Dh(t, e, i, o)
    }
  return Dh(t, e, i, o)
}
function Dh(t, e, n, r) {
  if (Object.is(t, e)) return !0
  let s = N2(t),
    i = N2(e)
  if ((s === P2 && (s = rb), i === P2 && (i = rb), s !== i)) return !1
  switch (s) {
    case rne:
      return t.toString() === e.toString()
    case sne: {
      const c = t.valueOf(),
        u = e.valueOf()
      return Ine(c, u)
    }
    case ine:
    case ane:
    case one:
      return Object.is(t.valueOf(), e.valueOf())
    case nne:
      return t.source === e.source && t.flags === e.flags
    case dne:
      return t === e
  }
  n = n ?? new Map()
  const o = n.get(t),
    a = n.get(e)
  if (o != null && a != null) return o === e
  n.set(t, e), n.set(e, t)
  try {
    switch (s) {
      case cne: {
        if (t.size !== e.size) return !1
        for (const [c, u] of t.entries())
          if (!e.has(c) || !vh(u, e.get(c), c, t, e, n, r)) return !1
        return !0
      }
      case une: {
        if (t.size !== e.size) return !1
        const c = Array.from(t.values()),
          u = Array.from(e.values())
        for (let l = 0; l < c.length; l++) {
          const d = c[l],
            h = u.findIndex(p => vh(d, p, void 0, t, e, n, r))
          if (h === -1) return !1
          u.splice(h, 1)
        }
        return !0
      }
      case lne:
      case gne:
      case mne:
      case yne:
      case wne:
      case bne:
      case vne:
      case Ene:
      case Ane:
      case _ne:
      case Cne:
      case Sne: {
        if (
          (typeof Buffer < 'u' && Buffer.isBuffer(t) !== Buffer.isBuffer(e)) ||
          t.length !== e.length
        )
          return !1
        for (let c = 0; c < t.length; c++) if (!vh(t[c], e[c], c, t, e, n, r)) return !1
        return !0
      }
      case hne:
        return t.byteLength !== e.byteLength ? !1 : Dh(new Uint8Array(t), new Uint8Array(e), n, r)
      case pne:
        return t.byteLength !== e.byteLength || t.byteOffset !== e.byteOffset
          ? !1
          : Dh(new Uint8Array(t), new Uint8Array(e), n, r)
      case fne:
        return t.name === e.name && t.message === e.message
      case rb: {
        if (!(Dh(t.constructor, e.constructor, n, r) || (x2(t) && x2(e)))) return !1
        const c = [...Object.keys(t), ...T2(t)],
          u = [...Object.keys(e), ...T2(e)]
        if (c.length !== u.length) return !1
        for (let l = 0; l < c.length; l++) {
          const d = c[l],
            h = t[d]
          if (!Object.hasOwn(e, d)) return !1
          const p = e[d]
          if (!vh(h, p, d, t, e, n, r)) return !1
        }
        return !0
      }
      default:
        return !1
    }
  } finally {
    n.delete(t), n.delete(e)
  }
}
function Tne(t, e) {
  return xne(t, e, tne)
}
var Nne = Object.defineProperty,
  R2 = Object.getOwnPropertySymbols,
  Pne = Object.prototype.hasOwnProperty,
  Rne = Object.prototype.propertyIsEnumerable,
  Sv = (t, e, n) =>
    e in t ? Nne(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  k2 = (t, e) => {
    for (var n in e || (e = {})) Pne.call(e, n) && Sv(t, n, e[n])
    if (R2) for (var n of R2(e)) Rne.call(e, n) && Sv(t, n, e[n])
    return t
  },
  fs = (t, e, n) => Sv(t, typeof e != 'symbol' ? e + '' : e, n)
class Nu extends Lz {
  constructor(e, n, r, s = co, i = void 0) {
    super(e, n, r, s),
      (this.core = e),
      (this.logger = n),
      (this.name = r),
      fs(this, 'map', new Map()),
      fs(this, 'version', OX),
      fs(this, 'cached', []),
      fs(this, 'initialized', !1),
      fs(this, 'getKey'),
      fs(this, 'storagePrefix', co),
      fs(this, 'recentlyDeleted', []),
      fs(this, 'recentlyDeletedLimit', 200),
      fs(this, 'init', async () => {
        this.initialized ||
          (this.logger.trace('Initialized'),
          await this.restore(),
          this.cached.forEach(o => {
            this.getKey && o !== null && !xr(o)
              ? this.map.set(this.getKey(o), o)
              : CJ(o)
                ? this.map.set(o.id, o)
                : SJ(o) && this.map.set(o.topic, o)
          }),
          (this.cached = []),
          (this.initialized = !0))
      }),
      fs(this, 'set', async (o, a) => {
        this.isInitialized(),
          this.map.has(o)
            ? await this.update(o, a)
            : (this.logger.debug('Setting value'),
              this.logger.trace({ type: 'method', method: 'set', key: o, value: a }),
              this.map.set(o, a),
              await this.persist())
      }),
      fs(
        this,
        'get',
        o => (
          this.isInitialized(),
          this.logger.debug('Getting value'),
          this.logger.trace({ type: 'method', method: 'get', key: o }),
          this.getData(o)
        )
      ),
      fs(
        this,
        'getAll',
        o => (
          this.isInitialized(),
          o ? this.values.filter(a => Object.keys(o).every(c => Tne(a[c], o[c]))) : this.values
        )
      ),
      fs(this, 'update', async (o, a) => {
        this.isInitialized(),
          this.logger.debug('Updating value'),
          this.logger.trace({ type: 'method', method: 'update', key: o, update: a })
        const c = k2(k2({}, this.getData(o)), a)
        this.map.set(o, c), await this.persist()
      }),
      fs(this, 'delete', async (o, a) => {
        this.isInitialized(),
          this.map.has(o) &&
            (this.logger.debug('Deleting value'),
            this.logger.trace({ type: 'method', method: 'delete', key: o, reason: a }),
            this.map.delete(o),
            this.addToRecentlyDeleted(o),
            await this.persist())
      }),
      (this.logger = Jr(n, this.name)),
      (this.storagePrefix = s),
      (this.getKey = i)
  }
  get context() {
    return Is(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
  }
  get length() {
    return this.map.size
  }
  get keys() {
    return Array.from(this.map.keys())
  }
  get values() {
    return Array.from(this.map.values())
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e),
      this.recentlyDeleted.length >= this.recentlyDeletedLimit &&
        this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2)
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e)
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey)
  }
  getData(e) {
    const n = this.map.get(e)
    if (!n) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: s } = Le(
          'MISSING_OR_INVALID',
          `Record was recently deleted - ${this.name}: ${e}`
        )
        throw (this.logger.error(s), new Error(s))
      }
      const { message: r } = Le('NO_MATCHING_KEY', `${this.name}: ${e}`)
      throw (this.logger.error(r), new Error(r))
    }
    return n
  }
  async persist() {
    await this.setDataStore(this.values)
  }
  async restore() {
    try {
      const e = await this.getDataStore()
      if (typeof e > 'u' || !e.length) return
      if (this.map.size) {
        const { message: n } = Le('RESTORE_WILL_OVERRIDE', this.name)
        throw (this.logger.error(n), new Error(n))
      }
      ;(this.cached = e),
        this.logger.debug(`Successfully Restored value for ${this.name}`),
        this.logger.trace({ type: 'method', method: 'restore', value: this.values })
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e)
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Le('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
}
var kne = Object.defineProperty,
  One = (t, e, n) =>
    e in t ? kne(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  $t = (t, e, n) => One(t, typeof e != 'symbol' ? e + '' : e, n)
class Bne {
  constructor(e, n) {
    ;(this.core = e),
      (this.logger = n),
      $t(this, 'name', UX),
      $t(this, 'version', LX),
      $t(this, 'events', new mA()),
      $t(this, 'pairings'),
      $t(this, 'initialized', !1),
      $t(this, 'storagePrefix', co),
      $t(this, 'ignoredPayloadTypes', [Go]),
      $t(this, 'registeredMethods', []),
      $t(this, 'init', async () => {
        this.initialized ||
          (await this.pairings.init(),
          await this.cleanup(),
          this.registerRelayerEvents(),
          this.registerExpirerEvents(),
          (this.initialized = !0),
          this.logger.trace('Initialized'))
      }),
      $t(this, 'register', ({ methods: r }) => {
        this.isInitialized(),
          (this.registeredMethods = [...new Set([...this.registeredMethods, ...r])])
      }),
      $t(this, 'create', async r => {
        this.isInitialized()
        const s = mv(),
          i = await this.core.crypto.setSymKey(s),
          o = tr(Me.FIVE_MINUTES),
          a = { protocol: zO },
          c = {
            topic: i,
            expiry: o,
            relay: a,
            active: !1,
            methods: r == null ? void 0 : r.methods
          },
          u = JI({
            protocol: this.core.protocol,
            version: this.core.version,
            topic: i,
            symKey: s,
            relay: a,
            expiryTimestamp: o,
            methods: r == null ? void 0 : r.methods
          })
        return (
          this.events.emit(kc.create, c),
          this.core.expirer.set(i, o),
          await this.pairings.set(i, c),
          await this.core.relayer.subscribe(i, {
            transportType: r == null ? void 0 : r.transportType
          }),
          { topic: i, uri: u }
        )
      }),
      $t(this, 'pair', async r => {
        this.isInitialized()
        const s = this.core.eventClient.createEvent({
          properties: { topic: r == null ? void 0 : r.uri, trace: [qi.pairing_started] }
        })
        this.isValidPair(r, s)
        const { topic: i, symKey: o, relay: a, expiryTimestamp: c, methods: u } = YI(r.uri)
        ;(s.props.properties.topic = i),
          s.addTrace(qi.pairing_uri_validation_success),
          s.addTrace(qi.pairing_uri_not_expired)
        let l
        if (this.pairings.keys.includes(i)) {
          if (((l = this.pairings.get(i)), s.addTrace(qi.existing_pairing), l.active))
            throw (
              (s.setError(Do.active_pairing_already_exists),
              new Error(
                `Pairing already exists: ${i}. Please try again with a new connection URI.`
              ))
            )
          s.addTrace(qi.pairing_not_expired)
        }
        const d = c || tr(Me.FIVE_MINUTES),
          h = { topic: i, relay: a, expiry: d, active: !1, methods: u }
        this.core.expirer.set(i, d),
          await this.pairings.set(i, h),
          s.addTrace(qi.store_new_pairing),
          r.activatePairing && (await this.activate({ topic: i })),
          this.events.emit(kc.create, h),
          s.addTrace(qi.emit_inactive_pairing),
          this.core.crypto.keychain.has(i) || (await this.core.crypto.setSymKey(o, i)),
          s.addTrace(qi.subscribing_pairing_topic)
        try {
          await this.core.relayer.confirmOnlineStateOrThrow()
        } catch {
          s.setError(Do.no_internet_connection)
        }
        try {
          await this.core.relayer.subscribe(i, { relay: a })
        } catch (p) {
          throw (s.setError(Do.subscribe_pairing_topic_failure), p)
        }
        return s.addTrace(qi.subscribe_pairing_topic_success), h
      }),
      $t(this, 'activate', async ({ topic: r }) => {
        this.isInitialized()
        const s = tr(Me.FIVE_MINUTES)
        this.core.expirer.set(r, s), await this.pairings.update(r, { active: !0, expiry: s })
      }),
      $t(this, 'ping', async r => {
        this.isInitialized(),
          await this.isValidPing(r),
          this.logger.warn('ping() is deprecated and will be removed in the next major release.')
        const { topic: s } = r
        if (this.pairings.keys.includes(s)) {
          const i = await this.sendRequest(s, 'wc_pairingPing', {}),
            { done: o, resolve: a, reject: c } = Ic()
          this.events.once(en('pairing_ping', i), ({ error: u }) => {
            u ? c(u) : a()
          }),
            await o()
        }
      }),
      $t(this, 'updateExpiry', async ({ topic: r, expiry: s }) => {
        this.isInitialized(), await this.pairings.update(r, { expiry: s })
      }),
      $t(this, 'updateMetadata', async ({ topic: r, metadata: s }) => {
        this.isInitialized(), await this.pairings.update(r, { peerMetadata: s })
      }),
      $t(this, 'getPairings', () => (this.isInitialized(), this.pairings.values)),
      $t(this, 'disconnect', async r => {
        this.isInitialized(), await this.isValidDisconnect(r)
        const { topic: s } = r
        this.pairings.keys.includes(s) &&
          (await this.sendRequest(s, 'wc_pairingDelete', an('USER_DISCONNECTED')),
          await this.deletePairing(s))
      }),
      $t(this, 'formatUriFromPairing', r => {
        this.isInitialized()
        const { topic: s, relay: i, expiry: o, methods: a } = r,
          c = this.core.crypto.keychain.get(s)
        return JI({
          protocol: this.core.protocol,
          version: this.core.version,
          topic: s,
          symKey: c,
          relay: i,
          expiryTimestamp: o,
          methods: a
        })
      }),
      $t(this, 'sendRequest', async (r, s, i) => {
        const o = Ua(s, i),
          a = await this.core.crypto.encode(r, o),
          c = Xd[s].req
        return this.core.history.set(r, o), this.core.relayer.publish(r, a, c), o.id
      }),
      $t(this, 'sendResult', async (r, s, i) => {
        const o = H0(r, i),
          a = await this.core.crypto.encode(s, o),
          c = (await this.core.history.get(s, r)).request.method,
          u = Xd[c].res
        await this.core.relayer.publish(s, a, u), await this.core.history.resolve(o)
      }),
      $t(this, 'sendError', async (r, s, i) => {
        const o = q0(r, i),
          a = await this.core.crypto.encode(s, o),
          c = (await this.core.history.get(s, r)).request.method,
          u = Xd[c] ? Xd[c].res : Xd.unregistered_method.res
        await this.core.relayer.publish(s, a, u), await this.core.history.resolve(o)
      }),
      $t(this, 'deletePairing', async (r, s) => {
        await this.core.relayer.unsubscribe(r),
          await Promise.all([
            this.pairings.delete(r, an('USER_DISCONNECTED')),
            this.core.crypto.deleteSymKey(r),
            s ? Promise.resolve() : this.core.expirer.del(r)
          ])
      }),
      $t(this, 'cleanup', async () => {
        const r = this.pairings.getAll().filter(s => Ca(s.expiry))
        await Promise.all(r.map(s => this.deletePairing(s.topic)))
      }),
      $t(this, 'onRelayEventRequest', async r => {
        const { topic: s, payload: i } = r
        switch (i.method) {
          case 'wc_pairingPing':
            return await this.onPairingPingRequest(s, i)
          case 'wc_pairingDelete':
            return await this.onPairingDeleteRequest(s, i)
          default:
            return await this.onUnknownRpcMethodRequest(s, i)
        }
      }),
      $t(this, 'onRelayEventResponse', async r => {
        const { topic: s, payload: i } = r,
          o = (await this.core.history.get(s, i.id)).request.method
        switch (o) {
          case 'wc_pairingPing':
            return this.onPairingPingResponse(s, i)
          default:
            return this.onUnknownRpcMethodResponse(o)
        }
      }),
      $t(this, 'onPairingPingRequest', async (r, s) => {
        const { id: i } = s
        try {
          this.isValidPing({ topic: r }),
            await this.sendResult(i, r, !0),
            this.events.emit(kc.ping, { id: i, topic: r })
        } catch (o) {
          await this.sendError(i, r, o), this.logger.error(o)
        }
      }),
      $t(this, 'onPairingPingResponse', (r, s) => {
        const { id: i } = s
        setTimeout(() => {
          Ki(s)
            ? this.events.emit(en('pairing_ping', i), {})
            : ri(s) && this.events.emit(en('pairing_ping', i), { error: s.error })
        }, 500)
      }),
      $t(this, 'onPairingDeleteRequest', async (r, s) => {
        const { id: i } = s
        try {
          this.isValidDisconnect({ topic: r }),
            await this.deletePairing(r),
            this.events.emit(kc.delete, { id: i, topic: r })
        } catch (o) {
          await this.sendError(i, r, o), this.logger.error(o)
        }
      }),
      $t(this, 'onUnknownRpcMethodRequest', async (r, s) => {
        const { id: i, method: o } = s
        try {
          if (this.registeredMethods.includes(o)) return
          const a = an('WC_METHOD_UNSUPPORTED', o)
          await this.sendError(i, r, a), this.logger.error(a)
        } catch (a) {
          await this.sendError(i, r, a), this.logger.error(a)
        }
      }),
      $t(this, 'onUnknownRpcMethodResponse', r => {
        this.registeredMethods.includes(r) || this.logger.error(an('WC_METHOD_UNSUPPORTED', r))
      }),
      $t(this, 'isValidPair', (r, s) => {
        var i
        if (!ws(r)) {
          const { message: a } = Le('MISSING_OR_INVALID', `pair() params: ${r}`)
          throw (s.setError(Do.malformed_pairing_uri), new Error(a))
        }
        if (!_J(r.uri)) {
          const { message: a } = Le('MISSING_OR_INVALID', `pair() uri: ${r.uri}`)
          throw (s.setError(Do.malformed_pairing_uri), new Error(a))
        }
        const o = YI(r == null ? void 0 : r.uri)
        if (!((i = o == null ? void 0 : o.relay) != null && i.protocol)) {
          const { message: a } = Le('MISSING_OR_INVALID', 'pair() uri#relay-protocol')
          throw (s.setError(Do.malformed_pairing_uri), new Error(a))
        }
        if (!(o != null && o.symKey)) {
          const { message: a } = Le('MISSING_OR_INVALID', 'pair() uri#symKey')
          throw (s.setError(Do.malformed_pairing_uri), new Error(a))
        }
        if (
          o != null &&
          o.expiryTimestamp &&
          Me.toMiliseconds(o == null ? void 0 : o.expiryTimestamp) < Date.now()
        ) {
          s.setError(Do.pairing_expired)
          const { message: a } = Le(
            'EXPIRED',
            'pair() URI has expired. Please try again with a new connection URI.'
          )
          throw new Error(a)
        }
      }),
      $t(this, 'isValidPing', async r => {
        if (!ws(r)) {
          const { message: i } = Le('MISSING_OR_INVALID', `ping() params: ${r}`)
          throw new Error(i)
        }
        const { topic: s } = r
        await this.isValidPairingTopic(s)
      }),
      $t(this, 'isValidDisconnect', async r => {
        if (!ws(r)) {
          const { message: i } = Le('MISSING_OR_INVALID', `disconnect() params: ${r}`)
          throw new Error(i)
        }
        const { topic: s } = r
        await this.isValidPairingTopic(s)
      }),
      $t(this, 'isValidPairingTopic', async r => {
        if (!Yn(r, !1)) {
          const { message: s } = Le('MISSING_OR_INVALID', `pairing topic should be a string: ${r}`)
          throw new Error(s)
        }
        if (!this.pairings.keys.includes(r)) {
          const { message: s } = Le('NO_MATCHING_KEY', `pairing topic doesn't exist: ${r}`)
          throw new Error(s)
        }
        if (Ca(this.pairings.get(r).expiry)) {
          await this.deletePairing(r)
          const { message: s } = Le('EXPIRED', `pairing topic: ${r}`)
          throw new Error(s)
        }
      }),
      (this.core = e),
      (this.logger = Jr(n, this.name)),
      (this.pairings = new Nu(this.core, this.logger, this.name, this.storagePrefix))
  }
  get context() {
    return Is(this.logger)
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Le('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(hr.message, async e => {
      const { topic: n, message: r, transportType: s } = e
      if (
        this.pairings.keys.includes(n) &&
        s !== Sn.link_mode &&
        !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(r))
      )
        try {
          const i = await this.core.crypto.decode(n, r)
          MA(i)
            ? (this.core.history.set(n, i),
              await this.onRelayEventRequest({ topic: n, payload: i }))
            : z0(i) &&
              (await this.core.history.resolve(i),
              await this.onRelayEventResponse({ topic: n, payload: i }),
              this.core.history.delete(n, i.id)),
            await this.core.relayer.messages.ack(n, r)
        } catch (i) {
          this.logger.error(i)
        }
    })
  }
  registerExpirerEvents() {
    this.core.expirer.on(ti.expired, async e => {
      const { topic: n } = tO(e.target)
      n &&
        this.pairings.keys.includes(n) &&
        (await this.deletePairing(n, !0), this.events.emit(kc.expire, { topic: n }))
    })
  }
}
var Dne = Object.defineProperty,
  Mne = (t, e, n) =>
    e in t ? Dne(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  _r = (t, e, n) => Mne(t, typeof e != 'symbol' ? e + '' : e, n)
class Une extends Bz {
  constructor(e, n) {
    super(e, n),
      (this.core = e),
      (this.logger = n),
      _r(this, 'records', new Map()),
      _r(this, 'events', new ui.EventEmitter()),
      _r(this, 'name', $X),
      _r(this, 'version', FX),
      _r(this, 'cached', []),
      _r(this, 'initialized', !1),
      _r(this, 'storagePrefix', co),
      _r(this, 'init', async () => {
        this.initialized ||
          (this.logger.trace('Initialized'),
          await this.restore(),
          this.cached.forEach(r => this.records.set(r.id, r)),
          (this.cached = []),
          this.registerEventListeners(),
          (this.initialized = !0))
      }),
      _r(this, 'set', (r, s, i) => {
        if (
          (this.isInitialized(),
          this.logger.debug('Setting JSON-RPC request history record'),
          this.logger.trace({ type: 'method', method: 'set', topic: r, request: s, chainId: i }),
          this.records.has(s.id))
        )
          return
        const o = {
          id: s.id,
          topic: r,
          request: { method: s.method, params: s.params || null },
          chainId: i,
          expiry: tr(Me.THIRTY_DAYS)
        }
        this.records.set(o.id, o), this.persist(), this.events.emit(pi.created, o)
      }),
      _r(this, 'resolve', async r => {
        if (
          (this.isInitialized(),
          this.logger.debug('Updating JSON-RPC response history record'),
          this.logger.trace({ type: 'method', method: 'update', response: r }),
          !this.records.has(r.id))
        )
          return
        const s = await this.getRecord(r.id)
        typeof s.response > 'u' &&
          ((s.response = ri(r) ? { error: r.error } : { result: r.result }),
          this.records.set(s.id, s),
          this.persist(),
          this.events.emit(pi.updated, s))
      }),
      _r(
        this,
        'get',
        async (r, s) => (
          this.isInitialized(),
          this.logger.debug('Getting record'),
          this.logger.trace({ type: 'method', method: 'get', topic: r, id: s }),
          await this.getRecord(s)
        )
      ),
      _r(this, 'delete', (r, s) => {
        this.isInitialized(),
          this.logger.debug('Deleting record'),
          this.logger.trace({ type: 'method', method: 'delete', id: s }),
          this.values.forEach(i => {
            if (i.topic === r) {
              if (typeof s < 'u' && i.id !== s) return
              this.records.delete(i.id), this.events.emit(pi.deleted, i)
            }
          }),
          this.persist()
      }),
      _r(
        this,
        'exists',
        async (r, s) => (
          this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === r : !1
        )
      ),
      _r(this, 'on', (r, s) => {
        this.events.on(r, s)
      }),
      _r(this, 'once', (r, s) => {
        this.events.once(r, s)
      }),
      _r(this, 'off', (r, s) => {
        this.events.off(r, s)
      }),
      _r(this, 'removeListener', (r, s) => {
        this.events.removeListener(r, s)
      }),
      (this.logger = Jr(n, this.name))
  }
  get context() {
    return Is(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
  }
  get size() {
    return this.records.size
  }
  get keys() {
    return Array.from(this.records.keys())
  }
  get values() {
    return Array.from(this.records.values())
  }
  get pending() {
    const e = []
    return (
      this.values.forEach(n => {
        if (typeof n.response < 'u') return
        const r = {
          topic: n.topic,
          request: Ua(n.request.method, n.request.params, n.id),
          chainId: n.chainId
        }
        return e.push(r)
      }),
      e
    )
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e)
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey)
  }
  getRecord(e) {
    this.isInitialized()
    const n = this.records.get(e)
    if (!n) {
      const { message: r } = Le('NO_MATCHING_KEY', `${this.name}: ${e}`)
      throw new Error(r)
    }
    return n
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(pi.sync)
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords()
      if (typeof e > 'u' || !e.length) return
      if (this.records.size) {
        const { message: n } = Le('RESTORE_WILL_OVERRIDE', this.name)
        throw (this.logger.error(n), new Error(n))
      }
      ;(this.cached = e),
        this.logger.debug(`Successfully Restored records for ${this.name}`),
        this.logger.trace({ type: 'method', method: 'restore', records: this.values })
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e)
    }
  }
  registerEventListeners() {
    this.events.on(pi.created, e => {
      const n = pi.created
      this.logger.info(`Emitting ${n}`), this.logger.debug({ type: 'event', event: n, record: e })
    }),
      this.events.on(pi.updated, e => {
        const n = pi.updated
        this.logger.info(`Emitting ${n}`), this.logger.debug({ type: 'event', event: n, record: e })
      }),
      this.events.on(pi.deleted, e => {
        const n = pi.deleted
        this.logger.info(`Emitting ${n}`), this.logger.debug({ type: 'event', event: n, record: e })
      }),
      this.core.heartbeat.on(Sd.pulse, () => {
        this.cleanup()
      })
  }
  cleanup() {
    try {
      this.isInitialized()
      let e = !1
      this.records.forEach(n => {
        Me.toMiliseconds(n.expiry || 0) - Date.now() <= 0 &&
          (this.logger.info(`Deleting expired history log: ${n.id}`),
          this.records.delete(n.id),
          this.events.emit(pi.deleted, n, !1),
          (e = !0))
      }),
        e && this.persist()
    } catch (e) {
      this.logger.warn(e)
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Le('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
}
var Lne = Object.defineProperty,
  $ne = (t, e, n) =>
    e in t ? Lne(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Mr = (t, e, n) => $ne(t, typeof e != 'symbol' ? e + '' : e, n)
class Fne extends Fz {
  constructor(e, n) {
    super(e, n),
      (this.core = e),
      (this.logger = n),
      Mr(this, 'expirations', new Map()),
      Mr(this, 'events', new ui.EventEmitter()),
      Mr(this, 'name', jX),
      Mr(this, 'version', HX),
      Mr(this, 'cached', []),
      Mr(this, 'initialized', !1),
      Mr(this, 'storagePrefix', co),
      Mr(this, 'init', async () => {
        this.initialized ||
          (this.logger.trace('Initialized'),
          await this.restore(),
          this.cached.forEach(r => this.expirations.set(r.target, r)),
          (this.cached = []),
          this.registerEventListeners(),
          (this.initialized = !0))
      }),
      Mr(this, 'has', r => {
        try {
          const s = this.formatTarget(r)
          return typeof this.getExpiration(s) < 'u'
        } catch {
          return !1
        }
      }),
      Mr(this, 'set', (r, s) => {
        this.isInitialized()
        const i = this.formatTarget(r),
          o = { target: i, expiry: s }
        this.expirations.set(i, o),
          this.checkExpiry(i, o),
          this.events.emit(ti.created, { target: i, expiration: o })
      }),
      Mr(this, 'get', r => {
        this.isInitialized()
        const s = this.formatTarget(r)
        return this.getExpiration(s)
      }),
      Mr(this, 'del', r => {
        if ((this.isInitialized(), this.has(r))) {
          const s = this.formatTarget(r),
            i = this.getExpiration(s)
          this.expirations.delete(s), this.events.emit(ti.deleted, { target: s, expiration: i })
        }
      }),
      Mr(this, 'on', (r, s) => {
        this.events.on(r, s)
      }),
      Mr(this, 'once', (r, s) => {
        this.events.once(r, s)
      }),
      Mr(this, 'off', (r, s) => {
        this.events.off(r, s)
      }),
      Mr(this, 'removeListener', (r, s) => {
        this.events.removeListener(r, s)
      }),
      (this.logger = Jr(n, this.name))
  }
  get context() {
    return Is(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + '//' + this.name
  }
  get length() {
    return this.expirations.size
  }
  get keys() {
    return Array.from(this.expirations.keys())
  }
  get values() {
    return Array.from(this.expirations.values())
  }
  formatTarget(e) {
    if (typeof e == 'string') return BQ(e)
    if (typeof e == 'number') return DQ(e)
    const { message: n } = Le('UNKNOWN_TYPE', `Target type: ${typeof e}`)
    throw new Error(n)
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e)
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey)
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(ti.sync)
  }
  async restore() {
    try {
      const e = await this.getExpirations()
      if (typeof e > 'u' || !e.length) return
      if (this.expirations.size) {
        const { message: n } = Le('RESTORE_WILL_OVERRIDE', this.name)
        throw (this.logger.error(n), new Error(n))
      }
      ;(this.cached = e),
        this.logger.debug(`Successfully Restored expirations for ${this.name}`),
        this.logger.trace({ type: 'method', method: 'restore', expirations: this.values })
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e)
    }
  }
  getExpiration(e) {
    const n = this.expirations.get(e)
    if (!n) {
      const { message: r } = Le('NO_MATCHING_KEY', `${this.name}: ${e}`)
      throw (this.logger.warn(r), new Error(r))
    }
    return n
  }
  checkExpiry(e, n) {
    const { expiry: r } = n
    Me.toMiliseconds(r) - Date.now() <= 0 && this.expire(e, n)
  }
  expire(e, n) {
    this.expirations.delete(e), this.events.emit(ti.expired, { target: e, expiration: n })
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, n) => this.checkExpiry(n, e))
  }
  registerEventListeners() {
    this.core.heartbeat.on(Sd.pulse, () => this.checkExpirations()),
      this.events.on(ti.created, e => {
        const n = ti.created
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: 'event', event: n, data: e }),
          this.persist()
      }),
      this.events.on(ti.expired, e => {
        const n = ti.expired
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: 'event', event: n, data: e }),
          this.persist()
      }),
      this.events.on(ti.deleted, e => {
        const n = ti.deleted
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: 'event', event: n, data: e }),
          this.persist()
      })
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Le('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
}
var jne = Object.defineProperty,
  Hne = (t, e, n) =>
    e in t ? jne(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Gn = (t, e, n) => Hne(t, typeof e != 'symbol' ? e + '' : e, n)
class qne extends jz {
  constructor(e, n, r) {
    super(e, n, r),
      (this.core = e),
      (this.logger = n),
      (this.store = r),
      Gn(this, 'name', qX),
      Gn(this, 'abortController'),
      Gn(this, 'isDevEnv'),
      Gn(this, 'verifyUrlV3', WX),
      Gn(this, 'storagePrefix', co),
      Gn(this, 'version', qO),
      Gn(this, 'publicKey'),
      Gn(this, 'fetchPromise'),
      Gn(this, 'init', async () => {
        var s
        this.isDevEnv ||
          ((this.publicKey = await this.store.getItem(this.storeKey)),
          this.publicKey &&
            Me.toMiliseconds((s = this.publicKey) == null ? void 0 : s.expiresAt) < Date.now() &&
            (this.logger.debug('verify v2 public key expired'), await this.removePublicKey()))
      }),
      Gn(this, 'register', async s => {
        if (!gp() || this.isDevEnv) return
        const i = window.location.origin,
          { id: o, decryptedId: a } = s,
          c = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${i}&id=${o}&decryptedId=${a}`
        try {
          const u = fu.getDocument(),
            l = this.startAbortTimer(Me.ONE_SECOND * 5),
            d = await new Promise((h, p) => {
              const y = () => {
                window.removeEventListener('message', b),
                  u.body.removeChild(m),
                  p('attestation aborted')
              }
              this.abortController.signal.addEventListener('abort', y)
              const m = u.createElement('iframe')
              ;(m.src = c),
                (m.style.display = 'none'),
                m.addEventListener('error', y, { signal: this.abortController.signal })
              const b = I => {
                if (I.data && typeof I.data == 'string')
                  try {
                    const x = JSON.parse(I.data)
                    if (x.type === 'verify_attestation') {
                      if (nv(x.attestation).payload.id !== o) return
                      clearInterval(l),
                        u.body.removeChild(m),
                        this.abortController.signal.removeEventListener('abort', y),
                        window.removeEventListener('message', b),
                        h(x.attestation === null ? '' : x.attestation)
                    }
                  } catch (x) {
                    this.logger.warn(x)
                  }
              }
              u.body.appendChild(m),
                window.addEventListener('message', b, { signal: this.abortController.signal })
            })
          return this.logger.debug('jwt attestation', d), d
        } catch (u) {
          this.logger.warn(u)
        }
        return ''
      }),
      Gn(this, 'resolve', async s => {
        if (this.isDevEnv) return ''
        const { attestationId: i, hash: o, encryptedId: a } = s
        if (i === '') {
          this.logger.debug('resolve: attestationId is empty, skipping')
          return
        }
        if (i) {
          if (nv(i).payload.id !== a) return
          const u = await this.isValidJwtAttestation(i)
          if (u) {
            if (!u.isVerified) {
              this.logger.warn('resolve: jwt attestation: origin url not verified')
              return
            }
            return u
          }
        }
        if (!o) return
        const c = this.getVerifyUrl(s == null ? void 0 : s.verifyUrl)
        return this.fetchAttestation(o, c)
      }),
      Gn(this, 'fetchAttestation', async (s, i) => {
        this.logger.debug(`resolving attestation: ${s} from url: ${i}`)
        const o = this.startAbortTimer(Me.ONE_SECOND * 5),
          a = await fetch(`${i}/attestation/${s}?v2Supported=true`, {
            signal: this.abortController.signal
          })
        return clearTimeout(o), a.status === 200 ? await a.json() : void 0
      }),
      Gn(this, 'getVerifyUrl', s => {
        let i = s || Bh
        return (
          KX.includes(i) ||
            (this.logger.info(
              `verify url: ${i}, not included in trusted list, assigning default: ${Bh}`
            ),
            (i = Bh)),
          i
        )
      }),
      Gn(this, 'fetchPublicKey', async () => {
        try {
          this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`)
          const s = this.startAbortTimer(Me.FIVE_SECONDS),
            i = await fetch(`${this.verifyUrlV3}/public-key`, {
              signal: this.abortController.signal
            })
          return clearTimeout(s), await i.json()
        } catch (s) {
          this.logger.warn(s)
        }
      }),
      Gn(this, 'persistPublicKey', async s => {
        this.logger.debug('persisting public key to local storage', s),
          await this.store.setItem(this.storeKey, s),
          (this.publicKey = s)
      }),
      Gn(this, 'removePublicKey', async () => {
        this.logger.debug('removing verify v2 public key from storage'),
          await this.store.removeItem(this.storeKey),
          (this.publicKey = void 0)
      }),
      Gn(this, 'isValidJwtAttestation', async s => {
        const i = await this.getPublicKey()
        try {
          if (i) return this.validateAttestation(s, i)
        } catch (a) {
          this.logger.error(a), this.logger.warn('error validating attestation')
        }
        const o = await this.fetchAndPersistPublicKey()
        try {
          if (o) return this.validateAttestation(s, o)
        } catch (a) {
          this.logger.error(a), this.logger.warn('error validating attestation')
        }
      }),
      Gn(this, 'getPublicKey', async () =>
        this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()
      ),
      Gn(this, 'fetchAndPersistPublicKey', async () => {
        if (this.fetchPromise) return await this.fetchPromise, this.publicKey
        this.fetchPromise = new Promise(async i => {
          const o = await this.fetchPublicKey()
          o && (await this.persistPublicKey(o), i(o))
        })
        const s = await this.fetchPromise
        return (this.fetchPromise = void 0), s
      }),
      Gn(this, 'validateAttestation', (s, i) => {
        const o = lJ(s, i.publicKey),
          a = { hasExpired: Me.toMiliseconds(o.exp) < Date.now(), payload: o }
        if (a.hasExpired)
          throw (
            (this.logger.warn('resolve: jwt attestation expired'),
            new Error('JWT attestation expired'))
          )
        return {
          origin: a.payload.origin,
          isScam: a.payload.isScam,
          isVerified: a.payload.isVerified
        }
      }),
      (this.logger = Jr(n, this.name)),
      (this.abortController = new AbortController()),
      (this.isDevEnv = IA()),
      this.init()
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + '//verify:public:key'
  }
  get context() {
    return Is(this.logger)
  }
  startAbortTimer(e) {
    return (
      (this.abortController = new AbortController()),
      setTimeout(() => this.abortController.abort(), Me.toMiliseconds(e))
    )
  }
}
var zne = Object.defineProperty,
  Wne = (t, e, n) =>
    e in t ? zne(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  O2 = (t, e, n) => Wne(t, typeof e != 'symbol' ? e + '' : e, n)
class Kne extends Hz {
  constructor(e, n) {
    super(e, n),
      (this.projectId = e),
      (this.logger = n),
      O2(this, 'context', VX),
      O2(this, 'registerDeviceToken', async r => {
        const { clientId: s, token: i, notificationType: o, enableEncrypted: a = !1 } = r,
          c = `${GX}/${this.projectId}/clients`
        await fetch(c, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ client_id: s, type: o, token: i, always_raw: a })
        })
      }),
      (this.logger = Jr(n, this.context))
  }
}
var Vne = Object.defineProperty,
  B2 = Object.getOwnPropertySymbols,
  Gne = Object.prototype.hasOwnProperty,
  Qne = Object.prototype.propertyIsEnumerable,
  Iv = (t, e, n) =>
    e in t ? Vne(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  nh = (t, e) => {
    for (var n in e || (e = {})) Gne.call(e, n) && Iv(t, n, e[n])
    if (B2) for (var n of B2(e)) Qne.call(e, n) && Iv(t, n, e[n])
    return t
  },
  ar = (t, e, n) => Iv(t, typeof e != 'symbol' ? e + '' : e, n)
class Zne extends qz {
  constructor(e, n, r = !0) {
    super(e, n, r),
      (this.core = e),
      (this.logger = n),
      ar(this, 'context', ZX),
      ar(this, 'storagePrefix', co),
      ar(this, 'storageVersion', QX),
      ar(this, 'events', new Map()),
      ar(this, 'shouldPersist', !1),
      ar(this, 'init', async () => {
        if (!IA())
          try {
            const s = {
              eventId: EI(),
              timestamp: Date.now(),
              domain: this.getAppDomain(),
              props: {
                event: 'INIT',
                type: '',
                properties: {
                  client_id: await this.core.crypto.getClientId(),
                  user_agent: Xk(this.core.relayer.protocol, this.core.relayer.version, wv)
                }
              }
            }
            await this.sendEvent([s])
          } catch (s) {
            this.logger.warn(s)
          }
      }),
      ar(this, 'createEvent', s => {
        const {
            event: i = 'ERROR',
            type: o = '',
            properties: { topic: a, trace: c }
          } = s,
          u = EI(),
          l = this.core.projectId || '',
          d = Date.now(),
          h = nh(
            {
              eventId: u,
              timestamp: d,
              props: { event: i, type: o, properties: { topic: a, trace: c } },
              bundleId: l,
              domain: this.getAppDomain()
            },
            this.setMethods(u)
          )
        return this.telemetryEnabled && (this.events.set(u, h), (this.shouldPersist = !0)), h
      }),
      ar(this, 'getEvent', s => {
        const { eventId: i, topic: o } = s
        if (i) return this.events.get(i)
        const a = Array.from(this.events.values()).find(c => c.props.properties.topic === o)
        if (a) return nh(nh({}, a), this.setMethods(a.eventId))
      }),
      ar(this, 'deleteEvent', s => {
        const { eventId: i } = s
        this.events.delete(i), (this.shouldPersist = !0)
      }),
      ar(this, 'setEventListeners', () => {
        this.core.heartbeat.on(Sd.pulse, async () => {
          this.shouldPersist && (await this.persist()),
            this.events.forEach(s => {
              Me.fromMiliseconds(Date.now()) - Me.fromMiliseconds(s.timestamp) > YX &&
                (this.events.delete(s.eventId), (this.shouldPersist = !0))
            })
        })
      }),
      ar(this, 'setMethods', s => ({
        addTrace: i => this.addTrace(s, i),
        setError: i => this.setError(s, i)
      })),
      ar(this, 'addTrace', (s, i) => {
        const o = this.events.get(s)
        o && (o.props.properties.trace.push(i), this.events.set(s, o), (this.shouldPersist = !0))
      }),
      ar(this, 'setError', (s, i) => {
        const o = this.events.get(s)
        o &&
          ((o.props.type = i),
          (o.timestamp = Date.now()),
          this.events.set(s, o),
          (this.shouldPersist = !0))
      }),
      ar(this, 'persist', async () => {
        await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())),
          (this.shouldPersist = !1)
      }),
      ar(this, 'restore', async () => {
        try {
          const s = (await this.core.storage.getItem(this.storageKey)) || []
          if (!s.length) return
          s.forEach(i => {
            this.events.set(i.eventId, nh(nh({}, i), this.setMethods(i.eventId)))
          })
        } catch (s) {
          this.logger.warn(s)
        }
      }),
      ar(this, 'submit', async () => {
        if (!this.telemetryEnabled || this.events.size === 0) return
        const s = []
        for (const [i, o] of this.events) o.props.type && s.push(o)
        if (s.length !== 0)
          try {
            if ((await this.sendEvent(s)).ok)
              for (const i of s) this.events.delete(i.eventId), (this.shouldPersist = !0)
          } catch (i) {
            this.logger.warn(i)
          }
      }),
      ar(this, 'sendEvent', async s => {
        const i = this.getAppDomain() ? '' : '&sp=desktop'
        return await fetch(`${JX}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${wv}${i}`, {
          method: 'POST',
          body: JSON.stringify(s)
        })
      }),
      ar(this, 'getAppDomain', () => Jk().url),
      (this.logger = Jr(n, this.context)),
      (this.telemetryEnabled = r),
      r
        ? this.restore().then(async () => {
            await this.submit(), this.setEventListeners()
          })
        : this.persist()
  }
  get storageKey() {
    return (
      this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + '//' + this.context
    )
  }
}
var Yne = Object.defineProperty,
  D2 = Object.getOwnPropertySymbols,
  Jne = Object.prototype.hasOwnProperty,
  Xne = Object.prototype.propertyIsEnumerable,
  xv = (t, e, n) =>
    e in t ? Yne(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  M2 = (t, e) => {
    for (var n in e || (e = {})) Jne.call(e, n) && xv(t, n, e[n])
    if (D2) for (var n of D2(e)) Xne.call(e, n) && xv(t, n, e[n])
    return t
  },
  mn = (t, e, n) => xv(t, typeof e != 'symbol' ? e + '' : e, n)
let ere = class r8 extends Pz {
  constructor(e) {
    var n
    super(e),
      mn(this, 'protocol', HO),
      mn(this, 'version', qO),
      mn(this, 'name', yv),
      mn(this, 'relayUrl'),
      mn(this, 'projectId'),
      mn(this, 'customStoragePrefix'),
      mn(this, 'events', new ui.EventEmitter()),
      mn(this, 'logger'),
      mn(this, 'heartbeat'),
      mn(this, 'relayer'),
      mn(this, 'crypto'),
      mn(this, 'storage'),
      mn(this, 'history'),
      mn(this, 'expirer'),
      mn(this, 'pairing'),
      mn(this, 'verify'),
      mn(this, 'echoClient'),
      mn(this, 'linkModeSupportedApps'),
      mn(this, 'eventClient'),
      mn(this, 'initialized', !1),
      mn(this, 'logChunkController'),
      mn(this, 'on', (a, c) => this.events.on(a, c)),
      mn(this, 'once', (a, c) => this.events.once(a, c)),
      mn(this, 'off', (a, c) => this.events.off(a, c)),
      mn(this, 'removeListener', (a, c) => this.events.removeListener(a, c)),
      mn(this, 'dispatchEnvelope', ({ topic: a, message: c, sessionExists: u }) => {
        if (!a || !c) return
        const l = { topic: a, message: c, publishedAt: Date.now(), transportType: Sn.link_mode }
        this.relayer.onLinkMessageEvent(l, { sessionExists: u })
      })
    const r = this.getGlobalCore(e == null ? void 0 : e.customStoragePrefix)
    if (r)
      try {
        return (
          (this.customStoragePrefix = r.customStoragePrefix),
          (this.logger = r.logger),
          (this.heartbeat = r.heartbeat),
          (this.crypto = r.crypto),
          (this.history = r.history),
          (this.expirer = r.expirer),
          (this.storage = r.storage),
          (this.relayer = r.relayer),
          (this.pairing = r.pairing),
          (this.verify = r.verify),
          (this.echoClient = r.echoClient),
          (this.linkModeSupportedApps = r.linkModeSupportedApps),
          (this.eventClient = r.eventClient),
          (this.initialized = r.initialized),
          (this.logChunkController = r.logChunkController),
          r
        )
      } catch (a) {
        console.warn('Failed to copy global core', a)
      }
    ;(this.projectId = e == null ? void 0 : e.projectId),
      (this.relayUrl = (e == null ? void 0 : e.relayUrl) || WO),
      (this.customStoragePrefix =
        e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : '')
    const s = Id({
        level:
          typeof (e == null ? void 0 : e.logger) == 'string' && e.logger ? e.logger : vX.logger,
        name: yv
      }),
      { logger: i, chunkLoggerController: o } = wA({
        opts: s,
        maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes,
        loggerOverride: e == null ? void 0 : e.logger
      })
    ;(this.logChunkController = o),
      (n = this.logChunkController) != null &&
        n.downloadLogsBlobInBrowser &&
        (window.downloadLogsBlobInBrowser = async () => {
          var a, c
          ;(a = this.logChunkController) != null &&
            a.downloadLogsBlobInBrowser &&
            ((c = this.logChunkController) == null ||
              c.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }))
        }),
      (this.logger = Jr(i, this.name)),
      (this.heartbeat = new Bq()),
      (this.crypto = new xte(this, this.logger, e == null ? void 0 : e.keychain)),
      (this.history = new Une(this, this.logger)),
      (this.expirer = new Fne(this, this.logger)),
      (this.storage =
        e != null && e.storage
          ? e.storage
          : new dz(M2(M2({}, EX), e == null ? void 0 : e.storageOptions))),
      (this.relayer = new ene({
        core: this,
        logger: this.logger,
        relayUrl: this.relayUrl,
        projectId: this.projectId
      })),
      (this.pairing = new Bne(this, this.logger)),
      (this.verify = new qne(this, this.logger, this.storage)),
      (this.echoClient = new Kne(this.projectId || '', this.logger)),
      (this.linkModeSupportedApps = []),
      (this.eventClient = new Zne(this, this.logger, e == null ? void 0 : e.telemetryEnabled)),
      this.setGlobalCore(this)
  }
  static async init(e) {
    const n = new r8(e)
    await n.initialize()
    const r = await n.crypto.getClientId()
    return await n.storage.setItem(BX, r), n
  }
  get context() {
    return Is(this.logger)
  }
  async start() {
    this.initialized || (await this.initialize())
  }
  async getLogsBlob() {
    var e
    return (e = this.logChunkController) == null
      ? void 0
      : e.logsToBlob({ clientId: await this.crypto.getClientId() })
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) ||
      (this.linkModeSupportedApps.push(e),
      await this.storage.setItem(g2, this.linkModeSupportedApps))
  }
  async initialize() {
    this.logger.trace('Initialized')
    try {
      await this.crypto.init(),
        await this.history.init(),
        await this.expirer.init(),
        await this.relayer.init(),
        await this.heartbeat.init(),
        await this.pairing.init(),
        (this.linkModeSupportedApps = (await this.storage.getItem(g2)) || []),
        (this.initialized = !0),
        this.logger.info('Core Initialization Success')
    } catch (e) {
      throw (
        (this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e),
        this.logger.error(e.message),
        e)
      )
    }
  }
  getGlobalCore(e = '') {
    try {
      if (this.isGlobalCoreDisabled()) return
      const n = `_walletConnectCore_${e}`,
        r = `${n}_count`
      return (
        (globalThis[r] = (globalThis[r] || 0) + 1),
        globalThis[r] > 1 &&
          console.warn(
            `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[r]} times.`
          ),
        globalThis[n]
      )
    } catch (n) {
      console.warn('Failed to get global WalletConnect core', n)
      return
    }
  }
  setGlobalCore(e) {
    var n
    try {
      if (this.isGlobalCoreDisabled()) return
      const r = `_walletConnectCore_${((n = e.opts) == null ? void 0 : n.customStoragePrefix) || ''}`
      globalThis[r] = e
    } catch (r) {
      console.warn('Failed to set global WalletConnect core', r)
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < 'u' && bX.DISABLE_GLOBAL_CORE === 'true'
    } catch {
      return !0
    }
  }
}
const tre = ere,
  s8 = 'wc',
  i8 = 2,
  o8 = 'client',
  UA = `${s8}@${i8}:${o8}:`,
  sb = { name: o8, logger: 'error' },
  U2 = 'WALLETCONNECT_DEEPLINK_CHOICE',
  nre = 'proposal',
  L2 = 'Proposal expired',
  rre = 'session',
  zu = Me.SEVEN_DAYS,
  sre = 'engine',
  cr = {
    wc_sessionPropose: {
      req: { ttl: Me.FIVE_MINUTES, prompt: !0, tag: 1100 },
      res: { ttl: Me.FIVE_MINUTES, prompt: !1, tag: 1101 },
      reject: { ttl: Me.FIVE_MINUTES, prompt: !1, tag: 1120 },
      autoReject: { ttl: Me.FIVE_MINUTES, prompt: !1, tag: 1121 }
    },
    wc_sessionSettle: {
      req: { ttl: Me.FIVE_MINUTES, prompt: !1, tag: 1102 },
      res: { ttl: Me.FIVE_MINUTES, prompt: !1, tag: 1103 }
    },
    wc_sessionUpdate: {
      req: { ttl: Me.ONE_DAY, prompt: !1, tag: 1104 },
      res: { ttl: Me.ONE_DAY, prompt: !1, tag: 1105 }
    },
    wc_sessionExtend: {
      req: { ttl: Me.ONE_DAY, prompt: !1, tag: 1106 },
      res: { ttl: Me.ONE_DAY, prompt: !1, tag: 1107 }
    },
    wc_sessionRequest: {
      req: { ttl: Me.FIVE_MINUTES, prompt: !0, tag: 1108 },
      res: { ttl: Me.FIVE_MINUTES, prompt: !1, tag: 1109 }
    },
    wc_sessionEvent: {
      req: { ttl: Me.FIVE_MINUTES, prompt: !0, tag: 1110 },
      res: { ttl: Me.FIVE_MINUTES, prompt: !1, tag: 1111 }
    },
    wc_sessionDelete: {
      req: { ttl: Me.ONE_DAY, prompt: !1, tag: 1112 },
      res: { ttl: Me.ONE_DAY, prompt: !1, tag: 1113 }
    },
    wc_sessionPing: {
      req: { ttl: Me.ONE_DAY, prompt: !1, tag: 1114 },
      res: { ttl: Me.ONE_DAY, prompt: !1, tag: 1115 }
    },
    wc_sessionAuthenticate: {
      req: { ttl: Me.ONE_HOUR, prompt: !0, tag: 1116 },
      res: { ttl: Me.ONE_HOUR, prompt: !1, tag: 1117 },
      reject: { ttl: Me.FIVE_MINUTES, prompt: !1, tag: 1118 },
      autoReject: { ttl: Me.FIVE_MINUTES, prompt: !1, tag: 1119 }
    }
  },
  ib = { min: Me.FIVE_MINUTES, max: Me.SEVEN_DAYS },
  ji = { idle: 'IDLE', active: 'ACTIVE' },
  $2 = {
    eth_sendTransaction: { key: '' },
    eth_sendRawTransaction: { key: '' },
    wallet_sendCalls: { key: '' },
    solana_signTransaction: { key: 'signature' },
    solana_signAllTransactions: { key: 'transactions' },
    solana_signAndSendTransaction: { key: 'signature' }
  },
  ire = 'request',
  ore = ['wc_sessionPropose', 'wc_sessionRequest', 'wc_authRequest', 'wc_sessionAuthenticate'],
  are = 'wc',
  cre = 'auth',
  ure = 'authKeys',
  lre = 'pairingTopics',
  dre = 'requests',
  K0 = `${are}@${1.5}:${cre}:`,
  Lg = `${K0}:PUB_KEY`
var hre = Object.defineProperty,
  fre = Object.defineProperties,
  pre = Object.getOwnPropertyDescriptors,
  F2 = Object.getOwnPropertySymbols,
  gre = Object.prototype.hasOwnProperty,
  mre = Object.prototype.propertyIsEnumerable,
  Tv = (t, e, n) =>
    e in t ? hre(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  fn = (t, e) => {
    for (var n in e || (e = {})) gre.call(e, n) && Tv(t, n, e[n])
    if (F2) for (var n of F2(e)) mre.call(e, n) && Tv(t, n, e[n])
    return t
  },
  es = (t, e) => fre(t, pre(e)),
  Ie = (t, e, n) => Tv(t, typeof e != 'symbol' ? e + '' : e, n)
class yre extends Vz {
  constructor(e) {
    super(e),
      Ie(this, 'name', sre),
      Ie(this, 'events', new mA()),
      Ie(this, 'initialized', !1),
      Ie(this, 'requestQueue', { state: ji.idle, queue: [] }),
      Ie(this, 'sessionRequestQueue', { state: ji.idle, queue: [] }),
      Ie(this, 'requestQueueDelay', Me.ONE_SECOND),
      Ie(this, 'expectedPairingMethodMap', new Map()),
      Ie(this, 'recentlyDeletedMap', new Map()),
      Ie(this, 'recentlyDeletedLimit', 200),
      Ie(this, 'relayMessageCache', []),
      Ie(this, 'pendingSessions', new Map()),
      Ie(this, 'init', async () => {
        this.initialized ||
          (await this.cleanup(),
          this.registerRelayerEvents(),
          this.registerExpirerEvents(),
          this.registerPairingEvents(),
          await this.registerLinkModeListeners(),
          this.client.core.pairing.register({ methods: Object.keys(cr) }),
          (this.initialized = !0),
          setTimeout(async () => {
            await this.processPendingMessageEvents(),
              (this.sessionRequestQueue.queue = this.getPendingSessionRequests()),
              this.processSessionRequestQueue()
          }, Me.toMiliseconds(this.requestQueueDelay)))
      }),
      Ie(this, 'connect', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow()
        const r = es(fn({}, n), {
          requiredNamespaces: n.requiredNamespaces || {},
          optionalNamespaces: n.optionalNamespaces || {}
        })
        await this.isValidConnect(r)
        const {
          pairingTopic: s,
          requiredNamespaces: i,
          optionalNamespaces: o,
          sessionProperties: a,
          scopedProperties: c,
          relays: u
        } = r
        let l = s,
          d,
          h = !1
        try {
          if (l) {
            const T = this.client.core.pairing.pairings.get(l)
            this.client.logger.warn(
              'connect() with existing pairing topic is deprecated and will be removed in the next major release.'
            ),
              (h = T.active)
          }
        } catch (T) {
          throw (this.client.logger.error(`connect() -> pairing.get(${l}) failed`), T)
        }
        if (!l || !h) {
          const { topic: T, uri: M } = await this.client.core.pairing.create()
          ;(l = T), (d = M)
        }
        if (!l) {
          const { message: T } = Le('NO_MATCHING_KEY', `connect() pairing topic: ${l}`)
          throw new Error(T)
        }
        const p = await this.client.core.crypto.generateKeyPair(),
          y = cr.wc_sessionPropose.req.ttl || Me.FIVE_MINUTES,
          m = tr(y),
          b = es(
            fn(
              fn(
                {
                  requiredNamespaces: i,
                  optionalNamespaces: o,
                  relays: u ?? [{ protocol: zO }],
                  proposer: { publicKey: p, metadata: this.client.metadata },
                  expiryTimestamp: m,
                  pairingTopic: l
                },
                a && { sessionProperties: a }
              ),
              c && { scopedProperties: c }
            ),
            { id: Wi() }
          ),
          I = en('session_connect', b.id),
          { reject: x, resolve: _, done: R } = Ic(y, L2),
          N = ({ id: T }) => {
            T === b.id &&
              (this.client.events.off('proposal_expire', N),
              this.pendingSessions.delete(b.id),
              this.events.emit(I, { error: { message: L2, code: 0 } }))
          }
        return (
          this.client.events.on('proposal_expire', N),
          this.events.once(I, ({ error: T, session: M }) => {
            this.client.events.off('proposal_expire', N), T ? x(T) : M && _(M)
          }),
          await this.sendRequest({
            topic: l,
            method: 'wc_sessionPropose',
            params: b,
            throwOnFailedPublish: !0,
            clientRpcId: b.id
          }),
          await this.setProposal(b.id, b),
          { uri: d, approval: R }
        )
      }),
      Ie(this, 'pair', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow()
        try {
          return await this.client.core.pairing.pair(n)
        } catch (r) {
          throw (this.client.logger.error('pair() failed'), r)
        }
      }),
      Ie(this, 'approve', async n => {
        var r, s, i
        const o = this.client.core.eventClient.createEvent({
          properties: {
            topic: (r = n == null ? void 0 : n.id) == null ? void 0 : r.toString(),
            trace: [gi.session_approve_started]
          }
        })
        try {
          this.isInitialized(), await this.confirmOnlineStateOrThrow()
        } catch (B) {
          throw (o.setError(wc.no_internet_connection), B)
        }
        try {
          await this.isValidProposalId(n == null ? void 0 : n.id)
        } catch (B) {
          throw (
            (this.client.logger.error(
              `approve() -> proposal.get(${n == null ? void 0 : n.id}) failed`
            ),
            o.setError(wc.proposal_not_found),
            B)
          )
        }
        try {
          await this.isValidApprove(n)
        } catch (B) {
          throw (
            (this.client.logger.error('approve() -> isValidApprove() failed'),
            o.setError(wc.session_approve_namespace_validation_failure),
            B)
          )
        }
        const {
            id: a,
            relayProtocol: c,
            namespaces: u,
            sessionProperties: l,
            scopedProperties: d,
            sessionConfig: h
          } = n,
          p = this.client.proposal.get(a)
        this.client.core.eventClient.deleteEvent({ eventId: o.eventId })
        const { pairingTopic: y, proposer: m, requiredNamespaces: b, optionalNamespaces: I } = p
        let x = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({ topic: y })
        x ||
          (x =
            (i = this.client.core.eventClient) == null
              ? void 0
              : i.createEvent({
                  type: gi.session_approve_started,
                  properties: {
                    topic: y,
                    trace: [gi.session_approve_started, gi.session_namespaces_validation_success]
                  }
                }))
        const _ = await this.client.core.crypto.generateKeyPair(),
          R = m.publicKey,
          N = await this.client.core.crypto.generateSharedKey(_, R),
          T = fn(
            fn(
              fn(
                {
                  relay: { protocol: c ?? 'irn' },
                  namespaces: u,
                  controller: { publicKey: _, metadata: this.client.metadata },
                  expiry: tr(zu)
                },
                l && { sessionProperties: l }
              ),
              d && { scopedProperties: d }
            ),
            h && { sessionConfig: h }
          ),
          M = Sn.relay
        x.addTrace(gi.subscribing_session_topic)
        try {
          await this.client.core.relayer.subscribe(N, { transportType: M })
        } catch (B) {
          throw (x.setError(wc.subscribe_session_topic_failure), B)
        }
        x.addTrace(gi.subscribe_session_topic_success)
        const H = es(fn({}, T), {
          topic: N,
          requiredNamespaces: b,
          optionalNamespaces: I,
          pairingTopic: y,
          acknowledged: !1,
          self: T.controller,
          peer: { publicKey: m.publicKey, metadata: m.metadata },
          controller: _,
          transportType: Sn.relay
        })
        await this.client.session.set(N, H), x.addTrace(gi.store_session)
        try {
          x.addTrace(gi.publishing_session_settle),
            await this.sendRequest({
              topic: N,
              method: 'wc_sessionSettle',
              params: T,
              throwOnFailedPublish: !0
            }).catch(B => {
              throw (x == null || x.setError(wc.session_settle_publish_failure), B)
            }),
            x.addTrace(gi.session_settle_publish_success),
            x.addTrace(gi.publishing_session_approve),
            await this.sendResult({
              id: a,
              topic: y,
              result: { relay: { protocol: c ?? 'irn' }, responderPublicKey: _ },
              throwOnFailedPublish: !0
            }).catch(B => {
              throw (x == null || x.setError(wc.session_approve_publish_failure), B)
            }),
            x.addTrace(gi.session_approve_publish_success)
        } catch (B) {
          throw (
            (this.client.logger.error(B),
            this.client.session.delete(N, an('USER_DISCONNECTED')),
            await this.client.core.relayer.unsubscribe(N),
            B)
          )
        }
        return (
          this.client.core.eventClient.deleteEvent({ eventId: x.eventId }),
          await this.client.core.pairing.updateMetadata({ topic: y, metadata: m.metadata }),
          await this.client.proposal.delete(a, an('USER_DISCONNECTED')),
          await this.client.core.pairing.activate({ topic: y }),
          await this.setExpiry(N, tr(zu)),
          { topic: N, acknowledged: () => Promise.resolve(this.client.session.get(N)) }
        )
      }),
      Ie(this, 'reject', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow()
        try {
          await this.isValidReject(n)
        } catch (o) {
          throw (this.client.logger.error('reject() -> isValidReject() failed'), o)
        }
        const { id: r, reason: s } = n
        let i
        try {
          i = this.client.proposal.get(r).pairingTopic
        } catch (o) {
          throw (this.client.logger.error(`reject() -> proposal.get(${r}) failed`), o)
        }
        i &&
          (await this.sendError({
            id: r,
            topic: i,
            error: s,
            rpcOpts: cr.wc_sessionPropose.reject
          }),
          await this.client.proposal.delete(r, an('USER_DISCONNECTED')))
      }),
      Ie(this, 'update', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow()
        try {
          await this.isValidUpdate(n)
        } catch (d) {
          throw (this.client.logger.error('update() -> isValidUpdate() failed'), d)
        }
        const { topic: r, namespaces: s } = n,
          { done: i, resolve: o, reject: a } = Ic(),
          c = Wi(),
          u = $c().toString(),
          l = this.client.session.get(r).namespaces
        return (
          this.events.once(en('session_update', c), ({ error: d }) => {
            d ? a(d) : o()
          }),
          await this.client.session.update(r, { namespaces: s }),
          await this.sendRequest({
            topic: r,
            method: 'wc_sessionUpdate',
            params: { namespaces: s },
            throwOnFailedPublish: !0,
            clientRpcId: c,
            relayRpcId: u
          }).catch(d => {
            this.client.logger.error(d), this.client.session.update(r, { namespaces: l }), a(d)
          }),
          { acknowledged: i }
        )
      }),
      Ie(this, 'extend', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow()
        try {
          await this.isValidExtend(n)
        } catch (c) {
          throw (this.client.logger.error('extend() -> isValidExtend() failed'), c)
        }
        const { topic: r } = n,
          s = Wi(),
          { done: i, resolve: o, reject: a } = Ic()
        return (
          this.events.once(en('session_extend', s), ({ error: c }) => {
            c ? a(c) : o()
          }),
          await this.setExpiry(r, tr(zu)),
          this.sendRequest({
            topic: r,
            method: 'wc_sessionExtend',
            params: {},
            clientRpcId: s,
            throwOnFailedPublish: !0
          }).catch(c => {
            a(c)
          }),
          { acknowledged: i }
        )
      }),
      Ie(this, 'request', async n => {
        this.isInitialized()
        try {
          await this.isValidRequest(n)
        } catch (I) {
          throw (this.client.logger.error('request() -> isValidRequest() failed'), I)
        }
        const { chainId: r, request: s, topic: i, expiry: o = cr.wc_sessionRequest.req.ttl } = n,
          a = this.client.session.get(i)
        ;(a == null ? void 0 : a.transportType) === Sn.relay &&
          (await this.confirmOnlineStateOrThrow())
        const c = Wi(),
          u = $c().toString(),
          { done: l, resolve: d, reject: h } = Ic(o, 'Request expired. Please try again.')
        this.events.once(en('session_request', c), ({ error: I, result: x }) => {
          I ? h(I) : d(x)
        })
        const p = 'wc_sessionRequest',
          y = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType)
        if (y)
          return (
            await this.sendRequest({
              clientRpcId: c,
              relayRpcId: u,
              topic: i,
              method: p,
              params: { request: es(fn({}, s), { expiryTimestamp: tr(o) }), chainId: r },
              expiry: o,
              throwOnFailedPublish: !0,
              appLink: y
            }).catch(I => h(I)),
            this.client.events.emit('session_request_sent', {
              topic: i,
              request: s,
              chainId: r,
              id: c
            }),
            await l()
          )
        const m = { request: es(fn({}, s), { expiryTimestamp: tr(o) }), chainId: r },
          b = this.shouldSetTVF(p, m)
        return await Promise.all([
          new Promise(async I => {
            await this.sendRequest(
              fn(
                {
                  clientRpcId: c,
                  relayRpcId: u,
                  topic: i,
                  method: p,
                  params: m,
                  expiry: o,
                  throwOnFailedPublish: !0
                },
                b && { tvf: this.getTVFParams(c, m) }
              )
            ).catch(x => h(x)),
              this.client.events.emit('session_request_sent', {
                topic: i,
                request: s,
                chainId: r,
                id: c
              }),
              I()
          }),
          new Promise(async I => {
            var x
            if (!((x = a.sessionConfig) != null && x.disableDeepLink)) {
              const _ = await $Q(this.client.core.storage, U2)
              await MQ({ id: c, topic: i, wcDeepLink: _ })
            }
            I()
          }),
          l()
        ]).then(I => I[2])
      }),
      Ie(this, 'respond', async n => {
        this.isInitialized(), await this.isValidRespond(n)
        const { topic: r, response: s } = n,
          { id: i } = s,
          o = this.client.session.get(r)
        o.transportType === Sn.relay && (await this.confirmOnlineStateOrThrow())
        const a = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType)
        Ki(s)
          ? await this.sendResult({
              id: i,
              topic: r,
              result: s.result,
              throwOnFailedPublish: !0,
              appLink: a
            })
          : ri(s) && (await this.sendError({ id: i, topic: r, error: s.error, appLink: a })),
          this.cleanupAfterResponse(n)
      }),
      Ie(this, 'ping', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow()
        try {
          await this.isValidPing(n)
        } catch (s) {
          throw (this.client.logger.error('ping() -> isValidPing() failed'), s)
        }
        const { topic: r } = n
        if (this.client.session.keys.includes(r)) {
          const s = Wi(),
            i = $c().toString(),
            { done: o, resolve: a, reject: c } = Ic()
          this.events.once(en('session_ping', s), ({ error: u }) => {
            u ? c(u) : a()
          }),
            await Promise.all([
              this.sendRequest({
                topic: r,
                method: 'wc_sessionPing',
                params: {},
                throwOnFailedPublish: !0,
                clientRpcId: s,
                relayRpcId: i
              }),
              o()
            ])
        } else
          this.client.core.pairing.pairings.keys.includes(r) &&
            (this.client.logger.warn(
              'ping() on pairing topic is deprecated and will be removed in the next major release.'
            ),
            await this.client.core.pairing.ping({ topic: r }))
      }),
      Ie(this, 'emit', async n => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(n)
        const { topic: r, event: s, chainId: i } = n,
          o = $c().toString(),
          a = Wi()
        await this.sendRequest({
          topic: r,
          method: 'wc_sessionEvent',
          params: { event: s, chainId: i },
          throwOnFailedPublish: !0,
          relayRpcId: o,
          clientRpcId: a
        })
      }),
      Ie(this, 'disconnect', async n => {
        this.isInitialized(),
          await this.confirmOnlineStateOrThrow(),
          await this.isValidDisconnect(n)
        const { topic: r } = n
        if (this.client.session.keys.includes(r))
          await this.sendRequest({
            topic: r,
            method: 'wc_sessionDelete',
            params: an('USER_DISCONNECTED'),
            throwOnFailedPublish: !0
          }),
            await this.deleteSession({ topic: r, emitEvent: !1 })
        else if (this.client.core.pairing.pairings.keys.includes(r))
          await this.client.core.pairing.disconnect({ topic: r })
        else {
          const { message: s } = Le('MISMATCHED_TOPIC', `Session or pairing topic not found: ${r}`)
          throw new Error(s)
        }
      }),
      Ie(
        this,
        'find',
        n => (this.isInitialized(), this.client.session.getAll().filter(r => EJ(r, n)))
      ),
      Ie(this, 'getPendingSessionRequests', () => this.client.pendingRequest.getAll()),
      Ie(this, 'authenticate', async (n, r) => {
        var s
        this.isInitialized(), this.isValidAuthenticate(n)
        const i =
            r &&
            this.client.core.linkModeSupportedApps.includes(r) &&
            ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode),
          o = i ? Sn.link_mode : Sn.relay
        o === Sn.relay && (await this.confirmOnlineStateOrThrow())
        const {
            chains: a,
            statement: c = '',
            uri: u,
            domain: l,
            nonce: d,
            type: h,
            exp: p,
            nbf: y,
            methods: m = [],
            expiry: b
          } = n,
          I = [...(n.resources || [])],
          { topic: x, uri: _ } = await this.client.core.pairing.create({
            methods: ['wc_sessionAuthenticate'],
            transportType: o
          })
        this.client.logger.info({ message: 'Generated new pairing', pairing: { topic: x, uri: _ } })
        const R = await this.client.core.crypto.generateKeyPair(),
          N = Mg(R)
        if (
          (await Promise.all([
            this.client.auth.authKeys.set(Lg, { responseTopic: N, publicKey: R }),
            this.client.auth.pairingTopics.set(N, { topic: N, pairingTopic: x })
          ]),
          await this.client.core.relayer.subscribe(N, { transportType: o }),
          this.client.logger.info(`sending request to new pairing topic: ${x}`),
          m.length > 0)
        ) {
          const { namespace: F } = Rl(a[0])
          let z = RZ(F, 'request', m)
          Dg(I) && (z = OZ(z, I.pop())), I.push(z)
        }
        const T =
            b && b > cr.wc_sessionAuthenticate.req.ttl ? b : cr.wc_sessionAuthenticate.req.ttl,
          M = {
            authPayload: {
              type: h ?? 'caip122',
              chains: a,
              statement: c,
              aud: u,
              domain: l,
              version: '1',
              nonce: d,
              iat: new Date().toISOString(),
              exp: p,
              nbf: y,
              resources: I
            },
            requester: { publicKey: R, metadata: this.client.metadata },
            expiryTimestamp: tr(T)
          },
          H = {
            eip155: {
              chains: a,
              methods: [...new Set(['personal_sign', ...m])],
              events: ['chainChanged', 'accountsChanged']
            }
          },
          B = {
            requiredNamespaces: {},
            optionalNamespaces: H,
            relays: [{ protocol: 'irn' }],
            pairingTopic: x,
            proposer: { publicKey: R, metadata: this.client.metadata },
            expiryTimestamp: tr(cr.wc_sessionPropose.req.ttl),
            id: Wi()
          },
          { done: $, resolve: D, reject: W } = Ic(T, 'Request expired'),
          U = Wi(),
          w = en('session_connect', B.id),
          v = en('session_request', U),
          A = async ({ error: F, session: z }) => {
            this.events.off(v, P), F ? W(F) : z && D({ session: z })
          },
          P = async F => {
            var z, j, E
            if (
              (await this.deletePendingAuthRequest(U, { message: 'fulfilled', code: 0 }), F.error)
            ) {
              const ve = an('WC_METHOD_UNSUPPORTED', 'wc_sessionAuthenticate')
              return F.error.code === ve.code ? void 0 : (this.events.off(w, A), W(F.error.message))
            }
            await this.deleteProposal(B.id), this.events.off(w, A)
            const { cacaos: C, responder: L } = F.result,
              K = [],
              ee = []
            for (const ve of C) {
              ;(await NI({ cacao: ve, projectId: this.client.core.projectId })) ||
                (this.client.logger.error(ve, 'Signature verification failed'),
                W(an('SESSION_SETTLEMENT_FAILED', 'Signature verification failed')))
              const { p: tt } = ve,
                Ge = Dg(tt.resources),
                nt = [av(tt.iss)],
                Z = Am(tt.iss)
              if (Ge) {
                const X = PI(Ge),
                  ie = RI(Ge)
                K.push(...X), nt.push(...ie)
              }
              for (const X of nt) ee.push(`${X}:${Z}`)
            }
            const oe = await this.client.core.crypto.generateSharedKey(R, L.publicKey)
            let fe
            K.length > 0 &&
              ((fe = {
                topic: oe,
                acknowledged: !0,
                self: { publicKey: R, metadata: this.client.metadata },
                peer: L,
                controller: L.publicKey,
                expiry: tr(zu),
                requiredNamespaces: {},
                optionalNamespaces: {},
                relay: { protocol: 'irn' },
                pairingTopic: x,
                namespaces: XI([...new Set(K)], [...new Set(ee)]),
                transportType: o
              }),
              await this.client.core.relayer.subscribe(oe, { transportType: o }),
              await this.client.session.set(oe, fe),
              x &&
                (await this.client.core.pairing.updateMetadata({ topic: x, metadata: L.metadata })),
              (fe = this.client.session.get(oe))),
              (z = this.client.metadata.redirect) != null &&
                z.linkMode &&
                (j = L.metadata.redirect) != null &&
                j.linkMode &&
                (E = L.metadata.redirect) != null &&
                E.universal &&
                r &&
                (this.client.core.addLinkModeSupportedApp(L.metadata.redirect.universal),
                this.client.session.update(oe, { transportType: Sn.link_mode })),
              D({ auths: C, session: fe })
          }
        this.events.once(w, A), this.events.once(v, P)
        let O
        try {
          if (i) {
            const F = Ua('wc_sessionAuthenticate', M, U)
            this.client.core.history.set(x, F)
            const z = await this.client.core.crypto.encode('', F, { type: Ep, encoding: Ta })
            O = cg(r, x, z)
          } else
            await Promise.all([
              this.sendRequest({
                topic: x,
                method: 'wc_sessionAuthenticate',
                params: M,
                expiry: n.expiry,
                throwOnFailedPublish: !0,
                clientRpcId: U
              }),
              this.sendRequest({
                topic: x,
                method: 'wc_sessionPropose',
                params: B,
                expiry: cr.wc_sessionPropose.req.ttl,
                throwOnFailedPublish: !0,
                clientRpcId: B.id
              })
            ])
        } catch (F) {
          throw (this.events.off(w, A), this.events.off(v, P), F)
        }
        return (
          await this.setProposal(B.id, B),
          await this.setAuthRequest(U, {
            request: es(fn({}, M), { verifyContext: {} }),
            pairingTopic: x,
            transportType: o
          }),
          { uri: O ?? _, response: $ }
        )
      }),
      Ie(this, 'approveSessionAuthenticate', async n => {
        const { id: r, auths: s } = n,
          i = this.client.core.eventClient.createEvent({
            properties: { topic: r.toString(), trace: [bc.authenticated_session_approve_started] }
          })
        try {
          this.isInitialized()
        } catch (b) {
          throw (i.setError(eh.no_internet_connection), b)
        }
        const o = this.getPendingAuthRequest(r)
        if (!o)
          throw (
            (i.setError(eh.authenticated_session_pending_request_not_found),
            new Error(`Could not find pending auth request with id ${r}`))
          )
        const a = o.transportType || Sn.relay
        a === Sn.relay && (await this.confirmOnlineStateOrThrow())
        const c = o.requester.publicKey,
          u = await this.client.core.crypto.generateKeyPair(),
          l = Mg(c),
          d = { type: Go, receiverPublicKey: c, senderPublicKey: u },
          h = [],
          p = []
        for (const b of s) {
          if (!(await NI({ cacao: b, projectId: this.client.core.projectId }))) {
            i.setError(eh.invalid_cacao)
            const N = an('SESSION_SETTLEMENT_FAILED', 'Signature verification failed')
            throw (
              (await this.sendError({ id: r, topic: l, error: N, encodeOpts: d }),
              new Error(N.message))
            )
          }
          i.addTrace(bc.cacaos_verified)
          const { p: I } = b,
            x = Dg(I.resources),
            _ = [av(I.iss)],
            R = Am(I.iss)
          if (x) {
            const N = PI(x),
              T = RI(x)
            h.push(...N), _.push(...T)
          }
          for (const N of _) p.push(`${N}:${R}`)
        }
        const y = await this.client.core.crypto.generateSharedKey(u, c)
        i.addTrace(bc.create_authenticated_session_topic)
        let m
        if ((h == null ? void 0 : h.length) > 0) {
          ;(m = {
            topic: y,
            acknowledged: !0,
            self: { publicKey: u, metadata: this.client.metadata },
            peer: { publicKey: c, metadata: o.requester.metadata },
            controller: c,
            expiry: tr(zu),
            authentication: s,
            requiredNamespaces: {},
            optionalNamespaces: {},
            relay: { protocol: 'irn' },
            pairingTopic: o.pairingTopic,
            namespaces: XI([...new Set(h)], [...new Set(p)]),
            transportType: a
          }),
            i.addTrace(bc.subscribing_authenticated_session_topic)
          try {
            await this.client.core.relayer.subscribe(y, { transportType: a })
          } catch (b) {
            throw (i.setError(eh.subscribe_authenticated_session_topic_failure), b)
          }
          i.addTrace(bc.subscribe_authenticated_session_topic_success),
            await this.client.session.set(y, m),
            i.addTrace(bc.store_authenticated_session),
            await this.client.core.pairing.updateMetadata({
              topic: o.pairingTopic,
              metadata: o.requester.metadata
            })
        }
        i.addTrace(bc.publishing_authenticated_session_approve)
        try {
          await this.sendResult({
            topic: l,
            id: r,
            result: { cacaos: s, responder: { publicKey: u, metadata: this.client.metadata } },
            encodeOpts: d,
            throwOnFailedPublish: !0,
            appLink: this.getAppLinkIfEnabled(o.requester.metadata, a)
          })
        } catch (b) {
          throw (i.setError(eh.authenticated_session_approve_publish_failure), b)
        }
        return (
          await this.client.auth.requests.delete(r, { message: 'fulfilled', code: 0 }),
          await this.client.core.pairing.activate({ topic: o.pairingTopic }),
          this.client.core.eventClient.deleteEvent({ eventId: i.eventId }),
          { session: m }
        )
      }),
      Ie(this, 'rejectSessionAuthenticate', async n => {
        this.isInitialized()
        const { id: r, reason: s } = n,
          i = this.getPendingAuthRequest(r)
        if (!i) throw new Error(`Could not find pending auth request with id ${r}`)
        i.transportType === Sn.relay && (await this.confirmOnlineStateOrThrow())
        const o = i.requester.publicKey,
          a = await this.client.core.crypto.generateKeyPair(),
          c = Mg(o),
          u = { type: Go, receiverPublicKey: o, senderPublicKey: a }
        await this.sendError({
          id: r,
          topic: c,
          error: s,
          encodeOpts: u,
          rpcOpts: cr.wc_sessionAuthenticate.reject,
          appLink: this.getAppLinkIfEnabled(i.requester.metadata, i.transportType)
        }),
          await this.client.auth.requests.delete(r, { message: 'rejected', code: 0 }),
          await this.client.proposal.delete(r, an('USER_DISCONNECTED'))
      }),
      Ie(this, 'formatAuthMessage', n => {
        this.isInitialized()
        const { request: r, iss: s } = n
        return lO(r, s)
      }),
      Ie(this, 'processRelayMessageCache', () => {
        setTimeout(async () => {
          if (this.relayMessageCache.length !== 0)
            for (; this.relayMessageCache.length > 0; )
              try {
                const n = this.relayMessageCache.shift()
                n && (await this.onRelayMessage(n))
              } catch (n) {
                this.client.logger.error(n)
              }
        }, 50)
      }),
      Ie(this, 'cleanupDuplicatePairings', async n => {
        if (n.pairingTopic)
          try {
            const r = this.client.core.pairing.pairings.get(n.pairingTopic),
              s = this.client.core.pairing.pairings.getAll().filter(i => {
                var o, a
                return (
                  ((o = i.peerMetadata) == null ? void 0 : o.url) &&
                  ((a = i.peerMetadata) == null ? void 0 : a.url) === n.peer.metadata.url &&
                  i.topic &&
                  i.topic !== r.topic
                )
              })
            if (s.length === 0) return
            this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),
              await Promise.all(
                s.map(i => this.client.core.pairing.disconnect({ topic: i.topic }))
              ),
              this.client.logger.info('Duplicate pairings clean up finished')
          } catch (r) {
            this.client.logger.error(r)
          }
      }),
      Ie(this, 'deleteSession', async n => {
        var r
        const { topic: s, expirerHasDeleted: i = !1, emitEvent: o = !0, id: a = 0 } = n,
          { self: c } = this.client.session.get(s)
        await this.client.core.relayer.unsubscribe(s),
          await this.client.session.delete(s, an('USER_DISCONNECTED')),
          this.addToRecentlyDeleted(s, 'session'),
          this.client.core.crypto.keychain.has(c.publicKey) &&
            (await this.client.core.crypto.deleteKeyPair(c.publicKey)),
          this.client.core.crypto.keychain.has(s) &&
            (await this.client.core.crypto.deleteSymKey(s)),
          i || this.client.core.expirer.del(s),
          this.client.core.storage.removeItem(U2).catch(u => this.client.logger.warn(u)),
          this.getPendingSessionRequests().forEach(u => {
            u.topic === s && this.deletePendingSessionRequest(u.id, an('USER_DISCONNECTED'))
          }),
          s === ((r = this.sessionRequestQueue.queue[0]) == null ? void 0 : r.topic) &&
            (this.sessionRequestQueue.state = ji.idle),
          o && this.client.events.emit('session_delete', { id: a, topic: s })
      }),
      Ie(this, 'deleteProposal', async (n, r) => {
        if (r)
          try {
            const s = this.client.proposal.get(n),
              i = this.client.core.eventClient.getEvent({ topic: s.pairingTopic })
            i == null || i.setError(wc.proposal_expired)
          } catch {}
        await Promise.all([
          this.client.proposal.delete(n, an('USER_DISCONNECTED')),
          r ? Promise.resolve() : this.client.core.expirer.del(n)
        ]),
          this.addToRecentlyDeleted(n, 'proposal')
      }),
      Ie(this, 'deletePendingSessionRequest', async (n, r, s = !1) => {
        await Promise.all([
          this.client.pendingRequest.delete(n, r),
          s ? Promise.resolve() : this.client.core.expirer.del(n)
        ]),
          this.addToRecentlyDeleted(n, 'request'),
          (this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(i => i.id !== n)),
          s &&
            ((this.sessionRequestQueue.state = ji.idle),
            this.client.events.emit('session_request_expire', { id: n }))
      }),
      Ie(this, 'deletePendingAuthRequest', async (n, r, s = !1) => {
        await Promise.all([
          this.client.auth.requests.delete(n, r),
          s ? Promise.resolve() : this.client.core.expirer.del(n)
        ])
      }),
      Ie(this, 'setExpiry', async (n, r) => {
        this.client.session.keys.includes(n) &&
          (this.client.core.expirer.set(n, r), await this.client.session.update(n, { expiry: r }))
      }),
      Ie(this, 'setProposal', async (n, r) => {
        this.client.core.expirer.set(n, tr(cr.wc_sessionPropose.req.ttl)),
          await this.client.proposal.set(n, r)
      }),
      Ie(this, 'setAuthRequest', async (n, r) => {
        const { request: s, pairingTopic: i, transportType: o = Sn.relay } = r
        this.client.core.expirer.set(n, s.expiryTimestamp),
          await this.client.auth.requests.set(n, {
            authPayload: s.authPayload,
            requester: s.requester,
            expiryTimestamp: s.expiryTimestamp,
            id: n,
            pairingTopic: i,
            verifyContext: s.verifyContext,
            transportType: o
          })
      }),
      Ie(this, 'setPendingSessionRequest', async n => {
        const { id: r, topic: s, params: i, verifyContext: o } = n,
          a = i.request.expiryTimestamp || tr(cr.wc_sessionRequest.req.ttl)
        this.client.core.expirer.set(r, a),
          await this.client.pendingRequest.set(r, { id: r, topic: s, params: i, verifyContext: o })
      }),
      Ie(this, 'sendRequest', async n => {
        const {
            topic: r,
            method: s,
            params: i,
            expiry: o,
            relayRpcId: a,
            clientRpcId: c,
            throwOnFailedPublish: u,
            appLink: l,
            tvf: d
          } = n,
          h = Ua(s, i, c)
        let p
        const y = !!l
        try {
          const I = y ? Ta : Ii
          p = await this.client.core.crypto.encode(r, h, { encoding: I })
        } catch (I) {
          throw (
            (await this.cleanup(),
            this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${r} failed`),
            I)
          )
        }
        let m
        if (ore.includes(s)) {
          const I = Ji(JSON.stringify(h)),
            x = Ji(p)
          m = await this.client.core.verify.register({ id: x, decryptedId: I })
        }
        const b = cr[s].req
        if (
          ((b.attestation = m),
          o && (b.ttl = o),
          a && (b.id = a),
          this.client.core.history.set(r, h),
          y)
        ) {
          const I = cg(l, r, p)
          await globalThis.Linking.openURL(I, this.client.name)
        } else {
          const I = cr[s].req
          o && (I.ttl = o),
            a && (I.id = a),
            (I.tvf = es(fn({}, d), { correlationId: h.id })),
            u
              ? ((I.internal = es(fn({}, I.internal), { throwOnFailedPublish: !0 })),
                await this.client.core.relayer.publish(r, p, I))
              : this.client.core.relayer.publish(r, p, I).catch(x => this.client.logger.error(x))
        }
        return h.id
      }),
      Ie(this, 'sendResult', async n => {
        const {
            id: r,
            topic: s,
            result: i,
            throwOnFailedPublish: o,
            encodeOpts: a,
            appLink: c
          } = n,
          u = H0(r, i)
        let l
        const d = c && typeof (global == null ? void 0 : global.Linking) < 'u'
        try {
          const y = d ? Ta : Ii
          l = await this.client.core.crypto.encode(s, u, es(fn({}, a || {}), { encoding: y }))
        } catch (y) {
          throw (
            (await this.cleanup(),
            this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),
            y)
          )
        }
        let h, p
        try {
          h = await this.client.core.history.get(s, r)
          const y = h.request
          try {
            this.shouldSetTVF(y.method, y.params) && (p = this.getTVFParams(r, y.params, i))
          } catch (m) {
            this.client.logger.warn('sendResult() -> getTVFParams() failed', m)
          }
        } catch (y) {
          throw (this.client.logger.error(`sendResult() -> history.get(${s}, ${r}) failed`), y)
        }
        if (d) {
          const y = cg(c, s, l)
          await globalThis.Linking.openURL(y, this.client.name)
        } else {
          const y = h.request.method,
            m = cr[y].res
          ;(m.tvf = es(fn({}, p), { correlationId: r })),
            o
              ? ((m.internal = es(fn({}, m.internal), { throwOnFailedPublish: !0 })),
                await this.client.core.relayer.publish(s, l, m))
              : this.client.core.relayer.publish(s, l, m).catch(b => this.client.logger.error(b))
        }
        await this.client.core.history.resolve(u)
      }),
      Ie(this, 'sendError', async n => {
        const { id: r, topic: s, error: i, encodeOpts: o, rpcOpts: a, appLink: c } = n,
          u = q0(r, i)
        let l
        const d = c && typeof (global == null ? void 0 : global.Linking) < 'u'
        try {
          const p = d ? Ta : Ii
          l = await this.client.core.crypto.encode(s, u, es(fn({}, o || {}), { encoding: p }))
        } catch (p) {
          throw (
            (await this.cleanup(),
            this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),
            p)
          )
        }
        let h
        try {
          h = await this.client.core.history.get(s, r)
        } catch (p) {
          throw (this.client.logger.error(`sendError() -> history.get(${s}, ${r}) failed`), p)
        }
        if (d) {
          const p = cg(c, s, l)
          await globalThis.Linking.openURL(p, this.client.name)
        } else {
          const p = h.request.method,
            y = a || cr[p].res
          this.client.core.relayer.publish(s, l, y)
        }
        await this.client.core.history.resolve(u)
      }),
      Ie(this, 'cleanup', async () => {
        const n = [],
          r = []
        this.client.session.getAll().forEach(s => {
          let i = !1
          Ca(s.expiry) && (i = !0),
            this.client.core.crypto.keychain.has(s.topic) || (i = !0),
            i && n.push(s.topic)
        }),
          this.client.proposal.getAll().forEach(s => {
            Ca(s.expiryTimestamp) && r.push(s.id)
          }),
          await Promise.all([
            ...n.map(s => this.deleteSession({ topic: s })),
            ...r.map(s => this.deleteProposal(s))
          ])
      }),
      Ie(this, 'onProviderMessageEvent', async n => {
        !this.initialized || this.relayMessageCache.length > 0
          ? this.relayMessageCache.push(n)
          : await this.onRelayMessage(n)
      }),
      Ie(this, 'onRelayEventRequest', async n => {
        this.requestQueue.queue.push(n), await this.processRequestsQueue()
      }),
      Ie(this, 'processRequestsQueue', async () => {
        if (this.requestQueue.state === ji.active) {
          this.client.logger.info('Request queue already active, skipping...')
          return
        }
        for (
          this.client.logger.info(
            `Request queue starting with ${this.requestQueue.queue.length} requests`
          );
          this.requestQueue.queue.length > 0;

        ) {
          this.requestQueue.state = ji.active
          const n = this.requestQueue.queue.shift()
          if (n)
            try {
              await this.processRequest(n)
            } catch (r) {
              this.client.logger.warn(r)
            }
        }
        this.requestQueue.state = ji.idle
      }),
      Ie(this, 'processRequest', async n => {
        const { topic: r, payload: s, attestation: i, transportType: o, encryptedId: a } = n,
          c = s.method
        if (!this.shouldIgnorePairingRequest({ topic: r, requestMethod: c }))
          switch (c) {
            case 'wc_sessionPropose':
              return await this.onSessionProposeRequest({
                topic: r,
                payload: s,
                attestation: i,
                encryptedId: a
              })
            case 'wc_sessionSettle':
              return await this.onSessionSettleRequest(r, s)
            case 'wc_sessionUpdate':
              return await this.onSessionUpdateRequest(r, s)
            case 'wc_sessionExtend':
              return await this.onSessionExtendRequest(r, s)
            case 'wc_sessionPing':
              return await this.onSessionPingRequest(r, s)
            case 'wc_sessionDelete':
              return await this.onSessionDeleteRequest(r, s)
            case 'wc_sessionRequest':
              return await this.onSessionRequest({
                topic: r,
                payload: s,
                attestation: i,
                encryptedId: a,
                transportType: o
              })
            case 'wc_sessionEvent':
              return await this.onSessionEventRequest(r, s)
            case 'wc_sessionAuthenticate':
              return await this.onSessionAuthenticateRequest({
                topic: r,
                payload: s,
                attestation: i,
                encryptedId: a,
                transportType: o
              })
            default:
              return this.client.logger.info(`Unsupported request method ${c}`)
          }
      }),
      Ie(this, 'onRelayEventResponse', async n => {
        const { topic: r, payload: s, transportType: i } = n,
          o = (await this.client.core.history.get(r, s.id)).request.method
        switch (o) {
          case 'wc_sessionPropose':
            return this.onSessionProposeResponse(r, s, i)
          case 'wc_sessionSettle':
            return this.onSessionSettleResponse(r, s)
          case 'wc_sessionUpdate':
            return this.onSessionUpdateResponse(r, s)
          case 'wc_sessionExtend':
            return this.onSessionExtendResponse(r, s)
          case 'wc_sessionPing':
            return this.onSessionPingResponse(r, s)
          case 'wc_sessionRequest':
            return this.onSessionRequestResponse(r, s)
          case 'wc_sessionAuthenticate':
            return this.onSessionAuthenticateResponse(r, s)
          default:
            return this.client.logger.info(`Unsupported response method ${o}`)
        }
      }),
      Ie(this, 'onRelayEventUnknownPayload', n => {
        const { topic: r } = n,
          { message: s } = Le(
            'MISSING_OR_INVALID',
            `Decoded payload on topic ${r} is not identifiable as a JSON-RPC request or a response.`
          )
        throw new Error(s)
      }),
      Ie(this, 'shouldIgnorePairingRequest', n => {
        const { topic: r, requestMethod: s } = n,
          i = this.expectedPairingMethodMap.get(r)
        return !i || i.includes(s)
          ? !1
          : !!(
              i.includes('wc_sessionAuthenticate') &&
              this.client.events.listenerCount('session_authenticate') > 0
            )
      }),
      Ie(this, 'onSessionProposeRequest', async n => {
        const { topic: r, payload: s, attestation: i, encryptedId: o } = n,
          { params: a, id: c } = s
        try {
          const u = this.client.core.eventClient.getEvent({ topic: r })
          this.client.events.listenerCount('session_proposal') === 0 &&
            (console.warn('No listener for session_proposal event'),
            u == null || u.setError(Do.proposal_listener_not_found)),
            this.isValidConnect(fn({}, s.params))
          const l = a.expiryTimestamp || tr(cr.wc_sessionPropose.req.ttl),
            d = fn({ id: c, pairingTopic: r, expiryTimestamp: l }, a)
          await this.setProposal(c, d)
          const h = await this.getVerifyContext({
            attestationId: i,
            hash: Ji(JSON.stringify(s)),
            encryptedId: o,
            metadata: d.proposer.metadata
          })
          u == null || u.addTrace(qi.emit_session_proposal),
            this.client.events.emit('session_proposal', { id: c, params: d, verifyContext: h })
        } catch (u) {
          await this.sendError({
            id: c,
            topic: r,
            error: u,
            rpcOpts: cr.wc_sessionPropose.autoReject
          }),
            this.client.logger.error(u)
        }
      }),
      Ie(this, 'onSessionProposeResponse', async (n, r, s) => {
        const { id: i } = r
        if (Ki(r)) {
          const { result: o } = r
          this.client.logger.trace({
            type: 'method',
            method: 'onSessionProposeResponse',
            result: o
          })
          const a = this.client.proposal.get(i)
          this.client.logger.trace({
            type: 'method',
            method: 'onSessionProposeResponse',
            proposal: a
          })
          const c = a.proposer.publicKey
          this.client.logger.trace({
            type: 'method',
            method: 'onSessionProposeResponse',
            selfPublicKey: c
          })
          const u = o.responderPublicKey
          this.client.logger.trace({
            type: 'method',
            method: 'onSessionProposeResponse',
            peerPublicKey: u
          })
          const l = await this.client.core.crypto.generateSharedKey(c, u)
          this.pendingSessions.set(i, {
            sessionTopic: l,
            pairingTopic: n,
            proposalId: i,
            publicKey: c
          })
          const d = await this.client.core.relayer.subscribe(l, { transportType: s })
          this.client.logger.trace({
            type: 'method',
            method: 'onSessionProposeResponse',
            subscriptionId: d
          }),
            await this.client.core.pairing.activate({ topic: n })
        } else if (ri(r)) {
          await this.client.proposal.delete(i, an('USER_DISCONNECTED'))
          const o = en('session_connect', i)
          if (this.events.listenerCount(o) === 0)
            throw new Error(`emitting ${o} without any listeners, 954`)
          this.events.emit(o, { error: r.error })
        }
      }),
      Ie(this, 'onSessionSettleRequest', async (n, r) => {
        const { id: s, params: i } = r
        try {
          this.isValidSessionSettleRequest(i)
          const {
              relay: o,
              controller: a,
              expiry: c,
              namespaces: u,
              sessionProperties: l,
              scopedProperties: d,
              sessionConfig: h
            } = r.params,
            p = [...this.pendingSessions.values()].find(b => b.sessionTopic === n)
          if (!p) return this.client.logger.error(`Pending session not found for topic ${n}`)
          const y = this.client.proposal.get(p.proposalId),
            m = es(
              fn(
                fn(
                  fn(
                    {
                      topic: n,
                      relay: o,
                      expiry: c,
                      namespaces: u,
                      acknowledged: !0,
                      pairingTopic: p.pairingTopic,
                      requiredNamespaces: y.requiredNamespaces,
                      optionalNamespaces: y.optionalNamespaces,
                      controller: a.publicKey,
                      self: { publicKey: p.publicKey, metadata: this.client.metadata },
                      peer: { publicKey: a.publicKey, metadata: a.metadata }
                    },
                    l && { sessionProperties: l }
                  ),
                  d && { scopedProperties: d }
                ),
                h && { sessionConfig: h }
              ),
              { transportType: Sn.relay }
            )
          await this.client.session.set(m.topic, m),
            await this.setExpiry(m.topic, m.expiry),
            await this.client.core.pairing.updateMetadata({
              topic: p.pairingTopic,
              metadata: m.peer.metadata
            }),
            this.client.events.emit('session_connect', { session: m }),
            this.events.emit(en('session_connect', p.proposalId), { session: m }),
            this.pendingSessions.delete(p.proposalId),
            this.deleteProposal(p.proposalId, !1),
            this.cleanupDuplicatePairings(m),
            await this.sendResult({ id: r.id, topic: n, result: !0, throwOnFailedPublish: !0 })
        } catch (o) {
          await this.sendError({ id: s, topic: n, error: o }), this.client.logger.error(o)
        }
      }),
      Ie(this, 'onSessionSettleResponse', async (n, r) => {
        const { id: s } = r
        Ki(r)
          ? (await this.client.session.update(n, { acknowledged: !0 }),
            this.events.emit(en('session_approve', s), {}))
          : ri(r) &&
            (await this.client.session.delete(n, an('USER_DISCONNECTED')),
            this.events.emit(en('session_approve', s), { error: r.error }))
      }),
      Ie(this, 'onSessionUpdateRequest', async (n, r) => {
        const { params: s, id: i } = r
        try {
          const o = `${n}_session_update`,
            a = Jd.get(o)
          if (a && this.isRequestOutOfSync(a, i)) {
            this.client.logger.warn(`Discarding out of sync request - ${i}`),
              this.sendError({ id: i, topic: n, error: an('INVALID_UPDATE_REQUEST') })
            return
          }
          this.isValidUpdate(fn({ topic: n }, s))
          try {
            Jd.set(o, i),
              await this.client.session.update(n, { namespaces: s.namespaces }),
              await this.sendResult({ id: i, topic: n, result: !0, throwOnFailedPublish: !0 })
          } catch (c) {
            throw (Jd.delete(o), c)
          }
          this.client.events.emit('session_update', { id: i, topic: n, params: s })
        } catch (o) {
          await this.sendError({ id: i, topic: n, error: o }), this.client.logger.error(o)
        }
      }),
      Ie(
        this,
        'isRequestOutOfSync',
        (n, r) => r.toString().slice(0, -3) < n.toString().slice(0, -3)
      ),
      Ie(this, 'onSessionUpdateResponse', (n, r) => {
        const { id: s } = r,
          i = en('session_update', s)
        if (this.events.listenerCount(i) === 0)
          throw new Error(`emitting ${i} without any listeners`)
        Ki(r)
          ? this.events.emit(en('session_update', s), {})
          : ri(r) && this.events.emit(en('session_update', s), { error: r.error })
      }),
      Ie(this, 'onSessionExtendRequest', async (n, r) => {
        const { id: s } = r
        try {
          this.isValidExtend({ topic: n }),
            await this.setExpiry(n, tr(zu)),
            await this.sendResult({ id: s, topic: n, result: !0, throwOnFailedPublish: !0 }),
            this.client.events.emit('session_extend', { id: s, topic: n })
        } catch (i) {
          await this.sendError({ id: s, topic: n, error: i }), this.client.logger.error(i)
        }
      }),
      Ie(this, 'onSessionExtendResponse', (n, r) => {
        const { id: s } = r,
          i = en('session_extend', s)
        if (this.events.listenerCount(i) === 0)
          throw new Error(`emitting ${i} without any listeners`)
        Ki(r)
          ? this.events.emit(en('session_extend', s), {})
          : ri(r) && this.events.emit(en('session_extend', s), { error: r.error })
      }),
      Ie(this, 'onSessionPingRequest', async (n, r) => {
        const { id: s } = r
        try {
          this.isValidPing({ topic: n }),
            await this.sendResult({ id: s, topic: n, result: !0, throwOnFailedPublish: !0 }),
            this.client.events.emit('session_ping', { id: s, topic: n })
        } catch (i) {
          await this.sendError({ id: s, topic: n, error: i }), this.client.logger.error(i)
        }
      }),
      Ie(this, 'onSessionPingResponse', (n, r) => {
        const { id: s } = r,
          i = en('session_ping', s)
        setTimeout(() => {
          if (this.events.listenerCount(i) === 0)
            throw new Error(`emitting ${i} without any listeners 2176`)
          Ki(r)
            ? this.events.emit(en('session_ping', s), {})
            : ri(r) && this.events.emit(en('session_ping', s), { error: r.error })
        }, 500)
      }),
      Ie(this, 'onSessionDeleteRequest', async (n, r) => {
        const { id: s } = r
        try {
          this.isValidDisconnect({ topic: n, reason: r.params }),
            Promise.all([
              new Promise(i => {
                this.client.core.relayer.once(hr.publish, async () => {
                  i(await this.deleteSession({ topic: n, id: s }))
                })
              }),
              this.sendResult({ id: s, topic: n, result: !0, throwOnFailedPublish: !0 }),
              this.cleanupPendingSentRequestsForTopic({ topic: n, error: an('USER_DISCONNECTED') })
            ]).catch(i => this.client.logger.error(i))
        } catch (i) {
          this.client.logger.error(i)
        }
      }),
      Ie(this, 'onSessionRequest', async n => {
        var r, s, i
        const { topic: o, payload: a, attestation: c, encryptedId: u, transportType: l } = n,
          { id: d, params: h } = a
        try {
          await this.isValidRequest(fn({ topic: o }, h))
          const p = this.client.session.get(o),
            y = await this.getVerifyContext({
              attestationId: c,
              hash: Ji(JSON.stringify(Ua('wc_sessionRequest', h, d))),
              encryptedId: u,
              metadata: p.peer.metadata,
              transportType: l
            }),
            m = { id: d, topic: o, params: h, verifyContext: y }
          await this.setPendingSessionRequest(m),
            l === Sn.link_mode &&
              (r = p.peer.metadata.redirect) != null &&
              r.universal &&
              this.client.core.addLinkModeSupportedApp(
                (s = p.peer.metadata.redirect) == null ? void 0 : s.universal
              ),
            (i = this.client.signConfig) != null && i.disableRequestQueue
              ? this.emitSessionRequest(m)
              : (this.addSessionRequestToSessionRequestQueue(m), this.processSessionRequestQueue())
        } catch (p) {
          await this.sendError({ id: d, topic: o, error: p }), this.client.logger.error(p)
        }
      }),
      Ie(this, 'onSessionRequestResponse', (n, r) => {
        const { id: s } = r,
          i = en('session_request', s)
        if (this.events.listenerCount(i) === 0)
          throw new Error(`emitting ${i} without any listeners`)
        Ki(r)
          ? this.events.emit(en('session_request', s), { result: r.result })
          : ri(r) && this.events.emit(en('session_request', s), { error: r.error })
      }),
      Ie(this, 'onSessionEventRequest', async (n, r) => {
        const { id: s, params: i } = r
        try {
          const o = `${n}_session_event_${i.event.name}`,
            a = Jd.get(o)
          if (a && this.isRequestOutOfSync(a, s)) {
            this.client.logger.info(`Discarding out of sync request - ${s}`)
            return
          }
          this.isValidEmit(fn({ topic: n }, i)),
            this.client.events.emit('session_event', { id: s, topic: n, params: i }),
            Jd.set(o, s)
        } catch (o) {
          await this.sendError({ id: s, topic: n, error: o }), this.client.logger.error(o)
        }
      }),
      Ie(this, 'onSessionAuthenticateResponse', (n, r) => {
        const { id: s } = r
        this.client.logger.trace({
          type: 'method',
          method: 'onSessionAuthenticateResponse',
          topic: n,
          payload: r
        }),
          Ki(r)
            ? this.events.emit(en('session_request', s), { result: r.result })
            : ri(r) && this.events.emit(en('session_request', s), { error: r.error })
      }),
      Ie(this, 'onSessionAuthenticateRequest', async n => {
        var r
        const { topic: s, payload: i, attestation: o, encryptedId: a, transportType: c } = n
        try {
          const { requester: u, authPayload: l, expiryTimestamp: d } = i.params,
            h = await this.getVerifyContext({
              attestationId: o,
              hash: Ji(JSON.stringify(i)),
              encryptedId: a,
              metadata: u.metadata,
              transportType: c
            }),
            p = {
              requester: u,
              pairingTopic: s,
              id: i.id,
              authPayload: l,
              verifyContext: h,
              expiryTimestamp: d
            }
          await this.setAuthRequest(i.id, { request: p, pairingTopic: s, transportType: c }),
            c === Sn.link_mode &&
              (r = u.metadata.redirect) != null &&
              r.universal &&
              this.client.core.addLinkModeSupportedApp(u.metadata.redirect.universal),
            this.client.events.emit('session_authenticate', {
              topic: s,
              params: i.params,
              id: i.id,
              verifyContext: h
            })
        } catch (u) {
          this.client.logger.error(u)
          const l = i.params.requester.publicKey,
            d = await this.client.core.crypto.generateKeyPair(),
            h = this.getAppLinkIfEnabled(i.params.requester.metadata, c),
            p = { type: Go, receiverPublicKey: l, senderPublicKey: d }
          await this.sendError({
            id: i.id,
            topic: s,
            error: u,
            encodeOpts: p,
            rpcOpts: cr.wc_sessionAuthenticate.autoReject,
            appLink: h
          })
        }
      }),
      Ie(this, 'addSessionRequestToSessionRequestQueue', n => {
        this.sessionRequestQueue.queue.push(n)
      }),
      Ie(this, 'cleanupAfterResponse', n => {
        this.deletePendingSessionRequest(n.response.id, { message: 'fulfilled', code: 0 }),
          setTimeout(() => {
            ;(this.sessionRequestQueue.state = ji.idle), this.processSessionRequestQueue()
          }, Me.toMiliseconds(this.requestQueueDelay))
      }),
      Ie(this, 'cleanupPendingSentRequestsForTopic', ({ topic: n, error: r }) => {
        const s = this.client.core.history.pending
        s.length > 0 &&
          s
            .filter(i => i.topic === n && i.request.method === 'wc_sessionRequest')
            .forEach(i => {
              const o = i.request.id,
                a = en('session_request', o)
              if (this.events.listenerCount(a) === 0)
                throw new Error(`emitting ${a} without any listeners`)
              this.events.emit(en('session_request', i.request.id), { error: r })
            })
      }),
      Ie(this, 'processSessionRequestQueue', () => {
        if (this.sessionRequestQueue.state === ji.active) {
          this.client.logger.info('session request queue is already active.')
          return
        }
        const n = this.sessionRequestQueue.queue[0]
        if (!n) {
          this.client.logger.info('session request queue is empty.')
          return
        }
        try {
          ;(this.sessionRequestQueue.state = ji.active), this.emitSessionRequest(n)
        } catch (r) {
          this.client.logger.error(r)
        }
      }),
      Ie(this, 'emitSessionRequest', n => {
        this.client.events.emit('session_request', n)
      }),
      Ie(this, 'onPairingCreated', n => {
        if ((n.methods && this.expectedPairingMethodMap.set(n.topic, n.methods), n.active)) return
        const r = this.client.proposal.getAll().find(s => s.pairingTopic === n.topic)
        r &&
          this.onSessionProposeRequest({
            topic: n.topic,
            payload: Ua(
              'wc_sessionPropose',
              es(fn({}, r), {
                requiredNamespaces: r.requiredNamespaces,
                optionalNamespaces: r.optionalNamespaces,
                relays: r.relays,
                proposer: r.proposer,
                sessionProperties: r.sessionProperties,
                scopedProperties: r.scopedProperties
              }),
              r.id
            )
          })
      }),
      Ie(this, 'isValidConnect', async n => {
        if (!ws(n)) {
          const { message: u } = Le('MISSING_OR_INVALID', `connect() params: ${JSON.stringify(n)}`)
          throw new Error(u)
        }
        const {
          pairingTopic: r,
          requiredNamespaces: s,
          optionalNamespaces: i,
          sessionProperties: o,
          scopedProperties: a,
          relays: c
        } = n
        if ((xr(r) || (await this.isValidPairingTopic(r)), !OJ(c))) {
          const { message: u } = Le('MISSING_OR_INVALID', `connect() relays: ${c}`)
          throw new Error(u)
        }
        if (
          (!xr(s) && Sf(s) !== 0 && this.validateNamespaces(s, 'requiredNamespaces'),
          !xr(i) && Sf(i) !== 0 && this.validateNamespaces(i, 'optionalNamespaces'),
          xr(o) || this.validateSessionProps(o, 'sessionProperties'),
          !xr(a))
        ) {
          this.validateSessionProps(a, 'scopedProperties')
          const u = Object.keys(s || {}).concat(Object.keys(i || {}))
          if (!Object.keys(a).every(l => u.includes(l)))
            throw new Error(
              `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(a)}, required/optional namespaces: ${JSON.stringify(u)}`
            )
        }
      }),
      Ie(this, 'validateNamespaces', (n, r) => {
        const s = kJ(n, 'connect()', r)
        if (s) throw new Error(s.message)
      }),
      Ie(this, 'isValidApprove', async n => {
        if (!ws(n)) throw new Error(Le('MISSING_OR_INVALID', `approve() params: ${n}`).message)
        const {
          id: r,
          namespaces: s,
          relayProtocol: i,
          sessionProperties: o,
          scopedProperties: a
        } = n
        this.checkRecentlyDeleted(r), await this.isValidProposalId(r)
        const c = this.client.proposal.get(r),
          u = Yw(s, 'approve()')
        if (u) throw new Error(u.message)
        const l = n2(c.requiredNamespaces, s, 'approve()')
        if (l) throw new Error(l.message)
        if (!Yn(i, !0)) {
          const { message: d } = Le('MISSING_OR_INVALID', `approve() relayProtocol: ${i}`)
          throw new Error(d)
        }
        if ((xr(o) || this.validateSessionProps(o, 'sessionProperties'), !xr(a))) {
          this.validateSessionProps(a, 'scopedProperties')
          const d = new Set(Object.keys(s))
          if (!Object.keys(a).every(h => d.has(h)))
            throw new Error(
              `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(a)}, approved namespaces: ${Array.from(d).join(', ')}`
            )
        }
      }),
      Ie(this, 'isValidReject', async n => {
        if (!ws(n)) {
          const { message: i } = Le('MISSING_OR_INVALID', `reject() params: ${n}`)
          throw new Error(i)
        }
        const { id: r, reason: s } = n
        if ((this.checkRecentlyDeleted(r), await this.isValidProposalId(r), !DJ(s))) {
          const { message: i } = Le('MISSING_OR_INVALID', `reject() reason: ${JSON.stringify(s)}`)
          throw new Error(i)
        }
      }),
      Ie(this, 'isValidSessionSettleRequest', n => {
        if (!ws(n)) {
          const { message: u } = Le('MISSING_OR_INVALID', `onSessionSettleRequest() params: ${n}`)
          throw new Error(u)
        }
        const { relay: r, controller: s, namespaces: i, expiry: o } = n
        if (!MO(r)) {
          const { message: u } = Le(
            'MISSING_OR_INVALID',
            'onSessionSettleRequest() relay protocol should be a string'
          )
          throw new Error(u)
        }
        const a = IJ(s, 'onSessionSettleRequest()')
        if (a) throw new Error(a.message)
        const c = Yw(i, 'onSessionSettleRequest()')
        if (c) throw new Error(c.message)
        if (Ca(o)) {
          const { message: u } = Le('EXPIRED', 'onSessionSettleRequest()')
          throw new Error(u)
        }
      }),
      Ie(this, 'isValidUpdate', async n => {
        if (!ws(n)) {
          const { message: c } = Le('MISSING_OR_INVALID', `update() params: ${n}`)
          throw new Error(c)
        }
        const { topic: r, namespaces: s } = n
        this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r)
        const i = this.client.session.get(r),
          o = Yw(s, 'update()')
        if (o) throw new Error(o.message)
        const a = n2(i.requiredNamespaces, s, 'update()')
        if (a) throw new Error(a.message)
      }),
      Ie(this, 'isValidExtend', async n => {
        if (!ws(n)) {
          const { message: s } = Le('MISSING_OR_INVALID', `extend() params: ${n}`)
          throw new Error(s)
        }
        const { topic: r } = n
        this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r)
      }),
      Ie(this, 'isValidRequest', async n => {
        if (!ws(n)) {
          const { message: c } = Le('MISSING_OR_INVALID', `request() params: ${n}`)
          throw new Error(c)
        }
        const { topic: r, request: s, chainId: i, expiry: o } = n
        this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r)
        const { namespaces: a } = this.client.session.get(r)
        if (!t2(a, i)) {
          const { message: c } = Le('MISSING_OR_INVALID', `request() chainId: ${i}`)
          throw new Error(c)
        }
        if (!MJ(s)) {
          const { message: c } = Le('MISSING_OR_INVALID', `request() ${JSON.stringify(s)}`)
          throw new Error(c)
        }
        if (!$J(a, i, s.method)) {
          const { message: c } = Le('MISSING_OR_INVALID', `request() method: ${s.method}`)
          throw new Error(c)
        }
        if (o && !qJ(o, ib)) {
          const { message: c } = Le(
            'MISSING_OR_INVALID',
            `request() expiry: ${o}. Expiry must be a number (in seconds) between ${ib.min} and ${ib.max}`
          )
          throw new Error(c)
        }
      }),
      Ie(this, 'isValidRespond', async n => {
        var r
        if (!ws(n)) {
          const { message: o } = Le('MISSING_OR_INVALID', `respond() params: ${n}`)
          throw new Error(o)
        }
        const { topic: s, response: i } = n
        try {
          await this.isValidSessionTopic(s)
        } catch (o) {
          throw (
            ((r = n == null ? void 0 : n.response) != null && r.id && this.cleanupAfterResponse(n),
            o)
          )
        }
        if (!UJ(i)) {
          const { message: o } = Le(
            'MISSING_OR_INVALID',
            `respond() response: ${JSON.stringify(i)}`
          )
          throw new Error(o)
        }
      }),
      Ie(this, 'isValidPing', async n => {
        if (!ws(n)) {
          const { message: s } = Le('MISSING_OR_INVALID', `ping() params: ${n}`)
          throw new Error(s)
        }
        const { topic: r } = n
        await this.isValidSessionOrPairingTopic(r)
      }),
      Ie(this, 'isValidEmit', async n => {
        if (!ws(n)) {
          const { message: a } = Le('MISSING_OR_INVALID', `emit() params: ${n}`)
          throw new Error(a)
        }
        const { topic: r, event: s, chainId: i } = n
        await this.isValidSessionTopic(r)
        const { namespaces: o } = this.client.session.get(r)
        if (!t2(o, i)) {
          const { message: a } = Le('MISSING_OR_INVALID', `emit() chainId: ${i}`)
          throw new Error(a)
        }
        if (!LJ(s)) {
          const { message: a } = Le('MISSING_OR_INVALID', `emit() event: ${JSON.stringify(s)}`)
          throw new Error(a)
        }
        if (!FJ(o, i, s.name)) {
          const { message: a } = Le('MISSING_OR_INVALID', `emit() event: ${JSON.stringify(s)}`)
          throw new Error(a)
        }
      }),
      Ie(this, 'isValidDisconnect', async n => {
        if (!ws(n)) {
          const { message: s } = Le('MISSING_OR_INVALID', `disconnect() params: ${n}`)
          throw new Error(s)
        }
        const { topic: r } = n
        await this.isValidSessionOrPairingTopic(r)
      }),
      Ie(this, 'isValidAuthenticate', n => {
        const { chains: r, uri: s, domain: i, nonce: o } = n
        if (!Array.isArray(r) || r.length === 0)
          throw new Error('chains is required and must be a non-empty array')
        if (!Yn(s, !1)) throw new Error('uri is required parameter')
        if (!Yn(i, !1)) throw new Error('domain is required parameter')
        if (!Yn(o, !1)) throw new Error('nonce is required parameter')
        if ([...new Set(r.map(c => Rl(c).namespace))].length > 1)
          throw new Error(
            'Multi-namespace requests are not supported. Please request single namespace only.'
          )
        const { namespace: a } = Rl(r[0])
        if (a !== 'eip155')
          throw new Error(
            'Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.'
          )
      }),
      Ie(this, 'getVerifyContext', async n => {
        const { attestationId: r, hash: s, encryptedId: i, metadata: o, transportType: a } = n,
          c = {
            verified: { verifyUrl: o.verifyUrl || Bh, validation: 'UNKNOWN', origin: o.url || '' }
          }
        try {
          if (a === Sn.link_mode) {
            const l = this.getAppLinkIfEnabled(o, a)
            return (
              (c.verified.validation =
                l && new URL(l).origin === new URL(o.url).origin ? 'VALID' : 'INVALID'),
              c
            )
          }
          const u = await this.client.core.verify.resolve({
            attestationId: r,
            hash: s,
            encryptedId: i,
            verifyUrl: o.verifyUrl
          })
          u &&
            ((c.verified.origin = u.origin),
            (c.verified.isScam = u.isScam),
            (c.verified.validation = u.origin === new URL(o.url).origin ? 'VALID' : 'INVALID'))
        } catch (u) {
          this.client.logger.warn(u)
        }
        return this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`), c
      }),
      Ie(this, 'validateSessionProps', (n, r) => {
        Object.values(n).forEach((s, i) => {
          if (s == null) {
            const { message: o } = Le(
              'MISSING_OR_INVALID',
              `${r} must contain an existing value for each key. Received: ${s} for key ${Object.keys(n)[i]}`
            )
            throw new Error(o)
          }
        })
      }),
      Ie(this, 'getPendingAuthRequest', n => {
        const r = this.client.auth.requests.get(n)
        return typeof r == 'object' ? r : void 0
      }),
      Ie(this, 'addToRecentlyDeleted', (n, r) => {
        if (
          (this.recentlyDeletedMap.set(n, r),
          this.recentlyDeletedMap.size >= this.recentlyDeletedLimit)
        ) {
          let s = 0
          const i = this.recentlyDeletedLimit / 2
          for (const o of this.recentlyDeletedMap.keys()) {
            if (s++ >= i) break
            this.recentlyDeletedMap.delete(o)
          }
        }
      }),
      Ie(this, 'checkRecentlyDeleted', n => {
        const r = this.recentlyDeletedMap.get(n)
        if (r) {
          const { message: s } = Le(
            'MISSING_OR_INVALID',
            `Record was recently deleted - ${r}: ${n}`
          )
          throw new Error(s)
        }
      }),
      Ie(this, 'isLinkModeEnabled', (n, r) => {
        var s, i, o, a, c, u, l, d, h
        return !n || r !== Sn.link_mode
          ? !1
          : ((i = (s = this.client.metadata) == null ? void 0 : s.redirect) == null
              ? void 0
              : i.linkMode) === !0 &&
              ((a = (o = this.client.metadata) == null ? void 0 : o.redirect) == null
                ? void 0
                : a.universal) !== void 0 &&
              ((u = (c = this.client.metadata) == null ? void 0 : c.redirect) == null
                ? void 0
                : u.universal) !== '' &&
              ((l = n == null ? void 0 : n.redirect) == null ? void 0 : l.universal) !== void 0 &&
              ((d = n == null ? void 0 : n.redirect) == null ? void 0 : d.universal) !== '' &&
              ((h = n == null ? void 0 : n.redirect) == null ? void 0 : h.linkMode) === !0 &&
              this.client.core.linkModeSupportedApps.includes(n.redirect.universal) &&
              typeof (global == null ? void 0 : global.Linking) < 'u'
      }),
      Ie(this, 'getAppLinkIfEnabled', (n, r) => {
        var s
        return this.isLinkModeEnabled(n, r)
          ? (s = n == null ? void 0 : n.redirect) == null
            ? void 0
            : s.universal
          : void 0
      }),
      Ie(this, 'handleLinkModeMessage', ({ url: n }) => {
        if (!n || !n.includes('wc_ev') || !n.includes('topic')) return
        const r = vI(n, 'topic') || '',
          s = decodeURIComponent(vI(n, 'wc_ev') || ''),
          i = this.client.session.keys.includes(r)
        i && this.client.session.update(r, { transportType: Sn.link_mode }),
          this.client.core.dispatchEnvelope({ topic: r, message: s, sessionExists: i })
      }),
      Ie(this, 'registerLinkModeListeners', async () => {
        var n
        if (IA() || (dc() && (n = this.client.metadata.redirect) != null && n.linkMode)) {
          const r = global == null ? void 0 : global.Linking
          if (typeof r < 'u') {
            r.addEventListener('url', this.handleLinkModeMessage, this.client.name)
            const s = await r.getInitialURL()
            s &&
              setTimeout(() => {
                this.handleLinkModeMessage({ url: s })
              }, 50)
          }
        }
      }),
      Ie(this, 'shouldSetTVF', (n, r) => {
        if (!r || n !== 'wc_sessionRequest') return !1
        const { request: s } = r
        return Object.keys($2).includes(s.method)
      }),
      Ie(this, 'getTVFParams', (n, r, s) => {
        var i, o
        try {
          const a = r.request.method,
            c = this.extractTxHashesFromResult(a, s)
          return es(
            fn(
              { correlationId: n, rpcMethods: [a], chainId: r.chainId },
              this.isValidContractData(r.request.params) && {
                contractAddresses: [
                  (o = (i = r.request.params) == null ? void 0 : i[0]) == null ? void 0 : o.to
                ]
              }
            ),
            { txHashes: c }
          )
        } catch (a) {
          this.client.logger.warn('Error getting TVF params', a)
        }
        return {}
      }),
      Ie(this, 'isValidContractData', n => {
        var r
        if (!n) return !1
        try {
          const s =
            (n == null ? void 0 : n.data) ||
            ((r = n == null ? void 0 : n[0]) == null ? void 0 : r.data)
          if (!s.startsWith('0x')) return !1
          const i = s.slice(2)
          return /^[0-9a-fA-F]*$/.test(i) ? i.length % 2 === 0 : !1
        } catch {}
        return !1
      }),
      Ie(this, 'extractTxHashesFromResult', (n, r) => {
        try {
          const s = $2[n]
          if (typeof r == 'string') return [r]
          const i = r[s.key]
          if (Wa(i)) return n === 'solana_signAllTransactions' ? i.map(o => yZ(o)) : i
          if (typeof i == 'string') return [i]
        } catch (s) {
          this.client.logger.warn('Error extracting tx hashes from result', s)
        }
        return []
      })
  }
  async processPendingMessageEvents() {
    try {
      const e = this.client.session.keys,
        n = this.client.core.relayer.messages.getWithoutAck(e)
      for (const [r, s] of Object.entries(n))
        for (const i of s)
          try {
            await this.onProviderMessageEvent({ topic: r, message: i, publishedAt: Date.now() })
          } catch {
            this.client.logger.warn(
              `Error processing pending message event for topic: ${r}, message: ${i}`
            )
          }
    } catch (e) {
      this.client.logger.warn('processPendingMessageEvents failed', e)
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Le('NOT_INITIALIZED', this.name)
      throw new Error(e)
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow()
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(hr.message, e => {
      this.onProviderMessageEvent(e)
    })
  }
  async onRelayMessage(e) {
    const { topic: n, message: r, attestation: s, transportType: i } = e,
      { publicKey: o } = this.client.auth.authKeys.keys.includes(Lg)
        ? this.client.auth.authKeys.get(Lg)
        : { publicKey: void 0 }
    try {
      const a = await this.client.core.crypto.decode(n, r, {
        receiverPublicKey: o,
        encoding: i === Sn.link_mode ? Ta : Ii
      })
      MA(a)
        ? (this.client.core.history.set(n, a),
          await this.onRelayEventRequest({
            topic: n,
            payload: a,
            attestation: s,
            transportType: i,
            encryptedId: Ji(r)
          }))
        : z0(a)
          ? (await this.client.core.history.resolve(a),
            await this.onRelayEventResponse({ topic: n, payload: a, transportType: i }),
            this.client.core.history.delete(n, a.id))
          : await this.onRelayEventUnknownPayload({ topic: n, payload: a, transportType: i }),
        await this.client.core.relayer.messages.ack(n, r)
    } catch (a) {
      this.client.logger.error(a)
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(ti.expired, async e => {
      const { topic: n, id: r } = tO(e.target)
      if (r && this.client.pendingRequest.keys.includes(r))
        return await this.deletePendingSessionRequest(r, Le('EXPIRED'), !0)
      if (r && this.client.auth.requests.keys.includes(r))
        return await this.deletePendingAuthRequest(r, Le('EXPIRED'), !0)
      n
        ? this.client.session.keys.includes(n) &&
          (await this.deleteSession({ topic: n, expirerHasDeleted: !0 }),
          this.client.events.emit('session_expire', { topic: n }))
        : r &&
          (await this.deleteProposal(r, !0), this.client.events.emit('proposal_expire', { id: r }))
    })
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(kc.create, e => this.onPairingCreated(e)),
      this.client.core.pairing.events.on(kc.delete, e => {
        this.addToRecentlyDeleted(e.topic, 'pairing')
      })
  }
  isValidPairingTopic(e) {
    if (!Yn(e, !1)) {
      const { message: n } = Le('MISSING_OR_INVALID', `pairing topic should be a string: ${e}`)
      throw new Error(n)
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: n } = Le('NO_MATCHING_KEY', `pairing topic doesn't exist: ${e}`)
      throw new Error(n)
    }
    if (Ca(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: n } = Le('EXPIRED', `pairing topic: ${e}`)
      throw new Error(n)
    }
  }
  async isValidSessionTopic(e) {
    if (!Yn(e, !1)) {
      const { message: n } = Le('MISSING_OR_INVALID', `session topic should be a string: ${e}`)
      throw new Error(n)
    }
    if ((this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e))) {
      const { message: n } = Le('NO_MATCHING_KEY', `session topic doesn't exist: ${e}`)
      throw new Error(n)
    }
    if (Ca(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e })
      const { message: n } = Le('EXPIRED', `session topic: ${e}`)
      throw new Error(n)
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: n } = Le(
        'MISSING_OR_INVALID',
        `session topic does not exist in keychain: ${e}`
      )
      throw (await this.deleteSession({ topic: e }), new Error(n))
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if ((this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)))
      await this.isValidSessionTopic(e)
    else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e)
    else if (Yn(e, !1)) {
      const { message: n } = Le('NO_MATCHING_KEY', `session or pairing topic doesn't exist: ${e}`)
      throw new Error(n)
    } else {
      const { message: n } = Le(
        'MISSING_OR_INVALID',
        `session or pairing topic should be a string: ${e}`
      )
      throw new Error(n)
    }
  }
  async isValidProposalId(e) {
    if (!BJ(e)) {
      const { message: n } = Le('MISSING_OR_INVALID', `proposal id should be a number: ${e}`)
      throw new Error(n)
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: n } = Le('NO_MATCHING_KEY', `proposal id doesn't exist: ${e}`)
      throw new Error(n)
    }
    if (Ca(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e)
      const { message: n } = Le('EXPIRED', `proposal id: ${e}`)
      throw new Error(n)
    }
  }
}
class wre extends Nu {
  constructor(e, n) {
    super(e, n, nre, UA), (this.core = e), (this.logger = n)
  }
}
let bre = class extends Nu {
  constructor(e, n) {
    super(e, n, rre, UA), (this.core = e), (this.logger = n)
  }
}
class vre extends Nu {
  constructor(e, n) {
    super(e, n, ire, UA, r => r.id), (this.core = e), (this.logger = n)
  }
}
class Ere extends Nu {
  constructor(e, n) {
    super(e, n, ure, K0, () => Lg), (this.core = e), (this.logger = n)
  }
}
class Are extends Nu {
  constructor(e, n) {
    super(e, n, lre, K0), (this.core = e), (this.logger = n)
  }
}
class _re extends Nu {
  constructor(e, n) {
    super(e, n, dre, K0, r => r.id), (this.core = e), (this.logger = n)
  }
}
var Cre = Object.defineProperty,
  Sre = (t, e, n) =>
    e in t ? Cre(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  ob = (t, e, n) => Sre(t, typeof e != 'symbol' ? e + '' : e, n)
class Ire {
  constructor(e, n) {
    ;(this.core = e),
      (this.logger = n),
      ob(this, 'authKeys'),
      ob(this, 'pairingTopics'),
      ob(this, 'requests'),
      (this.authKeys = new Ere(this.core, this.logger)),
      (this.pairingTopics = new Are(this.core, this.logger)),
      (this.requests = new _re(this.core, this.logger))
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init()
  }
}
var xre = Object.defineProperty,
  Tre = (t, e, n) =>
    e in t ? xre(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Ft = (t, e, n) => Tre(t, typeof e != 'symbol' ? e + '' : e, n)
let Nre = class a8 extends Kz {
  constructor(e) {
    super(e),
      Ft(this, 'protocol', s8),
      Ft(this, 'version', i8),
      Ft(this, 'name', sb.name),
      Ft(this, 'metadata'),
      Ft(this, 'core'),
      Ft(this, 'logger'),
      Ft(this, 'events', new ui.EventEmitter()),
      Ft(this, 'engine'),
      Ft(this, 'session'),
      Ft(this, 'proposal'),
      Ft(this, 'pendingRequest'),
      Ft(this, 'auth'),
      Ft(this, 'signConfig'),
      Ft(this, 'on', (r, s) => this.events.on(r, s)),
      Ft(this, 'once', (r, s) => this.events.once(r, s)),
      Ft(this, 'off', (r, s) => this.events.off(r, s)),
      Ft(this, 'removeListener', (r, s) => this.events.removeListener(r, s)),
      Ft(this, 'removeAllListeners', r => this.events.removeAllListeners(r)),
      Ft(this, 'connect', async r => {
        try {
          return await this.engine.connect(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'pair', async r => {
        try {
          return await this.engine.pair(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'approve', async r => {
        try {
          return await this.engine.approve(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'reject', async r => {
        try {
          return await this.engine.reject(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'update', async r => {
        try {
          return await this.engine.update(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'extend', async r => {
        try {
          return await this.engine.extend(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'request', async r => {
        try {
          return await this.engine.request(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'respond', async r => {
        try {
          return await this.engine.respond(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'ping', async r => {
        try {
          return await this.engine.ping(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'emit', async r => {
        try {
          return await this.engine.emit(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'disconnect', async r => {
        try {
          return await this.engine.disconnect(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'find', r => {
        try {
          return this.engine.find(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'getPendingSessionRequests', () => {
        try {
          return this.engine.getPendingSessionRequests()
        } catch (r) {
          throw (this.logger.error(r.message), r)
        }
      }),
      Ft(this, 'authenticate', async (r, s) => {
        try {
          return await this.engine.authenticate(r, s)
        } catch (i) {
          throw (this.logger.error(i.message), i)
        }
      }),
      Ft(this, 'formatAuthMessage', r => {
        try {
          return this.engine.formatAuthMessage(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'approveSessionAuthenticate', async r => {
        try {
          return await this.engine.approveSessionAuthenticate(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      Ft(this, 'rejectSessionAuthenticate', async r => {
        try {
          return await this.engine.rejectSessionAuthenticate(r)
        } catch (s) {
          throw (this.logger.error(s.message), s)
        }
      }),
      (this.name = (e == null ? void 0 : e.name) || sb.name),
      (this.metadata = PQ(e == null ? void 0 : e.metadata)),
      (this.signConfig = e == null ? void 0 : e.signConfig)
    const n =
      typeof (e == null ? void 0 : e.logger) < 'u' &&
      typeof (e == null ? void 0 : e.logger) != 'string'
        ? e.logger
        : dp(Id({ level: (e == null ? void 0 : e.logger) || sb.logger }))
    ;(this.core = (e == null ? void 0 : e.core) || new tre(e)),
      (this.logger = Jr(n, this.name)),
      (this.session = new bre(this.core, this.logger)),
      (this.proposal = new wre(this.core, this.logger)),
      (this.pendingRequest = new vre(this.core, this.logger)),
      (this.engine = new yre(this)),
      (this.auth = new Ire(this.core, this.logger))
  }
  static async init(e) {
    const n = new a8(e)
    return await n.initialize(), n
  }
  get context() {
    return Is(this.logger)
  }
  get pairing() {
    return this.core.pairing.pairings
  }
  async initialize() {
    this.logger.trace('Initialized')
    try {
      await this.core.start(),
        await this.session.init(),
        await this.proposal.init(),
        await this.pendingRequest.init(),
        await this.auth.init(),
        await this.engine.init(),
        this.logger.info('SignClient Initialization Success'),
        setTimeout(() => {
          this.engine.processRelayMessageCache()
        }, Me.toMiliseconds(Me.ONE_SECOND))
    } catch (e) {
      throw (this.logger.info('SignClient Initialization Failure'), this.logger.error(e.message), e)
    }
  }
}
var lg = { exports: {} },
  j2
function Pre() {
  return (
    j2 ||
      ((j2 = 1),
      (function (t, e) {
        var n =
            (typeof globalThis < 'u' && globalThis) ||
            (typeof self < 'u' && self) ||
            (typeof Yi < 'u' && Yi),
          r = (function () {
            function i() {
              ;(this.fetch = !1), (this.DOMException = n.DOMException)
            }
            return (i.prototype = n), new i()
          })()
        ;(function (i) {
          ;(function (o) {
            var a =
                (typeof i < 'u' && i) ||
                (typeof self < 'u' && self) ||
                (typeof Yi < 'u' && Yi) ||
                {},
              c = {
                searchParams: 'URLSearchParams' in a,
                iterable: 'Symbol' in a && 'iterator' in Symbol,
                blob:
                  'FileReader' in a &&
                  'Blob' in a &&
                  (function () {
                    try {
                      return new Blob(), !0
                    } catch {
                      return !1
                    }
                  })(),
                formData: 'FormData' in a,
                arrayBuffer: 'ArrayBuffer' in a
              }
            function u(v) {
              return v && DataView.prototype.isPrototypeOf(v)
            }
            if (c.arrayBuffer)
              var l = [
                  '[object Int8Array]',
                  '[object Uint8Array]',
                  '[object Uint8ClampedArray]',
                  '[object Int16Array]',
                  '[object Uint16Array]',
                  '[object Int32Array]',
                  '[object Uint32Array]',
                  '[object Float32Array]',
                  '[object Float64Array]'
                ],
                d =
                  ArrayBuffer.isView ||
                  function (v) {
                    return v && l.indexOf(Object.prototype.toString.call(v)) > -1
                  }
            function h(v) {
              if (
                (typeof v != 'string' && (v = String(v)),
                /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(v) || v === '')
              )
                throw new TypeError('Invalid character in header field name: "' + v + '"')
              return v.toLowerCase()
            }
            function p(v) {
              return typeof v != 'string' && (v = String(v)), v
            }
            function y(v) {
              var A = {
                next: function () {
                  var P = v.shift()
                  return { done: P === void 0, value: P }
                }
              }
              return (
                c.iterable &&
                  (A[Symbol.iterator] = function () {
                    return A
                  }),
                A
              )
            }
            function m(v) {
              ;(this.map = {}),
                v instanceof m
                  ? v.forEach(function (A, P) {
                      this.append(P, A)
                    }, this)
                  : Array.isArray(v)
                    ? v.forEach(function (A) {
                        if (A.length != 2)
                          throw new TypeError(
                            'Headers constructor: expected name/value pair to be length 2, found' +
                              A.length
                          )
                        this.append(A[0], A[1])
                      }, this)
                    : v &&
                      Object.getOwnPropertyNames(v).forEach(function (A) {
                        this.append(A, v[A])
                      }, this)
            }
            ;(m.prototype.append = function (v, A) {
              ;(v = h(v)), (A = p(A))
              var P = this.map[v]
              this.map[v] = P ? P + ', ' + A : A
            }),
              (m.prototype.delete = function (v) {
                delete this.map[h(v)]
              }),
              (m.prototype.get = function (v) {
                return (v = h(v)), this.has(v) ? this.map[v] : null
              }),
              (m.prototype.has = function (v) {
                return this.map.hasOwnProperty(h(v))
              }),
              (m.prototype.set = function (v, A) {
                this.map[h(v)] = p(A)
              }),
              (m.prototype.forEach = function (v, A) {
                for (var P in this.map)
                  this.map.hasOwnProperty(P) && v.call(A, this.map[P], P, this)
              }),
              (m.prototype.keys = function () {
                var v = []
                return (
                  this.forEach(function (A, P) {
                    v.push(P)
                  }),
                  y(v)
                )
              }),
              (m.prototype.values = function () {
                var v = []
                return (
                  this.forEach(function (A) {
                    v.push(A)
                  }),
                  y(v)
                )
              }),
              (m.prototype.entries = function () {
                var v = []
                return (
                  this.forEach(function (A, P) {
                    v.push([P, A])
                  }),
                  y(v)
                )
              }),
              c.iterable && (m.prototype[Symbol.iterator] = m.prototype.entries)
            function b(v) {
              if (!v._noBody) {
                if (v.bodyUsed) return Promise.reject(new TypeError('Already read'))
                v.bodyUsed = !0
              }
            }
            function I(v) {
              return new Promise(function (A, P) {
                ;(v.onload = function () {
                  A(v.result)
                }),
                  (v.onerror = function () {
                    P(v.error)
                  })
              })
            }
            function x(v) {
              var A = new FileReader(),
                P = I(A)
              return A.readAsArrayBuffer(v), P
            }
            function _(v) {
              var A = new FileReader(),
                P = I(A),
                O = /charset=([A-Za-z0-9_-]+)/.exec(v.type),
                F = O ? O[1] : 'utf-8'
              return A.readAsText(v, F), P
            }
            function R(v) {
              for (var A = new Uint8Array(v), P = new Array(A.length), O = 0; O < A.length; O++)
                P[O] = String.fromCharCode(A[O])
              return P.join('')
            }
            function N(v) {
              if (v.slice) return v.slice(0)
              var A = new Uint8Array(v.byteLength)
              return A.set(new Uint8Array(v)), A.buffer
            }
            function T() {
              return (
                (this.bodyUsed = !1),
                (this._initBody = function (v) {
                  ;(this.bodyUsed = this.bodyUsed),
                    (this._bodyInit = v),
                    v
                      ? typeof v == 'string'
                        ? (this._bodyText = v)
                        : c.blob && Blob.prototype.isPrototypeOf(v)
                          ? (this._bodyBlob = v)
                          : c.formData && FormData.prototype.isPrototypeOf(v)
                            ? (this._bodyFormData = v)
                            : c.searchParams && URLSearchParams.prototype.isPrototypeOf(v)
                              ? (this._bodyText = v.toString())
                              : c.arrayBuffer && c.blob && u(v)
                                ? ((this._bodyArrayBuffer = N(v.buffer)),
                                  (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                                : c.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(v) || d(v))
                                  ? (this._bodyArrayBuffer = N(v))
                                  : (this._bodyText = v = Object.prototype.toString.call(v))
                      : ((this._noBody = !0), (this._bodyText = '')),
                    this.headers.get('content-type') ||
                      (typeof v == 'string'
                        ? this.headers.set('content-type', 'text/plain;charset=UTF-8')
                        : this._bodyBlob && this._bodyBlob.type
                          ? this.headers.set('content-type', this._bodyBlob.type)
                          : c.searchParams &&
                            URLSearchParams.prototype.isPrototypeOf(v) &&
                            this.headers.set(
                              'content-type',
                              'application/x-www-form-urlencoded;charset=UTF-8'
                            ))
                }),
                c.blob &&
                  (this.blob = function () {
                    var v = b(this)
                    if (v) return v
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob)
                    if (this._bodyArrayBuffer)
                      return Promise.resolve(new Blob([this._bodyArrayBuffer]))
                    if (this._bodyFormData) throw new Error('could not read FormData body as blob')
                    return Promise.resolve(new Blob([this._bodyText]))
                  }),
                (this.arrayBuffer = function () {
                  if (this._bodyArrayBuffer) {
                    var v = b(this)
                    return (
                      v ||
                      (ArrayBuffer.isView(this._bodyArrayBuffer)
                        ? Promise.resolve(
                            this._bodyArrayBuffer.buffer.slice(
                              this._bodyArrayBuffer.byteOffset,
                              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                            )
                          )
                        : Promise.resolve(this._bodyArrayBuffer))
                    )
                  } else {
                    if (c.blob) return this.blob().then(x)
                    throw new Error('could not read as ArrayBuffer')
                  }
                }),
                (this.text = function () {
                  var v = b(this)
                  if (v) return v
                  if (this._bodyBlob) return _(this._bodyBlob)
                  if (this._bodyArrayBuffer) return Promise.resolve(R(this._bodyArrayBuffer))
                  if (this._bodyFormData) throw new Error('could not read FormData body as text')
                  return Promise.resolve(this._bodyText)
                }),
                c.formData &&
                  (this.formData = function () {
                    return this.text().then($)
                  }),
                (this.json = function () {
                  return this.text().then(JSON.parse)
                }),
                this
              )
            }
            var M = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE']
            function H(v) {
              var A = v.toUpperCase()
              return M.indexOf(A) > -1 ? A : v
            }
            function B(v, A) {
              if (!(this instanceof B))
                throw new TypeError(
                  'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
                )
              A = A || {}
              var P = A.body
              if (v instanceof B) {
                if (v.bodyUsed) throw new TypeError('Already read')
                ;(this.url = v.url),
                  (this.credentials = v.credentials),
                  A.headers || (this.headers = new m(v.headers)),
                  (this.method = v.method),
                  (this.mode = v.mode),
                  (this.signal = v.signal),
                  !P && v._bodyInit != null && ((P = v._bodyInit), (v.bodyUsed = !0))
              } else this.url = String(v)
              if (
                ((this.credentials = A.credentials || this.credentials || 'same-origin'),
                (A.headers || !this.headers) && (this.headers = new m(A.headers)),
                (this.method = H(A.method || this.method || 'GET')),
                (this.mode = A.mode || this.mode || null),
                (this.signal =
                  A.signal ||
                  this.signal ||
                  (function () {
                    if ('AbortController' in a) {
                      var z = new AbortController()
                      return z.signal
                    }
                  })()),
                (this.referrer = null),
                (this.method === 'GET' || this.method === 'HEAD') && P)
              )
                throw new TypeError('Body not allowed for GET or HEAD requests')
              if (
                (this._initBody(P),
                (this.method === 'GET' || this.method === 'HEAD') &&
                  (A.cache === 'no-store' || A.cache === 'no-cache'))
              ) {
                var O = /([?&])_=[^&]*/
                if (O.test(this.url)) this.url = this.url.replace(O, '$1_=' + new Date().getTime())
                else {
                  var F = /\?/
                  this.url += (F.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()
                }
              }
            }
            B.prototype.clone = function () {
              return new B(this, { body: this._bodyInit })
            }
            function $(v) {
              var A = new FormData()
              return (
                v
                  .trim()
                  .split('&')
                  .forEach(function (P) {
                    if (P) {
                      var O = P.split('='),
                        F = O.shift().replace(/\+/g, ' '),
                        z = O.join('=').replace(/\+/g, ' ')
                      A.append(decodeURIComponent(F), decodeURIComponent(z))
                    }
                  }),
                A
              )
            }
            function D(v) {
              var A = new m(),
                P = v.replace(/\r?\n[\t ]+/g, ' ')
              return (
                P.split('\r')
                  .map(function (O) {
                    return O.indexOf(`
`) === 0
                      ? O.substr(1, O.length)
                      : O
                  })
                  .forEach(function (O) {
                    var F = O.split(':'),
                      z = F.shift().trim()
                    if (z) {
                      var j = F.join(':').trim()
                      try {
                        A.append(z, j)
                      } catch (E) {
                        console.warn('Response ' + E.message)
                      }
                    }
                  }),
                A
              )
            }
            T.call(B.prototype)
            function W(v, A) {
              if (!(this instanceof W))
                throw new TypeError(
                  'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
                )
              if (
                (A || (A = {}),
                (this.type = 'default'),
                (this.status = A.status === void 0 ? 200 : A.status),
                this.status < 200 || this.status > 599)
              )
                throw new RangeError(
                  "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
                )
              ;(this.ok = this.status >= 200 && this.status < 300),
                (this.statusText = A.statusText === void 0 ? '' : '' + A.statusText),
                (this.headers = new m(A.headers)),
                (this.url = A.url || ''),
                this._initBody(v)
            }
            T.call(W.prototype),
              (W.prototype.clone = function () {
                return new W(this._bodyInit, {
                  status: this.status,
                  statusText: this.statusText,
                  headers: new m(this.headers),
                  url: this.url
                })
              }),
              (W.error = function () {
                var v = new W(null, { status: 200, statusText: '' })
                return (v.ok = !1), (v.status = 0), (v.type = 'error'), v
              })
            var U = [301, 302, 303, 307, 308]
            ;(W.redirect = function (v, A) {
              if (U.indexOf(A) === -1) throw new RangeError('Invalid status code')
              return new W(null, { status: A, headers: { location: v } })
            }),
              (o.DOMException = a.DOMException)
            try {
              new o.DOMException()
            } catch {
              ;(o.DOMException = function (A, P) {
                ;(this.message = A), (this.name = P)
                var O = Error(A)
                this.stack = O.stack
              }),
                (o.DOMException.prototype = Object.create(Error.prototype)),
                (o.DOMException.prototype.constructor = o.DOMException)
            }
            function w(v, A) {
              return new Promise(function (P, O) {
                var F = new B(v, A)
                if (F.signal && F.signal.aborted)
                  return O(new o.DOMException('Aborted', 'AbortError'))
                var z = new XMLHttpRequest()
                function j() {
                  z.abort()
                }
                ;(z.onload = function () {
                  var L = { statusText: z.statusText, headers: D(z.getAllResponseHeaders() || '') }
                  F.url.indexOf('file://') === 0 && (z.status < 200 || z.status > 599)
                    ? (L.status = 200)
                    : (L.status = z.status),
                    (L.url = 'responseURL' in z ? z.responseURL : L.headers.get('X-Request-URL'))
                  var K = 'response' in z ? z.response : z.responseText
                  setTimeout(function () {
                    P(new W(K, L))
                  }, 0)
                }),
                  (z.onerror = function () {
                    setTimeout(function () {
                      O(new TypeError('Network request failed'))
                    }, 0)
                  }),
                  (z.ontimeout = function () {
                    setTimeout(function () {
                      O(new TypeError('Network request timed out'))
                    }, 0)
                  }),
                  (z.onabort = function () {
                    setTimeout(function () {
                      O(new o.DOMException('Aborted', 'AbortError'))
                    }, 0)
                  })
                function E(L) {
                  try {
                    return L === '' && a.location.href ? a.location.href : L
                  } catch {
                    return L
                  }
                }
                if (
                  (z.open(F.method, E(F.url), !0),
                  F.credentials === 'include'
                    ? (z.withCredentials = !0)
                    : F.credentials === 'omit' && (z.withCredentials = !1),
                  'responseType' in z &&
                    (c.blob
                      ? (z.responseType = 'blob')
                      : c.arrayBuffer && (z.responseType = 'arraybuffer')),
                  A &&
                    typeof A.headers == 'object' &&
                    !(A.headers instanceof m || (a.Headers && A.headers instanceof a.Headers)))
                ) {
                  var C = []
                  Object.getOwnPropertyNames(A.headers).forEach(function (L) {
                    C.push(h(L)), z.setRequestHeader(L, p(A.headers[L]))
                  }),
                    F.headers.forEach(function (L, K) {
                      C.indexOf(K) === -1 && z.setRequestHeader(K, L)
                    })
                } else
                  F.headers.forEach(function (L, K) {
                    z.setRequestHeader(K, L)
                  })
                F.signal &&
                  (F.signal.addEventListener('abort', j),
                  (z.onreadystatechange = function () {
                    z.readyState === 4 && F.signal.removeEventListener('abort', j)
                  })),
                  z.send(typeof F._bodyInit > 'u' ? null : F._bodyInit)
              })
            }
            return (
              (w.polyfill = !0),
              a.fetch || ((a.fetch = w), (a.Headers = m), (a.Request = B), (a.Response = W)),
              (o.Headers = m),
              (o.Request = B),
              (o.Response = W),
              (o.fetch = w),
              Object.defineProperty(o, '__esModule', { value: !0 }),
              o
            )
          })({})
        })(r),
          (r.fetch.ponyfill = !0),
          delete r.fetch.polyfill
        var s = n.fetch ? n : r
        ;(e = s.fetch),
          (e.default = s.fetch),
          (e.fetch = s.fetch),
          (e.Headers = s.Headers),
          (e.Request = s.Request),
          (e.Response = s.Response),
          (t.exports = e)
      })(lg, lg.exports)),
    lg.exports
  )
}
var Rre = Pre()
const H2 = _u(Rre)
var kre = Object.defineProperty,
  Ore = Object.defineProperties,
  Bre = Object.getOwnPropertyDescriptors,
  q2 = Object.getOwnPropertySymbols,
  Dre = Object.prototype.hasOwnProperty,
  Mre = Object.prototype.propertyIsEnumerable,
  z2 = (t, e, n) =>
    e in t ? kre(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  W2 = (t, e) => {
    for (var n in e || (e = {})) Dre.call(e, n) && z2(t, n, e[n])
    if (q2) for (var n of q2(e)) Mre.call(e, n) && z2(t, n, e[n])
    return t
  },
  K2 = (t, e) => Ore(t, Bre(e))
const Ure = { Accept: 'application/json', 'Content-Type': 'application/json' },
  Lre = 'POST',
  V2 = { headers: Ure, method: Lre },
  G2 = 10
let Mi = class {
  constructor(e, n = !1) {
    if (
      ((this.url = e),
      (this.disableProviderPing = n),
      (this.events = new ui.EventEmitter()),
      (this.isAvailable = !1),
      (this.registering = !1),
      !u2(e))
    )
      throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`)
    ;(this.url = e), (this.disableProviderPing = n)
  }
  get connected() {
    return this.isAvailable
  }
  get connecting() {
    return this.registering
  }
  on(e, n) {
    this.events.on(e, n)
  }
  once(e, n) {
    this.events.once(e, n)
  }
  off(e, n) {
    this.events.off(e, n)
  }
  removeListener(e, n) {
    this.events.removeListener(e, n)
  }
  async open(e = this.url) {
    await this.register(e)
  }
  async close() {
    if (!this.isAvailable) throw new Error('Connection already closed')
    this.onClose()
  }
  async send(e) {
    this.isAvailable || (await this.register())
    try {
      const n = Jo(e),
        r = await (await H2(this.url, K2(W2({}, V2), { body: n }))).json()
      this.onPayload({ data: r })
    } catch (n) {
      this.onError(e.id, n)
    }
  }
  async register(e = this.url) {
    if (!u2(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`)
    if (this.registering) {
      const n = this.events.getMaxListeners()
      return (
        (this.events.listenerCount('register_error') >= n ||
          this.events.listenerCount('open') >= n) &&
          this.events.setMaxListeners(n + 1),
        new Promise((r, s) => {
          this.events.once('register_error', i => {
            this.resetMaxListeners(), s(i)
          }),
            this.events.once('open', () => {
              if ((this.resetMaxListeners(), typeof this.isAvailable > 'u'))
                return s(new Error('HTTP connection is missing or invalid'))
              r()
            })
        })
      )
    }
    ;(this.url = e), (this.registering = !0)
    try {
      if (!this.disableProviderPing) {
        const n = Jo({ id: 1, jsonrpc: '2.0', method: 'test', params: [] })
        await H2(e, K2(W2({}, V2), { body: n }))
      }
      this.onOpen()
    } catch (n) {
      const r = this.parseError(n)
      throw (this.events.emit('register_error', r), this.onClose(), r)
    }
  }
  onOpen() {
    ;(this.isAvailable = !0), (this.registering = !1), this.events.emit('open')
  }
  onClose() {
    ;(this.isAvailable = !1), (this.registering = !1), this.events.emit('close')
  }
  onPayload(e) {
    if (typeof e.data > 'u') return
    const n = typeof e.data == 'string' ? hu(e.data) : e.data
    this.events.emit('payload', n)
  }
  onError(e, n) {
    const r = this.parseError(n),
      s = r.message || r.toString(),
      i = q0(e, s)
    this.events.emit('payload', i)
  }
  parseError(e, n = this.url) {
    return $O(e, n, 'HTTP')
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > G2 && this.events.setMaxListeners(G2)
  }
}
const Q2 = 'error',
  $re = 'wss://relay.walletconnect.org',
  Fre = 'wc',
  jre = 'universal_provider',
  dg = `${Fre}@2:${jre}:`,
  c8 = 'https://rpc.walletconnect.org/v1/',
  al = 'generic',
  Hre = `${c8}bundler`,
  di = { DEFAULT_CHAIN_CHANGED: 'default_chain_changed' }
function qre() {}
function LA(t) {
  return t == null || (typeof t != 'object' && typeof t != 'function')
}
function $A(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView)
}
function zre(t) {
  if (LA(t)) return t
  if (
    Array.isArray(t) ||
    $A(t) ||
    t instanceof ArrayBuffer ||
    (typeof SharedArrayBuffer < 'u' && t instanceof SharedArrayBuffer)
  )
    return t.slice(0)
  const e = Object.getPrototypeOf(t),
    n = e.constructor
  if (t instanceof Date || t instanceof Map || t instanceof Set) return new n(t)
  if (t instanceof RegExp) {
    const r = new n(t)
    return (r.lastIndex = t.lastIndex), r
  }
  if (t instanceof DataView) return new n(t.buffer.slice(0))
  if (t instanceof Error) {
    const r = new n(t.message)
    return (r.stack = t.stack), (r.name = t.name), (r.cause = t.cause), r
  }
  if (typeof File < 'u' && t instanceof File)
    return new n([t], t.name, { type: t.type, lastModified: t.lastModified })
  if (typeof t == 'object') {
    const r = Object.create(e)
    return Object.assign(r, t)
  }
  return t
}
function Z2(t) {
  return typeof t == 'object' && t !== null
}
function u8(t) {
  return Object.getOwnPropertySymbols(t).filter(e =>
    Object.prototype.propertyIsEnumerable.call(t, e)
  )
}
function l8(t) {
  return t == null
    ? t === void 0
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(t)
}
const Wre = '[object RegExp]',
  d8 = '[object String]',
  h8 = '[object Number]',
  f8 = '[object Boolean]',
  p8 = '[object Arguments]',
  Kre = '[object Symbol]',
  Vre = '[object Date]',
  Gre = '[object Map]',
  Qre = '[object Set]',
  Zre = '[object Array]',
  Yre = '[object ArrayBuffer]',
  Jre = '[object Object]',
  Xre = '[object DataView]',
  ese = '[object Uint8Array]',
  tse = '[object Uint8ClampedArray]',
  nse = '[object Uint16Array]',
  rse = '[object Uint32Array]',
  sse = '[object Int8Array]',
  ise = '[object Int16Array]',
  ose = '[object Int32Array]',
  ase = '[object Float32Array]',
  cse = '[object Float64Array]'
function use(t, e) {
  return ml(t, void 0, t, new Map(), e)
}
function ml(t, e, n, r = new Map(), s = void 0) {
  const i = s == null ? void 0 : s(t, e, n, r)
  if (i != null) return i
  if (LA(t)) return t
  if (r.has(t)) return r.get(t)
  if (Array.isArray(t)) {
    const o = new Array(t.length)
    r.set(t, o)
    for (let a = 0; a < t.length; a++) o[a] = ml(t[a], a, n, r, s)
    return (
      Object.hasOwn(t, 'index') && (o.index = t.index),
      Object.hasOwn(t, 'input') && (o.input = t.input),
      o
    )
  }
  if (t instanceof Date) return new Date(t.getTime())
  if (t instanceof RegExp) {
    const o = new RegExp(t.source, t.flags)
    return (o.lastIndex = t.lastIndex), o
  }
  if (t instanceof Map) {
    const o = new Map()
    r.set(t, o)
    for (const [a, c] of t) o.set(a, ml(c, a, n, r, s))
    return o
  }
  if (t instanceof Set) {
    const o = new Set()
    r.set(t, o)
    for (const a of t) o.add(ml(a, void 0, n, r, s))
    return o
  }
  if (typeof Buffer < 'u' && Buffer.isBuffer(t)) return t.subarray()
  if ($A(t)) {
    const o = new (Object.getPrototypeOf(t).constructor)(t.length)
    r.set(t, o)
    for (let a = 0; a < t.length; a++) o[a] = ml(t[a], a, n, r, s)
    return o
  }
  if (
    t instanceof ArrayBuffer ||
    (typeof SharedArrayBuffer < 'u' && t instanceof SharedArrayBuffer)
  )
    return t.slice(0)
  if (t instanceof DataView) {
    const o = new DataView(t.buffer.slice(0), t.byteOffset, t.byteLength)
    return r.set(t, o), Oc(o, t, n, r, s), o
  }
  if (typeof File < 'u' && t instanceof File) {
    const o = new File([t], t.name, { type: t.type })
    return r.set(t, o), Oc(o, t, n, r, s), o
  }
  if (t instanceof Blob) {
    const o = new Blob([t], { type: t.type })
    return r.set(t, o), Oc(o, t, n, r, s), o
  }
  if (t instanceof Error) {
    const o = new t.constructor()
    return (
      r.set(t, o),
      (o.message = t.message),
      (o.name = t.name),
      (o.stack = t.stack),
      (o.cause = t.cause),
      Oc(o, t, n, r, s),
      o
    )
  }
  if (typeof t == 'object' && lse(t)) {
    const o = Object.create(Object.getPrototypeOf(t))
    return r.set(t, o), Oc(o, t, n, r, s), o
  }
  return t
}
function Oc(t, e, n = t, r, s) {
  const i = [...Object.keys(e), ...u8(e)]
  for (let o = 0; o < i.length; o++) {
    const a = i[o],
      c = Object.getOwnPropertyDescriptor(t, a)
    ;(c == null || c.writable) && (t[a] = ml(e[a], a, n, r, s))
  }
}
function lse(t) {
  switch (l8(t)) {
    case p8:
    case Zre:
    case Yre:
    case Xre:
    case f8:
    case Vre:
    case ase:
    case cse:
    case sse:
    case ise:
    case ose:
    case Gre:
    case h8:
    case Jre:
    case Wre:
    case Qre:
    case d8:
    case Kre:
    case ese:
    case tse:
    case nse:
    case rse:
      return !0
    default:
      return !1
  }
}
function dse(t, e) {
  return use(t, (n, r, s, i) => {
    if (typeof t == 'object')
      switch (Object.prototype.toString.call(t)) {
        case h8:
        case d8:
        case f8: {
          const o = new t.constructor(t == null ? void 0 : t.valueOf())
          return Oc(o, t), o
        }
        case p8: {
          const o = {}
          return Oc(o, t), (o.length = t.length), (o[Symbol.iterator] = t[Symbol.iterator]), o
        }
        default:
          return
      }
  })
}
function Y2(t) {
  return dse(t)
}
function J2(t) {
  return t !== null && typeof t == 'object' && l8(t) === '[object Arguments]'
}
function hse(t) {
  return $A(t)
}
function fse(t) {
  var n
  if (typeof t != 'object' || t == null) return !1
  if (Object.getPrototypeOf(t) === null) return !0
  if (Object.prototype.toString.call(t) !== '[object Object]') {
    const r = t[Symbol.toStringTag]
    return r == null ||
      !((n = Object.getOwnPropertyDescriptor(t, Symbol.toStringTag)) != null && n.writable)
      ? !1
      : t.toString() === `[object ${r}]`
  }
  let e = t
  for (; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e)
  return Object.getPrototypeOf(t) === e
}
function pse(t, ...e) {
  const n = e.slice(0, -1),
    r = e[e.length - 1]
  let s = t
  for (let i = 0; i < n.length; i++) {
    const o = n[i]
    s = Nv(s, o, r, new Map())
  }
  return s
}
function Nv(t, e, n, r) {
  if ((LA(t) && (t = Object(t)), e == null || typeof e != 'object')) return t
  if (r.has(e)) return zre(r.get(e))
  if ((r.set(e, t), Array.isArray(e))) {
    e = e.slice()
    for (let i = 0; i < e.length; i++) e[i] = e[i] ?? void 0
  }
  const s = [...Object.keys(e), ...u8(e)]
  for (let i = 0; i < s.length; i++) {
    const o = s[i]
    let a = e[o],
      c = t[o]
    if (
      (J2(a) && (a = { ...a }),
      J2(c) && (c = { ...c }),
      typeof Buffer < 'u' && Buffer.isBuffer(a) && (a = Y2(a)),
      Array.isArray(a))
    )
      if (typeof c == 'object' && c != null) {
        const l = [],
          d = Reflect.ownKeys(c)
        for (let h = 0; h < d.length; h++) {
          const p = d[h]
          l[p] = c[p]
        }
        c = l
      } else c = []
    const u = n(c, a, o, t, e, r)
    u != null
      ? (t[o] = u)
      : Array.isArray(a) || (Z2(c) && Z2(a))
        ? (t[o] = Nv(c, a, n, r))
        : c == null && fse(a)
          ? (t[o] = Nv({}, a, n, r))
          : c == null && hse(a)
            ? (t[o] = Y2(a))
            : (c === void 0 || a !== void 0) && (t[o] = a)
  }
  return t
}
function gse(t, ...e) {
  return pse(t, ...e, qre)
}
var mse = Object.defineProperty,
  yse = Object.defineProperties,
  wse = Object.getOwnPropertyDescriptors,
  X2 = Object.getOwnPropertySymbols,
  bse = Object.prototype.hasOwnProperty,
  vse = Object.prototype.propertyIsEnumerable,
  ex = (t, e, n) =>
    e in t ? mse(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  hg = (t, e) => {
    for (var n in e || (e = {})) bse.call(e, n) && ex(t, n, e[n])
    if (X2) for (var n of X2(e)) vse.call(e, n) && ex(t, n, e[n])
    return t
  },
  Ese = (t, e) => yse(t, wse(e))
function Ws(t, e, n) {
  var r
  const s = Rl(t)
  return (
    ((r = e.rpcMap) == null ? void 0 : r[s.reference]) ||
    `${c8}?chainId=${s.namespace}:${s.reference}&projectId=${n}`
  )
}
function Pu(t) {
  return t.includes(':') ? t.split(':')[1] : t
}
function g8(t) {
  return t.map(e => `${e.split(':')[0]}:${e.split(':')[1]}`)
}
function Ase(t, e) {
  const n = Object.keys(e.namespaces).filter(s => s.includes(t))
  if (!n.length) return []
  const r = []
  return (
    n.forEach(s => {
      const i = e.namespaces[s].accounts
      r.push(...i)
    }),
    r
  )
}
function ab(t = {}, e = {}) {
  const n = tx(t),
    r = tx(e)
  return gse(n, r)
}
function tx(t) {
  var e, n, r, s
  const i = {}
  if (!Sf(t)) return i
  for (const [o, a] of Object.entries(t)) {
    const c = OA(o) ? [o] : a.chains,
      u = a.methods || [],
      l = a.events || [],
      d = a.rpcMap || {},
      h = bh(o)
    i[h] = Ese(hg(hg({}, i[h]), a), {
      chains: Bg(c, (e = i[h]) == null ? void 0 : e.chains),
      methods: Bg(u, (n = i[h]) == null ? void 0 : n.methods),
      events: Bg(l, (r = i[h]) == null ? void 0 : r.events),
      rpcMap: hg(hg({}, d), (s = i[h]) == null ? void 0 : s.rpcMap)
    })
  }
  return i
}
function nx(t) {
  return t.includes(':') ? t.split(':')[2] : t
}
function rx(t) {
  const e = {}
  for (const [n, r] of Object.entries(t)) {
    const s = r.methods || [],
      i = r.events || [],
      o = r.accounts || [],
      a = OA(n) ? [n] : r.chains ? r.chains : g8(r.accounts)
    e[n] = { chains: a, methods: s, events: i, accounts: o }
  }
  return e
}
function cb(t) {
  return typeof t == 'number'
    ? t
    : t.includes('0x')
      ? parseInt(t, 16)
      : ((t = t.includes(':') ? t.split(':')[1] : t), isNaN(Number(t)) ? t : Number(t))
}
const m8 = {},
  Gt = t => m8[t],
  ub = (t, e) => {
    m8[t] = e
  }
var _se = Object.defineProperty,
  Cse = (t, e, n) =>
    e in t ? _se(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Wu = (t, e, n) => Cse(t, typeof e != 'symbol' ? e + '' : e, n)
class Sse {
  constructor(e) {
    Wu(this, 'name', 'polkadot'),
      Wu(this, 'client'),
      Wu(this, 'httpProviders'),
      Wu(this, 'events'),
      Wu(this, 'namespace'),
      Wu(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Gt('events')),
      (this.client = Gt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(di.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2]) || []
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        const s = Pu(n)
        e[s] = this.createHttpProvider(s, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || Ws(e, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new li(new Mi(r, Gt('disableProviderPing')))
  }
}
var Ise = Object.defineProperty,
  xse = Object.defineProperties,
  Tse = Object.getOwnPropertyDescriptors,
  sx = Object.getOwnPropertySymbols,
  Nse = Object.prototype.hasOwnProperty,
  Pse = Object.prototype.propertyIsEnumerable,
  Pv = (t, e, n) =>
    e in t ? Ise(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  ix = (t, e) => {
    for (var n in e || (e = {})) Nse.call(e, n) && Pv(t, n, e[n])
    if (sx) for (var n of sx(e)) Pse.call(e, n) && Pv(t, n, e[n])
    return t
  },
  ox = (t, e) => xse(t, Tse(e)),
  Ku = (t, e, n) => Pv(t, typeof e != 'symbol' ? e + '' : e, n)
class Rse {
  constructor(e) {
    Ku(this, 'name', 'eip155'),
      Ku(this, 'client'),
      Ku(this, 'chainId'),
      Ku(this, 'namespace'),
      Ku(this, 'httpProviders'),
      Ku(this, 'events'),
      (this.namespace = e.namespace),
      (this.events = Gt('events')),
      (this.client = Gt('client')),
      (this.httpProviders = this.createHttpProviders()),
      (this.chainId = parseInt(this.getDefaultChain()))
  }
  async request(e) {
    switch (e.request.method) {
      case 'eth_requestAccounts':
        return this.getAccounts()
      case 'eth_accounts':
        return this.getAccounts()
      case 'wallet_switchEthereumChain':
        return await this.handleSwitchChain(e)
      case 'eth_chainId':
        return parseInt(this.getDefaultChain())
      case 'wallet_getCapabilities':
        return await this.getCapabilities(e)
      case 'wallet_getCallsStatus':
        return await this.getCallStatus(e)
    }
    return this.namespace.methods.includes(e.request.method)
      ? await this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), n),
      (this.chainId = parseInt(e)),
      this.events.emit(di.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString()
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  createHttpProvider(e, n) {
    const r = n || Ws(`${this.name}:${e}`, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new li(new Mi(r, Gt('disableProviderPing')))
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        const s = parseInt(Pu(n))
        e[s] = this.createHttpProvider(s, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  getHttpProvider() {
    const e = this.chainId,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  async handleSwitchChain(e) {
    var n, r
    let s = e.request.params ? ((n = e.request.params[0]) == null ? void 0 : n.chainId) : '0x0'
    s = s.startsWith('0x') ? s : `0x${s}`
    const i = parseInt(s, 16)
    if (this.isChainApproved(i)) this.setDefaultChain(`${i}`)
    else if (this.namespace.methods.includes('wallet_switchEthereumChain'))
      await this.client.request({
        topic: e.topic,
        request: { method: e.request.method, params: [{ chainId: s }] },
        chainId: (r = this.namespace.chains) == null ? void 0 : r[0]
      }),
        this.setDefaultChain(`${i}`)
    else
      throw new Error(
        `Failed to switch to chain 'eip155:${i}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`
      )
    return null
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`)
  }
  async getCapabilities(e) {
    var n, r, s
    const i = (r = (n = e.request) == null ? void 0 : n.params) == null ? void 0 : r[0]
    if (!i) throw new Error('Missing address parameter in `wallet_getCapabilities` request')
    const o = this.client.session.get(e.topic),
      a = ((s = o == null ? void 0 : o.sessionProperties) == null ? void 0 : s.capabilities) || {}
    if (a != null && a[i]) return a == null ? void 0 : a[i]
    const c = await this.client.request(e)
    try {
      await this.client.session.update(e.topic, {
        sessionProperties: ox(ix({}, o.sessionProperties || {}), {
          capabilities: ox(ix({}, a || {}), { [i]: c })
        })
      })
    } catch (u) {
      console.warn('Failed to update session with capabilities', u)
    }
    return c
  }
  async getCallStatus(e) {
    var n, r
    const s = this.client.session.get(e.topic),
      i = (n = s.sessionProperties) == null ? void 0 : n.bundler_name
    if (i) {
      const a = this.getBundlerUrl(e.chainId, i)
      try {
        return await this.getUserOperationReceipt(a, e)
      } catch (c) {
        console.warn('Failed to fetch call status from bundler', c, a)
      }
    }
    const o = (r = s.sessionProperties) == null ? void 0 : r.bundler_url
    if (o)
      try {
        return await this.getUserOperationReceipt(o, e)
      } catch (a) {
        console.warn('Failed to fetch call status from custom bundler', a, o)
      }
    if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e)
    throw new Error('Fetching call status not approved by the wallet.')
  }
  async getUserOperationReceipt(e, n) {
    var r
    const s = new URL(e),
      i = await fetch(s, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(
          Ua('eth_getUserOperationReceipt', [(r = n.request.params) == null ? void 0 : r[0]])
        )
      })
    if (!i.ok) throw new Error(`Failed to fetch user operation receipt - ${i.status}`)
    return await i.json()
  }
  getBundlerUrl(e, n) {
    return `${Hre}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${n}`
  }
}
var kse = Object.defineProperty,
  Ose = (t, e, n) =>
    e in t ? kse(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Vu = (t, e, n) => Ose(t, typeof e != 'symbol' ? e + '' : e, n)
class Bse {
  constructor(e) {
    Vu(this, 'name', 'solana'),
      Vu(this, 'client'),
      Vu(this, 'httpProviders'),
      Vu(this, 'events'),
      Vu(this, 'namespace'),
      Vu(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Gt('events')),
      (this.client = Gt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(di.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        const s = Pu(n)
        e[s] = this.createHttpProvider(s, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || Ws(e, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new li(new Mi(r, Gt('disableProviderPing')))
  }
}
var Dse = Object.defineProperty,
  Mse = (t, e, n) =>
    e in t ? Dse(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Gu = (t, e, n) => Mse(t, typeof e != 'symbol' ? e + '' : e, n)
class Use {
  constructor(e) {
    Gu(this, 'name', 'cosmos'),
      Gu(this, 'client'),
      Gu(this, 'httpProviders'),
      Gu(this, 'events'),
      Gu(this, 'namespace'),
      Gu(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Gt('events')),
      (this.client = Gt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(di.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        const s = Pu(n)
        e[s] = this.createHttpProvider(s, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || Ws(e, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new li(new Mi(r, Gt('disableProviderPing')))
  }
}
var Lse = Object.defineProperty,
  $se = (t, e, n) =>
    e in t ? Lse(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Qu = (t, e, n) => $se(t, typeof e != 'symbol' ? e + '' : e, n)
class Fse {
  constructor(e) {
    Qu(this, 'name', 'algorand'),
      Qu(this, 'client'),
      Qu(this, 'httpProviders'),
      Qu(this, 'events'),
      Qu(this, 'namespace'),
      Qu(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Gt('events')),
      (this.client = Gt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    if (!this.httpProviders[e]) {
      const r = n || Ws(`${this.name}:${e}`, this.namespace, this.client.core.projectId)
      if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
      this.setHttpProvider(e, r)
    }
    ;(this.chainId = e), this.events.emit(di.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        e[n] = this.createHttpProvider(n, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || Ws(e, this.namespace, this.client.core.projectId)
    return typeof r > 'u' ? void 0 : new li(new Mi(r, Gt('disableProviderPing')))
  }
}
var jse = Object.defineProperty,
  Hse = (t, e, n) =>
    e in t ? jse(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Zu = (t, e, n) => Hse(t, typeof e != 'symbol' ? e + '' : e, n)
class qse {
  constructor(e) {
    Zu(this, 'name', 'cip34'),
      Zu(this, 'client'),
      Zu(this, 'httpProviders'),
      Zu(this, 'events'),
      Zu(this, 'namespace'),
      Zu(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Gt('events')),
      (this.client = Gt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(di.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        const r = this.getCardanoRPCUrl(n),
          s = Pu(n)
        e[s] = this.createHttpProvider(s, r)
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  getCardanoRPCUrl(e) {
    const n = this.namespace.rpcMap
    if (n) return n[e]
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || this.getCardanoRPCUrl(e)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new li(new Mi(r, Gt('disableProviderPing')))
  }
}
var zse = Object.defineProperty,
  Wse = (t, e, n) =>
    e in t ? zse(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Yu = (t, e, n) => Wse(t, typeof e != 'symbol' ? e + '' : e, n)
class Kse {
  constructor(e) {
    Yu(this, 'name', 'elrond'),
      Yu(this, 'client'),
      Yu(this, 'httpProviders'),
      Yu(this, 'events'),
      Yu(this, 'namespace'),
      Yu(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Gt('events')),
      (this.client = Gt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(di.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        const s = Pu(n)
        e[s] = this.createHttpProvider(s, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || Ws(e, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new li(new Mi(r, Gt('disableProviderPing')))
  }
}
var Vse = Object.defineProperty,
  Gse = (t, e, n) =>
    e in t ? Vse(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Ju = (t, e, n) => Gse(t, typeof e != 'symbol' ? e + '' : e, n)
class Qse {
  constructor(e) {
    Ju(this, 'name', 'multiversx'),
      Ju(this, 'client'),
      Ju(this, 'httpProviders'),
      Ju(this, 'events'),
      Ju(this, 'namespace'),
      Ju(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Gt('events')),
      (this.client = Gt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(di.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        const s = Pu(n)
        e[s] = this.createHttpProvider(s, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || Ws(e, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new li(new Mi(r, Gt('disableProviderPing')))
  }
}
var Zse = Object.defineProperty,
  Yse = (t, e, n) =>
    e in t ? Zse(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  Xu = (t, e, n) => Yse(t, typeof e != 'symbol' ? e + '' : e, n)
class Jse {
  constructor(e) {
    Xu(this, 'name', 'near'),
      Xu(this, 'client'),
      Xu(this, 'httpProviders'),
      Xu(this, 'events'),
      Xu(this, 'namespace'),
      Xu(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Gt('events')),
      (this.client = Gt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    if (((this.chainId = e), !this.httpProviders[e])) {
      const r = n || Ws(`${this.name}:${e}`, this.namespace)
      if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
      this.setHttpProvider(e, r)
    }
    this.events.emit(di.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2]) || []
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        var r
        e[n] = this.createHttpProvider(n, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || Ws(e, this.namespace)
    return typeof r > 'u' ? void 0 : new li(new Mi(r, Gt('disableProviderPing')))
  }
}
var Xse = Object.defineProperty,
  eie = (t, e, n) =>
    e in t ? Xse(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  el = (t, e, n) => eie(t, typeof e != 'symbol' ? e + '' : e, n)
class tie {
  constructor(e) {
    el(this, 'name', 'tezos'),
      el(this, 'client'),
      el(this, 'httpProviders'),
      el(this, 'events'),
      el(this, 'namespace'),
      el(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Gt('events')),
      (this.client = Gt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request)
  }
  setDefaultChain(e, n) {
    if (((this.chainId = e), !this.httpProviders[e])) {
      const r = n || Ws(`${this.name}:${e}`, this.namespace)
      if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
      this.setHttpProvider(e, r)
    }
    this.events.emit(di.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2]) || []
      : []
  }
  createHttpProviders() {
    const e = {}
    return (
      this.namespace.chains.forEach(n => {
        e[n] = this.createHttpProvider(n)
      }),
      e
    )
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || Ws(e, this.namespace)
    return typeof r > 'u' ? void 0 : new li(new Mi(r))
  }
}
var nie = Object.defineProperty,
  rie = (t, e, n) =>
    e in t ? nie(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  tl = (t, e, n) => rie(t, typeof e != 'symbol' ? e + '' : e, n)
class sie {
  constructor(e) {
    tl(this, 'name', al),
      tl(this, 'client'),
      tl(this, 'httpProviders'),
      tl(this, 'events'),
      tl(this, 'namespace'),
      tl(this, 'chainId'),
      (this.namespace = e.namespace),
      (this.events = Gt('events')),
      (this.client = Gt('client')),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders())
  }
  updateNamespace(e) {
    ;(this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))]),
      (this.namespace.accounts = [
        ...new Set((this.namespace.accounts || []).concat(e.accounts || []))
      ]),
      (this.namespace.methods = [
        ...new Set((this.namespace.methods || []).concat(e.methods || []))
      ]),
      (this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))]),
      (this.httpProviders = this.createHttpProviders())
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider(e.chainId).request(e.request)
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(di.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId
    if (this.namespace.defaultChain) return this.namespace.defaultChain
    const e = this.namespace.chains[0]
    if (!e) throw new Error('ChainId not found')
    return e.split(':')[1]
  }
  getAccounts() {
    const e = this.namespace.accounts
    return e
      ? [
          ...new Set(
            e.filter(n => n.split(':')[1] === this.chainId.toString()).map(n => n.split(':')[2])
          )
        ]
      : []
  }
  createHttpProviders() {
    var e, n
    const r = {}
    return (
      (n = (e = this.namespace) == null ? void 0 : e.accounts) == null ||
        n.forEach(s => {
          const i = Rl(s)
          r[`${i.namespace}:${i.reference}`] = this.createHttpProvider(s)
        }),
      r
    )
  }
  getHttpProvider(e) {
    const n = this.httpProviders[e]
    if (typeof n > 'u') throw new Error(`JSON-RPC provider for ${e} not found`)
    return n
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n)
    r && (this.httpProviders[e] = r)
  }
  createHttpProvider(e, n) {
    const r = n || Ws(e, this.namespace, this.client.core.projectId)
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`)
    return new li(new Mi(r, Gt('disableProviderPing')))
  }
}
var iie = Object.defineProperty,
  oie = Object.defineProperties,
  aie = Object.getOwnPropertyDescriptors,
  ax = Object.getOwnPropertySymbols,
  cie = Object.prototype.hasOwnProperty,
  uie = Object.prototype.propertyIsEnumerable,
  Rv = (t, e, n) =>
    e in t ? iie(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
  fg = (t, e) => {
    for (var n in e || (e = {})) cie.call(e, n) && Rv(t, n, e[n])
    if (ax) for (var n of ax(e)) uie.call(e, n) && Rv(t, n, e[n])
    return t
  },
  lb = (t, e) => oie(t, aie(e)),
  Qs = (t, e, n) => Rv(t, typeof e != 'symbol' ? e + '' : e, n)
let lie = class y8 {
  constructor(e) {
    Qs(this, 'client'),
      Qs(this, 'namespaces'),
      Qs(this, 'optionalNamespaces'),
      Qs(this, 'sessionProperties'),
      Qs(this, 'scopedProperties'),
      Qs(this, 'events', new mA()),
      Qs(this, 'rpcProviders', {}),
      Qs(this, 'session'),
      Qs(this, 'providerOpts'),
      Qs(this, 'logger'),
      Qs(this, 'uri'),
      Qs(this, 'disableProviderPing', !1),
      (this.providerOpts = e),
      (this.logger =
        typeof (e == null ? void 0 : e.logger) < 'u' &&
        typeof (e == null ? void 0 : e.logger) != 'string'
          ? e.logger
          : dp(Id({ level: (e == null ? void 0 : e.logger) || Q2 }))),
      (this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || !1)
  }
  static async init(e) {
    const n = new y8(e)
    return await n.initialize(), n
  }
  async request(e, n, r) {
    const [s, i] = this.validateChain(n)
    if (!this.session) throw new Error('Please call connect() before request()')
    return await this.getProvider(s).request({
      request: fg({}, e),
      chainId: `${s}:${i}`,
      topic: this.session.topic,
      expiry: r
    })
  }
  sendAsync(e, n, r, s) {
    const i = new Date().getTime()
    this.request(e, r, s)
      .then(o => n(null, H0(i, o)))
      .catch(o => n(o, void 0))
  }
  async enable() {
    if (!this.client) throw new Error('Sign Client not initialized')
    return (
      this.session ||
        (await this.connect({
          namespaces: this.namespaces,
          optionalNamespaces: this.optionalNamespaces,
          sessionProperties: this.sessionProperties,
          scopedProperties: this.scopedProperties
        })),
      await this.requestAccounts()
    )
  }
  async disconnect() {
    var e
    if (!this.session) throw new Error('Please call connect() before enable()')
    await this.client.disconnect({
      topic: (e = this.session) == null ? void 0 : e.topic,
      reason: an('USER_DISCONNECTED')
    }),
      await this.cleanup()
  }
  async connect(e) {
    if (!this.client) throw new Error('Sign Client not initialized')
    if ((this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing))
      return await this.pair(e.pairingTopic)
  }
  async authenticate(e, n) {
    if (!this.client) throw new Error('Sign Client not initialized')
    this.setNamespaces(e), await this.cleanupPendingPairings()
    const { uri: r, response: s } = await this.client.authenticate(e, n)
    r && ((this.uri = r), this.events.emit('display_uri', r))
    const i = await s()
    if (((this.session = i.session), this.session)) {
      const o = rx(this.session.namespaces)
      ;(this.namespaces = ab(this.namespaces, o)),
        await this.persist('namespaces', this.namespaces),
        this.onConnect()
    }
    return i
  }
  on(e, n) {
    this.events.on(e, n)
  }
  once(e, n) {
    this.events.once(e, n)
  }
  removeListener(e, n) {
    this.events.removeListener(e, n)
  }
  off(e, n) {
    this.events.off(e, n)
  }
  get isWalletConnect() {
    return !0
  }
  async pair(e) {
    const { uri: n, approval: r } = await this.client.connect({
      pairingTopic: e,
      requiredNamespaces: this.namespaces,
      optionalNamespaces: this.optionalNamespaces,
      sessionProperties: this.sessionProperties,
      scopedProperties: this.scopedProperties
    })
    n && ((this.uri = n), this.events.emit('display_uri', n))
    const s = await r()
    this.session = s
    const i = rx(s.namespaces)
    return (
      (this.namespaces = ab(this.namespaces, i)),
      await this.persist('namespaces', this.namespaces),
      await this.persist('optionalNamespaces', this.optionalNamespaces),
      this.onConnect(),
      this.session
    )
  }
  setDefaultChain(e, n) {
    try {
      if (!this.session) return
      const [r, s] = this.validateChain(e),
        i = this.getProvider(r)
      i.name === al ? i.setDefaultChain(`${r}:${s}`, n) : i.setDefaultChain(s, n)
    } catch (r) {
      if (!/Please call connect/.test(r.message)) throw r
    }
  }
  async cleanupPendingPairings(e = {}) {
    this.logger.info('Cleaning up inactive pairings...')
    const n = this.client.pairing.getAll()
    if (Wa(n)) {
      for (const r of n)
        e.deletePairings
          ? this.client.core.expirer.set(r.topic, 0)
          : await this.client.core.relayer.subscriber.unsubscribe(r.topic)
      this.logger.info(`Inactive pairings cleared: ${n.length}`)
    }
  }
  abortPairingAttempt() {
    this.logger.warn('abortPairingAttempt is deprecated. This is now a no-op.')
  }
  async checkStorage() {
    ;(this.namespaces = (await this.getFromStore('namespaces')) || {}),
      (this.optionalNamespaces = (await this.getFromStore('optionalNamespaces')) || {}),
      this.session && this.createProviders()
  }
  async initialize() {
    this.logger.trace('Initialized'),
      await this.createClient(),
      await this.checkStorage(),
      this.registerEventListeners()
  }
  async createClient() {
    var e, n
    if (
      ((this.client =
        this.providerOpts.client ||
        (await Nre.init({
          core: this.providerOpts.core,
          logger: this.providerOpts.logger || Q2,
          relayUrl: this.providerOpts.relayUrl || $re,
          projectId: this.providerOpts.projectId,
          metadata: this.providerOpts.metadata,
          storageOptions: this.providerOpts.storageOptions,
          storage: this.providerOpts.storage,
          name: this.providerOpts.name,
          customStoragePrefix: this.providerOpts.customStoragePrefix,
          telemetryEnabled: this.providerOpts.telemetryEnabled
        }))),
      this.providerOpts.session)
    )
      try {
        this.session = this.client.session.get(this.providerOpts.session.topic)
      } catch (r) {
        throw (
          (this.logger.error('Failed to get session', r),
          new Error(
            `The provided session: ${(n = (e = this.providerOpts) == null ? void 0 : e.session) == null ? void 0 : n.topic} doesn't exist in the Sign client`
          ))
        )
      }
    else {
      const r = this.client.session.getAll()
      this.session = r[0]
    }
    this.logger.trace('SignClient Initialized')
  }
  createProviders() {
    if (!this.client) throw new Error('Sign Client not initialized')
    if (!this.session)
      throw new Error('Session not initialized. Please call connect() before enable()')
    const e = [...new Set(Object.keys(this.session.namespaces).map(n => bh(n)))]
    ub('client', this.client),
      ub('events', this.events),
      ub('disableProviderPing', this.disableProviderPing),
      e.forEach(n => {
        if (!this.session) return
        const r = Ase(n, this.session),
          s = g8(r),
          i = ab(this.namespaces, this.optionalNamespaces),
          o = lb(fg({}, i[n]), { accounts: r, chains: s })
        switch (n) {
          case 'eip155':
            this.rpcProviders[n] = new Rse({ namespace: o })
            break
          case 'algorand':
            this.rpcProviders[n] = new Fse({ namespace: o })
            break
          case 'solana':
            this.rpcProviders[n] = new Bse({ namespace: o })
            break
          case 'cosmos':
            this.rpcProviders[n] = new Use({ namespace: o })
            break
          case 'polkadot':
            this.rpcProviders[n] = new Sse({ namespace: o })
            break
          case 'cip34':
            this.rpcProviders[n] = new qse({ namespace: o })
            break
          case 'elrond':
            this.rpcProviders[n] = new Kse({ namespace: o })
            break
          case 'multiversx':
            this.rpcProviders[n] = new Qse({ namespace: o })
            break
          case 'near':
            this.rpcProviders[n] = new Jse({ namespace: o })
            break
          case 'tezos':
            this.rpcProviders[n] = new tie({ namespace: o })
            break
          default:
            this.rpcProviders[al]
              ? this.rpcProviders[al].updateNamespace(o)
              : (this.rpcProviders[al] = new sie({ namespace: o }))
        }
      })
  }
  registerEventListeners() {
    if (typeof this.client > 'u') throw new Error('Sign Client is not initialized')
    this.client.on('session_ping', e => {
      var n
      const { topic: r } = e
      r === ((n = this.session) == null ? void 0 : n.topic) && this.events.emit('session_ping', e)
    }),
      this.client.on('session_event', e => {
        var n
        const { params: r, topic: s } = e
        if (s !== ((n = this.session) == null ? void 0 : n.topic)) return
        const { event: i } = r
        if (i.name === 'accountsChanged') {
          const o = i.data
          o && Wa(o) && this.events.emit('accountsChanged', o.map(nx))
        } else if (i.name === 'chainChanged') {
          const o = r.chainId,
            a = r.event.data,
            c = bh(o),
            u = cb(o) !== cb(a) ? `${c}:${cb(a)}` : o
          this.onChainChanged(u)
        } else this.events.emit(i.name, i.data)
        this.events.emit('session_event', e)
      }),
      this.client.on('session_update', ({ topic: e, params: n }) => {
        var r, s
        if (e !== ((r = this.session) == null ? void 0 : r.topic)) return
        const { namespaces: i } = n,
          o = (s = this.client) == null ? void 0 : s.session.get(e)
        ;(this.session = lb(fg({}, o), { namespaces: i })),
          this.onSessionUpdate(),
          this.events.emit('session_update', { topic: e, params: n })
      }),
      this.client.on('session_delete', async e => {
        var n
        e.topic === ((n = this.session) == null ? void 0 : n.topic) &&
          (await this.cleanup(),
          this.events.emit('session_delete', e),
          this.events.emit('disconnect', lb(fg({}, an('USER_DISCONNECTED')), { data: e.topic })))
      }),
      this.on(di.DEFAULT_CHAIN_CHANGED, e => {
        this.onChainChanged(e, !0)
      })
  }
  getProvider(e) {
    return this.rpcProviders[e] || this.rpcProviders[al]
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach(e => {
      var n
      this.getProvider(e).updateNamespace((n = this.session) == null ? void 0 : n.namespaces[e])
    })
  }
  setNamespaces(e) {
    const { namespaces: n, optionalNamespaces: r, sessionProperties: s, scopedProperties: i } = e
    n && Object.keys(n).length && (this.namespaces = n),
      r && Object.keys(r).length && (this.optionalNamespaces = r),
      (this.sessionProperties = s),
      (this.scopedProperties = i)
  }
  validateChain(e) {
    const [n, r] = (e == null ? void 0 : e.split(':')) || ['', '']
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [n, r]
    if (
      n &&
      !Object.keys(this.namespaces || {})
        .map(o => bh(o))
        .includes(n)
    )
      throw new Error(
        `Namespace '${n}' is not configured. Please call connect() first with namespace config.`
      )
    if (n && r) return [n, r]
    const s = bh(Object.keys(this.namespaces)[0]),
      i = this.rpcProviders[s].getDefaultChain()
    return [s, i]
  }
  async requestAccounts() {
    const [e] = this.validateChain()
    return await this.getProvider(e).requestAccounts()
  }
  async onChainChanged(e, n = !1) {
    if (!this.namespaces) return
    const [r, s] = this.validateChain(e)
    if (!s) return
    this.updateNamespaceChain(r, s), this.events.emit('chainChanged', s)
    const i = this.getProvider(r).getDefaultChain()
    n || this.getProvider(r).setDefaultChain(s),
      this.emitAccountsChangedOnChainChange({ namespace: r, previousChainId: i, newChainId: e }),
      await this.persist('namespaces', this.namespaces)
  }
  emitAccountsChangedOnChainChange({ namespace: e, previousChainId: n, newChainId: r }) {
    var s, i
    try {
      if (n === r) return
      const o =
        (i = (s = this.session) == null ? void 0 : s.namespaces[e]) == null ? void 0 : i.accounts
      if (!o) return
      const a = o.filter(c => c.includes(`${r}:`)).map(nx)
      if (!Wa(a)) return
      this.events.emit('accountsChanged', a)
    } catch (o) {
      this.logger.warn('Failed to emit accountsChanged on chain change', o)
    }
  }
  updateNamespaceChain(e, n) {
    if (!this.namespaces) return
    const r = this.namespaces[e] ? e : `${e}:${n}`,
      s = { chains: [], methods: [], events: [], defaultChain: n }
    this.namespaces[r]
      ? this.namespaces[r] && (this.namespaces[r].defaultChain = n)
      : (this.namespaces[r] = s)
  }
  onConnect() {
    this.createProviders(), this.events.emit('connect', { session: this.session })
  }
  async cleanup() {
    ;(this.namespaces = void 0),
      (this.optionalNamespaces = void 0),
      (this.sessionProperties = void 0),
      await this.deleteFromStore('namespaces'),
      await this.deleteFromStore('optionalNamespaces'),
      await this.deleteFromStore('sessionProperties'),
      (this.session = void 0),
      await this.cleanupPendingPairings({ deletePairings: !0 }),
      await this.cleanupStorage()
  }
  async persist(e, n) {
    var r
    const s = ((r = this.session) == null ? void 0 : r.topic) || ''
    await this.client.core.storage.setItem(`${dg}/${e}${s}`, n)
  }
  async getFromStore(e) {
    var n
    const r = ((n = this.session) == null ? void 0 : n.topic) || ''
    return await this.client.core.storage.getItem(`${dg}/${e}${r}`)
  }
  async deleteFromStore(e) {
    var n
    const r = ((n = this.session) == null ? void 0 : n.topic) || ''
    await this.client.core.storage.removeItem(`${dg}/${e}${r}`)
  }
  async cleanupStorage() {
    var e
    try {
      if (((e = this.client) == null ? void 0 : e.session.length) > 0) return
      const n = await this.client.core.storage.getKeys()
      for (const r of n) r.startsWith(dg) && (await this.client.core.storage.removeItem(r))
    } catch (n) {
      this.logger.warn('Failed to cleanup storage', n)
    }
  }
}
var ad = {}
const die = 'https://secure.walletconnect.org/sdk',
  hie =
    (typeof process < 'u' && typeof ad < 'u' ? ad.NEXT_PUBLIC_SECURE_SITE_SDK_URL : void 0) || die,
  fie =
    (typeof process < 'u' && typeof ad < 'u' ? ad.NEXT_PUBLIC_DEFAULT_LOG_LEVEL : void 0) ||
    'error',
  pie =
    (typeof process < 'u' && typeof ad < 'u' ? ad.NEXT_PUBLIC_SECURE_SITE_SDK_VERSION : void 0) ||
    '4',
  rt = {
    APP_EVENT_KEY: '@w3m-app/',
    FRAME_EVENT_KEY: '@w3m-frame/',
    RPC_METHOD_KEY: 'RPC_',
    STORAGE_KEY: '@appkit-wallet/',
    SESSION_TOKEN_KEY: 'SESSION_TOKEN_KEY',
    EMAIL_LOGIN_USED_KEY: 'EMAIL_LOGIN_USED_KEY',
    LAST_USED_CHAIN_KEY: 'LAST_USED_CHAIN_KEY',
    LAST_EMAIL_LOGIN_TIME: 'LAST_EMAIL_LOGIN_TIME',
    EMAIL: 'EMAIL',
    PREFERRED_ACCOUNT_TYPE: 'PREFERRED_ACCOUNT_TYPE',
    SMART_ACCOUNT_ENABLED: 'SMART_ACCOUNT_ENABLED',
    SMART_ACCOUNT_ENABLED_NETWORKS: 'SMART_ACCOUNT_ENABLED_NETWORKS',
    SOCIAL_USERNAME: 'SOCIAL_USERNAME',
    APP_SWITCH_NETWORK: '@w3m-app/SWITCH_NETWORK',
    APP_CONNECT_EMAIL: '@w3m-app/CONNECT_EMAIL',
    APP_CONNECT_DEVICE: '@w3m-app/CONNECT_DEVICE',
    APP_CONNECT_OTP: '@w3m-app/CONNECT_OTP',
    APP_CONNECT_SOCIAL: '@w3m-app/CONNECT_SOCIAL',
    APP_GET_SOCIAL_REDIRECT_URI: '@w3m-app/GET_SOCIAL_REDIRECT_URI',
    APP_GET_USER: '@w3m-app/GET_USER',
    APP_SIGN_OUT: '@w3m-app/SIGN_OUT',
    APP_IS_CONNECTED: '@w3m-app/IS_CONNECTED',
    APP_GET_CHAIN_ID: '@w3m-app/GET_CHAIN_ID',
    APP_RPC_REQUEST: '@w3m-app/RPC_REQUEST',
    APP_UPDATE_EMAIL: '@w3m-app/UPDATE_EMAIL',
    APP_UPDATE_EMAIL_PRIMARY_OTP: '@w3m-app/UPDATE_EMAIL_PRIMARY_OTP',
    APP_UPDATE_EMAIL_SECONDARY_OTP: '@w3m-app/UPDATE_EMAIL_SECONDARY_OTP',
    APP_AWAIT_UPDATE_EMAIL: '@w3m-app/AWAIT_UPDATE_EMAIL',
    APP_SYNC_THEME: '@w3m-app/SYNC_THEME',
    APP_SYNC_DAPP_DATA: '@w3m-app/SYNC_DAPP_DATA',
    APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS: '@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS',
    APP_INIT_SMART_ACCOUNT: '@w3m-app/INIT_SMART_ACCOUNT',
    APP_SET_PREFERRED_ACCOUNT: '@w3m-app/SET_PREFERRED_ACCOUNT',
    APP_CONNECT_FARCASTER: '@w3m-app/CONNECT_FARCASTER',
    APP_GET_FARCASTER_URI: '@w3m-app/GET_FARCASTER_URI',
    APP_RELOAD: '@w3m-app/RELOAD',
    FRAME_SWITCH_NETWORK_ERROR: '@w3m-frame/SWITCH_NETWORK_ERROR',
    FRAME_SWITCH_NETWORK_SUCCESS: '@w3m-frame/SWITCH_NETWORK_SUCCESS',
    FRAME_CONNECT_EMAIL_ERROR: '@w3m-frame/CONNECT_EMAIL_ERROR',
    FRAME_CONNECT_EMAIL_SUCCESS: '@w3m-frame/CONNECT_EMAIL_SUCCESS',
    FRAME_CONNECT_DEVICE_ERROR: '@w3m-frame/CONNECT_DEVICE_ERROR',
    FRAME_CONNECT_DEVICE_SUCCESS: '@w3m-frame/CONNECT_DEVICE_SUCCESS',
    FRAME_CONNECT_OTP_SUCCESS: '@w3m-frame/CONNECT_OTP_SUCCESS',
    FRAME_CONNECT_OTP_ERROR: '@w3m-frame/CONNECT_OTP_ERROR',
    FRAME_CONNECT_SOCIAL_SUCCESS: '@w3m-frame/CONNECT_SOCIAL_SUCCESS',
    FRAME_CONNECT_SOCIAL_ERROR: '@w3m-frame/CONNECT_SOCIAL_ERROR',
    FRAME_CONNECT_FARCASTER_SUCCESS: '@w3m-frame/CONNECT_FARCASTER_SUCCESS',
    FRAME_CONNECT_FARCASTER_ERROR: '@w3m-frame/CONNECT_FARCASTER_ERROR',
    FRAME_GET_FARCASTER_URI_SUCCESS: '@w3m-frame/GET_FARCASTER_URI_SUCCESS',
    FRAME_GET_FARCASTER_URI_ERROR: '@w3m-frame/GET_FARCASTER_URI_ERROR',
    FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS: '@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS',
    FRAME_GET_SOCIAL_REDIRECT_URI_ERROR: '@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR',
    FRAME_GET_USER_SUCCESS: '@w3m-frame/GET_USER_SUCCESS',
    FRAME_GET_USER_ERROR: '@w3m-frame/GET_USER_ERROR',
    FRAME_SIGN_OUT_SUCCESS: '@w3m-frame/SIGN_OUT_SUCCESS',
    FRAME_SIGN_OUT_ERROR: '@w3m-frame/SIGN_OUT_ERROR',
    FRAME_IS_CONNECTED_SUCCESS: '@w3m-frame/IS_CONNECTED_SUCCESS',
    FRAME_IS_CONNECTED_ERROR: '@w3m-frame/IS_CONNECTED_ERROR',
    FRAME_GET_CHAIN_ID_SUCCESS: '@w3m-frame/GET_CHAIN_ID_SUCCESS',
    FRAME_GET_CHAIN_ID_ERROR: '@w3m-frame/GET_CHAIN_ID_ERROR',
    FRAME_RPC_REQUEST_SUCCESS: '@w3m-frame/RPC_REQUEST_SUCCESS',
    FRAME_RPC_REQUEST_ERROR: '@w3m-frame/RPC_REQUEST_ERROR',
    FRAME_SESSION_UPDATE: '@w3m-frame/SESSION_UPDATE',
    FRAME_UPDATE_EMAIL_SUCCESS: '@w3m-frame/UPDATE_EMAIL_SUCCESS',
    FRAME_UPDATE_EMAIL_ERROR: '@w3m-frame/UPDATE_EMAIL_ERROR',
    FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: '@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS',
    FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: '@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR',
    FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: '@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS',
    FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: '@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR',
    FRAME_SYNC_THEME_SUCCESS: '@w3m-frame/SYNC_THEME_SUCCESS',
    FRAME_SYNC_THEME_ERROR: '@w3m-frame/SYNC_THEME_ERROR',
    FRAME_SYNC_DAPP_DATA_SUCCESS: '@w3m-frame/SYNC_DAPP_DATA_SUCCESS',
    FRAME_SYNC_DAPP_DATA_ERROR: '@w3m-frame/SYNC_DAPP_DATA_ERROR',
    FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS:
      '@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS',
    FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR:
      '@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR',
    FRAME_INIT_SMART_ACCOUNT_SUCCESS: '@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS',
    FRAME_INIT_SMART_ACCOUNT_ERROR: '@w3m-frame/INIT_SMART_ACCOUNT_ERROR',
    FRAME_SET_PREFERRED_ACCOUNT_SUCCESS: '@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS',
    FRAME_SET_PREFERRED_ACCOUNT_ERROR: '@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR',
    FRAME_READY: '@w3m-frame/READY',
    FRAME_RELOAD_SUCCESS: '@w3m-frame/RELOAD_SUCCESS',
    FRAME_RELOAD_ERROR: '@w3m-frame/RELOAD_ERROR',
    RPC_RESPONSE_TYPE_ERROR: 'RPC_RESPONSE_ERROR',
    RPC_RESPONSE_TYPE_TX: 'RPC_RESPONSE_TRANSACTION_HASH',
    RPC_RESPONSE_TYPE_OBJECT: 'RPC_RESPONSE_OBJECT'
  },
  Jn = {
    SAFE_RPC_METHODS: [
      'eth_accounts',
      'eth_blockNumber',
      'eth_call',
      'eth_chainId',
      'eth_estimateGas',
      'eth_feeHistory',
      'eth_gasPrice',
      'eth_getAccount',
      'eth_getBalance',
      'eth_getBlockByHash',
      'eth_getBlockByNumber',
      'eth_getBlockReceipts',
      'eth_getBlockTransactionCountByHash',
      'eth_getBlockTransactionCountByNumber',
      'eth_getCode',
      'eth_getFilterChanges',
      'eth_getFilterLogs',
      'eth_getLogs',
      'eth_getProof',
      'eth_getStorageAt',
      'eth_getTransactionByBlockHashAndIndex',
      'eth_getTransactionByBlockNumberAndIndex',
      'eth_getTransactionByHash',
      'eth_getTransactionCount',
      'eth_getTransactionReceipt',
      'eth_getUncleCountByBlockHash',
      'eth_getUncleCountByBlockNumber',
      'eth_maxPriorityFeePerGas',
      'eth_newBlockFilter',
      'eth_newFilter',
      'eth_newPendingTransactionFilter',
      'eth_sendRawTransaction',
      'eth_syncing',
      'eth_uninstallFilter',
      'wallet_getCapabilities',
      'wallet_getCallsStatus',
      'eth_getUserOperationReceipt',
      'eth_estimateUserOperationGas',
      'eth_getUserOperationByHash',
      'eth_supportedEntryPoints',
      'wallet_getAssets'
    ],
    NOT_SAFE_RPC_METHODS: [
      'personal_sign',
      'eth_signTypedData_v4',
      'eth_sendTransaction',
      'solana_signMessage',
      'solana_signTransaction',
      'solana_signAllTransactions',
      'solana_signAndSendTransaction',
      'wallet_sendCalls',
      'wallet_grantPermissions',
      'wallet_revokePermissions',
      'eth_sendUserOperation'
    ],
    GET_CHAIN_ID: 'eth_chainId',
    RPC_METHOD_NOT_ALLOWED_MESSAGE: 'Requested RPC call is not allowed',
    RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: 'Action not allowed',
    ACCOUNT_TYPES: { EOA: 'eoa', SMART_ACCOUNT: 'smartAccount' }
  },
  xc = Object.freeze({ message: '', variant: 'success', svg: void 0, open: !1, autoClose: !0 }),
  er = xn({ ...xc }),
  Tr = {
    state: er,
    subscribeKey(t, e) {
      return Yr(er, t, e)
    },
    showLoading(t, e = {}) {
      this._showMessage({ message: t, variant: 'loading', ...e })
    },
    showSuccess(t) {
      this._showMessage({ message: t, variant: 'success' })
    },
    showSvg(t, e) {
      this._showMessage({ message: t, svg: e })
    },
    showError(t) {
      const e = dt.parseError(t)
      this._showMessage({ message: e, variant: 'error' })
    },
    hide() {
      ;(er.message = xc.message),
        (er.variant = xc.variant),
        (er.svg = xc.svg),
        (er.open = xc.open),
        (er.autoClose = xc.autoClose)
    },
    _showMessage({ message: t, svg: e, variant: n = 'success', autoClose: r = xc.autoClose }) {
      er.open
        ? ((er.open = !1),
          setTimeout(() => {
            ;(er.message = t), (er.variant = n), (er.svg = e), (er.open = !0), (er.autoClose = r)
          }, 150))
        : ((er.message = t), (er.variant = n), (er.svg = e), (er.open = !0), (er.autoClose = r))
    }
  },
  Mh = {
    getSIWX() {
      return Pe.state.siwx
    },
    async initializeIfEnabled() {
      var i
      const t = Pe.state.siwx,
        e = ne.getActiveCaipAddress()
      if (!(t && e)) return
      const [n, r, s] = e.split(':')
      if (ne.checkIfSupportedNetwork(n))
        try {
          if ((await t.getSessions(`${n}:${r}`, s)).length) return
          await Kn.open({ view: 'SIWXSignMessage' })
        } catch (o) {
          console.error('SIWXUtil:initializeIfEnabled', o),
            gn.sendEvent({
              type: 'track',
              event: 'SIWX_AUTH_ERROR',
              properties: this.getSIWXEventProperties()
            }),
            await ((i = pn._getClient()) == null ? void 0 : i.disconnect().catch(console.error)),
            nn.reset('Connect'),
            Tr.showError('A problem occurred while trying initialize authentication')
        }
    },
    async requestSignMessage() {
      const t = Pe.state.siwx,
        e = dt.getPlainAddress(ne.getActiveCaipAddress()),
        n = ne.getActiveCaipNetwork(),
        r = pn._getClient()
      if (!t) throw new Error('SIWX is not enabled')
      if (!e) throw new Error('No ActiveCaipAddress found')
      if (!n) throw new Error('No ActiveCaipNetwork or client found')
      if (!r) throw new Error('No ConnectionController client found')
      try {
        const s = await t.createMessage({ chainId: n.caipNetworkId, accountAddress: e }),
          i = s.toString()
        Et.getConnectorId(n.chainNamespace) === Ae.CONNECTOR_ID.AUTH &&
          nn.pushTransactionStack({ view: null, goBack: !1, replace: !0 })
        const a = await r.signMessage(i)
        await t.addSession({ data: s, message: i, signature: a }),
          Kn.close(),
          gn.sendEvent({
            type: 'track',
            event: 'SIWX_AUTH_SUCCESS',
            properties: this.getSIWXEventProperties()
          })
      } catch (s) {
        const i = this.getSIWXEventProperties()
        ;(!Kn.state.open || nn.state.view === 'ApproveTransaction') &&
          (await Kn.open({ view: 'SIWXSignMessage' })),
          i.isSmartAccount
            ? Tr.showError('This application might not support Smart Accounts')
            : Tr.showError('Signature declined'),
          gn.sendEvent({ type: 'track', event: 'SIWX_AUTH_ERROR', properties: i }),
          console.error('SWIXUtil:requestSignMessage', s)
      }
    },
    async cancelSignMessage() {
      var t
      try {
        const e = this.getSIWX()
        ;((t = e == null ? void 0 : e.getRequired) == null ? void 0 : t.call(e))
          ? await pn.disconnect()
          : Kn.close(),
          nn.reset('Connect'),
          gn.sendEvent({
            event: 'CLICK_CANCEL_SIWX',
            type: 'track',
            properties: this.getSIWXEventProperties()
          })
      } catch (e) {
        console.error('SIWXUtil:cancelSignMessage', e)
      }
    },
    async getSessions() {
      const t = Pe.state.siwx,
        e = dt.getPlainAddress(ne.getActiveCaipAddress()),
        n = ne.getActiveCaipNetwork()
      return t && e && n ? t.getSessions(n.caipNetworkId, e) : []
    },
    async isSIWXCloseDisabled() {
      var e
      const t = this.getSIWX()
      if (t) {
        const n = nn.state.view === 'ApproveTransaction',
          r = nn.state.view === 'SIWXSignMessage'
        if (n || r)
          return (
            ((e = t.getRequired) == null ? void 0 : e.call(t)) &&
            (await this.getSessions()).length === 0
          )
      }
      return !1
    },
    async universalProviderAuthenticate({ universalProvider: t, chains: e, methods: n }) {
      var a, c, u
      const r = Mh.getSIWX(),
        s = new Set(e.map(l => l.split(':')[0]))
      if (!r || s.size !== 1 || !s.has('eip155')) return !1
      const i = await r.createMessage({
          chainId: ((a = ne.getActiveCaipNetwork()) == null ? void 0 : a.caipNetworkId) || '',
          accountAddress: ''
        }),
        o = await t.authenticate({
          nonce: i.nonce,
          domain: i.domain,
          uri: i.uri,
          exp: i.expirationTime,
          iat: i.issuedAt,
          nbf: i.notBefore,
          requestId: i.requestId,
          version: i.version,
          resources: i.resources,
          statement: i.statement,
          chainId: i.chainId,
          methods: n,
          chains: [i.chainId, ...e.filter(l => l !== i.chainId)]
        })
      if (
        (Tr.showLoading('Authenticating...', { autoClose: !1 }),
        Ye.setConnectedWalletInfo(
          {
            ...o.session.peer.metadata,
            name: o.session.peer.metadata.name,
            icon: (c = o.session.peer.metadata.icons) == null ? void 0 : c[0],
            type: 'WALLET_CONNECT'
          },
          Array.from(s)[0]
        ),
        (u = o == null ? void 0 : o.auths) != null && u.length)
      ) {
        const l = o.auths.map(d => {
          const h = t.client.formatAuthMessage({ request: d.p, iss: d.p.iss })
          return {
            data: {
              ...d.p,
              accountAddress: d.p.iss.split(':').slice(-1).join(''),
              chainId: d.p.iss.split(':').slice(2, 4).join(':'),
              uri: d.p.aud,
              version: d.p.version || i.version,
              expirationTime: d.p.exp,
              issuedAt: d.p.iat,
              notBefore: d.p.nbf
            },
            message: h,
            signature: d.s.s,
            cacao: d
          }
        })
        try {
          await r.setSessions(l),
            gn.sendEvent({
              type: 'track',
              event: 'SIWX_AUTH_SUCCESS',
              properties: Mh.getSIWXEventProperties()
            })
        } catch (d) {
          throw (
            (console.error('SIWX:universalProviderAuth - failed to set sessions', d),
            gn.sendEvent({
              type: 'track',
              event: 'SIWX_AUTH_ERROR',
              properties: Mh.getSIWXEventProperties()
            }),
            await t.disconnect().catch(console.error),
            d)
          )
        } finally {
          Tr.hide()
        }
      }
      return !0
    },
    getSIWXEventProperties() {
      var e, n
      const t = ne.state.activeChain
      return {
        network: ((e = ne.state.activeCaipNetwork) == null ? void 0 : e.caipNetworkId) || '',
        isSmartAccount:
          ((n = Ye.state.preferredAccountTypes) == null ? void 0 : n[t]) ===
          Jn.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    },
    async clearSessions() {
      const t = this.getSIWX()
      t && (await t.setSessions([]))
    }
  },
  yn = xn({
    transactions: [],
    coinbaseTransactions: {},
    transactionsByYear: {},
    lastNetworkInView: void 0,
    loading: !1,
    empty: !1,
    next: void 0
  }),
  gie = {
    state: yn,
    subscribe(t) {
      return Qr(yn, () => t(yn))
    },
    setLastNetworkInView(t) {
      yn.lastNetworkInView = t
    },
    async fetchTransactions(t, e) {
      var n, r
      if (!t) throw new Error("Transactions can't be fetched without an accountAddress")
      yn.loading = !0
      try {
        const s = await gt.fetchTransactions({
            account: t,
            cursor: yn.next,
            onramp: e,
            cache: e === 'coinbase' ? 'no-cache' : void 0,
            chainId: (n = ne.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
          }),
          i = this.filterSpamTransactions(s.data),
          o = this.filterByConnectedChain(i),
          a = [...yn.transactions, ...o]
        ;(yn.loading = !1),
          e === 'coinbase'
            ? (yn.coinbaseTransactions = this.groupTransactionsByYearAndMonth(
                yn.coinbaseTransactions,
                s.data
              ))
            : ((yn.transactions = a),
              (yn.transactionsByYear = this.groupTransactionsByYearAndMonth(
                yn.transactionsByYear,
                o
              ))),
          (yn.empty = a.length === 0),
          (yn.next = s.next ? s.next : void 0)
      } catch {
        const i = ne.state.activeChain
        gn.sendEvent({
          type: 'track',
          event: 'ERROR_FETCH_TRANSACTIONS',
          properties: {
            address: t,
            projectId: Pe.state.projectId,
            cursor: yn.next,
            isSmartAccount:
              ((r = Ye.state.preferredAccountTypes) == null ? void 0 : r[i]) ===
              Jn.ACCOUNT_TYPES.SMART_ACCOUNT
          }
        }),
          Tr.showError('Failed to fetch transactions'),
          (yn.loading = !1),
          (yn.empty = !0),
          (yn.next = void 0)
      }
    },
    groupTransactionsByYearAndMonth(t = {}, e = []) {
      const n = t
      return (
        e.forEach(r => {
          const s = new Date(r.metadata.minedAt).getFullYear(),
            i = new Date(r.metadata.minedAt).getMonth(),
            o = n[s] ?? {},
            c = (o[i] ?? []).filter(u => u.id !== r.id)
          n[s] = {
            ...o,
            [i]: [...c, r].sort(
              (u, l) =>
                new Date(l.metadata.minedAt).getTime() - new Date(u.metadata.minedAt).getTime()
            )
          }
        }),
        n
      )
    },
    filterSpamTransactions(t) {
      return t.filter(
        e =>
          !e.transfers.every(r => {
            var s
            return ((s = r.nft_info) == null ? void 0 : s.flags.is_spam) === !0
          })
      )
    },
    filterByConnectedChain(t) {
      var r
      const e = (r = ne.state.activeCaipNetwork) == null ? void 0 : r.caipNetworkId
      return t.filter(s => s.metadata.chain === e)
    },
    clearCursor() {
      yn.next = void 0
    },
    resetTransactions() {
      ;(yn.transactions = []),
        (yn.transactionsByYear = {}),
        (yn.lastNetworkInView = void 0),
        (yn.loading = !1),
        (yn.empty = !1),
        (yn.next = void 0)
    }
  },
  wn = xn({ wcError: !1, buffering: !1, status: 'disconnected' })
let nl
const pn = {
    state: wn,
    subscribeKey(t, e) {
      return Yr(wn, t, e)
    },
    _getClient() {
      return wn._client
    },
    setClient(t) {
      wn._client = tc(t)
    },
    async connectWalletConnect() {
      var t, e, n, r
      if (dt.isTelegram() || (dt.isSafari() && dt.isIos())) {
        if (nl) {
          await nl, (nl = void 0)
          return
        }
        if (!dt.isPairingExpired(wn == null ? void 0 : wn.wcPairingExpiry)) {
          const s = wn.wcUri
          wn.wcUri = s
          return
        }
        ;(nl =
          (e = (t = this._getClient()) == null ? void 0 : t.connectWalletConnect) == null
            ? void 0
            : e.call(t).catch(() => {})),
          (this.state.status = 'connecting'),
          await nl,
          (nl = void 0),
          (wn.wcPairingExpiry = void 0),
          (this.state.status = 'connected')
      } else
        await ((r = (n = this._getClient()) == null ? void 0 : n.connectWalletConnect) == null
          ? void 0
          : r.call(n))
    },
    async connectExternal(t, e, n = !0) {
      var r, s
      await ((s = (r = this._getClient()) == null ? void 0 : r.connectExternal) == null
        ? void 0
        : s.call(r, t)),
        n && ne.setActiveNamespace(e)
    },
    async reconnectExternal(t) {
      var n, r
      await ((r = (n = this._getClient()) == null ? void 0 : n.reconnectExternal) == null
        ? void 0
        : r.call(n, t))
      const e = t.chain || ne.state.activeChain
      e && Et.setConnectorId(t.id, e)
    },
    async setPreferredAccountType(t, e) {
      var r
      Kn.setLoading(!0, ne.state.activeChain)
      const n = Et.getAuthConnector()
      n &&
        (Ye.setPreferredAccountType(t, e),
        await n.provider.setPreferredAccount(t),
        Ke.setPreferredAccountTypes(Ye.state.preferredAccountTypes ?? { [e]: t }),
        await this.reconnectExternal(n),
        Kn.setLoading(!1, ne.state.activeChain),
        gn.sendEvent({
          type: 'track',
          event: 'SET_PREFERRED_ACCOUNT_TYPE',
          properties: {
            accountType: t,
            network: ((r = ne.state.activeCaipNetwork) == null ? void 0 : r.caipNetworkId) || ''
          }
        }))
    },
    async signMessage(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.signMessage(t)
    },
    parseUnits(t, e) {
      var n
      return (n = this._getClient()) == null ? void 0 : n.parseUnits(t, e)
    },
    formatUnits(t, e) {
      var n
      return (n = this._getClient()) == null ? void 0 : n.formatUnits(t, e)
    },
    async sendTransaction(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.sendTransaction(t)
    },
    async getCapabilities(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.getCapabilities(t)
    },
    async grantPermissions(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.grantPermissions(t)
    },
    async walletGetAssets(t) {
      var e
      return ((e = this._getClient()) == null ? void 0 : e.walletGetAssets(t)) ?? {}
    },
    async estimateGas(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.estimateGas(t)
    },
    async writeContract(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.writeContract(t)
    },
    async getEnsAddress(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.getEnsAddress(t)
    },
    async getEnsAvatar(t) {
      var e
      return (e = this._getClient()) == null ? void 0 : e.getEnsAvatar(t)
    },
    checkInstalled(t) {
      var e, n
      return (
        ((n = (e = this._getClient()) == null ? void 0 : e.checkInstalled) == null
          ? void 0
          : n.call(e, t)) || !1
      )
    },
    resetWcConnection() {
      ;(wn.wcUri = void 0),
        (wn.wcPairingExpiry = void 0),
        (wn.wcLinking = void 0),
        (wn.recentWallet = void 0),
        (wn.status = 'disconnected'),
        gie.resetTransactions(),
        Ke.deleteWalletConnectDeepLink()
    },
    resetUri() {
      ;(wn.wcUri = void 0), (wn.wcPairingExpiry = void 0)
    },
    finalizeWcConnection() {
      var n, r
      const { wcLinking: t, recentWallet: e } = pn.state
      t && Ke.setWalletConnectDeepLink(t),
        e && Ke.setAppKitRecent(e),
        gn.sendEvent({
          type: 'track',
          event: 'CONNECT_SUCCESS',
          properties: {
            method: t ? 'mobile' : 'qrcode',
            name:
              ((r = (n = nn.state.data) == null ? void 0 : n.wallet) == null ? void 0 : r.name) ||
              'Unknown'
          }
        })
    },
    setWcBasic(t) {
      wn.wcBasic = t
    },
    setUri(t) {
      ;(wn.wcUri = t), (wn.wcPairingExpiry = dt.getPairingExpiry())
    },
    setWcLinking(t) {
      wn.wcLinking = t
    },
    setWcError(t) {
      ;(wn.wcError = t), (wn.buffering = !1)
    },
    setRecentWallet(t) {
      wn.recentWallet = t
    },
    setBuffering(t) {
      wn.buffering = t
    },
    setStatus(t) {
      wn.status = t
    },
    async disconnect(t) {
      try {
        Kn.setLoading(!0, t),
          await Mh.clearSessions(),
          await ne.disconnect(t),
          Kn.setLoading(!1, t),
          Et.setFilterByNamespace(void 0)
      } catch {
        throw new Error('Failed to disconnect')
      }
    }
  },
  rl = xn({
    loading: !1,
    open: !1,
    selectedNetworkId: void 0,
    activeChain: void 0,
    initialized: !1
  }),
  no = {
    state: rl,
    subscribe(t) {
      return Qr(rl, () => t(rl))
    },
    subscribeOpen(t) {
      return Yr(rl, 'open', t)
    },
    set(t) {
      Object.assign(rl, { ...rl, ...t })
    }
  },
  db = {
    createBalance(t, e) {
      const n = {
        name: t.metadata.name || '',
        symbol: t.metadata.symbol || '',
        decimals: t.metadata.decimals || 0,
        value: t.metadata.value || 0,
        price: t.metadata.price || 0,
        iconUrl: t.metadata.iconUrl || ''
      }
      return {
        name: n.name,
        symbol: n.symbol,
        chainId: e,
        address: t.address === 'native' ? void 0 : this.convertAddressToCAIP10Address(t.address, e),
        value: n.value,
        price: n.price,
        quantity: {
          decimals: n.decimals.toString(),
          numeric: this.convertHexToBalance({ hex: t.balance, decimals: n.decimals })
        },
        iconUrl: n.iconUrl
      }
    },
    convertHexToBalance({ hex: t, decimals: e }) {
      return bd(BigInt(t), e)
    },
    convertAddressToCAIP10Address(t, e) {
      return `${e}:${t}`
    },
    createCAIP2ChainId(t, e) {
      return `${e}:${parseInt(t, 16)}`
    },
    getChainIdHexFromCAIP2ChainId(t) {
      const e = t.split(':')
      if (e.length < 2 || !e[1]) return '0x0'
      const n = e[1],
        r = parseInt(n, 10)
      return isNaN(r) ? '0x0' : `0x${r.toString(16)}`
    },
    isWalletGetAssetsResponse(t) {
      return typeof t != 'object' || t === null
        ? !1
        : Object.values(t).every(e => Array.isArray(e) && e.every(n => this.isValidAsset(n)))
    },
    isValidAsset(t) {
      return (
        typeof t == 'object' &&
        t !== null &&
        typeof t.address == 'string' &&
        typeof t.balance == 'string' &&
        (t.type === 'ERC20' || t.type === 'NATIVE') &&
        typeof t.metadata == 'object' &&
        t.metadata !== null &&
        typeof t.metadata.name == 'string' &&
        typeof t.metadata.symbol == 'string' &&
        typeof t.metadata.decimals == 'number' &&
        typeof t.metadata.price == 'number' &&
        typeof t.metadata.iconUrl == 'string'
      )
    }
  },
  cx = {
    async getMyTokensWithBalance(t) {
      const e = Ye.state.address,
        n = ne.state.activeCaipNetwork
      if (!e || !n) return []
      if (n.chainNamespace === 'eip155') {
        const s = await this.getEIP155Balances(e, n)
        if (s) return this.filterLowQualityTokens(s)
      }
      const r = await gt.getBalance(e, n.caipNetworkId, t)
      return this.filterLowQualityTokens(r.balances)
    },
    async getEIP155Balances(t, e) {
      var n, r
      try {
        const s = db.getChainIdHexFromCAIP2ChainId(e.caipNetworkId),
          i = await pn.getCapabilities(t)
        if (
          !(
            (r = (n = i == null ? void 0 : i[s]) == null ? void 0 : n.assetDiscovery) != null &&
            r.supported
          )
        )
          return null
        const o = await pn.walletGetAssets({ account: t, chainFilter: [s] })
        return db.isWalletGetAssetsResponse(o)
          ? (o[s] || []).map(c => db.createBalance(c, e.caipNetworkId))
          : null
      } catch {
        return null
      }
    },
    filterLowQualityTokens(t) {
      return t.filter(e => e.quantity.decimals !== '0')
    },
    mapBalancesToSwapTokens(t) {
      return (
        (t == null
          ? void 0
          : t.map(e => ({
              ...e,
              address: e != null && e.address ? e.address : ne.getActiveNetworkTokenAddress(),
              decimals: parseInt(e.quantity.decimals, 10),
              logoUri: e.iconUrl,
              eip2612: !1
            }))) || []
      )
    }
  },
  Ht = xn({ tokenBalances: [], loading: !1 }),
  ux = {
    state: Ht,
    subscribe(t) {
      return Qr(Ht, () => t(Ht))
    },
    subscribeKey(t, e) {
      return Yr(Ht, t, e)
    },
    setToken(t) {
      t && (Ht.token = tc(t))
    },
    setTokenAmount(t) {
      Ht.sendTokenAmount = t
    },
    setReceiverAddress(t) {
      Ht.receiverAddress = t
    },
    setReceiverProfileImageUrl(t) {
      Ht.receiverProfileImageUrl = t
    },
    setReceiverProfileName(t) {
      Ht.receiverProfileName = t
    },
    setGasPrice(t) {
      Ht.gasPrice = t
    },
    setGasPriceInUsd(t) {
      Ht.gasPriceInUSD = t
    },
    setNetworkBalanceInUsd(t) {
      Ht.networkBalanceInUSD = t
    },
    setLoading(t) {
      Ht.loading = t
    },
    sendToken() {
      var t
      switch ((t = ne.state.activeCaipNetwork) == null ? void 0 : t.chainNamespace) {
        case 'eip155':
          this.sendEvmToken()
          return
        case 'solana':
          this.sendSolanaToken()
          return
        default:
          throw new Error('Unsupported chain')
      }
    },
    sendEvmToken() {
      var n, r, s, i, o, a
      const t = ne.state.activeChain,
        e = (n = Ye.state.preferredAccountTypes) == null ? void 0 : n[t]
      ;(r = this.state.token) != null &&
      r.address &&
      this.state.sendTokenAmount &&
      this.state.receiverAddress
        ? (gn.sendEvent({
            type: 'track',
            event: 'SEND_INITIATED',
            properties: {
              isSmartAccount: e === Jn.ACCOUNT_TYPES.SMART_ACCOUNT,
              token: this.state.token.address,
              amount: this.state.sendTokenAmount,
              network: ((s = ne.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId) || ''
            }
          }),
          this.sendERC20Token({
            receiverAddress: this.state.receiverAddress,
            tokenAddress: this.state.token.address,
            sendTokenAmount: this.state.sendTokenAmount,
            decimals: this.state.token.quantity.decimals
          }))
        : this.state.receiverAddress &&
          this.state.sendTokenAmount &&
          this.state.gasPrice &&
          (i = this.state.token) != null &&
          i.quantity.decimals &&
          (gn.sendEvent({
            type: 'track',
            event: 'SEND_INITIATED',
            properties: {
              isSmartAccount: e === Jn.ACCOUNT_TYPES.SMART_ACCOUNT,
              token: (o = this.state.token) == null ? void 0 : o.symbol,
              amount: this.state.sendTokenAmount,
              network: ((a = ne.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId) || ''
            }
          }),
          this.sendNativeToken({
            receiverAddress: this.state.receiverAddress,
            sendTokenAmount: this.state.sendTokenAmount,
            gasPrice: this.state.gasPrice,
            decimals: this.state.token.quantity.decimals
          }))
    },
    async fetchTokenBalance(t) {
      var i, o
      Ht.loading = !0
      const e = (i = ne.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId,
        n = (o = ne.state.activeCaipNetwork) == null ? void 0 : o.chainNamespace,
        r = ne.state.activeCaipAddress,
        s = r ? dt.getPlainAddress(r) : void 0
      if (Ht.lastRetry && !dt.isAllowedRetry(Ht.lastRetry, 30 * gr.ONE_SEC_MS))
        return (Ht.loading = !1), []
      try {
        if (s && e && n) {
          const a = await cx.getMyTokensWithBalance()
          return (Ht.tokenBalances = a), (Ht.lastRetry = void 0), a
        }
      } catch (a) {
        ;(Ht.lastRetry = Date.now()), t == null || t(a), Tr.showError('Token Balance Unavailable')
      } finally {
        Ht.loading = !1
      }
      return []
    },
    fetchNetworkBalance() {
      if (Ht.tokenBalances.length === 0) return
      const t = cx.mapBalancesToSwapTokens(Ht.tokenBalances)
      if (!t) return
      const e = t.find(n => n.address === ne.getActiveNetworkTokenAddress())
      e && (Ht.networkBalanceInUSD = e ? Jp.multiply(e.quantity.numeric, e.price).toString() : '0')
    },
    isInsufficientNetworkTokenForGas(t, e) {
      const n = e || '0'
      return Jp.bigNumber(t).eq(0) ? !0 : Jp.bigNumber(Jp.bigNumber(n)).gt(t)
    },
    hasInsufficientGasFunds() {
      var n
      const t = ne.state.activeChain
      let e = !0
      return (
        ((n = Ye.state.preferredAccountTypes) == null ? void 0 : n[t]) ===
        Jn.ACCOUNT_TYPES.SMART_ACCOUNT
          ? (e = !1)
          : Ht.networkBalanceInUSD &&
            (e = this.isInsufficientNetworkTokenForGas(Ht.networkBalanceInUSD, Ht.gasPriceInUSD)),
        e
      )
    },
    async sendNativeToken(t) {
      var o, a, c, u, l, d
      const e = ne.state.activeChain
      nn.pushTransactionStack({ view: 'Account', goBack: !1 })
      const n = t.receiverAddress,
        r = Ye.state.address,
        s = pn.parseUnits(t.sendTokenAmount.toString(), Number(t.decimals)),
        i = '0x'
      try {
        await pn.sendTransaction({
          chainNamespace: 'eip155',
          to: n,
          address: r,
          data: i,
          value: s ?? BigInt(0),
          gasPrice: t.gasPrice
        }),
          Tr.showSuccess('Transaction started'),
          gn.sendEvent({
            type: 'track',
            event: 'SEND_SUCCESS',
            properties: {
              isSmartAccount:
                ((o = Ye.state.preferredAccountTypes) == null ? void 0 : o[e]) ===
                Jn.ACCOUNT_TYPES.SMART_ACCOUNT,
              token: ((a = this.state.token) == null ? void 0 : a.symbol) || '',
              amount: t.sendTokenAmount,
              network: ((c = ne.state.activeCaipNetwork) == null ? void 0 : c.caipNetworkId) || ''
            }
          }),
          this.resetSend()
      } catch (h) {
        console.error('SendController:sendERC20Token - failed to send native token', h)
        const p = h instanceof Error ? h.message : 'Unknown error'
        gn.sendEvent({
          type: 'track',
          event: 'SEND_ERROR',
          properties: {
            message: p,
            isSmartAccount:
              ((u = Ye.state.preferredAccountTypes) == null ? void 0 : u[e]) ===
              Jn.ACCOUNT_TYPES.SMART_ACCOUNT,
            token: ((l = this.state.token) == null ? void 0 : l.symbol) || '',
            amount: t.sendTokenAmount,
            network: ((d = ne.state.activeCaipNetwork) == null ? void 0 : d.caipNetworkId) || ''
          }
        }),
          Tr.showError('Something went wrong')
      }
    },
    async sendERC20Token(t) {
      var n, r, s
      nn.pushTransactionStack({ view: 'Account', goBack: !1 })
      const e = pn.parseUnits(t.sendTokenAmount.toString(), Number(t.decimals))
      try {
        if (Ye.state.address && t.sendTokenAmount && t.receiverAddress && t.tokenAddress) {
          const i = dt.getPlainAddress(t.tokenAddress)
          await pn.writeContract({
            fromAddress: Ye.state.address,
            tokenAddress: i,
            args: [t.receiverAddress, e ?? BigInt(0)],
            method: 'transfer',
            abi: zH.getERC20Abi(i),
            chainNamespace: 'eip155'
          }),
            Tr.showSuccess('Transaction started'),
            this.resetSend()
        }
      } catch (i) {
        console.error('SendController:sendERC20Token - failed to send erc20 token', i)
        const o = i instanceof Error ? i.message : 'Unknown error'
        gn.sendEvent({
          type: 'track',
          event: 'SEND_ERROR',
          properties: {
            message: o,
            isSmartAccount:
              ((n = Ye.state.preferredAccountTypes) == null ? void 0 : n.eip155) ===
              Jn.ACCOUNT_TYPES.SMART_ACCOUNT,
            token: ((r = this.state.token) == null ? void 0 : r.symbol) || '',
            amount: t.sendTokenAmount,
            network: ((s = ne.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId) || ''
          }
        }),
          Tr.showError('Something went wrong')
      }
    },
    sendSolanaToken() {
      if (!this.state.sendTokenAmount || !this.state.receiverAddress) {
        Tr.showError('Please enter a valid amount and receiver address')
        return
      }
      nn.pushTransactionStack({ view: 'Account', goBack: !1 }),
        pn
          .sendTransaction({
            chainNamespace: 'solana',
            to: this.state.receiverAddress,
            value: this.state.sendTokenAmount
          })
          .then(() => {
            this.resetSend(), Ye.fetchTokenBalance()
          })
          .catch(t => {
            Tr.showError('Failed to send transaction. Please try again.'),
              console.error('SendController:sendToken - failed to send solana transaction', t)
          })
    },
    resetSend() {
      ;(Ht.token = void 0),
        (Ht.sendTokenAmount = void 0),
        (Ht.receiverAddress = void 0),
        (Ht.receiverProfileImageUrl = void 0),
        (Ht.receiverProfileName = void 0),
        (Ht.loading = !1),
        (Ht.tokenBalances = [])
    }
  },
  hb = {
    currentTab: 0,
    tokenBalance: [],
    smartAccountDeployed: !1,
    addressLabels: new Map(),
    allAccounts: [],
    user: void 0
  },
  pg = { caipNetwork: void 0, supportsAllNetworks: !0, smartAccountEnabledNetworks: [] },
  We = xn({
    chains: RH(),
    activeCaipAddress: void 0,
    activeChain: void 0,
    activeCaipNetwork: void 0,
    noAdapters: !1,
    universalAdapter: { networkControllerClient: void 0, connectionControllerClient: void 0 },
    isSwitchingNamespace: !1
  }),
  ne = {
    state: We,
    subscribe(t) {
      return Qr(We, () => {
        t(We)
      })
    },
    subscribeKey(t, e) {
      return Yr(We, t, e)
    },
    subscribeChainProp(t, e, n) {
      let r
      return Qr(We.chains, () => {
        var i
        const s = n || We.activeChain
        if (s) {
          const o = (i = We.chains.get(s)) == null ? void 0 : i[t]
          r !== o && ((r = o), e(o))
        }
      })
    },
    initialize(t, e, n) {
      const { chainId: r, namespace: s } = Ke.getActiveNetworkProps(),
        i =
          e == null ? void 0 : e.find(u => u.id.toString() === (r == null ? void 0 : r.toString())),
        a = t.find(u => (u == null ? void 0 : u.namespace) === s) || (t == null ? void 0 : t[0]),
        c = new Set([...((e == null ? void 0 : e.map(u => u.chainNamespace)) ?? [])])
      ;((t == null ? void 0 : t.length) === 0 || !a) && (We.noAdapters = !0),
        We.noAdapters ||
          ((We.activeChain = a == null ? void 0 : a.namespace),
          (We.activeCaipNetwork = i),
          this.setChainNetworkData(a == null ? void 0 : a.namespace, { caipNetwork: i }),
          We.activeChain && no.set({ activeChain: a == null ? void 0 : a.namespace })),
        c.forEach(u => {
          const l = e == null ? void 0 : e.filter(d => d.chainNamespace === u)
          ne.state.chains.set(u, {
            namespace: u,
            networkState: xn({ ...pg, caipNetwork: l == null ? void 0 : l[0] }),
            accountState: xn(hb),
            caipNetworks: l ?? [],
            ...n
          }),
            this.setRequestedCaipNetworks(l ?? [], u)
        })
    },
    removeAdapter(t) {
      var e, n
      if (We.activeChain === t) {
        const r = Array.from(We.chains.entries()).find(([s]) => s !== t)
        if (r) {
          const s = (n = (e = r[1]) == null ? void 0 : e.caipNetworks) == null ? void 0 : n[0]
          s && this.setActiveCaipNetwork(s)
        }
      }
      We.chains.delete(t)
    },
    addAdapter(t, { networkControllerClient: e, connectionControllerClient: n }, r) {
      We.chains.set(t.namespace, {
        namespace: t.namespace,
        networkState: { ...pg, caipNetwork: r[0] },
        accountState: hb,
        caipNetworks: r,
        connectionControllerClient: n,
        networkControllerClient: e
      }),
        this.setRequestedCaipNetworks(
          (r == null ? void 0 : r.filter(s => s.chainNamespace === t.namespace)) ?? [],
          t.namespace
        )
    },
    addNetwork(t) {
      var n
      const e = We.chains.get(t.chainNamespace)
      if (e) {
        const r = [...(e.caipNetworks || [])]
        ;((n = e.caipNetworks) != null && n.find(s => s.id === t.id)) || r.push(t),
          We.chains.set(t.chainNamespace, { ...e, caipNetworks: r }),
          this.setRequestedCaipNetworks(r, t.chainNamespace),
          Et.updateAdapter(t.chainNamespace, !0)
      }
    },
    removeNetwork(t, e) {
      var r, s, i
      const n = We.chains.get(t)
      if (n) {
        const o = ((r = We.activeCaipNetwork) == null ? void 0 : r.id) === e,
          a = [...(((s = n.caipNetworks) == null ? void 0 : s.filter(c => c.id !== e)) || [])]
        o &&
          (i = n == null ? void 0 : n.caipNetworks) != null &&
          i[0] &&
          this.setActiveCaipNetwork(n.caipNetworks[0]),
          We.chains.set(t, { ...n, caipNetworks: a }),
          this.setRequestedCaipNetworks(a || [], t),
          a.length === 0 && Et.updateAdapter(t, !1)
      }
    },
    setAdapterNetworkState(t, e) {
      const n = We.chains.get(t)
      n && ((n.networkState = { ...(n.networkState || pg), ...e }), We.chains.set(t, n))
    },
    setChainAccountData(t, e, n = !0) {
      if (!t) throw new Error('Chain is required to update chain account data')
      const r = We.chains.get(t)
      if (r) {
        const s = { ...(r.accountState || hb), ...e }
        We.chains.set(t, { ...r, accountState: s }),
          (We.chains.size === 1 || We.activeChain === t) &&
            (e.caipAddress && (We.activeCaipAddress = e.caipAddress), Ye.replaceState(s))
      }
    },
    setChainNetworkData(t, e) {
      if (!t) return
      const n = We.chains.get(t)
      if (n) {
        const r = { ...(n.networkState || pg), ...e }
        We.chains.set(t, { ...n, networkState: r })
      }
    },
    setAccountProp(t, e, n, r = !0) {
      this.setChainAccountData(n, { [t]: e }, r),
        t === 'status' && e === 'disconnected' && n && Et.removeConnectorId(n)
    },
    setActiveNamespace(t) {
      var r, s
      We.activeChain = t
      const e = t ? We.chains.get(t) : void 0,
        n = (r = e == null ? void 0 : e.networkState) == null ? void 0 : r.caipNetwork
      n != null &&
        n.id &&
        t &&
        ((We.activeCaipAddress =
          (s = e == null ? void 0 : e.accountState) == null ? void 0 : s.caipAddress),
        (We.activeCaipNetwork = n),
        this.setChainNetworkData(t, { caipNetwork: n }),
        Ke.setActiveCaipNetworkId(n == null ? void 0 : n.caipNetworkId),
        no.set({ activeChain: t, selectedNetworkId: n == null ? void 0 : n.caipNetworkId }))
    },
    setActiveCaipNetwork(t) {
      var r, s, i
      if (!t) return
      We.activeChain !== t.chainNamespace && this.setIsSwitchingNamespace(!0)
      const e = We.chains.get(t.chainNamespace)
      ;(We.activeChain = t.chainNamespace),
        (We.activeCaipNetwork = t),
        this.setChainNetworkData(t.chainNamespace, { caipNetwork: t }),
        (r = e == null ? void 0 : e.accountState) != null && r.address
          ? (We.activeCaipAddress = `${t.chainNamespace}:${t.id}:${(s = e == null ? void 0 : e.accountState) == null ? void 0 : s.address}`)
          : (We.activeCaipAddress = void 0),
        this.setAccountProp('caipAddress', We.activeCaipAddress, t.chainNamespace),
        e && Ye.replaceState(e.accountState),
        ux.resetSend(),
        no.set({
          activeChain: We.activeChain,
          selectedNetworkId: (i = We.activeCaipNetwork) == null ? void 0 : i.caipNetworkId
        }),
        Ke.setActiveCaipNetworkId(t.caipNetworkId),
        !this.checkIfSupportedNetwork(t.chainNamespace) &&
          Pe.state.enableNetworkSwitch &&
          !Pe.state.allowUnsupportedChain &&
          !pn.state.wcBasic &&
          this.showUnsupportedChainUI()
    },
    addCaipNetwork(t) {
      var n
      if (!t) return
      const e = We.chains.get(t.chainNamespace)
      e && ((n = e == null ? void 0 : e.caipNetworks) == null || n.push(t))
    },
    async switchActiveNamespace(t) {
      var s
      if (!t) return
      const e = t !== ne.state.activeChain,
        n = (s = ne.getNetworkData(t)) == null ? void 0 : s.caipNetwork,
        r = ne.getCaipNetworkByNamespace(t, n == null ? void 0 : n.id)
      e && r && (await ne.switchActiveNetwork(r))
    },
    async switchActiveNetwork(t) {
      var s
      const e = ne.state.chains.get(ne.state.activeChain)
      !(
        (s = e == null ? void 0 : e.caipNetworks) != null &&
        s.some(i => {
          var o
          return i.id === ((o = We.activeCaipNetwork) == null ? void 0 : o.id)
        })
      ) && nn.goBack()
      const r = this.getNetworkControllerClient(t.chainNamespace)
      r &&
        (await r.switchCaipNetwork(t),
        gn.sendEvent({
          type: 'track',
          event: 'SWITCH_NETWORK',
          properties: { network: t.caipNetworkId }
        }))
    },
    getNetworkControllerClient(t) {
      const e = t || We.activeChain,
        n = We.chains.get(e)
      if (!n) throw new Error('Chain adapter not found')
      if (!n.networkControllerClient) throw new Error('NetworkController client not set')
      return n.networkControllerClient
    },
    getConnectionControllerClient(t) {
      const e = t || We.activeChain
      if (!e) throw new Error('Chain is required to get connection controller client')
      const n = We.chains.get(e)
      if (!(n != null && n.connectionControllerClient))
        throw new Error('ConnectionController client not set')
      return n.connectionControllerClient
    },
    getAccountProp(t, e) {
      var s
      let n = We.activeChain
      if ((e && (n = e), !n)) return
      const r = (s = We.chains.get(n)) == null ? void 0 : s.accountState
      if (r) return r[t]
    },
    getNetworkProp(t, e) {
      var r
      const n = (r = We.chains.get(e)) == null ? void 0 : r.networkState
      if (n) return n[t]
    },
    getRequestedCaipNetworks(t) {
      const e = We.chains.get(t),
        { approvedCaipNetworkIds: n = [], requestedCaipNetworks: r = [] } =
          (e == null ? void 0 : e.networkState) || {}
      return dt.sortRequestedNetworks(n, r)
    },
    getAllRequestedCaipNetworks() {
      const t = []
      return (
        We.chains.forEach(e => {
          const n = this.getRequestedCaipNetworks(e.namespace)
          t.push(...n)
        }),
        t
      )
    },
    setRequestedCaipNetworks(t, e) {
      this.setAdapterNetworkState(e, { requestedCaipNetworks: t })
    },
    getAllApprovedCaipNetworkIds() {
      const t = []
      return (
        We.chains.forEach(e => {
          const n = this.getApprovedCaipNetworkIds(e.namespace)
          t.push(...n)
        }),
        t
      )
    },
    getActiveCaipNetwork() {
      return We.activeCaipNetwork
    },
    getActiveCaipAddress() {
      return We.activeCaipAddress
    },
    getApprovedCaipNetworkIds(t) {
      var r
      const e = We.chains.get(t)
      return (
        ((r = e == null ? void 0 : e.networkState) == null ? void 0 : r.approvedCaipNetworkIds) ||
        []
      )
    },
    async setApprovedCaipNetworksData(t) {
      const e = this.getNetworkControllerClient(),
        n = await (e == null ? void 0 : e.getApprovedCaipNetworksData())
      this.setAdapterNetworkState(t, {
        approvedCaipNetworkIds: n == null ? void 0 : n.approvedCaipNetworkIds,
        supportsAllNetworks: n == null ? void 0 : n.supportsAllNetworks
      })
    },
    checkIfSupportedNetwork(t, e) {
      const n = e || We.activeCaipNetwork,
        r = this.getRequestedCaipNetworks(t)
      return r.length
        ? r == null
          ? void 0
          : r.some(s => s.id === (n == null ? void 0 : n.id))
        : !0
    },
    checkIfSupportedChainId(t) {
      if (!We.activeChain) return !0
      const e = this.getRequestedCaipNetworks(We.activeChain)
      return e == null ? void 0 : e.some(n => n.id === t)
    },
    setSmartAccountEnabledNetworks(t, e) {
      this.setAdapterNetworkState(e, { smartAccountEnabledNetworks: t })
    },
    checkIfSmartAccountEnabled() {
      var r
      const t = yf.caipNetworkIdToNumber(
          (r = We.activeCaipNetwork) == null ? void 0 : r.caipNetworkId
        ),
        e = We.activeChain
      if (!e || !t) return !1
      const n = this.getNetworkProp('smartAccountEnabledNetworks', e)
      return !!(n != null && n.includes(Number(t)))
    },
    getActiveNetworkTokenAddress() {
      var r, s
      const t = ((r = We.activeCaipNetwork) == null ? void 0 : r.chainNamespace) || 'eip155',
        e = ((s = We.activeCaipNetwork) == null ? void 0 : s.id) || 1,
        n = gr.NATIVE_TOKEN_ADDRESS[t]
      return `${t}:${e}:${n}`
    },
    showUnsupportedChainUI() {
      Kn.open({ view: 'UnsupportedChain' })
    },
    checkIfNamesSupported() {
      const t = We.activeCaipNetwork
      return !!(
        t != null &&
        t.chainNamespace &&
        gr.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(t.chainNamespace)
      )
    },
    resetNetwork(t) {
      this.setAdapterNetworkState(t, {
        approvedCaipNetworkIds: void 0,
        supportsAllNetworks: !0,
        smartAccountEnabledNetworks: []
      })
    },
    resetAccount(t) {
      const e = t
      if (!e) throw new Error('Chain is required to set account prop')
      ;(We.activeCaipAddress = void 0),
        this.setChainAccountData(e, {
          smartAccountDeployed: !1,
          currentTab: 0,
          caipAddress: void 0,
          address: void 0,
          balance: void 0,
          balanceSymbol: void 0,
          profileName: void 0,
          profileImage: void 0,
          addressExplorerUrl: void 0,
          tokenBalance: [],
          connectedWalletInfo: void 0,
          preferredAccountTypes: void 0,
          socialProvider: void 0,
          socialWindow: void 0,
          farcasterUrl: void 0,
          allAccounts: [],
          user: void 0,
          status: 'disconnected'
        }),
        Et.removeConnectorId(e)
    },
    async disconnect(t) {
      const e = nq(t)
      try {
        ux.resetSend()
        const n = await Promise.allSettled(
          e.map(async ([s, i]) => {
            var o
            try {
              const { caipAddress: a } = this.getAccountData(s) || {}
              a &&
                (o = i.connectionControllerClient) != null &&
                o.disconnect &&
                (await i.connectionControllerClient.disconnect(s)),
                this.resetAccount(s),
                this.resetNetwork(s)
            } catch (a) {
              throw new Error(`Failed to disconnect chain ${s}: ${a.message}`)
            }
          })
        )
        pn.resetWcConnection()
        const r = n.filter(s => s.status === 'rejected')
        if (r.length > 0) throw new Error(r.map(s => s.reason.message).join(', '))
        Ke.deleteConnectedSocialProvider(),
          t ? Et.removeConnectorId(t) : Et.resetConnectorIds(),
          gn.sendEvent({
            type: 'track',
            event: 'DISCONNECT_SUCCESS',
            properties: { namespace: t || 'all' }
          })
      } catch (n) {
        console.error(n.message || 'Failed to disconnect chains'),
          gn.sendEvent({
            type: 'track',
            event: 'DISCONNECT_ERROR',
            properties: { message: n.message || 'Failed to disconnect chains' }
          })
      }
    },
    setIsSwitchingNamespace(t) {
      We.isSwitchingNamespace = t
    },
    getFirstCaipNetworkSupportsAuthConnector() {
      var n, r
      const t = []
      let e
      if (
        (We.chains.forEach(s => {
          Ae.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(i => i === s.namespace) &&
            s.namespace &&
            t.push(s.namespace)
        }),
        t.length > 0)
      ) {
        const s = t[0]
        return (
          (e = s
            ? (r = (n = We.chains.get(s)) == null ? void 0 : n.caipNetworks) == null
              ? void 0
              : r[0]
            : void 0),
          e
        )
      }
    },
    getAccountData(t) {
      var e
      return t ? ((e = ne.state.chains.get(t)) == null ? void 0 : e.accountState) : Ye.state
    },
    getNetworkData(t) {
      var n
      const e = t || We.activeChain
      if (e) return (n = ne.state.chains.get(e)) == null ? void 0 : n.networkState
    },
    getCaipNetworkByNamespace(t, e) {
      var s, i, o
      if (!t) return
      const n = ne.state.chains.get(t),
        r = (s = n == null ? void 0 : n.caipNetworks) == null ? void 0 : s.find(a => a.id === e)
      return (
        r ||
        ((i = n == null ? void 0 : n.networkState) == null ? void 0 : i.caipNetwork) ||
        ((o = n == null ? void 0 : n.caipNetworks) == null ? void 0 : o[0])
      )
    },
    getRequestedCaipNetworkIds() {
      const t = Et.state.filterByNamespace
      return (t ? [We.chains.get(t)] : Array.from(We.chains.values()))
        .flatMap(n => (n == null ? void 0 : n.caipNetworks) || [])
        .map(n => n.caipNetworkId)
    },
    getCaipNetworks(t) {
      return t ? ne.getRequestedCaipNetworks(t) : ne.getAllRequestedCaipNetworks()
    }
  },
  mie = {
    purchaseCurrencies: [
      {
        id: '2b92315d-eab7-5bef-84fa-089a131333f5',
        name: 'USD Coin',
        symbol: 'USDC',
        networks: [
          {
            name: 'ethereum-mainnet',
            display_name: 'Ethereum',
            chain_id: '1',
            contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
          },
          {
            name: 'polygon-mainnet',
            display_name: 'Polygon',
            chain_id: '137',
            contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
          }
        ]
      },
      {
        id: '2b92315d-eab7-5bef-84fa-089a131333f5',
        name: 'Ether',
        symbol: 'ETH',
        networks: [
          {
            name: 'ethereum-mainnet',
            display_name: 'Ethereum',
            chain_id: '1',
            contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
          },
          {
            name: 'polygon-mainnet',
            display_name: 'Polygon',
            chain_id: '137',
            contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
          }
        ]
      }
    ],
    paymentCurrencies: [
      {
        id: 'USD',
        payment_method_limits: [
          { id: 'card', min: '10.00', max: '7500.00' },
          { id: 'ach_bank_account', min: '10.00', max: '25000.00' }
        ]
      },
      {
        id: 'EUR',
        payment_method_limits: [
          { id: 'card', min: '10.00', max: '7500.00' },
          { id: 'ach_bank_account', min: '10.00', max: '25000.00' }
        ]
      }
    ]
  },
  w8 = dt.getBlockchainApiUrl(),
  Ns = xn({
    clientId: null,
    api: new k0({ baseUrl: w8, clientId: null }),
    supportedChains: { http: [], ws: [] }
  }),
  gt = {
    state: Ns,
    async get(t) {
      const { st: e, sv: n } = gt.getSdkProperties(),
        r = Pe.state.projectId,
        s = { ...(t.params || {}), st: e, sv: n, projectId: r }
      return Ns.api.get({ ...t, params: s })
    },
    getSdkProperties() {
      const { sdkType: t, sdkVersion: e } = Pe.state
      return { st: t || 'unknown', sv: e || 'unknown' }
    },
    async isNetworkSupported(t) {
      if (!t) return !1
      try {
        Ns.supportedChains.http.length || (await gt.getSupportedNetworks())
      } catch {
        return !1
      }
      return Ns.supportedChains.http.includes(t)
    },
    async getSupportedNetworks() {
      const t = await gt.get({ path: 'v1/supported-chains' })
      return (Ns.supportedChains = t), t
    },
    async fetchIdentity({ address: t, caipNetworkId: e }) {
      if (!(await gt.isNetworkSupported(e))) return { avatar: '', name: '' }
      const r = Ke.getIdentityFromCacheForAddress(t)
      if (r) return r
      const s = await gt.get({
        path: `/v1/identity/${t}`,
        params: {
          sender: ne.state.activeCaipAddress
            ? dt.getPlainAddress(ne.state.activeCaipAddress)
            : void 0
        }
      })
      return Ke.updateIdentityCache({ address: t, identity: s, timestamp: Date.now() }), s
    },
    async fetchTransactions({ account: t, cursor: e, onramp: n, signal: r, cache: s, chainId: i }) {
      var a
      return (await gt.isNetworkSupported(
        (a = ne.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId
      ))
        ? gt.get({
            path: `/v1/account/${t}/history`,
            params: { cursor: e, onramp: n, chainId: i },
            signal: r,
            cache: s
          })
        : { data: [], next: void 0 }
    },
    async fetchSwapQuote({ amount: t, userAddress: e, from: n, to: r, gasPrice: s }) {
      var o
      return (await gt.isNetworkSupported(
        (o = ne.state.activeCaipNetwork) == null ? void 0 : o.caipNetworkId
      ))
        ? gt.get({
            path: '/v1/convert/quotes',
            headers: { 'Content-Type': 'application/json' },
            params: { amount: t, userAddress: e, from: n, to: r, gasPrice: s }
          })
        : { quotes: [] }
    },
    async fetchSwapTokens({ chainId: t }) {
      var n
      return (await gt.isNetworkSupported(
        (n = ne.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? gt.get({ path: '/v1/convert/tokens', params: { chainId: t } })
        : { tokens: [] }
    },
    async fetchTokenPrice({ addresses: t }) {
      var n
      return (await gt.isNetworkSupported(
        (n = ne.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? Ns.api.post({
            path: '/v1/fungible/price',
            body: { currency: 'usd', addresses: t, projectId: Pe.state.projectId },
            headers: { 'Content-Type': 'application/json' }
          })
        : { fungibles: [] }
    },
    async fetchSwapAllowance({ tokenAddress: t, userAddress: e }) {
      var r
      return (await gt.isNetworkSupported(
        (r = ne.state.activeCaipNetwork) == null ? void 0 : r.caipNetworkId
      ))
        ? gt.get({
            path: '/v1/convert/allowance',
            params: { tokenAddress: t, userAddress: e },
            headers: { 'Content-Type': 'application/json' }
          })
        : { allowance: '0' }
    },
    async fetchGasPrice({ chainId: t }) {
      var s
      const { st: e, sv: n } = gt.getSdkProperties()
      if (
        !(await gt.isNetworkSupported(
          (s = ne.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId
        ))
      )
        throw new Error('Network not supported for Gas Price')
      return gt.get({
        path: '/v1/convert/gas-price',
        headers: { 'Content-Type': 'application/json' },
        params: { chainId: t, st: e, sv: n }
      })
    },
    async generateSwapCalldata({ amount: t, from: e, to: n, userAddress: r, disableEstimate: s }) {
      var o
      if (
        !(await gt.isNetworkSupported(
          (o = ne.state.activeCaipNetwork) == null ? void 0 : o.caipNetworkId
        ))
      )
        throw new Error('Network not supported for Swaps')
      return Ns.api.post({
        path: '/v1/convert/build-transaction',
        headers: { 'Content-Type': 'application/json' },
        body: {
          amount: t,
          eip155: { slippage: gr.CONVERT_SLIPPAGE_TOLERANCE },
          projectId: Pe.state.projectId,
          from: e,
          to: n,
          userAddress: r,
          disableEstimate: s
        }
      })
    },
    async generateApproveCalldata({ from: t, to: e, userAddress: n }) {
      var o
      const { st: r, sv: s } = gt.getSdkProperties()
      if (
        !(await gt.isNetworkSupported(
          (o = ne.state.activeCaipNetwork) == null ? void 0 : o.caipNetworkId
        ))
      )
        throw new Error('Network not supported for Swaps')
      return gt.get({
        path: '/v1/convert/build-approve',
        headers: { 'Content-Type': 'application/json' },
        params: { userAddress: n, from: t, to: e, st: r, sv: s }
      })
    },
    async getBalance(t, e, n) {
      var u
      const { st: r, sv: s } = gt.getSdkProperties()
      if (
        !(await gt.isNetworkSupported(
          (u = ne.state.activeCaipNetwork) == null ? void 0 : u.caipNetworkId
        ))
      )
        return Tr.showError('Token Balance Unavailable'), { balances: [] }
      const o = `${e}:${t}`,
        a = Ke.getBalanceCacheForCaipAddress(o)
      if (a) return a
      const c = await gt.get({
        path: `/v1/account/${t}/balance`,
        params: { currency: 'usd', chainId: e, forceUpdate: n, st: r, sv: s }
      })
      return Ke.updateBalanceCache({ caipAddress: o, balance: c, timestamp: Date.now() }), c
    },
    async lookupEnsName(t) {
      var n
      return (await gt.isNetworkSupported(
        (n = ne.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? gt.get({ path: `/v1/profile/account/${t}`, params: { apiVersion: '2' } })
        : { addresses: {}, attributes: [] }
    },
    async reverseLookupEnsName({ address: t }) {
      var n
      return (await gt.isNetworkSupported(
        (n = ne.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? gt.get({
            path: `/v1/profile/reverse/${t}`,
            params: { sender: Ye.state.address, apiVersion: '2' }
          })
        : []
    },
    async getEnsNameSuggestions(t) {
      var n
      return (await gt.isNetworkSupported(
        (n = ne.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? gt.get({ path: `/v1/profile/suggestions/${t}`, params: { zone: 'reown.id' } })
        : { suggestions: [] }
    },
    async registerEnsName({ coinType: t, address: e, message: n, signature: r }) {
      var i
      return (await gt.isNetworkSupported(
        (i = ne.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId
      ))
        ? Ns.api.post({
            path: '/v1/profile/account',
            body: { coin_type: t, address: e, message: n, signature: r },
            headers: { 'Content-Type': 'application/json' }
          })
        : { success: !1 }
    },
    async generateOnRampURL({
      destinationWallets: t,
      partnerUserId: e,
      defaultNetwork: n,
      purchaseAmount: r,
      paymentAmount: s
    }) {
      var a
      return (await gt.isNetworkSupported(
        (a = ne.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId
      ))
        ? (
            await Ns.api.post({
              path: '/v1/generators/onrampurl',
              params: { projectId: Pe.state.projectId },
              body: {
                destinationWallets: t,
                defaultNetwork: n,
                partnerUserId: e,
                defaultExperience: 'buy',
                presetCryptoAmount: r,
                presetFiatAmount: s
              }
            })
          ).url
        : ''
    },
    async getOnrampOptions() {
      var e
      if (
        !(await gt.isNetworkSupported(
          (e = ne.state.activeCaipNetwork) == null ? void 0 : e.caipNetworkId
        ))
      )
        return { paymentCurrencies: [], purchaseCurrencies: [] }
      try {
        return await gt.get({ path: '/v1/onramp/options' })
      } catch {
        return mie
      }
    },
    async getOnrampQuote({ purchaseCurrency: t, paymentCurrency: e, amount: n, network: r }) {
      var s
      try {
        return (await gt.isNetworkSupported(
          (s = ne.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId
        ))
          ? await Ns.api.post({
              path: '/v1/onramp/quote',
              params: { projectId: Pe.state.projectId },
              body: { purchaseCurrency: t, paymentCurrency: e, amount: n, network: r }
            })
          : null
      } catch {
        return {
          coinbaseFee: { amount: n, currency: e.id },
          networkFee: { amount: n, currency: e.id },
          paymentSubtotal: { amount: n, currency: e.id },
          paymentTotal: { amount: n, currency: e.id },
          purchaseAmount: { amount: n, currency: e.id },
          quoteId: 'mocked-quote-id'
        }
      }
    },
    async getSmartSessions(t) {
      var n
      return (await gt.isNetworkSupported(
        (n = ne.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? gt.get({ path: `/v1/sessions/${t}` })
        : []
    },
    async revokeSmartSession(t, e, n) {
      var s
      return (await gt.isNetworkSupported(
        (s = ne.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId
      ))
        ? Ns.api.post({
            path: `/v1/sessions/${t}/revoke`,
            params: { projectId: Pe.state.projectId },
            body: { pci: e, signature: n }
          })
        : { success: !1 }
    },
    setClientId(t) {
      ;(Ns.clientId = t), (Ns.api = new k0({ baseUrl: w8, clientId: t }))
    }
  },
  Zs = xn({
    currentTab: 0,
    tokenBalance: [],
    smartAccountDeployed: !1,
    addressLabels: new Map(),
    allAccounts: []
  }),
  Ye = {
    state: Zs,
    replaceState(t) {
      t && Object.assign(Zs, tc(t))
    },
    subscribe(t) {
      return ne.subscribeChainProp('accountState', e => {
        if (e) return t(e)
      })
    },
    subscribeKey(t, e, n) {
      let r
      return ne.subscribeChainProp(
        'accountState',
        s => {
          if (s) {
            const i = s[t]
            r !== i && ((r = i), e(i))
          }
        },
        n
      )
    },
    setStatus(t, e) {
      ne.setAccountProp('status', t, e)
    },
    getCaipAddress(t) {
      return ne.getAccountProp('caipAddress', t)
    },
    setCaipAddress(t, e) {
      const n = t ? dt.getPlainAddress(t) : void 0
      e === ne.state.activeChain && (ne.state.activeCaipAddress = t),
        ne.setAccountProp('caipAddress', t, e),
        ne.setAccountProp('address', n, e)
    },
    setBalance(t, e, n) {
      ne.setAccountProp('balance', t, n), ne.setAccountProp('balanceSymbol', e, n)
    },
    setProfileName(t, e) {
      ne.setAccountProp('profileName', t, e)
    },
    setProfileImage(t, e) {
      ne.setAccountProp('profileImage', t, e)
    },
    setUser(t, e) {
      ne.setAccountProp('user', t, e)
    },
    setAddressExplorerUrl(t, e) {
      ne.setAccountProp('addressExplorerUrl', t, e)
    },
    setSmartAccountDeployed(t, e) {
      ne.setAccountProp('smartAccountDeployed', t, e)
    },
    setCurrentTab(t) {
      ne.setAccountProp('currentTab', t, ne.state.activeChain)
    },
    setTokenBalance(t, e) {
      t && ne.setAccountProp('tokenBalance', t, e)
    },
    setShouldUpdateToAddress(t, e) {
      ne.setAccountProp('shouldUpdateToAddress', t, e)
    },
    setAllAccounts(t, e) {
      ne.setAccountProp('allAccounts', t, e)
    },
    addAddressLabel(t, e, n) {
      const r = ne.getAccountProp('addressLabels', n) || new Map()
      r.set(t, e), ne.setAccountProp('addressLabels', r, n)
    },
    removeAddressLabel(t, e) {
      const n = ne.getAccountProp('addressLabels', e) || new Map()
      n.delete(t), ne.setAccountProp('addressLabels', n, e)
    },
    setConnectedWalletInfo(t, e) {
      ne.setAccountProp('connectedWalletInfo', t, e, !1)
    },
    setPreferredAccountType(t, e) {
      ne.setAccountProp('preferredAccountTypes', { ...Zs.preferredAccountTypes, [e]: t }, e)
    },
    setPreferredAccountTypes(t) {
      Zs.preferredAccountTypes = t
    },
    setSocialProvider(t, e) {
      t && ne.setAccountProp('socialProvider', t, e)
    },
    setSocialWindow(t, e) {
      ne.setAccountProp('socialWindow', t ? tc(t) : void 0, e)
    },
    setFarcasterUrl(t, e) {
      ne.setAccountProp('farcasterUrl', t, e)
    },
    async fetchTokenBalance(t) {
      var i, o
      Zs.balanceLoading = !0
      const e = (i = ne.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId,
        n = (o = ne.state.activeCaipNetwork) == null ? void 0 : o.chainNamespace,
        r = ne.state.activeCaipAddress,
        s = r ? dt.getPlainAddress(r) : void 0
      if (Zs.lastRetry && !dt.isAllowedRetry(Zs.lastRetry, 30 * gr.ONE_SEC_MS))
        return (Zs.balanceLoading = !1), []
      try {
        if (s && e && n) {
          const c = (await gt.getBalance(s, e)).balances.filter(u => u.quantity.decimals !== '0')
          return this.setTokenBalance(c, n), (Zs.lastRetry = void 0), (Zs.balanceLoading = !1), c
        }
      } catch (a) {
        ;(Zs.lastRetry = Date.now()), t == null || t(a), Tr.showError('Token Balance Unavailable')
      } finally {
        Zs.balanceLoading = !1
      }
      return []
    },
    resetAccount(t) {
      ne.resetAccount(t)
    }
  },
  ps = xn({ loading: !1, loadingNamespaceMap: new Map(), open: !1, shake: !1, namespace: void 0 }),
  Kn = {
    state: ps,
    subscribe(t) {
      return Qr(ps, () => t(ps))
    },
    subscribeKey(t, e) {
      return Yr(ps, t, e)
    },
    async open(t) {
      var s
      const e = Ye.state.status === 'connected'
      pn.state.wcBasic
        ? yt.prefetch({ fetchNetworkImages: !1, fetchConnectorImages: !1 })
        : await yt.prefetch({
            fetchConnectorImages: !e,
            fetchFeaturedWallets: !e,
            fetchRecommendedWallets: !e
          }),
        t != null && t.namespace
          ? (await ne.switchActiveNamespace(t.namespace), Kn.setLoading(!0, t.namespace))
          : Kn.setLoading(!0),
        Et.setFilterByNamespace(t == null ? void 0 : t.namespace)
      const n =
        (s = ne.getAccountData(t == null ? void 0 : t.namespace)) == null ? void 0 : s.caipAddress
      ne.state.noAdapters && !n
        ? dt.isMobile()
          ? nn.reset('AllWallets')
          : nn.reset('ConnectingWalletConnectBasic')
        : t != null && t.view
          ? nn.reset(t.view, t.data)
          : n
            ? nn.reset('Account')
            : nn.reset('Connect'),
        (ps.open = !0),
        no.set({ open: !0 }),
        gn.sendEvent({ type: 'track', event: 'MODAL_OPEN', properties: { connected: !!n } })
    },
    close(t = !1) {
      if (t || nn.state.view !== 'ApproveTransaction') {
        const e = Pe.state.enableEmbedded,
          n = !!ne.state.activeCaipAddress
        ps.open &&
          gn.sendEvent({ type: 'track', event: 'MODAL_CLOSE', properties: { connected: n } }),
          (ps.open = !1),
          Kn.clearLoading(),
          e ? (n ? nn.replace('Account') : nn.push('Connect')) : no.set({ open: !1 })
      }
      pn.resetUri()
    },
    setLoading(t, e) {
      e && ps.loadingNamespaceMap.set(e, t), (ps.loading = t), no.set({ loading: t })
    },
    clearLoading() {
      ps.loadingNamespaceMap.clear(), (ps.loading = !1)
    },
    shake() {
      ps.shake ||
        ((ps.shake = !0),
        setTimeout(() => {
          ps.shake = !1
        }, 500))
    }
  },
  lx = 2147483648,
  yie = {
    convertEVMChainIdToCoinType(t) {
      if (t >= lx) throw new Error('Invalid chainId')
      return (lx | t) >>> 0
    }
  },
  Ys = xn({ suggestions: [], loading: !1 }),
  b8 = {
    state: Ys,
    subscribe(t) {
      return Qr(Ys, () => t(Ys))
    },
    subscribeKey(t, e) {
      return Yr(Ys, t, e)
    },
    async resolveName(t) {
      var e, n
      try {
        return await gt.lookupEnsName(t)
      } catch (r) {
        const s = r
        throw new Error(
          ((n = (e = s == null ? void 0 : s.reasons) == null ? void 0 : e[0]) == null
            ? void 0
            : n.description) || 'Error resolving name'
        )
      }
    },
    async isNameRegistered(t) {
      try {
        return await gt.lookupEnsName(t), !0
      } catch {
        return !1
      }
    },
    async getSuggestions(t) {
      try {
        ;(Ys.loading = !0), (Ys.suggestions = [])
        const e = await gt.getEnsNameSuggestions(t)
        return (
          (Ys.suggestions = e.suggestions.map(n => ({ ...n, name: n.name })) || []), Ys.suggestions
        )
      } catch (e) {
        const n = this.parseEnsApiError(e, 'Error fetching name suggestions')
        throw new Error(n)
      } finally {
        Ys.loading = !1
      }
    },
    async getNamesForAddress(t) {
      try {
        if (!ne.state.activeCaipNetwork) return []
        const n = Ke.getEnsFromCacheForAddress(t)
        if (n) return n
        const r = await gt.reverseLookupEnsName({ address: t })
        return Ke.updateEnsCache({ address: t, ens: r, timestamp: Date.now() }), r
      } catch (e) {
        const n = this.parseEnsApiError(e, 'Error fetching names for address')
        throw new Error(n)
      }
    },
    async registerName(t) {
      const e = ne.state.activeCaipNetwork
      if (!e) throw new Error('Network not found')
      const n = Ye.state.address,
        r = Et.getAuthConnector()
      if (!n || !r) throw new Error('Address or auth connector not found')
      Ys.loading = !0
      try {
        const s = JSON.stringify({
          name: t,
          attributes: {},
          timestamp: Math.floor(Date.now() / 1e3)
        })
        nn.pushTransactionStack({
          view: 'RegisterAccountNameSuccess',
          goBack: !1,
          replace: !0,
          onCancel() {
            Ys.loading = !1
          }
        })
        const i = await pn.signMessage(s),
          o = e.id
        if (!o) throw new Error('Network not found')
        const a = yie.convertEVMChainIdToCoinType(Number(o))
        await gt.registerEnsName({ coinType: a, address: n, signature: i, message: s }),
          Ye.setProfileName(t, e.chainNamespace),
          nn.replace('RegisterAccountNameSuccess')
      } catch (s) {
        const i = this.parseEnsApiError(s, `Error registering name ${t}`)
        throw (nn.replace('RegisterAccountName'), new Error(i))
      } finally {
        Ys.loading = !1
      }
    },
    validateName(t) {
      return /^[a-zA-Z0-9-]{4,}$/u.test(t)
    },
    parseEnsApiError(t, e) {
      var r, s
      const n = t
      return (
        ((s = (r = n == null ? void 0 : n.reasons) == null ? void 0 : r[0]) == null
          ? void 0
          : s.description) || e
      )
    }
  },
  In = {
    METMASK_CONNECTOR_NAME: 'MetaMask',
    TRUST_CONNECTOR_NAME: 'Trust Wallet',
    SOLFLARE_CONNECTOR_NAME: 'Solflare',
    PHANTOM_CONNECTOR_NAME: 'Phantom',
    COIN98_CONNECTOR_NAME: 'Coin98',
    MAGIC_EDEN_CONNECTOR_NAME: 'Magic Eden',
    BACKPACK_CONNECTOR_NAME: 'Backpack',
    BITGET_CONNECTOR_NAME: 'Bitget Wallet',
    FRONTIER_CONNECTOR_NAME: 'Frontier',
    XVERSE_CONNECTOR_NAME: 'Xverse Wallet',
    LEATHER_CONNECTOR_NAME: 'Leather',
    EIP155: 'eip155',
    ADD_CHAIN_METHOD: 'wallet_addEthereumChain',
    EIP6963_ANNOUNCE_EVENT: 'eip6963:announceProvider',
    EIP6963_REQUEST_EVENT: 'eip6963:requestProvider',
    CONNECTOR_RDNS_MAP: {
      coinbaseWallet: 'com.coinbase.wallet',
      coinbaseWalletSDK: 'com.coinbase.wallet'
    },
    CONNECTOR_TYPE_EXTERNAL: 'EXTERNAL',
    CONNECTOR_TYPE_WALLET_CONNECT: 'WALLET_CONNECT',
    CONNECTOR_TYPE_INJECTED: 'INJECTED',
    CONNECTOR_TYPE_ANNOUNCED: 'ANNOUNCED',
    CONNECTOR_TYPE_AUTH: 'AUTH',
    CONNECTOR_TYPE_MULTI_CHAIN: 'MULTI_CHAIN',
    CONNECTOR_TYPE_W3M_AUTH: 'ID_AUTH'
  },
  Vr = {
    ConnectorExplorerIds: {
      [Ae.CONNECTOR_ID.COINBASE]:
        'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa',
      [Ae.CONNECTOR_ID.COINBASE_SDK]:
        'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa',
      [Ae.CONNECTOR_ID.SAFE]: '225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f',
      [Ae.CONNECTOR_ID.LEDGER]: '19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927',
      [Ae.CONNECTOR_ID.OKX]: '971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709',
      [In.METMASK_CONNECTOR_NAME]:
        'c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96',
      [In.TRUST_CONNECTOR_NAME]: '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0',
      [In.SOLFLARE_CONNECTOR_NAME]:
        '1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79',
      [In.PHANTOM_CONNECTOR_NAME]:
        'a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393',
      [In.COIN98_CONNECTOR_NAME]:
        '2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01',
      [In.MAGIC_EDEN_CONNECTOR_NAME]:
        '8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6',
      [In.BACKPACK_CONNECTOR_NAME]:
        '2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0',
      [In.BITGET_CONNECTOR_NAME]:
        '38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662',
      [In.FRONTIER_CONNECTOR_NAME]:
        '85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041',
      [In.XVERSE_CONNECTOR_NAME]:
        '2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b',
      [In.LEATHER_CONNECTOR_NAME]:
        '483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13'
    },
    NetworkImageIds: {
      1: 'ba0ba0cd-17c6-4806-ad93-f9d174f17900',
      42161: '3bff954d-5cb0-47a0-9a23-d20192e74600',
      43114: '30c46e53-e989-45fb-4549-be3bd4eb3b00',
      56: '93564157-2e8e-4ce7-81df-b264dbee9b00',
      250: '06b26297-fe0c-4733-5d6b-ffa5498aac00',
      10: 'ab9c186a-c52f-464b-2906-ca59d760a400',
      137: '41d04d42-da3b-4453-8506-668cc0727900',
      5e3: 'e86fae9b-b770-4eea-e520-150e12c81100',
      295: '6a97d510-cac8-4e58-c7ce-e8681b044c00',
      11155111: 'e909ea0a-f92a-4512-c8fc-748044ea6800',
      84532: 'a18a7ecd-e307-4360-4746-283182228e00',
      1301: '4eeea7ef-0014-4649-5d1d-07271a80f600',
      130: '2257980a-3463-48c6-cbac-a42d2a956e00',
      10143: '0a728e83-bacb-46db-7844-948f05434900',
      100: '02b53f6a-e3d4-479e-1cb4-21178987d100',
      9001: 'f926ff41-260d-4028-635e-91913fc28e00',
      324: 'b310f07f-4ef7-49f3-7073-2a0a39685800',
      314: '5a73b3dd-af74-424e-cae0-0de859ee9400',
      4689: '34e68754-e536-40da-c153-6ef2e7188a00',
      1088: '3897a66d-40b9-4833-162f-a2c90531c900',
      1284: '161038da-44ae-4ec7-1208-0ea569454b00',
      1285: 'f1d73bb6-5450-4e18-38f7-fb6484264a00',
      7777777: '845c60df-d429-4991-e687-91ae45791600',
      42220: 'ab781bbc-ccc6-418d-d32d-789b15da1f00',
      8453: '7289c336-3981-4081-c5f4-efc26ac64a00',
      1313161554: '3ff73439-a619-4894-9262-4470c773a100',
      2020: 'b8101fc0-9c19-4b6f-ec65-f6dfff106e00',
      2021: 'b8101fc0-9c19-4b6f-ec65-f6dfff106e00',
      80094: 'e329c2c9-59b0-4a02-83e4-212ff3779900',
      2741: 'fc2427d1-5af9-4a9c-8da5-6f94627cd900',
      '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp': 'a1b58899-f671-4276-6a5e-56ca5bd59700',
      '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z': 'a1b58899-f671-4276-6a5e-56ca5bd59700',
      EtWTRABZaYq6iMfeYKouRu166VU2xqa1: 'a1b58899-f671-4276-6a5e-56ca5bd59700',
      '000000000019d6689c085ae165831e93': '0b4838db-0161-4ffe-022d-532bf03dba00',
      '000000000933ea01ad0ee984209779ba': '39354064-d79b-420b-065d-f980c4b78200'
    },
    ConnectorImageIds: {
      [Ae.CONNECTOR_ID.COINBASE]: '0c2840c3-5b04-4c44-9661-fbd4b49e1800',
      [Ae.CONNECTOR_ID.COINBASE_SDK]: '0c2840c3-5b04-4c44-9661-fbd4b49e1800',
      [Ae.CONNECTOR_ID.SAFE]: '461db637-8616-43ce-035a-d89b8a1d5800',
      [Ae.CONNECTOR_ID.LEDGER]: '54a1aa77-d202-4f8d-0fb2-5d2bb6db0300',
      [Ae.CONNECTOR_ID.WALLET_CONNECT]: 'ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400',
      [Ae.CONNECTOR_ID.INJECTED]: '07ba87ed-43aa-4adf-4540-9e6a2b9cae00'
    },
    ConnectorNamesMap: {
      [Ae.CONNECTOR_ID.INJECTED]: 'Browser Wallet',
      [Ae.CONNECTOR_ID.WALLET_CONNECT]: 'WalletConnect',
      [Ae.CONNECTOR_ID.COINBASE]: 'Coinbase',
      [Ae.CONNECTOR_ID.COINBASE_SDK]: 'Coinbase',
      [Ae.CONNECTOR_ID.LEDGER]: 'Ledger',
      [Ae.CONNECTOR_ID.SAFE]: 'Safe'
    },
    ConnectorTypesMap: {
      [Ae.CONNECTOR_ID.INJECTED]: 'INJECTED',
      [Ae.CONNECTOR_ID.WALLET_CONNECT]: 'WALLET_CONNECT',
      [Ae.CONNECTOR_ID.EIP6963]: 'ANNOUNCED',
      [Ae.CONNECTOR_ID.AUTH]: 'AUTH'
    }
  },
  V0 = {
    getCaipTokens(t) {
      if (!t) return
      const e = {}
      return (
        Object.entries(t).forEach(([n, r]) => {
          e[`${In.EIP155}:${n}`] = r
        }),
        e
      )
    },
    isLowerCaseMatch(t, e) {
      return (t == null ? void 0 : t.toLowerCase()) === (e == null ? void 0 : e.toLowerCase())
    }
  },
  La = {
    UniversalProviderErrors: {
      UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
        message: 'Unauthorized: origin not allowed',
        alertErrorKey: 'INVALID_APP_CONFIGURATION'
      },
      JWT_VALIDATION_ERROR: {
        message: 'JWT validation error: JWT Token is not yet valid',
        alertErrorKey: 'JWT_TOKEN_NOT_VALID'
      },
      INVALID_KEY: { message: 'Unauthorized: invalid key', alertErrorKey: 'INVALID_PROJECT_ID' }
    },
    ALERT_ERRORS: {
      SWITCH_NETWORK_NOT_FOUND: {
        shortMessage: 'Network Not Found',
        longMessage:
          "Network not found - please make sure it is included in 'networks' array in createAppKit function"
      },
      INVALID_APP_CONFIGURATION: {
        shortMessage: 'Invalid App Configuration',
        longMessage: () =>
          `Origin ${wie() ? window.origin : 'unknown'} not found on Allowlist - update configuration on cloud.reown.com`
      },
      SOCIALS_TIMEOUT: {
        shortMessage: 'Invalid App Configuration',
        longMessage: () =>
          'There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com'
      },
      JWT_TOKEN_NOT_VALID: {
        shortMessage: 'Session Expired',
        longMessage:
          'Invalid session found on UniversalProvider - please check your time settings and connect again'
      },
      INVALID_PROJECT_ID: {
        shortMessage: 'Invalid App Configuration',
        longMessage: 'Invalid Project ID - update configuration'
      },
      PROJECT_ID_NOT_CONFIGURED: {
        shortMessage: 'Project ID Not Configured',
        longMessage: 'Project ID Not Configured - update configuration on cloud.reown.com'
      }
    }
  }
function wie() {
  return typeof window < 'u'
}
const bie = {
    createLogger(t, e = 'error') {
      const n = Id({ level: e }),
        { logger: r } = wA({ opts: n })
      return (
        (r.error = (...s) => {
          for (const i of s)
            if (i instanceof Error) {
              t(i, ...s)
              return
            }
          t(void 0, ...s)
        }),
        r
      )
    }
  },
  vie = 'rpc.walletconnect.org'
function dx(t, e) {
  const n = new URL('https://rpc.walletconnect.org/v1/')
  return n.searchParams.set('chainId', t), n.searchParams.set('projectId', e), n.toString()
}
const fb = [
    'near:mainnet',
    'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
    'eip155:1101',
    'eip155:56',
    'eip155:42161',
    'eip155:7777777',
    'eip155:59144',
    'eip155:324',
    'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
    'eip155:5000',
    'solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz',
    'eip155:80084',
    'eip155:5003',
    'eip155:100',
    'eip155:8453',
    'eip155:42220',
    'eip155:1313161555',
    'eip155:17000',
    'eip155:1',
    'eip155:300',
    'eip155:1313161554',
    'eip155:1329',
    'eip155:84532',
    'eip155:421614',
    'eip155:11155111',
    'eip155:8217',
    'eip155:43114',
    'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
    'eip155:999999999',
    'eip155:11155420',
    'eip155:80002',
    'eip155:97',
    'eip155:43113',
    'eip155:137',
    'eip155:10',
    'eip155:1301',
    'bip122:000000000019d6689c085ae165831e93',
    'bip122:000000000933ea01ad0ee984209779ba'
  ],
  Xi = {
    extendRpcUrlWithProjectId(t, e) {
      let n = !1
      try {
        n = new URL(t).host === vie
      } catch {
        n = !1
      }
      if (n) {
        const r = new URL(t)
        return r.searchParams.has('projectId') || r.searchParams.set('projectId', e), r.toString()
      }
      return t
    },
    isCaipNetwork(t) {
      return 'chainNamespace' in t && 'caipNetworkId' in t
    },
    getChainNamespace(t) {
      return this.isCaipNetwork(t) ? t.chainNamespace : Ae.CHAIN.EVM
    },
    getCaipNetworkId(t) {
      return this.isCaipNetwork(t) ? t.caipNetworkId : `${Ae.CHAIN.EVM}:${t.id}`
    },
    getDefaultRpcUrl(t, e, n) {
      var s, i, o
      const r =
        (o = (i = (s = t.rpcUrls) == null ? void 0 : s.default) == null ? void 0 : i.http) == null
          ? void 0
          : o[0]
      return fb.includes(e) ? dx(e, n) : r || ''
    },
    extendCaipNetwork(t, { customNetworkImageUrls: e, projectId: n, customRpcUrls: r }) {
      var h, p, y, m, b
      const s = this.getChainNamespace(t),
        i = this.getCaipNetworkId(t),
        o = (h = t.rpcUrls.default.http) == null ? void 0 : h[0],
        a = this.getDefaultRpcUrl(t, i, n),
        c =
          ((m =
            (y = (p = t == null ? void 0 : t.rpcUrls) == null ? void 0 : p.chainDefault) == null
              ? void 0
              : y.http) == null
            ? void 0
            : m[0]) || o,
        u = ((b = r == null ? void 0 : r[i]) == null ? void 0 : b.map(I => I.url)) || [],
        l = [...u, a],
        d = [...u]
      return (
        c && !d.includes(c) && d.push(c),
        {
          ...t,
          chainNamespace: s,
          caipNetworkId: i,
          assets: { imageId: Vr.NetworkImageIds[t.id], imageUrl: e == null ? void 0 : e[t.id] },
          rpcUrls: { ...t.rpcUrls, default: { http: l }, chainDefault: { http: d } }
        }
      )
    },
    extendCaipNetworks(t, { customNetworkImageUrls: e, projectId: n, customRpcUrls: r }) {
      return t.map(s =>
        Xi.extendCaipNetwork(s, { customNetworkImageUrls: e, customRpcUrls: r, projectId: n })
      )
    },
    getViemTransport(t, e, n) {
      var s, i, o
      const r = []
      return (
        n == null ||
          n.forEach(a => {
            r.push(Vp(a.url, a.config))
          }),
        fb.includes(t.caipNetworkId) &&
          r.push(
            Vp(dx(t.caipNetworkId, e), {
              fetchOptions: { headers: { 'Content-Type': 'text/plain' } }
            })
          ),
        (o =
          (i = (s = t == null ? void 0 : t.rpcUrls) == null ? void 0 : s.default) == null
            ? void 0
            : i.http) == null ||
          o.forEach(a => {
            r.push(Vp(a))
          }),
        sS(r)
      )
    },
    extendWagmiTransports(t, e, n) {
      if (fb.includes(t.caipNetworkId)) {
        const r = this.getDefaultRpcUrl(t, t.caipNetworkId, e)
        return sS([n, Vp(r)])
      }
      return n
    },
    getUnsupportedNetwork(t) {
      return {
        id: t.split(':')[1],
        caipNetworkId: t,
        name: Ae.UNSUPPORTED_NETWORK_NAME,
        chainNamespace: t.split(':')[0],
        nativeCurrency: { name: '', decimals: 0, symbol: '' },
        rpcUrls: { default: { http: [] } }
      }
    },
    getCaipNetworkFromStorage(t) {
      var c
      const e = Ke.getActiveCaipNetworkId(),
        n = ne.getAllRequestedCaipNetworks(),
        r = Array.from(((c = ne.state.chains) == null ? void 0 : c.keys()) || []),
        s = e == null ? void 0 : e.split(':')[0],
        i = s ? r.includes(s) : !1,
        o = n == null ? void 0 : n.find(u => u.caipNetworkId === e)
      return i && !o && e ? this.getUnsupportedNetwork(e) : o || t || (n == null ? void 0 : n[0])
    }
  },
  Sm = { eip155: void 0, solana: void 0, polkadot: void 0, bip122: void 0 },
  gs = xn({ providers: { ...Sm }, providerIds: { ...Sm } }),
  on = {
    state: gs,
    subscribeKey(t, e) {
      return Yr(gs, t, e)
    },
    subscribe(t) {
      return Qr(gs, () => {
        t(gs)
      })
    },
    subscribeProviders(t) {
      return Qr(gs.providers, () => t(gs.providers))
    },
    setProvider(t, e) {
      e && (gs.providers[t] = tc(e))
    },
    getProvider(t) {
      return gs.providers[t]
    },
    setProviderId(t, e) {
      e && (gs.providerIds[t] = e)
    },
    getProviderId(t) {
      if (t) return gs.providerIds[t]
    },
    reset() {
      ;(gs.providers = { ...Sm }), (gs.providerIds = { ...Sm })
    },
    resetChain(t) {
      ;(gs.providers[t] = void 0), (gs.providerIds[t] = void 0)
    }
  },
  hx = { transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u, signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u },
  Sr = {
    set(t, e) {
      js.isClient && localStorage.setItem(`${rt.STORAGE_KEY}${t}`, e)
    },
    get(t) {
      return js.isClient ? localStorage.getItem(`${rt.STORAGE_KEY}${t}`) : null
    },
    delete(t, e) {
      js.isClient &&
        (e ? localStorage.removeItem(t) : localStorage.removeItem(`${rt.STORAGE_KEY}${t}`))
    }
  },
  gg = 30 * 1e3,
  js = {
    checkIfAllowedToTriggerEmail() {
      const t = Sr.get(rt.LAST_EMAIL_LOGIN_TIME)
      if (t) {
        const e = Date.now() - Number(t)
        if (e < gg) {
          const n = Math.ceil((gg - e) / 1e3)
          throw new Error(`Please try again after ${n} seconds`)
        }
      }
    },
    getTimeToNextEmailLogin() {
      const t = Sr.get(rt.LAST_EMAIL_LOGIN_TIME)
      if (t) {
        const e = Date.now() - Number(t)
        if (e < gg) return Math.ceil((gg - e) / 1e3)
      }
      return 0
    },
    checkIfRequestExists(t) {
      return Jn.NOT_SAFE_RPC_METHODS.includes(t.method) || Jn.SAFE_RPC_METHODS.includes(t.method)
    },
    getResponseType(t) {
      return typeof t == 'string' &&
        ((t == null ? void 0 : t.match(hx.transactionHash)) ||
          (t == null ? void 0 : t.match(hx.signedMessage)))
        ? rt.RPC_RESPONSE_TYPE_TX
        : rt.RPC_RESPONSE_TYPE_OBJECT
    },
    checkIfRequestIsSafe(t) {
      return Jn.SAFE_RPC_METHODS.includes(t.method)
    },
    isClient: typeof window < 'u'
  }
var Vt
;(function (t) {
  t.assertEqual = s => s
  function e(s) {}
  t.assertIs = e
  function n(s) {
    throw new Error()
  }
  ;(t.assertNever = n),
    (t.arrayToEnum = s => {
      const i = {}
      for (const o of s) i[o] = o
      return i
    }),
    (t.getValidEnumValues = s => {
      const i = t.objectKeys(s).filter(a => typeof s[s[a]] != 'number'),
        o = {}
      for (const a of i) o[a] = s[a]
      return t.objectValues(o)
    }),
    (t.objectValues = s =>
      t.objectKeys(s).map(function (i) {
        return s[i]
      })),
    (t.objectKeys =
      typeof Object.keys == 'function'
        ? s => Object.keys(s)
        : s => {
            const i = []
            for (const o in s) Object.prototype.hasOwnProperty.call(s, o) && i.push(o)
            return i
          }),
    (t.find = (s, i) => {
      for (const o of s) if (i(o)) return o
    }),
    (t.isInteger =
      typeof Number.isInteger == 'function'
        ? s => Number.isInteger(s)
        : s => typeof s == 'number' && isFinite(s) && Math.floor(s) === s)
  function r(s, i = ' | ') {
    return s.map(o => (typeof o == 'string' ? `'${o}'` : o)).join(i)
  }
  ;(t.joinValues = r),
    (t.jsonStringifyReplacer = (s, i) => (typeof i == 'bigint' ? i.toString() : i))
})(Vt || (Vt = {}))
var kv
;(function (t) {
  t.mergeShapes = (e, n) => ({ ...e, ...n })
})(kv || (kv = {}))
const Ze = Vt.arrayToEnum([
    'string',
    'nan',
    'number',
    'integer',
    'float',
    'boolean',
    'date',
    'bigint',
    'symbol',
    'function',
    'undefined',
    'null',
    'array',
    'object',
    'unknown',
    'promise',
    'void',
    'never',
    'map',
    'set'
  ]),
  Na = t => {
    switch (typeof t) {
      case 'undefined':
        return Ze.undefined
      case 'string':
        return Ze.string
      case 'number':
        return isNaN(t) ? Ze.nan : Ze.number
      case 'boolean':
        return Ze.boolean
      case 'function':
        return Ze.function
      case 'bigint':
        return Ze.bigint
      case 'symbol':
        return Ze.symbol
      case 'object':
        return Array.isArray(t)
          ? Ze.array
          : t === null
            ? Ze.null
            : t.then && typeof t.then == 'function' && t.catch && typeof t.catch == 'function'
              ? Ze.promise
              : typeof Map < 'u' && t instanceof Map
                ? Ze.map
                : typeof Set < 'u' && t instanceof Set
                  ? Ze.set
                  : typeof Date < 'u' && t instanceof Date
                    ? Ze.date
                    : Ze.object
      default:
        return Ze.unknown
    }
  },
  Re = Vt.arrayToEnum([
    'invalid_type',
    'invalid_literal',
    'custom',
    'invalid_union',
    'invalid_union_discriminator',
    'invalid_enum_value',
    'unrecognized_keys',
    'invalid_arguments',
    'invalid_return_type',
    'invalid_date',
    'invalid_string',
    'too_small',
    'too_big',
    'invalid_intersection_types',
    'not_multiple_of',
    'not_finite'
  ]),
  Eie = t => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, '$1:')
class Pi extends Error {
  constructor(e) {
    super(),
      (this.issues = []),
      (this.addIssue = r => {
        this.issues = [...this.issues, r]
      }),
      (this.addIssues = (r = []) => {
        this.issues = [...this.issues, ...r]
      })
    const n = new.target.prototype
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : (this.__proto__ = n),
      (this.name = 'ZodError'),
      (this.issues = e)
  }
  get errors() {
    return this.issues
  }
  format(e) {
    const n =
        e ||
        function (i) {
          return i.message
        },
      r = { _errors: [] },
      s = i => {
        for (const o of i.issues)
          if (o.code === 'invalid_union') o.unionErrors.map(s)
          else if (o.code === 'invalid_return_type') s(o.returnTypeError)
          else if (o.code === 'invalid_arguments') s(o.argumentsError)
          else if (o.path.length === 0) r._errors.push(n(o))
          else {
            let a = r,
              c = 0
            for (; c < o.path.length; ) {
              const u = o.path[c]
              c === o.path.length - 1
                ? ((a[u] = a[u] || { _errors: [] }), a[u]._errors.push(n(o)))
                : (a[u] = a[u] || { _errors: [] }),
                (a = a[u]),
                c++
            }
          }
      }
    return s(this), r
  }
  toString() {
    return this.message
  }
  get message() {
    return JSON.stringify(this.issues, Vt.jsonStringifyReplacer, 2)
  }
  get isEmpty() {
    return this.issues.length === 0
  }
  flatten(e = n => n.message) {
    const n = {},
      r = []
    for (const s of this.issues)
      s.path.length > 0
        ? ((n[s.path[0]] = n[s.path[0]] || []), n[s.path[0]].push(e(s)))
        : r.push(e(s))
    return { formErrors: r, fieldErrors: n }
  }
  get formErrors() {
    return this.flatten()
  }
}
Pi.create = t => new Pi(t)
const If = (t, e) => {
  let n
  switch (t.code) {
    case Re.invalid_type:
      t.received === Ze.undefined
        ? (n = 'Required')
        : (n = `Expected ${t.expected}, received ${t.received}`)
      break
    case Re.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected, Vt.jsonStringifyReplacer)}`
      break
    case Re.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${Vt.joinValues(t.keys, ', ')}`
      break
    case Re.invalid_union:
      n = 'Invalid input'
      break
    case Re.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${Vt.joinValues(t.options)}`
      break
    case Re.invalid_enum_value:
      n = `Invalid enum value. Expected ${Vt.joinValues(t.options)}, received '${t.received}'`
      break
    case Re.invalid_arguments:
      n = 'Invalid function arguments'
      break
    case Re.invalid_return_type:
      n = 'Invalid function return type'
      break
    case Re.invalid_date:
      n = 'Invalid date'
      break
    case Re.invalid_string:
      typeof t.validation == 'object'
        ? 'includes' in t.validation
          ? ((n = `Invalid input: must include "${t.validation.includes}"`),
            typeof t.validation.position == 'number' &&
              (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`))
          : 'startsWith' in t.validation
            ? (n = `Invalid input: must start with "${t.validation.startsWith}"`)
            : 'endsWith' in t.validation
              ? (n = `Invalid input: must end with "${t.validation.endsWith}"`)
              : Vt.assertNever(t.validation)
        : t.validation !== 'regex'
          ? (n = `Invalid ${t.validation}`)
          : (n = 'Invalid')
      break
    case Re.too_small:
      t.type === 'array'
        ? (n = `Array must contain ${t.exact ? 'exactly' : t.inclusive ? 'at least' : 'more than'} ${t.minimum} element(s)`)
        : t.type === 'string'
          ? (n = `String must contain ${t.exact ? 'exactly' : t.inclusive ? 'at least' : 'over'} ${t.minimum} character(s)`)
          : t.type === 'number'
            ? (n = `Number must be ${t.exact ? 'exactly equal to ' : t.inclusive ? 'greater than or equal to ' : 'greater than '}${t.minimum}`)
            : t.type === 'date'
              ? (n = `Date must be ${t.exact ? 'exactly equal to ' : t.inclusive ? 'greater than or equal to ' : 'greater than '}${new Date(Number(t.minimum))}`)
              : (n = 'Invalid input')
      break
    case Re.too_big:
      t.type === 'array'
        ? (n = `Array must contain ${t.exact ? 'exactly' : t.inclusive ? 'at most' : 'less than'} ${t.maximum} element(s)`)
        : t.type === 'string'
          ? (n = `String must contain ${t.exact ? 'exactly' : t.inclusive ? 'at most' : 'under'} ${t.maximum} character(s)`)
          : t.type === 'number'
            ? (n = `Number must be ${t.exact ? 'exactly' : t.inclusive ? 'less than or equal to' : 'less than'} ${t.maximum}`)
            : t.type === 'bigint'
              ? (n = `BigInt must be ${t.exact ? 'exactly' : t.inclusive ? 'less than or equal to' : 'less than'} ${t.maximum}`)
              : t.type === 'date'
                ? (n = `Date must be ${t.exact ? 'exactly' : t.inclusive ? 'smaller than or equal to' : 'smaller than'} ${new Date(Number(t.maximum))}`)
                : (n = 'Invalid input')
      break
    case Re.custom:
      n = 'Invalid input'
      break
    case Re.invalid_intersection_types:
      n = 'Intersection results could not be merged'
      break
    case Re.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`
      break
    case Re.not_finite:
      n = 'Number must be finite'
      break
    default:
      ;(n = e.defaultError), Vt.assertNever(t)
  }
  return { message: n }
}
let v8 = If
function Aie(t) {
  v8 = t
}
function Im() {
  return v8
}
const xm = t => {
    const { data: e, path: n, errorMaps: r, issueData: s } = t,
      i = [...n, ...(s.path || [])],
      o = { ...s, path: i }
    let a = ''
    const c = r
      .filter(u => !!u)
      .slice()
      .reverse()
    for (const u of c) a = u(o, { data: e, defaultError: a }).message
    return { ...s, path: i, message: s.message || a }
  },
  _ie = []
function et(t, e) {
  const n = xm({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, Im(), If].filter(r => !!r)
  })
  t.common.issues.push(n)
}
class Zr {
  constructor() {
    this.value = 'valid'
  }
  dirty() {
    this.value === 'valid' && (this.value = 'dirty')
  }
  abort() {
    this.value !== 'aborted' && (this.value = 'aborted')
  }
  static mergeArray(e, n) {
    const r = []
    for (const s of n) {
      if (s.status === 'aborted') return Ct
      s.status === 'dirty' && e.dirty(), r.push(s.value)
    }
    return { status: e.value, value: r }
  }
  static async mergeObjectAsync(e, n) {
    const r = []
    for (const s of n) r.push({ key: await s.key, value: await s.value })
    return Zr.mergeObjectSync(e, r)
  }
  static mergeObjectSync(e, n) {
    const r = {}
    for (const s of n) {
      const { key: i, value: o } = s
      if (i.status === 'aborted' || o.status === 'aborted') return Ct
      i.status === 'dirty' && e.dirty(),
        o.status === 'dirty' && e.dirty(),
        i.value !== '__proto__' && (typeof o.value < 'u' || s.alwaysSet) && (r[i.value] = o.value)
    }
    return { status: e.value, value: r }
  }
}
const Ct = Object.freeze({ status: 'aborted' }),
  E8 = t => ({ status: 'dirty', value: t }),
  ls = t => ({ status: 'valid', value: t }),
  Ov = t => t.status === 'aborted',
  Bv = t => t.status === 'dirty',
  xf = t => t.status === 'valid',
  Tm = t => typeof Promise < 'u' && t instanceof Promise
var ut
;(function (t) {
  ;(t.errToObj = e => (typeof e == 'string' ? { message: e } : e || {})),
    (t.toString = e => (typeof e == 'string' ? e : e == null ? void 0 : e.message))
})(ut || (ut = {}))
class uo {
  constructor(e, n, r, s) {
    ;(this._cachedPath = []), (this.parent = e), (this.data = n), (this._path = r), (this._key = s)
  }
  get path() {
    return (
      this._cachedPath.length ||
        (this._key instanceof Array
          ? this._cachedPath.push(...this._path, ...this._key)
          : this._cachedPath.push(...this._path, this._key)),
      this._cachedPath
    )
  }
}
const fx = (t, e) => {
  if (xf(e)) return { success: !0, data: e.value }
  if (!t.common.issues.length) throw new Error('Validation failed but no issues detected.')
  return {
    success: !1,
    get error() {
      if (this._error) return this._error
      const n = new Pi(t.common.issues)
      return (this._error = n), this._error
    }
  }
}
function It(t) {
  if (!t) return {}
  const { errorMap: e, invalid_type_error: n, required_error: r, description: s } = t
  if (e && (n || r))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
    )
  return e
    ? { errorMap: e, description: s }
    : {
        errorMap: (o, a) =>
          o.code !== 'invalid_type'
            ? { message: a.defaultError }
            : typeof a.data > 'u'
              ? { message: r ?? a.defaultError }
              : { message: n ?? a.defaultError },
        description: s
      }
}
class Dt {
  constructor(e) {
    ;(this.spa = this.safeParseAsync),
      (this._def = e),
      (this.parse = this.parse.bind(this)),
      (this.safeParse = this.safeParse.bind(this)),
      (this.parseAsync = this.parseAsync.bind(this)),
      (this.safeParseAsync = this.safeParseAsync.bind(this)),
      (this.spa = this.spa.bind(this)),
      (this.refine = this.refine.bind(this)),
      (this.refinement = this.refinement.bind(this)),
      (this.superRefine = this.superRefine.bind(this)),
      (this.optional = this.optional.bind(this)),
      (this.nullable = this.nullable.bind(this)),
      (this.nullish = this.nullish.bind(this)),
      (this.array = this.array.bind(this)),
      (this.promise = this.promise.bind(this)),
      (this.or = this.or.bind(this)),
      (this.and = this.and.bind(this)),
      (this.transform = this.transform.bind(this)),
      (this.brand = this.brand.bind(this)),
      (this.default = this.default.bind(this)),
      (this.catch = this.catch.bind(this)),
      (this.describe = this.describe.bind(this)),
      (this.pipe = this.pipe.bind(this)),
      (this.readonly = this.readonly.bind(this)),
      (this.isNullable = this.isNullable.bind(this)),
      (this.isOptional = this.isOptional.bind(this))
  }
  get description() {
    return this._def.description
  }
  _getType(e) {
    return Na(e.data)
  }
  _getOrReturnCtx(e, n) {
    return (
      n || {
        common: e.parent.common,
        data: e.data,
        parsedType: Na(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    )
  }
  _processInputParams(e) {
    return {
      status: new Zr(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: Na(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    }
  }
  _parseSync(e) {
    const n = this._parse(e)
    if (Tm(n)) throw new Error('Synchronous parse encountered promise.')
    return n
  }
  _parseAsync(e) {
    const n = this._parse(e)
    return Promise.resolve(n)
  }
  parse(e, n) {
    const r = this.safeParse(e, n)
    if (r.success) return r.data
    throw r.error
  }
  safeParse(e, n) {
    var r
    const s = {
        common: {
          issues: [],
          async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
          contextualErrorMap: n == null ? void 0 : n.errorMap
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: Na(e)
      },
      i = this._parseSync({ data: e, path: s.path, parent: s })
    return fx(s, i)
  }
  async parseAsync(e, n) {
    const r = await this.safeParseAsync(e, n)
    if (r.success) return r.data
    throw r.error
  }
  async safeParseAsync(e, n) {
    const r = {
        common: { issues: [], contextualErrorMap: n == null ? void 0 : n.errorMap, async: !0 },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: Na(e)
      },
      s = this._parse({ data: e, path: r.path, parent: r }),
      i = await (Tm(s) ? s : Promise.resolve(s))
    return fx(r, i)
  }
  refine(e, n) {
    const r = s =>
      typeof n == 'string' || typeof n > 'u' ? { message: n } : typeof n == 'function' ? n(s) : n
    return this._refinement((s, i) => {
      const o = e(s),
        a = () => i.addIssue({ code: Re.custom, ...r(s) })
      return typeof Promise < 'u' && o instanceof Promise
        ? o.then(c => (c ? !0 : (a(), !1)))
        : o
          ? !0
          : (a(), !1)
    })
  }
  refinement(e, n) {
    return this._refinement((r, s) =>
      e(r) ? !0 : (s.addIssue(typeof n == 'function' ? n(r, s) : n), !1)
    )
  }
  _refinement(e) {
    return new Oi({
      schema: this,
      typeName: pt.ZodEffects,
      effect: { type: 'refinement', refinement: e }
    })
  }
  superRefine(e) {
    return this._refinement(e)
  }
  optional() {
    return Qo.create(this, this._def)
  }
  nullable() {
    return vu.create(this, this._def)
  }
  nullish() {
    return this.nullable().optional()
  }
  array() {
    return Ri.create(this, this._def)
  }
  promise() {
    return ud.create(this, this._def)
  }
  or(e) {
    return Rf.create([this, e], this._def)
  }
  and(e) {
    return kf.create(this, e, this._def)
  }
  transform(e) {
    return new Oi({
      ...It(this._def),
      schema: this,
      typeName: pt.ZodEffects,
      effect: { type: 'transform', transform: e }
    })
  }
  default(e) {
    const n = typeof e == 'function' ? e : () => e
    return new Uf({ ...It(this._def), innerType: this, defaultValue: n, typeName: pt.ZodDefault })
  }
  brand() {
    return new _8({ typeName: pt.ZodBranded, type: this, ...It(this._def) })
  }
  catch(e) {
    const n = typeof e == 'function' ? e : () => e
    return new km({ ...It(this._def), innerType: this, catchValue: n, typeName: pt.ZodCatch })
  }
  describe(e) {
    const n = this.constructor
    return new n({ ...this._def, description: e })
  }
  pipe(e) {
    return _p.create(this, e)
  }
  readonly() {
    return Bm.create(this)
  }
  isOptional() {
    return this.safeParse(void 0).success
  }
  isNullable() {
    return this.safeParse(null).success
  }
}
const Cie = /^c[^\s-]{8,}$/i,
  Sie = /^[a-z][a-z0-9]*$/,
  Iie = /^[0-9A-HJKMNP-TV-Z]{26}$/,
  xie = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  Tie = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  Nie = '^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$'
let pb
const Pie =
    /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
  Rie =
    /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  kie = t =>
    t.precision
      ? t.offset
        ? new RegExp(
            `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
          )
        : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`)
      : t.precision === 0
        ? t.offset
          ? new RegExp('^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$')
          : new RegExp('^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$')
        : t.offset
          ? new RegExp(
              '^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$'
            )
          : new RegExp('^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$')
function Oie(t, e) {
  return !!(((e === 'v4' || !e) && Pie.test(t)) || ((e === 'v6' || !e) && Rie.test(t)))
}
class xi extends Dt {
  _parse(e) {
    if ((this._def.coerce && (e.data = String(e.data)), this._getType(e) !== Ze.string)) {
      const i = this._getOrReturnCtx(e)
      return et(i, { code: Re.invalid_type, expected: Ze.string, received: i.parsedType }), Ct
    }
    const r = new Zr()
    let s
    for (const i of this._def.checks)
      if (i.kind === 'min')
        e.data.length < i.value &&
          ((s = this._getOrReturnCtx(e, s)),
          et(s, {
            code: Re.too_small,
            minimum: i.value,
            type: 'string',
            inclusive: !0,
            exact: !1,
            message: i.message
          }),
          r.dirty())
      else if (i.kind === 'max')
        e.data.length > i.value &&
          ((s = this._getOrReturnCtx(e, s)),
          et(s, {
            code: Re.too_big,
            maximum: i.value,
            type: 'string',
            inclusive: !0,
            exact: !1,
            message: i.message
          }),
          r.dirty())
      else if (i.kind === 'length') {
        const o = e.data.length > i.value,
          a = e.data.length < i.value
        ;(o || a) &&
          ((s = this._getOrReturnCtx(e, s)),
          o
            ? et(s, {
                code: Re.too_big,
                maximum: i.value,
                type: 'string',
                inclusive: !0,
                exact: !0,
                message: i.message
              })
            : a &&
              et(s, {
                code: Re.too_small,
                minimum: i.value,
                type: 'string',
                inclusive: !0,
                exact: !0,
                message: i.message
              }),
          r.dirty())
      } else if (i.kind === 'email')
        Tie.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          et(s, { validation: 'email', code: Re.invalid_string, message: i.message }),
          r.dirty())
      else if (i.kind === 'emoji')
        pb || (pb = new RegExp(Nie, 'u')),
          pb.test(e.data) ||
            ((s = this._getOrReturnCtx(e, s)),
            et(s, { validation: 'emoji', code: Re.invalid_string, message: i.message }),
            r.dirty())
      else if (i.kind === 'uuid')
        xie.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          et(s, { validation: 'uuid', code: Re.invalid_string, message: i.message }),
          r.dirty())
      else if (i.kind === 'cuid')
        Cie.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          et(s, { validation: 'cuid', code: Re.invalid_string, message: i.message }),
          r.dirty())
      else if (i.kind === 'cuid2')
        Sie.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          et(s, { validation: 'cuid2', code: Re.invalid_string, message: i.message }),
          r.dirty())
      else if (i.kind === 'ulid')
        Iie.test(e.data) ||
          ((s = this._getOrReturnCtx(e, s)),
          et(s, { validation: 'ulid', code: Re.invalid_string, message: i.message }),
          r.dirty())
      else if (i.kind === 'url')
        try {
          new URL(e.data)
        } catch {
          ;(s = this._getOrReturnCtx(e, s)),
            et(s, { validation: 'url', code: Re.invalid_string, message: i.message }),
            r.dirty()
        }
      else
        i.kind === 'regex'
          ? ((i.regex.lastIndex = 0),
            i.regex.test(e.data) ||
              ((s = this._getOrReturnCtx(e, s)),
              et(s, { validation: 'regex', code: Re.invalid_string, message: i.message }),
              r.dirty()))
          : i.kind === 'trim'
            ? (e.data = e.data.trim())
            : i.kind === 'includes'
              ? e.data.includes(i.value, i.position) ||
                ((s = this._getOrReturnCtx(e, s)),
                et(s, {
                  code: Re.invalid_string,
                  validation: { includes: i.value, position: i.position },
                  message: i.message
                }),
                r.dirty())
              : i.kind === 'toLowerCase'
                ? (e.data = e.data.toLowerCase())
                : i.kind === 'toUpperCase'
                  ? (e.data = e.data.toUpperCase())
                  : i.kind === 'startsWith'
                    ? e.data.startsWith(i.value) ||
                      ((s = this._getOrReturnCtx(e, s)),
                      et(s, {
                        code: Re.invalid_string,
                        validation: { startsWith: i.value },
                        message: i.message
                      }),
                      r.dirty())
                    : i.kind === 'endsWith'
                      ? e.data.endsWith(i.value) ||
                        ((s = this._getOrReturnCtx(e, s)),
                        et(s, {
                          code: Re.invalid_string,
                          validation: { endsWith: i.value },
                          message: i.message
                        }),
                        r.dirty())
                      : i.kind === 'datetime'
                        ? kie(i).test(e.data) ||
                          ((s = this._getOrReturnCtx(e, s)),
                          et(s, {
                            code: Re.invalid_string,
                            validation: 'datetime',
                            message: i.message
                          }),
                          r.dirty())
                        : i.kind === 'ip'
                          ? Oie(e.data, i.version) ||
                            ((s = this._getOrReturnCtx(e, s)),
                            et(s, {
                              validation: 'ip',
                              code: Re.invalid_string,
                              message: i.message
                            }),
                            r.dirty())
                          : Vt.assertNever(i)
    return { status: r.value, value: e.data }
  }
  _regex(e, n, r) {
    return this.refinement(s => e.test(s), {
      validation: n,
      code: Re.invalid_string,
      ...ut.errToObj(r)
    })
  }
  _addCheck(e) {
    return new xi({ ...this._def, checks: [...this._def.checks, e] })
  }
  email(e) {
    return this._addCheck({ kind: 'email', ...ut.errToObj(e) })
  }
  url(e) {
    return this._addCheck({ kind: 'url', ...ut.errToObj(e) })
  }
  emoji(e) {
    return this._addCheck({ kind: 'emoji', ...ut.errToObj(e) })
  }
  uuid(e) {
    return this._addCheck({ kind: 'uuid', ...ut.errToObj(e) })
  }
  cuid(e) {
    return this._addCheck({ kind: 'cuid', ...ut.errToObj(e) })
  }
  cuid2(e) {
    return this._addCheck({ kind: 'cuid2', ...ut.errToObj(e) })
  }
  ulid(e) {
    return this._addCheck({ kind: 'ulid', ...ut.errToObj(e) })
  }
  ip(e) {
    return this._addCheck({ kind: 'ip', ...ut.errToObj(e) })
  }
  datetime(e) {
    var n
    return typeof e == 'string'
      ? this._addCheck({ kind: 'datetime', precision: null, offset: !1, message: e })
      : this._addCheck({
          kind: 'datetime',
          precision:
            typeof (e == null ? void 0 : e.precision) > 'u'
              ? null
              : e == null
                ? void 0
                : e.precision,
          offset: (n = e == null ? void 0 : e.offset) !== null && n !== void 0 ? n : !1,
          ...ut.errToObj(e == null ? void 0 : e.message)
        })
  }
  regex(e, n) {
    return this._addCheck({ kind: 'regex', regex: e, ...ut.errToObj(n) })
  }
  includes(e, n) {
    return this._addCheck({
      kind: 'includes',
      value: e,
      position: n == null ? void 0 : n.position,
      ...ut.errToObj(n == null ? void 0 : n.message)
    })
  }
  startsWith(e, n) {
    return this._addCheck({ kind: 'startsWith', value: e, ...ut.errToObj(n) })
  }
  endsWith(e, n) {
    return this._addCheck({ kind: 'endsWith', value: e, ...ut.errToObj(n) })
  }
  min(e, n) {
    return this._addCheck({ kind: 'min', value: e, ...ut.errToObj(n) })
  }
  max(e, n) {
    return this._addCheck({ kind: 'max', value: e, ...ut.errToObj(n) })
  }
  length(e, n) {
    return this._addCheck({ kind: 'length', value: e, ...ut.errToObj(n) })
  }
  nonempty(e) {
    return this.min(1, ut.errToObj(e))
  }
  trim() {
    return new xi({ ...this._def, checks: [...this._def.checks, { kind: 'trim' }] })
  }
  toLowerCase() {
    return new xi({ ...this._def, checks: [...this._def.checks, { kind: 'toLowerCase' }] })
  }
  toUpperCase() {
    return new xi({ ...this._def, checks: [...this._def.checks, { kind: 'toUpperCase' }] })
  }
  get isDatetime() {
    return !!this._def.checks.find(e => e.kind === 'datetime')
  }
  get isEmail() {
    return !!this._def.checks.find(e => e.kind === 'email')
  }
  get isURL() {
    return !!this._def.checks.find(e => e.kind === 'url')
  }
  get isEmoji() {
    return !!this._def.checks.find(e => e.kind === 'emoji')
  }
  get isUUID() {
    return !!this._def.checks.find(e => e.kind === 'uuid')
  }
  get isCUID() {
    return !!this._def.checks.find(e => e.kind === 'cuid')
  }
  get isCUID2() {
    return !!this._def.checks.find(e => e.kind === 'cuid2')
  }
  get isULID() {
    return !!this._def.checks.find(e => e.kind === 'ulid')
  }
  get isIP() {
    return !!this._def.checks.find(e => e.kind === 'ip')
  }
  get minLength() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'min' && (e === null || n.value > e) && (e = n.value)
    return e
  }
  get maxLength() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'max' && (e === null || n.value < e) && (e = n.value)
    return e
  }
}
xi.create = t => {
  var e
  return new xi({
    checks: [],
    typeName: pt.ZodString,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...It(t)
  })
}
function Bie(t, e) {
  const n = (t.toString().split('.')[1] || '').length,
    r = (e.toString().split('.')[1] || '').length,
    s = n > r ? n : r,
    i = parseInt(t.toFixed(s).replace('.', '')),
    o = parseInt(e.toFixed(s).replace('.', ''))
  return (i % o) / Math.pow(10, s)
}
class nc extends Dt {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte), (this.step = this.multipleOf)
  }
  _parse(e) {
    if ((this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== Ze.number)) {
      const i = this._getOrReturnCtx(e)
      return et(i, { code: Re.invalid_type, expected: Ze.number, received: i.parsedType }), Ct
    }
    let r
    const s = new Zr()
    for (const i of this._def.checks)
      i.kind === 'int'
        ? Vt.isInteger(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          et(r, {
            code: Re.invalid_type,
            expected: 'integer',
            received: 'float',
            message: i.message
          }),
          s.dirty())
        : i.kind === 'min'
          ? (i.inclusive ? e.data < i.value : e.data <= i.value) &&
            ((r = this._getOrReturnCtx(e, r)),
            et(r, {
              code: Re.too_small,
              minimum: i.value,
              type: 'number',
              inclusive: i.inclusive,
              exact: !1,
              message: i.message
            }),
            s.dirty())
          : i.kind === 'max'
            ? (i.inclusive ? e.data > i.value : e.data >= i.value) &&
              ((r = this._getOrReturnCtx(e, r)),
              et(r, {
                code: Re.too_big,
                maximum: i.value,
                type: 'number',
                inclusive: i.inclusive,
                exact: !1,
                message: i.message
              }),
              s.dirty())
            : i.kind === 'multipleOf'
              ? Bie(e.data, i.value) !== 0 &&
                ((r = this._getOrReturnCtx(e, r)),
                et(r, { code: Re.not_multiple_of, multipleOf: i.value, message: i.message }),
                s.dirty())
              : i.kind === 'finite'
                ? Number.isFinite(e.data) ||
                  ((r = this._getOrReturnCtx(e, r)),
                  et(r, { code: Re.not_finite, message: i.message }),
                  s.dirty())
                : Vt.assertNever(i)
    return { status: s.value, value: e.data }
  }
  gte(e, n) {
    return this.setLimit('min', e, !0, ut.toString(n))
  }
  gt(e, n) {
    return this.setLimit('min', e, !1, ut.toString(n))
  }
  lte(e, n) {
    return this.setLimit('max', e, !0, ut.toString(n))
  }
  lt(e, n) {
    return this.setLimit('max', e, !1, ut.toString(n))
  }
  setLimit(e, n, r, s) {
    return new nc({
      ...this._def,
      checks: [...this._def.checks, { kind: e, value: n, inclusive: r, message: ut.toString(s) }]
    })
  }
  _addCheck(e) {
    return new nc({ ...this._def, checks: [...this._def.checks, e] })
  }
  int(e) {
    return this._addCheck({ kind: 'int', message: ut.toString(e) })
  }
  positive(e) {
    return this._addCheck({ kind: 'min', value: 0, inclusive: !1, message: ut.toString(e) })
  }
  negative(e) {
    return this._addCheck({ kind: 'max', value: 0, inclusive: !1, message: ut.toString(e) })
  }
  nonpositive(e) {
    return this._addCheck({ kind: 'max', value: 0, inclusive: !0, message: ut.toString(e) })
  }
  nonnegative(e) {
    return this._addCheck({ kind: 'min', value: 0, inclusive: !0, message: ut.toString(e) })
  }
  multipleOf(e, n) {
    return this._addCheck({ kind: 'multipleOf', value: e, message: ut.toString(n) })
  }
  finite(e) {
    return this._addCheck({ kind: 'finite', message: ut.toString(e) })
  }
  safe(e) {
    return this._addCheck({
      kind: 'min',
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: ut.toString(e)
    })._addCheck({
      kind: 'max',
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: ut.toString(e)
    })
  }
  get minValue() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'min' && (e === null || n.value > e) && (e = n.value)
    return e
  }
  get maxValue() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'max' && (e === null || n.value < e) && (e = n.value)
    return e
  }
  get isInt() {
    return !!this._def.checks.find(
      e => e.kind === 'int' || (e.kind === 'multipleOf' && Vt.isInteger(e.value))
    )
  }
  get isFinite() {
    let e = null,
      n = null
    for (const r of this._def.checks) {
      if (r.kind === 'finite' || r.kind === 'int' || r.kind === 'multipleOf') return !0
      r.kind === 'min'
        ? (n === null || r.value > n) && (n = r.value)
        : r.kind === 'max' && (e === null || r.value < e) && (e = r.value)
    }
    return Number.isFinite(n) && Number.isFinite(e)
  }
}
nc.create = t =>
  new nc({
    checks: [],
    typeName: pt.ZodNumber,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...It(t)
  })
class rc extends Dt {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte)
  }
  _parse(e) {
    if ((this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== Ze.bigint)) {
      const i = this._getOrReturnCtx(e)
      return et(i, { code: Re.invalid_type, expected: Ze.bigint, received: i.parsedType }), Ct
    }
    let r
    const s = new Zr()
    for (const i of this._def.checks)
      i.kind === 'min'
        ? (i.inclusive ? e.data < i.value : e.data <= i.value) &&
          ((r = this._getOrReturnCtx(e, r)),
          et(r, {
            code: Re.too_small,
            type: 'bigint',
            minimum: i.value,
            inclusive: i.inclusive,
            message: i.message
          }),
          s.dirty())
        : i.kind === 'max'
          ? (i.inclusive ? e.data > i.value : e.data >= i.value) &&
            ((r = this._getOrReturnCtx(e, r)),
            et(r, {
              code: Re.too_big,
              type: 'bigint',
              maximum: i.value,
              inclusive: i.inclusive,
              message: i.message
            }),
            s.dirty())
          : i.kind === 'multipleOf'
            ? e.data % i.value !== BigInt(0) &&
              ((r = this._getOrReturnCtx(e, r)),
              et(r, { code: Re.not_multiple_of, multipleOf: i.value, message: i.message }),
              s.dirty())
            : Vt.assertNever(i)
    return { status: s.value, value: e.data }
  }
  gte(e, n) {
    return this.setLimit('min', e, !0, ut.toString(n))
  }
  gt(e, n) {
    return this.setLimit('min', e, !1, ut.toString(n))
  }
  lte(e, n) {
    return this.setLimit('max', e, !0, ut.toString(n))
  }
  lt(e, n) {
    return this.setLimit('max', e, !1, ut.toString(n))
  }
  setLimit(e, n, r, s) {
    return new rc({
      ...this._def,
      checks: [...this._def.checks, { kind: e, value: n, inclusive: r, message: ut.toString(s) }]
    })
  }
  _addCheck(e) {
    return new rc({ ...this._def, checks: [...this._def.checks, e] })
  }
  positive(e) {
    return this._addCheck({ kind: 'min', value: BigInt(0), inclusive: !1, message: ut.toString(e) })
  }
  negative(e) {
    return this._addCheck({ kind: 'max', value: BigInt(0), inclusive: !1, message: ut.toString(e) })
  }
  nonpositive(e) {
    return this._addCheck({ kind: 'max', value: BigInt(0), inclusive: !0, message: ut.toString(e) })
  }
  nonnegative(e) {
    return this._addCheck({ kind: 'min', value: BigInt(0), inclusive: !0, message: ut.toString(e) })
  }
  multipleOf(e, n) {
    return this._addCheck({ kind: 'multipleOf', value: e, message: ut.toString(n) })
  }
  get minValue() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'min' && (e === null || n.value > e) && (e = n.value)
    return e
  }
  get maxValue() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'max' && (e === null || n.value < e) && (e = n.value)
    return e
  }
}
rc.create = t => {
  var e
  return new rc({
    checks: [],
    typeName: pt.ZodBigInt,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...It(t)
  })
}
class Tf extends Dt {
  _parse(e) {
    if ((this._def.coerce && (e.data = !!e.data), this._getType(e) !== Ze.boolean)) {
      const r = this._getOrReturnCtx(e)
      return et(r, { code: Re.invalid_type, expected: Ze.boolean, received: r.parsedType }), Ct
    }
    return ls(e.data)
  }
}
Tf.create = t =>
  new Tf({ typeName: pt.ZodBoolean, coerce: (t == null ? void 0 : t.coerce) || !1, ...It(t) })
class wu extends Dt {
  _parse(e) {
    if ((this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== Ze.date)) {
      const i = this._getOrReturnCtx(e)
      return et(i, { code: Re.invalid_type, expected: Ze.date, received: i.parsedType }), Ct
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e)
      return et(i, { code: Re.invalid_date }), Ct
    }
    const r = new Zr()
    let s
    for (const i of this._def.checks)
      i.kind === 'min'
        ? e.data.getTime() < i.value &&
          ((s = this._getOrReturnCtx(e, s)),
          et(s, {
            code: Re.too_small,
            message: i.message,
            inclusive: !0,
            exact: !1,
            minimum: i.value,
            type: 'date'
          }),
          r.dirty())
        : i.kind === 'max'
          ? e.data.getTime() > i.value &&
            ((s = this._getOrReturnCtx(e, s)),
            et(s, {
              code: Re.too_big,
              message: i.message,
              inclusive: !0,
              exact: !1,
              maximum: i.value,
              type: 'date'
            }),
            r.dirty())
          : Vt.assertNever(i)
    return { status: r.value, value: new Date(e.data.getTime()) }
  }
  _addCheck(e) {
    return new wu({ ...this._def, checks: [...this._def.checks, e] })
  }
  min(e, n) {
    return this._addCheck({ kind: 'min', value: e.getTime(), message: ut.toString(n) })
  }
  max(e, n) {
    return this._addCheck({ kind: 'max', value: e.getTime(), message: ut.toString(n) })
  }
  get minDate() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'min' && (e === null || n.value > e) && (e = n.value)
    return e != null ? new Date(e) : null
  }
  get maxDate() {
    let e = null
    for (const n of this._def.checks)
      n.kind === 'max' && (e === null || n.value < e) && (e = n.value)
    return e != null ? new Date(e) : null
  }
}
wu.create = t =>
  new wu({
    checks: [],
    coerce: (t == null ? void 0 : t.coerce) || !1,
    typeName: pt.ZodDate,
    ...It(t)
  })
class Nm extends Dt {
  _parse(e) {
    if (this._getType(e) !== Ze.symbol) {
      const r = this._getOrReturnCtx(e)
      return et(r, { code: Re.invalid_type, expected: Ze.symbol, received: r.parsedType }), Ct
    }
    return ls(e.data)
  }
}
Nm.create = t => new Nm({ typeName: pt.ZodSymbol, ...It(t) })
class Nf extends Dt {
  _parse(e) {
    if (this._getType(e) !== Ze.undefined) {
      const r = this._getOrReturnCtx(e)
      return et(r, { code: Re.invalid_type, expected: Ze.undefined, received: r.parsedType }), Ct
    }
    return ls(e.data)
  }
}
Nf.create = t => new Nf({ typeName: pt.ZodUndefined, ...It(t) })
class Pf extends Dt {
  _parse(e) {
    if (this._getType(e) !== Ze.null) {
      const r = this._getOrReturnCtx(e)
      return et(r, { code: Re.invalid_type, expected: Ze.null, received: r.parsedType }), Ct
    }
    return ls(e.data)
  }
}
Pf.create = t => new Pf({ typeName: pt.ZodNull, ...It(t) })
class cd extends Dt {
  constructor() {
    super(...arguments), (this._any = !0)
  }
  _parse(e) {
    return ls(e.data)
  }
}
cd.create = t => new cd({ typeName: pt.ZodAny, ...It(t) })
class eu extends Dt {
  constructor() {
    super(...arguments), (this._unknown = !0)
  }
  _parse(e) {
    return ls(e.data)
  }
}
eu.create = t => new eu({ typeName: pt.ZodUnknown, ...It(t) })
class Xo extends Dt {
  _parse(e) {
    const n = this._getOrReturnCtx(e)
    return et(n, { code: Re.invalid_type, expected: Ze.never, received: n.parsedType }), Ct
  }
}
Xo.create = t => new Xo({ typeName: pt.ZodNever, ...It(t) })
class Pm extends Dt {
  _parse(e) {
    if (this._getType(e) !== Ze.undefined) {
      const r = this._getOrReturnCtx(e)
      return et(r, { code: Re.invalid_type, expected: Ze.void, received: r.parsedType }), Ct
    }
    return ls(e.data)
  }
}
Pm.create = t => new Pm({ typeName: pt.ZodVoid, ...It(t) })
class Ri extends Dt {
  _parse(e) {
    const { ctx: n, status: r } = this._processInputParams(e),
      s = this._def
    if (n.parsedType !== Ze.array)
      return et(n, { code: Re.invalid_type, expected: Ze.array, received: n.parsedType }), Ct
    if (s.exactLength !== null) {
      const o = n.data.length > s.exactLength.value,
        a = n.data.length < s.exactLength.value
      ;(o || a) &&
        (et(n, {
          code: o ? Re.too_big : Re.too_small,
          minimum: a ? s.exactLength.value : void 0,
          maximum: o ? s.exactLength.value : void 0,
          type: 'array',
          inclusive: !0,
          exact: !0,
          message: s.exactLength.message
        }),
        r.dirty())
    }
    if (
      (s.minLength !== null &&
        n.data.length < s.minLength.value &&
        (et(n, {
          code: Re.too_small,
          minimum: s.minLength.value,
          type: 'array',
          inclusive: !0,
          exact: !1,
          message: s.minLength.message
        }),
        r.dirty()),
      s.maxLength !== null &&
        n.data.length > s.maxLength.value &&
        (et(n, {
          code: Re.too_big,
          maximum: s.maxLength.value,
          type: 'array',
          inclusive: !0,
          exact: !1,
          message: s.maxLength.message
        }),
        r.dirty()),
      n.common.async)
    )
      return Promise.all(
        [...n.data].map((o, a) => s.type._parseAsync(new uo(n, o, n.path, a)))
      ).then(o => Zr.mergeArray(r, o))
    const i = [...n.data].map((o, a) => s.type._parseSync(new uo(n, o, n.path, a)))
    return Zr.mergeArray(r, i)
  }
  get element() {
    return this._def.type
  }
  min(e, n) {
    return new Ri({ ...this._def, minLength: { value: e, message: ut.toString(n) } })
  }
  max(e, n) {
    return new Ri({ ...this._def, maxLength: { value: e, message: ut.toString(n) } })
  }
  length(e, n) {
    return new Ri({ ...this._def, exactLength: { value: e, message: ut.toString(n) } })
  }
  nonempty(e) {
    return this.min(1, e)
  }
}
Ri.create = (t, e) =>
  new Ri({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: pt.ZodArray,
    ...It(e)
  })
function cl(t) {
  if (t instanceof On) {
    const e = {}
    for (const n in t.shape) {
      const r = t.shape[n]
      e[n] = Qo.create(cl(r))
    }
    return new On({ ...t._def, shape: () => e })
  } else
    return t instanceof Ri
      ? new Ri({ ...t._def, type: cl(t.element) })
      : t instanceof Qo
        ? Qo.create(cl(t.unwrap()))
        : t instanceof vu
          ? vu.create(cl(t.unwrap()))
          : t instanceof lo
            ? lo.create(t.items.map(e => cl(e)))
            : t
}
class On extends Dt {
  constructor() {
    super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend)
  }
  _getCached() {
    if (this._cached !== null) return this._cached
    const e = this._def.shape(),
      n = Vt.objectKeys(e)
    return (this._cached = { shape: e, keys: n })
  }
  _parse(e) {
    if (this._getType(e) !== Ze.object) {
      const u = this._getOrReturnCtx(e)
      return et(u, { code: Re.invalid_type, expected: Ze.object, received: u.parsedType }), Ct
    }
    const { status: r, ctx: s } = this._processInputParams(e),
      { shape: i, keys: o } = this._getCached(),
      a = []
    if (!(this._def.catchall instanceof Xo && this._def.unknownKeys === 'strip'))
      for (const u in s.data) o.includes(u) || a.push(u)
    const c = []
    for (const u of o) {
      const l = i[u],
        d = s.data[u]
      c.push({
        key: { status: 'valid', value: u },
        value: l._parse(new uo(s, d, s.path, u)),
        alwaysSet: u in s.data
      })
    }
    if (this._def.catchall instanceof Xo) {
      const u = this._def.unknownKeys
      if (u === 'passthrough')
        for (const l of a)
          c.push({
            key: { status: 'valid', value: l },
            value: { status: 'valid', value: s.data[l] }
          })
      else if (u === 'strict')
        a.length > 0 && (et(s, { code: Re.unrecognized_keys, keys: a }), r.dirty())
      else if (u !== 'strip')
        throw new Error('Internal ZodObject error: invalid unknownKeys value.')
    } else {
      const u = this._def.catchall
      for (const l of a) {
        const d = s.data[l]
        c.push({
          key: { status: 'valid', value: l },
          value: u._parse(new uo(s, d, s.path, l)),
          alwaysSet: l in s.data
        })
      }
    }
    return s.common.async
      ? Promise.resolve()
          .then(async () => {
            const u = []
            for (const l of c) {
              const d = await l.key
              u.push({ key: d, value: await l.value, alwaysSet: l.alwaysSet })
            }
            return u
          })
          .then(u => Zr.mergeObjectSync(r, u))
      : Zr.mergeObjectSync(r, c)
  }
  get shape() {
    return this._def.shape()
  }
  strict(e) {
    return (
      ut.errToObj,
      new On({
        ...this._def,
        unknownKeys: 'strict',
        ...(e !== void 0
          ? {
              errorMap: (n, r) => {
                var s, i, o, a
                const c =
                  (o =
                    (i = (s = this._def).errorMap) === null || i === void 0
                      ? void 0
                      : i.call(s, n, r).message) !== null && o !== void 0
                    ? o
                    : r.defaultError
                return n.code === 'unrecognized_keys'
                  ? { message: (a = ut.errToObj(e).message) !== null && a !== void 0 ? a : c }
                  : { message: c }
              }
            }
          : {})
      })
    )
  }
  strip() {
    return new On({ ...this._def, unknownKeys: 'strip' })
  }
  passthrough() {
    return new On({ ...this._def, unknownKeys: 'passthrough' })
  }
  extend(e) {
    return new On({ ...this._def, shape: () => ({ ...this._def.shape(), ...e }) })
  }
  merge(e) {
    return new On({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
      typeName: pt.ZodObject
    })
  }
  setKey(e, n) {
    return this.augment({ [e]: n })
  }
  catchall(e) {
    return new On({ ...this._def, catchall: e })
  }
  pick(e) {
    const n = {}
    return (
      Vt.objectKeys(e).forEach(r => {
        e[r] && this.shape[r] && (n[r] = this.shape[r])
      }),
      new On({ ...this._def, shape: () => n })
    )
  }
  omit(e) {
    const n = {}
    return (
      Vt.objectKeys(this.shape).forEach(r => {
        e[r] || (n[r] = this.shape[r])
      }),
      new On({ ...this._def, shape: () => n })
    )
  }
  deepPartial() {
    return cl(this)
  }
  partial(e) {
    const n = {}
    return (
      Vt.objectKeys(this.shape).forEach(r => {
        const s = this.shape[r]
        e && !e[r] ? (n[r] = s) : (n[r] = s.optional())
      }),
      new On({ ...this._def, shape: () => n })
    )
  }
  required(e) {
    const n = {}
    return (
      Vt.objectKeys(this.shape).forEach(r => {
        if (e && !e[r]) n[r] = this.shape[r]
        else {
          let i = this.shape[r]
          for (; i instanceof Qo; ) i = i._def.innerType
          n[r] = i
        }
      }),
      new On({ ...this._def, shape: () => n })
    )
  }
  keyof() {
    return A8(Vt.objectKeys(this.shape))
  }
}
On.create = (t, e) =>
  new On({
    shape: () => t,
    unknownKeys: 'strip',
    catchall: Xo.create(),
    typeName: pt.ZodObject,
    ...It(e)
  })
On.strictCreate = (t, e) =>
  new On({
    shape: () => t,
    unknownKeys: 'strict',
    catchall: Xo.create(),
    typeName: pt.ZodObject,
    ...It(e)
  })
On.lazycreate = (t, e) =>
  new On({
    shape: t,
    unknownKeys: 'strip',
    catchall: Xo.create(),
    typeName: pt.ZodObject,
    ...It(e)
  })
class Rf extends Dt {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e),
      r = this._def.options
    function s(i) {
      for (const a of i) if (a.result.status === 'valid') return a.result
      for (const a of i)
        if (a.result.status === 'dirty')
          return n.common.issues.push(...a.ctx.common.issues), a.result
      const o = i.map(a => new Pi(a.ctx.common.issues))
      return et(n, { code: Re.invalid_union, unionErrors: o }), Ct
    }
    if (n.common.async)
      return Promise.all(
        r.map(async i => {
          const o = { ...n, common: { ...n.common, issues: [] }, parent: null }
          return { result: await i._parseAsync({ data: n.data, path: n.path, parent: o }), ctx: o }
        })
      ).then(s)
    {
      let i
      const o = []
      for (const c of r) {
        const u = { ...n, common: { ...n.common, issues: [] }, parent: null },
          l = c._parseSync({ data: n.data, path: n.path, parent: u })
        if (l.status === 'valid') return l
        l.status === 'dirty' && !i && (i = { result: l, ctx: u }),
          u.common.issues.length && o.push(u.common.issues)
      }
      if (i) return n.common.issues.push(...i.ctx.common.issues), i.result
      const a = o.map(c => new Pi(c))
      return et(n, { code: Re.invalid_union, unionErrors: a }), Ct
    }
  }
  get options() {
    return this._def.options
  }
}
Rf.create = (t, e) => new Rf({ options: t, typeName: pt.ZodUnion, ...It(e) })
const $g = t =>
  t instanceof Bf
    ? $g(t.schema)
    : t instanceof Oi
      ? $g(t.innerType())
      : t instanceof Df
        ? [t.value]
        : t instanceof sc
          ? t.options
          : t instanceof Mf
            ? Object.keys(t.enum)
            : t instanceof Uf
              ? $g(t._def.innerType)
              : t instanceof Nf
                ? [void 0]
                : t instanceof Pf
                  ? [null]
                  : null
class G0 extends Dt {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e)
    if (n.parsedType !== Ze.object)
      return et(n, { code: Re.invalid_type, expected: Ze.object, received: n.parsedType }), Ct
    const r = this.discriminator,
      s = n.data[r],
      i = this.optionsMap.get(s)
    return i
      ? n.common.async
        ? i._parseAsync({ data: n.data, path: n.path, parent: n })
        : i._parseSync({ data: n.data, path: n.path, parent: n })
      : (et(n, {
          code: Re.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [r]
        }),
        Ct)
  }
  get discriminator() {
    return this._def.discriminator
  }
  get options() {
    return this._def.options
  }
  get optionsMap() {
    return this._def.optionsMap
  }
  static create(e, n, r) {
    const s = new Map()
    for (const i of n) {
      const o = $g(i.shape[e])
      if (!o)
        throw new Error(
          `A discriminator value for key \`${e}\` could not be extracted from all schema options`
        )
      for (const a of o) {
        if (s.has(a))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`)
        s.set(a, i)
      }
    }
    return new G0({
      typeName: pt.ZodDiscriminatedUnion,
      discriminator: e,
      options: n,
      optionsMap: s,
      ...It(r)
    })
  }
}
function Dv(t, e) {
  const n = Na(t),
    r = Na(e)
  if (t === e) return { valid: !0, data: t }
  if (n === Ze.object && r === Ze.object) {
    const s = Vt.objectKeys(e),
      i = Vt.objectKeys(t).filter(a => s.indexOf(a) !== -1),
      o = { ...t, ...e }
    for (const a of i) {
      const c = Dv(t[a], e[a])
      if (!c.valid) return { valid: !1 }
      o[a] = c.data
    }
    return { valid: !0, data: o }
  } else if (n === Ze.array && r === Ze.array) {
    if (t.length !== e.length) return { valid: !1 }
    const s = []
    for (let i = 0; i < t.length; i++) {
      const o = t[i],
        a = e[i],
        c = Dv(o, a)
      if (!c.valid) return { valid: !1 }
      s.push(c.data)
    }
    return { valid: !0, data: s }
  } else return n === Ze.date && r === Ze.date && +t == +e ? { valid: !0, data: t } : { valid: !1 }
}
class kf extends Dt {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e),
      s = (i, o) => {
        if (Ov(i) || Ov(o)) return Ct
        const a = Dv(i.value, o.value)
        return a.valid
          ? ((Bv(i) || Bv(o)) && n.dirty(), { status: n.value, value: a.data })
          : (et(r, { code: Re.invalid_intersection_types }), Ct)
      }
    return r.common.async
      ? Promise.all([
          this._def.left._parseAsync({ data: r.data, path: r.path, parent: r }),
          this._def.right._parseAsync({ data: r.data, path: r.path, parent: r })
        ]).then(([i, o]) => s(i, o))
      : s(
          this._def.left._parseSync({ data: r.data, path: r.path, parent: r }),
          this._def.right._parseSync({ data: r.data, path: r.path, parent: r })
        )
  }
}
kf.create = (t, e, n) => new kf({ left: t, right: e, typeName: pt.ZodIntersection, ...It(n) })
class lo extends Dt {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e)
    if (r.parsedType !== Ze.array)
      return et(r, { code: Re.invalid_type, expected: Ze.array, received: r.parsedType }), Ct
    if (r.data.length < this._def.items.length)
      return (
        et(r, {
          code: Re.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: 'array'
        }),
        Ct
      )
    !this._def.rest &&
      r.data.length > this._def.items.length &&
      (et(r, {
        code: Re.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: 'array'
      }),
      n.dirty())
    const i = [...r.data]
      .map((o, a) => {
        const c = this._def.items[a] || this._def.rest
        return c ? c._parse(new uo(r, o, r.path, a)) : null
      })
      .filter(o => !!o)
    return r.common.async ? Promise.all(i).then(o => Zr.mergeArray(n, o)) : Zr.mergeArray(n, i)
  }
  get items() {
    return this._def.items
  }
  rest(e) {
    return new lo({ ...this._def, rest: e })
  }
}
lo.create = (t, e) => {
  if (!Array.isArray(t)) throw new Error('You must pass an array of schemas to z.tuple([ ... ])')
  return new lo({ items: t, typeName: pt.ZodTuple, rest: null, ...It(e) })
}
class Of extends Dt {
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e)
    if (r.parsedType !== Ze.object)
      return et(r, { code: Re.invalid_type, expected: Ze.object, received: r.parsedType }), Ct
    const s = [],
      i = this._def.keyType,
      o = this._def.valueType
    for (const a in r.data)
      s.push({
        key: i._parse(new uo(r, a, r.path, a)),
        value: o._parse(new uo(r, r.data[a], r.path, a))
      })
    return r.common.async ? Zr.mergeObjectAsync(n, s) : Zr.mergeObjectSync(n, s)
  }
  get element() {
    return this._def.valueType
  }
  static create(e, n, r) {
    return n instanceof Dt
      ? new Of({ keyType: e, valueType: n, typeName: pt.ZodRecord, ...It(r) })
      : new Of({ keyType: xi.create(), valueType: e, typeName: pt.ZodRecord, ...It(n) })
  }
}
class Rm extends Dt {
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e)
    if (r.parsedType !== Ze.map)
      return et(r, { code: Re.invalid_type, expected: Ze.map, received: r.parsedType }), Ct
    const s = this._def.keyType,
      i = this._def.valueType,
      o = [...r.data.entries()].map(([a, c], u) => ({
        key: s._parse(new uo(r, a, r.path, [u, 'key'])),
        value: i._parse(new uo(r, c, r.path, [u, 'value']))
      }))
    if (r.common.async) {
      const a = new Map()
      return Promise.resolve().then(async () => {
        for (const c of o) {
          const u = await c.key,
            l = await c.value
          if (u.status === 'aborted' || l.status === 'aborted') return Ct
          ;(u.status === 'dirty' || l.status === 'dirty') && n.dirty(), a.set(u.value, l.value)
        }
        return { status: n.value, value: a }
      })
    } else {
      const a = new Map()
      for (const c of o) {
        const u = c.key,
          l = c.value
        if (u.status === 'aborted' || l.status === 'aborted') return Ct
        ;(u.status === 'dirty' || l.status === 'dirty') && n.dirty(), a.set(u.value, l.value)
      }
      return { status: n.value, value: a }
    }
  }
}
Rm.create = (t, e, n) => new Rm({ valueType: e, keyType: t, typeName: pt.ZodMap, ...It(n) })
class bu extends Dt {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e)
    if (r.parsedType !== Ze.set)
      return et(r, { code: Re.invalid_type, expected: Ze.set, received: r.parsedType }), Ct
    const s = this._def
    s.minSize !== null &&
      r.data.size < s.minSize.value &&
      (et(r, {
        code: Re.too_small,
        minimum: s.minSize.value,
        type: 'set',
        inclusive: !0,
        exact: !1,
        message: s.minSize.message
      }),
      n.dirty()),
      s.maxSize !== null &&
        r.data.size > s.maxSize.value &&
        (et(r, {
          code: Re.too_big,
          maximum: s.maxSize.value,
          type: 'set',
          inclusive: !0,
          exact: !1,
          message: s.maxSize.message
        }),
        n.dirty())
    const i = this._def.valueType
    function o(c) {
      const u = new Set()
      for (const l of c) {
        if (l.status === 'aborted') return Ct
        l.status === 'dirty' && n.dirty(), u.add(l.value)
      }
      return { status: n.value, value: u }
    }
    const a = [...r.data.values()].map((c, u) => i._parse(new uo(r, c, r.path, u)))
    return r.common.async ? Promise.all(a).then(c => o(c)) : o(a)
  }
  min(e, n) {
    return new bu({ ...this._def, minSize: { value: e, message: ut.toString(n) } })
  }
  max(e, n) {
    return new bu({ ...this._def, maxSize: { value: e, message: ut.toString(n) } })
  }
  size(e, n) {
    return this.min(e, n).max(e, n)
  }
  nonempty(e) {
    return this.min(1, e)
  }
}
bu.create = (t, e) =>
  new bu({ valueType: t, minSize: null, maxSize: null, typeName: pt.ZodSet, ...It(e) })
class kl extends Dt {
  constructor() {
    super(...arguments), (this.validate = this.implement)
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e)
    if (n.parsedType !== Ze.function)
      return et(n, { code: Re.invalid_type, expected: Ze.function, received: n.parsedType }), Ct
    function r(a, c) {
      return xm({
        data: a,
        path: n.path,
        errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, Im(), If].filter(u => !!u),
        issueData: { code: Re.invalid_arguments, argumentsError: c }
      })
    }
    function s(a, c) {
      return xm({
        data: a,
        path: n.path,
        errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, Im(), If].filter(u => !!u),
        issueData: { code: Re.invalid_return_type, returnTypeError: c }
      })
    }
    const i = { errorMap: n.common.contextualErrorMap },
      o = n.data
    if (this._def.returns instanceof ud) {
      const a = this
      return ls(async function (...c) {
        const u = new Pi([]),
          l = await a._def.args.parseAsync(c, i).catch(p => {
            throw (u.addIssue(r(c, p)), u)
          }),
          d = await Reflect.apply(o, this, l)
        return await a._def.returns._def.type.parseAsync(d, i).catch(p => {
          throw (u.addIssue(s(d, p)), u)
        })
      })
    } else {
      const a = this
      return ls(function (...c) {
        const u = a._def.args.safeParse(c, i)
        if (!u.success) throw new Pi([r(c, u.error)])
        const l = Reflect.apply(o, this, u.data),
          d = a._def.returns.safeParse(l, i)
        if (!d.success) throw new Pi([s(l, d.error)])
        return d.data
      })
    }
  }
  parameters() {
    return this._def.args
  }
  returnType() {
    return this._def.returns
  }
  args(...e) {
    return new kl({ ...this._def, args: lo.create(e).rest(eu.create()) })
  }
  returns(e) {
    return new kl({ ...this._def, returns: e })
  }
  implement(e) {
    return this.parse(e)
  }
  strictImplement(e) {
    return this.parse(e)
  }
  static create(e, n, r) {
    return new kl({
      args: e || lo.create([]).rest(eu.create()),
      returns: n || eu.create(),
      typeName: pt.ZodFunction,
      ...It(r)
    })
  }
}
class Bf extends Dt {
  get schema() {
    return this._def.getter()
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e)
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n })
  }
}
Bf.create = (t, e) => new Bf({ getter: t, typeName: pt.ZodLazy, ...It(e) })
class Df extends Dt {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e)
      return et(n, { received: n.data, code: Re.invalid_literal, expected: this._def.value }), Ct
    }
    return { status: 'valid', value: e.data }
  }
  get value() {
    return this._def.value
  }
}
Df.create = (t, e) => new Df({ value: t, typeName: pt.ZodLiteral, ...It(e) })
function A8(t, e) {
  return new sc({ values: t, typeName: pt.ZodEnum, ...It(e) })
}
class sc extends Dt {
  _parse(e) {
    if (typeof e.data != 'string') {
      const n = this._getOrReturnCtx(e),
        r = this._def.values
      return (
        et(n, { expected: Vt.joinValues(r), received: n.parsedType, code: Re.invalid_type }), Ct
      )
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const n = this._getOrReturnCtx(e),
        r = this._def.values
      return et(n, { received: n.data, code: Re.invalid_enum_value, options: r }), Ct
    }
    return ls(e.data)
  }
  get options() {
    return this._def.values
  }
  get enum() {
    const e = {}
    for (const n of this._def.values) e[n] = n
    return e
  }
  get Values() {
    const e = {}
    for (const n of this._def.values) e[n] = n
    return e
  }
  get Enum() {
    const e = {}
    for (const n of this._def.values) e[n] = n
    return e
  }
  extract(e) {
    return sc.create(e)
  }
  exclude(e) {
    return sc.create(this.options.filter(n => !e.includes(n)))
  }
}
sc.create = A8
class Mf extends Dt {
  _parse(e) {
    const n = Vt.getValidEnumValues(this._def.values),
      r = this._getOrReturnCtx(e)
    if (r.parsedType !== Ze.string && r.parsedType !== Ze.number) {
      const s = Vt.objectValues(n)
      return (
        et(r, { expected: Vt.joinValues(s), received: r.parsedType, code: Re.invalid_type }), Ct
      )
    }
    if (n.indexOf(e.data) === -1) {
      const s = Vt.objectValues(n)
      return et(r, { received: r.data, code: Re.invalid_enum_value, options: s }), Ct
    }
    return ls(e.data)
  }
  get enum() {
    return this._def.values
  }
}
Mf.create = (t, e) => new Mf({ values: t, typeName: pt.ZodNativeEnum, ...It(e) })
class ud extends Dt {
  unwrap() {
    return this._def.type
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e)
    if (n.parsedType !== Ze.promise && n.common.async === !1)
      return et(n, { code: Re.invalid_type, expected: Ze.promise, received: n.parsedType }), Ct
    const r = n.parsedType === Ze.promise ? n.data : Promise.resolve(n.data)
    return ls(
      r.then(s =>
        this._def.type.parseAsync(s, { path: n.path, errorMap: n.common.contextualErrorMap })
      )
    )
  }
}
ud.create = (t, e) => new ud({ type: t, typeName: pt.ZodPromise, ...It(e) })
class Oi extends Dt {
  innerType() {
    return this._def.schema
  }
  sourceType() {
    return this._def.schema._def.typeName === pt.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e),
      s = this._def.effect || null,
      i = {
        addIssue: o => {
          et(r, o), o.fatal ? n.abort() : n.dirty()
        },
        get path() {
          return r.path
        }
      }
    if (((i.addIssue = i.addIssue.bind(i)), s.type === 'preprocess')) {
      const o = s.transform(r.data, i)
      return r.common.issues.length
        ? { status: 'dirty', value: r.data }
        : r.common.async
          ? Promise.resolve(o).then(a =>
              this._def.schema._parseAsync({ data: a, path: r.path, parent: r })
            )
          : this._def.schema._parseSync({ data: o, path: r.path, parent: r })
    }
    if (s.type === 'refinement') {
      const o = a => {
        const c = s.refinement(a, i)
        if (r.common.async) return Promise.resolve(c)
        if (c instanceof Promise)
          throw new Error(
            'Async refinement encountered during synchronous parse operation. Use .parseAsync instead.'
          )
        return a
      }
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({ data: r.data, path: r.path, parent: r })
        return a.status === 'aborted'
          ? Ct
          : (a.status === 'dirty' && n.dirty(), o(a.value), { status: n.value, value: a.value })
      } else
        return this._def.schema
          ._parseAsync({ data: r.data, path: r.path, parent: r })
          .then(a =>
            a.status === 'aborted'
              ? Ct
              : (a.status === 'dirty' && n.dirty(),
                o(a.value).then(() => ({ status: n.value, value: a.value })))
          )
    }
    if (s.type === 'transform')
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({ data: r.data, path: r.path, parent: r })
        if (!xf(o)) return o
        const a = s.transform(o.value, i)
        if (a instanceof Promise)
          throw new Error(
            'Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.'
          )
        return { status: n.value, value: a }
      } else
        return this._def.schema
          ._parseAsync({ data: r.data, path: r.path, parent: r })
          .then(o =>
            xf(o)
              ? Promise.resolve(s.transform(o.value, i)).then(a => ({ status: n.value, value: a }))
              : o
          )
    Vt.assertNever(s)
  }
}
Oi.create = (t, e, n) => new Oi({ schema: t, typeName: pt.ZodEffects, effect: e, ...It(n) })
Oi.createWithPreprocess = (t, e, n) =>
  new Oi({
    schema: e,
    effect: { type: 'preprocess', transform: t },
    typeName: pt.ZodEffects,
    ...It(n)
  })
class Qo extends Dt {
  _parse(e) {
    return this._getType(e) === Ze.undefined ? ls(void 0) : this._def.innerType._parse(e)
  }
  unwrap() {
    return this._def.innerType
  }
}
Qo.create = (t, e) => new Qo({ innerType: t, typeName: pt.ZodOptional, ...It(e) })
class vu extends Dt {
  _parse(e) {
    return this._getType(e) === Ze.null ? ls(null) : this._def.innerType._parse(e)
  }
  unwrap() {
    return this._def.innerType
  }
}
vu.create = (t, e) => new vu({ innerType: t, typeName: pt.ZodNullable, ...It(e) })
class Uf extends Dt {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e)
    let r = n.data
    return (
      n.parsedType === Ze.undefined && (r = this._def.defaultValue()),
      this._def.innerType._parse({ data: r, path: n.path, parent: n })
    )
  }
  removeDefault() {
    return this._def.innerType
  }
}
Uf.create = (t, e) =>
  new Uf({
    innerType: t,
    typeName: pt.ZodDefault,
    defaultValue: typeof e.default == 'function' ? e.default : () => e.default,
    ...It(e)
  })
class km extends Dt {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e),
      r = { ...n, common: { ...n.common, issues: [] } },
      s = this._def.innerType._parse({ data: r.data, path: r.path, parent: { ...r } })
    return Tm(s)
      ? s.then(i => ({
          status: 'valid',
          value:
            i.status === 'valid'
              ? i.value
              : this._def.catchValue({
                  get error() {
                    return new Pi(r.common.issues)
                  },
                  input: r.data
                })
        }))
      : {
          status: 'valid',
          value:
            s.status === 'valid'
              ? s.value
              : this._def.catchValue({
                  get error() {
                    return new Pi(r.common.issues)
                  },
                  input: r.data
                })
        }
  }
  removeCatch() {
    return this._def.innerType
  }
}
km.create = (t, e) =>
  new km({
    innerType: t,
    typeName: pt.ZodCatch,
    catchValue: typeof e.catch == 'function' ? e.catch : () => e.catch,
    ...It(e)
  })
class Om extends Dt {
  _parse(e) {
    if (this._getType(e) !== Ze.nan) {
      const r = this._getOrReturnCtx(e)
      return et(r, { code: Re.invalid_type, expected: Ze.nan, received: r.parsedType }), Ct
    }
    return { status: 'valid', value: e.data }
  }
}
Om.create = t => new Om({ typeName: pt.ZodNaN, ...It(t) })
const Die = Symbol('zod_brand')
class _8 extends Dt {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e),
      r = n.data
    return this._def.type._parse({ data: r, path: n.path, parent: n })
  }
  unwrap() {
    return this._def.type
  }
}
class _p extends Dt {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e)
    if (r.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({ data: r.data, path: r.path, parent: r })
        return i.status === 'aborted'
          ? Ct
          : i.status === 'dirty'
            ? (n.dirty(), E8(i.value))
            : this._def.out._parseAsync({ data: i.value, path: r.path, parent: r })
      })()
    {
      const s = this._def.in._parseSync({ data: r.data, path: r.path, parent: r })
      return s.status === 'aborted'
        ? Ct
        : s.status === 'dirty'
          ? (n.dirty(), { status: 'dirty', value: s.value })
          : this._def.out._parseSync({ data: s.value, path: r.path, parent: r })
    }
  }
  static create(e, n) {
    return new _p({ in: e, out: n, typeName: pt.ZodPipeline })
  }
}
class Bm extends Dt {
  _parse(e) {
    const n = this._def.innerType._parse(e)
    return xf(n) && (n.value = Object.freeze(n.value)), n
  }
}
Bm.create = (t, e) => new Bm({ innerType: t, typeName: pt.ZodReadonly, ...It(e) })
const C8 = (t, e = {}, n) =>
    t
      ? cd.create().superRefine((r, s) => {
          var i, o
          if (!t(r)) {
            const a = typeof e == 'function' ? e(r) : typeof e == 'string' ? { message: e } : e,
              c =
                (o = (i = a.fatal) !== null && i !== void 0 ? i : n) !== null && o !== void 0
                  ? o
                  : !0,
              u = typeof a == 'string' ? { message: a } : a
            s.addIssue({ code: 'custom', ...u, fatal: c })
          }
        })
      : cd.create(),
  Mie = { object: On.lazycreate }
var pt
;(function (t) {
  ;(t.ZodString = 'ZodString'),
    (t.ZodNumber = 'ZodNumber'),
    (t.ZodNaN = 'ZodNaN'),
    (t.ZodBigInt = 'ZodBigInt'),
    (t.ZodBoolean = 'ZodBoolean'),
    (t.ZodDate = 'ZodDate'),
    (t.ZodSymbol = 'ZodSymbol'),
    (t.ZodUndefined = 'ZodUndefined'),
    (t.ZodNull = 'ZodNull'),
    (t.ZodAny = 'ZodAny'),
    (t.ZodUnknown = 'ZodUnknown'),
    (t.ZodNever = 'ZodNever'),
    (t.ZodVoid = 'ZodVoid'),
    (t.ZodArray = 'ZodArray'),
    (t.ZodObject = 'ZodObject'),
    (t.ZodUnion = 'ZodUnion'),
    (t.ZodDiscriminatedUnion = 'ZodDiscriminatedUnion'),
    (t.ZodIntersection = 'ZodIntersection'),
    (t.ZodTuple = 'ZodTuple'),
    (t.ZodRecord = 'ZodRecord'),
    (t.ZodMap = 'ZodMap'),
    (t.ZodSet = 'ZodSet'),
    (t.ZodFunction = 'ZodFunction'),
    (t.ZodLazy = 'ZodLazy'),
    (t.ZodLiteral = 'ZodLiteral'),
    (t.ZodEnum = 'ZodEnum'),
    (t.ZodEffects = 'ZodEffects'),
    (t.ZodNativeEnum = 'ZodNativeEnum'),
    (t.ZodOptional = 'ZodOptional'),
    (t.ZodNullable = 'ZodNullable'),
    (t.ZodDefault = 'ZodDefault'),
    (t.ZodCatch = 'ZodCatch'),
    (t.ZodPromise = 'ZodPromise'),
    (t.ZodBranded = 'ZodBranded'),
    (t.ZodPipeline = 'ZodPipeline'),
    (t.ZodReadonly = 'ZodReadonly')
})(pt || (pt = {}))
const Uie = (t, e = { message: `Input not instance of ${t.name}` }) => C8(n => n instanceof t, e),
  S8 = xi.create,
  I8 = nc.create,
  Lie = Om.create,
  $ie = rc.create,
  x8 = Tf.create,
  Fie = wu.create,
  jie = Nm.create,
  Hie = Nf.create,
  qie = Pf.create,
  zie = cd.create,
  Wie = eu.create,
  Kie = Xo.create,
  Vie = Pm.create,
  Gie = Ri.create,
  Qie = On.create,
  Zie = On.strictCreate,
  Yie = Rf.create,
  Jie = G0.create,
  Xie = kf.create,
  eoe = lo.create,
  toe = Of.create,
  noe = Rm.create,
  roe = bu.create,
  soe = kl.create,
  ioe = Bf.create,
  ooe = Df.create,
  aoe = sc.create,
  coe = Mf.create,
  uoe = ud.create,
  px = Oi.create,
  loe = Qo.create,
  doe = vu.create,
  hoe = Oi.createWithPreprocess,
  foe = _p.create,
  poe = () => S8().optional(),
  goe = () => I8().optional(),
  moe = () => x8().optional(),
  yoe = {
    string: t => xi.create({ ...t, coerce: !0 }),
    number: t => nc.create({ ...t, coerce: !0 }),
    boolean: t => Tf.create({ ...t, coerce: !0 }),
    bigint: t => rc.create({ ...t, coerce: !0 }),
    date: t => wu.create({ ...t, coerce: !0 })
  },
  woe = Ct
var G = Object.freeze({
  __proto__: null,
  defaultErrorMap: If,
  setErrorMap: Aie,
  getErrorMap: Im,
  makeIssue: xm,
  EMPTY_PATH: _ie,
  addIssueToContext: et,
  ParseStatus: Zr,
  INVALID: Ct,
  DIRTY: E8,
  OK: ls,
  isAborted: Ov,
  isDirty: Bv,
  isValid: xf,
  isAsync: Tm,
  get util() {
    return Vt
  },
  get objectUtil() {
    return kv
  },
  ZodParsedType: Ze,
  getParsedType: Na,
  ZodType: Dt,
  ZodString: xi,
  ZodNumber: nc,
  ZodBigInt: rc,
  ZodBoolean: Tf,
  ZodDate: wu,
  ZodSymbol: Nm,
  ZodUndefined: Nf,
  ZodNull: Pf,
  ZodAny: cd,
  ZodUnknown: eu,
  ZodNever: Xo,
  ZodVoid: Pm,
  ZodArray: Ri,
  ZodObject: On,
  ZodUnion: Rf,
  ZodDiscriminatedUnion: G0,
  ZodIntersection: kf,
  ZodTuple: lo,
  ZodRecord: Of,
  ZodMap: Rm,
  ZodSet: bu,
  ZodFunction: kl,
  ZodLazy: Bf,
  ZodLiteral: Df,
  ZodEnum: sc,
  ZodNativeEnum: Mf,
  ZodPromise: ud,
  ZodEffects: Oi,
  ZodTransformer: Oi,
  ZodOptional: Qo,
  ZodNullable: vu,
  ZodDefault: Uf,
  ZodCatch: km,
  ZodNaN: Om,
  BRAND: Die,
  ZodBranded: _8,
  ZodPipeline: _p,
  ZodReadonly: Bm,
  custom: C8,
  Schema: Dt,
  ZodSchema: Dt,
  late: Mie,
  get ZodFirstPartyTypeKind() {
    return pt
  },
  coerce: yoe,
  any: zie,
  array: Gie,
  bigint: $ie,
  boolean: x8,
  date: Fie,
  discriminatedUnion: Jie,
  effect: px,
  enum: aoe,
  function: soe,
  instanceof: Uie,
  intersection: Xie,
  lazy: ioe,
  literal: ooe,
  map: noe,
  nan: Lie,
  nativeEnum: coe,
  never: Kie,
  null: qie,
  nullable: doe,
  number: I8,
  object: Qie,
  oboolean: moe,
  onumber: goe,
  optional: loe,
  ostring: poe,
  pipeline: foe,
  preprocess: hoe,
  promise: uoe,
  record: toe,
  set: roe,
  strictObject: Zie,
  string: S8,
  symbol: jie,
  transformer: px,
  tuple: eoe,
  undefined: Hie,
  union: Yie,
  unknown: Wie,
  void: Vie,
  NEVER: woe,
  ZodIssueCode: Re,
  quotelessJson: Eie,
  ZodError: Pi
})
const Ln = G.object({ message: G.string() })
function Je(t) {
  return G.literal(rt[t])
}
G.object({
  accessList: G.array(G.string()),
  blockHash: G.string().nullable(),
  blockNumber: G.string().nullable(),
  chainId: G.string().or(G.number()),
  from: G.string(),
  gas: G.string(),
  hash: G.string(),
  input: G.string().nullable(),
  maxFeePerGas: G.string(),
  maxPriorityFeePerGas: G.string(),
  nonce: G.string(),
  r: G.string(),
  s: G.string(),
  to: G.string(),
  transactionIndex: G.string().nullable(),
  type: G.string(),
  v: G.string(),
  value: G.string()
})
const boe = G.object({ chainId: G.string().or(G.number()) }),
  voe = G.object({ email: G.string().email() }),
  Eoe = G.object({ otp: G.string() }),
  Aoe = G.object({ uri: G.string() }),
  _oe = G.object({
    chainId: G.optional(G.string().or(G.number())),
    preferredAccountType: G.optional(G.string())
  }),
  Coe = G.object({ provider: G.enum(['google', 'github', 'apple', 'facebook', 'x', 'discord']) }),
  Soe = G.object({ email: G.string().email() }),
  Ioe = G.object({ otp: G.string() }),
  xoe = G.object({ otp: G.string() }),
  Toe = G.object({
    themeMode: G.optional(G.enum(['light', 'dark'])),
    themeVariables: G.optional(G.record(G.string(), G.string().or(G.number()))),
    w3mThemeVariables: G.optional(G.record(G.string(), G.string()))
  }),
  Noe = G.object({
    metadata: G.object({
      name: G.string(),
      description: G.string(),
      url: G.string(),
      icons: G.array(G.string())
    }).optional(),
    sdkVersion: G.string().optional(),
    sdkType: G.string().optional(),
    projectId: G.string()
  }),
  Poe = G.object({ type: G.string() }),
  Roe = G.object({ action: G.enum(['VERIFY_DEVICE', 'VERIFY_OTP', 'CONNECT']) }),
  koe = G.object({ url: G.string() }),
  Ooe = G.object({ userName: G.string() }),
  Boe = G.object({
    email: G.string().optional().nullable(),
    address: G.string(),
    chainId: G.string().or(G.number()),
    accounts: G.array(
      G.object({
        address: G.string(),
        type: G.enum([Jn.ACCOUNT_TYPES.EOA, Jn.ACCOUNT_TYPES.SMART_ACCOUNT])
      })
    ).optional(),
    userName: G.string().optional().nullable()
  }),
  Doe = G.object({ action: G.enum(['VERIFY_PRIMARY_OTP', 'VERIFY_SECONDARY_OTP']) }),
  Moe = G.object({
    email: G.string().email().optional().nullable(),
    address: G.string(),
    chainId: G.string().or(G.number()),
    smartAccountDeployed: G.optional(G.boolean()),
    accounts: G.array(
      G.object({
        address: G.string(),
        type: G.enum([Jn.ACCOUNT_TYPES.EOA, Jn.ACCOUNT_TYPES.SMART_ACCOUNT])
      })
    ).optional(),
    preferredAccountType: G.optional(G.string())
  }),
  Uoe = G.object({ uri: G.string() }),
  Loe = G.object({ isConnected: G.boolean() }),
  $oe = G.object({ chainId: G.string().or(G.number()) }),
  Foe = G.object({ chainId: G.string().or(G.number()) }),
  joe = G.object({ newEmail: G.string().email() }),
  Hoe = G.object({ smartAccountEnabledNetworks: G.array(G.number()) })
G.object({ address: G.string(), isDeployed: G.boolean() })
const qoe = G.object({ version: G.string().optional() }),
  zoe = G.object({ type: G.string(), address: G.string() }),
  Woe = G.any(),
  Koe = G.object({ method: G.literal('eth_accounts') }),
  Voe = G.object({ method: G.literal('eth_blockNumber') }),
  Goe = G.object({ method: G.literal('eth_call'), params: G.array(G.any()) }),
  Qoe = G.object({ method: G.literal('eth_chainId') }),
  Zoe = G.object({ method: G.literal('eth_estimateGas'), params: G.array(G.any()) }),
  Yoe = G.object({ method: G.literal('eth_feeHistory'), params: G.array(G.any()) }),
  Joe = G.object({ method: G.literal('eth_gasPrice') }),
  Xoe = G.object({ method: G.literal('eth_getAccount'), params: G.array(G.any()) }),
  eae = G.object({ method: G.literal('eth_getBalance'), params: G.array(G.any()) }),
  tae = G.object({ method: G.literal('eth_getBlockByHash'), params: G.array(G.any()) }),
  nae = G.object({ method: G.literal('eth_getBlockByNumber'), params: G.array(G.any()) }),
  rae = G.object({ method: G.literal('eth_getBlockReceipts'), params: G.array(G.any()) }),
  sae = G.object({
    method: G.literal('eth_getBlockTransactionCountByHash'),
    params: G.array(G.any())
  }),
  iae = G.object({
    method: G.literal('eth_getBlockTransactionCountByNumber'),
    params: G.array(G.any())
  }),
  oae = G.object({ method: G.literal('eth_getCode'), params: G.array(G.any()) }),
  aae = G.object({ method: G.literal('eth_getFilterChanges'), params: G.array(G.any()) }),
  cae = G.object({ method: G.literal('eth_getFilterLogs'), params: G.array(G.any()) }),
  uae = G.object({ method: G.literal('eth_getLogs'), params: G.array(G.any()) }),
  lae = G.object({ method: G.literal('eth_getProof'), params: G.array(G.any()) }),
  dae = G.object({ method: G.literal('eth_getStorageAt'), params: G.array(G.any()) }),
  hae = G.object({
    method: G.literal('eth_getTransactionByBlockHashAndIndex'),
    params: G.array(G.any())
  }),
  fae = G.object({
    method: G.literal('eth_getTransactionByBlockNumberAndIndex'),
    params: G.array(G.any())
  }),
  pae = G.object({ method: G.literal('eth_getTransactionByHash'), params: G.array(G.any()) }),
  gae = G.object({ method: G.literal('eth_getTransactionCount'), params: G.array(G.any()) }),
  mae = G.object({ method: G.literal('eth_getTransactionReceipt'), params: G.array(G.any()) }),
  yae = G.object({ method: G.literal('eth_getUncleCountByBlockHash'), params: G.array(G.any()) }),
  wae = G.object({ method: G.literal('eth_getUncleCountByBlockNumber'), params: G.array(G.any()) }),
  bae = G.object({ method: G.literal('eth_maxPriorityFeePerGas') }),
  vae = G.object({ method: G.literal('eth_newBlockFilter') }),
  Eae = G.object({ method: G.literal('eth_newFilter'), params: G.array(G.any()) }),
  Aae = G.object({ method: G.literal('eth_newPendingTransactionFilter') }),
  _ae = G.object({ method: G.literal('eth_sendRawTransaction'), params: G.array(G.any()) }),
  Cae = G.object({ method: G.literal('eth_syncing'), params: G.array(G.any()) }),
  Sae = G.object({ method: G.literal('eth_uninstallFilter'), params: G.array(G.any()) }),
  gx = G.object({ method: G.literal('personal_sign'), params: G.array(G.any()) }),
  Iae = G.object({ method: G.literal('eth_signTypedData_v4'), params: G.array(G.any()) }),
  xae = G.object({ method: G.literal('eth_sendTransaction'), params: G.array(G.any()) }),
  Tae = G.object({
    method: G.literal('solana_signMessage'),
    params: G.object({ message: G.string(), pubkey: G.string() })
  }),
  Nae = G.object({
    method: G.literal('solana_signTransaction'),
    params: G.object({ transaction: G.string() })
  }),
  Pae = G.object({
    method: G.literal('solana_signAllTransactions'),
    params: G.object({ transactions: G.array(G.string()) })
  }),
  Rae = G.object({
    method: G.literal('solana_signAndSendTransaction'),
    params: G.object({
      transaction: G.string(),
      options: G.object({
        skipPreflight: G.boolean().optional(),
        preflightCommitment: G.enum([
          'processed',
          'confirmed',
          'finalized',
          'recent',
          'single',
          'singleGossip',
          'root',
          'max'
        ]).optional(),
        maxRetries: G.number().optional(),
        minContextSlot: G.number().optional()
      }).optional()
    })
  }),
  kae = G.object({
    method: G.literal('wallet_sendCalls'),
    params: G.array(
      G.object({
        chainId: G.string().or(G.number()).optional(),
        from: G.string().optional(),
        version: G.string().optional(),
        capabilities: G.any().optional(),
        calls: G.array(
          G.object({
            to: G.string().startsWith('0x'),
            data: G.string().startsWith('0x').optional(),
            value: G.string().optional()
          })
        )
      })
    )
  }),
  Oae = G.object({ method: G.literal('wallet_getCallsStatus'), params: G.array(G.string()) }),
  Bae = G.object({ method: G.literal('wallet_getCapabilities') }),
  Dae = G.object({ method: G.literal('wallet_grantPermissions'), params: G.array(G.any()) }),
  Mae = G.object({ method: G.literal('wallet_revokePermissions'), params: G.any() }),
  Uae = G.object({ method: G.literal('wallet_getAssets'), params: G.any() }),
  mx = G.object({ token: G.string() }),
  Xe = G.object({ id: G.string().optional() }),
  rh = {
    appEvent: Xe.extend({ type: Je('APP_SWITCH_NETWORK'), payload: boe })
      .or(Xe.extend({ type: Je('APP_CONNECT_EMAIL'), payload: voe }))
      .or(Xe.extend({ type: Je('APP_CONNECT_DEVICE') }))
      .or(Xe.extend({ type: Je('APP_CONNECT_OTP'), payload: Eoe }))
      .or(Xe.extend({ type: Je('APP_CONNECT_SOCIAL'), payload: Aoe }))
      .or(Xe.extend({ type: Je('APP_GET_FARCASTER_URI') }))
      .or(Xe.extend({ type: Je('APP_CONNECT_FARCASTER') }))
      .or(Xe.extend({ type: Je('APP_GET_USER'), payload: G.optional(_oe) }))
      .or(Xe.extend({ type: Je('APP_GET_SOCIAL_REDIRECT_URI'), payload: Coe }))
      .or(Xe.extend({ type: Je('APP_SIGN_OUT') }))
      .or(Xe.extend({ type: Je('APP_IS_CONNECTED'), payload: G.optional(mx) }))
      .or(Xe.extend({ type: Je('APP_GET_CHAIN_ID') }))
      .or(Xe.extend({ type: Je('APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS') }))
      .or(Xe.extend({ type: Je('APP_INIT_SMART_ACCOUNT') }))
      .or(Xe.extend({ type: Je('APP_SET_PREFERRED_ACCOUNT'), payload: Poe }))
      .or(
        Xe.extend({
          type: Je('APP_RPC_REQUEST'),
          payload: gx
            .or(Uae)
            .or(Koe)
            .or(Voe)
            .or(Goe)
            .or(Qoe)
            .or(Zoe)
            .or(Yoe)
            .or(Joe)
            .or(Xoe)
            .or(eae)
            .or(tae)
            .or(nae)
            .or(rae)
            .or(sae)
            .or(iae)
            .or(oae)
            .or(aae)
            .or(cae)
            .or(uae)
            .or(lae)
            .or(dae)
            .or(hae)
            .or(fae)
            .or(pae)
            .or(gae)
            .or(mae)
            .or(yae)
            .or(wae)
            .or(bae)
            .or(vae)
            .or(Eae)
            .or(Aae)
            .or(_ae)
            .or(Cae)
            .or(Sae)
            .or(gx)
            .or(Iae)
            .or(xae)
            .or(Tae)
            .or(Nae)
            .or(Pae)
            .or(Rae)
            .or(Oae)
            .or(kae)
            .or(Bae)
            .or(Dae)
            .or(Mae)
        })
      )
      .or(Xe.extend({ type: Je('APP_UPDATE_EMAIL'), payload: Soe }))
      .or(Xe.extend({ type: Je('APP_UPDATE_EMAIL_PRIMARY_OTP'), payload: Ioe }))
      .or(Xe.extend({ type: Je('APP_UPDATE_EMAIL_SECONDARY_OTP'), payload: xoe }))
      .or(Xe.extend({ type: Je('APP_SYNC_THEME'), payload: Toe }))
      .or(Xe.extend({ type: Je('APP_SYNC_DAPP_DATA'), payload: Noe }))
      .or(Xe.extend({ type: Je('APP_RELOAD') })),
    frameEvent: Xe.extend({ type: Je('FRAME_SWITCH_NETWORK_ERROR'), payload: Ln })
      .or(Xe.extend({ type: Je('FRAME_SWITCH_NETWORK_SUCCESS'), payload: Foe }))
      .or(Xe.extend({ type: Je('FRAME_CONNECT_EMAIL_SUCCESS'), payload: Roe }))
      .or(Xe.extend({ type: Je('FRAME_CONNECT_EMAIL_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_GET_FARCASTER_URI_SUCCESS'), payload: koe }))
      .or(Xe.extend({ type: Je('FRAME_GET_FARCASTER_URI_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_CONNECT_FARCASTER_SUCCESS'), payload: Ooe }))
      .or(Xe.extend({ type: Je('FRAME_CONNECT_FARCASTER_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_CONNECT_OTP_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_CONNECT_OTP_SUCCESS') }))
      .or(Xe.extend({ type: Je('FRAME_CONNECT_DEVICE_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_CONNECT_DEVICE_SUCCESS') }))
      .or(Xe.extend({ type: Je('FRAME_CONNECT_SOCIAL_SUCCESS'), payload: Boe }))
      .or(Xe.extend({ type: Je('FRAME_CONNECT_SOCIAL_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_GET_USER_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_GET_USER_SUCCESS'), payload: Moe }))
      .or(Xe.extend({ type: Je('FRAME_GET_SOCIAL_REDIRECT_URI_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS'), payload: Uoe }))
      .or(Xe.extend({ type: Je('FRAME_SIGN_OUT_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_SIGN_OUT_SUCCESS') }))
      .or(Xe.extend({ type: Je('FRAME_IS_CONNECTED_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_IS_CONNECTED_SUCCESS'), payload: Loe }))
      .or(Xe.extend({ type: Je('FRAME_GET_CHAIN_ID_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_GET_CHAIN_ID_SUCCESS'), payload: $oe }))
      .or(Xe.extend({ type: Je('FRAME_RPC_REQUEST_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_RPC_REQUEST_SUCCESS'), payload: Woe }))
      .or(Xe.extend({ type: Je('FRAME_SESSION_UPDATE'), payload: mx }))
      .or(Xe.extend({ type: Je('FRAME_UPDATE_EMAIL_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_UPDATE_EMAIL_SUCCESS'), payload: Doe }))
      .or(Xe.extend({ type: Je('FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS') }))
      .or(Xe.extend({ type: Je('FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS'), payload: joe }))
      .or(Xe.extend({ type: Je('FRAME_SYNC_THEME_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_SYNC_THEME_SUCCESS') }))
      .or(Xe.extend({ type: Je('FRAME_SYNC_DAPP_DATA_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_SYNC_DAPP_DATA_SUCCESS') }))
      .or(Xe.extend({ type: Je('FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS'), payload: Hoe }))
      .or(Xe.extend({ type: Je('FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_INIT_SMART_ACCOUNT_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_SET_PREFERRED_ACCOUNT_SUCCESS'), payload: zoe }))
      .or(Xe.extend({ type: Je('FRAME_SET_PREFERRED_ACCOUNT_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_READY'), payload: qoe }))
      .or(Xe.extend({ type: Je('FRAME_RELOAD_ERROR'), payload: Ln }))
      .or(Xe.extend({ type: Je('FRAME_RELOAD_SUCCESS') }))
  }
function gb(t, e = {}) {
  var n
  return (
    typeof (e == null ? void 0 : e.type) == 'string' &&
    ((n = e == null ? void 0 : e.type) == null ? void 0 : n.includes(t))
  )
}
class Lae {
  constructor({
    projectId: e,
    isAppClient: n = !1,
    chainId: r = 'eip155:1',
    enableLogger: s = !0
  }) {
    if (
      ((this.iframe = null),
      (this.rpcUrl = Ae.BLOCKCHAIN_API_RPC_URL),
      (this.initFrame = () => {
        const i = document.getElementById('w3m-iframe')
        this.iframe && !i && document.body.appendChild(this.iframe)
      }),
      (this.events = {
        registerFrameEventHandler: (i, o, a) => {
          function c({ data: u }) {
            if (!gb(rt.FRAME_EVENT_KEY, u)) return
            const l = rh.frameEvent.parse(u)
            l.id === i && (o(l), window.removeEventListener('message', c))
          }
          js.isClient &&
            (window.addEventListener('message', c),
            a.addEventListener('abort', () => {
              window.removeEventListener('message', c)
            }))
        },
        onFrameEvent: i => {
          js.isClient &&
            window.addEventListener('message', ({ data: o }) => {
              if (!gb(rt.FRAME_EVENT_KEY, o)) return
              const a = rh.frameEvent.parse(o)
              i(a)
            })
        },
        onAppEvent: i => {
          js.isClient &&
            window.addEventListener('message', ({ data: o }) => {
              if (!gb(rt.APP_EVENT_KEY, o)) return
              const a = rh.appEvent.parse(o)
              i(a)
            })
        },
        postAppEvent: i => {
          var o
          if (js.isClient) {
            if (!((o = this.iframe) != null && o.contentWindow))
              throw new Error('W3mFrame: iframe is not set')
            rh.appEvent.parse(i), this.iframe.contentWindow.postMessage(i, '*')
          }
        },
        postFrameEvent: i => {
          if (js.isClient) {
            if (!parent) throw new Error('W3mFrame: parent is not set')
            rh.frameEvent.parse(i), parent.postMessage(i, '*')
          }
        }
      }),
      (this.projectId = e),
      (this.frameLoadPromise = new Promise((i, o) => {
        this.frameLoadPromiseResolver = { resolve: i, reject: o }
      })),
      n &&
        ((this.frameLoadPromise = new Promise((i, o) => {
          this.frameLoadPromiseResolver = { resolve: i, reject: o }
        })),
        js.isClient))
    ) {
      const i = document.createElement('iframe')
      ;(i.id = 'w3m-iframe'),
        (i.src = `${hie}?projectId=${e}&chainId=${r}&version=${pie}&enableLogger=${s}`),
        (i.name = 'w3m-secure-iframe'),
        (i.style.position = 'fixed'),
        (i.style.zIndex = '999999'),
        (i.style.display = 'none'),
        (i.style.border = 'none'),
        (i.style.animationDelay = '0s, 50ms'),
        (i.style.borderBottomLeftRadius = 'clamp(0px, var(--wui-border-radius-l), 44px)'),
        (i.style.borderBottomRightRadius = 'clamp(0px, var(--wui-border-radius-l), 44px)'),
        (this.iframe = i),
        (this.iframe.onerror = () => {
          var o
          ;(o = this.frameLoadPromiseResolver) == null ||
            o.reject('Unable to load email login dependency')
        }),
        this.events.onFrameEvent(o => {
          var a
          o.type === '@w3m-frame/READY' &&
            ((a = this.frameLoadPromiseResolver) == null || a.resolve(void 0))
        })
    }
  }
  get networks() {
    const e = [
      'eip155:1',
      'eip155:5',
      'eip155:11155111',
      'eip155:10',
      'eip155:420',
      'eip155:42161',
      'eip155:421613',
      'eip155:137',
      'eip155:80001',
      'eip155:42220',
      'eip155:1313161554',
      'eip155:1313161555',
      'eip155:56',
      'eip155:97',
      'eip155:43114',
      'eip155:43113',
      'eip155:324',
      'eip155:280',
      'eip155:100',
      'eip155:8453',
      'eip155:84531',
      'eip155:84532',
      'eip155:7777777',
      'eip155:999',
      'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
      'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
      'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1'
    ].map(n => ({
      [n]: { rpcUrl: `${this.rpcUrl}/v1/?chainId=${n}&projectId=${this.projectId}`, chainId: n }
    }))
    return Object.assign({}, ...e)
  }
}
class $ae {
  constructor(e) {
    var i
    const n = Id({ level: fie }),
      { logger: r, chunkLoggerController: s } = wA({ opts: n })
    ;(this.logger = Jr(r, this.constructor.name)),
      (this.chunkLoggerController = s),
      typeof window < 'u' &&
        (i = this.chunkLoggerController) != null &&
        i.downloadLogsBlobInBrowser &&
        (window.downloadAppKitLogsBlob || (window.downloadAppKitLogsBlob = {}),
        (window.downloadAppKitLogsBlob.sdk = () => {
          var o
          ;(o = this.chunkLoggerController) != null &&
            o.downloadLogsBlobInBrowser &&
            this.chunkLoggerController.downloadLogsBlobInBrowser({ projectId: e })
        }))
  }
}
class Fae {
  constructor({ projectId: e, chainId: n, enableLogger: r = !0, onTimeout: s }) {
    ;(this.openRpcRequests = []),
      r && (this.w3mLogger = new $ae(e)),
      (this.w3mFrame = new Lae({ projectId: e, isAppClient: !0, chainId: n, enableLogger: r })),
      (this.onTimeout = s),
      this.getLoginEmailUsed() && this.w3mFrame.initFrame(),
      (this.initPromise = new Promise(i => {
        this.w3mFrame.events.onFrameEvent(async o => {
          o.type === rt.FRAME_READY &&
            ((this.initPromise = void 0),
            await new Promise(a => {
              setTimeout(a, 500)
            }),
            i())
        })
      }))
  }
  async init() {
    this.w3mFrame.initFrame(), this.initPromise && (await this.initPromise)
  }
  getLoginEmailUsed() {
    return !!Sr.get(rt.EMAIL_LOGIN_USED_KEY)
  }
  getEmail() {
    return Sr.get(rt.EMAIL)
  }
  getUsername() {
    return Sr.get(rt.SOCIAL_USERNAME)
  }
  async reload() {
    var e
    try {
      this.w3mFrame.initFrame(), await this.appEvent({ type: rt.APP_RELOAD })
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error reloading iframe'), n)
      )
    }
  }
  async connectEmail(e) {
    var n
    try {
      js.checkIfAllowedToTriggerEmail(), this.w3mFrame.initFrame()
      const r = await this.appEvent({ type: rt.APP_CONNECT_EMAIL, payload: e })
      return this.setNewLastEmailLoginTime(), r
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error connecting email'), r)
      )
    }
  }
  async connectDevice() {
    var e
    try {
      return this.appEvent({ type: rt.APP_CONNECT_DEVICE })
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error connecting device'), n)
      )
    }
  }
  async connectOtp(e) {
    var n
    try {
      return this.appEvent({ type: rt.APP_CONNECT_OTP, payload: e })
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error connecting otp'), r)
      )
    }
  }
  async isConnected() {
    var e
    try {
      if (!this.getLoginEmailUsed()) return { isConnected: !1 }
      const n = await this.appEvent({ type: rt.APP_IS_CONNECTED })
      return (n != null && n.isConnected) || this.deleteAuthLoginCache(), n
    } catch (n) {
      throw (
        (this.deleteAuthLoginCache(),
        (e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error checking connection'),
        n)
      )
    }
  }
  async getChainId() {
    var e
    try {
      const n = await this.appEvent({ type: rt.APP_GET_CHAIN_ID })
      return this.setLastUsedChainId(n.chainId), n
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error getting chain id'), n)
      )
    }
  }
  async getSocialRedirectUri(e) {
    var n
    try {
      return (
        this.w3mFrame.initFrame(),
        this.appEvent({ type: rt.APP_GET_SOCIAL_REDIRECT_URI, payload: e })
      )
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, 'Error getting social redirect uri'),
        r)
      )
    }
  }
  async updateEmail(e) {
    var n
    try {
      const r = await this.appEvent({ type: rt.APP_UPDATE_EMAIL, payload: e })
      return this.setNewLastEmailLoginTime(), r
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error updating email'), r)
      )
    }
  }
  async updateEmailPrimaryOtp(e) {
    var n
    try {
      return this.appEvent({ type: rt.APP_UPDATE_EMAIL_PRIMARY_OTP, payload: e })
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, 'Error updating email primary otp'),
        r)
      )
    }
  }
  async updateEmailSecondaryOtp(e) {
    var n
    try {
      const r = await this.appEvent({ type: rt.APP_UPDATE_EMAIL_SECONDARY_OTP, payload: e })
      return this.setLoginSuccess(r.newEmail), r
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, 'Error updating email secondary otp'),
        r)
      )
    }
  }
  async syncTheme(e) {
    var n
    try {
      return this.appEvent({ type: rt.APP_SYNC_THEME, payload: e })
    } catch (r) {
      throw ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error syncing theme'), r)
    }
  }
  async syncDappData(e) {
    var n
    try {
      return this.appEvent({ type: rt.APP_SYNC_DAPP_DATA, payload: e })
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error syncing dapp data'), r)
      )
    }
  }
  async getSmartAccountEnabledNetworks() {
    var e
    try {
      const n = await this.appEvent({ type: rt.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS })
      return this.persistSmartAccountEnabledNetworks(n.smartAccountEnabledNetworks), n
    } catch (n) {
      throw (
        (this.persistSmartAccountEnabledNetworks([]),
        (e = this.w3mLogger) == null ||
          e.logger.error({ error: n }, 'Error getting smart account enabled networks'),
        n)
      )
    }
  }
  async setPreferredAccount(e) {
    var n
    try {
      return this.appEvent({ type: rt.APP_SET_PREFERRED_ACCOUNT, payload: { type: e } })
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, 'Error setting preferred account'),
        r)
      )
    }
  }
  async connect(e) {
    var n
    try {
      const r = (e == null ? void 0 : e.chainId) || this.getLastUsedChainId() || 1,
        s = await this.getUser({
          chainId: r,
          preferredAccountType: e == null ? void 0 : e.preferredAccountType
        })
      return this.setLoginSuccess(s.email), this.setLastUsedChainId(s.chainId), (this.user = s), s
    } catch (r) {
      throw ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error connecting'), r)
    }
  }
  async getUser(e) {
    var n
    try {
      const r = (e == null ? void 0 : e.chainId) || this.getLastUsedChainId() || 1,
        s = await this.appEvent({ type: rt.APP_GET_USER, payload: { ...e, chainId: r } })
      return (this.user = s), s
    } catch (r) {
      throw ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error connecting'), r)
    }
  }
  async connectSocial(e) {
    var n
    try {
      this.w3mFrame.initFrame()
      const r = await this.appEvent({ type: rt.APP_CONNECT_SOCIAL, payload: { uri: e } })
      return r.userName && this.setSocialLoginSuccess(r.userName), r
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error connecting social'), r)
      )
    }
  }
  async getFarcasterUri() {
    var e
    try {
      return this.w3mFrame.initFrame(), await this.appEvent({ type: rt.APP_GET_FARCASTER_URI })
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: n }, 'Error getting farcaster uri'),
        n)
      )
    }
  }
  async connectFarcaster() {
    var e
    try {
      const n = await this.appEvent({ type: rt.APP_CONNECT_FARCASTER })
      return n.userName && this.setSocialLoginSuccess(n.userName), n
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error connecting farcaster'),
        n)
      )
    }
  }
  async switchNetwork(e) {
    var n
    try {
      const r = await this.appEvent({ type: rt.APP_SWITCH_NETWORK, payload: { chainId: e } })
      return this.setLastUsedChainId(r.chainId), r
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null || n.logger.error({ error: r }, 'Error switching network'), r)
      )
    }
  }
  async disconnect() {
    var e
    try {
      const n = await this.appEvent({ type: rt.APP_SIGN_OUT })
      return this.deleteAuthLoginCache(), n
    } catch (n) {
      throw ((e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error disconnecting'), n)
    }
  }
  async request(e) {
    var n, r, s, i
    try {
      if (Jn.GET_CHAIN_ID === e.method) return this.getLastUsedChainId()
      ;(n = this.rpcRequestHandler) == null || n.call(this, e)
      const o = await this.appEvent({ type: rt.APP_RPC_REQUEST, payload: e })
      return (r = this.rpcSuccessHandler) == null || r.call(this, o, e), o
    } catch (o) {
      throw (
        ((s = this.rpcErrorHandler) == null || s.call(this, o, e),
        (i = this.w3mLogger) == null || i.logger.error({ error: o }, 'Error requesting'),
        o)
      )
    }
  }
  onRpcRequest(e) {
    this.rpcRequestHandler = e
  }
  onRpcSuccess(e) {
    this.rpcSuccessHandler = e
  }
  onRpcError(e) {
    this.rpcErrorHandler = e
  }
  onIsConnected(e) {
    this.w3mFrame.events.onFrameEvent(n => {
      n.type === rt.FRAME_IS_CONNECTED_SUCCESS && n.payload.isConnected && e()
    })
  }
  onNotConnected(e) {
    this.w3mFrame.events.onFrameEvent(n => {
      n.type === rt.FRAME_IS_CONNECTED_ERROR && e(),
        n.type === rt.FRAME_IS_CONNECTED_SUCCESS && !n.payload.isConnected && e()
    })
  }
  onConnect(e) {
    this.w3mFrame.events.onFrameEvent(n => {
      n.type === rt.FRAME_GET_USER_SUCCESS && e(n.payload)
    })
  }
  onSocialConnected(e) {
    this.w3mFrame.events.onFrameEvent(n => {
      n.type === rt.FRAME_CONNECT_SOCIAL_SUCCESS && e(n.payload)
    })
  }
  async getCapabilities() {
    try {
      return (await this.request({ method: 'wallet_getCapabilities' })) || {}
    } catch {
      return {}
    }
  }
  onSetPreferredAccount(e) {
    this.w3mFrame.events.onFrameEvent(n => {
      n.type === rt.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS
        ? e(n.payload)
        : n.type === rt.FRAME_SET_PREFERRED_ACCOUNT_ERROR && e({ type: Jn.ACCOUNT_TYPES.EOA })
    })
  }
  onGetSmartAccountEnabledNetworks(e) {
    this.w3mFrame.events.onFrameEvent(n => {
      n.type === rt.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS
        ? e(n.payload.smartAccountEnabledNetworks)
        : n.type === rt.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR && e([])
    })
  }
  getAvailableChainIds() {
    return Object.keys(this.w3mFrame.networks)
  }
  rejectRpcRequests() {
    var e
    try {
      this.openRpcRequests.forEach(({ abortController: n, method: r }) => {
        Jn.SAFE_RPC_METHODS.includes(r) || n.abort()
      }),
        (this.openRpcRequests = [])
    } catch (n) {
      ;(e = this.w3mLogger) == null || e.logger.error({ error: n }, 'Error aborting RPC request')
    }
  }
  async appEvent(e) {
    await this.w3mFrame.frameLoadPromise
    let n
    function r(a) {
      return a.replace('@w3m-app/', '')
    }
    const s = new AbortController(),
      i = r(e.type)
    return (
      [
        rt.APP_CONNECT_EMAIL,
        rt.APP_CONNECT_DEVICE,
        rt.APP_CONNECT_OTP,
        rt.APP_CONNECT_SOCIAL,
        rt.APP_GET_SOCIAL_REDIRECT_URI
      ]
        .map(r)
        .includes(i) &&
        (n = setTimeout(() => {
          var a
          ;(a = this.onTimeout) == null || a.call(this), s.abort()
        }, 3e4)),
      new Promise((a, c) => {
        var d, h, p
        const u = Math.random().toString(36).substring(7)
        if (
          ((p = (d = this.w3mLogger) == null ? void 0 : (h = d.logger).info) == null ||
            p.call(h, { event: e, id: u }, 'Sending app event'),
          this.w3mFrame.events.postAppEvent({ ...e, id: u }),
          i === 'RPC_REQUEST')
        ) {
          const y = e
          this.openRpcRequests = [...this.openRpcRequests, { ...y.payload, abortController: s }]
        }
        s.signal.addEventListener('abort', () => {
          i === 'RPC_REQUEST'
            ? c(new Error('Request was aborted'))
            : i !== 'GET_FARCASTER_URI' && c(new Error('Something went wrong'))
        })
        function l(y, m) {
          var b, I, x
          y.id === u &&
            ((I = m == null ? void 0 : (b = m.logger).info) == null ||
              I.call(b, { framEvent: y, id: u }, 'Received frame response'),
            y.type === `@w3m-frame/${i}_SUCCESS`
              ? (n && clearTimeout(n), 'payload' in y && a(y.payload), a(void 0))
              : y.type === `@w3m-frame/${i}_ERROR` &&
                (n && clearTimeout(n),
                'payload' in y &&
                  c(
                    new Error(((x = y.payload) == null ? void 0 : x.message) || 'An error occurred')
                  ),
                c(new Error('An error occurred'))))
        }
        this.w3mFrame.events.registerFrameEventHandler(u, y => l(y, this.w3mLogger), s.signal)
      })
    )
  }
  setNewLastEmailLoginTime() {
    Sr.set(rt.LAST_EMAIL_LOGIN_TIME, Date.now().toString())
  }
  setSocialLoginSuccess(e) {
    Sr.set(rt.SOCIAL_USERNAME, e)
  }
  setLoginSuccess(e) {
    e && Sr.set(rt.EMAIL, e),
      Sr.set(rt.EMAIL_LOGIN_USED_KEY, 'true'),
      Sr.delete(rt.LAST_EMAIL_LOGIN_TIME)
  }
  deleteAuthLoginCache() {
    Sr.delete(rt.EMAIL_LOGIN_USED_KEY),
      Sr.delete(rt.EMAIL),
      Sr.delete(rt.LAST_USED_CHAIN_KEY),
      Sr.delete(rt.SOCIAL_USERNAME)
  }
  setLastUsedChainId(e) {
    e && Sr.set(rt.LAST_USED_CHAIN_KEY, String(e))
  }
  getLastUsedChainId() {
    const e = Sr.get(rt.LAST_USED_CHAIN_KEY) ?? void 0,
      n = Number(e)
    return isNaN(n) ? e : n
  }
  persistSmartAccountEnabledNetworks(e) {
    Sr.set(rt.SMART_ACCOUNT_ENABLED_NETWORKS, e.join(','))
  }
}
class tu {
  constructor() {}
  static getInstance({ projectId: e, chainId: n, enableLogger: r, onTimeout: s }) {
    return (
      tu.instance ||
        (tu.instance = new Fae({ projectId: e, chainId: n, enableLogger: r, onTimeout: s })),
      tu.instance
    )
  }
}
var yx = {}
const jae = {
    ACCOUNT_TABS: [{ label: 'Tokens' }, { label: 'NFTs' }, { label: 'Activity' }],
    SECURE_SITE_ORIGIN:
      (typeof process < 'u' && typeof yx < 'u' ? yx.NEXT_PUBLIC_SECURE_SITE_ORIGIN : void 0) ||
      'https://secure.walletconnect.org',
    VIEW_DIRECTION: { Next: 'next', Prev: 'prev' },
    DEFAULT_CONNECT_METHOD_ORDER: ['email', 'social', 'wallet'],
    ANIMATION_DURATIONS: { HeaderText: 120, ModalHeight: 150, ViewTransition: 150 }
  },
  Mv = {
    filterOutDuplicatesByRDNS(t) {
      const e = Pe.state.enableEIP6963 ? Et.state.connectors : [],
        n = Ke.getRecentWallets(),
        r = e
          .map(a => {
            var c
            return (c = a.info) == null ? void 0 : c.rdns
          })
          .filter(Boolean),
        s = n.map(a => a.rdns).filter(Boolean),
        i = r.concat(s)
      if (i.includes('io.metamask.mobile') && dt.isMobile()) {
        const a = i.indexOf('io.metamask.mobile')
        i[a] = 'io.metamask'
      }
      return t.filter(a => !i.includes(String(a == null ? void 0 : a.rdns)))
    },
    filterOutDuplicatesByIds(t) {
      const e = Et.state.connectors.filter(a => a.type === 'ANNOUNCED' || a.type === 'INJECTED'),
        n = Ke.getRecentWallets(),
        r = e.map(a => a.explorerId),
        s = n.map(a => a.id),
        i = r.concat(s)
      return t.filter(a => !i.includes(a == null ? void 0 : a.id))
    },
    filterOutDuplicateWallets(t) {
      const e = this.filterOutDuplicatesByRDNS(t)
      return this.filterOutDuplicatesByIds(e)
    },
    markWalletsAsInstalled(t) {
      const { connectors: e } = Et.state,
        n = e
          .filter(i => i.type === 'ANNOUNCED')
          .reduce((i, o) => {
            var a
            return (a = o.info) != null && a.rdns && (i[o.info.rdns] = !0), i
          }, {})
      return t
        .map(i => ({ ...i, installed: !!i.rdns && !!n[i.rdns ?? ''] }))
        .sort((i, o) => Number(o.installed) - Number(i.installed))
    },
    getConnectOrderMethod(t, e) {
      var c
      const n =
          (t == null ? void 0 : t.connectMethodsOrder) ||
          ((c = Pe.state.features) == null ? void 0 : c.connectMethodsOrder),
        r = e || Et.state.connectors
      if (n) return n
      const { injected: s, announced: i } = Fg.getConnectorsByType(
          r,
          yt.state.recommended,
          yt.state.featured
        ),
        o = s.filter(Fg.showConnector),
        a = i.filter(Fg.showConnector)
      return o.length || a.length ? ['wallet', 'email', 'social'] : jae.DEFAULT_CONNECT_METHOD_ORDER
    },
    isExcluded(t) {
      const e = !!t.rdns && yt.state.excludedWallets.some(r => r.rdns === t.rdns),
        n = !!t.name && yt.state.excludedWallets.some(r => V0.isLowerCaseMatch(r.name, t.name))
      return e || n
    }
  },
  Fg = {
    getConnectorsByType(t, e, n) {
      const { customWallets: r } = Pe.state,
        s = Ke.getRecentWallets(),
        i = Mv.filterOutDuplicateWallets(e),
        o = Mv.filterOutDuplicateWallets(n),
        a = t.filter(d => d.type === 'MULTI_CHAIN'),
        c = t.filter(d => d.type === 'ANNOUNCED'),
        u = t.filter(d => d.type === 'INJECTED'),
        l = t.filter(d => d.type === 'EXTERNAL')
      return {
        custom: r,
        recent: s,
        external: l,
        multiChain: a,
        announced: c,
        injected: u,
        recommended: i,
        featured: o
      }
    },
    showConnector(t) {
      var s
      const e = (s = t.info) == null ? void 0 : s.rdns,
        n = !!e && yt.state.excludedWallets.some(i => !!i.rdns && i.rdns === e),
        r = !!t.name && yt.state.excludedWallets.some(i => V0.isLowerCaseMatch(i.name, t.name))
      return !(
        (t.type === 'INJECTED' &&
          ((t.name === 'Browser Wallet' &&
            (!dt.isMobile() || (dt.isMobile() && !e && !pn.checkInstalled()))) ||
            n ||
            r)) ||
        ((t.type === 'ANNOUNCED' || t.type === 'EXTERNAL') && (n || r))
      )
    },
    getIsConnectedWithWC() {
      return Array.from(ne.state.chains.values()).some(
        n => Et.getConnectorId(n.namespace) === Ae.CONNECTOR_ID.WALLET_CONNECT
      )
    },
    getConnectorTypeOrder({
      recommended: t,
      featured: e,
      custom: n,
      recent: r,
      announced: s,
      injected: i,
      multiChain: o,
      external: a,
      overriddenConnectors: c = (u =>
        (u = Pe.state.features) == null ? void 0 : u.connectorTypeOrder)() ?? []
    }) {
      const l = Fg.getIsConnectedWithWC(),
        p = [
          { type: 'walletConnect', isEnabled: Pe.state.enableWalletConnect && !l },
          { type: 'recent', isEnabled: r.length > 0 },
          { type: 'injected', isEnabled: [...i, ...s, ...o].length > 0 },
          { type: 'featured', isEnabled: e.length > 0 },
          { type: 'custom', isEnabled: n && n.length > 0 },
          { type: 'external', isEnabled: a.length > 0 },
          { type: 'recommended', isEnabled: t.length > 0 }
        ].filter(I => I.isEnabled),
        y = new Set(p.map(I => I.type)),
        m = c.filter(I => y.has(I)).map(I => ({ type: I, isEnabled: !0 })),
        b = p.filter(({ type: I }) => !m.some(({ type: _ }) => _ === I))
      return Array.from(new Set([...m, ...b].map(({ type: I }) => I)))
    }
  }
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const jg = globalThis,
  FA =
    jg.ShadowRoot &&
    (jg.ShadyCSS === void 0 || jg.ShadyCSS.nativeShadow) &&
    'adoptedStyleSheets' in Document.prototype &&
    'replace' in CSSStyleSheet.prototype,
  jA = Symbol(),
  wx = new WeakMap()
let T8 = class {
  constructor(e, n, r) {
    if (((this._$cssResult$ = !0), r !== jA))
      throw Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.')
    ;(this.cssText = e), (this.t = n)
  }
  get styleSheet() {
    let e = this.o
    const n = this.t
    if (FA && e === void 0) {
      const r = n !== void 0 && n.length === 1
      r && (e = wx.get(n)),
        e === void 0 &&
          ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), r && wx.set(n, e))
    }
    return e
  }
  toString() {
    return this.cssText
  }
}
const Xs = t => new T8(typeof t == 'string' ? t : t + '', void 0, jA),
  Ol = (t, ...e) => {
    const n =
      t.length === 1
        ? t[0]
        : e.reduce(
            (r, s, i) =>
              r +
              (o => {
                if (o._$cssResult$ === !0) return o.cssText
                if (typeof o == 'number') return o
                throw Error(
                  "Value passed to 'css' function must be a 'css' function result: " +
                    o +
                    ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security."
                )
              })(s) +
              t[i + 1],
            t[0]
          )
    return new T8(n, t, jA)
  },
  Hae = (t, e) => {
    if (FA) t.adoptedStyleSheets = e.map(n => (n instanceof CSSStyleSheet ? n : n.styleSheet))
    else
      for (const n of e) {
        const r = document.createElement('style'),
          s = jg.litNonce
        s !== void 0 && r.setAttribute('nonce', s), (r.textContent = n.cssText), t.appendChild(r)
      }
  },
  bx = FA
    ? t => t
    : t =>
        t instanceof CSSStyleSheet
          ? (e => {
              let n = ''
              for (const r of e.cssRules) n += r.cssText
              return Xs(n)
            })(t)
          : t
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const {
    is: qae,
    defineProperty: zae,
    getOwnPropertyDescriptor: Wae,
    getOwnPropertyNames: Kae,
    getOwnPropertySymbols: Vae,
    getPrototypeOf: Gae
  } = Object,
  Ka = globalThis,
  vx = Ka.trustedTypes,
  Qae = vx ? vx.emptyScript : '',
  mb = Ka.reactiveElementPolyfillSupport,
  Uh = (t, e) => t,
  Uv = {
    toAttribute(t, e) {
      switch (e) {
        case Boolean:
          t = t ? Qae : null
          break
        case Object:
        case Array:
          t = t == null ? t : JSON.stringify(t)
      }
      return t
    },
    fromAttribute(t, e) {
      let n = t
      switch (e) {
        case Boolean:
          n = t !== null
          break
        case Number:
          n = t === null ? null : Number(t)
          break
        case Object:
        case Array:
          try {
            n = JSON.parse(t)
          } catch {
            n = null
          }
      }
      return n
    }
  },
  N8 = (t, e) => !qae(t, e),
  Ex = { attribute: !0, type: String, converter: Uv, reflect: !1, hasChanged: N8 }
Symbol.metadata ?? (Symbol.metadata = Symbol('metadata')),
  Ka.litPropertyMetadata ?? (Ka.litPropertyMetadata = new WeakMap())
let ul = class extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e)
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()]
  }
  static createProperty(e, n = Ex) {
    if (
      (n.state && (n.attribute = !1), this._$Ei(), this.elementProperties.set(e, n), !n.noAccessor)
    ) {
      const r = Symbol(),
        s = this.getPropertyDescriptor(e, r, n)
      s !== void 0 && zae(this.prototype, e, s)
    }
  }
  static getPropertyDescriptor(e, n, r) {
    const { get: s, set: i } = Wae(this.prototype, e) ?? {
      get() {
        return this[n]
      },
      set(o) {
        this[n] = o
      }
    }
    return {
      get() {
        return s == null ? void 0 : s.call(this)
      },
      set(o) {
        const a = s == null ? void 0 : s.call(this)
        i.call(this, o), this.requestUpdate(e, a, r)
      },
      configurable: !0,
      enumerable: !0
    }
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? Ex
  }
  static _$Ei() {
    if (this.hasOwnProperty(Uh('elementProperties'))) return
    const e = Gae(this)
    e.finalize(),
      e.l !== void 0 && (this.l = [...e.l]),
      (this.elementProperties = new Map(e.elementProperties))
  }
  static finalize() {
    if (this.hasOwnProperty(Uh('finalized'))) return
    if (((this.finalized = !0), this._$Ei(), this.hasOwnProperty(Uh('properties')))) {
      const n = this.properties,
        r = [...Kae(n), ...Vae(n)]
      for (const s of r) this.createProperty(s, n[s])
    }
    const e = this[Symbol.metadata]
    if (e !== null) {
      const n = litPropertyMetadata.get(e)
      if (n !== void 0) for (const [r, s] of n) this.elementProperties.set(r, s)
    }
    this._$Eh = new Map()
    for (const [n, r] of this.elementProperties) {
      const s = this._$Eu(n, r)
      s !== void 0 && this._$Eh.set(s, n)
    }
    this.elementStyles = this.finalizeStyles(this.styles)
  }
  static finalizeStyles(e) {
    const n = []
    if (Array.isArray(e)) {
      const r = new Set(e.flat(1 / 0).reverse())
      for (const s of r) n.unshift(bx(s))
    } else e !== void 0 && n.push(bx(e))
    return n
  }
  static _$Eu(e, n) {
    const r = n.attribute
    return r === !1
      ? void 0
      : typeof r == 'string'
        ? r
        : typeof e == 'string'
          ? e.toLowerCase()
          : void 0
  }
  constructor() {
    super(),
      (this._$Ep = void 0),
      (this.isUpdatePending = !1),
      (this.hasUpdated = !1),
      (this._$Em = null),
      this._$Ev()
  }
  _$Ev() {
    var e
    ;(this._$ES = new Promise(n => (this.enableUpdating = n))),
      (this._$AL = new Map()),
      this._$E_(),
      this.requestUpdate(),
      (e = this.constructor.l) == null || e.forEach(n => n(this))
  }
  addController(e) {
    var n
    ;(this._$EO ?? (this._$EO = new Set())).add(e),
      this.renderRoot !== void 0 && this.isConnected && ((n = e.hostConnected) == null || n.call(e))
  }
  removeController(e) {
    var n
    ;(n = this._$EO) == null || n.delete(e)
  }
  _$E_() {
    const e = new Map(),
      n = this.constructor.elementProperties
    for (const r of n.keys()) this.hasOwnProperty(r) && (e.set(r, this[r]), delete this[r])
    e.size > 0 && (this._$Ep = e)
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions)
    return Hae(e, this.constructor.elementStyles), e
  }
  connectedCallback() {
    var e
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
      this.enableUpdating(!0),
      (e = this._$EO) == null ||
        e.forEach(n => {
          var r
          return (r = n.hostConnected) == null ? void 0 : r.call(n)
        })
  }
  enableUpdating(e) {}
  disconnectedCallback() {
    var e
    ;(e = this._$EO) == null ||
      e.forEach(n => {
        var r
        return (r = n.hostDisconnected) == null ? void 0 : r.call(n)
      })
  }
  attributeChangedCallback(e, n, r) {
    this._$AK(e, r)
  }
  _$EC(e, n) {
    var i
    const r = this.constructor.elementProperties.get(e),
      s = this.constructor._$Eu(e, r)
    if (s !== void 0 && r.reflect === !0) {
      const o = (
        ((i = r.converter) == null ? void 0 : i.toAttribute) !== void 0 ? r.converter : Uv
      ).toAttribute(n, r.type)
      ;(this._$Em = e),
        o == null ? this.removeAttribute(s) : this.setAttribute(s, o),
        (this._$Em = null)
    }
  }
  _$AK(e, n) {
    var i
    const r = this.constructor,
      s = r._$Eh.get(e)
    if (s !== void 0 && this._$Em !== s) {
      const o = r.getPropertyOptions(s),
        a =
          typeof o.converter == 'function'
            ? { fromAttribute: o.converter }
            : ((i = o.converter) == null ? void 0 : i.fromAttribute) !== void 0
              ? o.converter
              : Uv
      ;(this._$Em = s), (this[s] = a.fromAttribute(n, o.type)), (this._$Em = null)
    }
  }
  requestUpdate(e, n, r) {
    if (e !== void 0) {
      if ((r ?? (r = this.constructor.getPropertyOptions(e)), !(r.hasChanged ?? N8)(this[e], n)))
        return
      this.P(e, n, r)
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET())
  }
  P(e, n, r) {
    this._$AL.has(e) || this._$AL.set(e, n),
      r.reflect === !0 && this._$Em !== e && (this._$Ej ?? (this._$Ej = new Set())).add(e)
  }
  async _$ET() {
    this.isUpdatePending = !0
    try {
      await this._$ES
    } catch (n) {
      Promise.reject(n)
    }
    const e = this.scheduleUpdate()
    return e != null && (await e), !this.isUpdatePending
  }
  scheduleUpdate() {
    return this.performUpdate()
  }
  performUpdate() {
    var r
    if (!this.isUpdatePending) return
    if (!this.hasUpdated) {
      if ((this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep)) {
        for (const [i, o] of this._$Ep) this[i] = o
        this._$Ep = void 0
      }
      const s = this.constructor.elementProperties
      if (s.size > 0)
        for (const [i, o] of s)
          o.wrapped !== !0 || this._$AL.has(i) || this[i] === void 0 || this.P(i, this[i], o)
    }
    let e = !1
    const n = this._$AL
    try {
      ;(e = this.shouldUpdate(n)),
        e
          ? (this.willUpdate(n),
            (r = this._$EO) == null ||
              r.forEach(s => {
                var i
                return (i = s.hostUpdate) == null ? void 0 : i.call(s)
              }),
            this.update(n))
          : this._$EU()
    } catch (s) {
      throw ((e = !1), this._$EU(), s)
    }
    e && this._$AE(n)
  }
  willUpdate(e) {}
  _$AE(e) {
    var n
    ;(n = this._$EO) == null ||
      n.forEach(r => {
        var s
        return (s = r.hostUpdated) == null ? void 0 : s.call(r)
      }),
      this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(e)),
      this.updated(e)
  }
  _$EU() {
    ;(this._$AL = new Map()), (this.isUpdatePending = !1)
  }
  get updateComplete() {
    return this.getUpdateComplete()
  }
  getUpdateComplete() {
    return this._$ES
  }
  shouldUpdate(e) {
    return !0
  }
  update(e) {
    this._$Ej && (this._$Ej = this._$Ej.forEach(n => this._$EC(n, this[n]))), this._$EU()
  }
  updated(e) {}
  firstUpdated(e) {}
}
;(ul.elementStyles = []),
  (ul.shadowRootOptions = { mode: 'open' }),
  (ul[Uh('elementProperties')] = new Map()),
  (ul[Uh('finalized')] = new Map()),
  mb == null || mb({ ReactiveElement: ul }),
  (Ka.reactiveElementVersions ?? (Ka.reactiveElementVersions = [])).push('2.0.4')
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const Lh = globalThis,
  Dm = Lh.trustedTypes,
  Ax = Dm ? Dm.createPolicy('lit-html', { createHTML: t => t }) : void 0,
  P8 = '$lit$',
  Pa = `lit$${Math.random().toFixed(9).slice(2)}$`,
  R8 = '?' + Pa,
  Zae = `<${R8}>`,
  Eu = document,
  Lf = () => Eu.createComment(''),
  $f = t => t === null || (typeof t != 'object' && typeof t != 'function'),
  HA = Array.isArray,
  Yae = t => HA(t) || typeof (t == null ? void 0 : t[Symbol.iterator]) == 'function',
  yb = `[ 	
\f\r]`,
  sh = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
  _x = /-->/g,
  Cx = />/g,
  vc = RegExp(
    `>|${yb}(?:([^\\s"'>=/]+)(${yb}*=${yb}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
    'g'
  ),
  Sx = /'/g,
  Ix = /"/g,
  k8 = /^(?:script|style|textarea|title)$/i,
  O8 =
    t =>
    (e, ...n) => ({ _$litType$: t, strings: e, values: n }),
  Tme = O8(1),
  Nme = O8(2),
  ld = Symbol.for('lit-noChange'),
  fr = Symbol.for('lit-nothing'),
  xx = new WeakMap(),
  Fc = Eu.createTreeWalker(Eu, 129)
function B8(t, e) {
  if (!HA(t) || !t.hasOwnProperty('raw')) throw Error('invalid template strings array')
  return Ax !== void 0 ? Ax.createHTML(e) : e
}
const Jae = (t, e) => {
  const n = t.length - 1,
    r = []
  let s,
    i = e === 2 ? '<svg>' : e === 3 ? '<math>' : '',
    o = sh
  for (let a = 0; a < n; a++) {
    const c = t[a]
    let u,
      l,
      d = -1,
      h = 0
    for (; h < c.length && ((o.lastIndex = h), (l = o.exec(c)), l !== null); )
      (h = o.lastIndex),
        o === sh
          ? l[1] === '!--'
            ? (o = _x)
            : l[1] !== void 0
              ? (o = Cx)
              : l[2] !== void 0
                ? (k8.test(l[2]) && (s = RegExp('</' + l[2], 'g')), (o = vc))
                : l[3] !== void 0 && (o = vc)
          : o === vc
            ? l[0] === '>'
              ? ((o = s ?? sh), (d = -1))
              : l[1] === void 0
                ? (d = -2)
                : ((d = o.lastIndex - l[2].length),
                  (u = l[1]),
                  (o = l[3] === void 0 ? vc : l[3] === '"' ? Ix : Sx))
            : o === Ix || o === Sx
              ? (o = vc)
              : o === _x || o === Cx
                ? (o = sh)
                : ((o = vc), (s = void 0))
    const p = o === vc && t[a + 1].startsWith('/>') ? ' ' : ''
    i +=
      o === sh
        ? c + Zae
        : d >= 0
          ? (r.push(u), c.slice(0, d) + P8 + c.slice(d) + Pa + p)
          : c + Pa + (d === -2 ? a : p)
  }
  return [B8(t, i + (t[n] || '<?>') + (e === 2 ? '</svg>' : e === 3 ? '</math>' : '')), r]
}
class Ff {
  constructor({ strings: e, _$litType$: n }, r) {
    let s
    this.parts = []
    let i = 0,
      o = 0
    const a = e.length - 1,
      c = this.parts,
      [u, l] = Jae(e, n)
    if (
      ((this.el = Ff.createElement(u, r)), (Fc.currentNode = this.el.content), n === 2 || n === 3)
    ) {
      const d = this.el.content.firstChild
      d.replaceWith(...d.childNodes)
    }
    for (; (s = Fc.nextNode()) !== null && c.length < a; ) {
      if (s.nodeType === 1) {
        if (s.hasAttributes())
          for (const d of s.getAttributeNames())
            if (d.endsWith(P8)) {
              const h = l[o++],
                p = s.getAttribute(d).split(Pa),
                y = /([.?@])?(.*)/.exec(h)
              c.push({
                type: 1,
                index: i,
                name: y[2],
                strings: p,
                ctor: y[1] === '.' ? ece : y[1] === '?' ? tce : y[1] === '@' ? nce : Q0
              }),
                s.removeAttribute(d)
            } else d.startsWith(Pa) && (c.push({ type: 6, index: i }), s.removeAttribute(d))
        if (k8.test(s.tagName)) {
          const d = s.textContent.split(Pa),
            h = d.length - 1
          if (h > 0) {
            s.textContent = Dm ? Dm.emptyScript : ''
            for (let p = 0; p < h; p++)
              s.append(d[p], Lf()), Fc.nextNode(), c.push({ type: 2, index: ++i })
            s.append(d[h], Lf())
          }
        }
      } else if (s.nodeType === 8)
        if (s.data === R8) c.push({ type: 2, index: i })
        else {
          let d = -1
          for (; (d = s.data.indexOf(Pa, d + 1)) !== -1; )
            c.push({ type: 7, index: i }), (d += Pa.length - 1)
        }
      i++
    }
  }
  static createElement(e, n) {
    const r = Eu.createElement('template')
    return (r.innerHTML = e), r
  }
}
function dd(t, e, n = t, r) {
  var o, a
  if (e === ld) return e
  let s = r !== void 0 ? ((o = n._$Co) == null ? void 0 : o[r]) : n._$Cl
  const i = $f(e) ? void 0 : e._$litDirective$
  return (
    (s == null ? void 0 : s.constructor) !== i &&
      ((a = s == null ? void 0 : s._$AO) == null || a.call(s, !1),
      i === void 0 ? (s = void 0) : ((s = new i(t)), s._$AT(t, n, r)),
      r !== void 0 ? ((n._$Co ?? (n._$Co = []))[r] = s) : (n._$Cl = s)),
    s !== void 0 && (e = dd(t, s._$AS(t, e.values), s, r)),
    e
  )
}
class Xae {
  constructor(e, n) {
    ;(this._$AV = []), (this._$AN = void 0), (this._$AD = e), (this._$AM = n)
  }
  get parentNode() {
    return this._$AM.parentNode
  }
  get _$AU() {
    return this._$AM._$AU
  }
  u(e) {
    const {
        el: { content: n },
        parts: r
      } = this._$AD,
      s = ((e == null ? void 0 : e.creationScope) ?? Eu).importNode(n, !0)
    Fc.currentNode = s
    let i = Fc.nextNode(),
      o = 0,
      a = 0,
      c = r[0]
    for (; c !== void 0; ) {
      if (o === c.index) {
        let u
        c.type === 2
          ? (u = new Cp(i, i.nextSibling, this, e))
          : c.type === 1
            ? (u = new c.ctor(i, c.name, c.strings, this, e))
            : c.type === 6 && (u = new rce(i, this, e)),
          this._$AV.push(u),
          (c = r[++a])
      }
      o !== (c == null ? void 0 : c.index) && ((i = Fc.nextNode()), o++)
    }
    return (Fc.currentNode = Eu), s
  }
  p(e) {
    let n = 0
    for (const r of this._$AV)
      r !== void 0 &&
        (r.strings !== void 0 ? (r._$AI(e, r, n), (n += r.strings.length - 2)) : r._$AI(e[n])),
        n++
  }
}
class Cp {
  get _$AU() {
    var e
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv
  }
  constructor(e, n, r, s) {
    ;(this.type = 2),
      (this._$AH = fr),
      (this._$AN = void 0),
      (this._$AA = e),
      (this._$AB = n),
      (this._$AM = r),
      (this.options = s),
      (this._$Cv = (s == null ? void 0 : s.isConnected) ?? !0)
  }
  get parentNode() {
    let e = this._$AA.parentNode
    const n = this._$AM
    return n !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = n.parentNode), e
  }
  get startNode() {
    return this._$AA
  }
  get endNode() {
    return this._$AB
  }
  _$AI(e, n = this) {
    ;(e = dd(this, e, n)),
      $f(e)
        ? e === fr || e == null || e === ''
          ? (this._$AH !== fr && this._$AR(), (this._$AH = fr))
          : e !== this._$AH && e !== ld && this._(e)
        : e._$litType$ !== void 0
          ? this.$(e)
          : e.nodeType !== void 0
            ? this.T(e)
            : Yae(e)
              ? this.k(e)
              : this._(e)
  }
  O(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB)
  }
  T(e) {
    this._$AH !== e && (this._$AR(), (this._$AH = this.O(e)))
  }
  _(e) {
    this._$AH !== fr && $f(this._$AH)
      ? (this._$AA.nextSibling.data = e)
      : this.T(Eu.createTextNode(e)),
      (this._$AH = e)
  }
  $(e) {
    var i
    const { values: n, _$litType$: r } = e,
      s =
        typeof r == 'number'
          ? this._$AC(e)
          : (r.el === void 0 && (r.el = Ff.createElement(B8(r.h, r.h[0]), this.options)), r)
    if (((i = this._$AH) == null ? void 0 : i._$AD) === s) this._$AH.p(n)
    else {
      const o = new Xae(s, this),
        a = o.u(this.options)
      o.p(n), this.T(a), (this._$AH = o)
    }
  }
  _$AC(e) {
    let n = xx.get(e.strings)
    return n === void 0 && xx.set(e.strings, (n = new Ff(e))), n
  }
  k(e) {
    HA(this._$AH) || ((this._$AH = []), this._$AR())
    const n = this._$AH
    let r,
      s = 0
    for (const i of e)
      s === n.length
        ? n.push((r = new Cp(this.O(Lf()), this.O(Lf()), this, this.options)))
        : (r = n[s]),
        r._$AI(i),
        s++
    s < n.length && (this._$AR(r && r._$AB.nextSibling, s), (n.length = s))
  }
  _$AR(e = this._$AA.nextSibling, n) {
    var r
    for ((r = this._$AP) == null ? void 0 : r.call(this, !1, !0, n); e && e !== this._$AB; ) {
      const s = e.nextSibling
      e.remove(), (e = s)
    }
  }
  setConnected(e) {
    var n
    this._$AM === void 0 && ((this._$Cv = e), (n = this._$AP) == null || n.call(this, e))
  }
}
let Q0 = class {
  get tagName() {
    return this.element.tagName
  }
  get _$AU() {
    return this._$AM._$AU
  }
  constructor(e, n, r, s, i) {
    ;(this.type = 1),
      (this._$AH = fr),
      (this._$AN = void 0),
      (this.element = e),
      (this.name = n),
      (this._$AM = s),
      (this.options = i),
      r.length > 2 || r[0] !== '' || r[1] !== ''
        ? ((this._$AH = Array(r.length - 1).fill(new String())), (this.strings = r))
        : (this._$AH = fr)
  }
  _$AI(e, n = this, r, s) {
    const i = this.strings
    let o = !1
    if (i === void 0)
      (e = dd(this, e, n, 0)), (o = !$f(e) || (e !== this._$AH && e !== ld)), o && (this._$AH = e)
    else {
      const a = e
      let c, u
      for (e = i[0], c = 0; c < i.length - 1; c++)
        (u = dd(this, a[r + c], n, c)),
          u === ld && (u = this._$AH[c]),
          o || (o = !$f(u) || u !== this._$AH[c]),
          u === fr ? (e = fr) : e !== fr && (e += (u ?? '') + i[c + 1]),
          (this._$AH[c] = u)
    }
    o && !s && this.j(e)
  }
  j(e) {
    e === fr
      ? this.element.removeAttribute(this.name)
      : this.element.setAttribute(this.name, e ?? '')
  }
}
class ece extends Q0 {
  constructor() {
    super(...arguments), (this.type = 3)
  }
  j(e) {
    this.element[this.name] = e === fr ? void 0 : e
  }
}
class tce extends Q0 {
  constructor() {
    super(...arguments), (this.type = 4)
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== fr)
  }
}
class nce extends Q0 {
  constructor(e, n, r, s, i) {
    super(e, n, r, s, i), (this.type = 5)
  }
  _$AI(e, n = this) {
    if ((e = dd(this, e, n, 0) ?? fr) === ld) return
    const r = this._$AH,
      s =
        (e === fr && r !== fr) ||
        e.capture !== r.capture ||
        e.once !== r.once ||
        e.passive !== r.passive,
      i = e !== fr && (r === fr || s)
    s && this.element.removeEventListener(this.name, this, r),
      i && this.element.addEventListener(this.name, this, e),
      (this._$AH = e)
  }
  handleEvent(e) {
    var n
    typeof this._$AH == 'function'
      ? this._$AH.call(((n = this.options) == null ? void 0 : n.host) ?? this.element, e)
      : this._$AH.handleEvent(e)
  }
}
class rce {
  constructor(e, n, r) {
    ;(this.element = e), (this.type = 6), (this._$AN = void 0), (this._$AM = n), (this.options = r)
  }
  get _$AU() {
    return this._$AM._$AU
  }
  _$AI(e) {
    dd(this, e)
  }
}
const wb = Lh.litHtmlPolyfillSupport
wb == null || wb(Ff, Cp), (Lh.litHtmlVersions ?? (Lh.litHtmlVersions = [])).push('3.2.1')
const sce = (t, e, n) => {
  const r = (n == null ? void 0 : n.renderBefore) ?? e
  let s = r._$litPart$
  if (s === void 0) {
    const i = (n == null ? void 0 : n.renderBefore) ?? null
    r._$litPart$ = s = new Cp(e.insertBefore(Lf(), i), i, void 0, n ?? {})
  }
  return s._$AI(t), s
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ let Hg = class extends ul {
  constructor() {
    super(...arguments), (this.renderOptions = { host: this }), (this._$Do = void 0)
  }
  createRenderRoot() {
    var n
    const e = super.createRenderRoot()
    return (n = this.renderOptions).renderBefore ?? (n.renderBefore = e.firstChild), e
  }
  update(e) {
    const n = this.render()
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
      super.update(e),
      (this._$Do = sce(n, this.renderRoot, this.renderOptions))
  }
  connectedCallback() {
    var e
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0)
  }
  disconnectedCallback() {
    var e
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1)
  }
  render() {
    return ld
  }
}
var tN
;(Hg._$litElement$ = !0),
  (Hg.finalized = !0),
  (tN = globalThis.litElementHydrateSupport) == null || tN.call(globalThis, { LitElement: Hg })
const bb = globalThis.litElementPolyfillSupport
bb == null || bb({ LitElement: Hg })
;(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push('4.1.1')
let $h, Va, Ga
function kme(t, e) {
  ;($h = document.createElement('style')),
    (Va = document.createElement('style')),
    (Ga = document.createElement('style')),
    ($h.textContent = Bl(t).core.cssText),
    (Va.textContent = Bl(t).dark.cssText),
    (Ga.textContent = Bl(t).light.cssText),
    document.head.appendChild($h),
    document.head.appendChild(Va),
    document.head.appendChild(Ga),
    D8(e)
}
function D8(t) {
  Va &&
    Ga &&
    (t === 'light'
      ? (Va.removeAttribute('media'), (Ga.media = 'enabled'))
      : (Ga.removeAttribute('media'), (Va.media = 'enabled')))
}
function ice(t) {
  $h &&
    Va &&
    Ga &&
    (($h.textContent = Bl(t).core.cssText),
    (Va.textContent = Bl(t).dark.cssText),
    (Ga.textContent = Bl(t).light.cssText))
}
function Bl(t) {
  return {
    core: Ol`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${Xs(t != null && t['--w3m-color-mix-strength'] ? `${t['--w3m-color-mix-strength']}%` : '0%')};
        --w3m-font-family: ${Xs((t == null ? void 0 : t['--w3m-font-family']) || 'Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;')};
        --w3m-font-size-master: ${Xs((t == null ? void 0 : t['--w3m-font-size-master']) || '10px')};
        --w3m-border-radius-master: ${Xs((t == null ? void 0 : t['--w3m-border-radius-master']) || '4px')};
        --w3m-z-index: ${Xs((t == null ? void 0 : t['--w3m-z-index']) || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
    light: Ol`
      :root {
        --w3m-color-mix: ${Xs((t == null ? void 0 : t['--w3m-color-mix']) || '#fff')};
        --w3m-accent: ${Xs(zo(t, 'dark')['--w3m-accent'])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${Xs(zo(t, 'dark')['--w3m-background'])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
    dark: Ol`
      :root {
        --w3m-color-mix: ${Xs((t == null ? void 0 : t['--w3m-color-mix']) || '#000')};
        --w3m-accent: ${Xs(zo(t, 'light')['--w3m-accent'])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${Xs(zo(t, 'light')['--w3m-background'])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `
  }
}
const Ome = Ol`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`,
  Bme = Ol`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`,
  Dme = Ol`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`,
  mg = {
    ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
    ERROR_CODE_DEFAULT: 5e3,
    ERROR_INVALID_CHAIN_ID: 32603
  },
  oce = {
    gasPriceOracle: { address: '0x420000000000000000000000000000000000000F' },
    l1Block: { address: '0x4200000000000000000000000000000000000015' },
    l2CrossDomainMessenger: { address: '0x4200000000000000000000000000000000000007' },
    l2Erc721Bridge: { address: '0x4200000000000000000000000000000000000014' },
    l2StandardBridge: { address: '0x4200000000000000000000000000000000000010' },
    l2ToL1MessagePasser: { address: '0x4200000000000000000000000000000000000016' }
  },
  ace = {
    block: sF({
      format(t) {
        var n
        return {
          transactions:
            (n = t.transactions) == null
              ? void 0
              : n.map(r => {
                  if (typeof r == 'string') return r
                  const s = b0(r)
                  return (
                    s.typeHex === '0x7e' &&
                      ((s.isSystemTx = r.isSystemTx),
                      (s.mint = r.mint ? Ci(r.mint) : void 0),
                      (s.sourceHash = r.sourceHash),
                      (s.type = 'deposit')),
                    s
                  )
                }),
          stateRoot: t.stateRoot
        }
      }
    }),
    transaction: nF({
      format(t) {
        const e = {}
        return (
          t.type === '0x7e' &&
            ((e.isSystemTx = t.isSystemTx),
            (e.mint = t.mint ? Ci(t.mint) : void 0),
            (e.sourceHash = t.sourceHash),
            (e.type = 'deposit')),
          e
        )
      }
    }),
    transactionReceipt: C7({
      format(t) {
        return {
          l1GasPrice: t.l1GasPrice ? Ci(t.l1GasPrice) : null,
          l1GasUsed: t.l1GasUsed ? Ci(t.l1GasUsed) : null,
          l1Fee: t.l1Fee ? Ci(t.l1Fee) : null,
          l1FeeScalar: t.l1FeeScalar ? Number(t.l1FeeScalar) : null
        }
      }
    })
  }
function cce(t, e) {
  return dce(t) ? lce(t) : K7(t, e)
}
const uce = { transaction: cce }
function lce(t) {
  hce(t)
  const { sourceHash: e, data: n, from: r, gas: s, isSystemTx: i, mint: o, to: a, value: c } = t,
    u = [
      e,
      r,
      a ?? '0x',
      o ? wt(o) : '0x',
      c ? wt(c) : '0x',
      s ? wt(s) : '0x',
      i ? '0x1' : '0x',
      n ?? '0x'
    ]
  return na(['0x7e', ec(u)])
}
function dce(t) {
  return t.type === 'deposit' || typeof t.sourceHash < 'u'
}
function hce(t) {
  const { from: e, to: n } = t
  if (e && !Rr(e)) throw new Cs({ address: e })
  if (n && !Rr(n)) throw new Cs({ address: n })
}
const Tx = { contracts: oce, formatters: ace, serializers: uce },
  ih = 1,
  fce = dA({
    ...Tx,
    id: 8453,
    name: 'Base',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: { default: { http: ['https://mainnet.base.org'] } },
    blockExplorers: {
      default: {
        name: 'Basescan',
        url: 'https://basescan.org',
        apiUrl: 'https://api.basescan.org/api'
      }
    },
    contracts: {
      ...Tx.contracts,
      disputeGameFactory: { [ih]: { address: '0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e' } },
      l2OutputOracle: { [ih]: { address: '0x56315b90c40730925ec5485cf004d835058518A0' } },
      multicall3: { address: '0xca11bde05977b3631167028862be2a173976ca11', blockCreated: 5022 },
      portal: {
        [ih]: { address: '0x49048044D57e1C92A77f79988d21Fa8fAF74E97e', blockCreated: 17482143 }
      },
      l1StandardBridge: {
        [ih]: { address: '0x3154Cf16ccdb4C6d922629664174b904d80F2C35', blockCreated: 17482143 }
      }
    },
    sourceId: ih
  }),
  M8 = dA({
    id: 1,
    name: 'Ethereum',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: { default: { http: ['https://eth.merkle.io'] } },
    blockExplorers: {
      default: {
        name: 'Etherscan',
        url: 'https://etherscan.io',
        apiUrl: 'https://api.etherscan.io/api'
      }
    },
    contracts: {
      ensRegistry: { address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e' },
      ensUniversalResolver: {
        address: '0xce01f8eee7E479C928F8919abD53E553a36CeF67',
        blockCreated: 19258213
      },
      multicall3: { address: '0xca11bde05977b3631167028862be2a173976ca11', blockCreated: 14353601 }
    }
  }),
  pce = dA({
    id: 137,
    name: 'Polygon',
    nativeCurrency: { name: 'POL', symbol: 'POL', decimals: 18 },
    rpcUrls: { default: { http: ['https://polygon-rpc.com'] } },
    blockExplorers: {
      default: {
        name: 'PolygonScan',
        url: 'https://polygonscan.com',
        apiUrl: 'https://api.polygonscan.com/api'
      }
    },
    contracts: {
      multicall3: { address: '0xca11bde05977b3631167028862be2a173976ca11', blockCreated: 25770160 }
    }
  })
function Sp(t) {
  return { formatters: void 0, fees: void 0, serializers: void 0, ...t }
}
const jf = Sp({
    id: '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
    name: 'Solana',
    network: 'solana-mainnet',
    nativeCurrency: { name: 'Solana', symbol: 'SOL', decimals: 9 },
    rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
    blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
    testnet: !1,
    chainNamespace: 'solana',
    caipNetworkId: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
    deprecatedCaipNetworkId: 'solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ'
  }),
  Mm = Sp({
    id: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
    name: 'Solana Devnet',
    network: 'solana-devnet',
    nativeCurrency: { name: 'Solana', symbol: 'SOL', decimals: 9 },
    rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
    blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
    testnet: !0,
    chainNamespace: 'solana',
    caipNetworkId: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
    deprecatedCaipNetworkId: 'solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K'
  }),
  gce = Sp({
    id: '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
    name: 'Solana Testnet',
    network: 'solana-testnet',
    nativeCurrency: { name: 'Solana', symbol: 'SOL', decimals: 9 },
    rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
    blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
    testnet: !0,
    chainNamespace: 'solana',
    caipNetworkId: 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z'
  }),
  Ip = Sp({
    id: '000000000019d6689c085ae165831e93',
    caipNetworkId: 'bip122:000000000019d6689c085ae165831e93',
    chainNamespace: 'bip122',
    name: 'Bitcoin',
    nativeCurrency: { name: 'Bitcoin', symbol: 'BTC', decimals: 8 },
    rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } }
  }),
  Z0 = Sp({
    id: '000000000933ea01ad0ee984209779ba',
    caipNetworkId: 'bip122:000000000933ea01ad0ee984209779ba',
    chainNamespace: 'bip122',
    name: 'Bitcoin Testnet',
    nativeCurrency: { name: 'Bitcoin', symbol: 'BTC', decimals: 8 },
    rpcUrls: { default: { http: ['https://rpc.walletconnect.org/v1'] } },
    testnet: !0
  }),
  mce = {
    solana: [
      'solana_signMessage',
      'solana_signTransaction',
      'solana_requestAccounts',
      'solana_getAccounts',
      'solana_signAllTransactions',
      'solana_signAndSendTransaction'
    ],
    eip155: [
      'eth_accounts',
      'eth_requestAccounts',
      'eth_sendRawTransaction',
      'eth_sign',
      'eth_signTransaction',
      'eth_signTypedData',
      'eth_signTypedData_v3',
      'eth_signTypedData_v4',
      'eth_sendTransaction',
      'personal_sign',
      'wallet_switchEthereumChain',
      'wallet_addEthereumChain',
      'wallet_getPermissions',
      'wallet_requestPermissions',
      'wallet_registerOnboarding',
      'wallet_watchAsset',
      'wallet_scanQRCode',
      'wallet_getCallsStatus',
      'wallet_showCallsStatus',
      'wallet_sendCalls',
      'wallet_getCapabilities',
      'wallet_grantPermissions',
      'wallet_revokePermissions',
      'wallet_getAssets'
    ],
    bip122: ['sendTransfer', 'signMessage', 'signPsbt', 'getAccountAddresses']
  },
  Od = {
    getMethodsByChainNamespace(t) {
      return mce[t] || []
    },
    createDefaultNamespace(t) {
      return {
        methods: this.getMethodsByChainNamespace(t),
        events: ['accountsChanged', 'chainChanged'],
        chains: [],
        rpcMap: {}
      }
    },
    applyNamespaceOverrides(t, e) {
      if (!e) return { ...t }
      const n = { ...t },
        r = new Set()
      if (
        (e.methods && Object.keys(e.methods).forEach(s => r.add(s)),
        e.chains && Object.keys(e.chains).forEach(s => r.add(s)),
        e.events && Object.keys(e.events).forEach(s => r.add(s)),
        e.rpcMap &&
          Object.keys(e.rpcMap).forEach(s => {
            const [i] = s.split(':')
            i && r.add(i)
          }),
        r.forEach(s => {
          n[s] || (n[s] = this.createDefaultNamespace(s))
        }),
        e.methods &&
          Object.entries(e.methods).forEach(([s, i]) => {
            n[s] && (n[s].methods = i)
          }),
        e.chains &&
          Object.entries(e.chains).forEach(([s, i]) => {
            n[s] && (n[s].chains = i)
          }),
        e.events &&
          Object.entries(e.events).forEach(([s, i]) => {
            n[s] && (n[s].events = i)
          }),
        e.rpcMap)
      ) {
        const s = new Set()
        Object.entries(e.rpcMap).forEach(([i, o]) => {
          const [a, c] = i.split(':')
          !a ||
            !c ||
            !n[a] ||
            (n[a].rpcMap || (n[a].rpcMap = {}),
            s.has(a) || ((n[a].rpcMap = {}), s.add(a)),
            (n[a].rpcMap[c] = o))
        })
      }
      return n
    },
    createNamespaces(t, e) {
      const n = t.reduce((r, s) => {
        const { id: i, chainNamespace: o, rpcUrls: a } = s,
          c = a.default.http[0]
        r[o] || (r[o] = this.createDefaultNamespace(o))
        const u = `${o}:${i}`,
          l = r[o]
        switch ((l.chains.push(u), u)) {
          case jf.caipNetworkId:
            l.chains.push(jf.deprecatedCaipNetworkId)
            break
          case Mm.caipNetworkId:
            l.chains.push(Mm.deprecatedCaipNetworkId)
            break
        }
        return l != null && l.rpcMap && c && (l.rpcMap[i] = c), r
      }, {})
      return this.applyNamespaceOverrides(n, e)
    },
    resolveReownName: async t => {
      var r
      const e = await b8.resolveName(t)
      return (
        ((r = (Object.values(e == null ? void 0 : e.addresses) || [])[0]) == null
          ? void 0
          : r.address) || !1
      )
    },
    getChainsFromNamespaces(t = {}) {
      return Object.values(t).flatMap(e => {
        const n = e.chains || [],
          r = e.accounts.map(s => {
            const [i, o] = s.split(':')
            return `${i}:${o}`
          })
        return Array.from(new Set([...n, ...r]))
      })
    },
    isSessionEventData(t) {
      return (
        typeof t == 'object' &&
        t !== null &&
        'id' in t &&
        'topic' in t &&
        'params' in t &&
        typeof t.params == 'object' &&
        t.params !== null &&
        'chainId' in t.params &&
        'event' in t.params &&
        typeof t.params.event == 'object' &&
        t.params.event !== null
      )
    }
  }
class xp {
  constructor({ provider: e, namespace: n }) {
    ;(this.id = Ae.CONNECTOR_ID.WALLET_CONNECT),
      (this.name = Vr.ConnectorNamesMap[Ae.CONNECTOR_ID.WALLET_CONNECT]),
      (this.type = 'WALLET_CONNECT'),
      (this.imageId = Vr.ConnectorImageIds[Ae.CONNECTOR_ID.WALLET_CONNECT]),
      (this.getCaipNetworks = ne.getCaipNetworks.bind(ne)),
      (this.caipNetworks = this.getCaipNetworks()),
      (this.provider = e),
      (this.chain = n)
  }
  get chains() {
    return this.getCaipNetworks()
  }
  async connectWalletConnect() {
    if (!(await this.authenticate())) {
      const n = this.getCaipNetworks(),
        r = Pe.state.universalProviderConfigOverride,
        s = Od.createNamespaces(n, r)
      await this.provider.connect({ optionalNamespaces: s })
    }
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session
    }
  }
  async disconnect() {
    await this.provider.disconnect()
  }
  async authenticate() {
    const e = this.chains.map(n => n.caipNetworkId)
    return Mh.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains: e,
      methods: yce
    })
  }
}
const yce = [
  'eth_accounts',
  'eth_requestAccounts',
  'eth_sendRawTransaction',
  'eth_sign',
  'eth_signTransaction',
  'eth_signTypedData',
  'eth_signTypedData_v3',
  'eth_signTypedData_v4',
  'eth_sendTransaction',
  'personal_sign',
  'wallet_switchEthereumChain',
  'wallet_addEthereumChain',
  'wallet_getPermissions',
  'wallet_requestPermissions',
  'wallet_registerOnboarding',
  'wallet_watchAsset',
  'wallet_scanQRCode',
  'wallet_getCallsStatus',
  'wallet_sendCalls',
  'wallet_getCapabilities',
  'wallet_grantPermissions',
  'wallet_revokePermissions',
  'wallet_getAssets'
]
class Y0 {
  constructor(e) {
    ;(this.availableConnectors = []),
      (this.eventListeners = new Map()),
      (this.getCaipNetworks = n => ne.getCaipNetworks(n)),
      e && this.construct(e)
  }
  construct(e) {
    ;(this.projectId = e.projectId),
      (this.namespace = e.namespace),
      (this.adapterType = e.adapterType)
  }
  get connectors() {
    return this.availableConnectors
  }
  get networks() {
    return this.getCaipNetworks(this.namespace)
  }
  setAuthProvider(e) {
    this.addConnector({
      id: Ae.CONNECTOR_ID.AUTH,
      type: 'AUTH',
      name: Ae.CONNECTOR_NAMES.AUTH,
      provider: e,
      imageId: Vr.ConnectorImageIds[Ae.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    })
  }
  addConnector(...e) {
    const n = new Set()
    ;(this.availableConnectors = [...e, ...this.availableConnectors].filter(r =>
      n.has(r.id) ? !1 : (n.add(r.id), !0)
    )),
      this.emit('connectors', this.availableConnectors)
  }
  setStatus(e, n) {
    Ye.setStatus(e, n)
  }
  on(e, n) {
    var r
    this.eventListeners.has(e) || this.eventListeners.set(e, new Set()),
      (r = this.eventListeners.get(e)) == null || r.add(n)
  }
  off(e, n) {
    const r = this.eventListeners.get(e)
    r && r.delete(n)
  }
  removeAllEventListeners() {
    this.eventListeners.forEach(e => {
      e.clear()
    })
  }
  emit(e, n) {
    const r = this.eventListeners.get(e)
    r && r.forEach(s => s(n))
  }
  async connectWalletConnect(e) {
    return { clientId: (await this.getWalletConnectConnector().connectWalletConnect()).clientId }
  }
  async switchNetwork(e) {
    var i
    const { caipNetwork: n, providerType: r } = e
    if (!e.provider) return
    const s = 'provider' in e.provider ? e.provider.provider : e.provider
    if (r === 'WALLET_CONNECT') {
      s.setDefaultChain(n.caipNetworkId)
      return
    }
    if (s && r === 'AUTH') {
      const o = s,
        a = (i = Ye.state.preferredAccountTypes) == null ? void 0 : i[n.chainNamespace]
      await o.switchNetwork(n.caipNetworkId)
      const c = await o.getUser({ chainId: n.caipNetworkId, preferredAccountType: a })
      this.emit('switchNetwork', c)
    }
  }
  getWalletConnectConnector() {
    const e = this.connectors.find(n => n instanceof xp)
    if (!e) throw new Error('WalletConnectConnector not found')
    return e
  }
}
class wce extends Y0 {
  setUniversalProvider(e) {
    this.addConnector(
      new xp({ provider: e, caipNetworks: this.getCaipNetworks(), namespace: this.namespace })
    )
  }
  async connect(e) {
    return Promise.resolve({
      id: 'WALLET_CONNECT',
      type: 'WALLET_CONNECT',
      chainId: Number(e.chainId),
      provider: this.provider,
      address: ''
    })
  }
  async disconnect() {
    try {
      await this.getWalletConnectConnector().disconnect()
    } catch (e) {
      console.warn('UniversalAdapter:disconnect - error', e)
    }
  }
  async getAccounts({ namespace: e }) {
    var s, i, o, a
    const n = this.provider,
      r =
        ((a =
          (o =
            (i = (s = n == null ? void 0 : n.session) == null ? void 0 : s.namespaces) == null
              ? void 0
              : i[e]) == null
            ? void 0
            : o.accounts) == null
          ? void 0
          : a
              .map(c => {
                const [, , u] = c.split(':')
                return u
              })
              .filter((c, u, l) => l.indexOf(c) === u)) || []
    return Promise.resolve({
      accounts: r.map(c => dt.createAccount(e, c, e === 'bip122' ? 'payment' : 'eoa'))
    })
  }
  async syncConnectors() {
    return Promise.resolve()
  }
  async getBalance(e) {
    var i, o, a, c, u
    if (
      !(
        e.caipNetwork &&
        gr.BALANCE_SUPPORTED_CHAINS.includes(
          (i = e.caipNetwork) == null ? void 0 : i.chainNamespace
        )
      ) ||
      ((o = e.caipNetwork) != null && o.testnet)
    )
      return {
        balance: '0.00',
        symbol: ((a = e.caipNetwork) == null ? void 0 : a.nativeCurrency.symbol) || ''
      }
    if (
      Ye.state.balanceLoading &&
      e.chainId === ((c = ne.state.activeCaipNetwork) == null ? void 0 : c.id)
    )
      return { balance: Ye.state.balance || '0.00', symbol: Ye.state.balanceSymbol || '' }
    const s = (await Ye.fetchTokenBalance()).find(l => {
      var d, h
      return (
        l.chainId === `${(d = e.caipNetwork) == null ? void 0 : d.chainNamespace}:${e.chainId}` &&
        l.symbol === ((h = e.caipNetwork) == null ? void 0 : h.nativeCurrency.symbol)
      )
    })
    return {
      balance: (s == null ? void 0 : s.quantity.numeric) || '0.00',
      symbol:
        (s == null ? void 0 : s.symbol) ||
        ((u = e.caipNetwork) == null ? void 0 : u.nativeCurrency.symbol) ||
        ''
    }
  }
  async signMessage(e) {
    var o, a, c
    const { provider: n, message: r, address: s } = e
    if (!n) throw new Error('UniversalAdapter:signMessage - provider is undefined')
    let i = ''
    return (
      ((o = ne.state.activeCaipNetwork) == null ? void 0 : o.chainNamespace) === Ae.CHAIN.SOLANA
        ? (i = (
            await n.request(
              {
                method: 'solana_signMessage',
                params: { message: vs.encode(new TextEncoder().encode(r)), pubkey: s }
              },
              (a = ne.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId
            )
          ).signature)
        : (i = await n.request(
            { method: 'personal_sign', params: [r, s] },
            (c = ne.state.activeCaipNetwork) == null ? void 0 : c.caipNetworkId
          )),
      { signature: i }
    )
  }
  async estimateGas() {
    return Promise.resolve({ gas: BigInt(0) })
  }
  async getProfile() {
    return Promise.resolve({ profileImage: '', profileName: '' })
  }
  async sendTransaction() {
    return Promise.resolve({ hash: '' })
  }
  walletGetAssets(e) {
    return Promise.resolve({})
  }
  async writeContract() {
    return Promise.resolve({ hash: '' })
  }
  async getEnsAddress() {
    return Promise.resolve({ address: !1 })
  }
  parseUnits() {
    return 0n
  }
  formatUnits() {
    return '0'
  }
  async getCapabilities() {
    return Promise.resolve({})
  }
  async grantPermissions() {
    return Promise.resolve({})
  }
  async revokePermissions() {
    return Promise.resolve('0x')
  }
  async syncConnection() {
    return Promise.resolve({
      id: 'WALLET_CONNECT',
      type: 'WALLET_CONNECT',
      chainId: 1,
      provider: this.provider,
      address: ''
    })
  }
  async switchNetwork(e) {
    var s, i, o, a, c, u
    const { caipNetwork: n } = e,
      r = this.getWalletConnectConnector()
    if (n.chainNamespace === Ae.CHAIN.EVM)
      try {
        await ((s = r.provider) == null
          ? void 0
          : s.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: wt(n.id) }] }))
      } catch (l) {
        if (
          l.code === mg.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
          l.code === mg.ERROR_INVALID_CHAIN_ID ||
          l.code === mg.ERROR_CODE_DEFAULT ||
          ((o = (i = l == null ? void 0 : l.data) == null ? void 0 : i.originalError) == null
            ? void 0
            : o.code) === mg.ERROR_CODE_UNRECOGNIZED_CHAIN_ID
        )
          try {
            await ((u = r.provider) == null
              ? void 0
              : u.request({
                  method: 'wallet_addEthereumChain',
                  params: [
                    {
                      chainId: wt(n.id),
                      rpcUrls: [
                        (a = n == null ? void 0 : n.rpcUrls.chainDefault) == null ? void 0 : a.http
                      ],
                      chainName: n.name,
                      nativeCurrency: n.nativeCurrency,
                      blockExplorerUrls: [(c = n.blockExplorers) == null ? void 0 : c.default.url]
                    }
                  ]
                }))
          } catch {
            throw new Error('Chain is not supported')
          }
      }
    r.provider.setDefaultChain(n.caipNetworkId)
  }
  getWalletConnectProvider() {
    const e = this.connectors.find(r => r.type === 'WALLET_CONNECT')
    return e == null ? void 0 : e.provider
  }
}
class bce {
  constructor(e) {
    ;(this.chainNamespaces = []),
      (this.reportedAlertErrors = {}),
      (this.getCaipNetwork = (n, r) => {
        var s, i, o, a
        if (n) {
          const c =
            (i = (s = ne.getNetworkData(n)) == null ? void 0 : s.requestedCaipNetworks) == null
              ? void 0
              : i.find(l => l.id === r)
          if (c) return c
          const u = (o = ne.getNetworkData(n)) == null ? void 0 : o.caipNetwork
          return (
            u ||
            ((a = ne.getRequestedCaipNetworks(n).filter(l => l.chainNamespace === n)) == null
              ? void 0
              : a[0])
          )
        }
        return ne.state.activeCaipNetwork || this.defaultCaipNetwork
      }),
      (this.getCaipNetworkId = () => {
        const n = this.getCaipNetwork()
        if (n) return n.id
      }),
      (this.getCaipNetworks = n => ne.getCaipNetworks(n)),
      (this.getActiveChainNamespace = () => ne.state.activeChain),
      (this.setRequestedCaipNetworks = (n, r) => {
        ne.setRequestedCaipNetworks(n, r)
      }),
      (this.getApprovedCaipNetworkIds = () => ne.getAllApprovedCaipNetworkIds()),
      (this.getCaipAddress = n =>
        ne.state.activeChain === n || !n
          ? ne.state.activeCaipAddress
          : ne.getAccountProp('caipAddress', n)),
      (this.setClientId = n => {
        gt.setClientId(n)
      }),
      (this.getProvider = n => on.getProvider(n)),
      (this.getProviderType = n => on.getProviderId(n)),
      (this.getPreferredAccountType = n => {
        var r
        return (r = Ye.state.preferredAccountTypes) == null ? void 0 : r[n]
      }),
      (this.setCaipAddress = (n, r) => {
        Ye.setCaipAddress(n, r)
      }),
      (this.setBalance = (n, r, s) => {
        Ye.setBalance(n, r, s)
      }),
      (this.setProfileName = (n, r) => {
        Ye.setProfileName(n, r)
      }),
      (this.setProfileImage = (n, r) => {
        Ye.setProfileImage(n, r)
      }),
      (this.setUser = (n, r) => {
        Ye.setUser(n, r), Pe.state.enableEmbedded && Kn.close()
      }),
      (this.resetAccount = n => {
        Ye.resetAccount(n)
      }),
      (this.setCaipNetwork = n => {
        ne.setActiveCaipNetwork(n)
      }),
      (this.setCaipNetworkOfNamespace = (n, r) => {
        ne.setChainNetworkData(r, { caipNetwork: n })
      }),
      (this.setAllAccounts = (n, r) => {
        Ye.setAllAccounts(n, r), Pe.setHasMultipleAddresses((n == null ? void 0 : n.length) > 1)
      }),
      (this.setStatus = (n, r) => {
        Ye.setStatus(n, r),
          Et.isConnected()
            ? Ke.setConnectionStatus('connected')
            : Ke.setConnectionStatus('disconnected')
      }),
      (this.getAddressByChainNamespace = n => ne.getAccountProp('address', n)),
      (this.setConnectors = n => {
        const r = [...Et.state.allConnectors, ...n]
        Et.setConnectors(r)
      }),
      (this.fetchIdentity = n => gt.fetchIdentity(n)),
      (this.getReownName = n => b8.getNamesForAddress(n)),
      (this.getConnectors = () => Et.getConnectors()),
      (this.getConnectorImage = n => tk.getConnectorImage(n)),
      (this.setConnectedWalletInfo = (n, r) => {
        const s = on.getProviderId(r),
          i = n ? { ...n, type: s } : void 0
        Ye.setConnectedWalletInfo(i, r)
      }),
      (this.getIsConnectedState = () => !!ne.state.activeCaipAddress),
      (this.addAddressLabel = (n, r, s) => {
        Ye.addAddressLabel(n, r, s)
      }),
      (this.removeAddressLabel = (n, r) => {
        Ye.removeAddressLabel(n, r)
      }),
      (this.getAddress = n =>
        ne.state.activeChain === n || !n ? Ye.state.address : ne.getAccountProp('address', n)),
      (this.setApprovedCaipNetworksData = n => ne.setApprovedCaipNetworksData(n)),
      (this.resetNetwork = n => {
        ne.resetNetwork(n)
      }),
      (this.addConnector = n => {
        Et.addConnector(n)
      }),
      (this.resetWcConnection = () => {
        pn.resetWcConnection()
      }),
      (this.setAddressExplorerUrl = (n, r) => {
        Ye.setAddressExplorerUrl(n, r)
      }),
      (this.setSmartAccountDeployed = (n, r) => {
        Ye.setSmartAccountDeployed(n, r)
      }),
      (this.setSmartAccountEnabledNetworks = (n, r) => {
        ne.setSmartAccountEnabledNetworks(n, r)
      }),
      (this.setPreferredAccountType = (n, r) => {
        Ye.setPreferredAccountType(n, r)
      }),
      (this.setEIP6963Enabled = n => {
        Pe.setEIP6963Enabled(n)
      }),
      (this.handleUnsafeRPCRequest = () => {
        if (this.isOpen()) {
          if (this.isTransactionStackEmpty()) return
          this.redirect('ApproveTransaction')
        } else this.open({ view: 'ApproveTransaction' })
      }),
      (this.options = e),
      (this.version = e.sdkVersion),
      (this.caipNetworks = this.extendCaipNetworks(e)),
      (this.chainNamespaces = this.getChainNamespacesSet(e.adapters, this.caipNetworks)),
      (this.defaultCaipNetwork = this.extendDefaultCaipNetwork(e)),
      (this.chainAdapters = this.createAdapters(e.adapters)),
      this.initialize(e)
  }
  getChainNamespacesSet(e, n) {
    const r = e == null ? void 0 : e.map(i => i.namespace).filter(i => !!i)
    if (r != null && r.length) return [...new Set(r)]
    const s = n == null ? void 0 : n.map(i => i.chainNamespace)
    return [...new Set(s)]
  }
  async initialize(e) {
    this.initControllers(e),
      await this.initChainAdapters(),
      await this.injectModalUi(),
      this.sendInitializeEvent(e),
      no.set({ initialized: !0 }),
      await this.syncExistingConnection()
  }
  sendInitializeEvent(e) {
    var r
    const { ...n } = e
    delete n.adapters,
      delete n.universalProvider,
      gn.sendEvent({
        type: 'track',
        event: 'INITIALIZE',
        properties: {
          ...n,
          networks: e.networks.map(s => s.id),
          siweConfig: { options: ((r = e.siweConfig) == null ? void 0 : r.options) || {} }
        }
      })
  }
  initControllers(e) {
    this.initializeOptionsController(e),
      this.initializeChainController(e),
      this.initializeThemeController(e),
      this.initializeConnectionController(e),
      this.initializeConnectorController()
  }
  initializeThemeController(e) {
    e.themeMode && zr.setThemeMode(e.themeMode),
      e.themeVariables && zr.setThemeVariables(e.themeVariables)
  }
  initializeChainController(e) {
    if (!this.connectionControllerClient || !this.networkControllerClient)
      throw new Error('ConnectionControllerClient and NetworkControllerClient must be set')
    ne.initialize(e.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    })
    const n = this.getDefaultNetwork()
    n && ne.setActiveCaipNetwork(n)
  }
  initializeConnectionController(e) {
    pn.setWcBasic(e.basic ?? !1)
  }
  initializeConnectorController() {
    Et.initialize(this.chainNamespaces)
  }
  initializeOptionsController(e) {
    var o
    Pe.setDebug(e.debug !== !1),
      Pe.setEnableWalletConnect(e.enableWalletConnect !== !1),
      Pe.setEnableWalletGuide(e.enableWalletGuide !== !1),
      Pe.setEnableWallets(e.enableWallets !== !1),
      Pe.setEIP6963Enabled(e.enableEIP6963 !== !1),
      Pe.setEnableNetworkSwitch(e.enableNetworkSwitch !== !1),
      Pe.setEnableAuthLogger(e.enableAuthLogger !== !1),
      Pe.setCustomRpcUrls(e.customRpcUrls),
      Pe.setSdkVersion(e.sdkVersion),
      Pe.setProjectId(e.projectId),
      Pe.setEnableEmbedded(e.enableEmbedded),
      Pe.setAllWallets(e.allWallets),
      Pe.setIncludeWalletIds(e.includeWalletIds),
      Pe.setExcludeWalletIds(e.excludeWalletIds),
      Pe.setFeaturedWalletIds(e.featuredWalletIds),
      Pe.setTokens(e.tokens),
      Pe.setTermsConditionsUrl(e.termsConditionsUrl),
      Pe.setPrivacyPolicyUrl(e.privacyPolicyUrl),
      Pe.setCustomWallets(e.customWallets),
      Pe.setFeatures(e.features),
      Pe.setAllowUnsupportedChain(e.allowUnsupportedChain),
      Pe.setUniversalProviderConfigOverride(e.universalProviderConfigOverride),
      Pe.setDefaultAccountTypes(e.defaultAccountTypes)
    const n = Ke.getPreferredAccountTypes(),
      r = { ...Pe.state.defaultAccountTypes, ...n }
    Ye.setPreferredAccountTypes(r)
    const s = this.getDefaultMetaData()
    if (
      (!e.metadata && s && (e.metadata = s),
      Pe.setMetadata(e.metadata),
      Pe.setDisableAppend(e.disableAppend),
      Pe.setEnableEmbedded(e.enableEmbedded),
      Pe.setSIWX(e.siwx),
      !e.projectId)
    ) {
      qa.open(La.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, 'error')
      return
    }
    if (
      ((o = e.adapters) == null ? void 0 : o.find(a => a.namespace === Ae.CHAIN.EVM)) &&
      e.siweConfig
    ) {
      if (e.siwx) throw new Error('Cannot set both `siweConfig` and `siwx` options')
      Pe.setSIWX(e.siweConfig.mapToSIWX())
    }
  }
  getDefaultMetaData() {
    var e, n, r, s
    return typeof window < 'u' && typeof document < 'u'
      ? {
          name:
            ((n = (e = document.getElementsByTagName('title')) == null ? void 0 : e[0]) == null
              ? void 0
              : n.textContent) || '',
          description:
            ((r = document.querySelector('meta[property="og:description"]')) == null
              ? void 0
              : r.content) || '',
          url: window.location.origin,
          icons: [
            ((s = document.querySelector('link[rel~="icon"]')) == null ? void 0 : s.href) || ''
          ]
        }
      : null
  }
  setUnsupportedNetwork(e) {
    const n = this.getActiveChainNamespace()
    if (n) {
      const r = Xi.getUnsupportedNetwork(`${n}:${e}`)
      ne.setActiveCaipNetwork(r)
    }
  }
  getDefaultNetwork() {
    return Xi.getCaipNetworkFromStorage(this.defaultCaipNetwork)
  }
  extendCaipNetwork(e, n) {
    return Xi.extendCaipNetwork(e, {
      customNetworkImageUrls: n.chainImages,
      projectId: n.projectId
    })
  }
  extendCaipNetworks(e) {
    return Xi.extendCaipNetworks(e.networks, {
      customNetworkImageUrls: e.chainImages,
      customRpcUrls: e.customRpcUrls,
      projectId: e.projectId
    })
  }
  extendDefaultCaipNetwork(e) {
    const n = e.networks.find(s => {
      var i
      return s.id === ((i = e.defaultNetwork) == null ? void 0 : i.id)
    })
    return n
      ? Xi.extendCaipNetwork(n, {
          customNetworkImageUrls: e.chainImages,
          customRpcUrls: e.customRpcUrls,
          projectId: e.projectId
        })
      : void 0
  }
  createClients() {
    ;(this.connectionControllerClient = {
      connectWalletConnect: async () => {
        var i
        const e = ne.state.activeChain,
          n = this.getAdapter(e),
          r = (i = this.getCaipNetwork(e)) == null ? void 0 : i.id
        if (!n) throw new Error('Adapter not found')
        const s = await n.connectWalletConnect(r)
        this.close(),
          this.setClientId((s == null ? void 0 : s.clientId) || null),
          Ke.setConnectedNamespaces([...ne.state.chains.keys()]),
          this.chainNamespaces.forEach(o => {
            Et.setConnectorId(In.CONNECTOR_TYPE_WALLET_CONNECT, o)
          }),
          await this.syncWalletConnectAccount()
      },
      connectExternal: async ({
        id: e,
        info: n,
        type: r,
        provider: s,
        chain: i,
        caipNetwork: o
      }) => {
        var p, y, m, b, I, x
        const a = ne.state.activeChain,
          c = i || a,
          u = this.getAdapter(c)
        if (i && i !== a && !o) {
          const _ = this.getCaipNetworks().find(R => R.chainNamespace === i)
          _ && this.setCaipNetwork(_)
        }
        if (!u) throw new Error('Adapter not found')
        const l = this.getCaipNetwork(c),
          d = await u.connect({
            id: e,
            info: n,
            type: r,
            provider: s,
            chainId: (o == null ? void 0 : o.id) || (l == null ? void 0 : l.id),
            rpcUrl:
              ((m =
                (y = (p = o == null ? void 0 : o.rpcUrls) == null ? void 0 : p.default) == null
                  ? void 0
                  : y.http) == null
                ? void 0
                : m[0]) ||
              ((x =
                (I = (b = l == null ? void 0 : l.rpcUrls) == null ? void 0 : b.default) == null
                  ? void 0
                  : I.http) == null
                ? void 0
                : x[0])
          })
        if (!d) return
        Ke.addConnectedNamespace(c), this.syncProvider({ ...d, chainNamespace: c })
        const { accounts: h } = await u.getAccounts({ namespace: c, id: e })
        this.setAllAccounts(h, c), this.setStatus('connected', c)
      },
      reconnectExternal: async ({ id: e, info: n, type: r, provider: s }) => {
        var a
        const i = ne.state.activeChain,
          o = this.getAdapter(i)
        o != null &&
          o.reconnect &&
          (await (o == null
            ? void 0
            : o.reconnect({
                id: e,
                info: n,
                type: r,
                provider: s,
                chainId: (a = this.getCaipNetwork()) == null ? void 0 : a.id
              })),
          Ke.addConnectedNamespace(i))
      },
      disconnect: async e => {
        const n = e || ne.state.activeChain,
          r = this.getAdapter(n),
          s = on.getProvider(n),
          i = on.getProviderId(n)
        await (r == null ? void 0 : r.disconnect({ provider: s, providerType: i })),
          Ke.removeConnectedNamespace(n),
          on.resetChain(n),
          this.setUser(void 0, n),
          this.setStatus('disconnected', n)
      },
      checkInstalled: e =>
        e
          ? e.some(n => {
              var r
              return !!((r = window.ethereum) != null && r[String(n)])
            })
          : !!window.ethereum,
      signMessage: async e => {
        const n = this.getAdapter(ne.state.activeChain),
          r = await (n == null
            ? void 0
            : n.signMessage({
                message: e,
                address: Ye.state.address,
                provider: on.getProvider(ne.state.activeChain)
              }))
        return (r == null ? void 0 : r.signature) || ''
      },
      sendTransaction: async e => {
        if (e.chainNamespace === Ae.CHAIN.EVM) {
          const n = this.getAdapter(ne.state.activeChain),
            r = on.getProvider(ne.state.activeChain),
            s = await (n == null
              ? void 0
              : n.sendTransaction({ ...e, caipNetwork: this.getCaipNetwork(), provider: r }))
          return (s == null ? void 0 : s.hash) || ''
        }
        return ''
      },
      estimateGas: async e => {
        if (e.chainNamespace === Ae.CHAIN.EVM) {
          const n = this.getAdapter(ne.state.activeChain),
            r = on.getProvider(ne.state.activeChain),
            s = this.getCaipNetwork()
          if (!s) throw new Error('CaipNetwork is undefined')
          const i = await (n == null
            ? void 0
            : n.estimateGas({ ...e, provider: r, caipNetwork: s }))
          return (i == null ? void 0 : i.gas) || 0n
        }
        return 0n
      },
      getEnsAvatar: async () => {
        var r
        const e = this.getAdapter(ne.state.activeChain),
          n = await (e == null
            ? void 0
            : e.getProfile({
                address: Ye.state.address,
                chainId: Number((r = this.getCaipNetwork()) == null ? void 0 : r.id)
              }))
        return (n == null ? void 0 : n.profileImage) || !1
      },
      getEnsAddress: async e => {
        const n = this.getAdapter(ne.state.activeChain),
          r = this.getCaipNetwork()
        if (!r) return !1
        const s = await (n == null ? void 0 : n.getEnsAddress({ name: e, caipNetwork: r }))
        return (s == null ? void 0 : s.address) || !1
      },
      writeContract: async e => {
        const n = this.getAdapter(ne.state.activeChain),
          r = this.getCaipNetwork(),
          s = this.getCaipAddress(),
          i = on.getProvider(ne.state.activeChain)
        if (!r || !s) throw new Error('CaipNetwork or CaipAddress is undefined')
        const o = await (n == null
          ? void 0
          : n.writeContract({ ...e, caipNetwork: r, provider: i, caipAddress: s }))
        return o == null ? void 0 : o.hash
      },
      parseUnits: (e, n) => {
        const r = this.getAdapter(ne.state.activeChain)
        return (r == null ? void 0 : r.parseUnits({ value: e, decimals: n })) ?? 0n
      },
      formatUnits: (e, n) => {
        const r = this.getAdapter(ne.state.activeChain)
        return (r == null ? void 0 : r.formatUnits({ value: e, decimals: n })) ?? '0'
      },
      getCapabilities: async e => {
        const n = this.getAdapter(ne.state.activeChain)
        return await (n == null ? void 0 : n.getCapabilities(e))
      },
      grantPermissions: async e => {
        const n = this.getAdapter(ne.state.activeChain)
        return await (n == null ? void 0 : n.grantPermissions(e))
      },
      revokePermissions: async e => {
        const n = this.getAdapter(ne.state.activeChain)
        return n != null && n.revokePermissions ? await n.revokePermissions(e) : '0x'
      },
      walletGetAssets: async e => {
        const n = this.getAdapter(ne.state.activeChain)
        return (await (n == null ? void 0 : n.walletGetAssets(e))) ?? {}
      }
    }),
      (this.networkControllerClient = {
        switchCaipNetwork: async e => await this.switchCaipNetwork(e),
        getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()
      }),
      pn.setClient(this.connectionControllerClient)
  }
  getApprovedCaipNetworksData() {
    var n, r, s, i, o
    if (on.getProviderId(ne.state.activeChain) === In.CONNECTOR_TYPE_WALLET_CONNECT) {
      const a =
        (r = (n = this.universalProvider) == null ? void 0 : n.session) == null
          ? void 0
          : r.namespaces
      return {
        supportsAllNetworks:
          ((o =
            (i = (s = this.universalProvider) == null ? void 0 : s.session) == null
              ? void 0
              : i.peer) == null
            ? void 0
            : o.metadata.name) === 'MetaMask Wallet',
        approvedCaipNetworkIds: this.getChainsFromNamespaces(a)
      }
    }
    return { supportsAllNetworks: !0, approvedCaipNetworkIds: [] }
  }
  async switchCaipNetwork(e) {
    if (!e) return
    const n = e.chainNamespace
    if (this.getAddressByChainNamespace(e.chainNamespace)) {
      const s = on.getProvider(n),
        i = on.getProviderId(n)
      if (e.chainNamespace === ne.state.activeChain) {
        const o = this.getAdapter(n)
        await (o == null
          ? void 0
          : o.switchNetwork({ caipNetwork: e, provider: s, providerType: i }))
      } else if ((this.setCaipNetwork(e), i === In.CONNECTOR_TYPE_WALLET_CONNECT))
        this.syncWalletConnectAccount()
      else {
        const o = this.getAddressByChainNamespace(n)
        o && this.syncAccount({ address: o, chainId: e.id, chainNamespace: n })
      }
    } else this.setCaipNetwork(e)
  }
  getChainsFromNamespaces(e = {}) {
    return Object.values(e).flatMap(n => {
      const r = n.chains || [],
        s = n.accounts.map(i => {
          const { chainId: o, chainNamespace: a } = Bo.parseCaipAddress(i)
          return `${a}:${o}`
        })
      return Array.from(new Set([...r, ...s]))
    })
  }
  createAdapters(e) {
    return (
      this.createClients(),
      this.chainNamespaces.reduce((n, r) => {
        var i
        const s = e == null ? void 0 : e.find(o => o.namespace === r)
        return (
          s
            ? (s.construct({
                namespace: r,
                projectId: (i = this.options) == null ? void 0 : i.projectId,
                networks: this.getCaipNetworks()
              }),
              (n[r] = s))
            : (n[r] = new wce({ namespace: r, networks: this.getCaipNetworks() })),
          n
        )
      }, {})
    )
  }
  async initChainAdapter(e) {
    var n
    this.onConnectors(e),
      this.listenAdapter(e),
      (n = this.chainAdapters) == null || n[e].syncConnectors(this.options, this),
      await this.createUniversalProviderForAdapter(e)
  }
  async initChainAdapters() {
    await Promise.all(
      this.chainNamespaces.map(async e => {
        await this.initChainAdapter(e)
      })
    )
  }
  onConnectors(e) {
    const n = this.getAdapter(e)
    n == null || n.on('connectors', this.setConnectors.bind(this))
  }
  listenAdapter(e) {
    const n = this.getAdapter(e)
    if (!n) return
    const r = Ke.getConnectionStatus()
    r === 'connected'
      ? this.setStatus('connecting', e)
      : r === 'disconnected'
        ? (Ke.clearAddressCache(), this.setStatus(r, e))
        : this.setStatus(r, e),
      n.on('switchNetwork', ({ address: s, chainId: i }) => {
        const o = this.getCaipNetworks().find(u => u.id === i || u.caipNetworkId === i),
          a = ne.state.activeChain === e,
          c = ne.getAccountProp('address', e)
        if (o) {
          const u = a && s ? s : c
          u && this.syncAccount({ address: u, chainId: o.id, chainNamespace: e })
        } else this.setUnsupportedNetwork(i)
      }),
      n.on('disconnect', this.disconnect.bind(this, e)),
      n.on('pendingTransactions', () => {
        const s = Ye.state.address,
          i = ne.state.activeCaipNetwork
        !s || !(i != null && i.id) || this.updateNativeBalance(s, i.id, i.chainNamespace)
      }),
      n.on('accountChanged', ({ address: s, chainId: i }) => {
        var a, c
        const o = ne.state.activeChain === e
        o && i
          ? this.syncAccount({ address: s, chainId: i, chainNamespace: e })
          : o && (a = ne.state.activeCaipNetwork) != null && a.id
            ? this.syncAccount({
                address: s,
                chainId: (c = ne.state.activeCaipNetwork) == null ? void 0 : c.id,
                chainNamespace: e
              })
            : this.syncAccountInfo(s, i, e),
          this.syncAllAccounts(e)
      })
  }
  async createUniversalProviderForAdapter(e) {
    var n, r, s
    await this.getUniversalProvider(),
      this.universalProvider &&
        ((s =
          (r = (n = this.chainAdapters) == null ? void 0 : n[e]) == null
            ? void 0
            : r.setUniversalProvider) == null ||
          s.call(r, this.universalProvider))
  }
  async syncExistingConnection() {
    await Promise.allSettled(this.chainNamespaces.map(e => this.syncNamespaceConnection(e)))
  }
  async syncNamespaceConnection(e) {
    try {
      const n = Et.getConnectorId(e)
      switch ((this.setStatus('connecting', e), n)) {
        case Ae.CONNECTOR_ID.WALLET_CONNECT:
          await this.syncWalletConnectAccount()
          break
        case Ae.CONNECTOR_ID.AUTH:
          break
        default:
          await this.syncAdapterConnection(e)
      }
    } catch (n) {
      console.warn("AppKit couldn't sync existing connection", n), this.setStatus('disconnected', e)
    }
  }
  async syncAdapterConnection(e) {
    var o, a, c
    const n = this.getAdapter(e),
      r = Et.getConnectorId(e),
      s = this.getCaipNetwork(e),
      i = Et.getConnectors(e).find(u => u.id === r)
    try {
      if (!n || !i) throw new Error(`Adapter or connector not found for namespace ${e}`)
      if (!(s != null && s.id)) throw new Error('CaipNetwork not found')
      const u = await (n == null
        ? void 0
        : n.syncConnection({
            namespace: e,
            id: i.id,
            chainId: s.id,
            rpcUrl:
              (c =
                (a = (o = s == null ? void 0 : s.rpcUrls) == null ? void 0 : o.default) == null
                  ? void 0
                  : a.http) == null
                ? void 0
                : c[0]
          }))
      if (u) {
        const l = await (n == null ? void 0 : n.getAccounts({ namespace: e, id: i.id }))
        l && l.accounts.length > 0
          ? this.setAllAccounts(l.accounts, e)
          : this.setAllAccounts([dt.createAccount(e, u.address, 'eoa')], e),
          this.syncProvider({ ...u, chainNamespace: e }),
          await this.syncAccount({ ...u, chainNamespace: e }),
          this.setStatus('connected', e)
      } else this.setStatus('disconnected', e)
    } catch {
      this.setStatus('disconnected', e)
    }
  }
  async syncWalletConnectAccount() {
    const e = this.chainNamespaces.map(async n => {
      var a, c, u, l, d
      const r = this.getAdapter(n),
        s =
          ((l =
            (u =
              (c = (a = this.universalProvider) == null ? void 0 : a.session) == null
                ? void 0
                : c.namespaces) == null
              ? void 0
              : u[n]) == null
            ? void 0
            : l.accounts) || [],
        i = (d = ne.state.activeCaipNetwork) == null ? void 0 : d.id,
        o =
          s.find(h => {
            const { chainId: p } = Bo.parseCaipAddress(h)
            return p === (i == null ? void 0 : i.toString())
          }) || s[0]
      if (o) {
        const h = Bo.validateCaipAddress(o),
          { chainId: p, address: y } = Bo.parseCaipAddress(h)
        if (
          (on.setProviderId(n, In.CONNECTOR_TYPE_WALLET_CONNECT),
          this.caipNetworks &&
            ne.state.activeCaipNetwork &&
            (r == null ? void 0 : r.namespace) !== Ae.CHAIN.EVM)
        ) {
          const m =
            r == null
              ? void 0
              : r.getWalletConnectProvider({
                  caipNetworks: this.getCaipNetworks(),
                  provider: this.universalProvider,
                  activeCaipNetwork: ne.state.activeCaipNetwork
                })
          on.setProvider(n, m)
        } else on.setProvider(n, this.universalProvider)
        Et.setConnectorId(Ae.CONNECTOR_ID.WALLET_CONNECT, n),
          Ke.addConnectedNamespace(n),
          this.syncWalletConnectAccounts(n),
          await this.syncAccount({ address: y, chainId: p, chainNamespace: n })
      } else this.setStatus('disconnected', n)
      await ne.setApprovedCaipNetworksData(n)
    })
    await Promise.all(e)
  }
  syncWalletConnectAccounts(e) {
    var r, s, i, o, a
    const n =
      (a =
        (o =
          (i =
            (s = (r = this.universalProvider) == null ? void 0 : r.session) == null
              ? void 0
              : s.namespaces) == null
            ? void 0
            : i[e]) == null
          ? void 0
          : o.accounts) == null
        ? void 0
        : a
            .map(c => {
              const { address: u } = Bo.parseCaipAddress(c)
              return u
            })
            .filter((c, u, l) => l.indexOf(c) === u)
    n &&
      this.setAllAccounts(
        n.map(c => dt.createAccount(e, c, e === 'bip122' ? 'payment' : 'eoa')),
        e
      )
  }
  syncProvider({ type: e, provider: n, id: r, chainNamespace: s }) {
    on.setProviderId(s, e), on.setProvider(s, n), Et.setConnectorId(r, s)
  }
  async syncAllAccounts(e) {
    const n = Et.getConnectorId(e)
    if (!n) return
    const r = this.getAdapter(e),
      s = await (r == null ? void 0 : r.getAccounts({ namespace: e, id: n }))
    s && s.accounts.length > 0 && this.setAllAccounts(s.accounts, e)
  }
  async syncAccount(e) {
    var d, h
    const n = e.chainNamespace === ne.state.activeChain,
      r = ne.getCaipNetworkByNamespace(e.chainNamespace, e.chainId),
      { address: s, chainId: i, chainNamespace: o } = e,
      { chainId: a } = Ke.getActiveNetworkProps(),
      c = i || a,
      u =
        ((d = ne.state.activeCaipNetwork) == null ? void 0 : d.name) ===
        Ae.UNSUPPORTED_NETWORK_NAME,
      l = ne.getNetworkProp('supportsAllNetworks', o)
    if ((this.setStatus('connected', o), !(u && !l) && c)) {
      let p = this.getCaipNetworks().find(b => b.id.toString() === c.toString()),
        y = this.getCaipNetworks().find(b => b.chainNamespace === o)
      if (!l && !p && !y) {
        const b = this.getApprovedCaipNetworkIds() || [],
          I = b.find(_ => {
            var R
            return ((R = Bo.parseCaipNetworkId(_)) == null ? void 0 : R.chainId) === c.toString()
          }),
          x = b.find(_ => {
            var R
            return ((R = Bo.parseCaipNetworkId(_)) == null ? void 0 : R.chainNamespace) === o
          })
        ;(p = this.getCaipNetworks().find(_ => _.caipNetworkId === I)),
          (y = this.getCaipNetworks().find(
            _ =>
              _.caipNetworkId === x ||
              ('deprecatedCaipNetworkId' in _ && _.deprecatedCaipNetworkId === x)
          ))
      }
      const m = p || y
      ;(m == null ? void 0 : m.chainNamespace) === ne.state.activeChain
        ? Pe.state.enableNetworkSwitch &&
          !Pe.state.allowUnsupportedChain &&
          ((h = ne.state.activeCaipNetwork) == null ? void 0 : h.name) ===
            Ae.UNSUPPORTED_NETWORK_NAME
          ? ne.showUnsupportedChainUI()
          : this.setCaipNetwork(m)
        : n || (r && this.setCaipNetworkOfNamespace(r, o)),
        this.syncConnectedWalletInfo(o),
        V0.isLowerCaseMatch(s, Ye.state.address) ||
          this.syncAccountInfo(s, m == null ? void 0 : m.id, o),
        n
          ? await this.syncBalance({
              address: s,
              chainId: m == null ? void 0 : m.id,
              chainNamespace: o
            })
          : await this.syncBalance({
              address: s,
              chainId: r == null ? void 0 : r.id,
              chainNamespace: o
            })
    }
  }
  async syncAccountInfo(e, n, r) {
    const s = this.getCaipAddress(r),
      i = n || (s == null ? void 0 : s.split(':')[1])
    if (!i) return
    const o = `${r}:${i}:${e}`
    this.setCaipAddress(o, r),
      await this.syncIdentity({ address: e, chainId: i, chainNamespace: r })
  }
  async syncReownName(e, n) {
    try {
      const r = await this.getReownName(e)
      if (r[0]) {
        const s = r[0]
        this.setProfileName(s.name, n)
      } else this.setProfileName(null, n)
    } catch {
      this.setProfileName(null, n)
    }
  }
  syncConnectedWalletInfo(e) {
    var s
    const n = Et.getConnectorId(e),
      r = on.getProviderId(e)
    if (r === In.CONNECTOR_TYPE_ANNOUNCED || r === In.CONNECTOR_TYPE_INJECTED) {
      if (n) {
        const i = this.getConnectors().find(o => o.id === n)
        if (i) {
          const { info: o, name: a, imageUrl: c } = i,
            u = c || this.getConnectorImage(i)
          this.setConnectedWalletInfo({ name: a, icon: u, ...o }, e)
        }
      }
    } else if (r === In.CONNECTOR_TYPE_WALLET_CONNECT) {
      const i = on.getProvider(e)
      i != null &&
        i.session &&
        this.setConnectedWalletInfo(
          {
            ...i.session.peer.metadata,
            name: i.session.peer.metadata.name,
            icon: (s = i.session.peer.metadata.icons) == null ? void 0 : s[0]
          },
          e
        )
    } else if (n)
      if (n === Ae.CONNECTOR_ID.COINBASE) {
        const i = this.getConnectors().find(o => o.id === Ae.CONNECTOR_ID.COINBASE)
        this.setConnectedWalletInfo({ name: 'Coinbase Wallet', icon: this.getConnectorImage(i) }, e)
      } else this.setConnectedWalletInfo({ name: n }, e)
  }
  async syncBalance(e) {
    !yf.getNetworksByNamespace(this.getCaipNetworks(), e.chainNamespace).find(r => {
      var s
      return r.id.toString() === ((s = e.chainId) == null ? void 0 : s.toString())
    }) ||
      !e.chainId ||
      (await this.updateNativeBalance(e.address, e.chainId, e.chainNamespace))
  }
  async updateNativeBalance(e, n, r) {
    const s = this.getAdapter(r),
      i = ne.getCaipNetworkByNamespace(r, n)
    if (s) {
      const o = await s.getBalance({
        address: e,
        chainId: n,
        caipNetwork: i,
        tokens: this.options.tokens
      })
      this.setBalance(o.balance, o.symbol, r)
    }
  }
  async initializeUniversalAdapter() {
    var r, s, i, o, a, c, u, l, d, h
    const e = bie.createLogger((p, ...y) => {
        p && this.handleAlertError(p), console.error(...y)
      }),
      n = {
        projectId: (r = this.options) == null ? void 0 : r.projectId,
        metadata: {
          name:
            (s = this.options) != null && s.metadata
              ? (i = this.options) == null
                ? void 0
                : i.metadata.name
              : '',
          description:
            (o = this.options) != null && o.metadata
              ? (a = this.options) == null
                ? void 0
                : a.metadata.description
              : '',
          url:
            (c = this.options) != null && c.metadata
              ? (u = this.options) == null
                ? void 0
                : u.metadata.url
              : '',
          icons:
            (l = this.options) != null && l.metadata
              ? (d = this.options) == null
                ? void 0
                : d.metadata.icons
              : ['']
        },
        logger: e
      }
    Pe.setManualWCControl(!!((h = this.options) != null && h.manualWCControl)),
      (this.universalProvider = this.options.universalProvider ?? (await lie.init(n))),
      this.listenWalletConnect()
  }
  listenWalletConnect() {
    this.universalProvider &&
      (this.universalProvider.on('display_uri', e => {
        pn.setUri(e)
      }),
      this.universalProvider.on('connect', pn.finalizeWcConnection),
      this.universalProvider.on('disconnect', () => {
        this.chainNamespaces.forEach(e => {
          this.resetAccount(e)
        }),
          pn.resetWcConnection()
      }),
      this.universalProvider.on('chainChanged', e => {
        const n = this.getCaipNetworks().find(s => s.id == e),
          r = this.getCaipNetwork()
        if (!n) {
          this.setUnsupportedNetwork(e)
          return
        }
        ;(r == null ? void 0 : r.id) !== (n == null ? void 0 : n.id) && this.setCaipNetwork(n)
      }),
      this.universalProvider.on('session_event', e => {
        if (Od.isSessionEventData(e)) {
          const { name: n, data: r } = e.params.event
          n === 'accountsChanged' &&
            Array.isArray(r) &&
            dt.isCaipAddress(r[0]) &&
            this.syncAccount(Bo.parseCaipAddress(r[0]))
        }
      }))
  }
  createUniversalProvider() {
    var e
    return (
      !this.universalProviderInitPromise &&
        dt.isClient() &&
        (e = this.options) != null &&
        e.projectId &&
        (this.universalProviderInitPromise = this.initializeUniversalAdapter()),
      this.universalProviderInitPromise
    )
  }
  async getUniversalProvider() {
    if (!this.universalProvider)
      try {
        await this.createUniversalProvider()
      } catch (e) {
        gn.sendEvent({
          type: 'error',
          event: 'INTERNAL_SDK_ERROR',
          properties: {
            errorType: 'UniversalProviderInitError',
            errorMessage: e instanceof Error ? e.message : 'Unknown',
            uncaught: !1
          }
        }),
          console.error('AppKit:getUniversalProvider - Cannot create provider', e)
      }
    return this.universalProvider
  }
  handleAlertError(e) {
    const n = Object.entries(La.UniversalProviderErrors).find(([, { message: a }]) =>
        e.message.includes(a)
      ),
      [r, s] = n ?? [],
      { message: i, alertErrorKey: o } = s ?? {}
    if (r && i && !this.reportedAlertErrors[r]) {
      const a = La.ALERT_ERRORS[o]
      a && (qa.open(a, 'error'), (this.reportedAlertErrors[r] = !0))
    }
  }
  getAdapter(e) {
    var n
    if (e) return (n = this.chainAdapters) == null ? void 0 : n[e]
  }
  createAdapter(e) {
    var s
    if (!e) return
    const n = e.namespace
    if (!n) return
    this.createClients()
    const r = e
    ;(r.namespace = n),
      r.construct({
        namespace: n,
        projectId: (s = this.options) == null ? void 0 : s.projectId,
        networks: this.getCaipNetworks()
      }),
      this.chainNamespaces.includes(n) || this.chainNamespaces.push(n),
      this.chainAdapters && (this.chainAdapters[n] = r)
  }
  async open(e) {
    if (
      (await this.injectModalUi(), e != null && e.uri && pn.setUri(e.uri), e != null && e.arguments)
    )
      switch (e == null ? void 0 : e.view) {
        case 'Swap':
          return Kn.open({ ...e, data: { swap: e.arguments } })
      }
    return Kn.open(e)
  }
  async close(e = !1) {
    await this.injectModalUi(), Kn.close(e)
  }
  setLoading(e, n) {
    Kn.setLoading(e, n)
  }
  async disconnect(e) {
    await pn.disconnect(e)
  }
  getError() {
    return ''
  }
  getChainId() {
    var e
    return (e = ne.state.activeCaipNetwork) == null ? void 0 : e.id
  }
  async switchNetwork(e) {
    const n = this.getCaipNetworks().find(r => r.id === e.id)
    if (!n) {
      qa.open(La.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, 'error')
      return
    }
    await ne.switchActiveNetwork(n)
  }
  getWalletProvider() {
    return ne.state.activeChain ? on.state.providers[ne.state.activeChain] : null
  }
  getWalletProviderType() {
    return on.getProviderId(ne.state.activeChain)
  }
  subscribeProviders(e) {
    return on.subscribeProviders(e)
  }
  getThemeMode() {
    return zr.state.themeMode
  }
  getThemeVariables() {
    return zr.state.themeVariables
  }
  setThemeMode(e) {
    zr.setThemeMode(e), D8(zr.state.themeMode)
  }
  setTermsConditionsUrl(e) {
    Pe.setTermsConditionsUrl(e)
  }
  setPrivacyPolicyUrl(e) {
    Pe.setPrivacyPolicyUrl(e)
  }
  setThemeVariables(e) {
    zr.setThemeVariables(e), ice(zr.state.themeVariables)
  }
  subscribeTheme(e) {
    return zr.subscribe(e)
  }
  getWalletInfo() {
    return Ye.state.connectedWalletInfo
  }
  getAccount(e) {
    var i
    const n = Et.getAuthConnector(e),
      r = ne.getAccountData(e),
      s = ne.state.activeChain
    if (r)
      return {
        allAccounts: r.allAccounts,
        caipAddress: r.caipAddress,
        address: dt.getPlainAddress(r.caipAddress),
        isConnected: !!r.caipAddress,
        status: r.status,
        embeddedWalletInfo: n
          ? {
              user: r.user ? { ...r.user, username: Ke.getConnectedSocialUsername() } : void 0,
              authProvider: r.socialProvider || 'email',
              accountType: (i = r.preferredAccountTypes) == null ? void 0 : i[e || s],
              isSmartAccountDeployed: !!r.smartAccountDeployed
            }
          : void 0
      }
  }
  subscribeAccount(e, n) {
    const r = () => {
      const s = this.getAccount(n)
      s && e(s)
    }
    n ? ne.subscribeChainProp('accountState', r, n) : ne.subscribe(r), Et.subscribe(r)
  }
  subscribeNetwork(e) {
    return ne.subscribe(({ activeCaipNetwork: n }) => {
      e({
        caipNetwork: n,
        chainId: n == null ? void 0 : n.id,
        caipNetworkId: n == null ? void 0 : n.caipNetworkId
      })
    })
  }
  subscribeWalletInfo(e) {
    return Ye.subscribeKey('connectedWalletInfo', e)
  }
  subscribeShouldUpdateToAddress(e) {
    Ye.subscribeKey('shouldUpdateToAddress', e)
  }
  subscribeCaipNetworkChange(e) {
    ne.subscribeKey('activeCaipNetwork', e)
  }
  getState() {
    return no.state
  }
  subscribeState(e) {
    return no.subscribe(e)
  }
  showErrorMessage(e) {
    Tr.showError(e)
  }
  showSuccessMessage(e) {
    Tr.showSuccess(e)
  }
  getEvent() {
    return { ...gn.state }
  }
  subscribeEvents(e) {
    return gn.subscribe(e)
  }
  replace(e) {
    nn.replace(e)
  }
  redirect(e) {
    nn.push(e)
  }
  popTransactionStack(e) {
    nn.popTransactionStack(e)
  }
  isOpen() {
    return Kn.state.open
  }
  isTransactionStackEmpty() {
    return nn.state.transactionStack.length === 0
  }
  isTransactionShouldReplaceView() {
    var e
    return (e = nn.state.transactionStack[nn.state.transactionStack.length - 1]) == null
      ? void 0
      : e.replace
  }
  static getInstance() {
    return this.instance
  }
  updateFeatures(e) {
    Pe.setFeatures(e)
  }
  updateOptions(e) {
    const r = { ...(Pe.state || {}), ...e }
    Pe.setOptions(r)
  }
  setConnectMethodsOrder(e) {
    Pe.setConnectMethodsOrder(e)
  }
  setWalletFeaturesOrder(e) {
    Pe.setWalletFeaturesOrder(e)
  }
  setCollapseWallets(e) {
    Pe.setCollapseWallets(e)
  }
  setSocialsOrder(e) {
    Pe.setSocialsOrder(e)
  }
  getConnectMethodsOrder() {
    return Mv.getConnectOrderMethod(Pe.state.features, Et.getConnectors())
  }
  addNetwork(e, n) {
    if (this.chainAdapters && !this.chainAdapters[e])
      throw new Error(`Adapter for namespace ${e} doesn't exist`)
    const r = this.extendCaipNetwork(n, this.options)
    this.getCaipNetworks().find(s => s.id === r.id) || ne.addNetwork(r)
  }
  removeNetwork(e, n) {
    if (this.chainAdapters && !this.chainAdapters[e])
      throw new Error(`Adapter for namespace ${e} doesn't exist`)
    this.getCaipNetworks().find(s => s.id === n) && ne.removeNetwork(e, n)
  }
}
let Nx = !1
class vce extends bce {
  setupAuthConnectorListeners(e) {
    e.onRpcRequest(n => {
      js.checkIfRequestExists(n)
        ? js.checkIfRequestIsSafe(n) || this.handleUnsafeRPCRequest()
        : (this.open(),
          console.error(Jn.RPC_METHOD_NOT_ALLOWED_MESSAGE, { method: n.method }),
          setTimeout(() => {
            this.showErrorMessage(Jn.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE)
          }, 300),
          e.rejectRpcRequests())
    }),
      e.onRpcError(() => {
        this.isOpen() &&
          (this.isTransactionStackEmpty() ? this.close(!0) : this.popTransactionStack(!0))
      }),
      e.onRpcSuccess((n, r) => {
        const s = js.checkIfRequestIsSafe(r),
          i = Ye.state.address,
          o = ne.state.activeCaipNetwork
        s ||
          (this.isTransactionStackEmpty()
            ? (this.close(!0),
              i && o != null && o.id && this.updateNativeBalance(i, o.id, o.chainNamespace))
            : (this.popTransactionStack(),
              i && o != null && o.id && this.updateNativeBalance(i, o.id, o.chainNamespace)))
      }),
      e.onNotConnected(() => {
        const n = ne.state.activeChain
        Et.getConnectorId(n) === Ae.CONNECTOR_ID.AUTH &&
          (this.setCaipAddress(void 0, n), this.setLoading(!1, n))
      }),
      e.onConnect(async n => {
        var a, c
        const r = ne.state.activeChain,
          s = r === Ae.CHAIN.EVM ? `eip155:${n.chainId}:${n.address}` : `${n.chainId}:${n.address}`,
          i =
            n.preferredAccountType ||
            ((a = Ye.state.preferredAccountTypes) == null ? void 0 : a[r]) ||
            Pe.state.defaultAccountTypes[r]
        V0.isLowerCaseMatch(n.address, Ye.state.address) ||
          this.syncIdentity({ address: n.address, chainId: n.chainId, chainNamespace: r }),
          this.setCaipAddress(s, r),
          this.setUser({ ...(Ye.state.user || {}), ...n }, r),
          this.setSmartAccountDeployed(!!n.smartAccountDeployed, r),
          this.setPreferredAccountType(i, r)
        const o =
          (c = n.accounts) == null
            ? void 0
            : c.map(u => {
                var l
                return dt.createAccount(
                  r,
                  u.address,
                  u.type ||
                    ((l = Ye.state.preferredAccountTypes) == null ? void 0 : l[r]) ||
                    Pe.state.defaultAccountTypes[r]
                )
              })
        this.setAllAccounts(o || [dt.createAccount(r, n.address, n.preferredAccountType || i)], r),
          await e.getSmartAccountEnabledNetworks(),
          this.setLoading(!1, r)
      }),
      e.onSocialConnected(({ userName: n }) => {
        this.setUser({ ...(Ye.state.user || {}), username: n }, ne.state.activeChain)
      }),
      e.onGetSmartAccountEnabledNetworks(n => {
        this.setSmartAccountEnabledNetworks(n, ne.state.activeChain)
      }),
      e.onSetPreferredAccount(({ address: n, type: r }) => {
        n && this.setPreferredAccountType(r, ne.state.activeChain)
      })
  }
  async syncAuthConnector(e, n) {
    var l, d, h, p
    const r = Ae.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(n)
    if (!r) return
    this.setLoading(!0, n)
    const s = e.getLoginEmailUsed()
    this.setLoading(s, n), s && this.setStatus('connecting', n)
    const i = e.getEmail(),
      o = e.getUsername()
    this.setUser(
      { ...(((l = Ye.state) == null ? void 0 : l.user) || {}), username: o, email: i },
      ne.state.activeChain
    ),
      this.setupAuthConnectorListeners(e)
    const { isConnected: a } = await e.isConnected(),
      c = zr.getSnapshot(),
      u = Pe.getSnapshot()
    e.syncDappData({
      metadata: u.metadata,
      sdkVersion: u.sdkVersion,
      projectId: u.projectId,
      sdkType: u.sdkType
    }),
      e.syncTheme({
        themeMode: c.themeMode,
        themeVariables: c.themeVariables,
        w3mThemeVariables: zo(c.themeVariables, c.themeMode)
      }),
      n &&
        r &&
        (a && (d = this.connectionControllerClient) != null && d.connectExternal
          ? (await ((p = this.connectionControllerClient) == null
              ? void 0
              : p.connectExternal({
                  id: Ae.CONNECTOR_ID.AUTH,
                  info: { name: Ae.CONNECTOR_ID.AUTH },
                  type: In.CONNECTOR_TYPE_AUTH,
                  provider: e,
                  chainId: (h = ne.state.activeCaipNetwork) == null ? void 0 : h.id,
                  chain: n
                })),
            this.setStatus('connected', n))
          : Et.getConnectorId(n) === Ae.CONNECTOR_ID.AUTH &&
            (this.setStatus('disconnected', n), Ke.removeConnectedNamespace(n))),
      this.setLoading(!1, n)
  }
  async checkExistingTelegramSocialConnection(e) {
    var n
    try {
      if (!dt.isTelegram()) return
      const r = Ke.getTelegramSocialProvider()
      if (!r || typeof window > 'u' || typeof document > 'u') return
      const i = new URL(window.location.href).searchParams.get('result_uri')
      if (!i) return
      Ye.setSocialProvider(r, e), await ((n = this.authProvider) == null ? void 0 : n.init())
      const o = Et.getAuthConnector()
      r &&
        o &&
        (this.setLoading(!0, e),
        await o.provider.connectSocial(i),
        await pn.connectExternal(o, o.chain),
        Ke.setConnectedSocialProvider(r),
        Ke.removeTelegramSocialProvider(),
        gn.sendEvent({ type: 'track', event: 'SOCIAL_LOGIN_SUCCESS', properties: { provider: r } }))
    } catch (r) {
      this.setLoading(!1, e), console.error('checkExistingSTelegramocialConnection error', r)
    }
    try {
      const r = new URL(window.location.href)
      r.searchParams.delete('result_uri'),
        window.history.replaceState({}, document.title, r.toString())
    } catch (r) {
      console.error('tma social login failed', r)
    }
  }
  createAuthProvider(e) {
    var o, a, c, u, l, d, h, p, y, m, b, I, x
    if (!Ae.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(e)) return
    const r =
        ((a = (o = this.options) == null ? void 0 : o.features) == null ? void 0 : a.email) ===
        void 0
          ? gr.DEFAULT_FEATURES.email
          : (u = (c = this.options) == null ? void 0 : c.features) == null
            ? void 0
            : u.email,
      s =
        (d = (l = this.options) == null ? void 0 : l.features) != null && d.socials
          ? ((y =
              (p = (h = this.options) == null ? void 0 : h.features) == null
                ? void 0
                : p.socials) == null
              ? void 0
              : y.length) > 0
          : gr.DEFAULT_FEATURES.socials,
      i = r || s
    !this.authProvider &&
      (m = this.options) != null &&
      m.projectId &&
      i &&
      ((this.authProvider = tu.getInstance({
        projectId: this.options.projectId,
        enableLogger: this.options.enableAuthLogger,
        chainId: (b = this.getCaipNetwork(e)) == null ? void 0 : b.caipNetworkId,
        onTimeout: () => {
          qa.open(La.ALERT_ERRORS.SOCIALS_TIMEOUT, 'error')
        }
      })),
      no.subscribeOpen(_ => {
        var R
        !_ &&
          this.isTransactionStackEmpty() &&
          ((R = this.authProvider) == null || R.rejectRpcRequests())
      }),
      e === Ae.CHAIN.EVM &&
        (I = Ye.state.preferredAccountTypes) != null &&
        I.eip155 &&
        this.authProvider.setPreferredAccount(
          (x = Ye.state.preferredAccountTypes) == null ? void 0 : x.eip155
        ),
      this.syncAuthConnector(this.authProvider, e),
      this.checkExistingTelegramSocialConnection(e))
  }
  createAuthProviderForAdapter(e) {
    var n, r, s
    this.createAuthProvider(e),
      this.authProvider &&
        ((s =
          (r = (n = this.chainAdapters) == null ? void 0 : n[e]) == null
            ? void 0
            : r.setAuthProvider) == null ||
          s.call(r, this.authProvider))
  }
  initControllers(e) {
    super.initControllers(e),
      this.options.excludeWalletIds &&
        yt.initializeExcludedWallets({ ids: this.options.excludeWalletIds })
  }
  async switchCaipNetwork(e) {
    var i, o
    if (!e) return
    const n = ne.state.activeChain,
      r = e.chainNamespace,
      s = this.getAddressByChainNamespace(e.chainNamespace)
    if (e.chainNamespace === ne.state.activeChain && s) {
      const a = this.getAdapter(r),
        c = on.getProvider(r),
        u = on.getProviderId(r)
      await (a == null
        ? void 0
        : a.switchNetwork({ caipNetwork: e, provider: c, providerType: u })),
        this.setCaipNetwork(e)
    } else {
      const c = on.getProviderId(n) === In.CONNECTOR_TYPE_AUTH,
        u = on.getProviderId(r),
        l = u === In.CONNECTOR_TYPE_AUTH,
        d = Ae.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(r)
      if ((c || l) && d)
        try {
          ;(ne.state.activeChain = e.chainNamespace),
            await ((o =
              (i = this.connectionControllerClient) == null ? void 0 : i.connectExternal) == null
              ? void 0
              : o.call(i, {
                  id: Ae.CONNECTOR_ID.AUTH,
                  provider: this.authProvider,
                  chain: r,
                  chainId: e.id,
                  type: In.CONNECTOR_TYPE_AUTH,
                  caipNetwork: e
                })),
            this.setCaipNetwork(e)
        } catch {
          const p = this.getAdapter(r)
          await (p == null
            ? void 0
            : p.switchNetwork({ caipNetwork: e, provider: this.authProvider, providerType: u }))
        }
      else
        u === In.CONNECTOR_TYPE_WALLET_CONNECT
          ? (this.setCaipNetwork(e), this.syncWalletConnectAccount())
          : (this.setCaipNetwork(e),
            s && this.syncAccount({ address: s, chainId: e.id, chainNamespace: r }))
    }
  }
  async initChainAdapter(e) {
    await super.initChainAdapter(e), this.createAuthProviderForAdapter(e)
  }
  async syncIdentity({ address: e, chainId: n, chainNamespace: r }) {
    var o
    const s = `${r}:${n}`,
      i = (o = this.caipNetworks) == null ? void 0 : o.find(a => a.caipNetworkId === s)
    if (r !== Ae.CHAIN.EVM || (i != null && i.testnet)) {
      this.setProfileName(null, r), this.setProfileImage(null, r)
      return
    }
    try {
      const { name: a, avatar: c } = await this.fetchIdentity({ address: e, caipNetworkId: s })
      if ((this.setProfileName(a, r), this.setProfileImage(c, r), !a)) {
        const u = this.getAdapter(r),
          l = await (u == null ? void 0 : u.getProfile({ address: e, chainId: Number(n) }))
        l != null && l.profileName
          ? (this.setProfileName(l.profileName, r),
            l.profileImage && this.setProfileImage(l.profileImage, r))
          : (await this.syncReownName(e, r), this.setProfileImage(null, r))
      }
    } catch {
      await this.syncReownName(e, r), n !== 1 && this.setProfileImage(null, r)
    }
  }
  syncConnectedWalletInfo(e) {
    const n = on.getProviderId(e)
    if (n === In.CONNECTOR_TYPE_AUTH) {
      const r = this.authProvider
      if (r) {
        const s = Ke.getConnectedSocialProvider() ?? 'email',
          i = r.getEmail() ?? r.getUsername()
        this.setConnectedWalletInfo({ name: n, identifier: i, social: s }, e)
      }
    } else super.syncConnectedWalletInfo(e)
  }
  async injectModalUi() {
    if (!Nx && dt.isClient()) {
      const e = { ...gr.DEFAULT_FEATURES, ...this.options.features },
        n = []
      if (
        (e &&
          ((e.email || (e.socials && e.socials.length)) &&
            n.push(
              qr(
                () => import('./CbKxocG1.js'),
                __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]),
                import.meta.url
              )
            ),
          e.email &&
            n.push(
              qr(
                () => import('./BZU83xiY.js'),
                __vite__mapDeps([10, 1, 9, 5, 8, 4, 11, 6]),
                import.meta.url
              )
            ),
          e.socials &&
            n.push(
              qr(
                () => import('./DsZhg2eE.js'),
                __vite__mapDeps([12, 1, 13, 4, 5, 14, 8, 9, 15, 3, 16]),
                import.meta.url
              )
            ),
          e.swaps &&
            n.push(
              qr(
                () => import('./CgAXqmu2.js'),
                __vite__mapDeps([17, 1, 4, 5, 18, 19, 20, 3, 8, 16, 6]),
                import.meta.url
              )
            ),
          e.send &&
            n.push(
              qr(
                () => import('./Bj1RrTHK.js'),
                __vite__mapDeps([21, 1, 4, 5, 8, 9, 20, 3, 6, 22]),
                import.meta.url
              )
            ),
          e.receive &&
            n.push(
              qr(
                () => import('./CVyQrXOe.js'),
                __vite__mapDeps([23, 1, 24, 3, 15]),
                import.meta.url
              )
            ),
          e.onramp &&
            n.push(
              qr(
                () => import('./VeQhFUeZ.js'),
                __vite__mapDeps([25, 1, 26, 16, 8, 3, 5, 27, 13, 4, 9, 6]),
                import.meta.url
              )
            ),
          e.history &&
            n.push(
              qr(
                () => import('./D3U4eLiN.js'),
                __vite__mapDeps([28, 1, 29, 26, 16, 8, 9, 3]),
                import.meta.url
              )
            )),
        await Promise.all([
          ...n,
          qr(
            () => import('./DmqZ4eto.js'),
            __vite__mapDeps([
              30, 1, 3, 5, 22, 8, 31, 19, 7, 27, 4, 29, 26, 16, 9, 18, 6, 11, 13, 14, 2, 24, 15
            ]),
            import.meta.url
          ),
          qr(
            () => import('./BKj7FodF.js'),
            __vite__mapDeps([32, 1, 7, 3, 8, 5, 19, 31]),
            import.meta.url
          )
        ]),
        !document.querySelector('w3m-modal'))
      ) {
        const s = document.createElement('w3m-modal')
        !Pe.state.disableAppend &&
          !Pe.state.enableEmbedded &&
          document.body.insertAdjacentElement('beforeend', s)
      }
      Nx = !0
    }
  }
}
const Ece = '1.7.4'
var vb
function Ace(t) {
  return vb == null ? void 0 : vb.get(t)
}
var Eb
function _ce(t) {
  return Eb == null ? void 0 : Eb.get(t)
}
var Ab
function Cce(t, e) {
  var n
  return (n = Ab == null ? void 0 : Ab.get(t)) == null ? void 0 : n.get(e)
}
function J0(t) {
  var n, r
  const e = typeof t
  return e === 'string'
    ? `"${t}"`
    : e === 'number' || e === 'bigint' || e === 'boolean'
      ? `${t}`
      : e === 'object' || e === 'function'
        ? ((t &&
            ((r = (n = Object.getPrototypeOf(t)) == null ? void 0 : n.constructor) == null
              ? void 0
              : r.name)) ??
          'null')
        : e
}
function or(t, e, n, r, s) {
  const i = s && 'input' in s ? s.input : n.value,
    o = (s == null ? void 0 : s.expected) ?? t.expects ?? null,
    a = (s == null ? void 0 : s.received) ?? J0(i),
    c = {
      kind: t.kind,
      type: t.type,
      input: i,
      expected: o,
      received: a,
      message: `Invalid ${e}: ${o ? `Expected ${o} but r` : 'R'}eceived ${a}`,
      requirement: t.requirement,
      path: s == null ? void 0 : s.path,
      issues: s == null ? void 0 : s.issues,
      lang: r.lang,
      abortEarly: r.abortEarly,
      abortPipeEarly: r.abortPipeEarly
    },
    u = t.kind === 'schema',
    l =
      (s == null ? void 0 : s.message) ??
      t.message ??
      Cce(t.reference, c.lang) ??
      (u ? _ce(c.lang) : null) ??
      r.message ??
      Ace(c.lang)
  l && (c.message = typeof l == 'function' ? l(c) : l),
    u && (n.typed = !1),
    n.issues ? n.issues.push(c) : (n.issues = [c])
}
function U8(t, e) {
  return Object.hasOwn(t, e) && e !== '__proto__' && e !== 'prototype' && e !== 'constructor'
}
function X0(t, e) {
  const n = [...new Set(t)]
  return n.length > 1 ? `(${n.join(` ${e} `)})` : (n[0] ?? 'never')
}
function L8(t, e) {
  return {
    kind: 'validation',
    type: 'check',
    reference: L8,
    async: !1,
    expects: null,
    requirement: t,
    message: e,
    _run(n, r) {
      return n.typed && !this.requirement(n.value) && or(this, 'input', n, r), n
    }
  }
}
function $8(t, e) {
  return {
    kind: 'validation',
    type: 'max_length',
    reference: $8,
    async: !1,
    expects: `<=${t}`,
    requirement: t,
    message: e,
    _run(n, r) {
      return (
        n.typed &&
          n.value.length > this.requirement &&
          or(this, 'length', n, r, { received: `${n.value.length}` }),
        n
      )
    }
  }
}
function F8(t, e) {
  return {
    kind: 'validation',
    type: 'min_length',
    reference: F8,
    async: !1,
    expects: `>=${t}`,
    requirement: t,
    message: e,
    _run(n, r) {
      return (
        n.typed &&
          n.value.length < this.requirement &&
          or(this, 'length', n, r, { received: `${n.value.length}` }),
        n
      )
    }
  }
}
function j8(t, e, n) {
  return typeof t.default == 'function' ? t.default(e, n) : t.default
}
function jn(t, e) {
  return {
    kind: 'schema',
    type: 'array',
    reference: jn,
    expects: 'Array',
    async: !1,
    item: t,
    message: e,
    _run(n, r) {
      var i
      const s = n.value
      if (Array.isArray(s)) {
        ;(n.typed = !0), (n.value = [])
        for (let o = 0; o < s.length; o++) {
          const a = s[o],
            c = this.item._run({ typed: !1, value: a }, r)
          if (c.issues) {
            const u = { type: 'array', origin: 'value', input: s, key: o, value: a }
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : (l.path = [u]), (i = n.issues) == null || i.push(l)
            if ((n.issues || (n.issues = c.issues), r.abortEarly)) {
              n.typed = !1
              break
            }
          }
          c.typed || (n.typed = !1), n.value.push(c.value)
        }
      } else or(this, 'type', n, r)
      return n
    }
  }
}
function Ru(t) {
  return {
    kind: 'schema',
    type: 'boolean',
    reference: Ru,
    expects: 'boolean',
    async: !1,
    message: t,
    _run(e, n) {
      return typeof e.value == 'boolean' ? (e.typed = !0) : or(this, 'type', e, n), e
    }
  }
}
function Ks(t, e) {
  const n = Object.entries(t)
    .filter(([r]) => isNaN(+r))
    .map(([, r]) => r)
  return {
    kind: 'schema',
    type: 'enum',
    reference: Ks,
    expects: X0(n.map(J0), '|'),
    async: !1,
    enum: t,
    options: n,
    message: e,
    _run(r, s) {
      return this.options.includes(r.value) ? (r.typed = !0) : or(this, 'type', r, s), r
    }
  }
}
function At(t, e) {
  return {
    kind: 'schema',
    type: 'literal',
    reference: At,
    expects: J0(t),
    async: !1,
    literal: t,
    message: e,
    _run(n, r) {
      return n.value === this.literal ? (n.typed = !0) : or(this, 'type', n, r), n
    }
  }
}
function H8(t, e) {
  return {
    kind: 'schema',
    type: 'loose_object',
    reference: H8,
    expects: 'Object',
    async: !1,
    entries: t,
    message: e,
    _run(n, r) {
      var i
      const s = n.value
      if (s && typeof s == 'object') {
        ;(n.typed = !0), (n.value = {})
        for (const o in this.entries) {
          const a = s[o],
            c = this.entries[o]._run({ typed: !1, value: a }, r)
          if (c.issues) {
            const u = { type: 'object', origin: 'value', input: s, key: o, value: a }
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : (l.path = [u]), (i = n.issues) == null || i.push(l)
            if ((n.issues || (n.issues = c.issues), r.abortEarly)) {
              n.typed = !1
              break
            }
          }
          c.typed || (n.typed = !1), (c.value !== void 0 || o in s) && (n.value[o] = c.value)
        }
        if (!n.issues || !r.abortEarly)
          for (const o in s) U8(s, o) && !(o in this.entries) && (n.value[o] = s[o])
      } else or(this, 'type', n, r)
      return n
    }
  }
}
function qA(t, e) {
  return {
    kind: 'schema',
    type: 'non_optional',
    reference: qA,
    expects: '!undefined',
    async: !1,
    wrapped: t,
    message: e,
    _run(n, r) {
      return n.value === void 0 ? (or(this, 'type', n, r), n) : this.wrapped._run(n, r)
    }
  }
}
function Xr(t) {
  return {
    kind: 'schema',
    type: 'null',
    reference: Xr,
    expects: 'null',
    async: !1,
    message: t,
    _run(e, n) {
      return e.value === null ? (e.typed = !0) : or(this, 'type', e, n), e
    }
  }
}
function vr(t, ...e) {
  const n = {
    kind: 'schema',
    type: 'nullish',
    reference: vr,
    expects: `(${t.expects} | null | undefined)`,
    async: !1,
    wrapped: t,
    _run(r, s) {
      return (r.value === null || r.value === void 0) &&
        ('default' in this && (r.value = j8(this, r, s)), r.value === null || r.value === void 0)
        ? ((r.typed = !0), r)
        : this.wrapped._run(r, s)
    }
  }
  return 0 in e && (n.default = e[0]), n
}
function Xn(t) {
  return {
    kind: 'schema',
    type: 'number',
    reference: Xn,
    expects: 'number',
    async: !1,
    message: t,
    _run(e, n) {
      return (
        typeof e.value == 'number' && !isNaN(e.value) ? (e.typed = !0) : or(this, 'type', e, n), e
      )
    }
  }
}
function ye(t, e) {
  return {
    kind: 'schema',
    type: 'object',
    reference: ye,
    expects: 'Object',
    async: !1,
    entries: t,
    message: e,
    _run(n, r) {
      var i
      const s = n.value
      if (s && typeof s == 'object') {
        ;(n.typed = !0), (n.value = {})
        for (const o in this.entries) {
          const a = s[o],
            c = this.entries[o]._run({ typed: !1, value: a }, r)
          if (c.issues) {
            const u = { type: 'object', origin: 'value', input: s, key: o, value: a }
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : (l.path = [u]), (i = n.issues) == null || i.push(l)
            if ((n.issues || (n.issues = c.issues), r.abortEarly)) {
              n.typed = !1
              break
            }
          }
          c.typed || (n.typed = !1), (c.value !== void 0 || o in s) && (n.value[o] = c.value)
        }
      } else or(this, 'type', n, r)
      return n
    }
  }
}
function mt(t, ...e) {
  const n = {
    kind: 'schema',
    type: 'optional',
    reference: mt,
    expects: `(${t.expects} | undefined)`,
    async: !1,
    wrapped: t,
    _run(r, s) {
      return r.value === void 0 &&
        ('default' in this && (r.value = j8(this, r, s)), r.value === void 0)
        ? ((r.typed = !0), r)
        : this.wrapped._run(r, s)
    }
  }
  return 0 in e && (n.default = e[0]), n
}
function q8(t, e) {
  return {
    kind: 'schema',
    type: 'picklist',
    reference: q8,
    expects: X0(t.map(J0), '|'),
    async: !1,
    options: t,
    message: e,
    _run(n, r) {
      return this.options.includes(n.value) ? (n.typed = !0) : or(this, 'type', n, r), n
    }
  }
}
function z8(t, e, n) {
  return {
    kind: 'schema',
    type: 'record',
    reference: z8,
    expects: 'Object',
    async: !1,
    key: t,
    value: e,
    message: n,
    _run(r, s) {
      var o, a
      const i = r.value
      if (i && typeof i == 'object') {
        ;(r.typed = !0), (r.value = {})
        for (const c in i)
          if (U8(i, c)) {
            const u = i[c],
              l = this.key._run({ typed: !1, value: c }, s)
            if (l.issues) {
              const h = { type: 'object', origin: 'key', input: i, key: c, value: u }
              for (const p of l.issues) (p.path = [h]), (o = r.issues) == null || o.push(p)
              if ((r.issues || (r.issues = l.issues), s.abortEarly)) {
                r.typed = !1
                break
              }
            }
            const d = this.value._run({ typed: !1, value: u }, s)
            if (d.issues) {
              const h = { type: 'object', origin: 'value', input: i, key: c, value: u }
              for (const p of d.issues)
                p.path ? p.path.unshift(h) : (p.path = [h]), (a = r.issues) == null || a.push(p)
              if ((r.issues || (r.issues = d.issues), s.abortEarly)) {
                r.typed = !1
                break
              }
            }
            ;(!l.typed || !d.typed) && (r.typed = !1), l.typed && (r.value[l.value] = d.value)
          }
      } else or(this, 'type', r, s)
      return r
    }
  }
}
function me(t) {
  return {
    kind: 'schema',
    type: 'string',
    reference: me,
    expects: 'string',
    async: !1,
    message: t,
    _run(e, n) {
      return typeof e.value == 'string' ? (e.typed = !0) : or(this, 'type', e, n), e
    }
  }
}
function Px(t) {
  let e
  if (t) for (const n of t) e ? e.push(...n.issues) : (e = n.issues)
  return e
}
function ku(t, e) {
  return {
    kind: 'schema',
    type: 'union',
    reference: ku,
    expects: X0(
      t.map(n => n.expects),
      '|'
    ),
    async: !1,
    options: t,
    message: e,
    _run(n, r) {
      let s, i, o
      for (const a of this.options) {
        const c = a._run({ typed: !1, value: n.value }, r)
        if (c.typed)
          if (c.issues) i ? i.push(c) : (i = [c])
          else {
            s = c
            break
          }
        else o ? o.push(c) : (o = [c])
      }
      if (s) return s
      if (i) {
        if (i.length === 1) return i[0]
        or(this, 'type', n, r, { issues: Px(i) }), (n.typed = !0)
      } else {
        if ((o == null ? void 0 : o.length) === 1) return o[0]
        or(this, 'type', n, r, { issues: Px(o) })
      }
      return n
    }
  }
}
function ey() {
  return {
    kind: 'schema',
    type: 'unknown',
    reference: ey,
    expects: 'unknown',
    async: !1,
    _run(t) {
      return (t.typed = !0), t
    }
  }
}
function W8(t, e, n) {
  return {
    kind: 'schema',
    type: 'variant',
    reference: W8,
    expects: 'Object',
    async: !1,
    key: t,
    options: e,
    message: n,
    _run(r, s) {
      const i = r.value
      if (i && typeof i == 'object') {
        let o,
          a = 0,
          c = this.key,
          u = []
        const l = (d, h) => {
          for (const p of d.options) {
            if (p.type === 'variant') l(p, new Set(h).add(p.key))
            else {
              let y = !0,
                m = 0
              for (const b of h) {
                if (p.entries[b]._run({ typed: !1, value: i[b] }, s).issues) {
                  ;(y = !1),
                    c !== b &&
                      (a < m || (a === m && b in i && !(c in i))) &&
                      ((a = m), (c = b), (u = [])),
                    c === b && u.push(p.entries[b].expects)
                  break
                }
                m++
              }
              if (y) {
                const b = p._run({ typed: !1, value: i }, s)
                ;(!o || (!o.typed && b.typed)) && (o = b)
              }
            }
            if (o && !o.issues) break
          }
        }
        if ((l(this, new Set([this.key])), o)) return o
        or(this, 'type', r, s, {
          input: i[c],
          expected: X0(u, '|'),
          path: [{ type: 'object', origin: 'value', input: i, key: c, value: i[c] }]
        })
      } else or(this, 'type', r, s)
      return r
    }
  }
}
function Rx(t, e) {
  const n = { ...t.entries }
  for (const r of e) delete n[r]
  return { ...t, entries: n }
}
function Lv(...t) {
  return {
    ...t[0],
    pipe: t,
    _run(e, n) {
      for (const r of t)
        if (r.kind !== 'metadata') {
          if (e.issues && (r.kind === 'schema' || r.kind === 'transformation')) {
            e.typed = !1
            break
          }
          ;(!e.issues || (!n.abortEarly && !n.abortPipeEarly)) && (e = r._run(e, n))
        }
      return e
    }
  }
}
function Sce(t) {
  return t.wrapped
}
var Ec = {},
  Po = {},
  Ps = {},
  kx
function ty() {
  if (kx) return Ps
  ;(kx = 1),
    Object.defineProperty(Ps, '__esModule', { value: !0 }),
    (Ps.decode = Ps.encode = Ps.unescape = Ps.escape = Ps.pad = void 0)
  const t = P0()
  function e(o) {
    return `${o}${'='.repeat(4 - (o.length % 4 || 4))}`
  }
  Ps.pad = e
  function n(o) {
    return o.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_')
  }
  Ps.escape = n
  function r(o) {
    return e(o).replace(/-/g, '+').replace(/_/g, '/')
  }
  Ps.unescape = r
  function s(o) {
    return n((0, t.fromByteArray)(new TextEncoder().encode(o)))
  }
  Ps.encode = s
  function i(o) {
    return new TextDecoder().decode((0, t.toByteArray)(e(r(o))))
  }
  return (Ps.decode = i), Ps
}
var _b = {},
  oh = {},
  Cb = {},
  ha = {},
  Ox
function zA() {
  if (Ox) return ha
  ;(Ox = 1),
    Object.defineProperty(ha, '__esModule', { value: !0 }),
    (ha.anumber = t),
    (ha.abytes = n),
    (ha.ahash = r),
    (ha.aexists = s),
    (ha.aoutput = i)
  function t(o) {
    if (!Number.isSafeInteger(o) || o < 0) throw new Error('positive integer expected, got ' + o)
  }
  function e(o) {
    return o instanceof Uint8Array || (ArrayBuffer.isView(o) && o.constructor.name === 'Uint8Array')
  }
  function n(o, ...a) {
    if (!e(o)) throw new Error('Uint8Array expected')
    if (a.length > 0 && !a.includes(o.length))
      throw new Error('Uint8Array expected of length ' + a + ', got length=' + o.length)
  }
  function r(o) {
    if (typeof o != 'function' || typeof o.create != 'function')
      throw new Error('Hash should be wrapped by utils.wrapConstructor')
    t(o.outputLen), t(o.blockLen)
  }
  function s(o, a = !0) {
    if (o.destroyed) throw new Error('Hash instance has been destroyed')
    if (a && o.finished) throw new Error('Hash#digest() has already been called')
  }
  function i(o, a) {
    n(o)
    const c = a.outputLen
    if (o.length < c) throw new Error('digestInto() expects output buffer of length at least ' + c)
  }
  return ha
}
var Sb = {},
  ah = {},
  Bx
function Ice() {
  return (
    Bx ||
      ((Bx = 1),
      Object.defineProperty(ah, '__esModule', { value: !0 }),
      (ah.crypto = void 0),
      (ah.crypto =
        typeof globalThis == 'object' && 'crypto' in globalThis ? globalThis.crypto : void 0)),
    ah
  )
}
var Dx
function ny() {
  return (
    Dx ||
      ((Dx = 1),
      (function (t) {
        /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(
          t,
          '__esModule',
          { value: !0 }
        ),
          (t.Hash = t.nextTick = t.byteSwapIfBE = t.isLE = void 0),
          (t.isBytes = r),
          (t.u8 = s),
          (t.u32 = i),
          (t.createView = o),
          (t.rotr = a),
          (t.rotl = c),
          (t.byteSwap = u),
          (t.byteSwap32 = l),
          (t.bytesToHex = h),
          (t.hexToBytes = m),
          (t.asyncLoop = I),
          (t.utf8ToBytes = x),
          (t.toBytes = _),
          (t.concatBytes = R),
          (t.checkOpts = T),
          (t.wrapConstructor = M),
          (t.wrapConstructorWithOpts = H),
          (t.wrapXOFConstructorWithOpts = B),
          (t.randomBytes = $)
        const e = Ice(),
          n = zA()
        function r(D) {
          return (
            D instanceof Uint8Array ||
            (ArrayBuffer.isView(D) && D.constructor.name === 'Uint8Array')
          )
        }
        function s(D) {
          return new Uint8Array(D.buffer, D.byteOffset, D.byteLength)
        }
        function i(D) {
          return new Uint32Array(D.buffer, D.byteOffset, Math.floor(D.byteLength / 4))
        }
        function o(D) {
          return new DataView(D.buffer, D.byteOffset, D.byteLength)
        }
        function a(D, W) {
          return (D << (32 - W)) | (D >>> W)
        }
        function c(D, W) {
          return (D << W) | ((D >>> (32 - W)) >>> 0)
        }
        t.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68
        function u(D) {
          return (
            ((D << 24) & 4278190080) |
            ((D << 8) & 16711680) |
            ((D >>> 8) & 65280) |
            ((D >>> 24) & 255)
          )
        }
        t.byteSwapIfBE = t.isLE ? D => D : D => u(D)
        function l(D) {
          for (let W = 0; W < D.length; W++) D[W] = u(D[W])
        }
        const d = Array.from({ length: 256 }, (D, W) => W.toString(16).padStart(2, '0'))
        function h(D) {
          ;(0, n.abytes)(D)
          let W = ''
          for (let U = 0; U < D.length; U++) W += d[D[U]]
          return W
        }
        const p = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }
        function y(D) {
          if (D >= p._0 && D <= p._9) return D - p._0
          if (D >= p.A && D <= p.F) return D - (p.A - 10)
          if (D >= p.a && D <= p.f) return D - (p.a - 10)
        }
        function m(D) {
          if (typeof D != 'string') throw new Error('hex string expected, got ' + typeof D)
          const W = D.length,
            U = W / 2
          if (W % 2) throw new Error('hex string expected, got unpadded hex of length ' + W)
          const w = new Uint8Array(U)
          for (let v = 0, A = 0; v < U; v++, A += 2) {
            const P = y(D.charCodeAt(A)),
              O = y(D.charCodeAt(A + 1))
            if (P === void 0 || O === void 0) {
              const F = D[A] + D[A + 1]
              throw new Error(
                'hex string expected, got non-hex character "' + F + '" at index ' + A
              )
            }
            w[v] = P * 16 + O
          }
          return w
        }
        const b = async () => {}
        t.nextTick = b
        async function I(D, W, U) {
          let w = Date.now()
          for (let v = 0; v < D; v++) {
            U(v)
            const A = Date.now() - w
            ;(A >= 0 && A < W) || (await (0, t.nextTick)(), (w += A))
          }
        }
        function x(D) {
          if (typeof D != 'string') throw new Error('utf8ToBytes expected string, got ' + typeof D)
          return new Uint8Array(new TextEncoder().encode(D))
        }
        function _(D) {
          return typeof D == 'string' && (D = x(D)), (0, n.abytes)(D), D
        }
        function R(...D) {
          let W = 0
          for (let w = 0; w < D.length; w++) {
            const v = D[w]
            ;(0, n.abytes)(v), (W += v.length)
          }
          const U = new Uint8Array(W)
          for (let w = 0, v = 0; w < D.length; w++) {
            const A = D[w]
            U.set(A, v), (v += A.length)
          }
          return U
        }
        class N {
          clone() {
            return this._cloneInto()
          }
        }
        t.Hash = N
        function T(D, W) {
          if (W !== void 0 && {}.toString.call(W) !== '[object Object]')
            throw new Error('Options should be object or undefined')
          return Object.assign(D, W)
        }
        function M(D) {
          const W = w => D().update(_(w)).digest(),
            U = D()
          return (W.outputLen = U.outputLen), (W.blockLen = U.blockLen), (W.create = () => D()), W
        }
        function H(D) {
          const W = (w, v) => D(v).update(_(w)).digest(),
            U = D({})
          return (W.outputLen = U.outputLen), (W.blockLen = U.blockLen), (W.create = w => D(w)), W
        }
        function B(D) {
          const W = (w, v) => D(v).update(_(w)).digest(),
            U = D({})
          return (W.outputLen = U.outputLen), (W.blockLen = U.blockLen), (W.create = w => D(w)), W
        }
        function $(D = 32) {
          if (e.crypto && typeof e.crypto.getRandomValues == 'function')
            return e.crypto.getRandomValues(new Uint8Array(D))
          if (e.crypto && typeof e.crypto.randomBytes == 'function') return e.crypto.randomBytes(D)
          throw new Error('crypto.getRandomValues must be defined')
        }
      })(Sb)),
    Sb
  )
}
var Mx
function xce() {
  return (
    Mx ||
      ((Mx = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 }), (t.hmac = t.HMAC = void 0)
        const e = zA(),
          n = ny()
        class r extends n.Hash {
          constructor(o, a) {
            super(), (this.finished = !1), (this.destroyed = !1), (0, e.ahash)(o)
            const c = (0, n.toBytes)(a)
            if (((this.iHash = o.create()), typeof this.iHash.update != 'function'))
              throw new Error('Expected instance of class which extends utils.Hash')
            ;(this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen)
            const u = this.blockLen,
              l = new Uint8Array(u)
            l.set(c.length > u ? o.create().update(c).digest() : c)
            for (let d = 0; d < l.length; d++) l[d] ^= 54
            this.iHash.update(l), (this.oHash = o.create())
            for (let d = 0; d < l.length; d++) l[d] ^= 106
            this.oHash.update(l), l.fill(0)
          }
          update(o) {
            return (0, e.aexists)(this), this.iHash.update(o), this
          }
          digestInto(o) {
            ;(0, e.aexists)(this),
              (0, e.abytes)(o, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(o),
              this.oHash.update(o),
              this.oHash.digestInto(o),
              this.destroy()
          }
          digest() {
            const o = new Uint8Array(this.oHash.outputLen)
            return this.digestInto(o), o
          }
          _cloneInto(o) {
            o || (o = Object.create(Object.getPrototypeOf(this), {}))
            const {
              oHash: a,
              iHash: c,
              finished: u,
              destroyed: l,
              blockLen: d,
              outputLen: h
            } = this
            return (
              (o = o),
              (o.finished = u),
              (o.destroyed = l),
              (o.blockLen = d),
              (o.outputLen = h),
              (o.oHash = a._cloneInto(o.oHash)),
              (o.iHash = c._cloneInto(o.iHash)),
              o
            )
          }
          destroy() {
            ;(this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy()
          }
        }
        t.HMAC = r
        const s = (i, o, a) => new r(i, o).update(a).digest()
        ;(t.hmac = s), (t.hmac.create = (i, o) => new r(i, o))
      })(Cb)),
    Cb
  )
}
var Ro = {},
  fa = {},
  Ux
function Tce() {
  if (Ux) return fa
  ;(Ux = 1),
    Object.defineProperty(fa, '__esModule', { value: !0 }),
    (fa.HashMD = void 0),
    (fa.setBigUint64 = n),
    (fa.Chi = r),
    (fa.Maj = s)
  const t = zA(),
    e = ny()
  function n(o, a, c, u) {
    if (typeof o.setBigUint64 == 'function') return o.setBigUint64(a, c, u)
    const l = BigInt(32),
      d = BigInt(4294967295),
      h = Number((c >> l) & d),
      p = Number(c & d),
      y = u ? 4 : 0,
      m = u ? 0 : 4
    o.setUint32(a + y, h, u), o.setUint32(a + m, p, u)
  }
  function r(o, a, c) {
    return (o & a) ^ (~o & c)
  }
  function s(o, a, c) {
    return (o & a) ^ (o & c) ^ (a & c)
  }
  class i extends e.Hash {
    constructor(a, c, u, l) {
      super(),
        (this.blockLen = a),
        (this.outputLen = c),
        (this.padOffset = u),
        (this.isLE = l),
        (this.finished = !1),
        (this.length = 0),
        (this.pos = 0),
        (this.destroyed = !1),
        (this.buffer = new Uint8Array(a)),
        (this.view = (0, e.createView)(this.buffer))
    }
    update(a) {
      ;(0, t.aexists)(this)
      const { view: c, buffer: u, blockLen: l } = this
      a = (0, e.toBytes)(a)
      const d = a.length
      for (let h = 0; h < d; ) {
        const p = Math.min(l - this.pos, d - h)
        if (p === l) {
          const y = (0, e.createView)(a)
          for (; l <= d - h; h += l) this.process(y, h)
          continue
        }
        u.set(a.subarray(h, h + p), this.pos),
          (this.pos += p),
          (h += p),
          this.pos === l && (this.process(c, 0), (this.pos = 0))
      }
      return (this.length += a.length), this.roundClean(), this
    }
    digestInto(a) {
      ;(0, t.aexists)(this), (0, t.aoutput)(a, this), (this.finished = !0)
      const { buffer: c, view: u, blockLen: l, isLE: d } = this
      let { pos: h } = this
      ;(c[h++] = 128),
        this.buffer.subarray(h).fill(0),
        this.padOffset > l - h && (this.process(u, 0), (h = 0))
      for (let I = h; I < l; I++) c[I] = 0
      n(u, l - 8, BigInt(this.length * 8), d), this.process(u, 0)
      const p = (0, e.createView)(a),
        y = this.outputLen
      if (y % 4) throw new Error('_sha2: outputLen should be aligned to 32bit')
      const m = y / 4,
        b = this.get()
      if (m > b.length) throw new Error('_sha2: outputLen bigger than state')
      for (let I = 0; I < m; I++) p.setUint32(4 * I, b[I], d)
    }
    digest() {
      const { buffer: a, outputLen: c } = this
      this.digestInto(a)
      const u = a.slice(0, c)
      return this.destroy(), u
    }
    _cloneInto(a) {
      a || (a = new this.constructor()), a.set(...this.get())
      const { blockLen: c, buffer: u, length: l, finished: d, destroyed: h, pos: p } = this
      return (
        (a.length = l),
        (a.pos = p),
        (a.finished = d),
        (a.destroyed = h),
        l % c && a.buffer.set(u),
        a
      )
    }
  }
  return (fa.HashMD = i), fa
}
var Lx
function K8() {
  if (Lx) return Ro
  ;(Lx = 1),
    Object.defineProperty(Ro, '__esModule', { value: !0 }),
    (Ro.sha224 = Ro.sha256 = Ro.SHA256 = void 0)
  const t = Tce(),
    e = ny(),
    n = new Uint32Array([
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
      3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
      3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
      666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
      2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
      1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298
    ]),
    r = new Uint32Array([
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225
    ]),
    s = new Uint32Array(64)
  class i extends t.HashMD {
    constructor() {
      super(64, 32, 8, !1),
        (this.A = r[0] | 0),
        (this.B = r[1] | 0),
        (this.C = r[2] | 0),
        (this.D = r[3] | 0),
        (this.E = r[4] | 0),
        (this.F = r[5] | 0),
        (this.G = r[6] | 0),
        (this.H = r[7] | 0)
    }
    get() {
      const { A: c, B: u, C: l, D: d, E: h, F: p, G: y, H: m } = this
      return [c, u, l, d, h, p, y, m]
    }
    set(c, u, l, d, h, p, y, m) {
      ;(this.A = c | 0),
        (this.B = u | 0),
        (this.C = l | 0),
        (this.D = d | 0),
        (this.E = h | 0),
        (this.F = p | 0),
        (this.G = y | 0),
        (this.H = m | 0)
    }
    process(c, u) {
      for (let x = 0; x < 16; x++, u += 4) s[x] = c.getUint32(u, !1)
      for (let x = 16; x < 64; x++) {
        const _ = s[x - 15],
          R = s[x - 2],
          N = (0, e.rotr)(_, 7) ^ (0, e.rotr)(_, 18) ^ (_ >>> 3),
          T = (0, e.rotr)(R, 17) ^ (0, e.rotr)(R, 19) ^ (R >>> 10)
        s[x] = (T + s[x - 7] + N + s[x - 16]) | 0
      }
      let { A: l, B: d, C: h, D: p, E: y, F: m, G: b, H: I } = this
      for (let x = 0; x < 64; x++) {
        const _ = (0, e.rotr)(y, 6) ^ (0, e.rotr)(y, 11) ^ (0, e.rotr)(y, 25),
          R = (I + _ + (0, t.Chi)(y, m, b) + n[x] + s[x]) | 0,
          T =
            (((0, e.rotr)(l, 2) ^ (0, e.rotr)(l, 13) ^ (0, e.rotr)(l, 22)) + (0, t.Maj)(l, d, h)) |
            0
        ;(I = b), (b = m), (m = y), (y = (p + R) | 0), (p = h), (h = d), (d = l), (l = (R + T) | 0)
      }
      ;(l = (l + this.A) | 0),
        (d = (d + this.B) | 0),
        (h = (h + this.C) | 0),
        (p = (p + this.D) | 0),
        (y = (y + this.E) | 0),
        (m = (m + this.F) | 0),
        (b = (b + this.G) | 0),
        (I = (I + this.H) | 0),
        this.set(l, d, h, p, y, m, b, I)
    }
    roundClean() {
      s.fill(0)
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
    }
  }
  Ro.SHA256 = i
  class o extends i {
    constructor() {
      super(),
        (this.A = -1056596264),
        (this.B = 914150663),
        (this.C = 812702999),
        (this.D = -150054599),
        (this.E = -4191439),
        (this.F = 1750603025),
        (this.G = 1694076839),
        (this.H = -1090891868),
        (this.outputLen = 28)
    }
  }
  return (
    (Ro.sha256 = (0, e.wrapConstructor)(() => new i())),
    (Ro.sha224 = (0, e.wrapConstructor)(() => new o())),
    Ro
  )
}
var Ib = {}
const Nce = {},
  Pce = Object.freeze(
    Object.defineProperty({ __proto__: null, default: Nce }, Symbol.toStringTag, {
      value: 'Module'
    })
  ),
  WA = N0(Pce)
var $x
function Rce() {
  return (
    $x ||
      (($x = 1),
      (function (t) {
        /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ Object.defineProperty(
          t,
          '__esModule',
          { value: !0 }
        ),
          (t.utils =
            t.schnorr =
            t.verify =
            t.signSync =
            t.sign =
            t.getSharedSecret =
            t.recoverPublicKey =
            t.getPublicKey =
            t.Signature =
            t.Point =
            t.CURVE =
              void 0)
        const e = WA,
          n = BigInt(0),
          r = BigInt(1),
          s = BigInt(2),
          i = BigInt(3),
          o = BigInt(8),
          a = Object.freeze({
            a: n,
            b: BigInt(7),
            P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
            n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
            h: r,
            Gx: BigInt(
              '55066263022277343669578718895168534326250603453777594175500187360389116729240'
            ),
            Gy: BigInt(
              '32670510020758816978083085130507043184471273380659243275938904335757337482424'
            ),
            beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')
          })
        t.CURVE = a
        const c = (te, Q) => (te + Q / s) / Q,
          u = {
            beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
            splitScalar(te) {
              const { n: Q } = a,
                J = BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
                se = -r * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'),
                le = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),
                pe = J,
                xe = BigInt('0x100000000000000000000000000000000'),
                je = c(pe * te, Q),
                Qe = c(-se * te, Q)
              let qe = C(te - je * J - Qe * le, Q),
                vt = C(-je * se - Qe * pe, Q)
              const at = qe > xe,
                ct = vt > xe
              if ((at && (qe = Q - qe), ct && (vt = Q - vt), qe > xe || vt > xe))
                throw new Error('splitScalarEndo: Endomorphism failed, k=' + te)
              return { k1neg: at, k1: qe, k2neg: ct, k2: vt }
            }
          },
          l = 32,
          d = 32,
          h = 32,
          p = l + 1,
          y = 2 * l + 1
        function m(te) {
          const { a: Q, b: J } = a,
            se = C(te * te),
            le = C(se * te)
          return C(le + Q * te + J)
        }
        const b = a.a === n
        class I extends Error {
          constructor(Q) {
            super(Q)
          }
        }
        function x(te) {
          if (!(te instanceof _)) throw new TypeError('JacobianPoint expected')
        }
        class _ {
          constructor(Q, J, se) {
            ;(this.x = Q), (this.y = J), (this.z = se)
          }
          static fromAffine(Q) {
            if (!(Q instanceof T)) throw new TypeError('JacobianPoint#fromAffine: expected Point')
            return Q.equals(T.ZERO) ? _.ZERO : new _(Q.x, Q.y, r)
          }
          static toAffineBatch(Q) {
            const J = oe(Q.map(se => se.z))
            return Q.map((se, le) => se.toAffine(J[le]))
          }
          static normalizeZ(Q) {
            return _.toAffineBatch(Q).map(_.fromAffine)
          }
          equals(Q) {
            x(Q)
            const { x: J, y: se, z: le } = this,
              { x: pe, y: xe, z: je } = Q,
              Qe = C(le * le),
              qe = C(je * je),
              vt = C(J * qe),
              at = C(pe * Qe),
              ct = C(C(se * je) * qe),
              Un = C(C(xe * le) * Qe)
            return vt === at && ct === Un
          }
          negate() {
            return new _(this.x, C(-this.y), this.z)
          }
          double() {
            const { x: Q, y: J, z: se } = this,
              le = C(Q * Q),
              pe = C(J * J),
              xe = C(pe * pe),
              je = Q + pe,
              Qe = C(s * (C(je * je) - le - xe)),
              qe = C(i * le),
              vt = C(qe * qe),
              at = C(vt - s * Qe),
              ct = C(qe * (Qe - at) - o * xe),
              Un = C(s * J * se)
            return new _(at, ct, Un)
          }
          add(Q) {
            x(Q)
            const { x: J, y: se, z: le } = this,
              { x: pe, y: xe, z: je } = Q
            if (pe === n || xe === n) return this
            if (J === n || se === n) return Q
            const Qe = C(le * le),
              qe = C(je * je),
              vt = C(J * qe),
              at = C(pe * Qe),
              ct = C(C(se * je) * qe),
              Un = C(C(xe * le) * Qe),
              xt = C(at - vt),
              zt = C(Un - ct)
            if (xt === n) return zt === n ? this.double() : _.ZERO
            const yo = C(xt * xt),
              un = C(xt * yo),
              ln = C(vt * yo),
              sa = C(zt * zt - un - s * ln),
              hc = C(zt * (ln - sa) - ct * un),
              wo = C(le * je * xt)
            return new _(sa, hc, wo)
          }
          subtract(Q) {
            return this.add(Q.negate())
          }
          multiplyUnsafe(Q) {
            const J = _.ZERO
            if (typeof Q == 'bigint' && Q === n) return J
            let se = E(Q)
            if (se === r) return this
            if (!b) {
              let at = J,
                ct = this
              for (; se > n; ) se & r && (at = at.add(ct)), (ct = ct.double()), (se >>= r)
              return at
            }
            let { k1neg: le, k1: pe, k2neg: xe, k2: je } = u.splitScalar(se),
              Qe = J,
              qe = J,
              vt = this
            for (; pe > n || je > n; )
              pe & r && (Qe = Qe.add(vt)),
                je & r && (qe = qe.add(vt)),
                (vt = vt.double()),
                (pe >>= r),
                (je >>= r)
            return (
              le && (Qe = Qe.negate()),
              xe && (qe = qe.negate()),
              (qe = new _(C(qe.x * u.beta), qe.y, qe.z)),
              Qe.add(qe)
            )
          }
          precomputeWindow(Q) {
            const J = b ? 128 / Q + 1 : 256 / Q + 1,
              se = []
            let le = this,
              pe = le
            for (let xe = 0; xe < J; xe++) {
              ;(pe = le), se.push(pe)
              for (let je = 1; je < 2 ** (Q - 1); je++) (pe = pe.add(le)), se.push(pe)
              le = pe.double()
            }
            return se
          }
          wNAF(Q, J) {
            !J && this.equals(_.BASE) && (J = T.BASE)
            const se = (J && J._WINDOW_SIZE) || 1
            if (256 % se)
              throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2')
            let le = J && N.get(J)
            le ||
              ((le = this.precomputeWindow(se)),
              J && se !== 1 && ((le = _.normalizeZ(le)), N.set(J, le)))
            let pe = _.ZERO,
              xe = _.BASE
            const je = 1 + (b ? 128 / se : 256 / se),
              Qe = 2 ** (se - 1),
              qe = BigInt(2 ** se - 1),
              vt = 2 ** se,
              at = BigInt(se)
            for (let ct = 0; ct < je; ct++) {
              const Un = ct * Qe
              let xt = Number(Q & qe)
              ;(Q >>= at), xt > Qe && ((xt -= vt), (Q += r))
              const zt = Un,
                yo = Un + Math.abs(xt) - 1,
                un = ct % 2 !== 0,
                ln = xt < 0
              xt === 0 ? (xe = xe.add(R(un, le[zt]))) : (pe = pe.add(R(ln, le[yo])))
            }
            return { p: pe, f: xe }
          }
          multiply(Q, J) {
            let se = E(Q),
              le,
              pe
            if (b) {
              const { k1neg: xe, k1: je, k2neg: Qe, k2: qe } = u.splitScalar(se)
              let { p: vt, f: at } = this.wNAF(je, J),
                { p: ct, f: Un } = this.wNAF(qe, J)
              ;(vt = R(xe, vt)),
                (ct = R(Qe, ct)),
                (ct = new _(C(ct.x * u.beta), ct.y, ct.z)),
                (le = vt.add(ct)),
                (pe = at.add(Un))
            } else {
              const { p: xe, f: je } = this.wNAF(se, J)
              ;(le = xe), (pe = je)
            }
            return _.normalizeZ([le, pe])[0]
          }
          toAffine(Q) {
            const { x: J, y: se, z: le } = this,
              pe = this.equals(_.ZERO)
            Q == null && (Q = pe ? o : ee(le))
            const xe = Q,
              je = C(xe * xe),
              Qe = C(je * xe),
              qe = C(J * je),
              vt = C(se * Qe),
              at = C(le * xe)
            if (pe) return T.ZERO
            if (at !== r) throw new Error('invZ was invalid')
            return new T(qe, vt)
          }
        }
        ;(_.BASE = new _(a.Gx, a.Gy, r)), (_.ZERO = new _(n, r, n))
        function R(te, Q) {
          const J = Q.negate()
          return te ? J : Q
        }
        const N = new WeakMap()
        class T {
          constructor(Q, J) {
            ;(this.x = Q), (this.y = J)
          }
          _setWindowSize(Q) {
            ;(this._WINDOW_SIZE = Q), N.delete(this)
          }
          hasEvenY() {
            return this.y % s === n
          }
          static fromCompressedHex(Q) {
            const J = Q.length === 32,
              se = z(J ? Q : Q.subarray(1))
            if (!X(se)) throw new Error('Point is not on curve')
            const le = m(se)
            let pe = K(le)
            const xe = (pe & r) === r
            J ? xe && (pe = C(-pe)) : ((Q[0] & 1) === 1) !== xe && (pe = C(-pe))
            const je = new T(se, pe)
            return je.assertValidity(), je
          }
          static fromUncompressedHex(Q) {
            const J = z(Q.subarray(1, l + 1)),
              se = z(Q.subarray(l + 1, l * 2 + 1)),
              le = new T(J, se)
            return le.assertValidity(), le
          }
          static fromHex(Q) {
            const J = j(Q),
              se = J.length,
              le = J[0]
            if (se === l) return this.fromCompressedHex(J)
            if (se === p && (le === 2 || le === 3)) return this.fromCompressedHex(J)
            if (se === y && le === 4) return this.fromUncompressedHex(J)
            throw new Error(
              `Point.fromHex: received invalid point. Expected 32-${p} compressed bytes or ${y} uncompressed bytes, not ${se}`
            )
          }
          static fromPrivateKey(Q) {
            return T.BASE.multiply(be(Q))
          }
          static fromSignature(Q, J, se) {
            const { r: le, s: pe } = de(J)
            if (![0, 1, 2, 3].includes(se)) throw new Error('Cannot recover: invalid recovery bit')
            const xe = ve(j(Q)),
              { n: je } = a,
              Qe = se === 2 || se === 3 ? le + je : le,
              qe = ee(Qe, je),
              vt = C(-xe * qe, je),
              at = C(pe * qe, je),
              ct = se & 1 ? '03' : '02',
              Un = T.fromHex(ct + v(Qe)),
              xt = T.BASE.multiplyAndAddUnsafe(Un, vt, at)
            if (!xt) throw new Error('Cannot recover signature: point at infinify')
            return xt.assertValidity(), xt
          }
          toRawBytes(Q = !1) {
            return F(this.toHex(Q))
          }
          toHex(Q = !1) {
            const J = v(this.x)
            return Q ? `${this.hasEvenY() ? '02' : '03'}${J}` : `04${J}${v(this.y)}`
          }
          toHexX() {
            return this.toHex(!0).slice(2)
          }
          toRawX() {
            return this.toRawBytes(!0).slice(1)
          }
          assertValidity() {
            const Q = 'Point is not on elliptic curve',
              { x: J, y: se } = this
            if (!X(J) || !X(se)) throw new Error(Q)
            const le = C(se * se),
              pe = m(J)
            if (C(le - pe) !== n) throw new Error(Q)
          }
          equals(Q) {
            return this.x === Q.x && this.y === Q.y
          }
          negate() {
            return new T(this.x, C(-this.y))
          }
          double() {
            return _.fromAffine(this).double().toAffine()
          }
          add(Q) {
            return _.fromAffine(this).add(_.fromAffine(Q)).toAffine()
          }
          subtract(Q) {
            return this.add(Q.negate())
          }
          multiply(Q) {
            return _.fromAffine(this).multiply(Q, this).toAffine()
          }
          multiplyAndAddUnsafe(Q, J, se) {
            const le = _.fromAffine(this),
              pe = J === n || J === r || this !== T.BASE ? le.multiplyUnsafe(J) : le.multiply(J),
              xe = _.fromAffine(Q).multiplyUnsafe(se),
              je = pe.add(xe)
            return je.equals(_.ZERO) ? void 0 : je.toAffine()
          }
        }
        ;(t.Point = T), (T.BASE = new T(a.Gx, a.Gy)), (T.ZERO = new T(n, n))
        function M(te) {
          return Number.parseInt(te[0], 16) >= 8 ? '00' + te : te
        }
        function H(te) {
          if (te.length < 2 || te[0] !== 2)
            throw new Error(`Invalid signature integer tag: ${U(te)}`)
          const Q = te[1],
            J = te.subarray(2, Q + 2)
          if (!Q || J.length !== Q) throw new Error('Invalid signature integer: wrong length')
          if (J[0] === 0 && J[1] <= 127)
            throw new Error('Invalid signature integer: trailing length')
          return { data: z(J), left: te.subarray(Q + 2) }
        }
        function B(te) {
          if (te.length < 2 || te[0] != 48) throw new Error(`Invalid signature tag: ${U(te)}`)
          if (te[1] !== te.length - 2) throw new Error('Invalid signature: incorrect length')
          const { data: Q, left: J } = H(te.subarray(2)),
            { data: se, left: le } = H(J)
          if (le.length) throw new Error(`Invalid signature: left bytes after parsing: ${U(le)}`)
          return { r: Q, s: se }
        }
        class $ {
          constructor(Q, J) {
            ;(this.r = Q), (this.s = J), this.assertValidity()
          }
          static fromCompact(Q) {
            const J = Q instanceof Uint8Array,
              se = 'Signature.fromCompact'
            if (typeof Q != 'string' && !J)
              throw new TypeError(`${se}: Expected string or Uint8Array`)
            const le = J ? U(Q) : Q
            if (le.length !== 128) throw new Error(`${se}: Expected 64-byte hex`)
            return new $(O(le.slice(0, 64)), O(le.slice(64, 128)))
          }
          static fromDER(Q) {
            const J = Q instanceof Uint8Array
            if (typeof Q != 'string' && !J)
              throw new TypeError('Signature.fromDER: Expected string or Uint8Array')
            const { r: se, s: le } = B(J ? Q : F(Q))
            return new $(se, le)
          }
          static fromHex(Q) {
            return this.fromDER(Q)
          }
          assertValidity() {
            const { r: Q, s: J } = this
            if (!Z(Q)) throw new Error('Invalid Signature: r must be 0 < r < n')
            if (!Z(J)) throw new Error('Invalid Signature: s must be 0 < s < n')
          }
          hasHighS() {
            const Q = a.n >> r
            return this.s > Q
          }
          normalizeS() {
            return this.hasHighS() ? new $(this.r, C(-this.s, a.n)) : this
          }
          toDERRawBytes() {
            return F(this.toDERHex())
          }
          toDERHex() {
            const Q = M(P(this.s)),
              J = M(P(this.r)),
              se = Q.length / 2,
              le = J.length / 2,
              pe = P(se),
              xe = P(le)
            return `30${P(le + se + 4)}02${xe}${J}02${pe}${Q}`
          }
          toRawBytes() {
            return this.toDERRawBytes()
          }
          toHex() {
            return this.toDERHex()
          }
          toCompactRawBytes() {
            return F(this.toCompactHex())
          }
          toCompactHex() {
            return v(this.r) + v(this.s)
          }
        }
        t.Signature = $
        function D(...te) {
          if (!te.every(se => se instanceof Uint8Array)) throw new Error('Uint8Array list expected')
          if (te.length === 1) return te[0]
          const Q = te.reduce((se, le) => se + le.length, 0),
            J = new Uint8Array(Q)
          for (let se = 0, le = 0; se < te.length; se++) {
            const pe = te[se]
            J.set(pe, le), (le += pe.length)
          }
          return J
        }
        const W = Array.from({ length: 256 }, (te, Q) => Q.toString(16).padStart(2, '0'))
        function U(te) {
          if (!(te instanceof Uint8Array)) throw new Error('Expected Uint8Array')
          let Q = ''
          for (let J = 0; J < te.length; J++) Q += W[te[J]]
          return Q
        }
        const w = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000')
        function v(te) {
          if (typeof te != 'bigint') throw new Error('Expected bigint')
          if (!(n <= te && te < w)) throw new Error('Expected number 0 <= n < 2^256')
          return te.toString(16).padStart(64, '0')
        }
        function A(te) {
          const Q = F(v(te))
          if (Q.length !== 32) throw new Error('Error: expected 32 bytes')
          return Q
        }
        function P(te) {
          const Q = te.toString(16)
          return Q.length & 1 ? `0${Q}` : Q
        }
        function O(te) {
          if (typeof te != 'string')
            throw new TypeError('hexToNumber: expected string, got ' + typeof te)
          return BigInt(`0x${te}`)
        }
        function F(te) {
          if (typeof te != 'string')
            throw new TypeError('hexToBytes: expected string, got ' + typeof te)
          if (te.length % 2)
            throw new Error('hexToBytes: received invalid unpadded hex' + te.length)
          const Q = new Uint8Array(te.length / 2)
          for (let J = 0; J < Q.length; J++) {
            const se = J * 2,
              le = te.slice(se, se + 2),
              pe = Number.parseInt(le, 16)
            if (Number.isNaN(pe) || pe < 0) throw new Error('Invalid byte sequence')
            Q[J] = pe
          }
          return Q
        }
        function z(te) {
          return O(U(te))
        }
        function j(te) {
          return te instanceof Uint8Array ? Uint8Array.from(te) : F(te)
        }
        function E(te) {
          if (typeof te == 'number' && Number.isSafeInteger(te) && te > 0) return BigInt(te)
          if (typeof te == 'bigint' && Z(te)) return te
          throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n')
        }
        function C(te, Q = a.P) {
          const J = te % Q
          return J >= n ? J : Q + J
        }
        function L(te, Q) {
          const { P: J } = a
          let se = te
          for (; Q-- > n; ) (se *= se), (se %= J)
          return se
        }
        function K(te) {
          const { P: Q } = a,
            J = BigInt(6),
            se = BigInt(11),
            le = BigInt(22),
            pe = BigInt(23),
            xe = BigInt(44),
            je = BigInt(88),
            Qe = (te * te * te) % Q,
            qe = (Qe * Qe * te) % Q,
            vt = (L(qe, i) * qe) % Q,
            at = (L(vt, i) * qe) % Q,
            ct = (L(at, s) * Qe) % Q,
            Un = (L(ct, se) * ct) % Q,
            xt = (L(Un, le) * Un) % Q,
            zt = (L(xt, xe) * xt) % Q,
            yo = (L(zt, je) * zt) % Q,
            un = (L(yo, xe) * xt) % Q,
            ln = (L(un, i) * qe) % Q,
            sa = (L(ln, pe) * Un) % Q,
            hc = (L(sa, J) * Qe) % Q,
            wo = L(hc, s)
          if ((wo * wo) % Q !== te) throw new Error('Cannot find square root')
          return wo
        }
        function ee(te, Q = a.P) {
          if (te === n || Q <= n)
            throw new Error(`invert: expected positive integers, got n=${te} mod=${Q}`)
          let J = C(te, Q),
            se = Q,
            le = n,
            pe = r
          for (; J !== n; ) {
            const je = se / J,
              Qe = se % J,
              qe = le - pe * je
            ;(se = J), (J = Qe), (le = pe), (pe = qe)
          }
          if (se !== r) throw new Error('invert: does not exist')
          return C(le, Q)
        }
        function oe(te, Q = a.P) {
          const J = new Array(te.length),
            se = te.reduce((pe, xe, je) => (xe === n ? pe : ((J[je] = pe), C(pe * xe, Q))), r),
            le = ee(se, Q)
          return (
            te.reduceRight(
              (pe, xe, je) => (xe === n ? pe : ((J[je] = C(pe * J[je], Q)), C(pe * xe, Q))),
              le
            ),
            J
          )
        }
        function fe(te) {
          const Q = te.length * 8 - d * 8,
            J = z(te)
          return Q > 0 ? J >> BigInt(Q) : J
        }
        function ve(te, Q = !1) {
          const J = fe(te)
          if (Q) return J
          const { n: se } = a
          return J >= se ? J - se : J
        }
        let tt, Ge
        class nt {
          constructor(Q, J) {
            if (((this.hashLen = Q), (this.qByteLen = J), typeof Q != 'number' || Q < 2))
              throw new Error('hashLen must be a number')
            if (typeof J != 'number' || J < 2) throw new Error('qByteLen must be a number')
            ;(this.v = new Uint8Array(Q).fill(1)),
              (this.k = new Uint8Array(Q).fill(0)),
              (this.counter = 0)
          }
          hmac(...Q) {
            return t.utils.hmacSha256(this.k, ...Q)
          }
          hmacSync(...Q) {
            return Ge(this.k, ...Q)
          }
          checkSync() {
            if (typeof Ge != 'function') throw new I('hmacSha256Sync needs to be set')
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error('Tried 1,000 k values for sign(), all were invalid')
            this.counter += 1
          }
          async reseed(Q = new Uint8Array()) {
            ;(this.k = await this.hmac(this.v, Uint8Array.from([0]), Q)),
              (this.v = await this.hmac(this.v)),
              Q.length !== 0 &&
                ((this.k = await this.hmac(this.v, Uint8Array.from([1]), Q)),
                (this.v = await this.hmac(this.v)))
          }
          reseedSync(Q = new Uint8Array()) {
            this.checkSync(),
              (this.k = this.hmacSync(this.v, Uint8Array.from([0]), Q)),
              (this.v = this.hmacSync(this.v)),
              Q.length !== 0 &&
                ((this.k = this.hmacSync(this.v, Uint8Array.from([1]), Q)),
                (this.v = this.hmacSync(this.v)))
          }
          async generate() {
            this.incr()
            let Q = 0
            const J = []
            for (; Q < this.qByteLen; ) {
              this.v = await this.hmac(this.v)
              const se = this.v.slice()
              J.push(se), (Q += this.v.length)
            }
            return D(...J)
          }
          generateSync() {
            this.checkSync(), this.incr()
            let Q = 0
            const J = []
            for (; Q < this.qByteLen; ) {
              this.v = this.hmacSync(this.v)
              const se = this.v.slice()
              J.push(se), (Q += this.v.length)
            }
            return D(...J)
          }
        }
        function Z(te) {
          return n < te && te < a.n
        }
        function X(te) {
          return n < te && te < a.P
        }
        function ie(te, Q, J, se = !0) {
          const { n: le } = a,
            pe = ve(te, !0)
          if (!Z(pe)) return
          const xe = ee(pe, le),
            je = T.BASE.multiply(pe),
            Qe = C(je.x, le)
          if (Qe === n) return
          const qe = C(xe * C(Q + J * Qe, le), le)
          if (qe === n) return
          let vt = new $(Qe, qe),
            at = (je.x === vt.r ? 0 : 2) | Number(je.y & r)
          return (
            se && vt.hasHighS() && ((vt = vt.normalizeS()), (at ^= 1)), { sig: vt, recovery: at }
          )
        }
        function be(te) {
          let Q
          if (typeof te == 'bigint') Q = te
          else if (typeof te == 'number' && Number.isSafeInteger(te) && te > 0) Q = BigInt(te)
          else if (typeof te == 'string') {
            if (te.length !== 2 * d) throw new Error('Expected 32 bytes of private key')
            Q = O(te)
          } else if (te instanceof Uint8Array) {
            if (te.length !== d) throw new Error('Expected 32 bytes of private key')
            Q = z(te)
          } else throw new TypeError('Expected valid private key')
          if (!Z(Q)) throw new Error('Expected private key: 0 < key < n')
          return Q
        }
        function ue(te) {
          return te instanceof T ? (te.assertValidity(), te) : T.fromHex(te)
        }
        function de(te) {
          if (te instanceof $) return te.assertValidity(), te
          try {
            return $.fromDER(te)
          } catch {
            return $.fromCompact(te)
          }
        }
        function Te(te, Q = !1) {
          return T.fromPrivateKey(te).toRawBytes(Q)
        }
        t.getPublicKey = Te
        function we(te, Q, J, se = !1) {
          return T.fromSignature(te, Q, J).toRawBytes(se)
        }
        t.recoverPublicKey = we
        function ge(te) {
          const Q = te instanceof Uint8Array,
            J = typeof te == 'string',
            se = (Q || J) && te.length
          return Q ? se === p || se === y : J ? se === p * 2 || se === y * 2 : te instanceof T
        }
        function he(te, Q, J = !1) {
          if (ge(te)) throw new TypeError('getSharedSecret: first arg must be private key')
          if (!ge(Q)) throw new TypeError('getSharedSecret: second arg must be public key')
          const se = ue(Q)
          return se.assertValidity(), se.multiply(be(te)).toRawBytes(J)
        }
        t.getSharedSecret = he
        function Ne(te) {
          const Q = te.length > l ? te.slice(0, l) : te
          return z(Q)
        }
        function _e(te) {
          const Q = Ne(te),
            J = C(Q, a.n)
          return Be(J < n ? Q : J)
        }
        function Be(te) {
          return A(te)
        }
        function $e(te, Q, J) {
          if (te == null) throw new Error(`sign: expected valid message hash, not "${te}"`)
          const se = j(te),
            le = be(Q),
            pe = [Be(le), _e(se)]
          if (J != null) {
            J === !0 && (J = t.utils.randomBytes(l))
            const Qe = j(J)
            if (Qe.length !== l) throw new Error(`sign: Expected ${l} bytes of extra data`)
            pe.push(Qe)
          }
          const xe = D(...pe),
            je = Ne(se)
          return { seed: xe, m: je, d: le }
        }
        function S(te, Q) {
          const { sig: J, recovery: se } = te,
            { der: le, recovered: pe } = Object.assign({ canonical: !0, der: !0 }, Q),
            xe = le ? J.toDERRawBytes() : J.toCompactRawBytes()
          return pe ? [xe, se] : xe
        }
        async function f(te, Q, J = {}) {
          const { seed: se, m: le, d: pe } = $e(te, Q, J.extraEntropy),
            xe = new nt(h, d)
          await xe.reseed(se)
          let je
          for (; !(je = ie(await xe.generate(), le, pe, J.canonical)); ) await xe.reseed()
          return S(je, J)
        }
        t.sign = f
        function g(te, Q, J = {}) {
          const { seed: se, m: le, d: pe } = $e(te, Q, J.extraEntropy),
            xe = new nt(h, d)
          xe.reseedSync(se)
          let je
          for (; !(je = ie(xe.generateSync(), le, pe, J.canonical)); ) xe.reseedSync()
          return S(je, J)
        }
        t.signSync = g
        const k = { strict: !0 }
        function q(te, Q, J, se = k) {
          let le
          try {
            ;(le = de(te)), (Q = j(Q))
          } catch {
            return !1
          }
          const { r: pe, s: xe } = le
          if (se.strict && le.hasHighS()) return !1
          const je = ve(Q)
          let Qe
          try {
            Qe = ue(J)
          } catch {
            return !1
          }
          const { n: qe } = a,
            vt = ee(xe, qe),
            at = C(je * vt, qe),
            ct = C(pe * vt, qe),
            Un = T.BASE.multiplyAndAddUnsafe(Qe, at, ct)
          return Un ? C(Un.x, qe) === pe : !1
        }
        t.verify = q
        function V(te) {
          return C(z(te), a.n)
        }
        class Y {
          constructor(Q, J) {
            ;(this.r = Q), (this.s = J), this.assertValidity()
          }
          static fromHex(Q) {
            const J = j(Q)
            if (J.length !== 64)
              throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${J.length}`)
            const se = z(J.subarray(0, 32)),
              le = z(J.subarray(32, 64))
            return new Y(se, le)
          }
          assertValidity() {
            const { r: Q, s: J } = this
            if (!X(Q) || !Z(J)) throw new Error('Invalid signature')
          }
          toHex() {
            return v(this.r) + v(this.s)
          }
          toRawBytes() {
            return F(this.toHex())
          }
        }
        function ke(te) {
          return T.fromPrivateKey(te).toRawX()
        }
        class Ve {
          constructor(Q, J, se = t.utils.randomBytes()) {
            if (Q == null) throw new TypeError(`sign: Expected valid message, not "${Q}"`)
            this.m = j(Q)
            const { x: le, scalar: pe } = this.getScalar(be(J))
            if (((this.px = le), (this.d = pe), (this.rand = j(se)), this.rand.length !== 32))
              throw new TypeError('sign: Expected 32 bytes of aux randomness')
          }
          getScalar(Q) {
            const J = T.fromPrivateKey(Q),
              se = J.hasEvenY() ? Q : a.n - Q
            return { point: J, scalar: se, x: J.toRawX() }
          }
          initNonce(Q, J) {
            return A(Q ^ z(J))
          }
          finalizeNonce(Q) {
            const J = C(z(Q), a.n)
            if (J === n) throw new Error('sign: Creation of signature failed. k is zero')
            const { point: se, x: le, scalar: pe } = this.getScalar(J)
            return { R: se, rx: le, k: pe }
          }
          finalizeSig(Q, J, se, le) {
            return new Y(Q.x, C(J + se * le, a.n)).toRawBytes()
          }
          error() {
            throw new Error('sign: Invalid signature produced')
          }
          async calc() {
            const { m: Q, d: J, px: se, rand: le } = this,
              pe = t.utils.taggedHash,
              xe = this.initNonce(J, await pe(hi.aux, le)),
              { R: je, rx: Qe, k: qe } = this.finalizeNonce(await pe(hi.nonce, xe, se, Q)),
              vt = V(await pe(hi.challenge, Qe, se, Q)),
              at = this.finalizeSig(je, qe, vt, J)
            return (await Md(at, Q, se)) || this.error(), at
          }
          calcSync() {
            const { m: Q, d: J, px: se, rand: le } = this,
              pe = t.utils.taggedHashSync,
              xe = this.initNonce(J, pe(hi.aux, le)),
              { R: je, rx: Qe, k: qe } = this.finalizeNonce(pe(hi.nonce, xe, se, Q)),
              vt = V(pe(hi.challenge, Qe, se, Q)),
              at = this.finalizeSig(je, qe, vt, J)
            return kn(at, Q, se) || this.error(), at
          }
        }
        async function Oe(te, Q, J) {
          return new Ve(te, Q, J).calc()
        }
        function st(te, Q, J) {
          return new Ve(te, Q, J).calcSync()
        }
        function Ue(te, Q, J) {
          const se = te instanceof Y,
            le = se ? te : Y.fromHex(te)
          return se && le.assertValidity(), { ...le, m: j(Q), P: ue(J) }
        }
        function Rn(te, Q, J, se) {
          const le = T.BASE.multiplyAndAddUnsafe(Q, be(J), C(-se, a.n))
          return !(!le || !le.hasEvenY() || le.x !== te)
        }
        async function Md(te, Q, J) {
          try {
            const { r: se, s: le, m: pe, P: xe } = Ue(te, Q, J),
              je = V(await t.utils.taggedHash(hi.challenge, A(se), xe.toRawX(), pe))
            return Rn(se, xe, le, je)
          } catch {
            return !1
          }
        }
        function kn(te, Q, J) {
          try {
            const { r: se, s: le, m: pe, P: xe } = Ue(te, Q, J),
              je = V(t.utils.taggedHashSync(hi.challenge, A(se), xe.toRawX(), pe))
            return Rn(se, xe, le, je)
          } catch (se) {
            if (se instanceof I) throw se
            return !1
          }
        }
        ;(t.schnorr = {
          Signature: Y,
          getPublicKey: ke,
          sign: Oe,
          verify: Md,
          signSync: st,
          verifySync: kn
        }),
          T.BASE._setWindowSize(8)
        const jt = {
            node: e,
            web: typeof self == 'object' && 'crypto' in self ? self.crypto : void 0
          },
          hi = { challenge: 'BIP0340/challenge', aux: 'BIP0340/aux', nonce: 'BIP0340/nonce' },
          _n = {}
        ;(t.utils = {
          bytesToHex: U,
          hexToBytes: F,
          concatBytes: D,
          mod: C,
          invert: ee,
          isValidPrivateKey(te) {
            try {
              return be(te), !0
            } catch {
              return !1
            }
          },
          _bigintTo32Bytes: A,
          _normalizePrivateKey: be,
          hashToPrivateKey: te => {
            te = j(te)
            const Q = d + 8
            if (te.length < Q || te.length > 1024)
              throw new Error('Expected valid bytes of private key as per FIPS 186')
            const J = C(z(te), a.n - r) + r
            return A(J)
          },
          randomBytes: (te = 32) => {
            if (jt.web) return jt.web.getRandomValues(new Uint8Array(te))
            if (jt.node) {
              const { randomBytes: Q } = jt.node
              return Uint8Array.from(Q(te))
            } else throw new Error("The environment doesn't have randomBytes function")
          },
          randomPrivateKey: () => t.utils.hashToPrivateKey(t.utils.randomBytes(d + 8)),
          precompute(te = 8, Q = T.BASE) {
            const J = Q === T.BASE ? Q : new T(Q.x, Q.y)
            return J._setWindowSize(te), J.multiply(i), J
          },
          sha256: async (...te) => {
            if (jt.web) {
              const Q = await jt.web.subtle.digest('SHA-256', D(...te))
              return new Uint8Array(Q)
            } else if (jt.node) {
              const { createHash: Q } = jt.node,
                J = Q('sha256')
              return te.forEach(se => J.update(se)), Uint8Array.from(J.digest())
            } else throw new Error("The environment doesn't have sha256 function")
          },
          hmacSha256: async (te, ...Q) => {
            if (jt.web) {
              const J = await jt.web.subtle.importKey(
                  'raw',
                  te,
                  { name: 'HMAC', hash: { name: 'SHA-256' } },
                  !1,
                  ['sign']
                ),
                se = D(...Q),
                le = await jt.web.subtle.sign('HMAC', J, se)
              return new Uint8Array(le)
            } else if (jt.node) {
              const { createHmac: J } = jt.node,
                se = J('sha256', te)
              return Q.forEach(le => se.update(le)), Uint8Array.from(se.digest())
            } else throw new Error("The environment doesn't have hmac-sha256 function")
          },
          sha256Sync: void 0,
          hmacSha256Sync: void 0,
          taggedHash: async (te, ...Q) => {
            let J = _n[te]
            if (J === void 0) {
              const se = await t.utils.sha256(Uint8Array.from(te, le => le.charCodeAt(0)))
              ;(J = D(se, se)), (_n[te] = J)
            }
            return t.utils.sha256(J, ...Q)
          },
          taggedHashSync: (te, ...Q) => {
            if (typeof tt != 'function') throw new I('sha256Sync is undefined, you need to set it')
            let J = _n[te]
            if (J === void 0) {
              const se = tt(Uint8Array.from(te, le => le.charCodeAt(0)))
              ;(J = D(se, se)), (_n[te] = J)
            }
            return tt(J, ...Q)
          },
          _JacobianPoint: _
        }),
          Object.defineProperties(t.utils, {
            sha256Sync: {
              configurable: !1,
              get() {
                return tt
              },
              set(te) {
                tt || (tt = te)
              }
            },
            hmacSha256Sync: {
              configurable: !1,
              get() {
                return Ge
              },
              set(te) {
                Ge || (Ge = te)
              }
            }
          })
      })(Ib)),
    Ib
  )
}
var Ac = {},
  Fx
function kce() {
  if (Fx) return Ac
  ;(Fx = 1),
    Object.defineProperty(Ac, '__esModule', { value: !0 }),
    (Ac.joseToDer = Ac.derToJose = void 0)
  const t = P0(),
    e = ty()
  function n(b) {
    return ((b / 8) | 0) + (b % 8 === 0 ? 0 : 1)
  }
  const r = { ES256: n(256), ES384: n(384), ES512: n(521) }
  function s(b) {
    const I = r[b]
    if (I) return I
    throw new Error(`Unknown algorithm "${b}"`)
  }
  const i = 128,
    o = 0,
    a = 32,
    c = 16,
    u = 2,
    l = c | a | (o << 6),
    d = u | (o << 6)
  function h(b) {
    if (b instanceof Uint8Array) return b
    if (typeof b == 'string') return (0, t.toByteArray)((0, e.pad)(b))
    throw new TypeError('ECDSA signature must be a Base64 string or a Uint8Array')
  }
  function p(b, I) {
    const x = h(b),
      _ = s(I),
      R = _ + 1,
      N = x.length
    let T = 0
    if (x[T++] !== l) throw new Error('Could not find expected "seq"')
    let M = x[T++]
    if ((M === (i | 1) && (M = x[T++]), N - T < M))
      throw new Error(`"seq" specified length of "${M}", only "${N - T}" remaining`)
    if (x[T++] !== d) throw new Error('Could not find expected "int" for "r"')
    const H = x[T++]
    if (N - T - 2 < H)
      throw new Error(`"r" specified length of "${H}", only "${N - T - 2}" available`)
    if (R < H) throw new Error(`"r" specified length of "${H}", max of "${R}" is acceptable`)
    const B = T
    if (((T += H), x[T++] !== d)) throw new Error('Could not find expected "int" for "s"')
    const $ = x[T++]
    if (N - T !== $) throw new Error(`"s" specified length of "${$}", expected "${N - T}"`)
    if (R < $) throw new Error(`"s" specified length of "${$}", max of "${R}" is acceptable`)
    const D = T
    if (((T += $), T !== N))
      throw new Error(`Expected to consume entire array, but "${N - T}" bytes remain`)
    const W = _ - H,
      U = _ - $,
      w = new Uint8Array(W + H + U + $)
    for (T = 0; T < W; ++T) w[T] = 0
    w.set(x.subarray(B + Math.max(-W, 0), B + H), T), (T = _)
    for (const v = T; T < v + U; ++T) w[T] = 0
    return w.set(x.subarray(D + Math.max(-U, 0), D + $), T), (0, e.escape)((0, t.fromByteArray)(w))
  }
  Ac.derToJose = p
  function y(b, I, x) {
    let _ = 0
    for (; I + _ < x && b[I + _] === 0; ) ++_
    return b[I + _] >= i && --_, _
  }
  function m(b, I) {
    b = h(b)
    const x = s(I),
      _ = b.length
    if (_ !== x * 2) throw new TypeError(`"${I}" signatures must be "${x * 2}" bytes, saw "${_}"`)
    const R = y(b, 0, x),
      N = y(b, x, b.length),
      T = x - R,
      M = x - N,
      H = 2 + T + 1 + 1 + M,
      B = H < i,
      $ = new Uint8Array((B ? 2 : 3) + H)
    let D = 0
    return (
      ($[D++] = l),
      B ? ($[D++] = H) : (($[D++] = i | 1), ($[D++] = H & 255)),
      ($[D++] = d),
      ($[D++] = T),
      R < 0
        ? (($[D++] = 0), $.set(b.subarray(0, x), D), (D += x))
        : ($.set(b.subarray(R, x), D), (D += x - R)),
      ($[D++] = d),
      ($[D++] = M),
      N < 0 ? (($[D++] = 0), $.set(b.subarray(x), D)) : $.set(b.subarray(x + N), D),
      $
    )
  }
  return (Ac.joseToDer = m), Ac
}
var _c = {},
  jx
function ry() {
  if (jx) return _c
  ;(jx = 1),
    Object.defineProperty(_c, '__esModule', { value: !0 }),
    (_c.InvalidTokenError = _c.MissingParametersError = void 0)
  class t extends Error {
    constructor(r) {
      super(), (this.name = 'MissingParametersError'), (this.message = r || '')
    }
  }
  _c.MissingParametersError = t
  class e extends Error {
    constructor(r) {
      super(), (this.name = 'InvalidTokenError'), (this.message = r || '')
    }
  }
  return (_c.InvalidTokenError = e), _c
}
var Hx
function Oce() {
  if (Hx) return oh
  ;(Hx = 1), Object.defineProperty(oh, '__esModule', { value: !0 }), (oh.SECP256K1Client = void 0)
  const t = xce(),
    e = K8(),
    n = Rce(),
    r = kce(),
    s = ry(),
    i = ny()
  n.utils.hmacSha256Sync = (a, ...c) => {
    const u = t.hmac.create(e.sha256, a)
    return c.forEach(l => u.update(l)), u.digest()
  }
  class o {
    static derivePublicKey(c, u = !0) {
      return (
        c.length === 66 && (c = c.slice(0, 64)),
        c.length < 64 && (c = c.padStart(64, '0')),
        (0, i.bytesToHex)(n.getPublicKey(c, u))
      )
    }
    static signHash(c, u, l = 'jose') {
      if (!c || !u)
        throw new s.MissingParametersError('a signing input hash and private key are all required')
      const d = n.signSync(c, u.slice(0, 64), { der: !0, canonical: !1 })
      if (l === 'der') return (0, i.bytesToHex)(d)
      if (l === 'jose') return (0, r.derToJose)(d, 'ES256')
      throw Error('Invalid signature format')
    }
    static loadSignature(c) {
      return (0, r.joseToDer)(c, 'ES256')
    }
    static verifyHash(c, u, l) {
      if (!c || !u || !l)
        throw new s.MissingParametersError(
          'a signing input hash, der signature, and public key are all required'
        )
      return n.verify(u, c, l, { strict: !1 })
    }
  }
  return (oh.SECP256K1Client = o), (o.algorithmName = 'ES256K'), oh
}
var qx
function KA() {
  return (
    qx ||
      ((qx = 1),
      (function (t) {
        Object.defineProperty(t, '__esModule', { value: !0 }),
          (t.cryptoClients = t.SECP256K1Client = void 0)
        const e = Oce()
        Object.defineProperty(t, 'SECP256K1Client', {
          enumerable: !0,
          get: function () {
            return e.SECP256K1Client
          }
        })
        const n = { ES256K: e.SECP256K1Client }
        t.cryptoClients = n
      })(_b)),
    _b
  )
}
var ko = {},
  zx
function V8() {
  if (zx) return ko
  zx = 1
  var t =
    (ko && ko.__awaiter) ||
    function (s, i, o, a) {
      function c(u) {
        return u instanceof o
          ? u
          : new o(function (l) {
              l(u)
            })
      }
      return new (o || (o = Promise))(function (u, l) {
        function d(y) {
          try {
            p(a.next(y))
          } catch (m) {
            l(m)
          }
        }
        function h(y) {
          try {
            p(a.throw(y))
          } catch (m) {
            l(m)
          }
        }
        function p(y) {
          y.done ? u(y.value) : c(y.value).then(d, h)
        }
        p((a = a.apply(s, i || [])).next())
      })
    }
  Object.defineProperty(ko, '__esModule', { value: !0 }),
    (ko.hashSha256Async = ko.hashSha256 = void 0)
  const e = K8()
  function n(s) {
    return (0, e.sha256)(s)
  }
  ko.hashSha256 = n
  function r(s) {
    return t(this, void 0, void 0, function* () {
      try {
        if (typeof crypto < 'u' && typeof crypto.subtle < 'u') {
          const o = typeof s == 'string' ? new TextEncoder().encode(s) : s,
            a = yield crypto.subtle.digest('SHA-256', o)
          return new Uint8Array(a)
        } else {
          const o = WA
          if (!o.createHash) throw new Error('`crypto` module does not contain `createHash`')
          return Promise.resolve(o.createHash('sha256').update(s).digest())
        }
      } catch (i) {
        return (
          console.log(i),
          console.log(
            'Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'
          ),
          Promise.resolve(n(s))
        )
      }
    })
  }
  return (ko.hashSha256Async = r), ko
}
var Wx
function Bce() {
  if (Wx) return Po
  Wx = 1
  var t =
    (Po && Po.__awaiter) ||
    function (c, u, l, d) {
      function h(p) {
        return p instanceof l
          ? p
          : new l(function (y) {
              y(p)
            })
      }
      return new (l || (l = Promise))(function (p, y) {
        function m(x) {
          try {
            I(d.next(x))
          } catch (_) {
            y(_)
          }
        }
        function b(x) {
          try {
            I(d.throw(x))
          } catch (_) {
            y(_)
          }
        }
        function I(x) {
          x.done ? p(x.value) : h(x.value).then(m, b)
        }
        I((d = d.apply(c, u || [])).next())
      })
    }
  Object.defineProperty(Po, '__esModule', { value: !0 }),
    (Po.TokenSigner = Po.createUnsecuredToken = void 0)
  const e = ty(),
    n = KA(),
    r = ry(),
    s = V8()
  function i(c, u) {
    const l = [],
      d = e.encode(JSON.stringify(u))
    l.push(d)
    const h = e.encode(JSON.stringify(c))
    return l.push(h), l.join('.')
  }
  function o(c) {
    return i(c, { typ: 'JWT', alg: 'none' }) + '.'
  }
  Po.createUnsecuredToken = o
  class a {
    constructor(u, l) {
      if (!(u && l))
        throw new r.MissingParametersError('a signing algorithm and private key are required')
      if (typeof u != 'string') throw new Error('signing algorithm parameter must be a string')
      if (((u = u.toUpperCase()), !n.cryptoClients.hasOwnProperty(u)))
        throw new Error('invalid signing algorithm')
      ;(this.tokenType = 'JWT'), (this.cryptoClient = n.cryptoClients[u]), (this.rawPrivateKey = l)
    }
    header(u = {}) {
      const l = { typ: this.tokenType, alg: this.cryptoClient.algorithmName }
      return Object.assign({}, l, u)
    }
    sign(u, l = !1, d = {}) {
      const h = this.header(d),
        p = i(u, h),
        y = (0, s.hashSha256)(p)
      return this.createWithSignedHash(u, l, h, p, y)
    }
    signAsync(u, l = !1, d = {}) {
      return t(this, void 0, void 0, function* () {
        const h = this.header(d),
          p = i(u, h),
          y = yield (0, s.hashSha256Async)(p)
        return this.createWithSignedHash(u, l, h, p, y)
      })
    }
    createWithSignedHash(u, l, d, h, p) {
      const y = this.cryptoClient.signHash(p, this.rawPrivateKey)
      return l
        ? { header: [e.encode(JSON.stringify(d))], payload: JSON.stringify(u), signature: [y] }
        : [h, y].join('.')
    }
  }
  return (Po.TokenSigner = a), Po
}
var ch = {},
  Kx
function Dce() {
  if (Kx) return ch
  ;(Kx = 1), Object.defineProperty(ch, '__esModule', { value: !0 }), (ch.TokenVerifier = void 0)
  const t = ty(),
    e = KA(),
    n = ry(),
    r = V8()
  class s {
    constructor(o, a) {
      if (!(o && a))
        throw new n.MissingParametersError('a signing algorithm and public key are required')
      if (typeof o != 'string') throw 'signing algorithm parameter must be a string'
      if (((o = o.toUpperCase()), !e.cryptoClients.hasOwnProperty(o)))
        throw 'invalid signing algorithm'
      ;(this.tokenType = 'JWT'), (this.cryptoClient = e.cryptoClients[o]), (this.rawPublicKey = a)
    }
    verify(o) {
      return typeof o == 'string'
        ? this.verifyCompact(o, !1)
        : typeof o == 'object'
          ? this.verifyExpanded(o, !1)
          : !1
    }
    verifyAsync(o) {
      return typeof o == 'string'
        ? this.verifyCompact(o, !0)
        : typeof o == 'object'
          ? this.verifyExpanded(o, !0)
          : Promise.resolve(!1)
    }
    verifyCompact(o, a) {
      const c = o.split('.'),
        u = c[0] + '.' + c[1],
        l = d => {
          const h = this.cryptoClient.loadSignature(c[2])
          return this.cryptoClient.verifyHash(d, h, this.rawPublicKey)
        }
      if (a) return (0, r.hashSha256Async)(u).then(d => l(d))
      {
        const d = (0, r.hashSha256)(u)
        return l(d)
      }
    }
    verifyExpanded(o, a) {
      const c = [o.header.join('.'), t.encode(o.payload)].join('.')
      let u = !0
      const l = d => (
        o.signature.map(h => {
          const p = this.cryptoClient.loadSignature(h)
          this.cryptoClient.verifyHash(d, p, this.rawPublicKey) || (u = !1)
        }),
        u
      )
      if (a) return (0, r.hashSha256Async)(c).then(d => l(d))
      {
        const d = (0, r.hashSha256)(c)
        return l(d)
      }
    }
  }
  return (ch.TokenVerifier = s), ch
}
var uh = {},
  Vx
function Mce() {
  if (Vx) return uh
  ;(Vx = 1), Object.defineProperty(uh, '__esModule', { value: !0 }), (uh.decodeToken = void 0)
  const t = ty()
  function e(n) {
    if (typeof n == 'string') {
      const r = n.split('.'),
        s = JSON.parse(t.decode(r[0])),
        i = JSON.parse(t.decode(r[1])),
        o = r[2]
      return { header: s, payload: i, signature: o }
    } else if (typeof n == 'object') {
      if (typeof n.payload != 'string')
        throw new Error('Expected token payload to be a base64 or json string')
      let r = n.payload
      n.payload[0] !== '{' && (r = t.decode(r))
      const s = []
      return (
        n.header.map(i => {
          const o = JSON.parse(t.decode(i))
          s.push(o)
        }),
        { header: s, payload: JSON.parse(r), signature: n.signature }
      )
    }
  }
  return (uh.decodeToken = e), uh
}
var Gx
function Uce() {
  return (
    Gx ||
      ((Gx = 1),
      (function (t) {
        var e =
            (Ec && Ec.__createBinding) ||
            (Object.create
              ? function (r, s, i, o) {
                  o === void 0 && (o = i)
                  var a = Object.getOwnPropertyDescriptor(s, i)
                  ;(!a || ('get' in a ? !s.__esModule : a.writable || a.configurable)) &&
                    (a = {
                      enumerable: !0,
                      get: function () {
                        return s[i]
                      }
                    }),
                    Object.defineProperty(r, o, a)
                }
              : function (r, s, i, o) {
                  o === void 0 && (o = i), (r[o] = s[i])
                }),
          n =
            (Ec && Ec.__exportStar) ||
            function (r, s) {
              for (var i in r)
                i !== 'default' && !Object.prototype.hasOwnProperty.call(s, i) && e(s, r, i)
            }
        Object.defineProperty(t, '__esModule', { value: !0 }),
          n(Bce(), t),
          n(Dce(), t),
          n(Mce(), t),
          n(ry(), t),
          n(KA(), t)
      })(Ec)),
    Ec
  )
}
Uce()
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var Qx =
  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
;(() => {
  const t = Array(256).fill(-1)
  for (let e = 0; e < Qx.length; ++e) t[Qx.charCodeAt(e)] = e
})()
var Zx,
  xb,
  yg,
  VA =
    ((Zx = function (t, e) {
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.bech32m = e.bech32 = void 0)
      const n = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l',
        r = {}
      for (let d = 0; d < 32; d++) {
        const h = n.charAt(d)
        r[h] = d
      }
      function s(d) {
        const h = d >> 25
        return (
          ((33554431 & d) << 5) ^
          (996825010 & -((h >> 0) & 1)) ^
          (642813549 & -((h >> 1) & 1)) ^
          (513874426 & -((h >> 2) & 1)) ^
          (1027748829 & -((h >> 3) & 1)) ^
          (705979059 & -((h >> 4) & 1))
        )
      }
      function i(d) {
        let h = 1
        for (let p = 0; p < d.length; ++p) {
          const y = d.charCodeAt(p)
          if (y < 33 || y > 126) return 'Invalid prefix (' + d + ')'
          h = s(h) ^ (y >> 5)
        }
        h = s(h)
        for (let p = 0; p < d.length; ++p) {
          const y = d.charCodeAt(p)
          h = s(h) ^ (31 & y)
        }
        return h
      }
      function o(d, h, p, y) {
        let m = 0,
          b = 0
        const I = (1 << p) - 1,
          x = []
        for (let _ = 0; _ < d.length; ++_)
          for (m = (m << h) | d[_], b += h; b >= p; ) (b -= p), x.push((m >> b) & I)
        if (y) b > 0 && x.push((m << (p - b)) & I)
        else {
          if (b >= h) return 'Excess padding'
          if ((m << (p - b)) & I) return 'Non-zero padding'
        }
        return x
      }
      function a(d) {
        return o(d, 8, 5, !0)
      }
      function c(d) {
        const h = o(d, 5, 8, !1)
        if (Array.isArray(h)) return h
      }
      function u(d) {
        const h = o(d, 5, 8, !1)
        if (Array.isArray(h)) return h
        throw new Error(h)
      }
      function l(d) {
        let h
        function p(y, m) {
          if (((m = m || 90), y.length < 8)) return y + ' too short'
          if (y.length > m) return 'Exceeds length limit'
          const b = y.toLowerCase(),
            I = y.toUpperCase()
          if (y !== b && y !== I) return 'Mixed-case string ' + y
          const x = (y = b).lastIndexOf('1')
          if (x === -1) return 'No separator character for ' + y
          if (x === 0) return 'Missing prefix for ' + y
          const _ = y.slice(0, x),
            R = y.slice(x + 1)
          if (R.length < 6) return 'Data too short'
          let N = i(_)
          if (typeof N == 'string') return N
          const T = []
          for (let M = 0; M < R.length; ++M) {
            const H = R.charAt(M),
              B = r[H]
            if (B === void 0) return 'Unknown character ' + H
            ;(N = s(N) ^ B), M + 6 >= R.length || T.push(B)
          }
          return N !== h ? 'Invalid checksum for ' + y : { prefix: _, words: T }
        }
        return (
          (h = d === 'bech32' ? 1 : 734539939),
          {
            decodeUnsafe: function (y, m) {
              const b = p(y, m)
              if (typeof b == 'object') return b
            },
            decode: function (y, m) {
              const b = p(y, m)
              if (typeof b == 'object') return b
              throw new Error(b)
            },
            encode: function (y, m, b) {
              if (((b = b || 90), y.length + 7 + m.length > b))
                throw new TypeError('Exceeds length limit')
              let I = i((y = y.toLowerCase()))
              if (typeof I == 'string') throw new Error(I)
              let x = y + '1'
              for (let _ = 0; _ < m.length; ++_) {
                const R = m[_]
                if (R >> 5 != 0) throw new Error('Non 5-bit word')
                ;(I = s(I) ^ R), (x += n.charAt(R))
              }
              for (let _ = 0; _ < 6; ++_) I = s(I)
              I ^= h
              for (let _ = 0; _ < 6; ++_) x += n.charAt((I >> (5 * (5 - _))) & 31)
              return x
            },
            toWords: a,
            fromWordsUnsafe: c,
            fromWords: u
          }
        )
      }
      ;(e.bech32 = l('bech32')), (e.bech32m = l('bech32m'))
    }),
    Zx((xb = { exports: {} }), xb.exports),
    xb.exports)
;(yg = VA) && yg.__esModule && Object.prototype.hasOwnProperty.call(yg, 'default') && yg.default
VA.bech32m
VA.bech32
new Uint8Array(new Uint16Array([65279]).buffer)[0]
var yl, wl
;(function (t) {
  ;(t.mainnet = 'mainnet'), (t.testnet = 'testnet'), (t.regtest = 'regtest')
})(yl || (yl = {})),
  (function (t) {
    ;(t.p2pkh = 'p2pkh'),
      (t.p2sh = 'p2sh'),
      (t.p2wpkh = 'p2wpkh'),
      (t.p2wsh = 'p2wsh'),
      (t.p2tr = 'p2tr')
  })(wl || (wl = {}))
wl.p2pkh, yl.mainnet, wl.p2pkh, yl.testnet, wl.p2sh, yl.mainnet, wl.p2sh, yl.testnet
var ho = (t => (
    (t.Mainnet = 'Mainnet'),
    (t.Testnet = 'Testnet'),
    (t.Testnet4 = 'Testnet4'),
    (t.Signet = 'Signet'),
    (t.Regtest = 'Regtest'),
    t
  ))(ho || {}),
  GA = mt(ku([me(), Xn(), Xr()])),
  Yt = ye({
    jsonrpc: At('2.0'),
    method: me(),
    params: mt(ku([jn(ey()), H8({}), Xr()])),
    id: Sce(GA)
  }),
  Lce = ye({ jsonrpc: At('2.0'), result: qA(ey()), id: GA }),
  $ce = ye({ jsonrpc: At('2.0'), error: qA(ey()), id: GA })
ku([Lce, $ce])
var Fce = 'accountChange'
ye({ type: At(Fce) })
var jce = 'networkChange'
ye({ type: At(jce), bitcoin: ye({ name: Ks(ho) }), stacks: ye({ name: me() }) })
var Hce = 'disconnect'
ye({ type: At(Hce) })
function qce() {
  return window.btc_providers || (window.btc_providers = []), window.btc_providers
}
function zce(t) {
  return t == null ? void 0 : t.split('.').reduce((e, n) => (e == null ? void 0 : e[n]), window)
}
var Wce = 'stx_callContract',
  Kce = ye({
    contract: me(),
    functionName: me(),
    arguments: mt(jn(me())),
    functionArgs: mt(jn(me())),
    postConditions: mt(jn(me())),
    postConditionMode: mt(ku([At('allow'), At('deny')]))
  })
ye({ ...Yt.entries, ...ye({ method: At(Wce), params: Kce, id: me() }).entries })
var Vce = 'stx_deployContract',
  Gce = ye({
    name: me(),
    clarityCode: me(),
    clarityVersion: mt(me()),
    postConditions: mt(jn(me())),
    postConditionMode: mt(ku([At('allow'), At('deny')]))
  })
ye({ ...Yt.entries, ...ye({ method: At(Vce), params: Gce, id: me() }).entries })
var Qce = ['software', 'ledger', 'keystone'],
  G8 = q8(Qce),
  ki = (t => ((t.Ordinals = 'ordinals'), (t.Payment = 'payment'), (t.Stacks = 'stacks'), t))(
    ki || {}
  ),
  Q8 = (t => (
    (t.p2pkh = 'p2pkh'),
    (t.p2sh = 'p2sh'),
    (t.p2wpkh = 'p2wpkh'),
    (t.p2wsh = 'p2wsh'),
    (t.p2tr = 'p2tr'),
    (t.stacks = 'stacks'),
    t
  ))(Q8 || {}),
  Zce = ye({
    address: me(),
    publicKey: me(),
    purpose: Ks(ki),
    addressType: Ks(Q8),
    walletType: G8
  }),
  Yce = ye({ read: mt(Ru()) }),
  Jce = ye({ readNetwork: mt(Ru()) }),
  Xce = ye({ type: At('account'), resourceId: me(), clientId: me(), actions: Yce }),
  eue = ye({ type: At('wallet'), resourceId: me(), clientId: me(), actions: Jce }),
  Z8 = W8('type', [
    ye({ ...Rx(Xce, ['clientId']).entries }),
    ye({ ...Rx(eue, ['clientId']).entries })
  ]),
  tue = 'wallet_requestPermissions',
  nue = vr(jn(Z8))
At(!0)
ye({ ...Yt.entries, ...ye({ method: At(tue), params: nue, id: me() }).entries })
var rue = 'wallet_renouncePermissions',
  sue = vr(Xr())
vr(Xr())
ye({ ...Yt.entries, ...ye({ method: At(rue), params: sue, id: me() }).entries })
var iue = 'wallet_disconnect',
  oue = vr(Xr())
vr(Xr())
ye({ ...Yt.entries, ...ye({ method: At(iue), params: oue, id: me() }).entries })
var aue = 'wallet_getWalletType',
  cue = vr(Xr())
ye({ ...Yt.entries, ...ye({ method: At(aue), params: cue, id: me() }).entries })
var uue = 'wallet_getCurrentPermissions',
  lue = vr(Xr())
ye({ ...Yt.entries, ...ye({ method: At(uue), params: lue, id: me() }).entries })
var due = 'wallet_getNetwork',
  hue = vr(Xr())
ye({ bitcoin: ye({ name: Ks(ho) }), stacks: ye({ name: me() }) })
ye({ ...Yt.entries, ...ye({ method: At(due), params: hue, id: me() }).entries })
var fue = 'wallet_changeNetwork',
  pue = ye({ name: Ks(ho) })
vr(Xr())
ye({ ...Yt.entries, ...ye({ method: At(fue), params: pue, id: me() }).entries })
var gue = 'wallet_getAccount',
  mue = vr(Xr())
ye({ ...Yt.entries, ...ye({ method: At(gue), params: mue, id: me() }).entries })
var yue = 'wallet_connect',
  wue = vr(
    ye({
      permissions: mt(jn(Z8)),
      addresses: mt(jn(Ks(ki))),
      message: mt(Lv(me(), $8(80, 'The message must not exceed 80 characters.')))
    })
  )
ye({ ...Yt.entries, ...ye({ method: At(yue), params: wue, id: me() }).entries })
var bue = 'stx_getAccounts',
  vue = vr(Xr())
ye({ ...Yt.entries, ...ye({ method: At(bue), params: vue, id: me() }).entries })
var Eue = 'stx_getAddresses',
  Aue = vr(ye({ message: mt(me()) }))
ye({ ...Yt.entries, ...ye({ method: At(Eue), params: Aue, id: me() }).entries })
var _ue = 'stx_signMessage',
  Cue = ye({ message: me() })
ye({ ...Yt.entries, ...ye({ method: At(_ue), params: Cue, id: me() }).entries })
var Sue = 'stx_signStructuredMessage',
  Iue = ye({ domain: me(), message: me(), publicKey: mt(me()) })
ye({ ...Yt.entries, ...ye({ method: At(Sue), params: Iue, id: me() }).entries })
var xue = 'stx_signTransaction',
  Tue = ye({ transaction: me(), pubkey: mt(me()), broadcast: mt(Ru()) })
ye({ ...Yt.entries, ...ye({ method: At(xue), params: Tue, id: me() }).entries })
var Nue = 'stx_signTransactions',
  Pue = ye({
    transactions: Lv(
      jn(
        Lv(
          me(),
          L8(t => !0, 'Invalid hex-encoded Stacks transaction.')
        )
      ),
      F8(1)
    ),
    broadcast: mt(Ru())
  })
ye({ ...Yt.entries, ...ye({ method: At(Nue), params: Pue, id: me() }).entries })
var Rue = 'stx_transferStx',
  kue = ye({
    amount: ku([Xn(), me()]),
    recipient: me(),
    memo: mt(me()),
    version: mt(me()),
    postConditionMode: mt(Xn()),
    postConditions: mt(jn(me())),
    pubkey: mt(me())
  })
ye({ ...Yt.entries, ...ye({ method: At(Rue), params: kue, id: me() }).entries })
var Oue = 'getInfo',
  Bue = vr(Xr())
ye({ version: me(), methods: mt(jn(me())), supports: jn(me()) })
ye({ ...Yt.entries, ...ye({ method: At(Oue), params: Bue, id: me() }).entries })
var Due = 'getAddresses',
  Mue = ye({ purposes: jn(Ks(ki)), message: mt(me()) })
ye({ ...Yt.entries, ...ye({ method: At(Due), params: Mue, id: me() }).entries })
var Uue = 'signMessage',
  QA = (t => ((t.ECDSA = 'ECDSA'), (t.BIP322 = 'BIP322'), t))(QA || {}),
  Lue = ye({ address: me(), message: me(), protocol: mt(Ks(QA)) })
ye({ signature: me(), messageHash: me(), address: me(), protocol: Ks(QA) })
ye({ ...Yt.entries, ...ye({ method: At(Uue), params: Lue, id: me() }).entries })
var $ue = 'sendTransfer',
  Fue = ye({ recipients: jn(ye({ address: me(), amount: Xn() })) })
ye({ ...Yt.entries, ...ye({ method: At($ue), params: Fue, id: me() }).entries })
var jue = 'signPsbt',
  Hue = ye({ psbt: me(), signInputs: z8(me(), jn(Xn())), broadcast: mt(Ru()) })
ye({ psbt: me(), txid: mt(me()) })
ye({ ...Yt.entries, ...ye({ method: At(jue), params: Hue, id: me() }).entries })
var que = 'getAccounts',
  zue = ye({ purposes: jn(Ks(ki)), message: mt(me()) })
jn(ye({ ...Zce.entries, ...ye({ walletType: G8 }).entries }))
ye({ ...Yt.entries, ...ye({ method: At(que), params: zue, id: me() }).entries })
var Wue = 'getBalance'
vr(Xr())
ye({ ...Yt.entries, ...ye({ method: At(Wue), id: me() }).entries })
var Kue = 'runes_etch',
  Vue = ye({
    amount: me(),
    cap: me(),
    heightStart: mt(me()),
    heightEnd: mt(me()),
    offsetStart: mt(me()),
    offsetEnd: mt(me())
  }),
  Gue = ye({ contentType: me(), contentBase64: me() }),
  Que = ye({
    runeName: me(),
    divisibility: mt(Xn()),
    symbol: mt(me()),
    premine: mt(me()),
    isMintable: Ru(),
    delegateInscriptionId: mt(me()),
    destinationAddress: me(),
    refundAddress: me(),
    feeRate: Xn(),
    appServiceFee: mt(Xn()),
    appServiceFeeAddress: mt(me()),
    terms: mt(Vue),
    inscriptionDetails: mt(Gue),
    network: mt(Ks(ho))
  })
ye({ ...Yt.entries, ...ye({ method: At(Kue), params: Que, id: me() }).entries })
var Zue = 'runes_getBalance',
  Yue = vr(Xr())
ye({
  balances: jn(
    ye({
      runeName: me(),
      amount: me(),
      divisibility: Xn(),
      symbol: me(),
      inscriptionId: vr(me()),
      spendableBalance: me()
    })
  )
})
ye({ ...Yt.entries, ...ye({ method: At(Zue), params: Yue, id: me() }).entries })
var Jue = 'runes_mint',
  Xue = ye({
    appServiceFee: mt(Xn()),
    appServiceFeeAddress: mt(me()),
    destinationAddress: me(),
    feeRate: Xn(),
    refundAddress: me(),
    repeats: Xn(),
    runeName: me(),
    network: mt(Ks(ho))
  })
ye({ ...Yt.entries, ...ye({ method: At(Jue), params: Xue, id: me() }).entries })
var ele = 'runes_transfer',
  tle = ye({ recipients: jn(ye({ runeName: me(), amount: me(), address: me() })) })
ye({ ...Yt.entries, ...ye({ method: At(ele), params: tle, id: me() }).entries })
var nle = 'ord_getInscriptions',
  rle = ye({ offset: Xn(), limit: Xn() })
ye({
  total: Xn(),
  limit: Xn(),
  offset: Xn(),
  inscriptions: jn(
    ye({
      inscriptionId: me(),
      inscriptionNumber: me(),
      address: me(),
      collectionName: mt(me()),
      postage: me(),
      contentLength: me(),
      contentType: me(),
      timestamp: Xn(),
      offset: Xn(),
      genesisTransaction: me(),
      output: me()
    })
  )
})
ye({ ...Yt.entries, ...ye({ method: At(nle), params: rle, id: me() }).entries })
var sle = 'ord_sendInscriptions',
  ile = ye({ transfers: jn(ye({ address: me(), inscriptionId: me() })) })
ye({ ...Yt.entries, ...ye({ method: At(sle), params: ile, id: me() }).entries })
var Zo
;(function (t) {
  ;(t.Ordinal = 'ordinal'), (t.Payment = 'payment'), (t.Stacks = 'stx')
})(Zo || (Zo = {}))
function Yx(t) {
  switch (t) {
    case ki.Payment:
      return Zo.Payment
    case ki.Ordinals:
      return Zo.Ordinal
    case ki.Stacks:
      return Zo.Stacks
    default:
      return
  }
}
let sy = class {
  constructor() {
    this.listeners = {
      accountsChanged: [],
      chainChanged: [],
      connect: [],
      disconnect: [],
      display_uri: [],
      message: []
    }
  }
  on(e, n) {
    this.listeners[e].push(n)
  }
  removeListener(e, n) {
    e in this.listeners && (this.listeners[e] = this.listeners[e].filter(r => r !== n))
  }
  emit(e, n) {
    e in this.listeners && this.listeners[e].forEach(r => r(n))
  }
}
class Jx extends xp {
  constructor({ provider: e, chains: n, getActiveChain: r }) {
    super({ provider: e, caipNetworks: n, namespace: 'bip122' }),
      (this.eventEmitter = new sy()),
      (this.emit = this.eventEmitter.emit.bind(this.eventEmitter)),
      (this.on = this.eventEmitter.on.bind(this.eventEmitter)),
      (this.removeListener = this.eventEmitter.removeListener.bind(this.eventEmitter)),
      (this.getActiveChain = r)
  }
  get chains() {
    return this.sessionChains
      .map(e => this.caipNetworks.find(n => n.caipNetworkId === e))
      .filter(Boolean)
  }
  async connect() {
    return Promise.reject(
      new Error('Connection of WalletConnectProvider should be done via UniversalAdapter')
    )
  }
  async signMessage({ message: e, address: n, protocol: r }) {
    this.checkIfMethodIsSupported('signMessage')
    const s = await this.internalRequest({
      method: 'signMessage',
      params: { message: e, account: n, address: n, protocol: r }
    })
    return Buffer.from(s.signature, 'hex').toString('base64')
  }
  async sendTransfer({ recipient: e, amount: n }) {
    this.checkIfMethodIsSupported('sendTransfer')
    const r = this.getAccount(!0)
    return (
      await this.internalRequest({
        method: 'sendTransfer',
        params: { account: r, recipientAddress: e, amount: n }
      })
    ).txid
  }
  async getAccountAddresses() {
    return (
      this.checkIfMethodIsSupported('getAccountAddresses'),
      (await this.internalRequest({ method: 'getAccountAddresses', params: void 0 })).map(n => ({
        address: n,
        purpose: Zo.Payment
      }))
    )
  }
  async signPSBT(e) {
    this.checkIfMethodIsSupported('signPsbt')
    const n = this.getAccount(!0),
      r = await this.internalRequest({
        method: 'signPsbt',
        params: { account: n, psbt: e.psbt, signInputs: e.signInputs, broadcast: e.broadcast }
      })
    return { psbt: r.psbt, txid: r.txid }
  }
  async switchNetwork(e) {
    return Promise.resolve()
  }
  request(e) {
    return this.internalRequest(e)
  }
  get sessionChains() {
    var e
    return Od.getChainsFromNamespaces((e = this.provider.session) == null ? void 0 : e.namespaces)
  }
  getAccount(e) {
    var s, i
    const n =
      (i = (s = this.provider.session) == null ? void 0 : s.namespaces.bip122) == null
        ? void 0
        : i.accounts[0]
    if (!n) {
      if (e) throw new Error('Account not found')
      return
    }
    const r = n.split(':')[2]
    if (!r) {
      if (e) throw new Error('Address not found')
      return
    }
    return r
  }
  checkIfMethodIsSupported(e) {
    var n, r
    if (
      !(
        (r = (n = this.provider.session) == null ? void 0 : n.namespaces.bip122) != null &&
        r.methods.includes(e)
      )
    )
      throw new Error(`Method ${e} is not supported`)
  }
  async internalRequest({ method: e, params: n }) {
    const r = this.getActiveChain()
    if (!r) throw new Error('Chain not found')
    return await this.provider.request({ method: e, params: n }, r.caipNetworkId)
  }
}
function ole(t) {
  switch (t) {
    case 'bip122:000000000019d6689c085ae165831e93':
      return ho.Mainnet
    case 'bip122:000000000933ea01ad0ee984209779ba':
      return ho.Signet
    default:
      throw new Error(`Network ${t} not supported by Xverse wallet`)
  }
}
function ale(t) {
  switch (t) {
    case ho.Mainnet:
      return 'bip122:000000000019d6689c085ae165831e93'
    case ho.Signet:
      return 'bip122:000000000933ea01ad0ee984209779ba'
    default:
      throw new Error(`Network ${t} not supported by Xverse wallet`)
  }
}
class iy extends sy {
  constructor({ provider: e, requestedChains: n, getActiveNetwork: r }) {
    super(),
      (this.chain = 'bip122'),
      (this.type = 'ANNOUNCED'),
      (this.requestedChains = []),
      (this.walletUnsubscribes = []),
      (this.wallet = e),
      (this.requestedChains = n),
      (this.provider = this),
      (this.getActiveNetwork = r)
  }
  get id() {
    return this.name
  }
  get name() {
    return this.wallet.name
  }
  get explorerId() {
    return Vr.ConnectorExplorerIds[this.wallet.name]
  }
  get imageUrl() {
    return this.wallet.icon
  }
  get chains() {
    return this.requestedChains.filter(e => e.chainNamespace === 'bip122')
  }
  async request(e) {
    return this.internalRequest(e.method, e.params)
  }
  async connect() {
    const e = await this.getAccountAddresses()
      .then(n => {
        var r
        return (r = n[0]) == null ? void 0 : r.address
      })
      .catch(() =>
        this.internalRequest('wallet_connect', null).then(n => {
          var r
          return (r =
            n == null
              ? void 0
              : n.addresses
                  .map(s => ({ ...s, purpose: Yx(s.purpose) }))
                  .find(s => s.purpose === Zo.Payment)) == null
            ? void 0
            : r.address
        })
      )
    if (!e) throw new Error('No address available')
    return this.bindEvents(), this.emit('accountsChanged', [e]), e
  }
  async disconnect() {
    await this.internalRequest('wallet_disconnect', null), this.unbindEvents()
  }
  async getAccountAddresses() {
    const e = await this.internalRequest('getAddresses', {
      purposes: [ki.Payment, ki.Ordinals, ki.Stacks],
      message: 'Connect to your wallet'
    })
    if (e.addresses.length === 0) throw new Error('No address available')
    return e.addresses.map(n => ({ ...n, purpose: Yx(n.purpose) }))
  }
  static getWallets({ requestedChains: e, getActiveNetwork: n }) {
    return dt.isClient()
      ? qce().map(s => new iy({ provider: s, requestedChains: e, getActiveNetwork: n }))
      : []
  }
  async signMessage(e) {
    var s
    const n = (s = e.protocol) == null ? void 0 : s.toUpperCase()
    return (await this.internalRequest('signMessage', { ...e, protocol: n })).signature
  }
  async signPSBT(e) {
    const n = e.signInputs.reduce((s, i) => {
      const o = s[i.address] || []
      return o.push(i.index), { ...s, [i.address]: o }
    }, {})
    return await this.internalRequest('signPsbt', {
      psbt: e.psbt,
      broadcast: e.broadcast,
      signInputs: n
    })
  }
  async switchNetwork(e) {
    const n = ole(e)
    await this.internalRequest('wallet_changeNetwork', { name: n })
  }
  async sendTransfer({ amount: e, recipient: n }) {
    const r = Number(e)
    if (isNaN(r)) throw new Error('Invalid amount')
    return (await this.internalRequest('sendTransfer', { recipients: [{ address: n, amount: r }] }))
      .txid
  }
  getWalletProvider() {
    return zce(this.wallet.id)
  }
  async internalRequest(e, n) {
    const r = await this.getWalletProvider()
      .request(e, n)
      .catch(s => {
        if ('jsonrpc' in s && 'error' in s) return s
        throw s
      })
    if ('result' in r) return r.result
    throw { ...r.error, name: 'RPCError' }
  }
  bindEvents() {
    this.unbindEvents()
    const e = this.getWalletProvider()
    if (typeof e.addListener != 'function') {
      console.warn(
        `SatsConnectConnector:bindEvents - wallet provider "${this.name}" does not support events`
      )
      return
    }
    this.walletUnsubscribes.push(
      e.addListener('accountChange', async n => {
        const r = await this.connect()
        this.emit('accountsChanged', [r])
      }),
      e.addListener('disconnect', n => {
        this.emit('disconnect')
      }),
      e.addListener('networkChange', n => {
        const r = ale(n.stacks.name)
        this.emit('chainChanged', r)
      })
    )
  }
  unbindEvents() {
    this.walletUnsubscribes.forEach(e => e()), (this.walletUnsubscribes = [])
  }
}
class Hf extends iy {
  constructor({ connector: e }) {
    if (e.wallet.id !== Hf.ProviderId)
      throw new Error('LeatherConnector: wallet must be a LeatherProvider')
    super({
      provider: e.wallet,
      requestedChains: e.requestedChains,
      getActiveNetwork: e.getActiveNetwork
    })
  }
  get imageUrl() {
    var e, n
    return (n = (e = this.wallet) == null ? void 0 : e.icon) == null
      ? void 0
      : n.replace('data:image/svg', 'data:image/svg+xml')
  }
  async getAccountAddresses() {
    return this.connectedAccounts
      ? this.connectedAccounts
      : ((this.connectedAccounts = await super.getAccountAddresses()), this.connectedAccounts)
  }
  disconnect() {
    return (this.connectedAccounts = void 0), Promise.resolve()
  }
  async sendTransfer({ amount: e, recipient: n }) {
    const r = { address: n, amount: e }
    return (await this.internalRequest('sendTransfer', r)).txid
  }
  async signPSBT({ psbt: e, broadcast: n = !1 }) {
    const r = {
        hex: Buffer.from(e, 'base64').toString('hex'),
        network: this.getNetwork(),
        broadcast: n
      },
      s = await this.internalRequest('signPsbt', r)
    return { psbt: Buffer.from(s.hex, 'hex').toString('base64'), txid: s.txid }
  }
  getNetwork() {
    const e = this.getActiveNetwork()
    switch (e == null ? void 0 : e.caipNetworkId) {
      case Ip.caipNetworkId:
        return 'mainnet'
      case Z0.caipNetworkId:
        return 'testnet'
      default:
        throw new Error('LeatherConnector: unsupported network')
    }
  }
}
Hf.ProviderId = 'LeatherProvider'
class Eh extends Error {
  constructor(e, n, r) {
    super('Wallet call is not supported'),
      (this.name = 'MethodNotSupported'),
      (this.method = n),
      (this.walletId = e),
      console.error(
        `BitcoinAdapter:MethodNotSupportedError:${e} - The connected wallet doesn't support the method "${n}".${r ? ` ${r}` : ''}`
      )
  }
}
const Y8 = {
  parseSatoshis(t, e) {
    const n = parseFloat(t) / 10 ** e.nativeCurrency.decimals
    return Intl.NumberFormat('en-US', { maximumFractionDigits: e.nativeCurrency.decimals }).format(
      n
    )
  }
}
class ZA extends sy {
  constructor({ wallet: e, requestedChains: n, getActiveNetwork: r, imageUrl: s }) {
    super(),
      (this.id = 'OKX'),
      (this.name = 'OKX Wallet'),
      (this.chain = 'bip122'),
      (this.type = 'ANNOUNCED'),
      (this.explorerId = Vr.ConnectorExplorerIds[Ae.CONNECTOR_ID.OKX]),
      (this.provider = this),
      (this.requestedChains = []),
      (this.wallet = e),
      (this.requestedChains = n),
      (this.getActiveNetwork = r),
      (this.imageUrl = s)
  }
  get chains() {
    return this.requestedChains.filter(e => e.caipNetworkId === Ip.caipNetworkId)
  }
  async connect() {
    const e = await this.wallet.connect()
    return this.bindEvents(), e.address
  }
  async disconnect() {
    this.unbindEvents(), await this.wallet.disconnect()
  }
  async getAccountAddresses() {
    const e = await this.wallet.getAccounts(),
      n = await this.wallet.getPublicKey()
    return e.map(s => ({ address: s, purpose: Zo.Payment, publicKey: n }))
  }
  async signMessage(e) {
    const n = e.protocol === 'bip322' ? 'bip322-simple' : e.protocol
    return this.wallet.signMessage(e.message, n)
  }
  async sendTransfer(e) {
    const n = this.getActiveNetwork()
    if (!n) throw new Error('No active network available')
    const r = (await this.wallet.getAccounts())[0]
    if (!r) throw new Error('No account available')
    return (
      await this.wallet.send({ from: r, to: e.recipient, value: Y8.parseSatoshis(e.amount, n) })
    ).txhash
  }
  async signPSBT(e) {
    const n = Buffer.from(e.psbt, 'base64').toString('hex'),
      r = await this.wallet.signPsbt(n)
    let s
    return (
      e.broadcast && (s = await this.wallet.pushPsbt(r)),
      { psbt: Buffer.from(r, 'hex').toString('base64'), txid: s }
    )
  }
  async switchNetwork(e) {
    throw new Error(`${this.name} wallet does not support network switching`)
  }
  request(e) {
    return Promise.reject(new Eh(this.id, 'request'))
  }
  bindEvents() {
    this.unbindEvents(),
      this.wallet.on('accountChanged', e => {
        typeof e == 'object' && e && 'address' in e && this.emit('accountsChanged', [e.address])
      }),
      this.wallet.on('disconnect', () => {
        this.emit('disconnect')
      })
  }
  unbindEvents() {
    this.wallet.removeAllListeners()
  }
  static getWallet(e) {
    var i
    if (!dt.isClient()) return
    const n = window == null ? void 0 : window.okxwallet,
      r = n == null ? void 0 : n.bitcoin,
      s = ((i = n == null ? void 0 : n.cardano) == null ? void 0 : i.icon) || ''
    if (r) return new ZA({ wallet: r, imageUrl: s, ...e })
  }
  async getPublicKey() {
    return this.wallet.getPublicKey()
  }
}
var cle = function (t, e, n, r) {
    if (n === 'a' && !r) throw new TypeError('Private accessor was defined without a getter')
    if (typeof e == 'function' ? t !== e || !r : !e.has(t))
      throw new TypeError(
        'Cannot read private member from an object whose class did not declare it'
      )
    return n === 'm' ? r : n === 'a' ? r.call(t) : r ? r.value : e.get(t)
  },
  ule = function (t, e, n, r, s) {
    if (r === 'm') throw new TypeError('Private method is not writable')
    if (r === 'a' && !s) throw new TypeError('Private accessor was defined without a setter')
    if (typeof e == 'function' ? t !== e || !s : !e.has(t))
      throw new TypeError('Cannot write private member to an object whose class did not declare it')
    return r === 'a' ? s.call(t, n) : s ? (s.value = n) : e.set(t, n), n
  },
  qg
let lh
const oy = new Set()
function lle(t) {
  ;(Fh = void 0), oy.add(t)
}
function dle(t) {
  ;(Fh = void 0), oy.delete(t)
}
const bl = {}
function J8() {
  if (lh || ((lh = Object.freeze({ register: Xx, get: hle, on: fle })), typeof window > 'u'))
    return lh
  const t = Object.freeze({ register: Xx })
  try {
    window.addEventListener('wallet-standard:register-wallet', ({ detail: e }) => e(t))
  } catch (e) {
    console.error(
      `wallet-standard:register-wallet event listener could not be added
`,
      e
    )
  }
  try {
    window.dispatchEvent(new ple(t))
  } catch (e) {
    console.error(
      `wallet-standard:app-ready event could not be dispatched
`,
      e
    )
  }
  return lh
}
function Xx(...t) {
  var e
  return (
    (t = t.filter(n => !oy.has(n))),
    t.length
      ? (t.forEach(n => lle(n)),
        (e = bl.register) == null || e.forEach(n => eT(() => n(...t))),
        function () {
          var r
          t.forEach(s => dle(s)), (r = bl.unregister) == null || r.forEach(s => eT(() => s(...t)))
        })
      : () => {}
  )
}
let Fh
function hle() {
  return Fh || (Fh = [...oy]), Fh
}
function fle(t, e) {
  var n
  return (
    ((n = bl[t]) != null && n.push(e)) || (bl[t] = [e]),
    function () {
      var s
      bl[t] = (s = bl[t]) == null ? void 0 : s.filter(i => e !== i)
    }
  )
}
function eT(t) {
  try {
    t()
  } catch (e) {
    console.error(e)
  }
}
class ple extends Event {
  get detail() {
    return cle(this, qg, 'f')
  }
  get type() {
    return 'wallet-standard:app-ready'
  }
  constructor(e) {
    super('wallet-standard:app-ready', { bubbles: !1, cancelable: !1, composed: !1 }),
      qg.set(this, void 0),
      ule(this, qg, e, 'f')
  }
  preventDefault() {
    throw new Error('preventDefault cannot be called')
  }
  stopImmediatePropagation() {
    throw new Error('stopImmediatePropagation cannot be called')
  }
  stopPropagation() {
    throw new Error('stopPropagation cannot be called')
  }
}
qg = new WeakMap()
class YA extends sy {
  constructor({ wallet: e, requestedChains: n }) {
    super(),
      (this.chain = 'bip122'),
      (this.type = 'ANNOUNCED'),
      (this.requestedChains = []),
      (this.walletUnsubscribes = []),
      (this.provider = this),
      (this.wallet = e),
      (this.requestedChains = n),
      (this.provider = this)
  }
  get id() {
    return this.name
  }
  get name() {
    return this.wallet.name
  }
  get imageUrl() {
    return this.wallet.icon
  }
  get explorerId() {
    return Vr.ConnectorExplorerIds[this.name]
  }
  get chains() {
    return this.wallet.chains
      .map(e =>
        this.requestedChains.find(n => {
          switch (e) {
            case 'bitcoin:mainnet':
              return n.caipNetworkId === Ip.caipNetworkId
            case 'bitcoin:testnet':
              return n.caipNetworkId === Z0.caipNetworkId
            default:
              return n.caipNetworkId === e
          }
        })
      )
      .filter(Boolean)
  }
  async connect() {
    const e = this.getWalletFeature('bitcoin:connect')
    this.bindEvents()
    const r = (await e.connect({ purposes: ['payment', 'ordinals'] })).accounts[0]
    if (!r) throw new Error('No account found')
    return r.address
  }
  async getAccountAddresses() {
    const e = new Set(),
      n = this.wallet.accounts
        .map(r => ({
          address: r.address,
          purpose: Zo.Payment,
          publicKey: Buffer.from(r.publicKey).toString('hex')
        }))
        .filter(r => (e.has(r.address) ? !1 : (e.add(r.address), !0)))
    return Promise.resolve(n)
  }
  async signMessage(e) {
    e.protocol &&
      console.warn(
        'WalletStandardConnector:signMessage - protocol parameter not supported in WalletStandard:bitcoin - signMessage'
      )
    const n = this.getWalletFeature('bitcoin:signMessage'),
      r = this.wallet.accounts.find(o => o.address === e.address)
    if (!r) throw new Error('Account not found')
    const s = new TextEncoder().encode(e.message),
      i = (await n.signMessage({ account: r, message: s }))[0]
    if (!i) throw new Error('No response from wallet')
    return Buffer.from(i.signature).toString('base64')
  }
  async signPSBT(e) {
    const n = this.getWalletFeature('bitcoin:signTransaction')
    if (e.broadcast)
      throw new Eh(
        this.id,
        'signPSBT',
        'This wallet does not support broadcasting, please broadcast it manually or contact the development team.'
      )
    const r = e.signInputs.map(i => {
        const o = this.wallet.accounts.find(a => a.address === i.address)
        if (!o) throw new Error(`Account with address ${i.address} not found`)
        return { account: o, signingIndexes: [i.index], sigHash: void 0 }
      }),
      s = (
        await n.signTransaction({
          psbt: new Uint8Array(Buffer.from(e.psbt, 'base64')),
          inputsToSign: r
        })
      )[0]
    if (!s) throw new Error('No response from wallet')
    return { psbt: Buffer.from(s.signedPsbt).toString('base64'), txid: void 0 }
  }
  async sendTransfer(e) {
    return Promise.reject(
      new Eh(
        this.id,
        'sendTransfer',
        'Please use "signPSBT" instead and broadcast the transaction manually.'
      )
    )
  }
  async disconnect() {
    return this.unbindEvents(), Promise.resolve()
  }
  async request(e) {
    return Promise.reject(new Eh(this.id, 'request'))
  }
  getWalletFeature(e) {
    if (!(e in this.wallet.features)) throw new Eh(this.id, e)
    return this.wallet.features[e]
  }
  bindEvents() {
    this.unbindEvents()
    try {
      const e = this.getWalletFeature('standard:events')
      this.walletUnsubscribes.push(
        e.on('change', n => {
          'accounts' in n &&
            n.accounts &&
            (n.accounts.length === 0
              ? this.emit('disconnect')
              : this.emit(
                  'accountsChanged',
                  n.accounts.map(r => r.address)
                ))
        })
      )
    } catch {
      console.warn(
        `WalletStandardConnector:bindEvents - wallet provider "${this.name}" does not support events`
      )
    }
  }
  unbindEvents() {
    this.walletUnsubscribes.forEach(e => e()), (this.walletUnsubscribes = [])
  }
  static watchWallets({ callback: e, requestedChains: n }) {
    const { get: r, on: s } = J8()
    function i(o) {
      return o
        .filter(a => 'bitcoin:connect' in a.features)
        .map(a => new YA({ wallet: a, requestedChains: n }))
    }
    return e(...i(r())), s('register', (...o) => e(...i(o)))
  }
  async switchNetwork(e) {
    throw new Error(`${this.name} wallet does not support network switching`)
  }
}
const gle = {
  getUTXOs: async ({ network: t, address: e }) => {
    const n = t.caipNetworkId === Z0.caipNetworkId,
      r = await fetch(`https://mempool.space${n ? '/testnet' : ''}/api/address/${e}/utxo`)
    if (!r.ok) throw new Error(`Failed to fetch UTXOs: ${await r.text()}`)
    return await r.json()
  }
}
class mle extends Y0 {
  constructor({ api: e = {}, ...n } = {}) {
    super({ namespace: Ae.CHAIN.BITCOIN, adapterType: Ae.ADAPTER_TYPES.BITCOIN, ...n }),
      (this.eventsToUnbind = []),
      (this.balancePromises = {}),
      (this.api = { ...gle, ...e })
  }
  async connect(e) {
    const n = this.connectors.find(i => i.id === e.id)
    if (!n) throw new Error('connectionControllerClient:connectExternal - connector is undefined')
    ;(this.connector = n), this.bindEvents(this.connector)
    const r = await n.connect(),
      s = n.chains.find(i => i.id === e.chainId) || n.chains[0]
    if (!s) throw new Error('The connector does not support any of the requested chains')
    return { id: n.id, type: n.type, address: r, chainId: s.id, provider: n.provider }
  }
  async getAccounts(e) {
    var s
    const n = await ((s = this.connectors.find(i => i.id === e.id)) == null
      ? void 0
      : s.getAccountAddresses().catch(() => []))
    return {
      accounts:
        (n == null
          ? void 0
          : n.map(i =>
              dt.createAccount(
                Ae.CHAIN.BITCOIN,
                i.address,
                i.purpose || 'payment',
                i.publicKey,
                i.path
              )
            )) || []
    }
  }
  syncConnectors(e, n) {
    function r() {
      return n == null ? void 0 : n.getCaipNetwork()
    }
    YA.watchWallets({ callback: this.addConnector.bind(this), requestedChains: this.networks }),
      this.addConnector(
        ...iy.getWallets({ requestedChains: this.networks, getActiveNetwork: r }).map(i => {
          switch (i.wallet.id) {
            case Hf.ProviderId:
              return new Hf({ connector: i })
            default:
              return i
          }
        })
      )
    const s = ZA.getWallet({ requestedChains: this.networks, getActiveNetwork: r })
    s && this.addConnector(s)
  }
  syncConnection(e) {
    return this.connect({ id: e.id, chainId: e.chainId, type: '' })
  }
  async signMessage(e) {
    const n = e.provider
    if (!n) throw new Error('BitcoinAdapter:signMessage - connector is undefined')
    return { signature: await n.signMessage({ message: e.message, address: e.address }) }
  }
  getWalletConnectProvider(e) {
    return new Jx({
      provider: e.provider,
      chains: e.caipNetworks,
      getActiveChain: () => ne.getCaipNetworkByNamespace(this.namespace)
    })
  }
  async disconnect(e) {
    e != null && e.provider
      ? await e.provider.disconnect()
      : this.connector && (await this.connector.disconnect()),
      this.unbindEvents()
  }
  async getBalance(e) {
    const n = e.caipNetwork,
      r = e.address
    if (!r) return Promise.resolve({ balance: '0.00', symbol: 'BTC' })
    if (n && n.chainNamespace === this.namespace) {
      const s = `${n == null ? void 0 : n.caipNetworkId}:${r}`,
        i = this.balancePromises[s]
      if (i) return i
      const o = Ke.getNativeBalanceCacheForCaipAddress(s)
      return o
        ? { balance: o.balance, symbol: o.symbol }
        : ((this.balancePromises[s] = new Promise(async a => {
            const u = (await this.api.getUTXOs({ network: n, address: r })).reduce(
                (d, h) => d + h.value,
                0
              ),
              l = Y8.parseSatoshis(u.toString(), n)
            Ke.updateNativeBalanceCache({
              caipAddress: s,
              balance: l,
              symbol: n.nativeCurrency.symbol,
              timestamp: Date.now()
            }),
              a({ balance: l, symbol: n.nativeCurrency.symbol })
          }).finally(() => {
            delete this.balancePromises[s]
          })),
          this.balancePromises[s] || Promise.resolve({ balance: '0.00', symbol: 'BTC' }))
    }
    return Promise.resolve({ balance: '0', symbol: Ip.nativeCurrency.symbol })
  }
  async switchNetwork(e) {
    if (e.providerType === 'WALLET_CONNECT' || e.providerType === 'AUTH')
      return await super.switchNetwork(e)
    const n = e.provider
    if (!n) throw new Error('BitcoinAdapter:switchNetwork - provider is undefined')
    return await n.switchNetwork(e.caipNetwork.caipNetworkId)
  }
  getProfile(e) {
    return Promise.resolve({})
  }
  estimateGas(e) {
    return Promise.resolve({})
  }
  sendTransaction(e) {
    return Promise.resolve({})
  }
  writeContract(e) {
    return Promise.resolve({})
  }
  getEnsAddress(e) {
    return Promise.resolve({})
  }
  parseUnits(e) {
    return BigInt(0)
  }
  formatUnits(e) {
    return ''
  }
  grantPermissions(e) {
    return Promise.resolve({})
  }
  getCapabilities(e) {
    return Promise.resolve({})
  }
  revokePermissions(e) {
    return Promise.resolve('0x')
  }
  async walletGetAssets(e) {
    return Promise.resolve({})
  }
  bindEvents(e) {
    this.unbindEvents()
    const n = i => {
      const [o] = i
      o && this.emit('accountChanged', { address: o })
    }
    e.on('accountsChanged', n),
      this.eventsToUnbind.push(() => e.removeListener('accountsChanged', n))
    const r = async i => {
      const o = await this.connect({ id: e.id, chainId: i, type: '' })
      this.emit('switchNetwork', { chainId: i, address: o.address })
    }
    e.on('chainChanged', r), this.eventsToUnbind.push(() => e.removeListener('chainChanged', r))
    const s = () => {
      this.emit('disconnect')
    }
    e.on('disconnect', s), this.eventsToUnbind.push(() => e.removeListener('disconnect', s))
  }
  unbindEvents() {
    this.eventsToUnbind.forEach(e => e()), (this.eventsToUnbind = [])
  }
  setUniversalProvider(e) {
    this.addConnector(
      new Jx({
        provider: e,
        chains: this.getCaipNetworks(),
        getActiveChain: () => ne.getCaipNetworkByNamespace(this.namespace)
      })
    )
  }
}
const [yle, wle] = kt.split(
    [
      '0x428a2f98d728ae22',
      '0x7137449123ef65cd',
      '0xb5c0fbcfec4d3b2f',
      '0xe9b5dba58189dbbc',
      '0x3956c25bf348b538',
      '0x59f111f1b605d019',
      '0x923f82a4af194f9b',
      '0xab1c5ed5da6d8118',
      '0xd807aa98a3030242',
      '0x12835b0145706fbe',
      '0x243185be4ee4b28c',
      '0x550c7dc3d5ffb4e2',
      '0x72be5d74f27b896f',
      '0x80deb1fe3b1696b1',
      '0x9bdc06a725c71235',
      '0xc19bf174cf692694',
      '0xe49b69c19ef14ad2',
      '0xefbe4786384f25e3',
      '0x0fc19dc68b8cd5b5',
      '0x240ca1cc77ac9c65',
      '0x2de92c6f592b0275',
      '0x4a7484aa6ea6e483',
      '0x5cb0a9dcbd41fbd4',
      '0x76f988da831153b5',
      '0x983e5152ee66dfab',
      '0xa831c66d2db43210',
      '0xb00327c898fb213f',
      '0xbf597fc7beef0ee4',
      '0xc6e00bf33da88fc2',
      '0xd5a79147930aa725',
      '0x06ca6351e003826f',
      '0x142929670a0e6e70',
      '0x27b70a8546d22ffc',
      '0x2e1b21385c26c926',
      '0x4d2c6dfc5ac42aed',
      '0x53380d139d95b3df',
      '0x650a73548baf63de',
      '0x766a0abb3c77b2a8',
      '0x81c2c92e47edaee6',
      '0x92722c851482353b',
      '0xa2bfe8a14cf10364',
      '0xa81a664bbc423001',
      '0xc24b8b70d0f89791',
      '0xc76c51a30654be30',
      '0xd192e819d6ef5218',
      '0xd69906245565a910',
      '0xf40e35855771202a',
      '0x106aa07032bbd1b8',
      '0x19a4c116b8d2d0c8',
      '0x1e376c085141ab53',
      '0x2748774cdf8eeb99',
      '0x34b0bcb5e19b48a8',
      '0x391c0cb3c5c95a63',
      '0x4ed8aa4ae3418acb',
      '0x5b9cca4f7763e373',
      '0x682e6ff3d6b2b8a3',
      '0x748f82ee5defb2fc',
      '0x78a5636f43172f60',
      '0x84c87814a1f0ab72',
      '0x8cc702081a6439ec',
      '0x90befffa23631e28',
      '0xa4506cebde82bde9',
      '0xbef9a3f7b2c67915',
      '0xc67178f2e372532b',
      '0xca273eceea26619c',
      '0xd186b8c721c0c207',
      '0xeada7dd6cde0eb1e',
      '0xf57d4f7fee6ed178',
      '0x06f067aa72176fba',
      '0x0a637dc5a2c898a6',
      '0x113f9804bef90dae',
      '0x1b710b35131c471b',
      '0x28db77f523047d84',
      '0x32caab7b40c72493',
      '0x3c9ebe0a15c9bebc',
      '0x431d67c49c100d4c',
      '0x4cc5d4becb3e42b6',
      '0x597f299cfc657e2a',
      '0x5fcb6fab3ad6faec',
      '0x6c44198c4a475817'
    ].map(t => BigInt(t))
  ),
  pa = new Uint32Array(80),
  ga = new Uint32Array(80)
class ble extends WR {
  constructor() {
    super(128, 64, 16, !1),
      (this.Ah = 1779033703),
      (this.Al = -205731576),
      (this.Bh = -1150833019),
      (this.Bl = -2067093701),
      (this.Ch = 1013904242),
      (this.Cl = -23791573),
      (this.Dh = -1521486534),
      (this.Dl = 1595750129),
      (this.Eh = 1359893119),
      (this.El = -1377402159),
      (this.Fh = -1694144372),
      (this.Fl = 725511199),
      (this.Gh = 528734635),
      (this.Gl = -79577749),
      (this.Hh = 1541459225),
      (this.Hl = 327033209)
  }
  get() {
    const {
      Ah: e,
      Al: n,
      Bh: r,
      Bl: s,
      Ch: i,
      Cl: o,
      Dh: a,
      Dl: c,
      Eh: u,
      El: l,
      Fh: d,
      Fl: h,
      Gh: p,
      Gl: y,
      Hh: m,
      Hl: b
    } = this
    return [e, n, r, s, i, o, a, c, u, l, d, h, p, y, m, b]
  }
  set(e, n, r, s, i, o, a, c, u, l, d, h, p, y, m, b) {
    ;(this.Ah = e | 0),
      (this.Al = n | 0),
      (this.Bh = r | 0),
      (this.Bl = s | 0),
      (this.Ch = i | 0),
      (this.Cl = o | 0),
      (this.Dh = a | 0),
      (this.Dl = c | 0),
      (this.Eh = u | 0),
      (this.El = l | 0),
      (this.Fh = d | 0),
      (this.Fl = h | 0),
      (this.Gh = p | 0),
      (this.Gl = y | 0),
      (this.Hh = m | 0),
      (this.Hl = b | 0)
  }
  process(e, n) {
    for (let _ = 0; _ < 16; _++, n += 4) (pa[_] = e.getUint32(n)), (ga[_] = e.getUint32((n += 4)))
    for (let _ = 16; _ < 80; _++) {
      const R = pa[_ - 15] | 0,
        N = ga[_ - 15] | 0,
        T = kt.rotrSH(R, N, 1) ^ kt.rotrSH(R, N, 8) ^ kt.shrSH(R, N, 7),
        M = kt.rotrSL(R, N, 1) ^ kt.rotrSL(R, N, 8) ^ kt.shrSL(R, N, 7),
        H = pa[_ - 2] | 0,
        B = ga[_ - 2] | 0,
        $ = kt.rotrSH(H, B, 19) ^ kt.rotrBH(H, B, 61) ^ kt.shrSH(H, B, 6),
        D = kt.rotrSL(H, B, 19) ^ kt.rotrBL(H, B, 61) ^ kt.shrSL(H, B, 6),
        W = kt.add4L(M, D, ga[_ - 7], ga[_ - 16]),
        U = kt.add4H(W, T, $, pa[_ - 7], pa[_ - 16])
      ;(pa[_] = U | 0), (ga[_] = W | 0)
    }
    let {
      Ah: r,
      Al: s,
      Bh: i,
      Bl: o,
      Ch: a,
      Cl: c,
      Dh: u,
      Dl: l,
      Eh: d,
      El: h,
      Fh: p,
      Fl: y,
      Gh: m,
      Gl: b,
      Hh: I,
      Hl: x
    } = this
    for (let _ = 0; _ < 80; _++) {
      const R = kt.rotrSH(d, h, 14) ^ kt.rotrSH(d, h, 18) ^ kt.rotrBH(d, h, 41),
        N = kt.rotrSL(d, h, 14) ^ kt.rotrSL(d, h, 18) ^ kt.rotrBL(d, h, 41),
        T = (d & p) ^ (~d & m),
        M = (h & y) ^ (~h & b),
        H = kt.add5L(x, N, M, wle[_], ga[_]),
        B = kt.add5H(H, I, R, T, yle[_], pa[_]),
        $ = H | 0,
        D = kt.rotrSH(r, s, 28) ^ kt.rotrBH(r, s, 34) ^ kt.rotrBH(r, s, 39),
        W = kt.rotrSL(r, s, 28) ^ kt.rotrBL(r, s, 34) ^ kt.rotrBL(r, s, 39),
        U = (r & i) ^ (r & a) ^ (i & a),
        w = (s & o) ^ (s & c) ^ (o & c)
      ;(I = m | 0),
        (x = b | 0),
        (m = p | 0),
        (b = y | 0),
        (p = d | 0),
        (y = h | 0),
        ({ h: d, l: h } = kt.add(u | 0, l | 0, B | 0, $ | 0)),
        (u = a | 0),
        (l = c | 0),
        (a = i | 0),
        (c = o | 0),
        (i = r | 0),
        (o = s | 0)
      const v = kt.add3L($, W, w)
      ;(r = kt.add3H(v, B, D, U)), (s = v | 0)
    }
    ;({ h: r, l: s } = kt.add(this.Ah | 0, this.Al | 0, r | 0, s | 0)),
      ({ h: i, l: o } = kt.add(this.Bh | 0, this.Bl | 0, i | 0, o | 0)),
      ({ h: a, l: c } = kt.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0)),
      ({ h: u, l } = kt.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0)),
      ({ h: d, l: h } = kt.add(this.Eh | 0, this.El | 0, d | 0, h | 0)),
      ({ h: p, l: y } = kt.add(this.Fh | 0, this.Fl | 0, p | 0, y | 0)),
      ({ h: m, l: b } = kt.add(this.Gh | 0, this.Gl | 0, m | 0, b | 0)),
      ({ h: I, l: x } = kt.add(this.Hh | 0, this.Hl | 0, I | 0, x | 0)),
      this.set(r, s, i, o, a, c, u, l, d, h, p, y, m, b, I, x)
  }
  roundClean() {
    pa.fill(0), ga.fill(0)
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  }
}
const vle = ME(() => new ble())
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const yi = BigInt(0),
  ms = BigInt(1),
  wg = BigInt(2),
  Ele = BigInt(8),
  Ale = { zip215: !0 }
function _le(t) {
  const e = fA(t)
  return (
    _d(
      t,
      { hash: 'function', a: 'bigint', d: 'bigint', randomBytes: 'function' },
      {
        adjustScalarBytes: 'function',
        domain: 'function',
        uvRatio: 'function',
        mapToCurve: 'function'
      }
    ),
    Object.freeze({ ...e })
  )
}
function Cle(t) {
  const e = _le(t),
    { Fp: n, n: r, prehash: s, hash: i, randomBytes: o, nByteLength: a, h: c } = e,
    u = wg << (BigInt(a * 8) - ms),
    l = n.create,
    d = S0(e.n, e.nBitLength),
    h =
      e.uvRatio ||
      ((A, P) => {
        try {
          return { isValid: !0, value: n.sqrt(A * n.inv(P)) }
        } catch {
          return { isValid: !1, value: yi }
        }
      }),
    p = e.adjustScalarBytes || (A => A),
    y =
      e.domain ||
      ((A, P, O) => {
        if ((Ko('phflag', O), P.length || O)) throw new Error('Contexts/pre-hash are not supported')
        return A
      })
  function m(A, P) {
    si('coordinate ' + A, P, yi, u)
  }
  function b(A) {
    if (!(A instanceof _)) throw new Error('ExtendedPoint expected')
  }
  const I = pf((A, P) => {
      const { ex: O, ey: F, ez: z } = A,
        j = A.is0()
      P == null && (P = j ? Ele : n.inv(z))
      const E = l(O * P),
        C = l(F * P),
        L = l(z * P)
      if (j) return { x: yi, y: ms }
      if (L !== ms) throw new Error('invZ was invalid')
      return { x: E, y: C }
    }),
    x = pf(A => {
      const { a: P, d: O } = e
      if (A.is0()) throw new Error('bad point: ZERO')
      const { ex: F, ey: z, ez: j, et: E } = A,
        C = l(F * F),
        L = l(z * z),
        K = l(j * j),
        ee = l(K * K),
        oe = l(C * P),
        fe = l(K * l(oe + L)),
        ve = l(ee + l(O * l(C * L)))
      if (fe !== ve) throw new Error('bad point: equation left != right (1)')
      const tt = l(F * z),
        Ge = l(j * E)
      if (tt !== Ge) throw new Error('bad point: equation left != right (2)')
      return !0
    })
  class _ {
    constructor(P, O, F, z) {
      ;(this.ex = P),
        (this.ey = O),
        (this.ez = F),
        (this.et = z),
        m('x', P),
        m('y', O),
        m('z', F),
        m('t', z),
        Object.freeze(this)
    }
    get x() {
      return this.toAffine().x
    }
    get y() {
      return this.toAffine().y
    }
    static fromAffine(P) {
      if (P instanceof _) throw new Error('extended point not allowed')
      const { x: O, y: F } = P || {}
      return m('x', O), m('y', F), new _(O, F, ms, l(O * F))
    }
    static normalizeZ(P) {
      const O = n.invertBatch(P.map(F => F.ez))
      return P.map((F, z) => F.toAffine(O[z])).map(_.fromAffine)
    }
    static msm(P, O) {
      return H3(_, d, P, O)
    }
    _setWindowSize(P) {
      T.setWindowSize(this, P)
    }
    assertValidity() {
      x(this)
    }
    equals(P) {
      b(P)
      const { ex: O, ey: F, ez: z } = this,
        { ex: j, ey: E, ez: C } = P,
        L = l(O * C),
        K = l(j * z),
        ee = l(F * C),
        oe = l(E * z)
      return L === K && ee === oe
    }
    is0() {
      return this.equals(_.ZERO)
    }
    negate() {
      return new _(l(-this.ex), this.ey, this.ez, l(-this.et))
    }
    double() {
      const { a: P } = e,
        { ex: O, ey: F, ez: z } = this,
        j = l(O * O),
        E = l(F * F),
        C = l(wg * l(z * z)),
        L = l(P * j),
        K = O + F,
        ee = l(l(K * K) - j - E),
        oe = L + E,
        fe = oe - C,
        ve = L - E,
        tt = l(ee * fe),
        Ge = l(oe * ve),
        nt = l(ee * ve),
        Z = l(fe * oe)
      return new _(tt, Ge, Z, nt)
    }
    add(P) {
      b(P)
      const { a: O, d: F } = e,
        { ex: z, ey: j, ez: E, et: C } = this,
        { ex: L, ey: K, ez: ee, et: oe } = P
      if (O === BigInt(-1)) {
        const we = l((j - z) * (K + L)),
          ge = l((j + z) * (K - L)),
          he = l(ge - we)
        if (he === yi) return this.double()
        const Ne = l(E * wg * oe),
          _e = l(C * wg * ee),
          Be = _e + Ne,
          $e = ge + we,
          S = _e - Ne,
          f = l(Be * he),
          g = l($e * S),
          k = l(Be * S),
          q = l(he * $e)
        return new _(f, g, q, k)
      }
      const fe = l(z * L),
        ve = l(j * K),
        tt = l(C * F * oe),
        Ge = l(E * ee),
        nt = l((z + j) * (L + K) - fe - ve),
        Z = Ge - tt,
        X = Ge + tt,
        ie = l(ve - O * fe),
        be = l(nt * Z),
        ue = l(X * ie),
        de = l(nt * ie),
        Te = l(Z * X)
      return new _(be, ue, Te, de)
    }
    subtract(P) {
      return this.add(P.negate())
    }
    wNAF(P) {
      return T.wNAFCached(this, P, _.normalizeZ)
    }
    multiply(P) {
      const O = P
      si('scalar', O, ms, r)
      const { p: F, f: z } = this.wNAF(O)
      return _.normalizeZ([F, z])[0]
    }
    multiplyUnsafe(P, O = _.ZERO) {
      const F = P
      return (
        si('scalar', F, yi, r),
        F === yi ? N : this.is0() || F === ms ? this : T.wNAFCachedUnsafe(this, F, _.normalizeZ, O)
      )
    }
    isSmallOrder() {
      return this.multiplyUnsafe(c).is0()
    }
    isTorsionFree() {
      return T.unsafeLadder(this, r).is0()
    }
    toAffine(P) {
      return I(this, P)
    }
    clearCofactor() {
      const { h: P } = e
      return P === ms ? this : this.multiplyUnsafe(P)
    }
    static fromHex(P, O = !1) {
      const { d: F, a: z } = e,
        j = n.BYTES
      ;(P = Zn('pointHex', P, j)), Ko('zip215', O)
      const E = P.slice(),
        C = P[j - 1]
      E[j - 1] = C & -129
      const L = Pl(E),
        K = O ? u : n.ORDER
      si('pointHex.y', L, yi, K)
      const ee = l(L * L),
        oe = l(ee - ms),
        fe = l(F * ee - z)
      let { isValid: ve, value: tt } = h(oe, fe)
      if (!ve) throw new Error('Point.fromHex: invalid y coordinate')
      const Ge = (tt & ms) === ms,
        nt = (C & 128) !== 0
      if (!O && tt === yi && nt) throw new Error('Point.fromHex: x=0 and x_0=1')
      return nt !== Ge && (tt = l(-tt)), _.fromAffine({ x: tt, y: L })
    }
    static fromPrivateKey(P) {
      return B(P).point
    }
    toRawBytes() {
      const { x: P, y: O } = this.toAffine(),
        F = ff(O, n.BYTES)
      return (F[F.length - 1] |= P & ms ? 128 : 0), F
    }
    toHex() {
      return lu(this.toRawBytes())
    }
  }
  ;(_.BASE = new _(e.Gx, e.Gy, ms, l(e.Gx * e.Gy))), (_.ZERO = new _(yi, ms, ms, yi))
  const { BASE: R, ZERO: N } = _,
    T = j3(_, a * 8)
  function M(A) {
    return Nn(A, r)
  }
  function H(A) {
    return M(Pl(A))
  }
  function B(A) {
    const P = n.BYTES
    A = Zn('private key', A, P)
    const O = Zn('hashed private key', i(A), 2 * P),
      F = p(O.slice(0, P)),
      z = O.slice(P, 2 * P),
      j = H(F),
      E = R.multiply(j),
      C = E.toRawBytes()
    return { head: F, prefix: z, scalar: j, point: E, pointBytes: C }
  }
  function $(A) {
    return B(A).pointBytes
  }
  function D(A = new Uint8Array(), ...P) {
    const O = du(...P)
    return H(i(y(O, Zn('context', A), !!s)))
  }
  function W(A, P, O = {}) {
    ;(A = Zn('message', A)), s && (A = s(A))
    const { prefix: F, scalar: z, pointBytes: j } = B(P),
      E = D(O.context, F, A),
      C = R.multiply(E).toRawBytes(),
      L = D(O.context, C, j, A),
      K = M(E + L * z)
    si('signature.s', K, yi, r)
    const ee = du(C, ff(K, n.BYTES))
    return Zn('result', ee, n.BYTES * 2)
  }
  const U = Ale
  function w(A, P, O, F = U) {
    const { context: z, zip215: j } = F,
      E = n.BYTES
    ;(A = Zn('signature', A, 2 * E)),
      (P = Zn('message', P)),
      (O = Zn('publicKey', O, E)),
      j !== void 0 && Ko('zip215', j),
      s && (P = s(P))
    const C = Pl(A.slice(E, 2 * E))
    let L, K, ee
    try {
      ;(L = _.fromHex(O, j)), (K = _.fromHex(A.slice(0, E), j)), (ee = R.multiplyUnsafe(C))
    } catch {
      return !1
    }
    if (!j && L.isSmallOrder()) return !1
    const oe = D(z, K.toRawBytes(), L.toRawBytes(), P)
    return K.add(L.multiplyUnsafe(oe)).subtract(ee).clearCofactor().equals(_.ZERO)
  }
  return (
    R._setWindowSize(8),
    {
      CURVE: e,
      getPublicKey: $,
      sign: W,
      verify: w,
      ExtendedPoint: _,
      utils: {
        getExtendedPublicKey: B,
        randomPrivateKey: () => o(n.BYTES),
        precompute(A = 8, P = _.BASE) {
          return P._setWindowSize(A), P.multiply(BigInt(3)), P
        }
      }
    }
  )
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const JA = BigInt(
    '57896044618658097711785492504343953926634992332820282019728792003956564819949'
  ),
  tT = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752')
BigInt(0)
const Sle = BigInt(1),
  nT = BigInt(2)
BigInt(3)
const Ile = BigInt(5),
  xle = BigInt(8)
function Tle(t) {
  const e = BigInt(10),
    n = BigInt(20),
    r = BigInt(40),
    s = BigInt(80),
    i = JA,
    a = (((t * t) % i) * t) % i,
    c = (Fn(a, nT, i) * a) % i,
    u = (Fn(c, Sle, i) * t) % i,
    l = (Fn(u, Ile, i) * u) % i,
    d = (Fn(l, e, i) * l) % i,
    h = (Fn(d, n, i) * d) % i,
    p = (Fn(h, r, i) * h) % i,
    y = (Fn(p, s, i) * p) % i,
    m = (Fn(y, s, i) * p) % i,
    b = (Fn(m, e, i) * l) % i
  return { pow_p_5_8: (Fn(b, nT, i) * t) % i, b2: a }
}
function Nle(t) {
  return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t
}
function Ple(t, e) {
  const n = JA,
    r = Nn(e * e * e, n),
    s = Nn(r * r * e, n),
    i = Tle(t * s).pow_p_5_8
  let o = Nn(t * r * i, n)
  const a = Nn(e * o * o, n),
    c = o,
    u = Nn(o * tT, n),
    l = a === t,
    d = a === Nn(-t, n),
    h = a === Nn(-t * tT, n)
  return (
    l && (o = c), (d || h) && (o = u), lj(o, n) && (o = Nn(-o, n)), { isValid: l || d, value: o }
  )
}
const Rle = S0(JA, void 0, !0),
  kle = {
    a: BigInt(-1),
    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
    Fp: Rle,
    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),
    h: xle,
    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),
    hash: vle,
    randomBytes: vR,
    adjustScalarBytes: Nle,
    uvRatio: Ple
  },
  XA = Cle(kle)
var zg = { exports: {} },
  Ole = zg.exports,
  rT
function X8() {
  return (
    rT ||
      ((rT = 1),
      (function (t) {
        ;(function (e, n) {
          function r(U, w) {
            if (!U) throw new Error(w || 'Assertion failed')
          }
          function s(U, w) {
            U.super_ = w
            var v = function () {}
            ;(v.prototype = w.prototype), (U.prototype = new v()), (U.prototype.constructor = U)
          }
          function i(U, w, v) {
            if (i.isBN(U)) return U
            ;(this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              U !== null &&
                ((w === 'le' || w === 'be') && ((v = w), (w = 10)),
                this._init(U || 0, w || 10, v || 'be'))
          }
          typeof e == 'object' ? (e.exports = i) : (n.BN = i), (i.BN = i), (i.wordSize = 26)
          var o
          try {
            typeof window < 'u' && typeof window.Buffer < 'u'
              ? (o = window.Buffer)
              : (o = WA.Buffer)
          } catch {}
          ;(i.isBN = function (w) {
            return w instanceof i
              ? !0
              : w !== null &&
                  typeof w == 'object' &&
                  w.constructor.wordSize === i.wordSize &&
                  Array.isArray(w.words)
          }),
            (i.max = function (w, v) {
              return w.cmp(v) > 0 ? w : v
            }),
            (i.min = function (w, v) {
              return w.cmp(v) < 0 ? w : v
            }),
            (i.prototype._init = function (w, v, A) {
              if (typeof w == 'number') return this._initNumber(w, v, A)
              if (typeof w == 'object') return this._initArray(w, v, A)
              v === 'hex' && (v = 16),
                r(v === (v | 0) && v >= 2 && v <= 36),
                (w = w.toString().replace(/\s+/g, ''))
              var P = 0
              w[0] === '-' && (P++, (this.negative = 1)),
                P < w.length &&
                  (v === 16
                    ? this._parseHex(w, P, A)
                    : (this._parseBase(w, v, P),
                      A === 'le' && this._initArray(this.toArray(), v, A)))
            }),
            (i.prototype._initNumber = function (w, v, A) {
              w < 0 && ((this.negative = 1), (w = -w)),
                w < 67108864
                  ? ((this.words = [w & 67108863]), (this.length = 1))
                  : w < 4503599627370496
                    ? ((this.words = [w & 67108863, (w / 67108864) & 67108863]), (this.length = 2))
                    : (r(w < 9007199254740992),
                      (this.words = [w & 67108863, (w / 67108864) & 67108863, 1]),
                      (this.length = 3)),
                A === 'le' && this._initArray(this.toArray(), v, A)
            }),
            (i.prototype._initArray = function (w, v, A) {
              if ((r(typeof w.length == 'number'), w.length <= 0))
                return (this.words = [0]), (this.length = 1), this
              ;(this.length = Math.ceil(w.length / 3)), (this.words = new Array(this.length))
              for (var P = 0; P < this.length; P++) this.words[P] = 0
              var O,
                F,
                z = 0
              if (A === 'be')
                for (P = w.length - 1, O = 0; P >= 0; P -= 3)
                  (F = w[P] | (w[P - 1] << 8) | (w[P - 2] << 16)),
                    (this.words[O] |= (F << z) & 67108863),
                    (this.words[O + 1] = (F >>> (26 - z)) & 67108863),
                    (z += 24),
                    z >= 26 && ((z -= 26), O++)
              else if (A === 'le')
                for (P = 0, O = 0; P < w.length; P += 3)
                  (F = w[P] | (w[P + 1] << 8) | (w[P + 2] << 16)),
                    (this.words[O] |= (F << z) & 67108863),
                    (this.words[O + 1] = (F >>> (26 - z)) & 67108863),
                    (z += 24),
                    z >= 26 && ((z -= 26), O++)
              return this._strip()
            })
          function a(U, w) {
            var v = U.charCodeAt(w)
            if (v >= 48 && v <= 57) return v - 48
            if (v >= 65 && v <= 70) return v - 55
            if (v >= 97 && v <= 102) return v - 87
            r(!1, 'Invalid character in ' + U)
          }
          function c(U, w, v) {
            var A = a(U, v)
            return v - 1 >= w && (A |= a(U, v - 1) << 4), A
          }
          i.prototype._parseHex = function (w, v, A) {
            ;(this.length = Math.ceil((w.length - v) / 6)), (this.words = new Array(this.length))
            for (var P = 0; P < this.length; P++) this.words[P] = 0
            var O = 0,
              F = 0,
              z
            if (A === 'be')
              for (P = w.length - 1; P >= v; P -= 2)
                (z = c(w, v, P) << O),
                  (this.words[F] |= z & 67108863),
                  O >= 18 ? ((O -= 18), (F += 1), (this.words[F] |= z >>> 26)) : (O += 8)
            else {
              var j = w.length - v
              for (P = j % 2 === 0 ? v + 1 : v; P < w.length; P += 2)
                (z = c(w, v, P) << O),
                  (this.words[F] |= z & 67108863),
                  O >= 18 ? ((O -= 18), (F += 1), (this.words[F] |= z >>> 26)) : (O += 8)
            }
            this._strip()
          }
          function u(U, w, v, A) {
            for (var P = 0, O = 0, F = Math.min(U.length, v), z = w; z < F; z++) {
              var j = U.charCodeAt(z) - 48
              ;(P *= A),
                j >= 49 ? (O = j - 49 + 10) : j >= 17 ? (O = j - 17 + 10) : (O = j),
                r(j >= 0 && O < A, 'Invalid character'),
                (P += O)
            }
            return P
          }
          ;(i.prototype._parseBase = function (w, v, A) {
            ;(this.words = [0]), (this.length = 1)
            for (var P = 0, O = 1; O <= 67108863; O *= v) P++
            P--, (O = (O / v) | 0)
            for (
              var F = w.length - A, z = F % P, j = Math.min(F, F - z) + A, E = 0, C = A;
              C < j;
              C += P
            )
              (E = u(w, C, C + P, v)),
                this.imuln(O),
                this.words[0] + E < 67108864 ? (this.words[0] += E) : this._iaddn(E)
            if (z !== 0) {
              var L = 1
              for (E = u(w, C, w.length, v), C = 0; C < z; C++) L *= v
              this.imuln(L), this.words[0] + E < 67108864 ? (this.words[0] += E) : this._iaddn(E)
            }
            this._strip()
          }),
            (i.prototype.copy = function (w) {
              w.words = new Array(this.length)
              for (var v = 0; v < this.length; v++) w.words[v] = this.words[v]
              ;(w.length = this.length), (w.negative = this.negative), (w.red = this.red)
            })
          function l(U, w) {
            ;(U.words = w.words), (U.length = w.length), (U.negative = w.negative), (U.red = w.red)
          }
          if (
            ((i.prototype._move = function (w) {
              l(w, this)
            }),
            (i.prototype.clone = function () {
              var w = new i(null)
              return this.copy(w), w
            }),
            (i.prototype._expand = function (w) {
              for (; this.length < w; ) this.words[this.length++] = 0
              return this
            }),
            (i.prototype._strip = function () {
              for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--
              return this._normSign()
            }),
            (i.prototype._normSign = function () {
              return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }),
            typeof Symbol < 'u' && typeof Symbol.for == 'function')
          )
            try {
              i.prototype[Symbol.for('nodejs.util.inspect.custom')] = d
            } catch {
              i.prototype.inspect = d
            }
          else i.prototype.inspect = d
          function d() {
            return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>'
          }
          var h = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000'
            ],
            p = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5
            ],
            y = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721,
              1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224,
              47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
              17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
            ]
          ;(i.prototype.toString = function (w, v) {
            ;(w = w || 10), (v = v | 0 || 1)
            var A
            if (w === 16 || w === 'hex') {
              A = ''
              for (var P = 0, O = 0, F = 0; F < this.length; F++) {
                var z = this.words[F],
                  j = (((z << P) | O) & 16777215).toString(16)
                ;(O = (z >>> (24 - P)) & 16777215),
                  (P += 2),
                  P >= 26 && ((P -= 26), F--),
                  O !== 0 || F !== this.length - 1 ? (A = h[6 - j.length] + j + A) : (A = j + A)
              }
              for (O !== 0 && (A = O.toString(16) + A); A.length % v !== 0; ) A = '0' + A
              return this.negative !== 0 && (A = '-' + A), A
            }
            if (w === (w | 0) && w >= 2 && w <= 36) {
              var E = p[w],
                C = y[w]
              A = ''
              var L = this.clone()
              for (L.negative = 0; !L.isZero(); ) {
                var K = L.modrn(C).toString(w)
                ;(L = L.idivn(C)), L.isZero() ? (A = K + A) : (A = h[E - K.length] + K + A)
              }
              for (this.isZero() && (A = '0' + A); A.length % v !== 0; ) A = '0' + A
              return this.negative !== 0 && (A = '-' + A), A
            }
            r(!1, 'Base should be between 2 and 36')
          }),
            (i.prototype.toNumber = function () {
              var w = this.words[0]
              return (
                this.length === 2
                  ? (w += this.words[1] * 67108864)
                  : this.length === 3 && this.words[2] === 1
                    ? (w += 4503599627370496 + this.words[1] * 67108864)
                    : this.length > 2 && r(!1, 'Number can only safely store up to 53 bits'),
                this.negative !== 0 ? -w : w
              )
            }),
            (i.prototype.toJSON = function () {
              return this.toString(16, 2)
            }),
            o &&
              (i.prototype.toBuffer = function (w, v) {
                return this.toArrayLike(o, w, v)
              }),
            (i.prototype.toArray = function (w, v) {
              return this.toArrayLike(Array, w, v)
            })
          var m = function (w, v) {
            return w.allocUnsafe ? w.allocUnsafe(v) : new w(v)
          }
          ;(i.prototype.toArrayLike = function (w, v, A) {
            this._strip()
            var P = this.byteLength(),
              O = A || Math.max(1, P)
            r(P <= O, 'byte array longer than desired length'),
              r(O > 0, 'Requested array length <= 0')
            var F = m(w, O),
              z = v === 'le' ? 'LE' : 'BE'
            return this['_toArrayLike' + z](F, P), F
          }),
            (i.prototype._toArrayLikeLE = function (w, v) {
              for (var A = 0, P = 0, O = 0, F = 0; O < this.length; O++) {
                var z = (this.words[O] << F) | P
                ;(w[A++] = z & 255),
                  A < w.length && (w[A++] = (z >> 8) & 255),
                  A < w.length && (w[A++] = (z >> 16) & 255),
                  F === 6
                    ? (A < w.length && (w[A++] = (z >> 24) & 255), (P = 0), (F = 0))
                    : ((P = z >>> 24), (F += 2))
              }
              if (A < w.length) for (w[A++] = P; A < w.length; ) w[A++] = 0
            }),
            (i.prototype._toArrayLikeBE = function (w, v) {
              for (var A = w.length - 1, P = 0, O = 0, F = 0; O < this.length; O++) {
                var z = (this.words[O] << F) | P
                ;(w[A--] = z & 255),
                  A >= 0 && (w[A--] = (z >> 8) & 255),
                  A >= 0 && (w[A--] = (z >> 16) & 255),
                  F === 6
                    ? (A >= 0 && (w[A--] = (z >> 24) & 255), (P = 0), (F = 0))
                    : ((P = z >>> 24), (F += 2))
              }
              if (A >= 0) for (w[A--] = P; A >= 0; ) w[A--] = 0
            }),
            Math.clz32
              ? (i.prototype._countBits = function (w) {
                  return 32 - Math.clz32(w)
                })
              : (i.prototype._countBits = function (w) {
                  var v = w,
                    A = 0
                  return (
                    v >= 4096 && ((A += 13), (v >>>= 13)),
                    v >= 64 && ((A += 7), (v >>>= 7)),
                    v >= 8 && ((A += 4), (v >>>= 4)),
                    v >= 2 && ((A += 2), (v >>>= 2)),
                    A + v
                  )
                }),
            (i.prototype._zeroBits = function (w) {
              if (w === 0) return 26
              var v = w,
                A = 0
              return (
                (v & 8191) === 0 && ((A += 13), (v >>>= 13)),
                (v & 127) === 0 && ((A += 7), (v >>>= 7)),
                (v & 15) === 0 && ((A += 4), (v >>>= 4)),
                (v & 3) === 0 && ((A += 2), (v >>>= 2)),
                (v & 1) === 0 && A++,
                A
              )
            }),
            (i.prototype.bitLength = function () {
              var w = this.words[this.length - 1],
                v = this._countBits(w)
              return (this.length - 1) * 26 + v
            })
          function b(U) {
            for (var w = new Array(U.bitLength()), v = 0; v < w.length; v++) {
              var A = (v / 26) | 0,
                P = v % 26
              w[v] = (U.words[A] >>> P) & 1
            }
            return w
          }
          ;(i.prototype.zeroBits = function () {
            if (this.isZero()) return 0
            for (var w = 0, v = 0; v < this.length; v++) {
              var A = this._zeroBits(this.words[v])
              if (((w += A), A !== 26)) break
            }
            return w
          }),
            (i.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8)
            }),
            (i.prototype.toTwos = function (w) {
              return this.negative !== 0 ? this.abs().inotn(w).iaddn(1) : this.clone()
            }),
            (i.prototype.fromTwos = function (w) {
              return this.testn(w - 1) ? this.notn(w).iaddn(1).ineg() : this.clone()
            }),
            (i.prototype.isNeg = function () {
              return this.negative !== 0
            }),
            (i.prototype.neg = function () {
              return this.clone().ineg()
            }),
            (i.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this
            }),
            (i.prototype.iuor = function (w) {
              for (; this.length < w.length; ) this.words[this.length++] = 0
              for (var v = 0; v < w.length; v++) this.words[v] = this.words[v] | w.words[v]
              return this._strip()
            }),
            (i.prototype.ior = function (w) {
              return r((this.negative | w.negative) === 0), this.iuor(w)
            }),
            (i.prototype.or = function (w) {
              return this.length > w.length ? this.clone().ior(w) : w.clone().ior(this)
            }),
            (i.prototype.uor = function (w) {
              return this.length > w.length ? this.clone().iuor(w) : w.clone().iuor(this)
            }),
            (i.prototype.iuand = function (w) {
              var v
              this.length > w.length ? (v = w) : (v = this)
              for (var A = 0; A < v.length; A++) this.words[A] = this.words[A] & w.words[A]
              return (this.length = v.length), this._strip()
            }),
            (i.prototype.iand = function (w) {
              return r((this.negative | w.negative) === 0), this.iuand(w)
            }),
            (i.prototype.and = function (w) {
              return this.length > w.length ? this.clone().iand(w) : w.clone().iand(this)
            }),
            (i.prototype.uand = function (w) {
              return this.length > w.length ? this.clone().iuand(w) : w.clone().iuand(this)
            }),
            (i.prototype.iuxor = function (w) {
              var v, A
              this.length > w.length ? ((v = this), (A = w)) : ((v = w), (A = this))
              for (var P = 0; P < A.length; P++) this.words[P] = v.words[P] ^ A.words[P]
              if (this !== v) for (; P < v.length; P++) this.words[P] = v.words[P]
              return (this.length = v.length), this._strip()
            }),
            (i.prototype.ixor = function (w) {
              return r((this.negative | w.negative) === 0), this.iuxor(w)
            }),
            (i.prototype.xor = function (w) {
              return this.length > w.length ? this.clone().ixor(w) : w.clone().ixor(this)
            }),
            (i.prototype.uxor = function (w) {
              return this.length > w.length ? this.clone().iuxor(w) : w.clone().iuxor(this)
            }),
            (i.prototype.inotn = function (w) {
              r(typeof w == 'number' && w >= 0)
              var v = Math.ceil(w / 26) | 0,
                A = w % 26
              this._expand(v), A > 0 && v--
              for (var P = 0; P < v; P++) this.words[P] = ~this.words[P] & 67108863
              return (
                A > 0 && (this.words[P] = ~this.words[P] & (67108863 >> (26 - A))), this._strip()
              )
            }),
            (i.prototype.notn = function (w) {
              return this.clone().inotn(w)
            }),
            (i.prototype.setn = function (w, v) {
              r(typeof w == 'number' && w >= 0)
              var A = (w / 26) | 0,
                P = w % 26
              return (
                this._expand(A + 1),
                v
                  ? (this.words[A] = this.words[A] | (1 << P))
                  : (this.words[A] = this.words[A] & ~(1 << P)),
                this._strip()
              )
            }),
            (i.prototype.iadd = function (w) {
              var v
              if (this.negative !== 0 && w.negative === 0)
                return (
                  (this.negative = 0), (v = this.isub(w)), (this.negative ^= 1), this._normSign()
                )
              if (this.negative === 0 && w.negative !== 0)
                return (w.negative = 0), (v = this.isub(w)), (w.negative = 1), v._normSign()
              var A, P
              this.length > w.length ? ((A = this), (P = w)) : ((A = w), (P = this))
              for (var O = 0, F = 0; F < P.length; F++)
                (v = (A.words[F] | 0) + (P.words[F] | 0) + O),
                  (this.words[F] = v & 67108863),
                  (O = v >>> 26)
              for (; O !== 0 && F < A.length; F++)
                (v = (A.words[F] | 0) + O), (this.words[F] = v & 67108863), (O = v >>> 26)
              if (((this.length = A.length), O !== 0)) (this.words[this.length] = O), this.length++
              else if (A !== this) for (; F < A.length; F++) this.words[F] = A.words[F]
              return this
            }),
            (i.prototype.add = function (w) {
              var v
              return w.negative !== 0 && this.negative === 0
                ? ((w.negative = 0), (v = this.sub(w)), (w.negative ^= 1), v)
                : w.negative === 0 && this.negative !== 0
                  ? ((this.negative = 0), (v = w.sub(this)), (this.negative = 1), v)
                  : this.length > w.length
                    ? this.clone().iadd(w)
                    : w.clone().iadd(this)
            }),
            (i.prototype.isub = function (w) {
              if (w.negative !== 0) {
                w.negative = 0
                var v = this.iadd(w)
                return (w.negative = 1), v._normSign()
              } else if (this.negative !== 0)
                return (this.negative = 0), this.iadd(w), (this.negative = 1), this._normSign()
              var A = this.cmp(w)
              if (A === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
              var P, O
              A > 0 ? ((P = this), (O = w)) : ((P = w), (O = this))
              for (var F = 0, z = 0; z < O.length; z++)
                (v = (P.words[z] | 0) - (O.words[z] | 0) + F),
                  (F = v >> 26),
                  (this.words[z] = v & 67108863)
              for (; F !== 0 && z < P.length; z++)
                (v = (P.words[z] | 0) + F), (F = v >> 26), (this.words[z] = v & 67108863)
              if (F === 0 && z < P.length && P !== this)
                for (; z < P.length; z++) this.words[z] = P.words[z]
              return (
                (this.length = Math.max(this.length, z)),
                P !== this && (this.negative = 1),
                this._strip()
              )
            }),
            (i.prototype.sub = function (w) {
              return this.clone().isub(w)
            })
          function I(U, w, v) {
            v.negative = w.negative ^ U.negative
            var A = (U.length + w.length) | 0
            ;(v.length = A), (A = (A - 1) | 0)
            var P = U.words[0] | 0,
              O = w.words[0] | 0,
              F = P * O,
              z = F & 67108863,
              j = (F / 67108864) | 0
            v.words[0] = z
            for (var E = 1; E < A; E++) {
              for (
                var C = j >>> 26,
                  L = j & 67108863,
                  K = Math.min(E, w.length - 1),
                  ee = Math.max(0, E - U.length + 1);
                ee <= K;
                ee++
              ) {
                var oe = (E - ee) | 0
                ;(P = U.words[oe] | 0),
                  (O = w.words[ee] | 0),
                  (F = P * O + L),
                  (C += (F / 67108864) | 0),
                  (L = F & 67108863)
              }
              ;(v.words[E] = L | 0), (j = C | 0)
            }
            return j !== 0 ? (v.words[E] = j | 0) : v.length--, v._strip()
          }
          var x = function (w, v, A) {
            var P = w.words,
              O = v.words,
              F = A.words,
              z = 0,
              j,
              E,
              C,
              L = P[0] | 0,
              K = L & 8191,
              ee = L >>> 13,
              oe = P[1] | 0,
              fe = oe & 8191,
              ve = oe >>> 13,
              tt = P[2] | 0,
              Ge = tt & 8191,
              nt = tt >>> 13,
              Z = P[3] | 0,
              X = Z & 8191,
              ie = Z >>> 13,
              be = P[4] | 0,
              ue = be & 8191,
              de = be >>> 13,
              Te = P[5] | 0,
              we = Te & 8191,
              ge = Te >>> 13,
              he = P[6] | 0,
              Ne = he & 8191,
              _e = he >>> 13,
              Be = P[7] | 0,
              $e = Be & 8191,
              S = Be >>> 13,
              f = P[8] | 0,
              g = f & 8191,
              k = f >>> 13,
              q = P[9] | 0,
              V = q & 8191,
              Y = q >>> 13,
              ke = O[0] | 0,
              Ve = ke & 8191,
              Oe = ke >>> 13,
              st = O[1] | 0,
              Ue = st & 8191,
              Rn = st >>> 13,
              Md = O[2] | 0,
              kn = Md & 8191,
              jt = Md >>> 13,
              hi = O[3] | 0,
              _n = hi & 8191,
              te = hi >>> 13,
              Q = O[4] | 0,
              J = Q & 8191,
              se = Q >>> 13,
              le = O[5] | 0,
              pe = le & 8191,
              xe = le >>> 13,
              je = O[6] | 0,
              Qe = je & 8191,
              qe = je >>> 13,
              vt = O[7] | 0,
              at = vt & 8191,
              ct = vt >>> 13,
              Un = O[8] | 0,
              xt = Un & 8191,
              zt = Un >>> 13,
              yo = O[9] | 0,
              un = yo & 8191,
              ln = yo >>> 13
            ;(A.negative = w.negative ^ v.negative),
              (A.length = 19),
              (j = Math.imul(K, Ve)),
              (E = Math.imul(K, Oe)),
              (E = (E + Math.imul(ee, Ve)) | 0),
              (C = Math.imul(ee, Oe))
            var sa = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (sa >>> 26)) | 0),
              (sa &= 67108863),
              (j = Math.imul(fe, Ve)),
              (E = Math.imul(fe, Oe)),
              (E = (E + Math.imul(ve, Ve)) | 0),
              (C = Math.imul(ve, Oe)),
              (j = (j + Math.imul(K, Ue)) | 0),
              (E = (E + Math.imul(K, Rn)) | 0),
              (E = (E + Math.imul(ee, Ue)) | 0),
              (C = (C + Math.imul(ee, Rn)) | 0)
            var hc = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (hc >>> 26)) | 0),
              (hc &= 67108863),
              (j = Math.imul(Ge, Ve)),
              (E = Math.imul(Ge, Oe)),
              (E = (E + Math.imul(nt, Ve)) | 0),
              (C = Math.imul(nt, Oe)),
              (j = (j + Math.imul(fe, Ue)) | 0),
              (E = (E + Math.imul(fe, Rn)) | 0),
              (E = (E + Math.imul(ve, Ue)) | 0),
              (C = (C + Math.imul(ve, Rn)) | 0),
              (j = (j + Math.imul(K, kn)) | 0),
              (E = (E + Math.imul(K, jt)) | 0),
              (E = (E + Math.imul(ee, kn)) | 0),
              (C = (C + Math.imul(ee, jt)) | 0)
            var wo = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (wo >>> 26)) | 0),
              (wo &= 67108863),
              (j = Math.imul(X, Ve)),
              (E = Math.imul(X, Oe)),
              (E = (E + Math.imul(ie, Ve)) | 0),
              (C = Math.imul(ie, Oe)),
              (j = (j + Math.imul(Ge, Ue)) | 0),
              (E = (E + Math.imul(Ge, Rn)) | 0),
              (E = (E + Math.imul(nt, Ue)) | 0),
              (C = (C + Math.imul(nt, Rn)) | 0),
              (j = (j + Math.imul(fe, kn)) | 0),
              (E = (E + Math.imul(fe, jt)) | 0),
              (E = (E + Math.imul(ve, kn)) | 0),
              (C = (C + Math.imul(ve, jt)) | 0),
              (j = (j + Math.imul(K, _n)) | 0),
              (E = (E + Math.imul(K, te)) | 0),
              (E = (E + Math.imul(ee, _n)) | 0),
              (C = (C + Math.imul(ee, te)) | 0)
            var Rp = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (Rp >>> 26)) | 0),
              (Rp &= 67108863),
              (j = Math.imul(ue, Ve)),
              (E = Math.imul(ue, Oe)),
              (E = (E + Math.imul(de, Ve)) | 0),
              (C = Math.imul(de, Oe)),
              (j = (j + Math.imul(X, Ue)) | 0),
              (E = (E + Math.imul(X, Rn)) | 0),
              (E = (E + Math.imul(ie, Ue)) | 0),
              (C = (C + Math.imul(ie, Rn)) | 0),
              (j = (j + Math.imul(Ge, kn)) | 0),
              (E = (E + Math.imul(Ge, jt)) | 0),
              (E = (E + Math.imul(nt, kn)) | 0),
              (C = (C + Math.imul(nt, jt)) | 0),
              (j = (j + Math.imul(fe, _n)) | 0),
              (E = (E + Math.imul(fe, te)) | 0),
              (E = (E + Math.imul(ve, _n)) | 0),
              (C = (C + Math.imul(ve, te)) | 0),
              (j = (j + Math.imul(K, J)) | 0),
              (E = (E + Math.imul(K, se)) | 0),
              (E = (E + Math.imul(ee, J)) | 0),
              (C = (C + Math.imul(ee, se)) | 0)
            var yy = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (yy >>> 26)) | 0),
              (yy &= 67108863),
              (j = Math.imul(we, Ve)),
              (E = Math.imul(we, Oe)),
              (E = (E + Math.imul(ge, Ve)) | 0),
              (C = Math.imul(ge, Oe)),
              (j = (j + Math.imul(ue, Ue)) | 0),
              (E = (E + Math.imul(ue, Rn)) | 0),
              (E = (E + Math.imul(de, Ue)) | 0),
              (C = (C + Math.imul(de, Rn)) | 0),
              (j = (j + Math.imul(X, kn)) | 0),
              (E = (E + Math.imul(X, jt)) | 0),
              (E = (E + Math.imul(ie, kn)) | 0),
              (C = (C + Math.imul(ie, jt)) | 0),
              (j = (j + Math.imul(Ge, _n)) | 0),
              (E = (E + Math.imul(Ge, te)) | 0),
              (E = (E + Math.imul(nt, _n)) | 0),
              (C = (C + Math.imul(nt, te)) | 0),
              (j = (j + Math.imul(fe, J)) | 0),
              (E = (E + Math.imul(fe, se)) | 0),
              (E = (E + Math.imul(ve, J)) | 0),
              (C = (C + Math.imul(ve, se)) | 0),
              (j = (j + Math.imul(K, pe)) | 0),
              (E = (E + Math.imul(K, xe)) | 0),
              (E = (E + Math.imul(ee, pe)) | 0),
              (C = (C + Math.imul(ee, xe)) | 0)
            var wy = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (wy >>> 26)) | 0),
              (wy &= 67108863),
              (j = Math.imul(Ne, Ve)),
              (E = Math.imul(Ne, Oe)),
              (E = (E + Math.imul(_e, Ve)) | 0),
              (C = Math.imul(_e, Oe)),
              (j = (j + Math.imul(we, Ue)) | 0),
              (E = (E + Math.imul(we, Rn)) | 0),
              (E = (E + Math.imul(ge, Ue)) | 0),
              (C = (C + Math.imul(ge, Rn)) | 0),
              (j = (j + Math.imul(ue, kn)) | 0),
              (E = (E + Math.imul(ue, jt)) | 0),
              (E = (E + Math.imul(de, kn)) | 0),
              (C = (C + Math.imul(de, jt)) | 0),
              (j = (j + Math.imul(X, _n)) | 0),
              (E = (E + Math.imul(X, te)) | 0),
              (E = (E + Math.imul(ie, _n)) | 0),
              (C = (C + Math.imul(ie, te)) | 0),
              (j = (j + Math.imul(Ge, J)) | 0),
              (E = (E + Math.imul(Ge, se)) | 0),
              (E = (E + Math.imul(nt, J)) | 0),
              (C = (C + Math.imul(nt, se)) | 0),
              (j = (j + Math.imul(fe, pe)) | 0),
              (E = (E + Math.imul(fe, xe)) | 0),
              (E = (E + Math.imul(ve, pe)) | 0),
              (C = (C + Math.imul(ve, xe)) | 0),
              (j = (j + Math.imul(K, Qe)) | 0),
              (E = (E + Math.imul(K, qe)) | 0),
              (E = (E + Math.imul(ee, Qe)) | 0),
              (C = (C + Math.imul(ee, qe)) | 0)
            var by = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (by >>> 26)) | 0),
              (by &= 67108863),
              (j = Math.imul($e, Ve)),
              (E = Math.imul($e, Oe)),
              (E = (E + Math.imul(S, Ve)) | 0),
              (C = Math.imul(S, Oe)),
              (j = (j + Math.imul(Ne, Ue)) | 0),
              (E = (E + Math.imul(Ne, Rn)) | 0),
              (E = (E + Math.imul(_e, Ue)) | 0),
              (C = (C + Math.imul(_e, Rn)) | 0),
              (j = (j + Math.imul(we, kn)) | 0),
              (E = (E + Math.imul(we, jt)) | 0),
              (E = (E + Math.imul(ge, kn)) | 0),
              (C = (C + Math.imul(ge, jt)) | 0),
              (j = (j + Math.imul(ue, _n)) | 0),
              (E = (E + Math.imul(ue, te)) | 0),
              (E = (E + Math.imul(de, _n)) | 0),
              (C = (C + Math.imul(de, te)) | 0),
              (j = (j + Math.imul(X, J)) | 0),
              (E = (E + Math.imul(X, se)) | 0),
              (E = (E + Math.imul(ie, J)) | 0),
              (C = (C + Math.imul(ie, se)) | 0),
              (j = (j + Math.imul(Ge, pe)) | 0),
              (E = (E + Math.imul(Ge, xe)) | 0),
              (E = (E + Math.imul(nt, pe)) | 0),
              (C = (C + Math.imul(nt, xe)) | 0),
              (j = (j + Math.imul(fe, Qe)) | 0),
              (E = (E + Math.imul(fe, qe)) | 0),
              (E = (E + Math.imul(ve, Qe)) | 0),
              (C = (C + Math.imul(ve, qe)) | 0),
              (j = (j + Math.imul(K, at)) | 0),
              (E = (E + Math.imul(K, ct)) | 0),
              (E = (E + Math.imul(ee, at)) | 0),
              (C = (C + Math.imul(ee, ct)) | 0)
            var vy = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (vy >>> 26)) | 0),
              (vy &= 67108863),
              (j = Math.imul(g, Ve)),
              (E = Math.imul(g, Oe)),
              (E = (E + Math.imul(k, Ve)) | 0),
              (C = Math.imul(k, Oe)),
              (j = (j + Math.imul($e, Ue)) | 0),
              (E = (E + Math.imul($e, Rn)) | 0),
              (E = (E + Math.imul(S, Ue)) | 0),
              (C = (C + Math.imul(S, Rn)) | 0),
              (j = (j + Math.imul(Ne, kn)) | 0),
              (E = (E + Math.imul(Ne, jt)) | 0),
              (E = (E + Math.imul(_e, kn)) | 0),
              (C = (C + Math.imul(_e, jt)) | 0),
              (j = (j + Math.imul(we, _n)) | 0),
              (E = (E + Math.imul(we, te)) | 0),
              (E = (E + Math.imul(ge, _n)) | 0),
              (C = (C + Math.imul(ge, te)) | 0),
              (j = (j + Math.imul(ue, J)) | 0),
              (E = (E + Math.imul(ue, se)) | 0),
              (E = (E + Math.imul(de, J)) | 0),
              (C = (C + Math.imul(de, se)) | 0),
              (j = (j + Math.imul(X, pe)) | 0),
              (E = (E + Math.imul(X, xe)) | 0),
              (E = (E + Math.imul(ie, pe)) | 0),
              (C = (C + Math.imul(ie, xe)) | 0),
              (j = (j + Math.imul(Ge, Qe)) | 0),
              (E = (E + Math.imul(Ge, qe)) | 0),
              (E = (E + Math.imul(nt, Qe)) | 0),
              (C = (C + Math.imul(nt, qe)) | 0),
              (j = (j + Math.imul(fe, at)) | 0),
              (E = (E + Math.imul(fe, ct)) | 0),
              (E = (E + Math.imul(ve, at)) | 0),
              (C = (C + Math.imul(ve, ct)) | 0),
              (j = (j + Math.imul(K, xt)) | 0),
              (E = (E + Math.imul(K, zt)) | 0),
              (E = (E + Math.imul(ee, xt)) | 0),
              (C = (C + Math.imul(ee, zt)) | 0)
            var Ey = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (Ey >>> 26)) | 0),
              (Ey &= 67108863),
              (j = Math.imul(V, Ve)),
              (E = Math.imul(V, Oe)),
              (E = (E + Math.imul(Y, Ve)) | 0),
              (C = Math.imul(Y, Oe)),
              (j = (j + Math.imul(g, Ue)) | 0),
              (E = (E + Math.imul(g, Rn)) | 0),
              (E = (E + Math.imul(k, Ue)) | 0),
              (C = (C + Math.imul(k, Rn)) | 0),
              (j = (j + Math.imul($e, kn)) | 0),
              (E = (E + Math.imul($e, jt)) | 0),
              (E = (E + Math.imul(S, kn)) | 0),
              (C = (C + Math.imul(S, jt)) | 0),
              (j = (j + Math.imul(Ne, _n)) | 0),
              (E = (E + Math.imul(Ne, te)) | 0),
              (E = (E + Math.imul(_e, _n)) | 0),
              (C = (C + Math.imul(_e, te)) | 0),
              (j = (j + Math.imul(we, J)) | 0),
              (E = (E + Math.imul(we, se)) | 0),
              (E = (E + Math.imul(ge, J)) | 0),
              (C = (C + Math.imul(ge, se)) | 0),
              (j = (j + Math.imul(ue, pe)) | 0),
              (E = (E + Math.imul(ue, xe)) | 0),
              (E = (E + Math.imul(de, pe)) | 0),
              (C = (C + Math.imul(de, xe)) | 0),
              (j = (j + Math.imul(X, Qe)) | 0),
              (E = (E + Math.imul(X, qe)) | 0),
              (E = (E + Math.imul(ie, Qe)) | 0),
              (C = (C + Math.imul(ie, qe)) | 0),
              (j = (j + Math.imul(Ge, at)) | 0),
              (E = (E + Math.imul(Ge, ct)) | 0),
              (E = (E + Math.imul(nt, at)) | 0),
              (C = (C + Math.imul(nt, ct)) | 0),
              (j = (j + Math.imul(fe, xt)) | 0),
              (E = (E + Math.imul(fe, zt)) | 0),
              (E = (E + Math.imul(ve, xt)) | 0),
              (C = (C + Math.imul(ve, zt)) | 0),
              (j = (j + Math.imul(K, un)) | 0),
              (E = (E + Math.imul(K, ln)) | 0),
              (E = (E + Math.imul(ee, un)) | 0),
              (C = (C + Math.imul(ee, ln)) | 0)
            var Ay = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (Ay >>> 26)) | 0),
              (Ay &= 67108863),
              (j = Math.imul(V, Ue)),
              (E = Math.imul(V, Rn)),
              (E = (E + Math.imul(Y, Ue)) | 0),
              (C = Math.imul(Y, Rn)),
              (j = (j + Math.imul(g, kn)) | 0),
              (E = (E + Math.imul(g, jt)) | 0),
              (E = (E + Math.imul(k, kn)) | 0),
              (C = (C + Math.imul(k, jt)) | 0),
              (j = (j + Math.imul($e, _n)) | 0),
              (E = (E + Math.imul($e, te)) | 0),
              (E = (E + Math.imul(S, _n)) | 0),
              (C = (C + Math.imul(S, te)) | 0),
              (j = (j + Math.imul(Ne, J)) | 0),
              (E = (E + Math.imul(Ne, se)) | 0),
              (E = (E + Math.imul(_e, J)) | 0),
              (C = (C + Math.imul(_e, se)) | 0),
              (j = (j + Math.imul(we, pe)) | 0),
              (E = (E + Math.imul(we, xe)) | 0),
              (E = (E + Math.imul(ge, pe)) | 0),
              (C = (C + Math.imul(ge, xe)) | 0),
              (j = (j + Math.imul(ue, Qe)) | 0),
              (E = (E + Math.imul(ue, qe)) | 0),
              (E = (E + Math.imul(de, Qe)) | 0),
              (C = (C + Math.imul(de, qe)) | 0),
              (j = (j + Math.imul(X, at)) | 0),
              (E = (E + Math.imul(X, ct)) | 0),
              (E = (E + Math.imul(ie, at)) | 0),
              (C = (C + Math.imul(ie, ct)) | 0),
              (j = (j + Math.imul(Ge, xt)) | 0),
              (E = (E + Math.imul(Ge, zt)) | 0),
              (E = (E + Math.imul(nt, xt)) | 0),
              (C = (C + Math.imul(nt, zt)) | 0),
              (j = (j + Math.imul(fe, un)) | 0),
              (E = (E + Math.imul(fe, ln)) | 0),
              (E = (E + Math.imul(ve, un)) | 0),
              (C = (C + Math.imul(ve, ln)) | 0)
            var _y = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (_y >>> 26)) | 0),
              (_y &= 67108863),
              (j = Math.imul(V, kn)),
              (E = Math.imul(V, jt)),
              (E = (E + Math.imul(Y, kn)) | 0),
              (C = Math.imul(Y, jt)),
              (j = (j + Math.imul(g, _n)) | 0),
              (E = (E + Math.imul(g, te)) | 0),
              (E = (E + Math.imul(k, _n)) | 0),
              (C = (C + Math.imul(k, te)) | 0),
              (j = (j + Math.imul($e, J)) | 0),
              (E = (E + Math.imul($e, se)) | 0),
              (E = (E + Math.imul(S, J)) | 0),
              (C = (C + Math.imul(S, se)) | 0),
              (j = (j + Math.imul(Ne, pe)) | 0),
              (E = (E + Math.imul(Ne, xe)) | 0),
              (E = (E + Math.imul(_e, pe)) | 0),
              (C = (C + Math.imul(_e, xe)) | 0),
              (j = (j + Math.imul(we, Qe)) | 0),
              (E = (E + Math.imul(we, qe)) | 0),
              (E = (E + Math.imul(ge, Qe)) | 0),
              (C = (C + Math.imul(ge, qe)) | 0),
              (j = (j + Math.imul(ue, at)) | 0),
              (E = (E + Math.imul(ue, ct)) | 0),
              (E = (E + Math.imul(de, at)) | 0),
              (C = (C + Math.imul(de, ct)) | 0),
              (j = (j + Math.imul(X, xt)) | 0),
              (E = (E + Math.imul(X, zt)) | 0),
              (E = (E + Math.imul(ie, xt)) | 0),
              (C = (C + Math.imul(ie, zt)) | 0),
              (j = (j + Math.imul(Ge, un)) | 0),
              (E = (E + Math.imul(Ge, ln)) | 0),
              (E = (E + Math.imul(nt, un)) | 0),
              (C = (C + Math.imul(nt, ln)) | 0)
            var Cy = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (Cy >>> 26)) | 0),
              (Cy &= 67108863),
              (j = Math.imul(V, _n)),
              (E = Math.imul(V, te)),
              (E = (E + Math.imul(Y, _n)) | 0),
              (C = Math.imul(Y, te)),
              (j = (j + Math.imul(g, J)) | 0),
              (E = (E + Math.imul(g, se)) | 0),
              (E = (E + Math.imul(k, J)) | 0),
              (C = (C + Math.imul(k, se)) | 0),
              (j = (j + Math.imul($e, pe)) | 0),
              (E = (E + Math.imul($e, xe)) | 0),
              (E = (E + Math.imul(S, pe)) | 0),
              (C = (C + Math.imul(S, xe)) | 0),
              (j = (j + Math.imul(Ne, Qe)) | 0),
              (E = (E + Math.imul(Ne, qe)) | 0),
              (E = (E + Math.imul(_e, Qe)) | 0),
              (C = (C + Math.imul(_e, qe)) | 0),
              (j = (j + Math.imul(we, at)) | 0),
              (E = (E + Math.imul(we, ct)) | 0),
              (E = (E + Math.imul(ge, at)) | 0),
              (C = (C + Math.imul(ge, ct)) | 0),
              (j = (j + Math.imul(ue, xt)) | 0),
              (E = (E + Math.imul(ue, zt)) | 0),
              (E = (E + Math.imul(de, xt)) | 0),
              (C = (C + Math.imul(de, zt)) | 0),
              (j = (j + Math.imul(X, un)) | 0),
              (E = (E + Math.imul(X, ln)) | 0),
              (E = (E + Math.imul(ie, un)) | 0),
              (C = (C + Math.imul(ie, ln)) | 0)
            var Sy = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (Sy >>> 26)) | 0),
              (Sy &= 67108863),
              (j = Math.imul(V, J)),
              (E = Math.imul(V, se)),
              (E = (E + Math.imul(Y, J)) | 0),
              (C = Math.imul(Y, se)),
              (j = (j + Math.imul(g, pe)) | 0),
              (E = (E + Math.imul(g, xe)) | 0),
              (E = (E + Math.imul(k, pe)) | 0),
              (C = (C + Math.imul(k, xe)) | 0),
              (j = (j + Math.imul($e, Qe)) | 0),
              (E = (E + Math.imul($e, qe)) | 0),
              (E = (E + Math.imul(S, Qe)) | 0),
              (C = (C + Math.imul(S, qe)) | 0),
              (j = (j + Math.imul(Ne, at)) | 0),
              (E = (E + Math.imul(Ne, ct)) | 0),
              (E = (E + Math.imul(_e, at)) | 0),
              (C = (C + Math.imul(_e, ct)) | 0),
              (j = (j + Math.imul(we, xt)) | 0),
              (E = (E + Math.imul(we, zt)) | 0),
              (E = (E + Math.imul(ge, xt)) | 0),
              (C = (C + Math.imul(ge, zt)) | 0),
              (j = (j + Math.imul(ue, un)) | 0),
              (E = (E + Math.imul(ue, ln)) | 0),
              (E = (E + Math.imul(de, un)) | 0),
              (C = (C + Math.imul(de, ln)) | 0)
            var Iy = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (Iy >>> 26)) | 0),
              (Iy &= 67108863),
              (j = Math.imul(V, pe)),
              (E = Math.imul(V, xe)),
              (E = (E + Math.imul(Y, pe)) | 0),
              (C = Math.imul(Y, xe)),
              (j = (j + Math.imul(g, Qe)) | 0),
              (E = (E + Math.imul(g, qe)) | 0),
              (E = (E + Math.imul(k, Qe)) | 0),
              (C = (C + Math.imul(k, qe)) | 0),
              (j = (j + Math.imul($e, at)) | 0),
              (E = (E + Math.imul($e, ct)) | 0),
              (E = (E + Math.imul(S, at)) | 0),
              (C = (C + Math.imul(S, ct)) | 0),
              (j = (j + Math.imul(Ne, xt)) | 0),
              (E = (E + Math.imul(Ne, zt)) | 0),
              (E = (E + Math.imul(_e, xt)) | 0),
              (C = (C + Math.imul(_e, zt)) | 0),
              (j = (j + Math.imul(we, un)) | 0),
              (E = (E + Math.imul(we, ln)) | 0),
              (E = (E + Math.imul(ge, un)) | 0),
              (C = (C + Math.imul(ge, ln)) | 0)
            var xy = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (xy >>> 26)) | 0),
              (xy &= 67108863),
              (j = Math.imul(V, Qe)),
              (E = Math.imul(V, qe)),
              (E = (E + Math.imul(Y, Qe)) | 0),
              (C = Math.imul(Y, qe)),
              (j = (j + Math.imul(g, at)) | 0),
              (E = (E + Math.imul(g, ct)) | 0),
              (E = (E + Math.imul(k, at)) | 0),
              (C = (C + Math.imul(k, ct)) | 0),
              (j = (j + Math.imul($e, xt)) | 0),
              (E = (E + Math.imul($e, zt)) | 0),
              (E = (E + Math.imul(S, xt)) | 0),
              (C = (C + Math.imul(S, zt)) | 0),
              (j = (j + Math.imul(Ne, un)) | 0),
              (E = (E + Math.imul(Ne, ln)) | 0),
              (E = (E + Math.imul(_e, un)) | 0),
              (C = (C + Math.imul(_e, ln)) | 0)
            var Ty = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (Ty >>> 26)) | 0),
              (Ty &= 67108863),
              (j = Math.imul(V, at)),
              (E = Math.imul(V, ct)),
              (E = (E + Math.imul(Y, at)) | 0),
              (C = Math.imul(Y, ct)),
              (j = (j + Math.imul(g, xt)) | 0),
              (E = (E + Math.imul(g, zt)) | 0),
              (E = (E + Math.imul(k, xt)) | 0),
              (C = (C + Math.imul(k, zt)) | 0),
              (j = (j + Math.imul($e, un)) | 0),
              (E = (E + Math.imul($e, ln)) | 0),
              (E = (E + Math.imul(S, un)) | 0),
              (C = (C + Math.imul(S, ln)) | 0)
            var Ny = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (Ny >>> 26)) | 0),
              (Ny &= 67108863),
              (j = Math.imul(V, xt)),
              (E = Math.imul(V, zt)),
              (E = (E + Math.imul(Y, xt)) | 0),
              (C = Math.imul(Y, zt)),
              (j = (j + Math.imul(g, un)) | 0),
              (E = (E + Math.imul(g, ln)) | 0),
              (E = (E + Math.imul(k, un)) | 0),
              (C = (C + Math.imul(k, ln)) | 0)
            var Py = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            ;(z = (((C + (E >>> 13)) | 0) + (Py >>> 26)) | 0),
              (Py &= 67108863),
              (j = Math.imul(V, un)),
              (E = Math.imul(V, ln)),
              (E = (E + Math.imul(Y, un)) | 0),
              (C = Math.imul(Y, ln))
            var Ry = (((z + j) | 0) + ((E & 8191) << 13)) | 0
            return (
              (z = (((C + (E >>> 13)) | 0) + (Ry >>> 26)) | 0),
              (Ry &= 67108863),
              (F[0] = sa),
              (F[1] = hc),
              (F[2] = wo),
              (F[3] = Rp),
              (F[4] = yy),
              (F[5] = wy),
              (F[6] = by),
              (F[7] = vy),
              (F[8] = Ey),
              (F[9] = Ay),
              (F[10] = _y),
              (F[11] = Cy),
              (F[12] = Sy),
              (F[13] = Iy),
              (F[14] = xy),
              (F[15] = Ty),
              (F[16] = Ny),
              (F[17] = Py),
              (F[18] = Ry),
              z !== 0 && ((F[19] = z), A.length++),
              A
            )
          }
          Math.imul || (x = I)
          function _(U, w, v) {
            ;(v.negative = w.negative ^ U.negative), (v.length = U.length + w.length)
            for (var A = 0, P = 0, O = 0; O < v.length - 1; O++) {
              var F = P
              P = 0
              for (
                var z = A & 67108863,
                  j = Math.min(O, w.length - 1),
                  E = Math.max(0, O - U.length + 1);
                E <= j;
                E++
              ) {
                var C = O - E,
                  L = U.words[C] | 0,
                  K = w.words[E] | 0,
                  ee = L * K,
                  oe = ee & 67108863
                ;(F = (F + ((ee / 67108864) | 0)) | 0),
                  (oe = (oe + z) | 0),
                  (z = oe & 67108863),
                  (F = (F + (oe >>> 26)) | 0),
                  (P += F >>> 26),
                  (F &= 67108863)
              }
              ;(v.words[O] = z), (A = F), (F = P)
            }
            return A !== 0 ? (v.words[O] = A) : v.length--, v._strip()
          }
          function R(U, w, v) {
            return _(U, w, v)
          }
          ;(i.prototype.mulTo = function (w, v) {
            var A,
              P = this.length + w.length
            return (
              this.length === 10 && w.length === 10
                ? (A = x(this, w, v))
                : P < 63
                  ? (A = I(this, w, v))
                  : P < 1024
                    ? (A = _(this, w, v))
                    : (A = R(this, w, v)),
              A
            )
          }),
            (i.prototype.mul = function (w) {
              var v = new i(null)
              return (v.words = new Array(this.length + w.length)), this.mulTo(w, v)
            }),
            (i.prototype.mulf = function (w) {
              var v = new i(null)
              return (v.words = new Array(this.length + w.length)), R(this, w, v)
            }),
            (i.prototype.imul = function (w) {
              return this.clone().mulTo(w, this)
            }),
            (i.prototype.imuln = function (w) {
              var v = w < 0
              v && (w = -w), r(typeof w == 'number'), r(w < 67108864)
              for (var A = 0, P = 0; P < this.length; P++) {
                var O = (this.words[P] | 0) * w,
                  F = (O & 67108863) + (A & 67108863)
                ;(A >>= 26),
                  (A += (O / 67108864) | 0),
                  (A += F >>> 26),
                  (this.words[P] = F & 67108863)
              }
              return A !== 0 && ((this.words[P] = A), this.length++), v ? this.ineg() : this
            }),
            (i.prototype.muln = function (w) {
              return this.clone().imuln(w)
            }),
            (i.prototype.sqr = function () {
              return this.mul(this)
            }),
            (i.prototype.isqr = function () {
              return this.imul(this.clone())
            }),
            (i.prototype.pow = function (w) {
              var v = b(w)
              if (v.length === 0) return new i(1)
              for (var A = this, P = 0; P < v.length && v[P] === 0; P++, A = A.sqr());
              if (++P < v.length)
                for (var O = A.sqr(); P < v.length; P++, O = O.sqr()) v[P] !== 0 && (A = A.mul(O))
              return A
            }),
            (i.prototype.iushln = function (w) {
              r(typeof w == 'number' && w >= 0)
              var v = w % 26,
                A = (w - v) / 26,
                P = (67108863 >>> (26 - v)) << (26 - v),
                O
              if (v !== 0) {
                var F = 0
                for (O = 0; O < this.length; O++) {
                  var z = this.words[O] & P,
                    j = ((this.words[O] | 0) - z) << v
                  ;(this.words[O] = j | F), (F = z >>> (26 - v))
                }
                F && ((this.words[O] = F), this.length++)
              }
              if (A !== 0) {
                for (O = this.length - 1; O >= 0; O--) this.words[O + A] = this.words[O]
                for (O = 0; O < A; O++) this.words[O] = 0
                this.length += A
              }
              return this._strip()
            }),
            (i.prototype.ishln = function (w) {
              return r(this.negative === 0), this.iushln(w)
            }),
            (i.prototype.iushrn = function (w, v, A) {
              r(typeof w == 'number' && w >= 0)
              var P
              v ? (P = (v - (v % 26)) / 26) : (P = 0)
              var O = w % 26,
                F = Math.min((w - O) / 26, this.length),
                z = 67108863 ^ ((67108863 >>> O) << O),
                j = A
              if (((P -= F), (P = Math.max(0, P)), j)) {
                for (var E = 0; E < F; E++) j.words[E] = this.words[E]
                j.length = F
              }
              if (F !== 0)
                if (this.length > F)
                  for (this.length -= F, E = 0; E < this.length; E++)
                    this.words[E] = this.words[E + F]
                else (this.words[0] = 0), (this.length = 1)
              var C = 0
              for (E = this.length - 1; E >= 0 && (C !== 0 || E >= P); E--) {
                var L = this.words[E] | 0
                ;(this.words[E] = (C << (26 - O)) | (L >>> O)), (C = L & z)
              }
              return (
                j && C !== 0 && (j.words[j.length++] = C),
                this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
                this._strip()
              )
            }),
            (i.prototype.ishrn = function (w, v, A) {
              return r(this.negative === 0), this.iushrn(w, v, A)
            }),
            (i.prototype.shln = function (w) {
              return this.clone().ishln(w)
            }),
            (i.prototype.ushln = function (w) {
              return this.clone().iushln(w)
            }),
            (i.prototype.shrn = function (w) {
              return this.clone().ishrn(w)
            }),
            (i.prototype.ushrn = function (w) {
              return this.clone().iushrn(w)
            }),
            (i.prototype.testn = function (w) {
              r(typeof w == 'number' && w >= 0)
              var v = w % 26,
                A = (w - v) / 26,
                P = 1 << v
              if (this.length <= A) return !1
              var O = this.words[A]
              return !!(O & P)
            }),
            (i.prototype.imaskn = function (w) {
              r(typeof w == 'number' && w >= 0)
              var v = w % 26,
                A = (w - v) / 26
              if (
                (r(this.negative === 0, 'imaskn works only with positive numbers'),
                this.length <= A)
              )
                return this
              if ((v !== 0 && A++, (this.length = Math.min(A, this.length)), v !== 0)) {
                var P = 67108863 ^ ((67108863 >>> v) << v)
                this.words[this.length - 1] &= P
              }
              return this._strip()
            }),
            (i.prototype.maskn = function (w) {
              return this.clone().imaskn(w)
            }),
            (i.prototype.iaddn = function (w) {
              return (
                r(typeof w == 'number'),
                r(w < 67108864),
                w < 0
                  ? this.isubn(-w)
                  : this.negative !== 0
                    ? this.length === 1 && (this.words[0] | 0) <= w
                      ? ((this.words[0] = w - (this.words[0] | 0)), (this.negative = 0), this)
                      : ((this.negative = 0), this.isubn(w), (this.negative = 1), this)
                    : this._iaddn(w)
              )
            }),
            (i.prototype._iaddn = function (w) {
              this.words[0] += w
              for (var v = 0; v < this.length && this.words[v] >= 67108864; v++)
                (this.words[v] -= 67108864),
                  v === this.length - 1 ? (this.words[v + 1] = 1) : this.words[v + 1]++
              return (this.length = Math.max(this.length, v + 1)), this
            }),
            (i.prototype.isubn = function (w) {
              if ((r(typeof w == 'number'), r(w < 67108864), w < 0)) return this.iaddn(-w)
              if (this.negative !== 0)
                return (this.negative = 0), this.iaddn(w), (this.negative = 1), this
              if (((this.words[0] -= w), this.length === 1 && this.words[0] < 0))
                (this.words[0] = -this.words[0]), (this.negative = 1)
              else
                for (var v = 0; v < this.length && this.words[v] < 0; v++)
                  (this.words[v] += 67108864), (this.words[v + 1] -= 1)
              return this._strip()
            }),
            (i.prototype.addn = function (w) {
              return this.clone().iaddn(w)
            }),
            (i.prototype.subn = function (w) {
              return this.clone().isubn(w)
            }),
            (i.prototype.iabs = function () {
              return (this.negative = 0), this
            }),
            (i.prototype.abs = function () {
              return this.clone().iabs()
            }),
            (i.prototype._ishlnsubmul = function (w, v, A) {
              var P = w.length + A,
                O
              this._expand(P)
              var F,
                z = 0
              for (O = 0; O < w.length; O++) {
                F = (this.words[O + A] | 0) + z
                var j = (w.words[O] | 0) * v
                ;(F -= j & 67108863),
                  (z = (F >> 26) - ((j / 67108864) | 0)),
                  (this.words[O + A] = F & 67108863)
              }
              for (; O < this.length - A; O++)
                (F = (this.words[O + A] | 0) + z), (z = F >> 26), (this.words[O + A] = F & 67108863)
              if (z === 0) return this._strip()
              for (r(z === -1), z = 0, O = 0; O < this.length; O++)
                (F = -(this.words[O] | 0) + z), (z = F >> 26), (this.words[O] = F & 67108863)
              return (this.negative = 1), this._strip()
            }),
            (i.prototype._wordDiv = function (w, v) {
              var A = this.length - w.length,
                P = this.clone(),
                O = w,
                F = O.words[O.length - 1] | 0,
                z = this._countBits(F)
              ;(A = 26 - z),
                A !== 0 && ((O = O.ushln(A)), P.iushln(A), (F = O.words[O.length - 1] | 0))
              var j = P.length - O.length,
                E
              if (v !== 'mod') {
                ;(E = new i(null)), (E.length = j + 1), (E.words = new Array(E.length))
                for (var C = 0; C < E.length; C++) E.words[C] = 0
              }
              var L = P.clone()._ishlnsubmul(O, 1, j)
              L.negative === 0 && ((P = L), E && (E.words[j] = 1))
              for (var K = j - 1; K >= 0; K--) {
                var ee = (P.words[O.length + K] | 0) * 67108864 + (P.words[O.length + K - 1] | 0)
                for (
                  ee = Math.min((ee / F) | 0, 67108863), P._ishlnsubmul(O, ee, K);
                  P.negative !== 0;

                )
                  ee--, (P.negative = 0), P._ishlnsubmul(O, 1, K), P.isZero() || (P.negative ^= 1)
                E && (E.words[K] = ee)
              }
              return (
                E && E._strip(),
                P._strip(),
                v !== 'div' && A !== 0 && P.iushrn(A),
                { div: E || null, mod: P }
              )
            }),
            (i.prototype.divmod = function (w, v, A) {
              if ((r(!w.isZero()), this.isZero())) return { div: new i(0), mod: new i(0) }
              var P, O, F
              return this.negative !== 0 && w.negative === 0
                ? ((F = this.neg().divmod(w, v)),
                  v !== 'mod' && (P = F.div.neg()),
                  v !== 'div' && ((O = F.mod.neg()), A && O.negative !== 0 && O.iadd(w)),
                  { div: P, mod: O })
                : this.negative === 0 && w.negative !== 0
                  ? ((F = this.divmod(w.neg(), v)),
                    v !== 'mod' && (P = F.div.neg()),
                    { div: P, mod: F.mod })
                  : (this.negative & w.negative) !== 0
                    ? ((F = this.neg().divmod(w.neg(), v)),
                      v !== 'div' && ((O = F.mod.neg()), A && O.negative !== 0 && O.isub(w)),
                      { div: F.div, mod: O })
                    : w.length > this.length || this.cmp(w) < 0
                      ? { div: new i(0), mod: this }
                      : w.length === 1
                        ? v === 'div'
                          ? { div: this.divn(w.words[0]), mod: null }
                          : v === 'mod'
                            ? { div: null, mod: new i(this.modrn(w.words[0])) }
                            : { div: this.divn(w.words[0]), mod: new i(this.modrn(w.words[0])) }
                        : this._wordDiv(w, v)
            }),
            (i.prototype.div = function (w) {
              return this.divmod(w, 'div', !1).div
            }),
            (i.prototype.mod = function (w) {
              return this.divmod(w, 'mod', !1).mod
            }),
            (i.prototype.umod = function (w) {
              return this.divmod(w, 'mod', !0).mod
            }),
            (i.prototype.divRound = function (w) {
              var v = this.divmod(w)
              if (v.mod.isZero()) return v.div
              var A = v.div.negative !== 0 ? v.mod.isub(w) : v.mod,
                P = w.ushrn(1),
                O = w.andln(1),
                F = A.cmp(P)
              return F < 0 || (O === 1 && F === 0)
                ? v.div
                : v.div.negative !== 0
                  ? v.div.isubn(1)
                  : v.div.iaddn(1)
            }),
            (i.prototype.modrn = function (w) {
              var v = w < 0
              v && (w = -w), r(w <= 67108863)
              for (var A = (1 << 26) % w, P = 0, O = this.length - 1; O >= 0; O--)
                P = (A * P + (this.words[O] | 0)) % w
              return v ? -P : P
            }),
            (i.prototype.modn = function (w) {
              return this.modrn(w)
            }),
            (i.prototype.idivn = function (w) {
              var v = w < 0
              v && (w = -w), r(w <= 67108863)
              for (var A = 0, P = this.length - 1; P >= 0; P--) {
                var O = (this.words[P] | 0) + A * 67108864
                ;(this.words[P] = (O / w) | 0), (A = O % w)
              }
              return this._strip(), v ? this.ineg() : this
            }),
            (i.prototype.divn = function (w) {
              return this.clone().idivn(w)
            }),
            (i.prototype.egcd = function (w) {
              r(w.negative === 0), r(!w.isZero())
              var v = this,
                A = w.clone()
              v.negative !== 0 ? (v = v.umod(w)) : (v = v.clone())
              for (
                var P = new i(1), O = new i(0), F = new i(0), z = new i(1), j = 0;
                v.isEven() && A.isEven();

              )
                v.iushrn(1), A.iushrn(1), ++j
              for (var E = A.clone(), C = v.clone(); !v.isZero(); ) {
                for (var L = 0, K = 1; (v.words[0] & K) === 0 && L < 26; ++L, K <<= 1);
                if (L > 0)
                  for (v.iushrn(L); L-- > 0; )
                    (P.isOdd() || O.isOdd()) && (P.iadd(E), O.isub(C)), P.iushrn(1), O.iushrn(1)
                for (var ee = 0, oe = 1; (A.words[0] & oe) === 0 && ee < 26; ++ee, oe <<= 1);
                if (ee > 0)
                  for (A.iushrn(ee); ee-- > 0; )
                    (F.isOdd() || z.isOdd()) && (F.iadd(E), z.isub(C)), F.iushrn(1), z.iushrn(1)
                v.cmp(A) >= 0
                  ? (v.isub(A), P.isub(F), O.isub(z))
                  : (A.isub(v), F.isub(P), z.isub(O))
              }
              return { a: F, b: z, gcd: A.iushln(j) }
            }),
            (i.prototype._invmp = function (w) {
              r(w.negative === 0), r(!w.isZero())
              var v = this,
                A = w.clone()
              v.negative !== 0 ? (v = v.umod(w)) : (v = v.clone())
              for (
                var P = new i(1), O = new i(0), F = A.clone();
                v.cmpn(1) > 0 && A.cmpn(1) > 0;

              ) {
                for (var z = 0, j = 1; (v.words[0] & j) === 0 && z < 26; ++z, j <<= 1);
                if (z > 0) for (v.iushrn(z); z-- > 0; ) P.isOdd() && P.iadd(F), P.iushrn(1)
                for (var E = 0, C = 1; (A.words[0] & C) === 0 && E < 26; ++E, C <<= 1);
                if (E > 0) for (A.iushrn(E); E-- > 0; ) O.isOdd() && O.iadd(F), O.iushrn(1)
                v.cmp(A) >= 0 ? (v.isub(A), P.isub(O)) : (A.isub(v), O.isub(P))
              }
              var L
              return v.cmpn(1) === 0 ? (L = P) : (L = O), L.cmpn(0) < 0 && L.iadd(w), L
            }),
            (i.prototype.gcd = function (w) {
              if (this.isZero()) return w.abs()
              if (w.isZero()) return this.abs()
              var v = this.clone(),
                A = w.clone()
              ;(v.negative = 0), (A.negative = 0)
              for (var P = 0; v.isEven() && A.isEven(); P++) v.iushrn(1), A.iushrn(1)
              do {
                for (; v.isEven(); ) v.iushrn(1)
                for (; A.isEven(); ) A.iushrn(1)
                var O = v.cmp(A)
                if (O < 0) {
                  var F = v
                  ;(v = A), (A = F)
                } else if (O === 0 || A.cmpn(1) === 0) break
                v.isub(A)
              } while (!0)
              return A.iushln(P)
            }),
            (i.prototype.invm = function (w) {
              return this.egcd(w).a.umod(w)
            }),
            (i.prototype.isEven = function () {
              return (this.words[0] & 1) === 0
            }),
            (i.prototype.isOdd = function () {
              return (this.words[0] & 1) === 1
            }),
            (i.prototype.andln = function (w) {
              return this.words[0] & w
            }),
            (i.prototype.bincn = function (w) {
              r(typeof w == 'number')
              var v = w % 26,
                A = (w - v) / 26,
                P = 1 << v
              if (this.length <= A) return this._expand(A + 1), (this.words[A] |= P), this
              for (var O = P, F = A; O !== 0 && F < this.length; F++) {
                var z = this.words[F] | 0
                ;(z += O), (O = z >>> 26), (z &= 67108863), (this.words[F] = z)
              }
              return O !== 0 && ((this.words[F] = O), this.length++), this
            }),
            (i.prototype.isZero = function () {
              return this.length === 1 && this.words[0] === 0
            }),
            (i.prototype.cmpn = function (w) {
              var v = w < 0
              if (this.negative !== 0 && !v) return -1
              if (this.negative === 0 && v) return 1
              this._strip()
              var A
              if (this.length > 1) A = 1
              else {
                v && (w = -w), r(w <= 67108863, 'Number is too big')
                var P = this.words[0] | 0
                A = P === w ? 0 : P < w ? -1 : 1
              }
              return this.negative !== 0 ? -A | 0 : A
            }),
            (i.prototype.cmp = function (w) {
              if (this.negative !== 0 && w.negative === 0) return -1
              if (this.negative === 0 && w.negative !== 0) return 1
              var v = this.ucmp(w)
              return this.negative !== 0 ? -v | 0 : v
            }),
            (i.prototype.ucmp = function (w) {
              if (this.length > w.length) return 1
              if (this.length < w.length) return -1
              for (var v = 0, A = this.length - 1; A >= 0; A--) {
                var P = this.words[A] | 0,
                  O = w.words[A] | 0
                if (P !== O) {
                  P < O ? (v = -1) : P > O && (v = 1)
                  break
                }
              }
              return v
            }),
            (i.prototype.gtn = function (w) {
              return this.cmpn(w) === 1
            }),
            (i.prototype.gt = function (w) {
              return this.cmp(w) === 1
            }),
            (i.prototype.gten = function (w) {
              return this.cmpn(w) >= 0
            }),
            (i.prototype.gte = function (w) {
              return this.cmp(w) >= 0
            }),
            (i.prototype.ltn = function (w) {
              return this.cmpn(w) === -1
            }),
            (i.prototype.lt = function (w) {
              return this.cmp(w) === -1
            }),
            (i.prototype.lten = function (w) {
              return this.cmpn(w) <= 0
            }),
            (i.prototype.lte = function (w) {
              return this.cmp(w) <= 0
            }),
            (i.prototype.eqn = function (w) {
              return this.cmpn(w) === 0
            }),
            (i.prototype.eq = function (w) {
              return this.cmp(w) === 0
            }),
            (i.red = function (w) {
              return new D(w)
            }),
            (i.prototype.toRed = function (w) {
              return (
                r(!this.red, 'Already a number in reduction context'),
                r(this.negative === 0, 'red works only with positives'),
                w.convertTo(this)._forceRed(w)
              )
            }),
            (i.prototype.fromRed = function () {
              return (
                r(this.red, 'fromRed works only with numbers in reduction context'),
                this.red.convertFrom(this)
              )
            }),
            (i.prototype._forceRed = function (w) {
              return (this.red = w), this
            }),
            (i.prototype.forceRed = function (w) {
              return r(!this.red, 'Already a number in reduction context'), this._forceRed(w)
            }),
            (i.prototype.redAdd = function (w) {
              return r(this.red, 'redAdd works only with red numbers'), this.red.add(this, w)
            }),
            (i.prototype.redIAdd = function (w) {
              return r(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, w)
            }),
            (i.prototype.redSub = function (w) {
              return r(this.red, 'redSub works only with red numbers'), this.red.sub(this, w)
            }),
            (i.prototype.redISub = function (w) {
              return r(this.red, 'redISub works only with red numbers'), this.red.isub(this, w)
            }),
            (i.prototype.redShl = function (w) {
              return r(this.red, 'redShl works only with red numbers'), this.red.shl(this, w)
            }),
            (i.prototype.redMul = function (w) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, w),
                this.red.mul(this, w)
              )
            }),
            (i.prototype.redIMul = function (w) {
              return (
                r(this.red, 'redMul works only with red numbers'),
                this.red._verify2(this, w),
                this.red.imul(this, w)
              )
            }),
            (i.prototype.redSqr = function () {
              return (
                r(this.red, 'redSqr works only with red numbers'),
                this.red._verify1(this),
                this.red.sqr(this)
              )
            }),
            (i.prototype.redISqr = function () {
              return (
                r(this.red, 'redISqr works only with red numbers'),
                this.red._verify1(this),
                this.red.isqr(this)
              )
            }),
            (i.prototype.redSqrt = function () {
              return (
                r(this.red, 'redSqrt works only with red numbers'),
                this.red._verify1(this),
                this.red.sqrt(this)
              )
            }),
            (i.prototype.redInvm = function () {
              return (
                r(this.red, 'redInvm works only with red numbers'),
                this.red._verify1(this),
                this.red.invm(this)
              )
            }),
            (i.prototype.redNeg = function () {
              return (
                r(this.red, 'redNeg works only with red numbers'),
                this.red._verify1(this),
                this.red.neg(this)
              )
            }),
            (i.prototype.redPow = function (w) {
              return (
                r(this.red && !w.red, 'redPow(normalNum)'),
                this.red._verify1(this),
                this.red.pow(this, w)
              )
            })
          var N = { k256: null, p224: null, p192: null, p25519: null }
          function T(U, w) {
            ;(this.name = U),
              (this.p = new i(w, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new i(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp())
          }
          ;(T.prototype._tmp = function () {
            var w = new i(null)
            return (w.words = new Array(Math.ceil(this.n / 13))), w
          }),
            (T.prototype.ireduce = function (w) {
              var v = w,
                A
              do
                this.split(v, this.tmp),
                  (v = this.imulK(v)),
                  (v = v.iadd(this.tmp)),
                  (A = v.bitLength())
              while (A > this.n)
              var P = A < this.n ? -1 : v.ucmp(this.p)
              return (
                P === 0
                  ? ((v.words[0] = 0), (v.length = 1))
                  : P > 0
                    ? v.isub(this.p)
                    : v.strip !== void 0
                      ? v.strip()
                      : v._strip(),
                v
              )
            }),
            (T.prototype.split = function (w, v) {
              w.iushrn(this.n, 0, v)
            }),
            (T.prototype.imulK = function (w) {
              return w.imul(this.k)
            })
          function M() {
            T.call(
              this,
              'k256',
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
            )
          }
          s(M, T),
            (M.prototype.split = function (w, v) {
              for (var A = 4194303, P = Math.min(w.length, 9), O = 0; O < P; O++)
                v.words[O] = w.words[O]
              if (((v.length = P), w.length <= 9)) {
                ;(w.words[0] = 0), (w.length = 1)
                return
              }
              var F = w.words[9]
              for (v.words[v.length++] = F & A, O = 10; O < w.length; O++) {
                var z = w.words[O] | 0
                ;(w.words[O - 10] = ((z & A) << 4) | (F >>> 22)), (F = z)
              }
              ;(F >>>= 22),
                (w.words[O - 10] = F),
                F === 0 && w.length > 10 ? (w.length -= 10) : (w.length -= 9)
            }),
            (M.prototype.imulK = function (w) {
              ;(w.words[w.length] = 0), (w.words[w.length + 1] = 0), (w.length += 2)
              for (var v = 0, A = 0; A < w.length; A++) {
                var P = w.words[A] | 0
                ;(v += P * 977), (w.words[A] = v & 67108863), (v = P * 64 + ((v / 67108864) | 0))
              }
              return (
                w.words[w.length - 1] === 0 &&
                  (w.length--, w.words[w.length - 1] === 0 && w.length--),
                w
              )
            })
          function H() {
            T.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001')
          }
          s(H, T)
          function B() {
            T.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff')
          }
          s(B, T)
          function $() {
            T.call(
              this,
              '25519',
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
            )
          }
          s($, T),
            ($.prototype.imulK = function (w) {
              for (var v = 0, A = 0; A < w.length; A++) {
                var P = (w.words[A] | 0) * 19 + v,
                  O = P & 67108863
                ;(P >>>= 26), (w.words[A] = O), (v = P)
              }
              return v !== 0 && (w.words[w.length++] = v), w
            }),
            (i._prime = function (w) {
              if (N[w]) return N[w]
              var v
              if (w === 'k256') v = new M()
              else if (w === 'p224') v = new H()
              else if (w === 'p192') v = new B()
              else if (w === 'p25519') v = new $()
              else throw new Error('Unknown prime ' + w)
              return (N[w] = v), v
            })
          function D(U) {
            if (typeof U == 'string') {
              var w = i._prime(U)
              ;(this.m = w.p), (this.prime = w)
            } else r(U.gtn(1), 'modulus must be greater than 1'), (this.m = U), (this.prime = null)
          }
          ;(D.prototype._verify1 = function (w) {
            r(w.negative === 0, 'red works only with positives'),
              r(w.red, 'red works only with red numbers')
          }),
            (D.prototype._verify2 = function (w, v) {
              r((w.negative | v.negative) === 0, 'red works only with positives'),
                r(w.red && w.red === v.red, 'red works only with red numbers')
            }),
            (D.prototype.imod = function (w) {
              return this.prime
                ? this.prime.ireduce(w)._forceRed(this)
                : (l(w, w.umod(this.m)._forceRed(this)), w)
            }),
            (D.prototype.neg = function (w) {
              return w.isZero() ? w.clone() : this.m.sub(w)._forceRed(this)
            }),
            (D.prototype.add = function (w, v) {
              this._verify2(w, v)
              var A = w.add(v)
              return A.cmp(this.m) >= 0 && A.isub(this.m), A._forceRed(this)
            }),
            (D.prototype.iadd = function (w, v) {
              this._verify2(w, v)
              var A = w.iadd(v)
              return A.cmp(this.m) >= 0 && A.isub(this.m), A
            }),
            (D.prototype.sub = function (w, v) {
              this._verify2(w, v)
              var A = w.sub(v)
              return A.cmpn(0) < 0 && A.iadd(this.m), A._forceRed(this)
            }),
            (D.prototype.isub = function (w, v) {
              this._verify2(w, v)
              var A = w.isub(v)
              return A.cmpn(0) < 0 && A.iadd(this.m), A
            }),
            (D.prototype.shl = function (w, v) {
              return this._verify1(w), this.imod(w.ushln(v))
            }),
            (D.prototype.imul = function (w, v) {
              return this._verify2(w, v), this.imod(w.imul(v))
            }),
            (D.prototype.mul = function (w, v) {
              return this._verify2(w, v), this.imod(w.mul(v))
            }),
            (D.prototype.isqr = function (w) {
              return this.imul(w, w.clone())
            }),
            (D.prototype.sqr = function (w) {
              return this.mul(w, w)
            }),
            (D.prototype.sqrt = function (w) {
              if (w.isZero()) return w.clone()
              var v = this.m.andln(3)
              if ((r(v % 2 === 1), v === 3)) {
                var A = this.m.add(new i(1)).iushrn(2)
                return this.pow(w, A)
              }
              for (var P = this.m.subn(1), O = 0; !P.isZero() && P.andln(1) === 0; )
                O++, P.iushrn(1)
              r(!P.isZero())
              var F = new i(1).toRed(this),
                z = F.redNeg(),
                j = this.m.subn(1).iushrn(1),
                E = this.m.bitLength()
              for (E = new i(2 * E * E).toRed(this); this.pow(E, j).cmp(z) !== 0; ) E.redIAdd(z)
              for (
                var C = this.pow(E, P),
                  L = this.pow(w, P.addn(1).iushrn(1)),
                  K = this.pow(w, P),
                  ee = O;
                K.cmp(F) !== 0;

              ) {
                for (var oe = K, fe = 0; oe.cmp(F) !== 0; fe++) oe = oe.redSqr()
                r(fe < ee)
                var ve = this.pow(C, new i(1).iushln(ee - fe - 1))
                ;(L = L.redMul(ve)), (C = ve.redSqr()), (K = K.redMul(C)), (ee = fe)
              }
              return L
            }),
            (D.prototype.invm = function (w) {
              var v = w._invmp(this.m)
              return v.negative !== 0 ? ((v.negative = 0), this.imod(v).redNeg()) : this.imod(v)
            }),
            (D.prototype.pow = function (w, v) {
              if (v.isZero()) return new i(1).toRed(this)
              if (v.cmpn(1) === 0) return w.clone()
              var A = 4,
                P = new Array(1 << A)
              ;(P[0] = new i(1).toRed(this)), (P[1] = w)
              for (var O = 2; O < P.length; O++) P[O] = this.mul(P[O - 1], w)
              var F = P[0],
                z = 0,
                j = 0,
                E = v.bitLength() % 26
              for (E === 0 && (E = 26), O = v.length - 1; O >= 0; O--) {
                for (var C = v.words[O], L = E - 1; L >= 0; L--) {
                  var K = (C >> L) & 1
                  if ((F !== P[0] && (F = this.sqr(F)), K === 0 && z === 0)) {
                    j = 0
                    continue
                  }
                  ;(z <<= 1),
                    (z |= K),
                    j++,
                    !(j !== A && (O !== 0 || L !== 0)) &&
                      ((F = this.mul(F, P[z])), (j = 0), (z = 0))
                }
                E = 26
              }
              return F
            }),
            (D.prototype.convertTo = function (w) {
              var v = w.umod(this.m)
              return v === w ? v.clone() : v
            }),
            (D.prototype.convertFrom = function (w) {
              var v = w.clone()
              return (v.red = null), v
            }),
            (i.mont = function (w) {
              return new W(w)
            })
          function W(U) {
            D.call(this, U),
              (this.shift = this.m.bitLength()),
              this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new i(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv))
          }
          s(W, D),
            (W.prototype.convertTo = function (w) {
              return this.imod(w.ushln(this.shift))
            }),
            (W.prototype.convertFrom = function (w) {
              var v = this.imod(w.mul(this.rinv))
              return (v.red = null), v
            }),
            (W.prototype.imul = function (w, v) {
              if (w.isZero() || v.isZero()) return (w.words[0] = 0), (w.length = 1), w
              var A = w.imul(v),
                P = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                O = A.isub(P).iushrn(this.shift),
                F = O
              return (
                O.cmp(this.m) >= 0 ? (F = O.isub(this.m)) : O.cmpn(0) < 0 && (F = O.iadd(this.m)),
                F._forceRed(this)
              )
            }),
            (W.prototype.mul = function (w, v) {
              if (w.isZero() || v.isZero()) return new i(0)._forceRed(this)
              var A = w.mul(v),
                P = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                O = A.isub(P).iushrn(this.shift),
                F = O
              return (
                O.cmp(this.m) >= 0 ? (F = O.isub(this.m)) : O.cmpn(0) < 0 && (F = O.iadd(this.m)),
                F._forceRed(this)
              )
            }),
            (W.prototype.invm = function (w) {
              var v = this.imod(w._invmp(this.m).mul(this.r2))
              return v._forceRed(this)
            })
        })(t, Ole)
      })(zg)),
    zg.exports
  )
}
var Ble = X8()
const sT = _u(Ble)
var bg = { exports: {} },
  Tb = {}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var iT
function Dle() {
  return (
    iT ||
      ((iT = 1),
      (function (t) {
        const e = P0(),
          n = Y3(),
          r =
            typeof Symbol == 'function' && typeof Symbol.for == 'function'
              ? Symbol.for('nodejs.util.inspect.custom')
              : null
        ;(t.Buffer = a), (t.SlowBuffer = x), (t.INSPECT_MAX_BYTES = 50)
        const s = 2147483647
        ;(t.kMaxLength = s),
          (a.TYPED_ARRAY_SUPPORT = i()),
          !a.TYPED_ARRAY_SUPPORT &&
            typeof console < 'u' &&
            typeof console.error == 'function' &&
            console.error(
              'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
            )
        function i() {
          try {
            const S = new Uint8Array(1),
              f = {
                foo: function () {
                  return 42
                }
              }
            return (
              Object.setPrototypeOf(f, Uint8Array.prototype),
              Object.setPrototypeOf(S, f),
              S.foo() === 42
            )
          } catch {
            return !1
          }
        }
        Object.defineProperty(a.prototype, 'parent', {
          enumerable: !0,
          get: function () {
            if (a.isBuffer(this)) return this.buffer
          }
        }),
          Object.defineProperty(a.prototype, 'offset', {
            enumerable: !0,
            get: function () {
              if (a.isBuffer(this)) return this.byteOffset
            }
          })
        function o(S) {
          if (S > s) throw new RangeError('The value "' + S + '" is invalid for option "size"')
          const f = new Uint8Array(S)
          return Object.setPrototypeOf(f, a.prototype), f
        }
        function a(S, f, g) {
          if (typeof S == 'number') {
            if (typeof f == 'string')
              throw new TypeError(
                'The "string" argument must be of type string. Received type number'
              )
            return d(S)
          }
          return c(S, f, g)
        }
        a.poolSize = 8192
        function c(S, f, g) {
          if (typeof S == 'string') return h(S, f)
          if (ArrayBuffer.isView(S)) return y(S)
          if (S == null)
            throw new TypeError(
              'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
                typeof S
            )
          if (
            he(S, ArrayBuffer) ||
            (S && he(S.buffer, ArrayBuffer)) ||
            (typeof SharedArrayBuffer < 'u' &&
              (he(S, SharedArrayBuffer) || (S && he(S.buffer, SharedArrayBuffer))))
          )
            return m(S, f, g)
          if (typeof S == 'number')
            throw new TypeError(
              'The "value" argument must not be of type number. Received type number'
            )
          const k = S.valueOf && S.valueOf()
          if (k != null && k !== S) return a.from(k, f, g)
          const q = b(S)
          if (q) return q
          if (
            typeof Symbol < 'u' &&
            Symbol.toPrimitive != null &&
            typeof S[Symbol.toPrimitive] == 'function'
          )
            return a.from(S[Symbol.toPrimitive]('string'), f, g)
          throw new TypeError(
            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
              typeof S
          )
        }
        ;(a.from = function (S, f, g) {
          return c(S, f, g)
        }),
          Object.setPrototypeOf(a.prototype, Uint8Array.prototype),
          Object.setPrototypeOf(a, Uint8Array)
        function u(S) {
          if (typeof S != 'number') throw new TypeError('"size" argument must be of type number')
          if (S < 0) throw new RangeError('The value "' + S + '" is invalid for option "size"')
        }
        function l(S, f, g) {
          return (
            u(S),
            S <= 0
              ? o(S)
              : f !== void 0
                ? typeof g == 'string'
                  ? o(S).fill(f, g)
                  : o(S).fill(f)
                : o(S)
          )
        }
        a.alloc = function (S, f, g) {
          return l(S, f, g)
        }
        function d(S) {
          return u(S), o(S < 0 ? 0 : I(S) | 0)
        }
        ;(a.allocUnsafe = function (S) {
          return d(S)
        }),
          (a.allocUnsafeSlow = function (S) {
            return d(S)
          })
        function h(S, f) {
          if (((typeof f != 'string' || f === '') && (f = 'utf8'), !a.isEncoding(f)))
            throw new TypeError('Unknown encoding: ' + f)
          const g = _(S, f) | 0
          let k = o(g)
          const q = k.write(S, f)
          return q !== g && (k = k.slice(0, q)), k
        }
        function p(S) {
          const f = S.length < 0 ? 0 : I(S.length) | 0,
            g = o(f)
          for (let k = 0; k < f; k += 1) g[k] = S[k] & 255
          return g
        }
        function y(S) {
          if (he(S, Uint8Array)) {
            const f = new Uint8Array(S)
            return m(f.buffer, f.byteOffset, f.byteLength)
          }
          return p(S)
        }
        function m(S, f, g) {
          if (f < 0 || S.byteLength < f)
            throw new RangeError('"offset" is outside of buffer bounds')
          if (S.byteLength < f + (g || 0))
            throw new RangeError('"length" is outside of buffer bounds')
          let k
          return (
            f === void 0 && g === void 0
              ? (k = new Uint8Array(S))
              : g === void 0
                ? (k = new Uint8Array(S, f))
                : (k = new Uint8Array(S, f, g)),
            Object.setPrototypeOf(k, a.prototype),
            k
          )
        }
        function b(S) {
          if (a.isBuffer(S)) {
            const f = I(S.length) | 0,
              g = o(f)
            return g.length === 0 || S.copy(g, 0, 0, f), g
          }
          if (S.length !== void 0) return typeof S.length != 'number' || Ne(S.length) ? o(0) : p(S)
          if (S.type === 'Buffer' && Array.isArray(S.data)) return p(S.data)
        }
        function I(S) {
          if (S >= s)
            throw new RangeError(
              'Attempt to allocate Buffer larger than maximum size: 0x' + s.toString(16) + ' bytes'
            )
          return S | 0
        }
        function x(S) {
          return +S != S && (S = 0), a.alloc(+S)
        }
        ;(a.isBuffer = function (f) {
          return f != null && f._isBuffer === !0 && f !== a.prototype
        }),
          (a.compare = function (f, g) {
            if (
              (he(f, Uint8Array) && (f = a.from(f, f.offset, f.byteLength)),
              he(g, Uint8Array) && (g = a.from(g, g.offset, g.byteLength)),
              !a.isBuffer(f) || !a.isBuffer(g))
            )
              throw new TypeError(
                'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
              )
            if (f === g) return 0
            let k = f.length,
              q = g.length
            for (let V = 0, Y = Math.min(k, q); V < Y; ++V)
              if (f[V] !== g[V]) {
                ;(k = f[V]), (q = g[V])
                break
              }
            return k < q ? -1 : q < k ? 1 : 0
          }),
          (a.isEncoding = function (f) {
            switch (String(f).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'latin1':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return !0
              default:
                return !1
            }
          }),
          (a.concat = function (f, g) {
            if (!Array.isArray(f))
              throw new TypeError('"list" argument must be an Array of Buffers')
            if (f.length === 0) return a.alloc(0)
            let k
            if (g === void 0) for (g = 0, k = 0; k < f.length; ++k) g += f[k].length
            const q = a.allocUnsafe(g)
            let V = 0
            for (k = 0; k < f.length; ++k) {
              const Y = f[k]
              if (he(Y, Uint8Array)) Uint8Array.prototype.set.call(q, Y, V)
              else if (a.isBuffer(Y)) Y.copy(q, V)
              else throw new TypeError('"list" argument must be an Array of Buffers')
              V += Y.length
            }
            return q
          })
        function _(S, f) {
          if (a.isBuffer(S)) return S.length
          if (ArrayBuffer.isView(S) || he(S, ArrayBuffer)) return S.byteLength
          if (typeof S != 'string')
            throw new TypeError(
              'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                typeof S
            )
          const g = S.length,
            k = arguments.length > 2 && arguments[2] === !0
          if (!k && g === 0) return 0
          let q = !1
          for (;;)
            switch (f) {
              case 'ascii':
              case 'latin1':
              case 'binary':
                return g
              case 'utf8':
              case 'utf-8':
                return ue(S).length
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return g * 2
              case 'hex':
                return g >>> 1
              case 'base64':
                return we(S).length
              default:
                if (q) return k ? -1 : ue(S).length
                ;(f = ('' + f).toLowerCase()), (q = !0)
            }
        }
        a.byteLength = _
        function R(S, f, g) {
          let k = !1
          if (
            ((f === void 0 || f < 0) && (f = 0),
            f > this.length ||
              ((g === void 0 || g > this.length) && (g = this.length), g <= 0) ||
              ((g >>>= 0), (f >>>= 0), g <= f))
          )
            return ''
          for (S || (S = 'utf8'); ; )
            switch (S) {
              case 'hex':
                return F(this, f, g)
              case 'utf8':
              case 'utf-8':
                return w(this, f, g)
              case 'ascii':
                return P(this, f, g)
              case 'latin1':
              case 'binary':
                return O(this, f, g)
              case 'base64':
                return U(this, f, g)
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return z(this, f, g)
              default:
                if (k) throw new TypeError('Unknown encoding: ' + S)
                ;(S = (S + '').toLowerCase()), (k = !0)
            }
        }
        a.prototype._isBuffer = !0
        function N(S, f, g) {
          const k = S[f]
          ;(S[f] = S[g]), (S[g] = k)
        }
        ;(a.prototype.swap16 = function () {
          const f = this.length
          if (f % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')
          for (let g = 0; g < f; g += 2) N(this, g, g + 1)
          return this
        }),
          (a.prototype.swap32 = function () {
            const f = this.length
            if (f % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')
            for (let g = 0; g < f; g += 4) N(this, g, g + 3), N(this, g + 1, g + 2)
            return this
          }),
          (a.prototype.swap64 = function () {
            const f = this.length
            if (f % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')
            for (let g = 0; g < f; g += 8)
              N(this, g, g + 7), N(this, g + 1, g + 6), N(this, g + 2, g + 5), N(this, g + 3, g + 4)
            return this
          }),
          (a.prototype.toString = function () {
            const f = this.length
            return f === 0 ? '' : arguments.length === 0 ? w(this, 0, f) : R.apply(this, arguments)
          }),
          (a.prototype.toLocaleString = a.prototype.toString),
          (a.prototype.equals = function (f) {
            if (!a.isBuffer(f)) throw new TypeError('Argument must be a Buffer')
            return this === f ? !0 : a.compare(this, f) === 0
          }),
          (a.prototype.inspect = function () {
            let f = ''
            const g = t.INSPECT_MAX_BYTES
            return (
              (f = this.toString('hex', 0, g)
                .replace(/(.{2})/g, '$1 ')
                .trim()),
              this.length > g && (f += ' ... '),
              '<Buffer ' + f + '>'
            )
          }),
          r && (a.prototype[r] = a.prototype.inspect),
          (a.prototype.compare = function (f, g, k, q, V) {
            if ((he(f, Uint8Array) && (f = a.from(f, f.offset, f.byteLength)), !a.isBuffer(f)))
              throw new TypeError(
                'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                  typeof f
              )
            if (
              (g === void 0 && (g = 0),
              k === void 0 && (k = f ? f.length : 0),
              q === void 0 && (q = 0),
              V === void 0 && (V = this.length),
              g < 0 || k > f.length || q < 0 || V > this.length)
            )
              throw new RangeError('out of range index')
            if (q >= V && g >= k) return 0
            if (q >= V) return -1
            if (g >= k) return 1
            if (((g >>>= 0), (k >>>= 0), (q >>>= 0), (V >>>= 0), this === f)) return 0
            let Y = V - q,
              ke = k - g
            const Ve = Math.min(Y, ke),
              Oe = this.slice(q, V),
              st = f.slice(g, k)
            for (let Ue = 0; Ue < Ve; ++Ue)
              if (Oe[Ue] !== st[Ue]) {
                ;(Y = Oe[Ue]), (ke = st[Ue])
                break
              }
            return Y < ke ? -1 : ke < Y ? 1 : 0
          })
        function T(S, f, g, k, q) {
          if (S.length === 0) return -1
          if (
            (typeof g == 'string'
              ? ((k = g), (g = 0))
              : g > 2147483647
                ? (g = 2147483647)
                : g < -2147483648 && (g = -2147483648),
            (g = +g),
            Ne(g) && (g = q ? 0 : S.length - 1),
            g < 0 && (g = S.length + g),
            g >= S.length)
          ) {
            if (q) return -1
            g = S.length - 1
          } else if (g < 0)
            if (q) g = 0
            else return -1
          if ((typeof f == 'string' && (f = a.from(f, k)), a.isBuffer(f)))
            return f.length === 0 ? -1 : M(S, f, g, k, q)
          if (typeof f == 'number')
            return (
              (f = f & 255),
              typeof Uint8Array.prototype.indexOf == 'function'
                ? q
                  ? Uint8Array.prototype.indexOf.call(S, f, g)
                  : Uint8Array.prototype.lastIndexOf.call(S, f, g)
                : M(S, [f], g, k, q)
            )
          throw new TypeError('val must be string, number or Buffer')
        }
        function M(S, f, g, k, q) {
          let V = 1,
            Y = S.length,
            ke = f.length
          if (
            k !== void 0 &&
            ((k = String(k).toLowerCase()),
            k === 'ucs2' || k === 'ucs-2' || k === 'utf16le' || k === 'utf-16le')
          ) {
            if (S.length < 2 || f.length < 2) return -1
            ;(V = 2), (Y /= 2), (ke /= 2), (g /= 2)
          }
          function Ve(st, Ue) {
            return V === 1 ? st[Ue] : st.readUInt16BE(Ue * V)
          }
          let Oe
          if (q) {
            let st = -1
            for (Oe = g; Oe < Y; Oe++)
              if (Ve(S, Oe) === Ve(f, st === -1 ? 0 : Oe - st)) {
                if ((st === -1 && (st = Oe), Oe - st + 1 === ke)) return st * V
              } else st !== -1 && (Oe -= Oe - st), (st = -1)
          } else
            for (g + ke > Y && (g = Y - ke), Oe = g; Oe >= 0; Oe--) {
              let st = !0
              for (let Ue = 0; Ue < ke; Ue++)
                if (Ve(S, Oe + Ue) !== Ve(f, Ue)) {
                  st = !1
                  break
                }
              if (st) return Oe
            }
          return -1
        }
        ;(a.prototype.includes = function (f, g, k) {
          return this.indexOf(f, g, k) !== -1
        }),
          (a.prototype.indexOf = function (f, g, k) {
            return T(this, f, g, k, !0)
          }),
          (a.prototype.lastIndexOf = function (f, g, k) {
            return T(this, f, g, k, !1)
          })
        function H(S, f, g, k) {
          g = Number(g) || 0
          const q = S.length - g
          k ? ((k = Number(k)), k > q && (k = q)) : (k = q)
          const V = f.length
          k > V / 2 && (k = V / 2)
          let Y
          for (Y = 0; Y < k; ++Y) {
            const ke = parseInt(f.substr(Y * 2, 2), 16)
            if (Ne(ke)) return Y
            S[g + Y] = ke
          }
          return Y
        }
        function B(S, f, g, k) {
          return ge(ue(f, S.length - g), S, g, k)
        }
        function $(S, f, g, k) {
          return ge(de(f), S, g, k)
        }
        function D(S, f, g, k) {
          return ge(we(f), S, g, k)
        }
        function W(S, f, g, k) {
          return ge(Te(f, S.length - g), S, g, k)
        }
        ;(a.prototype.write = function (f, g, k, q) {
          if (g === void 0) (q = 'utf8'), (k = this.length), (g = 0)
          else if (k === void 0 && typeof g == 'string') (q = g), (k = this.length), (g = 0)
          else if (isFinite(g))
            (g = g >>> 0),
              isFinite(k) ? ((k = k >>> 0), q === void 0 && (q = 'utf8')) : ((q = k), (k = void 0))
          else
            throw new Error(
              'Buffer.write(string, encoding, offset[, length]) is no longer supported'
            )
          const V = this.length - g
          if (
            ((k === void 0 || k > V) && (k = V),
            (f.length > 0 && (k < 0 || g < 0)) || g > this.length)
          )
            throw new RangeError('Attempt to write outside buffer bounds')
          q || (q = 'utf8')
          let Y = !1
          for (;;)
            switch (q) {
              case 'hex':
                return H(this, f, g, k)
              case 'utf8':
              case 'utf-8':
                return B(this, f, g, k)
              case 'ascii':
              case 'latin1':
              case 'binary':
                return $(this, f, g, k)
              case 'base64':
                return D(this, f, g, k)
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return W(this, f, g, k)
              default:
                if (Y) throw new TypeError('Unknown encoding: ' + q)
                ;(q = ('' + q).toLowerCase()), (Y = !0)
            }
        }),
          (a.prototype.toJSON = function () {
            return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) }
          })
        function U(S, f, g) {
          return f === 0 && g === S.length ? e.fromByteArray(S) : e.fromByteArray(S.slice(f, g))
        }
        function w(S, f, g) {
          g = Math.min(S.length, g)
          const k = []
          let q = f
          for (; q < g; ) {
            const V = S[q]
            let Y = null,
              ke = V > 239 ? 4 : V > 223 ? 3 : V > 191 ? 2 : 1
            if (q + ke <= g) {
              let Ve, Oe, st, Ue
              switch (ke) {
                case 1:
                  V < 128 && (Y = V)
                  break
                case 2:
                  ;(Ve = S[q + 1]),
                    (Ve & 192) === 128 && ((Ue = ((V & 31) << 6) | (Ve & 63)), Ue > 127 && (Y = Ue))
                  break
                case 3:
                  ;(Ve = S[q + 1]),
                    (Oe = S[q + 2]),
                    (Ve & 192) === 128 &&
                      (Oe & 192) === 128 &&
                      ((Ue = ((V & 15) << 12) | ((Ve & 63) << 6) | (Oe & 63)),
                      Ue > 2047 && (Ue < 55296 || Ue > 57343) && (Y = Ue))
                  break
                case 4:
                  ;(Ve = S[q + 1]),
                    (Oe = S[q + 2]),
                    (st = S[q + 3]),
                    (Ve & 192) === 128 &&
                      (Oe & 192) === 128 &&
                      (st & 192) === 128 &&
                      ((Ue = ((V & 15) << 18) | ((Ve & 63) << 12) | ((Oe & 63) << 6) | (st & 63)),
                      Ue > 65535 && Ue < 1114112 && (Y = Ue))
              }
            }
            Y === null
              ? ((Y = 65533), (ke = 1))
              : Y > 65535 &&
                ((Y -= 65536), k.push(((Y >>> 10) & 1023) | 55296), (Y = 56320 | (Y & 1023))),
              k.push(Y),
              (q += ke)
          }
          return A(k)
        }
        const v = 4096
        function A(S) {
          const f = S.length
          if (f <= v) return String.fromCharCode.apply(String, S)
          let g = '',
            k = 0
          for (; k < f; ) g += String.fromCharCode.apply(String, S.slice(k, (k += v)))
          return g
        }
        function P(S, f, g) {
          let k = ''
          g = Math.min(S.length, g)
          for (let q = f; q < g; ++q) k += String.fromCharCode(S[q] & 127)
          return k
        }
        function O(S, f, g) {
          let k = ''
          g = Math.min(S.length, g)
          for (let q = f; q < g; ++q) k += String.fromCharCode(S[q])
          return k
        }
        function F(S, f, g) {
          const k = S.length
          ;(!f || f < 0) && (f = 0), (!g || g < 0 || g > k) && (g = k)
          let q = ''
          for (let V = f; V < g; ++V) q += _e[S[V]]
          return q
        }
        function z(S, f, g) {
          const k = S.slice(f, g)
          let q = ''
          for (let V = 0; V < k.length - 1; V += 2) q += String.fromCharCode(k[V] + k[V + 1] * 256)
          return q
        }
        a.prototype.slice = function (f, g) {
          const k = this.length
          ;(f = ~~f),
            (g = g === void 0 ? k : ~~g),
            f < 0 ? ((f += k), f < 0 && (f = 0)) : f > k && (f = k),
            g < 0 ? ((g += k), g < 0 && (g = 0)) : g > k && (g = k),
            g < f && (g = f)
          const q = this.subarray(f, g)
          return Object.setPrototypeOf(q, a.prototype), q
        }
        function j(S, f, g) {
          if (S % 1 !== 0 || S < 0) throw new RangeError('offset is not uint')
          if (S + f > g) throw new RangeError('Trying to access beyond buffer length')
        }
        ;(a.prototype.readUintLE = a.prototype.readUIntLE =
          function (f, g, k) {
            ;(f = f >>> 0), (g = g >>> 0), k || j(f, g, this.length)
            let q = this[f],
              V = 1,
              Y = 0
            for (; ++Y < g && (V *= 256); ) q += this[f + Y] * V
            return q
          }),
          (a.prototype.readUintBE = a.prototype.readUIntBE =
            function (f, g, k) {
              ;(f = f >>> 0), (g = g >>> 0), k || j(f, g, this.length)
              let q = this[f + --g],
                V = 1
              for (; g > 0 && (V *= 256); ) q += this[f + --g] * V
              return q
            }),
          (a.prototype.readUint8 = a.prototype.readUInt8 =
            function (f, g) {
              return (f = f >>> 0), g || j(f, 1, this.length), this[f]
            }),
          (a.prototype.readUint16LE = a.prototype.readUInt16LE =
            function (f, g) {
              return (f = f >>> 0), g || j(f, 2, this.length), this[f] | (this[f + 1] << 8)
            }),
          (a.prototype.readUint16BE = a.prototype.readUInt16BE =
            function (f, g) {
              return (f = f >>> 0), g || j(f, 2, this.length), (this[f] << 8) | this[f + 1]
            }),
          (a.prototype.readUint32LE = a.prototype.readUInt32LE =
            function (f, g) {
              return (
                (f = f >>> 0),
                g || j(f, 4, this.length),
                (this[f] | (this[f + 1] << 8) | (this[f + 2] << 16)) + this[f + 3] * 16777216
              )
            }),
          (a.prototype.readUint32BE = a.prototype.readUInt32BE =
            function (f, g) {
              return (
                (f = f >>> 0),
                g || j(f, 4, this.length),
                this[f] * 16777216 + ((this[f + 1] << 16) | (this[f + 2] << 8) | this[f + 3])
              )
            }),
          (a.prototype.readBigUInt64LE = Be(function (f) {
            ;(f = f >>> 0), Z(f, 'offset')
            const g = this[f],
              k = this[f + 7]
            ;(g === void 0 || k === void 0) && X(f, this.length - 8)
            const q = g + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24,
              V = this[++f] + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + k * 2 ** 24
            return BigInt(q) + (BigInt(V) << BigInt(32))
          })),
          (a.prototype.readBigUInt64BE = Be(function (f) {
            ;(f = f >>> 0), Z(f, 'offset')
            const g = this[f],
              k = this[f + 7]
            ;(g === void 0 || k === void 0) && X(f, this.length - 8)
            const q = g * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f],
              V = this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + k
            return (BigInt(q) << BigInt(32)) + BigInt(V)
          })),
          (a.prototype.readIntLE = function (f, g, k) {
            ;(f = f >>> 0), (g = g >>> 0), k || j(f, g, this.length)
            let q = this[f],
              V = 1,
              Y = 0
            for (; ++Y < g && (V *= 256); ) q += this[f + Y] * V
            return (V *= 128), q >= V && (q -= Math.pow(2, 8 * g)), q
          }),
          (a.prototype.readIntBE = function (f, g, k) {
            ;(f = f >>> 0), (g = g >>> 0), k || j(f, g, this.length)
            let q = g,
              V = 1,
              Y = this[f + --q]
            for (; q > 0 && (V *= 256); ) Y += this[f + --q] * V
            return (V *= 128), Y >= V && (Y -= Math.pow(2, 8 * g)), Y
          }),
          (a.prototype.readInt8 = function (f, g) {
            return (
              (f = f >>> 0),
              g || j(f, 1, this.length),
              this[f] & 128 ? (255 - this[f] + 1) * -1 : this[f]
            )
          }),
          (a.prototype.readInt16LE = function (f, g) {
            ;(f = f >>> 0), g || j(f, 2, this.length)
            const k = this[f] | (this[f + 1] << 8)
            return k & 32768 ? k | 4294901760 : k
          }),
          (a.prototype.readInt16BE = function (f, g) {
            ;(f = f >>> 0), g || j(f, 2, this.length)
            const k = this[f + 1] | (this[f] << 8)
            return k & 32768 ? k | 4294901760 : k
          }),
          (a.prototype.readInt32LE = function (f, g) {
            return (
              (f = f >>> 0),
              g || j(f, 4, this.length),
              this[f] | (this[f + 1] << 8) | (this[f + 2] << 16) | (this[f + 3] << 24)
            )
          }),
          (a.prototype.readInt32BE = function (f, g) {
            return (
              (f = f >>> 0),
              g || j(f, 4, this.length),
              (this[f] << 24) | (this[f + 1] << 16) | (this[f + 2] << 8) | this[f + 3]
            )
          }),
          (a.prototype.readBigInt64LE = Be(function (f) {
            ;(f = f >>> 0), Z(f, 'offset')
            const g = this[f],
              k = this[f + 7]
            ;(g === void 0 || k === void 0) && X(f, this.length - 8)
            const q = this[f + 4] + this[f + 5] * 2 ** 8 + this[f + 6] * 2 ** 16 + (k << 24)
            return (
              (BigInt(q) << BigInt(32)) +
              BigInt(g + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24)
            )
          })),
          (a.prototype.readBigInt64BE = Be(function (f) {
            ;(f = f >>> 0), Z(f, 'offset')
            const g = this[f],
              k = this[f + 7]
            ;(g === void 0 || k === void 0) && X(f, this.length - 8)
            const q = (g << 24) + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f]
            return (
              (BigInt(q) << BigInt(32)) +
              BigInt(this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + k)
            )
          })),
          (a.prototype.readFloatLE = function (f, g) {
            return (f = f >>> 0), g || j(f, 4, this.length), n.read(this, f, !0, 23, 4)
          }),
          (a.prototype.readFloatBE = function (f, g) {
            return (f = f >>> 0), g || j(f, 4, this.length), n.read(this, f, !1, 23, 4)
          }),
          (a.prototype.readDoubleLE = function (f, g) {
            return (f = f >>> 0), g || j(f, 8, this.length), n.read(this, f, !0, 52, 8)
          }),
          (a.prototype.readDoubleBE = function (f, g) {
            return (f = f >>> 0), g || j(f, 8, this.length), n.read(this, f, !1, 52, 8)
          })
        function E(S, f, g, k, q, V) {
          if (!a.isBuffer(S)) throw new TypeError('"buffer" argument must be a Buffer instance')
          if (f > q || f < V) throw new RangeError('"value" argument is out of bounds')
          if (g + k > S.length) throw new RangeError('Index out of range')
        }
        ;(a.prototype.writeUintLE = a.prototype.writeUIntLE =
          function (f, g, k, q) {
            if (((f = +f), (g = g >>> 0), (k = k >>> 0), !q)) {
              const ke = Math.pow(2, 8 * k) - 1
              E(this, f, g, k, ke, 0)
            }
            let V = 1,
              Y = 0
            for (this[g] = f & 255; ++Y < k && (V *= 256); ) this[g + Y] = (f / V) & 255
            return g + k
          }),
          (a.prototype.writeUintBE = a.prototype.writeUIntBE =
            function (f, g, k, q) {
              if (((f = +f), (g = g >>> 0), (k = k >>> 0), !q)) {
                const ke = Math.pow(2, 8 * k) - 1
                E(this, f, g, k, ke, 0)
              }
              let V = k - 1,
                Y = 1
              for (this[g + V] = f & 255; --V >= 0 && (Y *= 256); ) this[g + V] = (f / Y) & 255
              return g + k
            }),
          (a.prototype.writeUint8 = a.prototype.writeUInt8 =
            function (f, g, k) {
              return (
                (f = +f), (g = g >>> 0), k || E(this, f, g, 1, 255, 0), (this[g] = f & 255), g + 1
              )
            }),
          (a.prototype.writeUint16LE = a.prototype.writeUInt16LE =
            function (f, g, k) {
              return (
                (f = +f),
                (g = g >>> 0),
                k || E(this, f, g, 2, 65535, 0),
                (this[g] = f & 255),
                (this[g + 1] = f >>> 8),
                g + 2
              )
            }),
          (a.prototype.writeUint16BE = a.prototype.writeUInt16BE =
            function (f, g, k) {
              return (
                (f = +f),
                (g = g >>> 0),
                k || E(this, f, g, 2, 65535, 0),
                (this[g] = f >>> 8),
                (this[g + 1] = f & 255),
                g + 2
              )
            }),
          (a.prototype.writeUint32LE = a.prototype.writeUInt32LE =
            function (f, g, k) {
              return (
                (f = +f),
                (g = g >>> 0),
                k || E(this, f, g, 4, 4294967295, 0),
                (this[g + 3] = f >>> 24),
                (this[g + 2] = f >>> 16),
                (this[g + 1] = f >>> 8),
                (this[g] = f & 255),
                g + 4
              )
            }),
          (a.prototype.writeUint32BE = a.prototype.writeUInt32BE =
            function (f, g, k) {
              return (
                (f = +f),
                (g = g >>> 0),
                k || E(this, f, g, 4, 4294967295, 0),
                (this[g] = f >>> 24),
                (this[g + 1] = f >>> 16),
                (this[g + 2] = f >>> 8),
                (this[g + 3] = f & 255),
                g + 4
              )
            })
        function C(S, f, g, k, q) {
          nt(f, k, q, S, g, 7)
          let V = Number(f & BigInt(4294967295))
          ;(S[g++] = V),
            (V = V >> 8),
            (S[g++] = V),
            (V = V >> 8),
            (S[g++] = V),
            (V = V >> 8),
            (S[g++] = V)
          let Y = Number((f >> BigInt(32)) & BigInt(4294967295))
          return (
            (S[g++] = Y),
            (Y = Y >> 8),
            (S[g++] = Y),
            (Y = Y >> 8),
            (S[g++] = Y),
            (Y = Y >> 8),
            (S[g++] = Y),
            g
          )
        }
        function L(S, f, g, k, q) {
          nt(f, k, q, S, g, 7)
          let V = Number(f & BigInt(4294967295))
          ;(S[g + 7] = V),
            (V = V >> 8),
            (S[g + 6] = V),
            (V = V >> 8),
            (S[g + 5] = V),
            (V = V >> 8),
            (S[g + 4] = V)
          let Y = Number((f >> BigInt(32)) & BigInt(4294967295))
          return (
            (S[g + 3] = Y),
            (Y = Y >> 8),
            (S[g + 2] = Y),
            (Y = Y >> 8),
            (S[g + 1] = Y),
            (Y = Y >> 8),
            (S[g] = Y),
            g + 8
          )
        }
        ;(a.prototype.writeBigUInt64LE = Be(function (f, g = 0) {
          return C(this, f, g, BigInt(0), BigInt('0xffffffffffffffff'))
        })),
          (a.prototype.writeBigUInt64BE = Be(function (f, g = 0) {
            return L(this, f, g, BigInt(0), BigInt('0xffffffffffffffff'))
          })),
          (a.prototype.writeIntLE = function (f, g, k, q) {
            if (((f = +f), (g = g >>> 0), !q)) {
              const Ve = Math.pow(2, 8 * k - 1)
              E(this, f, g, k, Ve - 1, -Ve)
            }
            let V = 0,
              Y = 1,
              ke = 0
            for (this[g] = f & 255; ++V < k && (Y *= 256); )
              f < 0 && ke === 0 && this[g + V - 1] !== 0 && (ke = 1),
                (this[g + V] = (((f / Y) >> 0) - ke) & 255)
            return g + k
          }),
          (a.prototype.writeIntBE = function (f, g, k, q) {
            if (((f = +f), (g = g >>> 0), !q)) {
              const Ve = Math.pow(2, 8 * k - 1)
              E(this, f, g, k, Ve - 1, -Ve)
            }
            let V = k - 1,
              Y = 1,
              ke = 0
            for (this[g + V] = f & 255; --V >= 0 && (Y *= 256); )
              f < 0 && ke === 0 && this[g + V + 1] !== 0 && (ke = 1),
                (this[g + V] = (((f / Y) >> 0) - ke) & 255)
            return g + k
          }),
          (a.prototype.writeInt8 = function (f, g, k) {
            return (
              (f = +f),
              (g = g >>> 0),
              k || E(this, f, g, 1, 127, -128),
              f < 0 && (f = 255 + f + 1),
              (this[g] = f & 255),
              g + 1
            )
          }),
          (a.prototype.writeInt16LE = function (f, g, k) {
            return (
              (f = +f),
              (g = g >>> 0),
              k || E(this, f, g, 2, 32767, -32768),
              (this[g] = f & 255),
              (this[g + 1] = f >>> 8),
              g + 2
            )
          }),
          (a.prototype.writeInt16BE = function (f, g, k) {
            return (
              (f = +f),
              (g = g >>> 0),
              k || E(this, f, g, 2, 32767, -32768),
              (this[g] = f >>> 8),
              (this[g + 1] = f & 255),
              g + 2
            )
          }),
          (a.prototype.writeInt32LE = function (f, g, k) {
            return (
              (f = +f),
              (g = g >>> 0),
              k || E(this, f, g, 4, 2147483647, -2147483648),
              (this[g] = f & 255),
              (this[g + 1] = f >>> 8),
              (this[g + 2] = f >>> 16),
              (this[g + 3] = f >>> 24),
              g + 4
            )
          }),
          (a.prototype.writeInt32BE = function (f, g, k) {
            return (
              (f = +f),
              (g = g >>> 0),
              k || E(this, f, g, 4, 2147483647, -2147483648),
              f < 0 && (f = 4294967295 + f + 1),
              (this[g] = f >>> 24),
              (this[g + 1] = f >>> 16),
              (this[g + 2] = f >>> 8),
              (this[g + 3] = f & 255),
              g + 4
            )
          }),
          (a.prototype.writeBigInt64LE = Be(function (f, g = 0) {
            return C(this, f, g, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
          })),
          (a.prototype.writeBigInt64BE = Be(function (f, g = 0) {
            return L(this, f, g, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
          }))
        function K(S, f, g, k, q, V) {
          if (g + k > S.length) throw new RangeError('Index out of range')
          if (g < 0) throw new RangeError('Index out of range')
        }
        function ee(S, f, g, k, q) {
          return (f = +f), (g = g >>> 0), q || K(S, f, g, 4), n.write(S, f, g, k, 23, 4), g + 4
        }
        ;(a.prototype.writeFloatLE = function (f, g, k) {
          return ee(this, f, g, !0, k)
        }),
          (a.prototype.writeFloatBE = function (f, g, k) {
            return ee(this, f, g, !1, k)
          })
        function oe(S, f, g, k, q) {
          return (f = +f), (g = g >>> 0), q || K(S, f, g, 8), n.write(S, f, g, k, 52, 8), g + 8
        }
        ;(a.prototype.writeDoubleLE = function (f, g, k) {
          return oe(this, f, g, !0, k)
        }),
          (a.prototype.writeDoubleBE = function (f, g, k) {
            return oe(this, f, g, !1, k)
          }),
          (a.prototype.copy = function (f, g, k, q) {
            if (!a.isBuffer(f)) throw new TypeError('argument should be a Buffer')
            if (
              (k || (k = 0),
              !q && q !== 0 && (q = this.length),
              g >= f.length && (g = f.length),
              g || (g = 0),
              q > 0 && q < k && (q = k),
              q === k || f.length === 0 || this.length === 0)
            )
              return 0
            if (g < 0) throw new RangeError('targetStart out of bounds')
            if (k < 0 || k >= this.length) throw new RangeError('Index out of range')
            if (q < 0) throw new RangeError('sourceEnd out of bounds')
            q > this.length && (q = this.length), f.length - g < q - k && (q = f.length - g + k)
            const V = q - k
            return (
              this === f && typeof Uint8Array.prototype.copyWithin == 'function'
                ? this.copyWithin(g, k, q)
                : Uint8Array.prototype.set.call(f, this.subarray(k, q), g),
              V
            )
          }),
          (a.prototype.fill = function (f, g, k, q) {
            if (typeof f == 'string') {
              if (
                (typeof g == 'string'
                  ? ((q = g), (g = 0), (k = this.length))
                  : typeof k == 'string' && ((q = k), (k = this.length)),
                q !== void 0 && typeof q != 'string')
              )
                throw new TypeError('encoding must be a string')
              if (typeof q == 'string' && !a.isEncoding(q))
                throw new TypeError('Unknown encoding: ' + q)
              if (f.length === 1) {
                const Y = f.charCodeAt(0)
                ;((q === 'utf8' && Y < 128) || q === 'latin1') && (f = Y)
              }
            } else typeof f == 'number' ? (f = f & 255) : typeof f == 'boolean' && (f = Number(f))
            if (g < 0 || this.length < g || this.length < k)
              throw new RangeError('Out of range index')
            if (k <= g) return this
            ;(g = g >>> 0), (k = k === void 0 ? this.length : k >>> 0), f || (f = 0)
            let V
            if (typeof f == 'number') for (V = g; V < k; ++V) this[V] = f
            else {
              const Y = a.isBuffer(f) ? f : a.from(f, q),
                ke = Y.length
              if (ke === 0)
                throw new TypeError('The value "' + f + '" is invalid for argument "value"')
              for (V = 0; V < k - g; ++V) this[V + g] = Y[V % ke]
            }
            return this
          })
        var fe = {}
        function ve(S, f, g) {
          fe[S] = class extends g {
            constructor() {
              super(),
                Object.defineProperty(this, 'message', {
                  value: f.apply(this, arguments),
                  writable: !0,
                  configurable: !0
                }),
                (this.name = `${this.name} [${S}]`),
                this.stack,
                delete this.name
            }
            get code() {
              return S
            }
            set code(q) {
              Object.defineProperty(this, 'code', {
                configurable: !0,
                enumerable: !0,
                value: q,
                writable: !0
              })
            }
            toString() {
              return `${this.name} [${S}]: ${this.message}`
            }
          }
        }
        ve(
          'ERR_BUFFER_OUT_OF_BOUNDS',
          function (S) {
            return S
              ? `${S} is outside of buffer bounds`
              : 'Attempt to access memory outside buffer bounds'
          },
          RangeError
        ),
          ve(
            'ERR_INVALID_ARG_TYPE',
            function (S, f) {
              return `The "${S}" argument must be of type number. Received type ${typeof f}`
            },
            TypeError
          ),
          ve(
            'ERR_OUT_OF_RANGE',
            function (S, f, g) {
              let k = `The value of "${S}" is out of range.`,
                q = g
              return (
                Number.isInteger(g) && Math.abs(g) > 2 ** 32
                  ? (q = tt(String(g)))
                  : typeof g == 'bigint' &&
                    ((q = String(g)),
                    (g > BigInt(2) ** BigInt(32) || g < -(BigInt(2) ** BigInt(32))) && (q = tt(q)),
                    (q += 'n')),
                (k += ` It must be ${f}. Received ${q}`),
                k
              )
            },
            RangeError
          )
        function tt(S) {
          let f = '',
            g = S.length
          const k = S[0] === '-' ? 1 : 0
          for (; g >= k + 4; g -= 3) f = `_${S.slice(g - 3, g)}${f}`
          return `${S.slice(0, g)}${f}`
        }
        function Ge(S, f, g) {
          Z(f, 'offset'), (S[f] === void 0 || S[f + g] === void 0) && X(f, S.length - (g + 1))
        }
        function nt(S, f, g, k, q, V) {
          if (S > g || S < f) {
            const Y = typeof f == 'bigint' ? 'n' : ''
            let ke
            throw (
              (f === 0 || f === BigInt(0)
                ? (ke = `>= 0${Y} and < 2${Y} ** ${(V + 1) * 8}${Y}`)
                : (ke = `>= -(2${Y} ** ${(V + 1) * 8 - 1}${Y}) and < 2 ** ${(V + 1) * 8 - 1}${Y}`),
              new fe.ERR_OUT_OF_RANGE('value', ke, S))
            )
          }
          Ge(k, q, V)
        }
        function Z(S, f) {
          if (typeof S != 'number') throw new fe.ERR_INVALID_ARG_TYPE(f, 'number', S)
        }
        function X(S, f, g) {
          throw Math.floor(S) !== S
            ? (Z(S, g), new fe.ERR_OUT_OF_RANGE('offset', 'an integer', S))
            : f < 0
              ? new fe.ERR_BUFFER_OUT_OF_BOUNDS()
              : new fe.ERR_OUT_OF_RANGE('offset', `>= 0 and <= ${f}`, S)
        }
        const ie = /[^+/0-9A-Za-z-_]/g
        function be(S) {
          if (((S = S.split('=')[0]), (S = S.trim().replace(ie, '')), S.length < 2)) return ''
          for (; S.length % 4 !== 0; ) S = S + '='
          return S
        }
        function ue(S, f) {
          f = f || 1 / 0
          let g
          const k = S.length
          let q = null
          const V = []
          for (let Y = 0; Y < k; ++Y) {
            if (((g = S.charCodeAt(Y)), g > 55295 && g < 57344)) {
              if (!q) {
                if (g > 56319) {
                  ;(f -= 3) > -1 && V.push(239, 191, 189)
                  continue
                } else if (Y + 1 === k) {
                  ;(f -= 3) > -1 && V.push(239, 191, 189)
                  continue
                }
                q = g
                continue
              }
              if (g < 56320) {
                ;(f -= 3) > -1 && V.push(239, 191, 189), (q = g)
                continue
              }
              g = (((q - 55296) << 10) | (g - 56320)) + 65536
            } else q && (f -= 3) > -1 && V.push(239, 191, 189)
            if (((q = null), g < 128)) {
              if ((f -= 1) < 0) break
              V.push(g)
            } else if (g < 2048) {
              if ((f -= 2) < 0) break
              V.push((g >> 6) | 192, (g & 63) | 128)
            } else if (g < 65536) {
              if ((f -= 3) < 0) break
              V.push((g >> 12) | 224, ((g >> 6) & 63) | 128, (g & 63) | 128)
            } else if (g < 1114112) {
              if ((f -= 4) < 0) break
              V.push((g >> 18) | 240, ((g >> 12) & 63) | 128, ((g >> 6) & 63) | 128, (g & 63) | 128)
            } else throw new Error('Invalid code point')
          }
          return V
        }
        function de(S) {
          const f = []
          for (let g = 0; g < S.length; ++g) f.push(S.charCodeAt(g) & 255)
          return f
        }
        function Te(S, f) {
          let g, k, q
          const V = []
          for (let Y = 0; Y < S.length && !((f -= 2) < 0); ++Y)
            (g = S.charCodeAt(Y)), (k = g >> 8), (q = g % 256), V.push(q), V.push(k)
          return V
        }
        function we(S) {
          return e.toByteArray(be(S))
        }
        function ge(S, f, g, k) {
          let q
          for (q = 0; q < k && !(q + g >= f.length || q >= S.length); ++q) f[q + g] = S[q]
          return q
        }
        function he(S, f) {
          return (
            S instanceof f ||
            (S != null &&
              S.constructor != null &&
              S.constructor.name != null &&
              S.constructor.name === f.name)
          )
        }
        function Ne(S) {
          return S !== S
        }
        const _e = (function () {
          const S = '0123456789abcdef',
            f = new Array(256)
          for (let g = 0; g < 16; ++g) {
            const k = g * 16
            for (let q = 0; q < 16; ++q) f[k + q] = S[g] + S[q]
          }
          return f
        })()
        function Be(S) {
          return typeof BigInt > 'u' ? $e : S
        }
        function $e() {
          throw new Error('BigInt not supported')
        }
      })(Tb)),
    Tb
  )
}
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var oT
function Mle() {
  return (
    oT ||
      ((oT = 1),
      (function (t, e) {
        var n = Dle(),
          r = n.Buffer
        function s(o, a) {
          for (var c in o) a[c] = o[c]
        }
        r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow
          ? (t.exports = n)
          : (s(n, e), (e.Buffer = i))
        function i(o, a, c) {
          return r(o, a, c)
        }
        ;(i.prototype = Object.create(r.prototype)),
          s(r, i),
          (i.from = function (o, a, c) {
            if (typeof o == 'number') throw new TypeError('Argument must not be a number')
            return r(o, a, c)
          }),
          (i.alloc = function (o, a, c) {
            if (typeof o != 'number') throw new TypeError('Argument must be a number')
            var u = r(o)
            return a !== void 0 ? (typeof c == 'string' ? u.fill(a, c) : u.fill(a)) : u.fill(0), u
          }),
          (i.allocUnsafe = function (o) {
            if (typeof o != 'number') throw new TypeError('Argument must be a number')
            return r(o)
          }),
          (i.allocUnsafeSlow = function (o) {
            if (typeof o != 'number') throw new TypeError('Argument must be a number')
            return n.SlowBuffer(o)
          })
      })(bg, bg.exports)),
    bg.exports
  )
}
var Nb, aT
function Ule() {
  if (aT) return Nb
  aT = 1
  var t = Mle().Buffer
  function e(n) {
    if (n.length >= 255) throw new TypeError('Alphabet too long')
    for (var r = new Uint8Array(256), s = 0; s < r.length; s++) r[s] = 255
    for (var i = 0; i < n.length; i++) {
      var o = n.charAt(i),
        a = o.charCodeAt(0)
      if (r[a] !== 255) throw new TypeError(o + ' is ambiguous')
      r[a] = i
    }
    var c = n.length,
      u = n.charAt(0),
      l = Math.log(c) / Math.log(256),
      d = Math.log(256) / Math.log(c)
    function h(m) {
      if (((Array.isArray(m) || m instanceof Uint8Array) && (m = t.from(m)), !t.isBuffer(m)))
        throw new TypeError('Expected Buffer')
      if (m.length === 0) return ''
      for (var b = 0, I = 0, x = 0, _ = m.length; x !== _ && m[x] === 0; ) x++, b++
      for (var R = ((_ - x) * d + 1) >>> 0, N = new Uint8Array(R); x !== _; ) {
        for (var T = m[x], M = 0, H = R - 1; (T !== 0 || M < I) && H !== -1; H--, M++)
          (T += (256 * N[H]) >>> 0), (N[H] = T % c >>> 0), (T = (T / c) >>> 0)
        if (T !== 0) throw new Error('Non-zero carry')
        ;(I = M), x++
      }
      for (var B = R - I; B !== R && N[B] === 0; ) B++
      for (var $ = u.repeat(b); B < R; ++B) $ += n.charAt(N[B])
      return $
    }
    function p(m) {
      if (typeof m != 'string') throw new TypeError('Expected String')
      if (m.length === 0) return t.alloc(0)
      for (var b = 0, I = 0, x = 0; m[b] === u; ) I++, b++
      for (var _ = ((m.length - b) * l + 1) >>> 0, R = new Uint8Array(_); b < m.length; ) {
        var N = m.charCodeAt(b)
        if (N > 255) return
        var T = r[N]
        if (T === 255) return
        for (var M = 0, H = _ - 1; (T !== 0 || M < x) && H !== -1; H--, M++)
          (T += (c * R[H]) >>> 0), (R[H] = T % 256 >>> 0), (T = (T / 256) >>> 0)
        if (T !== 0) throw new Error('Non-zero carry')
        ;(x = M), b++
      }
      for (var B = _ - x; B !== _ && R[B] === 0; ) B++
      var $ = t.allocUnsafe(I + (_ - B))
      $.fill(0, 0, I)
      for (var D = I; B !== _; ) $[D++] = R[B++]
      return $
    }
    function y(m) {
      var b = p(m)
      if (b) return b
      throw new Error('Non-base' + c + ' character')
    }
    return { encode: h, decodeUnsafe: p, decode: y }
  }
  return (Nb = e), Nb
}
var Pb, cT
function e5() {
  if (cT) return Pb
  cT = 1
  var t = Ule(),
    e = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
  return (Pb = t(e)), Pb
}
var Lle = e5()
const Nr = _u(Lle)
var rn = {}
function Ho(t, e, n) {
  return e <= t && t <= n
}
function ay(t) {
  if (t === void 0) return {}
  if (t === Object(t)) return t
  throw TypeError('Could not convert argument to dictionary')
}
function $le(t) {
  for (var e = String(t), n = e.length, r = 0, s = []; r < n; ) {
    var i = e.charCodeAt(r)
    if (i < 55296 || i > 57343) s.push(i)
    else if (56320 <= i && i <= 57343) s.push(65533)
    else if (55296 <= i && i <= 56319)
      if (r === n - 1) s.push(65533)
      else {
        var o = t.charCodeAt(r + 1)
        if (56320 <= o && o <= 57343) {
          var a = i & 1023,
            c = o & 1023
          s.push(65536 + (a << 10) + c), (r += 1)
        } else s.push(65533)
      }
    r += 1
  }
  return s
}
function Fle(t) {
  for (var e = '', n = 0; n < t.length; ++n) {
    var r = t[n]
    r <= 65535
      ? (e += String.fromCharCode(r))
      : ((r -= 65536), (e += String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320)))
  }
  return e
}
var Um = -1
function e_(t) {
  this.tokens = [].slice.call(t)
}
e_.prototype = {
  endOfStream: function () {
    return !this.tokens.length
  },
  read: function () {
    return this.tokens.length ? this.tokens.shift() : Um
  },
  prepend: function (t) {
    if (Array.isArray(t)) for (var e = t; e.length; ) this.tokens.unshift(e.pop())
    else this.tokens.unshift(t)
  },
  push: function (t) {
    if (Array.isArray(t)) for (var e = t; e.length; ) this.tokens.push(e.shift())
    else this.tokens.push(t)
  }
}
var hd = -1
function Rb(t, e) {
  if (t) throw TypeError('Decoder error')
  return e || 65533
}
var Lm = 'utf-8'
function $m(t, e) {
  if (!(this instanceof $m)) return new $m(t, e)
  if (((t = t !== void 0 ? String(t).toLowerCase() : Lm), t !== Lm))
    throw new Error('Encoding not supported. Only utf-8 is supported')
  ;(e = ay(e)),
    (this._streaming = !1),
    (this._BOMseen = !1),
    (this._decoder = null),
    (this._fatal = !!e.fatal),
    (this._ignoreBOM = !!e.ignoreBOM),
    Object.defineProperty(this, 'encoding', { value: 'utf-8' }),
    Object.defineProperty(this, 'fatal', { value: this._fatal }),
    Object.defineProperty(this, 'ignoreBOM', { value: this._ignoreBOM })
}
$m.prototype = {
  decode: function (e, n) {
    var r
    typeof e == 'object' && e instanceof ArrayBuffer
      ? (r = new Uint8Array(e))
      : typeof e == 'object' && 'buffer' in e && e.buffer instanceof ArrayBuffer
        ? (r = new Uint8Array(e.buffer, e.byteOffset, e.byteLength))
        : (r = new Uint8Array(0)),
      (n = ay(n)),
      this._streaming || ((this._decoder = new jle({ fatal: this._fatal })), (this._BOMseen = !1)),
      (this._streaming = !!n.stream)
    for (
      var s = new e_(r), i = [], o;
      !s.endOfStream() && ((o = this._decoder.handler(s, s.read())), o !== hd);

    )
      o !== null && (Array.isArray(o) ? i.push.apply(i, o) : i.push(o))
    if (!this._streaming) {
      do {
        if (((o = this._decoder.handler(s, s.read())), o === hd)) break
        o !== null && (Array.isArray(o) ? i.push.apply(i, o) : i.push(o))
      } while (!s.endOfStream())
      this._decoder = null
    }
    return (
      i.length &&
        ['utf-8'].indexOf(this.encoding) !== -1 &&
        !this._ignoreBOM &&
        !this._BOMseen &&
        (i[0] === 65279 ? ((this._BOMseen = !0), i.shift()) : (this._BOMseen = !0)),
      Fle(i)
    )
  }
}
function Fm(t, e) {
  if (!(this instanceof Fm)) return new Fm(t, e)
  if (((t = t !== void 0 ? String(t).toLowerCase() : Lm), t !== Lm))
    throw new Error('Encoding not supported. Only utf-8 is supported')
  ;(e = ay(e)),
    (this._streaming = !1),
    (this._encoder = null),
    (this._options = { fatal: !!e.fatal }),
    Object.defineProperty(this, 'encoding', { value: 'utf-8' })
}
Fm.prototype = {
  encode: function (e, n) {
    ;(e = e ? String(e) : ''),
      (n = ay(n)),
      this._streaming || (this._encoder = new Hle(this._options)),
      (this._streaming = !!n.stream)
    for (
      var r = [], s = new e_($le(e)), i;
      !s.endOfStream() && ((i = this._encoder.handler(s, s.read())), i !== hd);

    )
      Array.isArray(i) ? r.push.apply(r, i) : r.push(i)
    if (!this._streaming) {
      for (; (i = this._encoder.handler(s, s.read())), i !== hd; )
        Array.isArray(i) ? r.push.apply(r, i) : r.push(i)
      this._encoder = null
    }
    return new Uint8Array(r)
  }
}
function jle(t) {
  var e = t.fatal,
    n = 0,
    r = 0,
    s = 0,
    i = 128,
    o = 191
  this.handler = function (a, c) {
    if (c === Um && s !== 0) return (s = 0), Rb(e)
    if (c === Um) return hd
    if (s === 0) {
      if (Ho(c, 0, 127)) return c
      if (Ho(c, 194, 223)) (s = 1), (n = c - 192)
      else if (Ho(c, 224, 239))
        c === 224 && (i = 160), c === 237 && (o = 159), (s = 2), (n = c - 224)
      else if (Ho(c, 240, 244))
        c === 240 && (i = 144), c === 244 && (o = 143), (s = 3), (n = c - 240)
      else return Rb(e)
      return (n = n << (6 * s)), null
    }
    if (!Ho(c, i, o)) return (n = s = r = 0), (i = 128), (o = 191), a.prepend(c), Rb(e)
    if (((i = 128), (o = 191), (r += 1), (n += (c - 128) << (6 * (s - r))), r !== s)) return null
    var u = n
    return (n = s = r = 0), u
  }
}
function Hle(t) {
  t.fatal,
    (this.handler = function (e, n) {
      if (n === Um) return hd
      if (Ho(n, 0, 127)) return n
      var r, s
      Ho(n, 128, 2047)
        ? ((r = 1), (s = 192))
        : Ho(n, 2048, 65535)
          ? ((r = 2), (s = 224))
          : Ho(n, 65536, 1114111) && ((r = 3), (s = 240))
      for (var i = [(n >> (6 * r)) + s]; r > 0; ) {
        var o = n >> (6 * (r - 1))
        i.push(128 | (o & 63)), (r -= 1)
      }
      return i
    })
}
const qle = Object.freeze(
    Object.defineProperty(
      { __proto__: null, TextDecoder: $m, TextEncoder: Fm },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  zle = N0(qle)
var uT
function Wle() {
  if (uT) return rn
  uT = 1
  var t =
      (rn && rn.__createBinding) ||
      (Object.create
        ? function (B, $, D, W) {
            W === void 0 && (W = D),
              Object.defineProperty(B, W, {
                enumerable: !0,
                get: function () {
                  return $[D]
                }
              })
          }
        : function (B, $, D, W) {
            W === void 0 && (W = D), (B[W] = $[D])
          }),
    e =
      (rn && rn.__setModuleDefault) ||
      (Object.create
        ? function (B, $) {
            Object.defineProperty(B, 'default', { enumerable: !0, value: $ })
          }
        : function (B, $) {
            B.default = $
          }),
    n =
      (rn && rn.__decorate) ||
      function (B, $, D, W) {
        var U = arguments.length,
          w = U < 3 ? $ : W === null ? (W = Object.getOwnPropertyDescriptor($, D)) : W,
          v
        if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
          w = Reflect.decorate(B, $, D, W)
        else
          for (var A = B.length - 1; A >= 0; A--)
            (v = B[A]) && (w = (U < 3 ? v(w) : U > 3 ? v($, D, w) : v($, D)) || w)
        return U > 3 && w && Object.defineProperty($, D, w), w
      },
    r =
      (rn && rn.__importStar) ||
      function (B) {
        if (B && B.__esModule) return B
        var $ = {}
        if (B != null)
          for (var D in B) D !== 'default' && Object.hasOwnProperty.call(B, D) && t($, B, D)
        return e($, B), $
      },
    s =
      (rn && rn.__importDefault) ||
      function (B) {
        return B && B.__esModule ? B : { default: B }
      }
  Object.defineProperty(rn, '__esModule', { value: !0 }),
    (rn.deserializeUnchecked =
      rn.deserialize =
      rn.serialize =
      rn.BinaryReader =
      rn.BinaryWriter =
      rn.BorshError =
      rn.baseDecode =
      rn.baseEncode =
        void 0)
  const i = s(X8()),
    o = s(e5()),
    a = r(zle),
    c = typeof TextDecoder != 'function' ? a.TextDecoder : TextDecoder,
    u = new c('utf-8', { fatal: !0 })
  function l(B) {
    return typeof B == 'string' && (B = Buffer.from(B, 'utf8')), o.default.encode(Buffer.from(B))
  }
  rn.baseEncode = l
  function d(B) {
    return Buffer.from(o.default.decode(B))
  }
  rn.baseDecode = d
  const h = 1024
  class p extends Error {
    constructor($) {
      super($), (this.fieldPath = []), (this.originalMessage = $)
    }
    addToFieldPath($) {
      this.fieldPath.splice(0, 0, $),
        (this.message = this.originalMessage + ': ' + this.fieldPath.join('.'))
    }
  }
  rn.BorshError = p
  class y {
    constructor() {
      ;(this.buf = Buffer.alloc(h)), (this.length = 0)
    }
    maybeResize() {
      this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(h)]))
    }
    writeU8($) {
      this.maybeResize(), this.buf.writeUInt8($, this.length), (this.length += 1)
    }
    writeU16($) {
      this.maybeResize(), this.buf.writeUInt16LE($, this.length), (this.length += 2)
    }
    writeU32($) {
      this.maybeResize(), this.buf.writeUInt32LE($, this.length), (this.length += 4)
    }
    writeU64($) {
      this.maybeResize(), this.writeBuffer(Buffer.from(new i.default($).toArray('le', 8)))
    }
    writeU128($) {
      this.maybeResize(), this.writeBuffer(Buffer.from(new i.default($).toArray('le', 16)))
    }
    writeU256($) {
      this.maybeResize(), this.writeBuffer(Buffer.from(new i.default($).toArray('le', 32)))
    }
    writeU512($) {
      this.maybeResize(), this.writeBuffer(Buffer.from(new i.default($).toArray('le', 64)))
    }
    writeBuffer($) {
      ;(this.buf = Buffer.concat([
        Buffer.from(this.buf.subarray(0, this.length)),
        $,
        Buffer.alloc(h)
      ])),
        (this.length += $.length)
    }
    writeString($) {
      this.maybeResize()
      const D = Buffer.from($, 'utf8')
      this.writeU32(D.length), this.writeBuffer(D)
    }
    writeFixedArray($) {
      this.writeBuffer(Buffer.from($))
    }
    writeArray($, D) {
      this.maybeResize(), this.writeU32($.length)
      for (const W of $) this.maybeResize(), D(W)
    }
    toArray() {
      return this.buf.subarray(0, this.length)
    }
  }
  rn.BinaryWriter = y
  function m(B, $, D) {
    const W = D.value
    D.value = function (...U) {
      try {
        return W.apply(this, U)
      } catch (w) {
        if (w instanceof RangeError) {
          const v = w.code
          if (['ERR_BUFFER_OUT_OF_BOUNDS', 'ERR_OUT_OF_RANGE'].indexOf(v) >= 0)
            throw new p('Reached the end of buffer when deserializing')
        }
        throw w
      }
    }
  }
  class b {
    constructor($) {
      ;(this.buf = $), (this.offset = 0)
    }
    readU8() {
      const $ = this.buf.readUInt8(this.offset)
      return (this.offset += 1), $
    }
    readU16() {
      const $ = this.buf.readUInt16LE(this.offset)
      return (this.offset += 2), $
    }
    readU32() {
      const $ = this.buf.readUInt32LE(this.offset)
      return (this.offset += 4), $
    }
    readU64() {
      const $ = this.readBuffer(8)
      return new i.default($, 'le')
    }
    readU128() {
      const $ = this.readBuffer(16)
      return new i.default($, 'le')
    }
    readU256() {
      const $ = this.readBuffer(32)
      return new i.default($, 'le')
    }
    readU512() {
      const $ = this.readBuffer(64)
      return new i.default($, 'le')
    }
    readBuffer($) {
      if (this.offset + $ > this.buf.length)
        throw new p(`Expected buffer length ${$} isn't within bounds`)
      const D = this.buf.slice(this.offset, this.offset + $)
      return (this.offset += $), D
    }
    readString() {
      const $ = this.readU32(),
        D = this.readBuffer($)
      try {
        return u.decode(D)
      } catch (W) {
        throw new p(`Error decoding UTF-8 string: ${W}`)
      }
    }
    readFixedArray($) {
      return new Uint8Array(this.readBuffer($))
    }
    readArray($) {
      const D = this.readU32(),
        W = Array()
      for (let U = 0; U < D; ++U) W.push($())
      return W
    }
  }
  n([m], b.prototype, 'readU8', null),
    n([m], b.prototype, 'readU16', null),
    n([m], b.prototype, 'readU32', null),
    n([m], b.prototype, 'readU64', null),
    n([m], b.prototype, 'readU128', null),
    n([m], b.prototype, 'readU256', null),
    n([m], b.prototype, 'readU512', null),
    n([m], b.prototype, 'readString', null),
    n([m], b.prototype, 'readFixedArray', null),
    n([m], b.prototype, 'readArray', null),
    (rn.BinaryReader = b)
  function I(B) {
    return B.charAt(0).toUpperCase() + B.slice(1)
  }
  function x(B, $, D, W, U) {
    try {
      if (typeof W == 'string') U[`write${I(W)}`](D)
      else if (W instanceof Array)
        if (typeof W[0] == 'number') {
          if (D.length !== W[0])
            throw new p(`Expecting byte array of length ${W[0]}, but got ${D.length} bytes`)
          U.writeFixedArray(D)
        } else if (W.length === 2 && typeof W[1] == 'number') {
          if (D.length !== W[1])
            throw new p(`Expecting byte array of length ${W[1]}, but got ${D.length} bytes`)
          for (let w = 0; w < W[1]; w++) x(B, null, D[w], W[0], U)
        } else
          U.writeArray(D, w => {
            x(B, $, w, W[0], U)
          })
      else if (W.kind !== void 0)
        switch (W.kind) {
          case 'option': {
            D == null ? U.writeU8(0) : (U.writeU8(1), x(B, $, D, W.type, U))
            break
          }
          case 'map': {
            U.writeU32(D.size),
              D.forEach((w, v) => {
                x(B, $, v, W.key, U), x(B, $, w, W.value, U)
              })
            break
          }
          default:
            throw new p(`FieldType ${W} unrecognized`)
        }
      else _(B, D, U)
    } catch (w) {
      throw (w instanceof p && w.addToFieldPath($), w)
    }
  }
  function _(B, $, D) {
    if (typeof $.borshSerialize == 'function') {
      $.borshSerialize(D)
      return
    }
    const W = B.get($.constructor)
    if (!W) throw new p(`Class ${$.constructor.name} is missing in schema`)
    if (W.kind === 'struct')
      W.fields.map(([U, w]) => {
        x(B, U, $[U], w, D)
      })
    else if (W.kind === 'enum') {
      const U = $[W.field]
      for (let w = 0; w < W.values.length; ++w) {
        const [v, A] = W.values[w]
        if (v === U) {
          D.writeU8(w), x(B, v, $[v], A, D)
          break
        }
      }
    } else throw new p(`Unexpected schema kind: ${W.kind} for ${$.constructor.name}`)
  }
  function R(B, $, D = y) {
    const W = new D()
    return _(B, $, W), W.toArray()
  }
  rn.serialize = R
  function N(B, $, D, W) {
    try {
      if (typeof D == 'string') return W[`read${I(D)}`]()
      if (D instanceof Array) {
        if (typeof D[0] == 'number') return W.readFixedArray(D[0])
        if (typeof D[1] == 'number') {
          const U = []
          for (let w = 0; w < D[1]; w++) U.push(N(B, null, D[0], W))
          return U
        } else return W.readArray(() => N(B, $, D[0], W))
      }
      if (D.kind === 'option') return W.readU8() ? N(B, $, D.type, W) : void 0
      if (D.kind === 'map') {
        let U = new Map()
        const w = W.readU32()
        for (let v = 0; v < w; v++) {
          const A = N(B, $, D.key, W),
            P = N(B, $, D.value, W)
          U.set(A, P)
        }
        return U
      }
      return T(B, D, W)
    } catch (U) {
      throw (U instanceof p && U.addToFieldPath($), U)
    }
  }
  function T(B, $, D) {
    if (typeof $.borshDeserialize == 'function') return $.borshDeserialize(D)
    const W = B.get($)
    if (!W) throw new p(`Class ${$.name} is missing in schema`)
    if (W.kind === 'struct') {
      const U = {}
      for (const [w, v] of B.get($).fields) U[w] = N(B, w, v, D)
      return new $(U)
    }
    if (W.kind === 'enum') {
      const U = D.readU8()
      if (U >= W.values.length) throw new p(`Enum index: ${U} is out of range`)
      const [w, v] = W.values[U],
        A = N(B, w, v, D)
      return new $({ [w]: A })
    }
    throw new p(`Unexpected schema kind: ${W.kind} for ${$.constructor.name}`)
  }
  function M(B, $, D, W = b) {
    const U = new W(D),
      w = T(B, $, U)
    if (U.offset < D.length)
      throw new p(`Unexpected ${D.length - U.offset} bytes after deserialized data`)
    return w
  }
  rn.deserialize = M
  function H(B, $, D, W = b) {
    const U = new W(D)
    return T(B, $, U)
  }
  return (rn.deserializeUnchecked = H), rn
}
var kb = Wle(),
  ce = {},
  lT
function Kle() {
  if (lT) return ce
  ;(lT = 1),
    Object.defineProperty(ce, '__esModule', { value: !0 }),
    (ce.s16 =
      ce.s8 =
      ce.nu64be =
      ce.u48be =
      ce.u40be =
      ce.u32be =
      ce.u24be =
      ce.u16be =
      ce.nu64 =
      ce.u48 =
      ce.u40 =
      ce.u32 =
      ce.u24 =
      ce.u16 =
      ce.u8 =
      ce.offset =
      ce.greedy =
      ce.Constant =
      ce.UTF8 =
      ce.CString =
      ce.Blob =
      ce.Boolean =
      ce.BitField =
      ce.BitStructure =
      ce.VariantLayout =
      ce.Union =
      ce.UnionLayoutDiscriminator =
      ce.UnionDiscriminator =
      ce.Structure =
      ce.Sequence =
      ce.DoubleBE =
      ce.Double =
      ce.FloatBE =
      ce.Float =
      ce.NearInt64BE =
      ce.NearInt64 =
      ce.NearUInt64BE =
      ce.NearUInt64 =
      ce.IntBE =
      ce.Int =
      ce.UIntBE =
      ce.UInt =
      ce.OffsetLayout =
      ce.GreedyCount =
      ce.ExternalLayout =
      ce.bindConstructorLayout =
      ce.nameWithProperty =
      ce.Layout =
      ce.uint8ArrayToBuffer =
      ce.checkUint8Array =
        void 0),
    (ce.constant =
      ce.utf8 =
      ce.cstr =
      ce.blob =
      ce.unionLayoutDiscriminator =
      ce.union =
      ce.seq =
      ce.bits =
      ce.struct =
      ce.f64be =
      ce.f64 =
      ce.f32be =
      ce.f32 =
      ce.ns64be =
      ce.s48be =
      ce.s40be =
      ce.s32be =
      ce.s24be =
      ce.s16be =
      ce.ns64 =
      ce.s48 =
      ce.s40 =
      ce.s32 =
      ce.s24 =
        void 0)
  const t = J3()
  function e(E) {
    if (!(E instanceof Uint8Array)) throw new TypeError('b must be a Uint8Array')
  }
  ce.checkUint8Array = e
  function n(E) {
    return e(E), t.Buffer.from(E.buffer, E.byteOffset, E.length)
  }
  ce.uint8ArrayToBuffer = n
  let r = class {
    constructor(C, L) {
      if (!Number.isInteger(C)) throw new TypeError('span must be an integer')
      ;(this.span = C), (this.property = L)
    }
    makeDestinationObject() {
      return {}
    }
    getSpan(C, L) {
      if (0 > this.span) throw new RangeError('indeterminate span')
      return this.span
    }
    replicate(C) {
      const L = Object.create(this.constructor.prototype)
      return Object.assign(L, this), (L.property = C), L
    }
    fromArray(C) {}
  }
  ce.Layout = r
  function s(E, C) {
    return C.property ? E + '[' + C.property + ']' : E
  }
  ce.nameWithProperty = s
  function i(E, C) {
    if (typeof E != 'function') throw new TypeError('Class must be constructor')
    if (Object.prototype.hasOwnProperty.call(E, 'layout_'))
      throw new Error('Class is already bound to a layout')
    if (!(C && C instanceof r)) throw new TypeError('layout must be a Layout')
    if (Object.prototype.hasOwnProperty.call(C, 'boundConstructor_'))
      throw new Error('layout is already bound to a constructor')
    ;(E.layout_ = C),
      (C.boundConstructor_ = E),
      (C.makeDestinationObject = () => new E()),
      Object.defineProperty(E.prototype, 'encode', {
        value(L, K) {
          return C.encode(this, L, K)
        },
        writable: !0
      }),
      Object.defineProperty(E, 'decode', {
        value(L, K) {
          return C.decode(L, K)
        },
        writable: !0
      })
  }
  ce.bindConstructorLayout = i
  class o extends r {
    isCount() {
      throw new Error('ExternalLayout is abstract')
    }
  }
  ce.ExternalLayout = o
  class a extends o {
    constructor(C = 1, L) {
      if (!Number.isInteger(C) || 0 >= C)
        throw new TypeError('elementSpan must be a (positive) integer')
      super(-1, L), (this.elementSpan = C)
    }
    isCount() {
      return !0
    }
    decode(C, L = 0) {
      e(C)
      const K = C.length - L
      return Math.floor(K / this.elementSpan)
    }
    encode(C, L, K) {
      return 0
    }
  }
  ce.GreedyCount = a
  class c extends o {
    constructor(C, L = 0, K) {
      if (!(C instanceof r)) throw new TypeError('layout must be a Layout')
      if (!Number.isInteger(L)) throw new TypeError('offset must be integer or undefined')
      super(C.span, K || C.property), (this.layout = C), (this.offset = L)
    }
    isCount() {
      return this.layout instanceof u || this.layout instanceof l
    }
    decode(C, L = 0) {
      return this.layout.decode(C, L + this.offset)
    }
    encode(C, L, K = 0) {
      return this.layout.encode(C, L, K + this.offset)
    }
  }
  ce.OffsetLayout = c
  class u extends r {
    constructor(C, L) {
      if ((super(C, L), 6 < this.span)) throw new RangeError('span must not exceed 6 bytes')
    }
    decode(C, L = 0) {
      return n(C).readUIntLE(L, this.span)
    }
    encode(C, L, K = 0) {
      return n(L).writeUIntLE(C, K, this.span), this.span
    }
  }
  ce.UInt = u
  class l extends r {
    constructor(C, L) {
      if ((super(C, L), 6 < this.span)) throw new RangeError('span must not exceed 6 bytes')
    }
    decode(C, L = 0) {
      return n(C).readUIntBE(L, this.span)
    }
    encode(C, L, K = 0) {
      return n(L).writeUIntBE(C, K, this.span), this.span
    }
  }
  ce.UIntBE = l
  class d extends r {
    constructor(C, L) {
      if ((super(C, L), 6 < this.span)) throw new RangeError('span must not exceed 6 bytes')
    }
    decode(C, L = 0) {
      return n(C).readIntLE(L, this.span)
    }
    encode(C, L, K = 0) {
      return n(L).writeIntLE(C, K, this.span), this.span
    }
  }
  ce.Int = d
  class h extends r {
    constructor(C, L) {
      if ((super(C, L), 6 < this.span)) throw new RangeError('span must not exceed 6 bytes')
    }
    decode(C, L = 0) {
      return n(C).readIntBE(L, this.span)
    }
    encode(C, L, K = 0) {
      return n(L).writeIntBE(C, K, this.span), this.span
    }
  }
  ce.IntBE = h
  const p = Math.pow(2, 32)
  function y(E) {
    const C = Math.floor(E / p),
      L = E - C * p
    return { hi32: C, lo32: L }
  }
  function m(E, C) {
    return E * p + C
  }
  class b extends r {
    constructor(C) {
      super(8, C)
    }
    decode(C, L = 0) {
      const K = n(C),
        ee = K.readUInt32LE(L),
        oe = K.readUInt32LE(L + 4)
      return m(oe, ee)
    }
    encode(C, L, K = 0) {
      const ee = y(C),
        oe = n(L)
      return oe.writeUInt32LE(ee.lo32, K), oe.writeUInt32LE(ee.hi32, K + 4), 8
    }
  }
  ce.NearUInt64 = b
  class I extends r {
    constructor(C) {
      super(8, C)
    }
    decode(C, L = 0) {
      const K = n(C),
        ee = K.readUInt32BE(L),
        oe = K.readUInt32BE(L + 4)
      return m(ee, oe)
    }
    encode(C, L, K = 0) {
      const ee = y(C),
        oe = n(L)
      return oe.writeUInt32BE(ee.hi32, K), oe.writeUInt32BE(ee.lo32, K + 4), 8
    }
  }
  ce.NearUInt64BE = I
  class x extends r {
    constructor(C) {
      super(8, C)
    }
    decode(C, L = 0) {
      const K = n(C),
        ee = K.readUInt32LE(L),
        oe = K.readInt32LE(L + 4)
      return m(oe, ee)
    }
    encode(C, L, K = 0) {
      const ee = y(C),
        oe = n(L)
      return oe.writeUInt32LE(ee.lo32, K), oe.writeInt32LE(ee.hi32, K + 4), 8
    }
  }
  ce.NearInt64 = x
  class _ extends r {
    constructor(C) {
      super(8, C)
    }
    decode(C, L = 0) {
      const K = n(C),
        ee = K.readInt32BE(L),
        oe = K.readUInt32BE(L + 4)
      return m(ee, oe)
    }
    encode(C, L, K = 0) {
      const ee = y(C),
        oe = n(L)
      return oe.writeInt32BE(ee.hi32, K), oe.writeUInt32BE(ee.lo32, K + 4), 8
    }
  }
  ce.NearInt64BE = _
  class R extends r {
    constructor(C) {
      super(4, C)
    }
    decode(C, L = 0) {
      return n(C).readFloatLE(L)
    }
    encode(C, L, K = 0) {
      return n(L).writeFloatLE(C, K), 4
    }
  }
  ce.Float = R
  class N extends r {
    constructor(C) {
      super(4, C)
    }
    decode(C, L = 0) {
      return n(C).readFloatBE(L)
    }
    encode(C, L, K = 0) {
      return n(L).writeFloatBE(C, K), 4
    }
  }
  ce.FloatBE = N
  class T extends r {
    constructor(C) {
      super(8, C)
    }
    decode(C, L = 0) {
      return n(C).readDoubleLE(L)
    }
    encode(C, L, K = 0) {
      return n(L).writeDoubleLE(C, K), 8
    }
  }
  ce.Double = T
  class M extends r {
    constructor(C) {
      super(8, C)
    }
    decode(C, L = 0) {
      return n(C).readDoubleBE(L)
    }
    encode(C, L, K = 0) {
      return n(L).writeDoubleBE(C, K), 8
    }
  }
  ce.DoubleBE = M
  class H extends r {
    constructor(C, L, K) {
      if (!(C instanceof r)) throw new TypeError('elementLayout must be a Layout')
      if (!((L instanceof o && L.isCount()) || (Number.isInteger(L) && 0 <= L)))
        throw new TypeError(
          'count must be non-negative integer or an unsigned integer ExternalLayout'
        )
      let ee = -1
      !(L instanceof o) && 0 < C.span && (ee = L * C.span),
        super(ee, K),
        (this.elementLayout = C),
        (this.count = L)
    }
    getSpan(C, L = 0) {
      if (0 <= this.span) return this.span
      let K = 0,
        ee = this.count
      if ((ee instanceof o && (ee = ee.decode(C, L)), 0 < this.elementLayout.span))
        K = ee * this.elementLayout.span
      else {
        let oe = 0
        for (; oe < ee; ) (K += this.elementLayout.getSpan(C, L + K)), ++oe
      }
      return K
    }
    decode(C, L = 0) {
      const K = []
      let ee = 0,
        oe = this.count
      for (oe instanceof o && (oe = oe.decode(C, L)); ee < oe; )
        K.push(this.elementLayout.decode(C, L)), (L += this.elementLayout.getSpan(C, L)), (ee += 1)
      return K
    }
    encode(C, L, K = 0) {
      const ee = this.elementLayout,
        oe = C.reduce((fe, ve) => fe + ee.encode(ve, L, K + fe), 0)
      return this.count instanceof o && this.count.encode(C.length, L, K), oe
    }
  }
  ce.Sequence = H
  class B extends r {
    constructor(C, L, K) {
      if (!(Array.isArray(C) && C.reduce((oe, fe) => oe && fe instanceof r, !0)))
        throw new TypeError('fields must be array of Layout instances')
      typeof L == 'boolean' && K === void 0 && ((K = L), (L = void 0))
      for (const oe of C)
        if (0 > oe.span && oe.property === void 0)
          throw new Error('fields cannot contain unnamed variable-length layout')
      let ee = -1
      try {
        ee = C.reduce((oe, fe) => oe + fe.getSpan(), 0)
      } catch {}
      super(ee, L), (this.fields = C), (this.decodePrefixes = !!K)
    }
    getSpan(C, L = 0) {
      if (0 <= this.span) return this.span
      let K = 0
      try {
        K = this.fields.reduce((ee, oe) => {
          const fe = oe.getSpan(C, L)
          return (L += fe), ee + fe
        }, 0)
      } catch {
        throw new RangeError('indeterminate span')
      }
      return K
    }
    decode(C, L = 0) {
      e(C)
      const K = this.makeDestinationObject()
      for (const ee of this.fields)
        if (
          (ee.property !== void 0 && (K[ee.property] = ee.decode(C, L)),
          (L += ee.getSpan(C, L)),
          this.decodePrefixes && C.length === L)
        )
          break
      return K
    }
    encode(C, L, K = 0) {
      const ee = K
      let oe = 0,
        fe = 0
      for (const ve of this.fields) {
        let tt = ve.span
        if (((fe = 0 < tt ? tt : 0), ve.property !== void 0)) {
          const Ge = C[ve.property]
          Ge !== void 0 && ((fe = ve.encode(Ge, L, K)), 0 > tt && (tt = ve.getSpan(L, K)))
        }
        ;(oe = K), (K += tt)
      }
      return oe + fe - ee
    }
    fromArray(C) {
      const L = this.makeDestinationObject()
      for (const K of this.fields)
        K.property !== void 0 && 0 < C.length && (L[K.property] = C.shift())
      return L
    }
    layoutFor(C) {
      if (typeof C != 'string') throw new TypeError('property must be string')
      for (const L of this.fields) if (L.property === C) return L
    }
    offsetOf(C) {
      if (typeof C != 'string') throw new TypeError('property must be string')
      let L = 0
      for (const K of this.fields) {
        if (K.property === C) return L
        0 > K.span ? (L = -1) : 0 <= L && (L += K.span)
      }
    }
  }
  ce.Structure = B
  class $ {
    constructor(C) {
      this.property = C
    }
    decode(C, L) {
      throw new Error('UnionDiscriminator is abstract')
    }
    encode(C, L, K) {
      throw new Error('UnionDiscriminator is abstract')
    }
  }
  ce.UnionDiscriminator = $
  class D extends $ {
    constructor(C, L) {
      if (!(C instanceof o && C.isCount()))
        throw new TypeError('layout must be an unsigned integer ExternalLayout')
      super(L || C.property || 'variant'), (this.layout = C)
    }
    decode(C, L) {
      return this.layout.decode(C, L)
    }
    encode(C, L, K) {
      return this.layout.encode(C, L, K)
    }
  }
  ce.UnionLayoutDiscriminator = D
  class W extends r {
    constructor(C, L, K) {
      let ee
      if (C instanceof u || C instanceof l) ee = new D(new c(C))
      else if (C instanceof o && C.isCount()) ee = new D(C)
      else if (C instanceof $) ee = C
      else throw new TypeError('discr must be a UnionDiscriminator or an unsigned integer layout')
      if ((L === void 0 && (L = null), !(L === null || L instanceof r)))
        throw new TypeError('defaultLayout must be null or a Layout')
      if (L !== null) {
        if (0 > L.span) throw new Error('defaultLayout must have constant span')
        L.property === void 0 && (L = L.replicate('content'))
      }
      let oe = -1
      L && ((oe = L.span), 0 <= oe && (C instanceof u || C instanceof l) && (oe += ee.layout.span)),
        super(oe, K),
        (this.discriminator = ee),
        (this.usesPrefixDiscriminator = C instanceof u || C instanceof l),
        (this.defaultLayout = L),
        (this.registry = {})
      let fe = this.defaultGetSourceVariant.bind(this)
      ;(this.getSourceVariant = function (ve) {
        return fe(ve)
      }),
        (this.configGetSourceVariant = function (ve) {
          fe = ve.bind(this)
        })
    }
    getSpan(C, L = 0) {
      if (0 <= this.span) return this.span
      const K = this.getVariant(C, L)
      if (!K) throw new Error('unable to determine span for unrecognized variant')
      return K.getSpan(C, L)
    }
    defaultGetSourceVariant(C) {
      if (Object.prototype.hasOwnProperty.call(C, this.discriminator.property)) {
        if (
          this.defaultLayout &&
          this.defaultLayout.property &&
          Object.prototype.hasOwnProperty.call(C, this.defaultLayout.property)
        )
          return
        const L = this.registry[C[this.discriminator.property]]
        if (L && (!L.layout || (L.property && Object.prototype.hasOwnProperty.call(C, L.property))))
          return L
      } else
        for (const L in this.registry) {
          const K = this.registry[L]
          if (K.property && Object.prototype.hasOwnProperty.call(C, K.property)) return K
        }
      throw new Error('unable to infer src variant')
    }
    decode(C, L = 0) {
      let K
      const ee = this.discriminator,
        oe = ee.decode(C, L),
        fe = this.registry[oe]
      if (fe === void 0) {
        const ve = this.defaultLayout
        let tt = 0
        this.usesPrefixDiscriminator && (tt = ee.layout.span),
          (K = this.makeDestinationObject()),
          (K[ee.property] = oe),
          (K[ve.property] = ve.decode(C, L + tt))
      } else K = fe.decode(C, L)
      return K
    }
    encode(C, L, K = 0) {
      const ee = this.getSourceVariant(C)
      if (ee === void 0) {
        const oe = this.discriminator,
          fe = this.defaultLayout
        let ve = 0
        return (
          this.usesPrefixDiscriminator && (ve = oe.layout.span),
          oe.encode(C[oe.property], L, K),
          ve + fe.encode(C[fe.property], L, K + ve)
        )
      }
      return ee.encode(C, L, K)
    }
    addVariant(C, L, K) {
      const ee = new U(this, C, L, K)
      return (this.registry[C] = ee), ee
    }
    getVariant(C, L = 0) {
      let K
      return (
        C instanceof Uint8Array ? (K = this.discriminator.decode(C, L)) : (K = C), this.registry[K]
      )
    }
  }
  ce.Union = W
  class U extends r {
    constructor(C, L, K, ee) {
      if (!(C instanceof W)) throw new TypeError('union must be a Union')
      if (!Number.isInteger(L) || 0 > L)
        throw new TypeError('variant must be a (non-negative) integer')
      if ((typeof K == 'string' && ee === void 0 && ((ee = K), (K = null)), K)) {
        if (!(K instanceof r)) throw new TypeError('layout must be a Layout')
        if (C.defaultLayout !== null && 0 <= K.span && K.span > C.defaultLayout.span)
          throw new Error('variant span exceeds span of containing union')
        if (typeof ee != 'string') throw new TypeError('variant must have a String property')
      }
      let oe = C.span
      0 > C.span &&
        ((oe = K ? K.span : 0),
        0 <= oe && C.usesPrefixDiscriminator && (oe += C.discriminator.layout.span)),
        super(oe, ee),
        (this.union = C),
        (this.variant = L),
        (this.layout = K || null)
    }
    getSpan(C, L = 0) {
      if (0 <= this.span) return this.span
      let K = 0
      this.union.usesPrefixDiscriminator && (K = this.union.discriminator.layout.span)
      let ee = 0
      return this.layout && (ee = this.layout.getSpan(C, L + K)), K + ee
    }
    decode(C, L = 0) {
      const K = this.makeDestinationObject()
      if (this !== this.union.getVariant(C, L)) throw new Error('variant mismatch')
      let ee = 0
      return (
        this.union.usesPrefixDiscriminator && (ee = this.union.discriminator.layout.span),
        this.layout
          ? (K[this.property] = this.layout.decode(C, L + ee))
          : this.property
            ? (K[this.property] = !0)
            : this.union.usesPrefixDiscriminator &&
              (K[this.union.discriminator.property] = this.variant),
        K
      )
    }
    encode(C, L, K = 0) {
      let ee = 0
      if (
        (this.union.usesPrefixDiscriminator && (ee = this.union.discriminator.layout.span),
        this.layout && !Object.prototype.hasOwnProperty.call(C, this.property))
      )
        throw new TypeError('variant lacks property ' + this.property)
      this.union.discriminator.encode(this.variant, L, K)
      let oe = ee
      if (
        this.layout &&
        (this.layout.encode(C[this.property], L, K + ee),
        (oe += this.layout.getSpan(L, K + ee)),
        0 <= this.union.span && oe > this.union.span)
      )
        throw new Error('encoded variant overruns containing union')
      return oe
    }
    fromArray(C) {
      if (this.layout) return this.layout.fromArray(C)
    }
  }
  ce.VariantLayout = U
  function w(E) {
    return 0 > E && (E += 4294967296), E
  }
  class v extends r {
    constructor(C, L, K) {
      if (!(C instanceof u || C instanceof l))
        throw new TypeError('word must be a UInt or UIntBE layout')
      if ((typeof L == 'string' && K === void 0 && ((K = L), (L = !1)), 4 < C.span))
        throw new RangeError('word cannot exceed 32 bits')
      super(C.span, K), (this.word = C), (this.msb = !!L), (this.fields = [])
      let ee = 0
      ;(this._packedSetValue = function (oe) {
        return (ee = w(oe)), this
      }),
        (this._packedGetValue = function () {
          return ee
        })
    }
    decode(C, L = 0) {
      const K = this.makeDestinationObject(),
        ee = this.word.decode(C, L)
      this._packedSetValue(ee)
      for (const oe of this.fields) oe.property !== void 0 && (K[oe.property] = oe.decode(C))
      return K
    }
    encode(C, L, K = 0) {
      const ee = this.word.decode(L, K)
      this._packedSetValue(ee)
      for (const oe of this.fields)
        if (oe.property !== void 0) {
          const fe = C[oe.property]
          fe !== void 0 && oe.encode(fe)
        }
      return this.word.encode(this._packedGetValue(), L, K)
    }
    addField(C, L) {
      const K = new A(this, C, L)
      return this.fields.push(K), K
    }
    addBoolean(C) {
      const L = new P(this, C)
      return this.fields.push(L), L
    }
    fieldFor(C) {
      if (typeof C != 'string') throw new TypeError('property must be string')
      for (const L of this.fields) if (L.property === C) return L
    }
  }
  ce.BitStructure = v
  class A {
    constructor(C, L, K) {
      if (!(C instanceof v)) throw new TypeError('container must be a BitStructure')
      if (!Number.isInteger(L) || 0 >= L) throw new TypeError('bits must be positive integer')
      const ee = 8 * C.span,
        oe = C.fields.reduce((fe, ve) => fe + ve.bits, 0)
      if (L + oe > ee)
        throw new Error('bits too long for span remainder (' + (ee - oe) + ' of ' + ee + ' remain)')
      ;(this.container = C),
        (this.bits = L),
        (this.valueMask = (1 << L) - 1),
        L === 32 && (this.valueMask = 4294967295),
        (this.start = oe),
        this.container.msb && (this.start = ee - oe - L),
        (this.wordMask = w(this.valueMask << this.start)),
        (this.property = K)
    }
    decode(C, L) {
      const K = this.container._packedGetValue()
      return w(K & this.wordMask) >>> this.start
    }
    encode(C) {
      if (typeof C != 'number' || !Number.isInteger(C) || C !== w(C & this.valueMask))
        throw new TypeError(
          s('BitField.encode', this) + ' value must be integer not exceeding ' + this.valueMask
        )
      const L = this.container._packedGetValue(),
        K = w(C << this.start)
      this.container._packedSetValue(w(L & ~this.wordMask) | K)
    }
  }
  ce.BitField = A
  class P extends A {
    constructor(C, L) {
      super(C, 1, L)
    }
    decode(C, L) {
      return !!super.decode(C, L)
    }
    encode(C) {
      typeof C == 'boolean' && (C = +C), super.encode(C)
    }
  }
  ce.Boolean = P
  class O extends r {
    constructor(C, L) {
      if (!((C instanceof o && C.isCount()) || (Number.isInteger(C) && 0 <= C)))
        throw new TypeError('length must be positive integer or an unsigned integer ExternalLayout')
      let K = -1
      C instanceof o || (K = C), super(K, L), (this.length = C)
    }
    getSpan(C, L) {
      let K = this.span
      return 0 > K && (K = this.length.decode(C, L)), K
    }
    decode(C, L = 0) {
      let K = this.span
      return 0 > K && (K = this.length.decode(C, L)), n(C).slice(L, L + K)
    }
    encode(C, L, K) {
      let ee = this.length
      if (
        (this.length instanceof o && (ee = C.length), !(C instanceof Uint8Array && ee === C.length))
      )
        throw new TypeError(
          s('Blob.encode', this) + ' requires (length ' + ee + ') Uint8Array as src'
        )
      if (K + ee > L.length) throw new RangeError('encoding overruns Uint8Array')
      const oe = n(C)
      return (
        n(L).write(oe.toString('hex'), K, ee, 'hex'),
        this.length instanceof o && this.length.encode(ee, L, K),
        ee
      )
    }
  }
  ce.Blob = O
  class F extends r {
    constructor(C) {
      super(-1, C)
    }
    getSpan(C, L = 0) {
      e(C)
      let K = L
      for (; K < C.length && C[K] !== 0; ) K += 1
      return 1 + K - L
    }
    decode(C, L = 0) {
      const K = this.getSpan(C, L)
      return n(C)
        .slice(L, L + K - 1)
        .toString('utf-8')
    }
    encode(C, L, K = 0) {
      typeof C != 'string' && (C = String(C))
      const ee = t.Buffer.from(C, 'utf8'),
        oe = ee.length
      if (K + oe > L.length) throw new RangeError('encoding overruns Buffer')
      const fe = n(L)
      return ee.copy(fe, K), (fe[K + oe] = 0), oe + 1
    }
  }
  ce.CString = F
  class z extends r {
    constructor(C, L) {
      if ((typeof C == 'string' && L === void 0 && ((L = C), (C = void 0)), C === void 0)) C = -1
      else if (!Number.isInteger(C)) throw new TypeError('maxSpan must be an integer')
      super(-1, L), (this.maxSpan = C)
    }
    getSpan(C, L = 0) {
      return e(C), C.length - L
    }
    decode(C, L = 0) {
      const K = this.getSpan(C, L)
      if (0 <= this.maxSpan && this.maxSpan < K) throw new RangeError('text length exceeds maxSpan')
      return n(C)
        .slice(L, L + K)
        .toString('utf-8')
    }
    encode(C, L, K = 0) {
      typeof C != 'string' && (C = String(C))
      const ee = t.Buffer.from(C, 'utf8'),
        oe = ee.length
      if (0 <= this.maxSpan && this.maxSpan < oe)
        throw new RangeError('text length exceeds maxSpan')
      if (K + oe > L.length) throw new RangeError('encoding overruns Buffer')
      return ee.copy(n(L), K), oe
    }
  }
  ce.UTF8 = z
  class j extends r {
    constructor(C, L) {
      super(0, L), (this.value = C)
    }
    decode(C, L) {
      return this.value
    }
    encode(C, L, K) {
      return 0
    }
  }
  return (
    (ce.Constant = j),
    (ce.greedy = (E, C) => new a(E, C)),
    (ce.offset = (E, C, L) => new c(E, C, L)),
    (ce.u8 = E => new u(1, E)),
    (ce.u16 = E => new u(2, E)),
    (ce.u24 = E => new u(3, E)),
    (ce.u32 = E => new u(4, E)),
    (ce.u40 = E => new u(5, E)),
    (ce.u48 = E => new u(6, E)),
    (ce.nu64 = E => new b(E)),
    (ce.u16be = E => new l(2, E)),
    (ce.u24be = E => new l(3, E)),
    (ce.u32be = E => new l(4, E)),
    (ce.u40be = E => new l(5, E)),
    (ce.u48be = E => new l(6, E)),
    (ce.nu64be = E => new I(E)),
    (ce.s8 = E => new d(1, E)),
    (ce.s16 = E => new d(2, E)),
    (ce.s24 = E => new d(3, E)),
    (ce.s32 = E => new d(4, E)),
    (ce.s40 = E => new d(5, E)),
    (ce.s48 = E => new d(6, E)),
    (ce.ns64 = E => new x(E)),
    (ce.s16be = E => new h(2, E)),
    (ce.s24be = E => new h(3, E)),
    (ce.s32be = E => new h(4, E)),
    (ce.s40be = E => new h(5, E)),
    (ce.s48be = E => new h(6, E)),
    (ce.ns64be = E => new _(E)),
    (ce.f32 = E => new R(E)),
    (ce.f32be = E => new N(E)),
    (ce.f64 = E => new T(E)),
    (ce.f64be = E => new M(E)),
    (ce.struct = (E, C, L) => new B(E, C, L)),
    (ce.bits = (E, C, L) => new v(E, C, L)),
    (ce.seq = (E, C, L) => new H(E, C, L)),
    (ce.union = (E, C, L) => new W(E, C, L)),
    (ce.unionLayoutDiscriminator = (E, C) => new D(E, C)),
    (ce.blob = (E, C) => new O(E, C)),
    (ce.cstr = E => new F(E)),
    (ce.utf8 = (E, C) => new z(E, C)),
    (ce.constant = (E, C) => new j(E, C)),
    ce
  )
}
var re = Kle(),
  Cc = {},
  dT
function Vle() {
  if (dT) return Cc
  ;(dT = 1), Object.defineProperty(Cc, '__esModule', { value: !0 })
  function t(s) {
    {
      const i = Buffer.from(s)
      i.reverse()
      const o = i.toString('hex')
      return o.length === 0 ? BigInt(0) : BigInt(`0x${o}`)
    }
  }
  Cc.toBigIntLE = t
  function e(s) {
    {
      const i = s.toString('hex')
      return i.length === 0 ? BigInt(0) : BigInt(`0x${i}`)
    }
  }
  Cc.toBigIntBE = e
  function n(s, i) {
    {
      const o = s.toString(16),
        a = Buffer.from(o.padStart(i * 2, '0').slice(0, i * 2), 'hex')
      return a.reverse(), a
    }
  }
  Cc.toBufferLE = n
  function r(s, i) {
    {
      const o = s.toString(16)
      return Buffer.from(o.padStart(i * 2, '0').slice(0, i * 2), 'hex')
    }
  }
  return (Cc.toBufferBE = r), Cc
}
var hT = Vle()
class Gle extends TypeError {
  constructor(e, n) {
    let r
    const { message: s, explanation: i, ...o } = e,
      { path: a } = e,
      c = a.length === 0 ? s : `At path: ${a.join('.')} -- ${s}`
    super(i ?? c),
      i != null && (this.cause = c),
      Object.assign(this, o),
      (this.name = this.constructor.name),
      (this.failures = () => r ?? (r = [e, ...n()]))
  }
}
function Qle(t) {
  return Tp(t) && typeof t[Symbol.iterator] == 'function'
}
function Tp(t) {
  return typeof t == 'object' && t != null
}
function jm(t) {
  return Tp(t) && !Array.isArray(t)
}
function Bi(t) {
  return typeof t == 'symbol' ? t.toString() : typeof t == 'string' ? JSON.stringify(t) : `${t}`
}
function Zle(t) {
  const { done: e, value: n } = t.next()
  return e ? void 0 : n
}
function Yle(t, e, n, r) {
  if (t === !0) return
  t === !1 ? (t = {}) : typeof t == 'string' && (t = { message: t })
  const { path: s, branch: i } = e,
    { type: o } = n,
    {
      refinement: a,
      message:
        c = `Expected a value of type \`${o}\`${a ? ` with refinement \`${a}\`` : ''}, but received: \`${Bi(r)}\``
    } = t
  return {
    value: r,
    type: o,
    refinement: a,
    key: s[s.length - 1],
    path: s,
    branch: i,
    ...t,
    message: c
  }
}
function* fT(t, e, n, r) {
  Qle(t) || (t = [t])
  for (const s of t) {
    const i = Yle(s, e, n, r)
    i && (yield i)
  }
}
function* t_(t, e, n = {}) {
  const { path: r = [], branch: s = [t], coerce: i = !1, mask: o = !1 } = n,
    a = { path: r, branch: s, mask: o }
  i && (t = e.coercer(t, a))
  let c = 'valid'
  for (const u of e.validator(t, a))
    (u.explanation = n.message), (c = 'not_valid'), yield [u, void 0]
  for (let [u, l, d] of e.entries(t, a)) {
    const h = t_(l, d, {
      path: u === void 0 ? r : [...r, u],
      branch: u === void 0 ? s : [...s, l],
      coerce: i,
      mask: o,
      message: n.message
    })
    for (const p of h)
      p[0]
        ? ((c = p[0].refinement != null ? 'not_refined' : 'not_valid'), yield [p[0], void 0])
        : i &&
          ((l = p[1]),
          u === void 0
            ? (t = l)
            : t instanceof Map
              ? t.set(u, l)
              : t instanceof Set
                ? t.add(l)
                : Tp(t) && (l !== void 0 || u in t) && (t[u] = l))
  }
  if (c !== 'not_valid')
    for (const u of e.refiner(t, a))
      (u.explanation = n.message), (c = 'not_refined'), yield [u, void 0]
  c === 'valid' && (yield [void 0, t])
}
let mo = class {
  constructor(e) {
    const {
      type: n,
      schema: r,
      validator: s,
      refiner: i,
      coercer: o = c => c,
      entries: a = function* () {}
    } = e
    ;(this.type = n),
      (this.schema = r),
      (this.entries = a),
      (this.coercer = o),
      s
        ? (this.validator = (c, u) => {
            const l = s(c, u)
            return fT(l, u, this, c)
          })
        : (this.validator = () => []),
      i
        ? (this.refiner = (c, u) => {
            const l = i(c, u)
            return fT(l, u, this, c)
          })
        : (this.refiner = () => [])
  }
  assert(e, n) {
    return Jle(e, this, n)
  }
  create(e, n) {
    return Fe(e, this, n)
  }
  is(e) {
    return t5(e, this)
  }
  mask(e, n) {
    return Xle(e, this, n)
  }
  validate(e, n = {}) {
    return Np(e, this, n)
  }
}
function Jle(t, e, n) {
  const r = Np(t, e, { message: n })
  if (r[0]) throw r[0]
}
function Fe(t, e, n) {
  const r = Np(t, e, { coerce: !0, message: n })
  if (r[0]) throw r[0]
  return r[1]
}
function Xle(t, e, n) {
  const r = Np(t, e, { coerce: !0, mask: !0, message: n })
  if (r[0]) throw r[0]
  return r[1]
}
function t5(t, e) {
  return !Np(t, e)[0]
}
function Np(t, e, n = {}) {
  const r = t_(t, e, n),
    s = Zle(r)
  return s[0]
    ? [
        new Gle(s[0], function* () {
          for (const o of r) o[0] && (yield o[0])
        }),
        void 0
      ]
    : [void 0, s[1]]
}
function Ou(t, e) {
  return new mo({ type: t, schema: null, validator: e })
}
function ede() {
  return Ou('any', () => !0)
}
function He(t) {
  return new mo({
    type: 'array',
    schema: t,
    *entries(e) {
      if (t && Array.isArray(e)) for (const [n, r] of e.entries()) yield [n, r, t]
    },
    coercer(e) {
      return Array.isArray(e) ? e.slice() : e
    },
    validator(e) {
      return Array.isArray(e) || `Expected an array value, but received: ${Bi(e)}`
    }
  })
}
function fo() {
  return Ou('boolean', t => typeof t == 'boolean')
}
function n_(t) {
  return Ou(
    'instance',
    e => e instanceof t || `Expected a \`${t.name}\` instance, but received: ${Bi(e)}`
  )
}
function Bn(t) {
  const e = Bi(t),
    n = typeof t
  return new mo({
    type: 'literal',
    schema: n === 'string' || n === 'number' || n === 'boolean' ? t : null,
    validator(r) {
      return r === t || `Expected the literal \`${e}\`, but received: ${Bi(r)}`
    }
  })
}
function tde() {
  return Ou('never', () => !1)
}
function ze(t) {
  return new mo({
    ...t,
    validator: (e, n) => e === null || t.validator(e, n),
    refiner: (e, n) => e === null || t.refiner(e, n)
  })
}
function ae() {
  return Ou(
    'number',
    t => (typeof t == 'number' && !isNaN(t)) || `Expected a number, but received: ${Bi(t)}`
  )
}
function lt(t) {
  return new mo({
    ...t,
    validator: (e, n) => e === void 0 || t.validator(e, n),
    refiner: (e, n) => e === void 0 || t.refiner(e, n)
  })
}
function n5(t, e) {
  return new mo({
    type: 'record',
    schema: null,
    *entries(n) {
      if (Tp(n))
        for (const r in n) {
          const s = n[r]
          yield [r, r, t], yield [r, s, e]
        }
    },
    validator(n) {
      return jm(n) || `Expected an object, but received: ${Bi(n)}`
    },
    coercer(n) {
      return jm(n) ? { ...n } : n
    }
  })
}
function De() {
  return Ou('string', t => typeof t == 'string' || `Expected a string, but received: ${Bi(t)}`)
}
function r_(t) {
  const e = tde()
  return new mo({
    type: 'tuple',
    schema: null,
    *entries(n) {
      if (Array.isArray(n)) {
        const r = Math.max(t.length, n.length)
        for (let s = 0; s < r; s++) yield [s, n[s], t[s] || e]
      }
    },
    validator(n) {
      return Array.isArray(n) || `Expected an array, but received: ${Bi(n)}`
    },
    coercer(n) {
      return Array.isArray(n) ? n.slice() : n
    }
  })
}
function Ce(t) {
  const e = Object.keys(t)
  return new mo({
    type: 'type',
    schema: t,
    *entries(n) {
      if (Tp(n)) for (const r of e) yield [r, n[r], t[r]]
    },
    validator(n) {
      return jm(n) || `Expected an object, but received: ${Bi(n)}`
    },
    coercer(n) {
      return jm(n) ? { ...n } : n
    }
  })
}
function ds(t) {
  const e = t.map(n => n.type).join(' | ')
  return new mo({
    type: 'union',
    schema: null,
    coercer(n, r) {
      for (const s of t) {
        const [i, o] = s.validate(n, { coerce: !0, mask: r.mask })
        if (!i) return o
      }
      return n
    },
    validator(n, r) {
      const s = []
      for (const i of t) {
        const [...o] = t_(n, i, r),
          [a] = o
        if (a[0]) for (const [c] of o) c && s.push(c)
        else return []
      }
      return [`Expected the value to satisfy a union of \`${e}\`, but received: ${Bi(n)}`, ...s]
    }
  })
}
function Bd() {
  return Ou('unknown', () => !0)
}
function Pp(t, e, n) {
  return new mo({ ...t, coercer: (r, s) => (t5(r, e) ? t.coercer(n(r, s), s) : t.coercer(r, s)) })
}
var vg,
  nde = new Uint8Array(16)
function r5() {
  if (
    !vg &&
    ((vg =
      (typeof crypto < 'u' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
      (typeof msCrypto < 'u' &&
        typeof msCrypto.getRandomValues == 'function' &&
        msCrypto.getRandomValues.bind(msCrypto))),
    !vg)
  )
    throw new Error(
      'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'
    )
  return vg(nde)
}
const rde =
  /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
function cy(t) {
  return typeof t == 'string' && rde.test(t)
}
var Cr = []
for (var Ob = 0; Ob < 256; ++Ob) Cr.push((Ob + 256).toString(16).substr(1))
function uy(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
    n = (
      Cr[t[e + 0]] +
      Cr[t[e + 1]] +
      Cr[t[e + 2]] +
      Cr[t[e + 3]] +
      '-' +
      Cr[t[e + 4]] +
      Cr[t[e + 5]] +
      '-' +
      Cr[t[e + 6]] +
      Cr[t[e + 7]] +
      '-' +
      Cr[t[e + 8]] +
      Cr[t[e + 9]] +
      '-' +
      Cr[t[e + 10]] +
      Cr[t[e + 11]] +
      Cr[t[e + 12]] +
      Cr[t[e + 13]] +
      Cr[t[e + 14]] +
      Cr[t[e + 15]]
    ).toLowerCase()
  if (!cy(n)) throw TypeError('Stringified UUID is invalid')
  return n
}
var pT,
  Bb,
  Db = 0,
  Mb = 0
function sde(t, e, n) {
  var r = (e && n) || 0,
    s = e || new Array(16)
  t = t || {}
  var i = t.node || pT,
    o = t.clockseq !== void 0 ? t.clockseq : Bb
  if (i == null || o == null) {
    var a = t.random || (t.rng || r5)()
    i == null && (i = pT = [a[0] | 1, a[1], a[2], a[3], a[4], a[5]]),
      o == null && (o = Bb = ((a[6] << 8) | a[7]) & 16383)
  }
  var c = t.msecs !== void 0 ? t.msecs : Date.now(),
    u = t.nsecs !== void 0 ? t.nsecs : Mb + 1,
    l = c - Db + (u - Mb) / 1e4
  if (
    (l < 0 && t.clockseq === void 0 && (o = (o + 1) & 16383),
    (l < 0 || c > Db) && t.nsecs === void 0 && (u = 0),
    u >= 1e4)
  )
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec")
  ;(Db = c), (Mb = u), (Bb = o), (c += 122192928e5)
  var d = ((c & 268435455) * 1e4 + u) % 4294967296
  ;(s[r++] = (d >>> 24) & 255),
    (s[r++] = (d >>> 16) & 255),
    (s[r++] = (d >>> 8) & 255),
    (s[r++] = d & 255)
  var h = ((c / 4294967296) * 1e4) & 268435455
  ;(s[r++] = (h >>> 8) & 255),
    (s[r++] = h & 255),
    (s[r++] = ((h >>> 24) & 15) | 16),
    (s[r++] = (h >>> 16) & 255),
    (s[r++] = (o >>> 8) | 128),
    (s[r++] = o & 255)
  for (var p = 0; p < 6; ++p) s[r + p] = i[p]
  return e || uy(s)
}
function s5(t) {
  if (!cy(t)) throw TypeError('Invalid UUID')
  var e,
    n = new Uint8Array(16)
  return (
    (n[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24),
    (n[1] = (e >>> 16) & 255),
    (n[2] = (e >>> 8) & 255),
    (n[3] = e & 255),
    (n[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8),
    (n[5] = e & 255),
    (n[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8),
    (n[7] = e & 255),
    (n[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8),
    (n[9] = e & 255),
    (n[10] = ((e = parseInt(t.slice(24, 36), 16)) / 1099511627776) & 255),
    (n[11] = (e / 4294967296) & 255),
    (n[12] = (e >>> 24) & 255),
    (n[13] = (e >>> 16) & 255),
    (n[14] = (e >>> 8) & 255),
    (n[15] = e & 255),
    n
  )
}
function ide(t) {
  t = unescape(encodeURIComponent(t))
  for (var e = [], n = 0; n < t.length; ++n) e.push(t.charCodeAt(n))
  return e
}
var ode = '6ba7b810-9dad-11d1-80b4-00c04fd430c8',
  ade = '6ba7b811-9dad-11d1-80b4-00c04fd430c8'
function i5(t, e, n) {
  function r(s, i, o, a) {
    if (
      (typeof s == 'string' && (s = ide(s)), typeof i == 'string' && (i = s5(i)), i.length !== 16)
    )
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)')
    var c = new Uint8Array(16 + s.length)
    if (
      (c.set(i),
      c.set(s, i.length),
      (c = n(c)),
      (c[6] = (c[6] & 15) | e),
      (c[8] = (c[8] & 63) | 128),
      o)
    ) {
      a = a || 0
      for (var u = 0; u < 16; ++u) o[a + u] = c[u]
      return o
    }
    return uy(c)
  }
  try {
    r.name = t
  } catch {}
  return (r.DNS = ode), (r.URL = ade), r
}
function cde(t) {
  if (typeof t == 'string') {
    var e = unescape(encodeURIComponent(t))
    t = new Uint8Array(e.length)
    for (var n = 0; n < e.length; ++n) t[n] = e.charCodeAt(n)
  }
  return ude(lde(dde(t), t.length * 8))
}
function ude(t) {
  for (var e = [], n = t.length * 32, r = '0123456789abcdef', s = 0; s < n; s += 8) {
    var i = (t[s >> 5] >>> s % 32) & 255,
      o = parseInt(r.charAt((i >>> 4) & 15) + r.charAt(i & 15), 16)
    e.push(o)
  }
  return e
}
function o5(t) {
  return (((t + 64) >>> 9) << 4) + 14 + 1
}
function lde(t, e) {
  ;(t[e >> 5] |= 128 << e % 32), (t[o5(e) - 1] = e)
  for (
    var n = 1732584193, r = -271733879, s = -1732584194, i = 271733878, o = 0;
    o < t.length;
    o += 16
  ) {
    var a = n,
      c = r,
      u = s,
      l = i
    ;(n = Ur(n, r, s, i, t[o], 7, -680876936)),
      (i = Ur(i, n, r, s, t[o + 1], 12, -389564586)),
      (s = Ur(s, i, n, r, t[o + 2], 17, 606105819)),
      (r = Ur(r, s, i, n, t[o + 3], 22, -1044525330)),
      (n = Ur(n, r, s, i, t[o + 4], 7, -176418897)),
      (i = Ur(i, n, r, s, t[o + 5], 12, 1200080426)),
      (s = Ur(s, i, n, r, t[o + 6], 17, -1473231341)),
      (r = Ur(r, s, i, n, t[o + 7], 22, -45705983)),
      (n = Ur(n, r, s, i, t[o + 8], 7, 1770035416)),
      (i = Ur(i, n, r, s, t[o + 9], 12, -1958414417)),
      (s = Ur(s, i, n, r, t[o + 10], 17, -42063)),
      (r = Ur(r, s, i, n, t[o + 11], 22, -1990404162)),
      (n = Ur(n, r, s, i, t[o + 12], 7, 1804603682)),
      (i = Ur(i, n, r, s, t[o + 13], 12, -40341101)),
      (s = Ur(s, i, n, r, t[o + 14], 17, -1502002290)),
      (r = Ur(r, s, i, n, t[o + 15], 22, 1236535329)),
      (n = Lr(n, r, s, i, t[o + 1], 5, -165796510)),
      (i = Lr(i, n, r, s, t[o + 6], 9, -1069501632)),
      (s = Lr(s, i, n, r, t[o + 11], 14, 643717713)),
      (r = Lr(r, s, i, n, t[o], 20, -373897302)),
      (n = Lr(n, r, s, i, t[o + 5], 5, -701558691)),
      (i = Lr(i, n, r, s, t[o + 10], 9, 38016083)),
      (s = Lr(s, i, n, r, t[o + 15], 14, -660478335)),
      (r = Lr(r, s, i, n, t[o + 4], 20, -405537848)),
      (n = Lr(n, r, s, i, t[o + 9], 5, 568446438)),
      (i = Lr(i, n, r, s, t[o + 14], 9, -1019803690)),
      (s = Lr(s, i, n, r, t[o + 3], 14, -187363961)),
      (r = Lr(r, s, i, n, t[o + 8], 20, 1163531501)),
      (n = Lr(n, r, s, i, t[o + 13], 5, -1444681467)),
      (i = Lr(i, n, r, s, t[o + 2], 9, -51403784)),
      (s = Lr(s, i, n, r, t[o + 7], 14, 1735328473)),
      (r = Lr(r, s, i, n, t[o + 12], 20, -1926607734)),
      (n = $r(n, r, s, i, t[o + 5], 4, -378558)),
      (i = $r(i, n, r, s, t[o + 8], 11, -2022574463)),
      (s = $r(s, i, n, r, t[o + 11], 16, 1839030562)),
      (r = $r(r, s, i, n, t[o + 14], 23, -35309556)),
      (n = $r(n, r, s, i, t[o + 1], 4, -1530992060)),
      (i = $r(i, n, r, s, t[o + 4], 11, 1272893353)),
      (s = $r(s, i, n, r, t[o + 7], 16, -155497632)),
      (r = $r(r, s, i, n, t[o + 10], 23, -1094730640)),
      (n = $r(n, r, s, i, t[o + 13], 4, 681279174)),
      (i = $r(i, n, r, s, t[o], 11, -358537222)),
      (s = $r(s, i, n, r, t[o + 3], 16, -722521979)),
      (r = $r(r, s, i, n, t[o + 6], 23, 76029189)),
      (n = $r(n, r, s, i, t[o + 9], 4, -640364487)),
      (i = $r(i, n, r, s, t[o + 12], 11, -421815835)),
      (s = $r(s, i, n, r, t[o + 15], 16, 530742520)),
      (r = $r(r, s, i, n, t[o + 2], 23, -995338651)),
      (n = Fr(n, r, s, i, t[o], 6, -198630844)),
      (i = Fr(i, n, r, s, t[o + 7], 10, 1126891415)),
      (s = Fr(s, i, n, r, t[o + 14], 15, -1416354905)),
      (r = Fr(r, s, i, n, t[o + 5], 21, -57434055)),
      (n = Fr(n, r, s, i, t[o + 12], 6, 1700485571)),
      (i = Fr(i, n, r, s, t[o + 3], 10, -1894986606)),
      (s = Fr(s, i, n, r, t[o + 10], 15, -1051523)),
      (r = Fr(r, s, i, n, t[o + 1], 21, -2054922799)),
      (n = Fr(n, r, s, i, t[o + 8], 6, 1873313359)),
      (i = Fr(i, n, r, s, t[o + 15], 10, -30611744)),
      (s = Fr(s, i, n, r, t[o + 6], 15, -1560198380)),
      (r = Fr(r, s, i, n, t[o + 13], 21, 1309151649)),
      (n = Fr(n, r, s, i, t[o + 4], 6, -145523070)),
      (i = Fr(i, n, r, s, t[o + 11], 10, -1120210379)),
      (s = Fr(s, i, n, r, t[o + 2], 15, 718787259)),
      (r = Fr(r, s, i, n, t[o + 9], 21, -343485551)),
      (n = $a(n, a)),
      (r = $a(r, c)),
      (s = $a(s, u)),
      (i = $a(i, l))
  }
  return [n, r, s, i]
}
function dde(t) {
  if (t.length === 0) return []
  for (var e = t.length * 8, n = new Uint32Array(o5(e)), r = 0; r < e; r += 8)
    n[r >> 5] |= (t[r / 8] & 255) << r % 32
  return n
}
function $a(t, e) {
  var n = (t & 65535) + (e & 65535),
    r = (t >> 16) + (e >> 16) + (n >> 16)
  return (r << 16) | (n & 65535)
}
function hde(t, e) {
  return (t << e) | (t >>> (32 - e))
}
function ly(t, e, n, r, s, i) {
  return $a(hde($a($a(e, t), $a(r, i)), s), n)
}
function Ur(t, e, n, r, s, i, o) {
  return ly((e & n) | (~e & r), t, e, s, i, o)
}
function Lr(t, e, n, r, s, i, o) {
  return ly((e & r) | (n & ~r), t, e, s, i, o)
}
function $r(t, e, n, r, s, i, o) {
  return ly(e ^ n ^ r, t, e, s, i, o)
}
function Fr(t, e, n, r, s, i, o) {
  return ly(n ^ (e | ~r), t, e, s, i, o)
}
var fde = i5('v3', 48, cde)
function pde(t, e, n) {
  t = t || {}
  var r = t.random || (t.rng || r5)()
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), e)) {
    n = n || 0
    for (var s = 0; s < 16; ++s) e[n + s] = r[s]
    return e
  }
  return uy(r)
}
function gde(t, e, n, r) {
  switch (t) {
    case 0:
      return (e & n) ^ (~e & r)
    case 1:
      return e ^ n ^ r
    case 2:
      return (e & n) ^ (e & r) ^ (n & r)
    case 3:
      return e ^ n ^ r
  }
}
function Ub(t, e) {
  return (t << e) | (t >>> (32 - e))
}
function mde(t) {
  var e = [1518500249, 1859775393, 2400959708, 3395469782],
    n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]
  if (typeof t == 'string') {
    var r = unescape(encodeURIComponent(t))
    t = []
    for (var s = 0; s < r.length; ++s) t.push(r.charCodeAt(s))
  } else Array.isArray(t) || (t = Array.prototype.slice.call(t))
  t.push(128)
  for (var i = t.length / 4 + 2, o = Math.ceil(i / 16), a = new Array(o), c = 0; c < o; ++c) {
    for (var u = new Uint32Array(16), l = 0; l < 16; ++l)
      u[l] =
        (t[c * 64 + l * 4] << 24) |
        (t[c * 64 + l * 4 + 1] << 16) |
        (t[c * 64 + l * 4 + 2] << 8) |
        t[c * 64 + l * 4 + 3]
    a[c] = u
  }
  ;(a[o - 1][14] = ((t.length - 1) * 8) / Math.pow(2, 32)),
    (a[o - 1][14] = Math.floor(a[o - 1][14])),
    (a[o - 1][15] = ((t.length - 1) * 8) & 4294967295)
  for (var d = 0; d < o; ++d) {
    for (var h = new Uint32Array(80), p = 0; p < 16; ++p) h[p] = a[d][p]
    for (var y = 16; y < 80; ++y) h[y] = Ub(h[y - 3] ^ h[y - 8] ^ h[y - 14] ^ h[y - 16], 1)
    for (var m = n[0], b = n[1], I = n[2], x = n[3], _ = n[4], R = 0; R < 80; ++R) {
      var N = Math.floor(R / 20),
        T = (Ub(m, 5) + gde(N, b, I, x) + _ + e[N] + h[R]) >>> 0
      ;(_ = x), (x = I), (I = Ub(b, 30) >>> 0), (b = m), (m = T)
    }
    ;(n[0] = (n[0] + m) >>> 0),
      (n[1] = (n[1] + b) >>> 0),
      (n[2] = (n[2] + I) >>> 0),
      (n[3] = (n[3] + x) >>> 0),
      (n[4] = (n[4] + _) >>> 0)
  }
  return [
    (n[0] >> 24) & 255,
    (n[0] >> 16) & 255,
    (n[0] >> 8) & 255,
    n[0] & 255,
    (n[1] >> 24) & 255,
    (n[1] >> 16) & 255,
    (n[1] >> 8) & 255,
    n[1] & 255,
    (n[2] >> 24) & 255,
    (n[2] >> 16) & 255,
    (n[2] >> 8) & 255,
    n[2] & 255,
    (n[3] >> 24) & 255,
    (n[3] >> 16) & 255,
    (n[3] >> 8) & 255,
    n[3] & 255,
    (n[4] >> 24) & 255,
    (n[4] >> 16) & 255,
    (n[4] >> 8) & 255,
    n[4] & 255
  ]
}
var yde = i5('v5', 80, mde)
const wde = '00000000-0000-0000-0000-000000000000'
function bde(t) {
  if (!cy(t)) throw TypeError('Invalid UUID')
  return parseInt(t.substr(14, 1), 16)
}
const vde = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        NIL: wde,
        parse: s5,
        stringify: uy,
        v1: sde,
        v3: fde,
        v4: pde,
        v5: yde,
        validate: cy,
        version: bde
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  a5 = N0(vde)
var Lb, gT
function Ede() {
  if (gT) return Lb
  gT = 1
  const t = a5.v4
  return (
    (Lb = function (n, r, s, i) {
      if (typeof n != 'string') throw new TypeError(n + ' must be a string')
      i = i || {}
      const o = typeof i.version == 'number' ? i.version : 2
      if (o !== 1 && o !== 2) throw new TypeError(o + ' must be 1 or 2')
      const a = { method: n }
      if ((o === 2 && (a.jsonrpc = '2.0'), r)) {
        if (typeof r != 'object' && !Array.isArray(r))
          throw new TypeError(r + ' must be an object, array or omitted')
        a.params = r
      }
      if (typeof s > 'u') {
        const c =
          typeof i.generator == 'function'
            ? i.generator
            : function () {
                return t()
              }
        a.id = c(a, i)
      } else o === 2 && s === null ? i.notificationIdNull && (a.id = null) : (a.id = s)
      return a
    }),
    Lb
  )
}
var $b, mT
function Ade() {
  if (mT) return $b
  mT = 1
  const t = a5.v4,
    e = Ede(),
    n = function (r, s) {
      if (!(this instanceof n)) return new n(r, s)
      s || (s = {}),
        (this.options = {
          reviver: typeof s.reviver < 'u' ? s.reviver : null,
          replacer: typeof s.replacer < 'u' ? s.replacer : null,
          generator:
            typeof s.generator < 'u'
              ? s.generator
              : function () {
                  return t()
                },
          version: typeof s.version < 'u' ? s.version : 2,
          notificationIdNull: typeof s.notificationIdNull == 'boolean' ? s.notificationIdNull : !1
        }),
        (this.callServer = r)
    }
  return (
    ($b = n),
    (n.prototype.request = function (r, s, i, o) {
      const a = this
      let c = null
      const u = Array.isArray(r) && typeof s == 'function'
      if (this.options.version === 1 && u)
        throw new TypeError('JSON-RPC 1.0 does not support batching')
      if (u || (!u && r && typeof r == 'object' && typeof s == 'function')) (o = s), (c = r)
      else {
        typeof i == 'function' && ((o = i), (i = void 0))
        const h = typeof o == 'function'
        try {
          c = e(r, s, i, {
            generator: this.options.generator,
            version: this.options.version,
            notificationIdNull: this.options.notificationIdNull
          })
        } catch (p) {
          if (h) return o(p)
          throw p
        }
        if (!h) return c
      }
      let d
      try {
        d = JSON.stringify(c, this.options.replacer)
      } catch (h) {
        return o(h)
      }
      return (
        this.callServer(d, function (h, p) {
          a._parseResponse(h, p, o)
        }),
        c
      )
    }),
    (n.prototype._parseResponse = function (r, s, i) {
      if (r) {
        i(r)
        return
      }
      if (!s) return i()
      let o
      try {
        o = JSON.parse(s, this.options.reviver)
      } catch (a) {
        return i(a)
      }
      if (i.length === 3)
        if (Array.isArray(o)) {
          const a = function (u) {
              return typeof u.error < 'u'
            },
            c = function (u) {
              return !a(u)
            }
          return i(null, o.filter(a), o.filter(c))
        } else return i(null, o.error, o.result)
      i(null, o)
    }),
    $b
  )
}
var _de = Ade()
const Cde = _u(_de)
var Sde = class extends gA {
  constructor(e, n, r) {
    super()
    Cn(this, 'socket')
    ;(this.socket = new window.WebSocket(e, r)),
      (this.socket.onopen = () => this.emit('open')),
      (this.socket.onmessage = s => this.emit('message', s.data)),
      (this.socket.onerror = s => this.emit('error', s)),
      (this.socket.onclose = s => {
        this.emit('close', s.code, s.reason)
      })
  }
  send(e, n, r) {
    const s = r || n
    try {
      this.socket.send(e), s()
    } catch (i) {
      s(i)
    }
  }
  close(e, n) {
    this.socket.close(e, n)
  }
  addEventListener(e, n, r) {
    this.socket.addEventListener(e, n, r)
  }
}
function Ide(t, e) {
  return new Sde(t, e)
}
var xde = class {
    encode(t) {
      return JSON.stringify(t)
    }
    decode(t) {
      return JSON.parse(t)
    }
  },
  Tde = class extends gA {
    constructor(
      e,
      n = 'ws://localhost:8080',
      {
        autoconnect: r = !0,
        reconnect: s = !0,
        reconnect_interval: i = 1e3,
        max_reconnects: o = 5,
        ...a
      } = {},
      c,
      u
    ) {
      super()
      Cn(this, 'address')
      Cn(this, 'rpc_id')
      Cn(this, 'queue')
      Cn(this, 'options')
      Cn(this, 'autoconnect')
      Cn(this, 'ready')
      Cn(this, 'reconnect')
      Cn(this, 'reconnect_timer_id')
      Cn(this, 'reconnect_interval')
      Cn(this, 'max_reconnects')
      Cn(this, 'rest_options')
      Cn(this, 'current_reconnects')
      Cn(this, 'generate_request_id')
      Cn(this, 'socket')
      Cn(this, 'webSocketFactory')
      Cn(this, 'dataPack')
      ;(this.webSocketFactory = e),
        (this.queue = {}),
        (this.rpc_id = 0),
        (this.address = n),
        (this.autoconnect = r),
        (this.ready = !1),
        (this.reconnect = s),
        (this.reconnect_timer_id = void 0),
        (this.reconnect_interval = i),
        (this.max_reconnects = o),
        (this.rest_options = a),
        (this.current_reconnects = 0),
        (this.generate_request_id =
          c || (() => (typeof this.rpc_id == 'number' ? ++this.rpc_id : Number(this.rpc_id) + 1))),
        u ? (this.dataPack = u) : (this.dataPack = new xde()),
        this.autoconnect &&
          this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
          })
    }
    connect() {
      this.socket ||
        this._connect(this.address, {
          autoconnect: this.autoconnect,
          reconnect: this.reconnect,
          reconnect_interval: this.reconnect_interval,
          max_reconnects: this.max_reconnects,
          ...this.rest_options
        })
    }
    call(e, n, r, s) {
      return (
        !s && typeof r == 'object' && ((s = r), (r = null)),
        new Promise((i, o) => {
          if (!this.ready) return o(new Error('socket not ready'))
          const a = this.generate_request_id(e, n),
            c = { jsonrpc: '2.0', method: e, params: n || void 0, id: a }
          this.socket.send(this.dataPack.encode(c), s, u => {
            if (u) return o(u)
            ;(this.queue[a] = { promise: [i, o] }),
              r &&
                (this.queue[a].timeout = setTimeout(() => {
                  delete this.queue[a], o(new Error('reply timeout'))
                }, r))
          })
        })
      )
    }
    async login(e) {
      const n = await this.call('rpc.login', e)
      if (!n) throw new Error('authentication failed')
      return n
    }
    async listMethods() {
      return await this.call('__listMethods')
    }
    notify(e, n) {
      return new Promise((r, s) => {
        if (!this.ready) return s(new Error('socket not ready'))
        const i = { jsonrpc: '2.0', method: e, params: n }
        this.socket.send(this.dataPack.encode(i), o => {
          if (o) return s(o)
          r()
        })
      })
    }
    async subscribe(e) {
      typeof e == 'string' && (e = [e])
      const n = await this.call('rpc.on', e)
      if (typeof e == 'string' && n[e] !== 'ok')
        throw new Error("Failed subscribing to an event '" + e + "' with: " + n[e])
      return n
    }
    async unsubscribe(e) {
      typeof e == 'string' && (e = [e])
      const n = await this.call('rpc.off', e)
      if (typeof e == 'string' && n[e] !== 'ok')
        throw new Error('Failed unsubscribing from an event with: ' + n)
      return n
    }
    close(e, n) {
      this.socket.close(e || 1e3, n)
    }
    setAutoReconnect(e) {
      this.reconnect = e
    }
    setReconnectInterval(e) {
      this.reconnect_interval = e
    }
    setMaxReconnects(e) {
      this.max_reconnects = e
    }
    _connect(e, n) {
      clearTimeout(this.reconnect_timer_id),
        (this.socket = this.webSocketFactory(e, n)),
        this.socket.addEventListener('open', () => {
          ;(this.ready = !0), this.emit('open'), (this.current_reconnects = 0)
        }),
        this.socket.addEventListener('message', ({ data: r }) => {
          r instanceof ArrayBuffer && (r = Nt.Buffer.from(r).toString())
          try {
            r = this.dataPack.decode(r)
          } catch {
            return
          }
          if (r.notification && this.listeners(r.notification).length) {
            if (!Object.keys(r.params).length) return this.emit(r.notification)
            const s = [r.notification]
            if (r.params.constructor === Object) s.push(r.params)
            else for (let i = 0; i < r.params.length; i++) s.push(r.params[i])
            return Promise.resolve().then(() => {
              this.emit.apply(this, s)
            })
          }
          if (!this.queue[r.id])
            return r.method
              ? Promise.resolve().then(() => {
                  this.emit(r.method, r == null ? void 0 : r.params)
                })
              : void 0
          'error' in r == 'result' in r &&
            this.queue[r.id].promise[1](
              new Error(
                'Server response malformed. Response must include either "result" or "error", but not both.'
              )
            ),
            this.queue[r.id].timeout && clearTimeout(this.queue[r.id].timeout),
            r.error ? this.queue[r.id].promise[1](r.error) : this.queue[r.id].promise[0](r.result),
            delete this.queue[r.id]
        }),
        this.socket.addEventListener('error', r => this.emit('error', r)),
        this.socket.addEventListener('close', ({ code: r, reason: s }) => {
          this.ready && setTimeout(() => this.emit('close', r, s), 0),
            (this.ready = !1),
            (this.socket = void 0),
            r !== 1e3 &&
              (this.current_reconnects++,
              this.reconnect &&
                (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0) &&
                (this.reconnect_timer_id = setTimeout(
                  () => this._connect(e, n),
                  this.reconnect_interval
                )))
        })
    }
  }
function yT(t) {
  try {
    return XA.ExtendedPoint.fromHex(t), !0
  } catch {
    return !1
  }
}
const c5 = (t, e) => XA.sign(t, e.slice(0, 32)),
  Nde = XA.verify,
  Ir = t =>
    Nt.Buffer.isBuffer(t)
      ? t
      : t instanceof Uint8Array
        ? Nt.Buffer.from(t.buffer, t.byteOffset, t.byteLength)
        : Nt.Buffer.from(t)
class Pde {
  constructor(e) {
    Object.assign(this, e)
  }
  encode() {
    return Nt.Buffer.from(kb.serialize(Wg, this))
  }
  static decode(e) {
    return kb.deserialize(Wg, this, e)
  }
  static decodeUnchecked(e) {
    return kb.deserializeUnchecked(Wg, this, e)
  }
}
const Wg = new Map()
var u5
const Rde = 32,
  Qa = 32
function kde(t) {
  return t._bn !== void 0
}
let wT = 1
class it extends Pde {
  constructor(e) {
    if ((super({}), (this._bn = void 0), kde(e))) this._bn = e._bn
    else {
      if (typeof e == 'string') {
        const n = Nr.decode(e)
        if (n.length != Qa) throw new Error('Invalid public key input')
        this._bn = new sT(n)
      } else this._bn = new sT(e)
      if (this._bn.byteLength() > Qa) throw new Error('Invalid public key input')
    }
  }
  static unique() {
    const e = new it(wT)
    return (wT += 1), new it(e.toBuffer())
  }
  equals(e) {
    return this._bn.eq(e._bn)
  }
  toBase58() {
    return Nr.encode(this.toBytes())
  }
  toJSON() {
    return this.toBase58()
  }
  toBytes() {
    const e = this.toBuffer()
    return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
  }
  toBuffer() {
    const e = this._bn.toArrayLike(Nt.Buffer)
    if (e.length === Qa) return e
    const n = Nt.Buffer.alloc(32)
    return e.copy(n, 32 - e.length), n
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`
  }
  toString() {
    return this.toBase58()
  }
  static async createWithSeed(e, n, r) {
    const s = Nt.Buffer.concat([e.toBuffer(), Nt.Buffer.from(n), r.toBuffer()]),
      i = cm(s)
    return new it(i)
  }
  static createProgramAddressSync(e, n) {
    let r = Nt.Buffer.alloc(0)
    e.forEach(function (i) {
      if (i.length > Rde) throw new TypeError('Max seed length exceeded')
      r = Nt.Buffer.concat([r, Ir(i)])
    }),
      (r = Nt.Buffer.concat([r, n.toBuffer(), Nt.Buffer.from('ProgramDerivedAddress')]))
    const s = cm(r)
    if (yT(s)) throw new Error('Invalid seeds, address must fall off the curve')
    return new it(s)
  }
  static async createProgramAddress(e, n) {
    return this.createProgramAddressSync(e, n)
  }
  static findProgramAddressSync(e, n) {
    let r = 255,
      s
    for (; r != 0; ) {
      try {
        const i = e.concat(Nt.Buffer.from([r]))
        s = this.createProgramAddressSync(i, n)
      } catch (i) {
        if (i instanceof TypeError) throw i
        r--
        continue
      }
      return [s, r]
    }
    throw new Error('Unable to find a viable program address nonce')
  }
  static async findProgramAddress(e, n) {
    return this.findProgramAddressSync(e, n)
  }
  static isOnCurve(e) {
    const n = new it(e)
    return yT(n.toBytes())
  }
}
u5 = it
it.default = new u5('11111111111111111111111111111111')
Wg.set(it, { kind: 'struct', fields: [['_bn', 'u256']] })
new it('BPFLoader1111111111111111111111111111111111')
const Dl = 1232,
  s_ = 127,
  Hm = 64
class l5 extends Error {
  constructor(e) {
    super(`Signature ${e} has expired: block height exceeded.`),
      (this.signature = void 0),
      (this.signature = e)
  }
}
Object.defineProperty(l5.prototype, 'name', { value: 'TransactionExpiredBlockheightExceededError' })
class d5 extends Error {
  constructor(e, n) {
    super(
      `Transaction was not confirmed in ${n.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`
    ),
      (this.signature = void 0),
      (this.signature = e)
  }
}
Object.defineProperty(d5.prototype, 'name', { value: 'TransactionExpiredTimeoutError' })
class Ah extends Error {
  constructor(e) {
    super(`Signature ${e} has expired: the nonce is no longer valid.`),
      (this.signature = void 0),
      (this.signature = e)
  }
}
Object.defineProperty(Ah.prototype, 'name', { value: 'TransactionExpiredNonceInvalidError' })
class qm {
  constructor(e, n) {
    ;(this.staticAccountKeys = void 0),
      (this.accountKeysFromLookups = void 0),
      (this.staticAccountKeys = e),
      (this.accountKeysFromLookups = n)
  }
  keySegments() {
    const e = [this.staticAccountKeys]
    return (
      this.accountKeysFromLookups &&
        (e.push(this.accountKeysFromLookups.writable),
        e.push(this.accountKeysFromLookups.readonly)),
      e
    )
  }
  get(e) {
    for (const n of this.keySegments()) {
      if (e < n.length) return n[e]
      e -= n.length
    }
  }
  get length() {
    return this.keySegments().flat().length
  }
  compileInstructions(e) {
    if (this.length > 256) throw new Error('Account index overflow encountered during compilation')
    const r = new Map()
    this.keySegments()
      .flat()
      .forEach((i, o) => {
        r.set(i.toBase58(), o)
      })
    const s = i => {
      const o = r.get(i.toBase58())
      if (o === void 0)
        throw new Error('Encountered an unknown instruction account key during compilation')
      return o
    }
    return e.map(i => ({
      programIdIndex: s(i.programId),
      accountKeyIndexes: i.keys.map(o => s(o.pubkey)),
      data: i.data
    }))
  }
}
const Lt = (t = 'publicKey') => re.blob(32, t),
  Ode = (t = 'signature') => re.blob(64, t),
  vl = (t = 'string') => {
    const e = re.struct(
        [re.u32('length'), re.u32('lengthPadding'), re.blob(re.offset(re.u32(), -8), 'chars')],
        t
      ),
      n = e.decode.bind(e),
      r = e.encode.bind(e),
      s = e
    return (
      (s.decode = (i, o) => n(i, o).chars.toString()),
      (s.encode = (i, o, a) => {
        const c = { chars: Nt.Buffer.from(i, 'utf8') }
        return r(c, o, a)
      }),
      (s.alloc = i => re.u32().span + re.u32().span + Nt.Buffer.from(i, 'utf8').length),
      s
    )
  },
  Bde = (t = 'authorized') => re.struct([Lt('staker'), Lt('withdrawer')], t),
  Dde = (t = 'lockup') =>
    re.struct([re.ns64('unixTimestamp'), re.ns64('epoch'), Lt('custodian')], t),
  Mde = (t = 'voteInit') =>
    re.struct(
      [Lt('nodePubkey'), Lt('authorizedVoter'), Lt('authorizedWithdrawer'), re.u8('commission')],
      t
    ),
  Ude = (t = 'voteAuthorizeWithSeedArgs') =>
    re.struct(
      [
        re.u32('voteAuthorizationType'),
        Lt('currentAuthorityDerivedKeyOwnerPubkey'),
        vl('currentAuthorityDerivedKeySeed'),
        Lt('newAuthorized')
      ],
      t
    )
function h5(t, e) {
  const n = s => {
    if (s.span >= 0) return s.span
    if (typeof s.alloc == 'function') return s.alloc(e[s.property])
    if ('count' in s && 'elementLayout' in s) {
      const i = e[s.property]
      if (Array.isArray(i)) return i.length * n(s.elementLayout)
    } else if ('fields' in s) return h5({ layout: s }, e[s.property])
    return 0
  }
  let r = 0
  return (
    t.layout.fields.forEach(s => {
      r += n(s)
    }),
    r
  )
}
function Us(t) {
  let e = 0,
    n = 0
  for (;;) {
    let r = t.shift()
    if (((e |= (r & 127) << (n * 7)), (n += 1), (r & 128) === 0)) break
  }
  return e
}
function Ls(t, e) {
  let n = e
  for (;;) {
    let r = n & 127
    if (((n >>= 7), n == 0)) {
      t.push(r)
      break
    } else (r |= 128), t.push(r)
  }
}
function Tn(t, e) {
  if (!t) throw new Error(e || 'Assertion failed')
}
class dy {
  constructor(e, n) {
    ;(this.payer = void 0), (this.keyMetaMap = void 0), (this.payer = e), (this.keyMetaMap = n)
  }
  static compile(e, n) {
    const r = new Map(),
      s = o => {
        const a = o.toBase58()
        let c = r.get(a)
        return (
          c === void 0 && ((c = { isSigner: !1, isWritable: !1, isInvoked: !1 }), r.set(a, c)), c
        )
      },
      i = s(n)
    ;(i.isSigner = !0), (i.isWritable = !0)
    for (const o of e) {
      s(o.programId).isInvoked = !0
      for (const a of o.keys) {
        const c = s(a.pubkey)
        c.isSigner || (c.isSigner = a.isSigner), c.isWritable || (c.isWritable = a.isWritable)
      }
    }
    return new dy(n, r)
  }
  getMessageComponents() {
    const e = [...this.keyMetaMap.entries()]
    Tn(e.length <= 256, 'Max static account keys length exceeded')
    const n = e.filter(([, c]) => c.isSigner && c.isWritable),
      r = e.filter(([, c]) => c.isSigner && !c.isWritable),
      s = e.filter(([, c]) => !c.isSigner && c.isWritable),
      i = e.filter(([, c]) => !c.isSigner && !c.isWritable),
      o = {
        numRequiredSignatures: n.length + r.length,
        numReadonlySignedAccounts: r.length,
        numReadonlyUnsignedAccounts: i.length
      }
    {
      Tn(n.length > 0, 'Expected at least one writable signer key')
      const [c] = n[0]
      Tn(c === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer')
    }
    const a = [
      ...n.map(([c]) => new it(c)),
      ...r.map(([c]) => new it(c)),
      ...s.map(([c]) => new it(c)),
      ...i.map(([c]) => new it(c))
    ]
    return [o, a]
  }
  extractTableLookup(e) {
    const [n, r] = this.drainKeysFoundInLookupTable(
        e.state.addresses,
        o => !o.isSigner && !o.isInvoked && o.isWritable
      ),
      [s, i] = this.drainKeysFoundInLookupTable(
        e.state.addresses,
        o => !o.isSigner && !o.isInvoked && !o.isWritable
      )
    if (!(n.length === 0 && s.length === 0))
      return [
        { accountKey: e.key, writableIndexes: n, readonlyIndexes: s },
        { writable: r, readonly: i }
      ]
  }
  drainKeysFoundInLookupTable(e, n) {
    const r = new Array(),
      s = new Array()
    for (const [i, o] of this.keyMetaMap.entries())
      if (n(o)) {
        const a = new it(i),
          c = e.findIndex(u => u.equals(a))
        c >= 0 &&
          (Tn(c < 256, 'Max lookup table index exceeded'),
          r.push(c),
          s.push(a),
          this.keyMetaMap.delete(i))
      }
    return [r, s]
  }
}
const f5 = 'Reached end of buffer unexpectedly'
function qo(t) {
  if (t.length === 0) throw new Error(f5)
  return t.shift()
}
function $s(t, ...e) {
  const [n] = e
  if (e.length === 2 ? n + (e[1] ?? 0) > t.length : n >= t.length) throw new Error(f5)
  return t.splice(...e)
}
class ea {
  constructor(e) {
    ;(this.header = void 0),
      (this.accountKeys = void 0),
      (this.recentBlockhash = void 0),
      (this.instructions = void 0),
      (this.indexToProgramIds = new Map()),
      (this.header = e.header),
      (this.accountKeys = e.accountKeys.map(n => new it(n))),
      (this.recentBlockhash = e.recentBlockhash),
      (this.instructions = e.instructions),
      this.instructions.forEach(n =>
        this.indexToProgramIds.set(n.programIdIndex, this.accountKeys[n.programIdIndex])
      )
  }
  get version() {
    return 'legacy'
  }
  get staticAccountKeys() {
    return this.accountKeys
  }
  get compiledInstructions() {
    return this.instructions.map(e => ({
      programIdIndex: e.programIdIndex,
      accountKeyIndexes: e.accounts,
      data: Nr.decode(e.data)
    }))
  }
  get addressTableLookups() {
    return []
  }
  getAccountKeys() {
    return new qm(this.staticAccountKeys)
  }
  static compile(e) {
    const n = dy.compile(e.instructions, e.payerKey),
      [r, s] = n.getMessageComponents(),
      o = new qm(s).compileInstructions(e.instructions).map(a => ({
        programIdIndex: a.programIdIndex,
        accounts: a.accountKeyIndexes,
        data: Nr.encode(a.data)
      }))
    return new ea({
      header: r,
      accountKeys: s,
      recentBlockhash: e.recentBlockhash,
      instructions: o
    })
  }
  isAccountSigner(e) {
    return e < this.header.numRequiredSignatures
  }
  isAccountWritable(e) {
    const n = this.header.numRequiredSignatures
    if (e >= this.header.numRequiredSignatures) {
      const r = e - n,
        i = this.accountKeys.length - n - this.header.numReadonlyUnsignedAccounts
      return r < i
    } else {
      const r = n - this.header.numReadonlySignedAccounts
      return e < r
    }
  }
  isProgramId(e) {
    return this.indexToProgramIds.has(e)
  }
  programIds() {
    return [...this.indexToProgramIds.values()]
  }
  nonProgramIds() {
    return this.accountKeys.filter((e, n) => !this.isProgramId(n))
  }
  serialize() {
    const e = this.accountKeys.length
    let n = []
    Ls(n, e)
    const r = this.instructions.map(d => {
      const { accounts: h, programIdIndex: p } = d,
        y = Array.from(Nr.decode(d.data))
      let m = []
      Ls(m, h.length)
      let b = []
      return (
        Ls(b, y.length),
        {
          programIdIndex: p,
          keyIndicesCount: Nt.Buffer.from(m),
          keyIndices: h,
          dataLength: Nt.Buffer.from(b),
          data: y
        }
      )
    })
    let s = []
    Ls(s, r.length)
    let i = Nt.Buffer.alloc(Dl)
    Nt.Buffer.from(s).copy(i)
    let o = s.length
    r.forEach(d => {
      const p = re
        .struct([
          re.u8('programIdIndex'),
          re.blob(d.keyIndicesCount.length, 'keyIndicesCount'),
          re.seq(re.u8('keyIndex'), d.keyIndices.length, 'keyIndices'),
          re.blob(d.dataLength.length, 'dataLength'),
          re.seq(re.u8('userdatum'), d.data.length, 'data')
        ])
        .encode(d, i, o)
      o += p
    }),
      (i = i.slice(0, o))
    const a = re.struct([
        re.blob(1, 'numRequiredSignatures'),
        re.blob(1, 'numReadonlySignedAccounts'),
        re.blob(1, 'numReadonlyUnsignedAccounts'),
        re.blob(n.length, 'keyCount'),
        re.seq(Lt('key'), e, 'keys'),
        Lt('recentBlockhash')
      ]),
      c = {
        numRequiredSignatures: Nt.Buffer.from([this.header.numRequiredSignatures]),
        numReadonlySignedAccounts: Nt.Buffer.from([this.header.numReadonlySignedAccounts]),
        numReadonlyUnsignedAccounts: Nt.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
        keyCount: Nt.Buffer.from(n),
        keys: this.accountKeys.map(d => Ir(d.toBytes())),
        recentBlockhash: Nr.decode(this.recentBlockhash)
      }
    let u = Nt.Buffer.alloc(2048)
    const l = a.encode(c, u)
    return i.copy(u, l), u.slice(0, l + i.length)
  }
  static from(e) {
    let n = [...e]
    const r = qo(n)
    if (r !== (r & s_))
      throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()')
    const s = qo(n),
      i = qo(n),
      o = Us(n)
    let a = []
    for (let h = 0; h < o; h++) {
      const p = $s(n, 0, Qa)
      a.push(new it(Nt.Buffer.from(p)))
    }
    const c = $s(n, 0, Qa),
      u = Us(n)
    let l = []
    for (let h = 0; h < u; h++) {
      const p = qo(n),
        y = Us(n),
        m = $s(n, 0, y),
        b = Us(n),
        I = $s(n, 0, b),
        x = Nr.encode(Nt.Buffer.from(I))
      l.push({ programIdIndex: p, accounts: m, data: x })
    }
    const d = {
      header: {
        numRequiredSignatures: r,
        numReadonlySignedAccounts: s,
        numReadonlyUnsignedAccounts: i
      },
      recentBlockhash: Nr.encode(Nt.Buffer.from(c)),
      accountKeys: a,
      instructions: l
    }
    return new ea(d)
  }
}
class qf {
  constructor(e) {
    ;(this.header = void 0),
      (this.staticAccountKeys = void 0),
      (this.recentBlockhash = void 0),
      (this.compiledInstructions = void 0),
      (this.addressTableLookups = void 0),
      (this.header = e.header),
      (this.staticAccountKeys = e.staticAccountKeys),
      (this.recentBlockhash = e.recentBlockhash),
      (this.compiledInstructions = e.compiledInstructions),
      (this.addressTableLookups = e.addressTableLookups)
  }
  get version() {
    return 0
  }
  get numAccountKeysFromLookups() {
    let e = 0
    for (const n of this.addressTableLookups)
      e += n.readonlyIndexes.length + n.writableIndexes.length
    return e
  }
  getAccountKeys(e) {
    let n
    if (e && 'accountKeysFromLookups' in e && e.accountKeysFromLookups) {
      if (
        this.numAccountKeysFromLookups !=
        e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length
      )
        throw new Error(
          'Failed to get account keys because of a mismatch in the number of account keys from lookups'
        )
      n = e.accountKeysFromLookups
    } else if (e && 'addressLookupTableAccounts' in e && e.addressLookupTableAccounts)
      n = this.resolveAddressTableLookups(e.addressLookupTableAccounts)
    else if (this.addressTableLookups.length > 0)
      throw new Error('Failed to get account keys because address table lookups were not resolved')
    return new qm(this.staticAccountKeys, n)
  }
  isAccountSigner(e) {
    return e < this.header.numRequiredSignatures
  }
  isAccountWritable(e) {
    const n = this.header.numRequiredSignatures,
      r = this.staticAccountKeys.length
    if (e >= r) {
      const s = e - r,
        i = this.addressTableLookups.reduce((o, a) => o + a.writableIndexes.length, 0)
      return s < i
    } else if (e >= this.header.numRequiredSignatures) {
      const s = e - n,
        o = r - n - this.header.numReadonlyUnsignedAccounts
      return s < o
    } else {
      const s = n - this.header.numReadonlySignedAccounts
      return e < s
    }
  }
  resolveAddressTableLookups(e) {
    const n = { writable: [], readonly: [] }
    for (const r of this.addressTableLookups) {
      const s = e.find(i => i.key.equals(r.accountKey))
      if (!s)
        throw new Error(
          `Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`
        )
      for (const i of r.writableIndexes)
        if (i < s.state.addresses.length) n.writable.push(s.state.addresses[i])
        else
          throw new Error(
            `Failed to find address for index ${i} in address lookup table ${r.accountKey.toBase58()}`
          )
      for (const i of r.readonlyIndexes)
        if (i < s.state.addresses.length) n.readonly.push(s.state.addresses[i])
        else
          throw new Error(
            `Failed to find address for index ${i} in address lookup table ${r.accountKey.toBase58()}`
          )
    }
    return n
  }
  static compile(e) {
    const n = dy.compile(e.instructions, e.payerKey),
      r = new Array(),
      s = { writable: new Array(), readonly: new Array() },
      i = e.addressLookupTableAccounts || []
    for (const l of i) {
      const d = n.extractTableLookup(l)
      if (d !== void 0) {
        const [h, { writable: p, readonly: y }] = d
        r.push(h), s.writable.push(...p), s.readonly.push(...y)
      }
    }
    const [o, a] = n.getMessageComponents(),
      u = new qm(a, s).compileInstructions(e.instructions)
    return new qf({
      header: o,
      staticAccountKeys: a,
      recentBlockhash: e.recentBlockhash,
      compiledInstructions: u,
      addressTableLookups: r
    })
  }
  serialize() {
    const e = Array()
    Ls(e, this.staticAccountKeys.length)
    const n = this.serializeInstructions(),
      r = Array()
    Ls(r, this.compiledInstructions.length)
    const s = this.serializeAddressTableLookups(),
      i = Array()
    Ls(i, this.addressTableLookups.length)
    const o = re.struct([
        re.u8('prefix'),
        re.struct(
          [
            re.u8('numRequiredSignatures'),
            re.u8('numReadonlySignedAccounts'),
            re.u8('numReadonlyUnsignedAccounts')
          ],
          'header'
        ),
        re.blob(e.length, 'staticAccountKeysLength'),
        re.seq(Lt(), this.staticAccountKeys.length, 'staticAccountKeys'),
        Lt('recentBlockhash'),
        re.blob(r.length, 'instructionsLength'),
        re.blob(n.length, 'serializedInstructions'),
        re.blob(i.length, 'addressTableLookupsLength'),
        re.blob(s.length, 'serializedAddressTableLookups')
      ]),
      a = new Uint8Array(Dl),
      u = o.encode(
        {
          prefix: 128,
          header: this.header,
          staticAccountKeysLength: new Uint8Array(e),
          staticAccountKeys: this.staticAccountKeys.map(l => l.toBytes()),
          recentBlockhash: Nr.decode(this.recentBlockhash),
          instructionsLength: new Uint8Array(r),
          serializedInstructions: n,
          addressTableLookupsLength: new Uint8Array(i),
          serializedAddressTableLookups: s
        },
        a
      )
    return a.slice(0, u)
  }
  serializeInstructions() {
    let e = 0
    const n = new Uint8Array(Dl)
    for (const r of this.compiledInstructions) {
      const s = Array()
      Ls(s, r.accountKeyIndexes.length)
      const i = Array()
      Ls(i, r.data.length)
      const o = re.struct([
        re.u8('programIdIndex'),
        re.blob(s.length, 'encodedAccountKeyIndexesLength'),
        re.seq(re.u8(), r.accountKeyIndexes.length, 'accountKeyIndexes'),
        re.blob(i.length, 'encodedDataLength'),
        re.blob(r.data.length, 'data')
      ])
      e += o.encode(
        {
          programIdIndex: r.programIdIndex,
          encodedAccountKeyIndexesLength: new Uint8Array(s),
          accountKeyIndexes: r.accountKeyIndexes,
          encodedDataLength: new Uint8Array(i),
          data: r.data
        },
        n,
        e
      )
    }
    return n.slice(0, e)
  }
  serializeAddressTableLookups() {
    let e = 0
    const n = new Uint8Array(Dl)
    for (const r of this.addressTableLookups) {
      const s = Array()
      Ls(s, r.writableIndexes.length)
      const i = Array()
      Ls(i, r.readonlyIndexes.length)
      const o = re.struct([
        Lt('accountKey'),
        re.blob(s.length, 'encodedWritableIndexesLength'),
        re.seq(re.u8(), r.writableIndexes.length, 'writableIndexes'),
        re.blob(i.length, 'encodedReadonlyIndexesLength'),
        re.seq(re.u8(), r.readonlyIndexes.length, 'readonlyIndexes')
      ])
      e += o.encode(
        {
          accountKey: r.accountKey.toBytes(),
          encodedWritableIndexesLength: new Uint8Array(s),
          writableIndexes: r.writableIndexes,
          encodedReadonlyIndexesLength: new Uint8Array(i),
          readonlyIndexes: r.readonlyIndexes
        },
        n,
        e
      )
    }
    return n.slice(0, e)
  }
  static deserialize(e) {
    let n = [...e]
    const r = qo(n),
      s = r & s_
    Tn(r !== s, 'Expected versioned message but received legacy message')
    const i = s
    Tn(i === 0, `Expected versioned message with version 0 but found version ${i}`)
    const o = {
        numRequiredSignatures: qo(n),
        numReadonlySignedAccounts: qo(n),
        numReadonlyUnsignedAccounts: qo(n)
      },
      a = [],
      c = Us(n)
    for (let y = 0; y < c; y++) a.push(new it($s(n, 0, Qa)))
    const u = Nr.encode($s(n, 0, Qa)),
      l = Us(n),
      d = []
    for (let y = 0; y < l; y++) {
      const m = qo(n),
        b = Us(n),
        I = $s(n, 0, b),
        x = Us(n),
        _ = new Uint8Array($s(n, 0, x))
      d.push({ programIdIndex: m, accountKeyIndexes: I, data: _ })
    }
    const h = Us(n),
      p = []
    for (let y = 0; y < h; y++) {
      const m = new it($s(n, 0, Qa)),
        b = Us(n),
        I = $s(n, 0, b),
        x = Us(n),
        _ = $s(n, 0, x)
      p.push({ accountKey: m, writableIndexes: I, readonlyIndexes: _ })
    }
    return new qf({
      header: o,
      staticAccountKeys: a,
      recentBlockhash: u,
      compiledInstructions: d,
      addressTableLookups: p
    })
  }
}
const p5 = {
  deserializeMessageVersion(t) {
    const e = t[0],
      n = e & s_
    return n === e ? 'legacy' : n
  },
  deserialize: t => {
    const e = p5.deserializeMessageVersion(t)
    if (e === 'legacy') return ea.from(t)
    if (e === 0) return qf.deserialize(t)
    throw new Error(`Transaction message version ${e} deserialization is not supported`)
  }
}
let ma = (function (t) {
  return (
    (t[(t.BLOCKHEIGHT_EXCEEDED = 0)] = 'BLOCKHEIGHT_EXCEEDED'),
    (t[(t.PROCESSED = 1)] = 'PROCESSED'),
    (t[(t.TIMED_OUT = 2)] = 'TIMED_OUT'),
    (t[(t.NONCE_INVALID = 3)] = 'NONCE_INVALID'),
    t
  )
})({})
const Lde = Nt.Buffer.alloc(Hm).fill(0)
class rs {
  constructor(e) {
    ;(this.keys = void 0),
      (this.programId = void 0),
      (this.data = Nt.Buffer.alloc(0)),
      (this.programId = e.programId),
      (this.keys = e.keys),
      e.data && (this.data = e.data)
  }
  toJSON() {
    return {
      keys: this.keys.map(({ pubkey: e, isSigner: n, isWritable: r }) => ({
        pubkey: e.toJSON(),
        isSigner: n,
        isWritable: r
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    }
  }
}
class Kr {
  get signature() {
    return this.signatures.length > 0 ? this.signatures[0].signature : null
  }
  constructor(e) {
    if (
      ((this.signatures = []),
      (this.feePayer = void 0),
      (this.instructions = []),
      (this.recentBlockhash = void 0),
      (this.lastValidBlockHeight = void 0),
      (this.nonceInfo = void 0),
      (this.minNonceContextSlot = void 0),
      (this._message = void 0),
      (this._json = void 0),
      !!e)
    )
      if (
        (e.feePayer && (this.feePayer = e.feePayer),
        e.signatures && (this.signatures = e.signatures),
        Object.prototype.hasOwnProperty.call(e, 'nonceInfo'))
      ) {
        const { minContextSlot: n, nonceInfo: r } = e
        ;(this.minNonceContextSlot = n), (this.nonceInfo = r)
      } else if (Object.prototype.hasOwnProperty.call(e, 'lastValidBlockHeight')) {
        const { blockhash: n, lastValidBlockHeight: r } = e
        ;(this.recentBlockhash = n), (this.lastValidBlockHeight = r)
      } else {
        const { recentBlockhash: n, nonceInfo: r } = e
        r && (this.nonceInfo = r), (this.recentBlockhash = n)
      }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo
        ? {
            nonce: this.nonceInfo.nonce,
            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
          }
        : null,
      instructions: this.instructions.map(e => e.toJSON()),
      signers: this.signatures.map(({ publicKey: e }) => e.toJSON())
    }
  }
  add(...e) {
    if (e.length === 0) throw new Error('No instructions')
    return (
      e.forEach(n => {
        'instructions' in n
          ? (this.instructions = this.instructions.concat(n.instructions))
          : 'data' in n && 'programId' in n && 'keys' in n
            ? this.instructions.push(n)
            : this.instructions.push(new rs(n))
      }),
      this
    )
  }
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
      return this._message
    let e, n
    if (
      (this.nonceInfo
        ? ((e = this.nonceInfo.nonce),
          this.instructions[0] != this.nonceInfo.nonceInstruction
            ? (n = [this.nonceInfo.nonceInstruction, ...this.instructions])
            : (n = this.instructions))
        : ((e = this.recentBlockhash), (n = this.instructions)),
      !e)
    )
      throw new Error('Transaction recentBlockhash required')
    n.length < 1 && console.warn('No instructions provided')
    let r
    if (this.feePayer) r = this.feePayer
    else if (this.signatures.length > 0 && this.signatures[0].publicKey)
      r = this.signatures[0].publicKey
    else throw new Error('Transaction fee payer required')
    for (let m = 0; m < n.length; m++)
      if (n[m].programId === void 0)
        throw new Error(`Transaction instruction index ${m} has undefined program id`)
    const s = [],
      i = []
    n.forEach(m => {
      m.keys.forEach(I => {
        i.push({ ...I })
      })
      const b = m.programId.toString()
      s.includes(b) || s.push(b)
    }),
      s.forEach(m => {
        i.push({ pubkey: new it(m), isSigner: !1, isWritable: !1 })
      })
    const o = []
    i.forEach(m => {
      const b = m.pubkey.toString(),
        I = o.findIndex(x => x.pubkey.toString() === b)
      I > -1
        ? ((o[I].isWritable = o[I].isWritable || m.isWritable),
          (o[I].isSigner = o[I].isSigner || m.isSigner))
        : o.push(m)
    }),
      o.sort(function (m, b) {
        if (m.isSigner !== b.isSigner) return m.isSigner ? -1 : 1
        if (m.isWritable !== b.isWritable) return m.isWritable ? -1 : 1
        const I = {
          localeMatcher: 'best fit',
          usage: 'sort',
          sensitivity: 'variant',
          ignorePunctuation: !1,
          numeric: !1,
          caseFirst: 'lower'
        }
        return m.pubkey.toBase58().localeCompare(b.pubkey.toBase58(), 'en', I)
      })
    const a = o.findIndex(m => m.pubkey.equals(r))
    if (a > -1) {
      const [m] = o.splice(a, 1)
      ;(m.isSigner = !0), (m.isWritable = !0), o.unshift(m)
    } else o.unshift({ pubkey: r, isSigner: !0, isWritable: !0 })
    for (const m of this.signatures) {
      const b = o.findIndex(I => I.pubkey.equals(m.publicKey))
      if (b > -1)
        o[b].isSigner ||
          ((o[b].isSigner = !0),
          console.warn(
            'Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.'
          ))
      else throw new Error(`unknown signer: ${m.publicKey.toString()}`)
    }
    let c = 0,
      u = 0,
      l = 0
    const d = [],
      h = []
    o.forEach(({ pubkey: m, isSigner: b, isWritable: I }) => {
      b ? (d.push(m.toString()), (c += 1), I || (u += 1)) : (h.push(m.toString()), I || (l += 1))
    })
    const p = d.concat(h),
      y = n.map(m => {
        const { data: b, programId: I } = m
        return {
          programIdIndex: p.indexOf(I.toString()),
          accounts: m.keys.map(x => p.indexOf(x.pubkey.toString())),
          data: Nr.encode(b)
        }
      })
    return (
      y.forEach(m => {
        Tn(m.programIdIndex >= 0), m.accounts.forEach(b => Tn(b >= 0))
      }),
      new ea({
        header: {
          numRequiredSignatures: c,
          numReadonlySignedAccounts: u,
          numReadonlyUnsignedAccounts: l
        },
        accountKeys: p,
        recentBlockhash: e,
        instructions: y
      })
    )
  }
  _compile() {
    const e = this.compileMessage(),
      n = e.accountKeys.slice(0, e.header.numRequiredSignatures)
    return (
      (this.signatures.length === n.length &&
        this.signatures.every((s, i) => n[i].equals(s.publicKey))) ||
        (this.signatures = n.map(r => ({ signature: null, publicKey: r }))),
      e
    )
  }
  serializeMessage() {
    return this._compile().serialize()
  }
  async getEstimatedFee(e) {
    return (await e.getFeeForMessage(this.compileMessage())).value
  }
  setSigners(...e) {
    if (e.length === 0) throw new Error('No signers')
    const n = new Set()
    this.signatures = e
      .filter(r => {
        const s = r.toString()
        return n.has(s) ? !1 : (n.add(s), !0)
      })
      .map(r => ({ signature: null, publicKey: r }))
  }
  sign(...e) {
    if (e.length === 0) throw new Error('No signers')
    const n = new Set(),
      r = []
    for (const i of e) {
      const o = i.publicKey.toString()
      n.has(o) || (n.add(o), r.push(i))
    }
    this.signatures = r.map(i => ({ signature: null, publicKey: i.publicKey }))
    const s = this._compile()
    this._partialSign(s, ...r)
  }
  partialSign(...e) {
    if (e.length === 0) throw new Error('No signers')
    const n = new Set(),
      r = []
    for (const i of e) {
      const o = i.publicKey.toString()
      n.has(o) || (n.add(o), r.push(i))
    }
    const s = this._compile()
    this._partialSign(s, ...r)
  }
  _partialSign(e, ...n) {
    const r = e.serialize()
    n.forEach(s => {
      const i = c5(r, s.secretKey)
      this._addSignature(s.publicKey, Ir(i))
    })
  }
  addSignature(e, n) {
    this._compile(), this._addSignature(e, n)
  }
  _addSignature(e, n) {
    Tn(n.length === 64)
    const r = this.signatures.findIndex(s => e.equals(s.publicKey))
    if (r < 0) throw new Error(`unknown signer: ${e.toString()}`)
    this.signatures[r].signature = Nt.Buffer.from(n)
  }
  verifySignatures(e = !0) {
    return !this._getMessageSignednessErrors(this.serializeMessage(), e)
  }
  _getMessageSignednessErrors(e, n) {
    const r = {}
    for (const { signature: s, publicKey: i } of this.signatures)
      s === null
        ? n && (r.missing || (r.missing = [])).push(i)
        : Nde(s, e, i.toBytes()) || (r.invalid || (r.invalid = [])).push(i)
    return r.invalid || r.missing ? r : void 0
  }
  serialize(e) {
    const { requireAllSignatures: n, verifySignatures: r } = Object.assign(
        { requireAllSignatures: !0, verifySignatures: !0 },
        e
      ),
      s = this.serializeMessage()
    if (r) {
      const i = this._getMessageSignednessErrors(s, n)
      if (i) {
        let o = 'Signature verification failed.'
        throw (
          (i.invalid &&
            (o += `
Invalid signature for public key${i.invalid.length === 1 ? '' : '(s)'} [\`${i.invalid.map(a => a.toBase58()).join('`, `')}\`].`),
          i.missing &&
            (o += `
Missing signature for public key${i.missing.length === 1 ? '' : '(s)'} [\`${i.missing.map(a => a.toBase58()).join('`, `')}\`].`),
          new Error(o))
        )
      }
    }
    return this._serialize(s)
  }
  _serialize(e) {
    const { signatures: n } = this,
      r = []
    Ls(r, n.length)
    const s = r.length + n.length * 64 + e.length,
      i = Nt.Buffer.alloc(s)
    return (
      Tn(n.length < 256),
      Nt.Buffer.from(r).copy(i, 0),
      n.forEach(({ signature: o }, a) => {
        o !== null &&
          (Tn(o.length === 64, 'signature has invalid length'),
          Nt.Buffer.from(o).copy(i, r.length + a * 64))
      }),
      e.copy(i, r.length + n.length * 64),
      Tn(i.length <= Dl, `Transaction too large: ${i.length} > ${Dl}`),
      i
    )
  }
  get keys() {
    return Tn(this.instructions.length === 1), this.instructions[0].keys.map(e => e.pubkey)
  }
  get programId() {
    return Tn(this.instructions.length === 1), this.instructions[0].programId
  }
  get data() {
    return Tn(this.instructions.length === 1), this.instructions[0].data
  }
  static from(e) {
    let n = [...e]
    const r = Us(n)
    let s = []
    for (let i = 0; i < r; i++) {
      const o = $s(n, 0, Hm)
      s.push(Nr.encode(Nt.Buffer.from(o)))
    }
    return Kr.populate(ea.from(n), s)
  }
  static populate(e, n = []) {
    const r = new Kr()
    return (
      (r.recentBlockhash = e.recentBlockhash),
      e.header.numRequiredSignatures > 0 && (r.feePayer = e.accountKeys[0]),
      n.forEach((s, i) => {
        const o = {
          signature: s == Nr.encode(Lde) ? null : Nr.decode(s),
          publicKey: e.accountKeys[i]
        }
        r.signatures.push(o)
      }),
      e.instructions.forEach(s => {
        const i = s.accounts.map(o => {
          const a = e.accountKeys[o]
          return {
            pubkey: a,
            isSigner:
              r.signatures.some(c => c.publicKey.toString() === a.toString()) ||
              e.isAccountSigner(o),
            isWritable: e.isAccountWritable(o)
          }
        })
        r.instructions.push(
          new rs({ keys: i, programId: e.accountKeys[s.programIdIndex], data: Nr.decode(s.data) })
        )
      }),
      (r._message = e),
      (r._json = r.toJSON()),
      r
    )
  }
}
class ic {
  get version() {
    return this.message.version
  }
  constructor(e, n) {
    if (((this.signatures = void 0), (this.message = void 0), n !== void 0))
      Tn(
        n.length === e.header.numRequiredSignatures,
        'Expected signatures length to be equal to the number of required signatures'
      ),
        (this.signatures = n)
    else {
      const r = []
      for (let s = 0; s < e.header.numRequiredSignatures; s++) r.push(new Uint8Array(Hm))
      this.signatures = r
    }
    this.message = e
  }
  serialize() {
    const e = this.message.serialize(),
      n = Array()
    Ls(n, this.signatures.length)
    const r = re.struct([
        re.blob(n.length, 'encodedSignaturesLength'),
        re.seq(Ode(), this.signatures.length, 'signatures'),
        re.blob(e.length, 'serializedMessage')
      ]),
      s = new Uint8Array(2048),
      i = r.encode(
        {
          encodedSignaturesLength: new Uint8Array(n),
          signatures: this.signatures,
          serializedMessage: e
        },
        s
      )
    return s.slice(0, i)
  }
  static deserialize(e) {
    let n = [...e]
    const r = [],
      s = Us(n)
    for (let o = 0; o < s; o++) r.push(new Uint8Array($s(n, 0, Hm)))
    const i = p5.deserialize(new Uint8Array(n))
    return new ic(i, r)
  }
  sign(e) {
    const n = this.message.serialize(),
      r = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures)
    for (const s of e) {
      const i = r.findIndex(o => o.equals(s.publicKey))
      Tn(i >= 0, `Cannot sign with non signer key ${s.publicKey.toBase58()}`),
        (this.signatures[i] = c5(n, s.secretKey))
    }
  }
  addSignature(e, n) {
    Tn(n.byteLength === 64, 'Signature must be 64 bytes long')
    const s = this.message.staticAccountKeys
      .slice(0, this.message.header.numRequiredSignatures)
      .findIndex(i => i.equals(e))
    Tn(
      s >= 0,
      `Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`
    ),
      (this.signatures[s] = n)
  }
}
const $de = 160,
  Fde = 64,
  jde = $de / Fde,
  Hde = 1e3 / jde
new it('SysvarC1ock11111111111111111111111111111111')
new it('SysvarEpochSchedu1e111111111111111111111111')
new it('Sysvar1nstructions1111111111111111111111111')
const Fb = new it('SysvarRecentB1ockHashes11111111111111111111'),
  bT = new it('SysvarRent111111111111111111111111111111111')
new it('SysvarRewards111111111111111111111111111111')
new it('SysvarS1otHashes111111111111111111111111111')
new it('SysvarS1otHistory11111111111111111111111111')
new it('SysvarStakeHistory1111111111111111111111111')
class vT extends Error {
  constructor({ action: e, signature: n, transactionMessage: r, logs: s }) {
    const i = s
        ? `Logs: 
${JSON.stringify(s.slice(-10), null, 2)}. `
        : '',
      o = '\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.'
    let a
    switch (e) {
      case 'send':
        a =
          `Transaction ${n} resulted in an error. 
${r}. ` +
          i +
          o
        break
      case 'simulate':
        a =
          `Simulation failed. 
Message: ${r}. 
` +
          i +
          o
        break
      default:
        a = `Unknown action '${(c => c)(e)}'`
    }
    super(a),
      (this.signature = void 0),
      (this.transactionMessage = void 0),
      (this.transactionLogs = void 0),
      (this.signature = n),
      (this.transactionMessage = r),
      (this.transactionLogs = s || void 0)
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
    }
  }
  get logs() {
    const e = this.transactionLogs
    if (!(e != null && typeof e == 'object' && 'then' in e)) return e
  }
  async getLogs(e) {
    return (
      Array.isArray(this.transactionLogs) ||
        (this.transactionLogs = new Promise((n, r) => {
          e.getTransaction(this.signature)
            .then(s => {
              if (s && s.meta && s.meta.logMessages) {
                const i = s.meta.logMessages
                ;(this.transactionLogs = i), n(i)
              } else r(new Error('Log messages not found'))
            })
            .catch(r)
        })),
      await this.transactionLogs
    )
  }
}
class ot extends Error {
  constructor({ code: e, message: n, data: r }, s) {
    super(s != null ? `${s}: ${n}` : n),
      (this.code = void 0),
      (this.data = void 0),
      (this.code = e),
      (this.data = r),
      (this.name = 'SolanaJSONRPCError')
  }
}
function ll(t) {
  return new Promise(e => setTimeout(e, t))
}
function Hr(t, e) {
  const n = t.layout.span >= 0 ? t.layout.span : h5(t, e),
    r = Nt.Buffer.alloc(n),
    s = Object.assign({ instruction: t.index }, e)
  return t.layout.encode(s, r), r
}
const qde = re.nu64('lamportsPerSignature'),
  g5 = re.struct([
    re.u32('version'),
    re.u32('state'),
    Lt('authorizedPubkey'),
    Lt('nonce'),
    re.struct([qde], 'feeCalculator')
  ]),
  ET = g5.span
class i_ {
  constructor(e) {
    ;(this.authorizedPubkey = void 0),
      (this.nonce = void 0),
      (this.feeCalculator = void 0),
      (this.authorizedPubkey = e.authorizedPubkey),
      (this.nonce = e.nonce),
      (this.feeCalculator = e.feeCalculator)
  }
  static fromAccountData(e) {
    const n = g5.decode(Ir(e), 0)
    return new i_({
      authorizedPubkey: new it(n.authorizedPubkey),
      nonce: new it(n.nonce).toString(),
      feeCalculator: n.feeCalculator
    })
  }
}
const zde = t => {
    const e = t.decode.bind(t),
      n = t.encode.bind(t)
    return { decode: e, encode: n }
  },
  Wde = t => e => {
    const n = re.blob(t, e),
      { encode: r, decode: s } = zde(n),
      i = n
    return (
      (i.decode = (o, a) => {
        const c = s(o, a)
        return hT.toBigIntLE(Nt.Buffer.from(c))
      }),
      (i.encode = (o, a, c) => {
        const u = hT.toBufferLE(o, t)
        return r(u, a, c)
      }),
      i
    )
  },
  fd = Wde(8),
  Js = Object.freeze({
    Create: {
      index: 0,
      layout: re.struct([
        re.u32('instruction'),
        re.ns64('lamports'),
        re.ns64('space'),
        Lt('programId')
      ])
    },
    Assign: { index: 1, layout: re.struct([re.u32('instruction'), Lt('programId')]) },
    Transfer: { index: 2, layout: re.struct([re.u32('instruction'), fd('lamports')]) },
    CreateWithSeed: {
      index: 3,
      layout: re.struct([
        re.u32('instruction'),
        Lt('base'),
        vl('seed'),
        re.ns64('lamports'),
        re.ns64('space'),
        Lt('programId')
      ])
    },
    AdvanceNonceAccount: { index: 4, layout: re.struct([re.u32('instruction')]) },
    WithdrawNonceAccount: {
      index: 5,
      layout: re.struct([re.u32('instruction'), re.ns64('lamports')])
    },
    InitializeNonceAccount: {
      index: 6,
      layout: re.struct([re.u32('instruction'), Lt('authorized')])
    },
    AuthorizeNonceAccount: {
      index: 7,
      layout: re.struct([re.u32('instruction'), Lt('authorized')])
    },
    Allocate: { index: 8, layout: re.struct([re.u32('instruction'), re.ns64('space')]) },
    AllocateWithSeed: {
      index: 9,
      layout: re.struct([
        re.u32('instruction'),
        Lt('base'),
        vl('seed'),
        re.ns64('space'),
        Lt('programId')
      ])
    },
    AssignWithSeed: {
      index: 10,
      layout: re.struct([re.u32('instruction'), Lt('base'), vl('seed'), Lt('programId')])
    },
    TransferWithSeed: {
      index: 11,
      layout: re.struct([re.u32('instruction'), fd('lamports'), vl('seed'), Lt('programId')])
    },
    UpgradeNonceAccount: { index: 12, layout: re.struct([re.u32('instruction')]) }
  })
class zf {
  constructor() {}
  static createAccount(e) {
    const n = Js.Create,
      r = Hr(n, { lamports: e.lamports, space: e.space, programId: Ir(e.programId.toBuffer()) })
    return new rs({
      keys: [
        { pubkey: e.fromPubkey, isSigner: !0, isWritable: !0 },
        { pubkey: e.newAccountPubkey, isSigner: !0, isWritable: !0 }
      ],
      programId: this.programId,
      data: r
    })
  }
  static transfer(e) {
    let n, r
    if ('basePubkey' in e) {
      const s = Js.TransferWithSeed
      ;(n = Hr(s, {
        lamports: BigInt(e.lamports),
        seed: e.seed,
        programId: Ir(e.programId.toBuffer())
      })),
        (r = [
          { pubkey: e.fromPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: e.basePubkey, isSigner: !0, isWritable: !1 },
          { pubkey: e.toPubkey, isSigner: !1, isWritable: !0 }
        ])
    } else {
      const s = Js.Transfer
      ;(n = Hr(s, { lamports: BigInt(e.lamports) })),
        (r = [
          { pubkey: e.fromPubkey, isSigner: !0, isWritable: !0 },
          { pubkey: e.toPubkey, isSigner: !1, isWritable: !0 }
        ])
    }
    return new rs({ keys: r, programId: this.programId, data: n })
  }
  static assign(e) {
    let n, r
    if ('basePubkey' in e) {
      const s = Js.AssignWithSeed
      ;(n = Hr(s, {
        base: Ir(e.basePubkey.toBuffer()),
        seed: e.seed,
        programId: Ir(e.programId.toBuffer())
      })),
        (r = [
          { pubkey: e.accountPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: e.basePubkey, isSigner: !0, isWritable: !1 }
        ])
    } else {
      const s = Js.Assign
      ;(n = Hr(s, { programId: Ir(e.programId.toBuffer()) })),
        (r = [{ pubkey: e.accountPubkey, isSigner: !0, isWritable: !0 }])
    }
    return new rs({ keys: r, programId: this.programId, data: n })
  }
  static createAccountWithSeed(e) {
    const n = Js.CreateWithSeed,
      r = Hr(n, {
        base: Ir(e.basePubkey.toBuffer()),
        seed: e.seed,
        lamports: e.lamports,
        space: e.space,
        programId: Ir(e.programId.toBuffer())
      })
    let s = [
      { pubkey: e.fromPubkey, isSigner: !0, isWritable: !0 },
      { pubkey: e.newAccountPubkey, isSigner: !1, isWritable: !0 }
    ]
    return (
      e.basePubkey.equals(e.fromPubkey) ||
        s.push({ pubkey: e.basePubkey, isSigner: !0, isWritable: !1 }),
      new rs({ keys: s, programId: this.programId, data: r })
    )
  }
  static createNonceAccount(e) {
    const n = new Kr()
    'basePubkey' in e && 'seed' in e
      ? n.add(
          zf.createAccountWithSeed({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.noncePubkey,
            basePubkey: e.basePubkey,
            seed: e.seed,
            lamports: e.lamports,
            space: ET,
            programId: this.programId
          })
        )
      : n.add(
          zf.createAccount({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.noncePubkey,
            lamports: e.lamports,
            space: ET,
            programId: this.programId
          })
        )
    const r = { noncePubkey: e.noncePubkey, authorizedPubkey: e.authorizedPubkey }
    return n.add(this.nonceInitialize(r)), n
  }
  static nonceInitialize(e) {
    const n = Js.InitializeNonceAccount,
      r = Hr(n, { authorized: Ir(e.authorizedPubkey.toBuffer()) }),
      s = {
        keys: [
          { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: Fb, isSigner: !1, isWritable: !1 },
          { pubkey: bT, isSigner: !1, isWritable: !1 }
        ],
        programId: this.programId,
        data: r
      }
    return new rs(s)
  }
  static nonceAdvance(e) {
    const n = Js.AdvanceNonceAccount,
      r = Hr(n),
      s = {
        keys: [
          { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: Fb, isSigner: !1, isWritable: !1 },
          { pubkey: e.authorizedPubkey, isSigner: !0, isWritable: !1 }
        ],
        programId: this.programId,
        data: r
      }
    return new rs(s)
  }
  static nonceWithdraw(e) {
    const n = Js.WithdrawNonceAccount,
      r = Hr(n, { lamports: e.lamports })
    return new rs({
      keys: [
        { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
        { pubkey: e.toPubkey, isSigner: !1, isWritable: !0 },
        { pubkey: Fb, isSigner: !1, isWritable: !1 },
        { pubkey: bT, isSigner: !1, isWritable: !1 },
        { pubkey: e.authorizedPubkey, isSigner: !0, isWritable: !1 }
      ],
      programId: this.programId,
      data: r
    })
  }
  static nonceAuthorize(e) {
    const n = Js.AuthorizeNonceAccount,
      r = Hr(n, { authorized: Ir(e.newAuthorizedPubkey.toBuffer()) })
    return new rs({
      keys: [
        { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
        { pubkey: e.authorizedPubkey, isSigner: !0, isWritable: !1 }
      ],
      programId: this.programId,
      data: r
    })
  }
  static allocate(e) {
    let n, r
    if ('basePubkey' in e) {
      const s = Js.AllocateWithSeed
      ;(n = Hr(s, {
        base: Ir(e.basePubkey.toBuffer()),
        seed: e.seed,
        space: e.space,
        programId: Ir(e.programId.toBuffer())
      })),
        (r = [
          { pubkey: e.accountPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: e.basePubkey, isSigner: !0, isWritable: !1 }
        ])
    } else {
      const s = Js.Allocate
      ;(n = Hr(s, { space: e.space })),
        (r = [{ pubkey: e.accountPubkey, isSigner: !0, isWritable: !0 }])
    }
    return new rs({ keys: r, programId: this.programId, data: n })
  }
}
zf.programId = new it('11111111111111111111111111111111')
new it('BPFLoader2111111111111111111111111111111111')
function Kde(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t
}
var jb, AT
function Vde() {
  if (AT) return jb
  AT = 1
  var t = Object.prototype.toString,
    e =
      Object.keys ||
      function (r) {
        var s = []
        for (var i in r) s.push(i)
        return s
      }
  function n(r, s) {
    var i, o, a, c, u, l, d
    if (r === !0) return 'true'
    if (r === !1) return 'false'
    switch (typeof r) {
      case 'object':
        if (r === null) return null
        if (r.toJSON && typeof r.toJSON == 'function') return n(r.toJSON(), s)
        if (((d = t.call(r)), d === '[object Array]')) {
          for (a = '[', o = r.length - 1, i = 0; i < o; i++) a += n(r[i], !0) + ','
          return o > -1 && (a += n(r[i], !0)), a + ']'
        } else if (d === '[object Object]') {
          for (c = e(r).sort(), o = c.length, a = '', i = 0; i < o; )
            (u = c[i]),
              (l = n(r[u], !1)),
              l !== void 0 && (a && (a += ','), (a += JSON.stringify(u) + ':' + l)),
              i++
          return '{' + a + '}'
        } else return JSON.stringify(r)
      case 'function':
      case 'undefined':
        return s ? null : void 0
      case 'string':
        return JSON.stringify(r)
      default:
        return isFinite(r) ? r : null
    }
  }
  return (
    (jb = function (r) {
      var s = n(r, !1)
      if (s !== void 0) return '' + s
    }),
    jb
  )
}
var Gde = Vde(),
  _T = Kde(Gde)
const dh = 32
function Hb(t) {
  let e = 0
  for (; t > 1; ) (t /= 2), e++
  return e
}
function Qde(t) {
  return t === 0
    ? 1
    : (t--,
      (t |= t >> 1),
      (t |= t >> 2),
      (t |= t >> 4),
      (t |= t >> 8),
      (t |= t >> 16),
      (t |= t >> 32),
      t + 1)
}
class Zde {
  constructor(e, n, r, s, i) {
    ;(this.slotsPerEpoch = void 0),
      (this.leaderScheduleSlotOffset = void 0),
      (this.warmup = void 0),
      (this.firstNormalEpoch = void 0),
      (this.firstNormalSlot = void 0),
      (this.slotsPerEpoch = e),
      (this.leaderScheduleSlotOffset = n),
      (this.warmup = r),
      (this.firstNormalEpoch = s),
      (this.firstNormalSlot = i)
  }
  getEpoch(e) {
    return this.getEpochAndSlotIndex(e)[0]
  }
  getEpochAndSlotIndex(e) {
    if (e < this.firstNormalSlot) {
      const n = Hb(Qde(e + dh + 1)) - Hb(dh) - 1,
        r = this.getSlotsInEpoch(n),
        s = e - (r - dh)
      return [n, s]
    } else {
      const n = e - this.firstNormalSlot,
        r = Math.floor(n / this.slotsPerEpoch),
        s = this.firstNormalEpoch + r,
        i = n % this.slotsPerEpoch
      return [s, i]
    }
  }
  getFirstSlotInEpoch(e) {
    return e <= this.firstNormalEpoch
      ? (Math.pow(2, e) - 1) * dh
      : (e - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
  }
  getLastSlotInEpoch(e) {
    return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1
  }
  getSlotsInEpoch(e) {
    return e < this.firstNormalEpoch ? Math.pow(2, e + Hb(dh)) : this.slotsPerEpoch
  }
}
var Yde = globalThis.fetch
class Jde extends Tde {
  constructor(e, n, r) {
    const s = i => {
      const o = Ide(i, {
        autoconnect: !0,
        max_reconnects: 5,
        reconnect: !0,
        reconnect_interval: 1e3,
        ...n
      })
      return 'socket' in o ? (this.underlyingSocket = o.socket) : (this.underlyingSocket = o), o
    }
    super(s, e, n, r), (this.underlyingSocket = void 0)
  }
  call(...e) {
    var r
    const n = (r = this.underlyingSocket) == null ? void 0 : r.readyState
    return n === 1
      ? super.call(...e)
      : Promise.reject(
          new Error(
            'Tried to call a JSON-RPC method `' +
              e[0] +
              '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' +
              n +
              ')'
          )
        )
  }
  notify(...e) {
    var r
    const n = (r = this.underlyingSocket) == null ? void 0 : r.readyState
    return n === 1
      ? super.notify(...e)
      : Promise.reject(
          new Error(
            'Tried to send a JSON-RPC notification `' +
              e[0] +
              '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' +
              n +
              ')'
          )
        )
  }
}
function Xde(t, e) {
  let n
  try {
    n = t.layout.decode(e)
  } catch (r) {
    throw new Error('invalid instruction; ' + r)
  }
  if (n.typeIndex !== t.index)
    throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${t.index}`)
  return n
}
const CT = 56
class ST {
  constructor(e) {
    ;(this.key = void 0), (this.state = void 0), (this.key = e.key), (this.state = e.state)
  }
  isActive() {
    const e = BigInt('0xffffffffffffffff')
    return this.state.deactivationSlot === e
  }
  static deserialize(e) {
    const n = Xde(ehe, e),
      r = e.length - CT
    Tn(r >= 0, 'lookup table is invalid'), Tn(r % 32 === 0, 'lookup table is invalid')
    const s = r / 32,
      { addresses: i } = re.struct([re.seq(Lt(), s, 'addresses')]).decode(e.slice(CT))
    return {
      deactivationSlot: n.deactivationSlot,
      lastExtendedSlot: n.lastExtendedSlot,
      lastExtendedSlotStartIndex: n.lastExtendedStartIndex,
      authority: n.authority.length !== 0 ? new it(n.authority[0]) : void 0,
      addresses: i.map(o => new it(o))
    }
  }
}
const ehe = {
    index: 1,
    layout: re.struct([
      re.u32('typeIndex'),
      fd('deactivationSlot'),
      re.nu64('lastExtendedSlot'),
      re.u8('lastExtendedStartIndex'),
      re.u8(),
      re.seq(Lt(), re.offset(re.u8(), -1), 'authority')
    ])
  },
  the = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i
function nhe(t) {
  const e = t.match(the)
  if (e == null) throw TypeError(`Failed to validate endpoint URL \`${t}\``)
  const [n, r, s, i] = e,
    o = t.startsWith('https:') ? 'wss:' : 'ws:',
    a = s == null ? null : parseInt(s.slice(1), 10),
    c = a == null ? '' : `:${a + 1}`
  return `${o}//${r}${c}${i}`
}
const Mn = Pp(n_(it), De(), t => new it(t)),
  m5 = r_([De(), Bn('base64')]),
  o_ = Pp(n_(Nt.Buffer), m5, t => Nt.Buffer.from(t[0], 'base64')),
  rhe = 30 * 1e3
function she(t) {
  if (/^https?:/.test(t) === !1)
    throw new TypeError('Endpoint URL must start with `http:` or `https:`.')
  return t
}
function bn(t) {
  let e, n
  if (typeof t == 'string') e = t
  else if (t) {
    const { commitment: r, ...s } = t
    ;(e = r), (n = s)
  }
  return { commitment: e, config: n }
}
function IT(t) {
  return t.map(e =>
    'memcmp' in e ? { ...e, memcmp: { ...e.memcmp, encoding: e.memcmp.encoding ?? 'base58' } } : e
  )
}
function y5(t) {
  return ds([
    Ce({ jsonrpc: Bn('2.0'), id: De(), result: t }),
    Ce({ jsonrpc: Bn('2.0'), id: De(), error: Ce({ code: Bd(), message: De(), data: lt(ede()) }) })
  ])
}
const ihe = y5(Bd())
function Bt(t) {
  return Pp(y5(t), ihe, e => ('error' in e ? e : { ...e, result: Fe(e.result, t) }))
}
function qn(t) {
  return Bt(Ce({ context: Ce({ slot: ae() }), value: t }))
}
function hy(t) {
  return Ce({ context: Ce({ slot: ae() }), value: t })
}
function qb(t, e) {
  return t === 0
    ? new qf({
        header: e.header,
        staticAccountKeys: e.accountKeys.map(n => new it(n)),
        recentBlockhash: e.recentBlockhash,
        compiledInstructions: e.instructions.map(n => ({
          programIdIndex: n.programIdIndex,
          accountKeyIndexes: n.accounts,
          data: Nr.decode(n.data)
        })),
        addressTableLookups: e.addressTableLookups
      })
    : new ea(e)
}
const ohe = Ce({
    foundation: ae(),
    foundationTerm: ae(),
    initial: ae(),
    taper: ae(),
    terminal: ae()
  }),
  ahe = Bt(
    He(
      ze(
        Ce({
          epoch: ae(),
          effectiveSlot: ae(),
          amount: ae(),
          postBalance: ae(),
          commission: lt(ze(ae()))
        })
      )
    )
  ),
  che = He(Ce({ slot: ae(), prioritizationFee: ae() })),
  uhe = Ce({ total: ae(), validator: ae(), foundation: ae(), epoch: ae() }),
  lhe = Ce({
    epoch: ae(),
    slotIndex: ae(),
    slotsInEpoch: ae(),
    absoluteSlot: ae(),
    blockHeight: lt(ae()),
    transactionCount: lt(ae())
  }),
  dhe = Ce({
    slotsPerEpoch: ae(),
    leaderScheduleSlotOffset: ae(),
    warmup: fo(),
    firstNormalEpoch: ae(),
    firstNormalSlot: ae()
  }),
  hhe = n5(De(), He(ae())),
  Bu = ze(ds([Ce({}), De()])),
  fhe = Ce({ err: Bu }),
  phe = Bn('receivedSignature'),
  ghe = Ce({ 'solana-core': De(), 'feature-set': lt(ae()) }),
  mhe = Ce({ program: De(), programId: Mn, parsed: Bd() }),
  yhe = Ce({ programId: Mn, accounts: He(Mn), data: De() }),
  xT = qn(
    Ce({
      err: ze(ds([Ce({}), De()])),
      logs: ze(He(De())),
      accounts: lt(
        ze(
          He(
            ze(
              Ce({
                executable: fo(),
                owner: De(),
                lamports: ae(),
                data: He(De()),
                rentEpoch: lt(ae())
              })
            )
          )
        )
      ),
      unitsConsumed: lt(ae()),
      returnData: lt(ze(Ce({ programId: De(), data: r_([De(), Bn('base64')]) }))),
      innerInstructions: lt(ze(He(Ce({ index: ae(), instructions: He(ds([mhe, yhe])) }))))
    })
  ),
  whe = qn(Ce({ byIdentity: n5(De(), He(ae())), range: Ce({ firstSlot: ae(), lastSlot: ae() }) }))
function bhe(t, e, n, r, s, i) {
  const o = n || Yde
  let a
  i != null &&
    console.warn(
      'You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.'
    )
  let c
  return (
    r &&
      (c = async (l, d) => {
        const h = await new Promise((p, y) => {
          try {
            r(l, d, (m, b) => p([m, b]))
          } catch (m) {
            y(m)
          }
        })
        return await o(...h)
      }),
    new Cde(async (l, d) => {
      const h = {
        method: 'POST',
        body: l,
        agent: a,
        headers: Object.assign({ 'Content-Type': 'application/json' }, e || {}, bfe)
      }
      try {
        let p = 5,
          y,
          m = 500
        for (
          ;
          c ? (y = await c(t, h)) : (y = await o(t, h)),
            !(y.status !== 429 || s === !0 || ((p -= 1), p === 0));

        )
          console.error(
            `Server responded with ${y.status} ${y.statusText}.  Retrying after ${m}ms delay...`
          ),
            await ll(m),
            (m *= 2)
        const b = await y.text()
        y.ok ? d(null, b) : d(new Error(`${y.status} ${y.statusText}: ${b}`))
      } catch (p) {
        p instanceof Error && d(p)
      }
    }, {})
  )
}
function vhe(t) {
  return (e, n) =>
    new Promise((r, s) => {
      t.request(e, n, (i, o) => {
        if (i) {
          s(i)
          return
        }
        r(o)
      })
    })
}
function Ehe(t) {
  return e =>
    new Promise((n, r) => {
      e.length === 0 && n([])
      const s = e.map(i => t.request(i.methodName, i.args))
      t.request(s, (i, o) => {
        if (i) {
          r(i)
          return
        }
        n(o)
      })
    })
}
const Ahe = Bt(ohe),
  _he = Bt(uhe),
  Che = Bt(che),
  She = Bt(lhe),
  Ihe = Bt(dhe),
  xhe = Bt(hhe),
  The = Bt(ae()),
  Nhe = qn(
    Ce({ total: ae(), circulating: ae(), nonCirculating: ae(), nonCirculatingAccounts: He(Mn) })
  ),
  $v = Ce({ amount: De(), uiAmount: ze(ae()), decimals: ae(), uiAmountString: lt(De()) }),
  Phe = qn(
    He(
      Ce({
        address: Mn,
        amount: De(),
        uiAmount: ze(ae()),
        decimals: ae(),
        uiAmountString: lt(De())
      })
    )
  ),
  Rhe = qn(
    He(
      Ce({
        pubkey: Mn,
        account: Ce({ executable: fo(), owner: Mn, lamports: ae(), data: o_, rentEpoch: ae() })
      })
    )
  ),
  Fv = Ce({ program: De(), parsed: Bd(), space: ae() }),
  khe = qn(
    He(
      Ce({
        pubkey: Mn,
        account: Ce({ executable: fo(), owner: Mn, lamports: ae(), data: Fv, rentEpoch: ae() })
      })
    )
  ),
  Ohe = qn(He(Ce({ lamports: ae(), address: Mn }))),
  Wf = Ce({ executable: fo(), owner: Mn, lamports: ae(), data: o_, rentEpoch: ae() }),
  Bhe = Ce({ pubkey: Mn, account: Wf }),
  Dhe = Pp(ds([n_(Nt.Buffer), Fv]), ds([m5, Fv]), t => (Array.isArray(t) ? Fe(t, o_) : t)),
  jv = Ce({ executable: fo(), owner: Mn, lamports: ae(), data: Dhe, rentEpoch: ae() }),
  Mhe = Ce({ pubkey: Mn, account: jv }),
  Uhe = Ce({
    state: ds([Bn('active'), Bn('inactive'), Bn('activating'), Bn('deactivating')]),
    active: ae(),
    inactive: ae()
  }),
  Lhe = Bt(
    He(Ce({ signature: De(), slot: ae(), err: Bu, memo: ze(De()), blockTime: lt(ze(ae())) }))
  ),
  $he = Bt(
    He(Ce({ signature: De(), slot: ae(), err: Bu, memo: ze(De()), blockTime: lt(ze(ae())) }))
  ),
  Fhe = Ce({ subscription: ae(), result: hy(Wf) }),
  jhe = Ce({ pubkey: Mn, account: Wf }),
  Hhe = Ce({ subscription: ae(), result: hy(jhe) }),
  qhe = Ce({ parent: ae(), slot: ae(), root: ae() }),
  zhe = Ce({ subscription: ae(), result: qhe }),
  Whe = ds([
    Ce({
      type: ds([
        Bn('firstShredReceived'),
        Bn('completed'),
        Bn('optimisticConfirmation'),
        Bn('root')
      ]),
      slot: ae(),
      timestamp: ae()
    }),
    Ce({ type: Bn('createdBank'), parent: ae(), slot: ae(), timestamp: ae() }),
    Ce({
      type: Bn('frozen'),
      slot: ae(),
      timestamp: ae(),
      stats: Ce({
        numTransactionEntries: ae(),
        numSuccessfulTransactions: ae(),
        numFailedTransactions: ae(),
        maxTransactionsPerEntry: ae()
      })
    }),
    Ce({ type: Bn('dead'), slot: ae(), timestamp: ae(), err: De() })
  ]),
  Khe = Ce({ subscription: ae(), result: Whe }),
  Vhe = Ce({ subscription: ae(), result: hy(ds([fhe, phe])) }),
  Ghe = Ce({ subscription: ae(), result: ae() }),
  Qhe = Ce({ pubkey: De(), gossip: ze(De()), tpu: ze(De()), rpc: ze(De()), version: ze(De()) }),
  TT = Ce({
    votePubkey: De(),
    nodePubkey: De(),
    activatedStake: ae(),
    epochVoteAccount: fo(),
    epochCredits: He(r_([ae(), ae(), ae()])),
    commission: ae(),
    lastVote: ae(),
    rootSlot: ze(ae())
  }),
  Zhe = Bt(Ce({ current: He(TT), delinquent: He(TT) })),
  Yhe = ds([Bn('processed'), Bn('confirmed'), Bn('finalized')]),
  Jhe = Ce({ slot: ae(), confirmations: ze(ae()), err: Bu, confirmationStatus: lt(Yhe) }),
  Xhe = qn(He(ze(Jhe))),
  efe = Bt(ae()),
  w5 = Ce({ accountKey: Mn, writableIndexes: He(ae()), readonlyIndexes: He(ae()) }),
  a_ = Ce({
    signatures: He(De()),
    message: Ce({
      accountKeys: He(De()),
      header: Ce({
        numRequiredSignatures: ae(),
        numReadonlySignedAccounts: ae(),
        numReadonlyUnsignedAccounts: ae()
      }),
      instructions: He(Ce({ accounts: He(ae()), data: De(), programIdIndex: ae() })),
      recentBlockhash: De(),
      addressTableLookups: lt(He(w5))
    })
  }),
  b5 = Ce({
    pubkey: Mn,
    signer: fo(),
    writable: fo(),
    source: lt(ds([Bn('transaction'), Bn('lookupTable')]))
  }),
  v5 = Ce({ accountKeys: He(b5), signatures: He(De()) }),
  E5 = Ce({ parsed: Bd(), program: De(), programId: Mn }),
  A5 = Ce({ accounts: He(Mn), data: De(), programId: Mn }),
  tfe = ds([A5, E5]),
  nfe = ds([
    Ce({ parsed: Bd(), program: De(), programId: De() }),
    Ce({ accounts: He(De()), data: De(), programId: De() })
  ]),
  _5 = Pp(tfe, nfe, t => ('accounts' in t ? Fe(t, A5) : Fe(t, E5))),
  C5 = Ce({
    signatures: He(De()),
    message: Ce({
      accountKeys: He(b5),
      instructions: He(_5),
      recentBlockhash: De(),
      addressTableLookups: lt(ze(He(w5)))
    })
  }),
  zm = Ce({
    accountIndex: ae(),
    mint: De(),
    owner: lt(De()),
    programId: lt(De()),
    uiTokenAmount: $v
  }),
  S5 = Ce({ writable: He(Mn), readonly: He(Mn) }),
  fy = Ce({
    err: Bu,
    fee: ae(),
    innerInstructions: lt(
      ze(
        He(
          Ce({
            index: ae(),
            instructions: He(Ce({ accounts: He(ae()), data: De(), programIdIndex: ae() }))
          })
        )
      )
    ),
    preBalances: He(ae()),
    postBalances: He(ae()),
    logMessages: lt(ze(He(De()))),
    preTokenBalances: lt(ze(He(zm))),
    postTokenBalances: lt(ze(He(zm))),
    loadedAddresses: lt(S5),
    computeUnitsConsumed: lt(ae())
  }),
  c_ = Ce({
    err: Bu,
    fee: ae(),
    innerInstructions: lt(ze(He(Ce({ index: ae(), instructions: He(_5) })))),
    preBalances: He(ae()),
    postBalances: He(ae()),
    logMessages: lt(ze(He(De()))),
    preTokenBalances: lt(ze(He(zm))),
    postTokenBalances: lt(ze(He(zm))),
    loadedAddresses: lt(S5),
    computeUnitsConsumed: lt(ae())
  }),
  Dd = ds([Bn(0), Bn('legacy')]),
  Du = Ce({
    pubkey: De(),
    lamports: ae(),
    postBalance: ze(ae()),
    rewardType: ze(De()),
    commission: lt(ze(ae()))
  }),
  rfe = Bt(
    ze(
      Ce({
        blockhash: De(),
        previousBlockhash: De(),
        parentSlot: ae(),
        transactions: He(Ce({ transaction: a_, meta: ze(fy), version: lt(Dd) })),
        rewards: lt(He(Du)),
        blockTime: ze(ae()),
        blockHeight: ze(ae())
      })
    )
  ),
  sfe = Bt(
    ze(
      Ce({
        blockhash: De(),
        previousBlockhash: De(),
        parentSlot: ae(),
        rewards: lt(He(Du)),
        blockTime: ze(ae()),
        blockHeight: ze(ae())
      })
    )
  ),
  ife = Bt(
    ze(
      Ce({
        blockhash: De(),
        previousBlockhash: De(),
        parentSlot: ae(),
        transactions: He(Ce({ transaction: v5, meta: ze(fy), version: lt(Dd) })),
        rewards: lt(He(Du)),
        blockTime: ze(ae()),
        blockHeight: ze(ae())
      })
    )
  ),
  ofe = Bt(
    ze(
      Ce({
        blockhash: De(),
        previousBlockhash: De(),
        parentSlot: ae(),
        transactions: He(Ce({ transaction: C5, meta: ze(c_), version: lt(Dd) })),
        rewards: lt(He(Du)),
        blockTime: ze(ae()),
        blockHeight: ze(ae())
      })
    )
  ),
  afe = Bt(
    ze(
      Ce({
        blockhash: De(),
        previousBlockhash: De(),
        parentSlot: ae(),
        transactions: He(Ce({ transaction: v5, meta: ze(c_), version: lt(Dd) })),
        rewards: lt(He(Du)),
        blockTime: ze(ae()),
        blockHeight: ze(ae())
      })
    )
  ),
  cfe = Bt(
    ze(
      Ce({
        blockhash: De(),
        previousBlockhash: De(),
        parentSlot: ae(),
        rewards: lt(He(Du)),
        blockTime: ze(ae()),
        blockHeight: ze(ae())
      })
    )
  ),
  ufe = Bt(
    ze(
      Ce({
        blockhash: De(),
        previousBlockhash: De(),
        parentSlot: ae(),
        transactions: He(Ce({ transaction: a_, meta: ze(fy) })),
        rewards: lt(He(Du)),
        blockTime: ze(ae())
      })
    )
  ),
  NT = Bt(
    ze(
      Ce({
        blockhash: De(),
        previousBlockhash: De(),
        parentSlot: ae(),
        signatures: He(De()),
        blockTime: ze(ae())
      })
    )
  ),
  zb = Bt(
    ze(Ce({ slot: ae(), meta: ze(fy), blockTime: lt(ze(ae())), transaction: a_, version: lt(Dd) }))
  ),
  Eg = Bt(
    ze(Ce({ slot: ae(), transaction: C5, meta: ze(c_), blockTime: lt(ze(ae())), version: lt(Dd) }))
  ),
  lfe = qn(Ce({ blockhash: De(), lastValidBlockHeight: ae() })),
  dfe = qn(fo()),
  hfe = Ce({ slot: ae(), numTransactions: ae(), numSlots: ae(), samplePeriodSecs: ae() }),
  ffe = Bt(He(hfe)),
  pfe = qn(ze(Ce({ feeCalculator: Ce({ lamportsPerSignature: ae() }) }))),
  gfe = Bt(De()),
  mfe = Bt(De()),
  yfe = Ce({ err: Bu, logs: He(De()), signature: De() }),
  wfe = Ce({ result: hy(yfe), subscription: ae() }),
  bfe = { 'solana-client': 'js/1.0.0-maintenance' }
class hh {
  constructor(e, n) {
    ;(this._commitment = void 0),
      (this._confirmTransactionInitialTimeout = void 0),
      (this._rpcEndpoint = void 0),
      (this._rpcWsEndpoint = void 0),
      (this._rpcClient = void 0),
      (this._rpcRequest = void 0),
      (this._rpcBatchRequest = void 0),
      (this._rpcWebSocket = void 0),
      (this._rpcWebSocketConnected = !1),
      (this._rpcWebSocketHeartbeat = null),
      (this._rpcWebSocketIdleTimeout = null),
      (this._rpcWebSocketGeneration = 0),
      (this._disableBlockhashCaching = !1),
      (this._pollingBlockhash = !1),
      (this._blockhashInfo = {
        latestBlockhash: null,
        lastFetch: 0,
        transactionSignatures: [],
        simulatedSignatures: []
      }),
      (this._nextClientSubscriptionId = 0),
      (this._subscriptionDisposeFunctionsByClientSubscriptionId = {}),
      (this._subscriptionHashByClientSubscriptionId = {}),
      (this._subscriptionStateChangeCallbacksByHash = {}),
      (this._subscriptionCallbacksByServerSubscriptionId = {}),
      (this._subscriptionsByHash = {}),
      (this._subscriptionsAutoDisposedByRpc = new Set()),
      (this.getBlockHeight = (() => {
        const u = {}
        return async l => {
          const { commitment: d, config: h } = bn(l),
            p = this._buildArgs([], d, void 0, h),
            y = _T(p)
          return (
            (u[y] =
              u[y] ??
              (async () => {
                try {
                  const m = await this._rpcRequest('getBlockHeight', p),
                    b = Fe(m, Bt(ae()))
                  if ('error' in b) throw new ot(b.error, 'failed to get block height information')
                  return b.result
                } finally {
                  delete u[y]
                }
              })()),
            await u[y]
          )
        }
      })())
    let r, s, i, o, a, c
    n && typeof n == 'string'
      ? (this._commitment = n)
      : n &&
        ((this._commitment = n.commitment),
        (this._confirmTransactionInitialTimeout = n.confirmTransactionInitialTimeout),
        (r = n.wsEndpoint),
        (s = n.httpHeaders),
        (i = n.fetch),
        (o = n.fetchMiddleware),
        (a = n.disableRetryOnRateLimit),
        (c = n.httpAgent)),
      (this._rpcEndpoint = she(e)),
      (this._rpcWsEndpoint = r || nhe(e)),
      (this._rpcClient = bhe(e, s, i, o, a, c)),
      (this._rpcRequest = vhe(this._rpcClient)),
      (this._rpcBatchRequest = Ehe(this._rpcClient)),
      (this._rpcWebSocket = new Jde(this._rpcWsEndpoint, {
        autoconnect: !1,
        max_reconnects: 1 / 0
      })),
      this._rpcWebSocket.on('open', this._wsOnOpen.bind(this)),
      this._rpcWebSocket.on('error', this._wsOnError.bind(this)),
      this._rpcWebSocket.on('close', this._wsOnClose.bind(this)),
      this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this)),
      this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this)),
      this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this)),
      this._rpcWebSocket.on(
        'slotsUpdatesNotification',
        this._wsOnSlotUpdatesNotification.bind(this)
      ),
      this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this)),
      this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this)),
      this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this))
  }
  get commitment() {
    return this._commitment
  }
  get rpcEndpoint() {
    return this._rpcEndpoint
  }
  async getBalanceAndContext(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = this._buildArgs([e.toBase58()], r, void 0, s),
      o = await this._rpcRequest('getBalance', i),
      a = Fe(o, qn(ae()))
    if ('error' in a) throw new ot(a.error, `failed to get balance for ${e.toBase58()}`)
    return a.result
  }
  async getBalance(e, n) {
    return await this.getBalanceAndContext(e, n)
      .then(r => r.value)
      .catch(r => {
        throw new Error('failed to get balance of account ' + e.toBase58() + ': ' + r)
      })
  }
  async getBlockTime(e) {
    const n = await this._rpcRequest('getBlockTime', [e]),
      r = Fe(n, Bt(ze(ae())))
    if ('error' in r) throw new ot(r.error, `failed to get block time for slot ${e}`)
    return r.result
  }
  async getMinimumLedgerSlot() {
    const e = await this._rpcRequest('minimumLedgerSlot', []),
      n = Fe(e, Bt(ae()))
    if ('error' in n) throw new ot(n.error, 'failed to get minimum ledger slot')
    return n.result
  }
  async getFirstAvailableBlock() {
    const e = await this._rpcRequest('getFirstAvailableBlock', []),
      n = Fe(e, The)
    if ('error' in n) throw new ot(n.error, 'failed to get first available block')
    return n.result
  }
  async getSupply(e) {
    let n = {}
    typeof e == 'string'
      ? (n = { commitment: e })
      : e
        ? (n = { ...e, commitment: (e && e.commitment) || this.commitment })
        : (n = { commitment: this.commitment })
    const r = await this._rpcRequest('getSupply', [n]),
      s = Fe(r, Nhe)
    if ('error' in s) throw new ot(s.error, 'failed to get supply')
    return s.result
  }
  async getTokenSupply(e, n) {
    const r = this._buildArgs([e.toBase58()], n),
      s = await this._rpcRequest('getTokenSupply', r),
      i = Fe(s, qn($v))
    if ('error' in i) throw new ot(i.error, 'failed to get token supply')
    return i.result
  }
  async getTokenAccountBalance(e, n) {
    const r = this._buildArgs([e.toBase58()], n),
      s = await this._rpcRequest('getTokenAccountBalance', r),
      i = Fe(s, qn($v))
    if ('error' in i) throw new ot(i.error, 'failed to get token account balance')
    return i.result
  }
  async getTokenAccountsByOwner(e, n, r) {
    const { commitment: s, config: i } = bn(r)
    let o = [e.toBase58()]
    'mint' in n
      ? o.push({ mint: n.mint.toBase58() })
      : o.push({ programId: n.programId.toBase58() })
    const a = this._buildArgs(o, s, 'base64', i),
      c = await this._rpcRequest('getTokenAccountsByOwner', a),
      u = Fe(c, Rhe)
    if ('error' in u)
      throw new ot(u.error, `failed to get token accounts owned by account ${e.toBase58()}`)
    return u.result
  }
  async getParsedTokenAccountsByOwner(e, n, r) {
    let s = [e.toBase58()]
    'mint' in n
      ? s.push({ mint: n.mint.toBase58() })
      : s.push({ programId: n.programId.toBase58() })
    const i = this._buildArgs(s, r, 'jsonParsed'),
      o = await this._rpcRequest('getTokenAccountsByOwner', i),
      a = Fe(o, khe)
    if ('error' in a)
      throw new ot(a.error, `failed to get token accounts owned by account ${e.toBase58()}`)
    return a.result
  }
  async getLargestAccounts(e) {
    const n = { ...e, commitment: (e && e.commitment) || this.commitment },
      r = n.filter || n.commitment ? [n] : [],
      s = await this._rpcRequest('getLargestAccounts', r),
      i = Fe(s, Ohe)
    if ('error' in i) throw new ot(i.error, 'failed to get largest accounts')
    return i.result
  }
  async getTokenLargestAccounts(e, n) {
    const r = this._buildArgs([e.toBase58()], n),
      s = await this._rpcRequest('getTokenLargestAccounts', r),
      i = Fe(s, Phe)
    if ('error' in i) throw new ot(i.error, 'failed to get token largest accounts')
    return i.result
  }
  async getAccountInfoAndContext(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = this._buildArgs([e.toBase58()], r, 'base64', s),
      o = await this._rpcRequest('getAccountInfo', i),
      a = Fe(o, qn(ze(Wf)))
    if ('error' in a) throw new ot(a.error, `failed to get info about account ${e.toBase58()}`)
    return a.result
  }
  async getParsedAccountInfo(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = this._buildArgs([e.toBase58()], r, 'jsonParsed', s),
      o = await this._rpcRequest('getAccountInfo', i),
      a = Fe(o, qn(ze(jv)))
    if ('error' in a) throw new ot(a.error, `failed to get info about account ${e.toBase58()}`)
    return a.result
  }
  async getAccountInfo(e, n) {
    try {
      return (await this.getAccountInfoAndContext(e, n)).value
    } catch (r) {
      throw new Error('failed to get info about account ' + e.toBase58() + ': ' + r)
    }
  }
  async getMultipleParsedAccounts(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = e.map(u => u.toBase58()),
      o = this._buildArgs([i], r, 'jsonParsed', s),
      a = await this._rpcRequest('getMultipleAccounts', o),
      c = Fe(a, qn(He(ze(jv))))
    if ('error' in c) throw new ot(c.error, `failed to get info for accounts ${i}`)
    return c.result
  }
  async getMultipleAccountsInfoAndContext(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = e.map(u => u.toBase58()),
      o = this._buildArgs([i], r, 'base64', s),
      a = await this._rpcRequest('getMultipleAccounts', o),
      c = Fe(a, qn(He(ze(Wf))))
    if ('error' in c) throw new ot(c.error, `failed to get info for accounts ${i}`)
    return c.result
  }
  async getMultipleAccountsInfo(e, n) {
    return (await this.getMultipleAccountsInfoAndContext(e, n)).value
  }
  async getStakeActivation(e, n, r) {
    const { commitment: s, config: i } = bn(n),
      o = this._buildArgs([e.toBase58()], s, void 0, {
        ...i,
        epoch: r ?? (i == null ? void 0 : i.epoch)
      }),
      a = await this._rpcRequest('getStakeActivation', o),
      c = Fe(a, Bt(Uhe))
    if ('error' in c) throw new ot(c.error, `failed to get Stake Activation ${e.toBase58()}`)
    return c.result
  }
  async getProgramAccounts(e, n) {
    const { commitment: r, config: s } = bn(n),
      { encoding: i, ...o } = s || {},
      a = this._buildArgs([e.toBase58()], r, i || 'base64', {
        ...o,
        ...(o.filters ? { filters: IT(o.filters) } : null)
      }),
      c = await this._rpcRequest('getProgramAccounts', a),
      u = He(Bhe),
      l = o.withContext === !0 ? Fe(c, qn(u)) : Fe(c, Bt(u))
    if ('error' in l)
      throw new ot(l.error, `failed to get accounts owned by program ${e.toBase58()}`)
    return l.result
  }
  async getParsedProgramAccounts(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = this._buildArgs([e.toBase58()], r, 'jsonParsed', s),
      o = await this._rpcRequest('getProgramAccounts', i),
      a = Fe(o, Bt(He(Mhe)))
    if ('error' in a)
      throw new ot(a.error, `failed to get accounts owned by program ${e.toBase58()}`)
    return a.result
  }
  async confirmTransaction(e, n) {
    var i
    let r
    if (typeof e == 'string') r = e
    else {
      const o = e
      if ((i = o.abortSignal) != null && i.aborted) return Promise.reject(o.abortSignal.reason)
      r = o.signature
    }
    let s
    try {
      s = Nr.decode(r)
    } catch {
      throw new Error('signature must be base58 encoded: ' + r)
    }
    return (
      Tn(s.length === 64, 'signature has invalid length'),
      typeof e == 'string'
        ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: n || this.commitment,
            signature: r
          })
        : 'lastValidBlockHeight' in e
          ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
              commitment: n || this.commitment,
              strategy: e
            })
          : await this.confirmTransactionUsingDurableNonceStrategy({
              commitment: n || this.commitment,
              strategy: e
            })
    )
  }
  getCancellationPromise(e) {
    return new Promise((n, r) => {
      e != null &&
        (e.aborted
          ? r(e.reason)
          : e.addEventListener('abort', () => {
              r(e.reason)
            }))
    })
  }
  getTransactionConfirmationPromise({ commitment: e, signature: n }) {
    let r,
      s,
      i = !1
    const o = new Promise((c, u) => {
      try {
        r = this.onSignature(
          n,
          (d, h) => {
            r = void 0
            const p = { context: h, value: d }
            c({ __type: ma.PROCESSED, response: p })
          },
          e
        )
        const l = new Promise(d => {
          r == null
            ? d()
            : (s = this._onSubscriptionStateChange(r, h => {
                h === 'subscribed' && d()
              }))
        })
        ;(async () => {
          if ((await l, i)) return
          const d = await this.getSignatureStatus(n)
          if (i || d == null) return
          const { context: h, value: p } = d
          if (p != null)
            if (p != null && p.err) u(p.err)
            else {
              switch (e) {
                case 'confirmed':
                case 'single':
                case 'singleGossip': {
                  if (p.confirmationStatus === 'processed') return
                  break
                }
                case 'finalized':
                case 'max':
                case 'root': {
                  if (p.confirmationStatus === 'processed' || p.confirmationStatus === 'confirmed')
                    return
                  break
                }
                case 'processed':
                case 'recent':
              }
              ;(i = !0), c({ __type: ma.PROCESSED, response: { context: h, value: p } })
            }
        })()
      } catch (l) {
        u(l)
      }
    })
    return {
      abortConfirmation: () => {
        s && (s(), (s = void 0)), r != null && (this.removeSignatureListener(r), (r = void 0))
      },
      confirmationPromise: o
    }
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment: e,
    strategy: { abortSignal: n, lastValidBlockHeight: r, signature: s }
  }) {
    let i = !1
    const o = new Promise(d => {
        const h = async () => {
          try {
            return await this.getBlockHeight(e)
          } catch {
            return -1
          }
        }
        ;(async () => {
          let p = await h()
          if (!i) {
            for (; p <= r; ) if ((await ll(1e3), i || ((p = await h()), i))) return
            d({ __type: ma.BLOCKHEIGHT_EXCEEDED })
          }
        })()
      }),
      { abortConfirmation: a, confirmationPromise: c } = this.getTransactionConfirmationPromise({
        commitment: e,
        signature: s
      }),
      u = this.getCancellationPromise(n)
    let l
    try {
      const d = await Promise.race([u, c, o])
      if (d.__type === ma.PROCESSED) l = d.response
      else throw new l5(s)
    } finally {
      ;(i = !0), a()
    }
    return l
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment: e,
    strategy: {
      abortSignal: n,
      minContextSlot: r,
      nonceAccountPubkey: s,
      nonceValue: i,
      signature: o
    }
  }) {
    let a = !1
    const c = new Promise(p => {
        let y = i,
          m = null
        const b = async () => {
          try {
            const { context: I, value: x } = await this.getNonceAndContext(s, {
              commitment: e,
              minContextSlot: r
            })
            return (m = I.slot), x == null ? void 0 : x.nonce
          } catch {
            return y
          }
        }
        ;(async () => {
          if (((y = await b()), !a))
            for (;;) {
              if (i !== y) {
                p({ __type: ma.NONCE_INVALID, slotInWhichNonceDidAdvance: m })
                return
              }
              if ((await ll(2e3), a || ((y = await b()), a))) return
            }
        })()
      }),
      { abortConfirmation: u, confirmationPromise: l } = this.getTransactionConfirmationPromise({
        commitment: e,
        signature: o
      }),
      d = this.getCancellationPromise(n)
    let h
    try {
      const p = await Promise.race([d, l, c])
      if (p.__type === ma.PROCESSED) h = p.response
      else {
        let y
        for (;;) {
          const m = await this.getSignatureStatus(o)
          if (m == null) break
          if (m.context.slot < (p.slotInWhichNonceDidAdvance ?? r)) {
            await ll(400)
            continue
          }
          y = m
          break
        }
        if (y != null && y.value) {
          const m = e || 'finalized',
            { confirmationStatus: b } = y.value
          switch (m) {
            case 'processed':
            case 'recent':
              if (b !== 'processed' && b !== 'confirmed' && b !== 'finalized') throw new Ah(o)
              break
            case 'confirmed':
            case 'single':
            case 'singleGossip':
              if (b !== 'confirmed' && b !== 'finalized') throw new Ah(o)
              break
            case 'finalized':
            case 'max':
            case 'root':
              if (b !== 'finalized') throw new Ah(o)
              break
            default:
          }
          h = { context: y.context, value: { err: y.value.err } }
        } else throw new Ah(o)
      }
    } finally {
      ;(a = !0), u()
    }
    return h
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({ commitment: e, signature: n }) {
    let r
    const s = new Promise(c => {
        let u = this._confirmTransactionInitialTimeout || 6e4
        switch (e) {
          case 'processed':
          case 'recent':
          case 'single':
          case 'confirmed':
          case 'singleGossip': {
            u = this._confirmTransactionInitialTimeout || 3e4
            break
          }
        }
        r = setTimeout(() => c({ __type: ma.TIMED_OUT, timeoutMs: u }), u)
      }),
      { abortConfirmation: i, confirmationPromise: o } = this.getTransactionConfirmationPromise({
        commitment: e,
        signature: n
      })
    let a
    try {
      const c = await Promise.race([o, s])
      if (c.__type === ma.PROCESSED) a = c.response
      else throw new d5(n, c.timeoutMs / 1e3)
    } finally {
      clearTimeout(r), i()
    }
    return a
  }
  async getClusterNodes() {
    const e = await this._rpcRequest('getClusterNodes', []),
      n = Fe(e, Bt(He(Qhe)))
    if ('error' in n) throw new ot(n.error, 'failed to get cluster nodes')
    return n.result
  }
  async getVoteAccounts(e) {
    const n = this._buildArgs([], e),
      r = await this._rpcRequest('getVoteAccounts', n),
      s = Fe(r, Zhe)
    if ('error' in s) throw new ot(s.error, 'failed to get vote accounts')
    return s.result
  }
  async getSlot(e) {
    const { commitment: n, config: r } = bn(e),
      s = this._buildArgs([], n, void 0, r),
      i = await this._rpcRequest('getSlot', s),
      o = Fe(i, Bt(ae()))
    if ('error' in o) throw new ot(o.error, 'failed to get slot')
    return o.result
  }
  async getSlotLeader(e) {
    const { commitment: n, config: r } = bn(e),
      s = this._buildArgs([], n, void 0, r),
      i = await this._rpcRequest('getSlotLeader', s),
      o = Fe(i, Bt(De()))
    if ('error' in o) throw new ot(o.error, 'failed to get slot leader')
    return o.result
  }
  async getSlotLeaders(e, n) {
    const r = [e, n],
      s = await this._rpcRequest('getSlotLeaders', r),
      i = Fe(s, Bt(He(Mn)))
    if ('error' in i) throw new ot(i.error, 'failed to get slot leaders')
    return i.result
  }
  async getSignatureStatus(e, n) {
    const { context: r, value: s } = await this.getSignatureStatuses([e], n)
    Tn(s.length === 1)
    const i = s[0]
    return { context: r, value: i }
  }
  async getSignatureStatuses(e, n) {
    const r = [e]
    n && r.push(n)
    const s = await this._rpcRequest('getSignatureStatuses', r),
      i = Fe(s, Xhe)
    if ('error' in i) throw new ot(i.error, 'failed to get signature status')
    return i.result
  }
  async getTransactionCount(e) {
    const { commitment: n, config: r } = bn(e),
      s = this._buildArgs([], n, void 0, r),
      i = await this._rpcRequest('getTransactionCount', s),
      o = Fe(i, Bt(ae()))
    if ('error' in o) throw new ot(o.error, 'failed to get transaction count')
    return o.result
  }
  async getTotalSupply(e) {
    return (await this.getSupply({ commitment: e, excludeNonCirculatingAccountsList: !0 })).value
      .total
  }
  async getInflationGovernor(e) {
    const n = this._buildArgs([], e),
      r = await this._rpcRequest('getInflationGovernor', n),
      s = Fe(r, Ahe)
    if ('error' in s) throw new ot(s.error, 'failed to get inflation')
    return s.result
  }
  async getInflationReward(e, n, r) {
    const { commitment: s, config: i } = bn(r),
      o = this._buildArgs([e.map(u => u.toBase58())], s, void 0, {
        ...i,
        epoch: n ?? (i == null ? void 0 : i.epoch)
      }),
      a = await this._rpcRequest('getInflationReward', o),
      c = Fe(a, ahe)
    if ('error' in c) throw new ot(c.error, 'failed to get inflation reward')
    return c.result
  }
  async getInflationRate() {
    const e = await this._rpcRequest('getInflationRate', []),
      n = Fe(e, _he)
    if ('error' in n) throw new ot(n.error, 'failed to get inflation rate')
    return n.result
  }
  async getEpochInfo(e) {
    const { commitment: n, config: r } = bn(e),
      s = this._buildArgs([], n, void 0, r),
      i = await this._rpcRequest('getEpochInfo', s),
      o = Fe(i, She)
    if ('error' in o) throw new ot(o.error, 'failed to get epoch info')
    return o.result
  }
  async getEpochSchedule() {
    const e = await this._rpcRequest('getEpochSchedule', []),
      n = Fe(e, Ihe)
    if ('error' in n) throw new ot(n.error, 'failed to get epoch schedule')
    const r = n.result
    return new Zde(
      r.slotsPerEpoch,
      r.leaderScheduleSlotOffset,
      r.warmup,
      r.firstNormalEpoch,
      r.firstNormalSlot
    )
  }
  async getLeaderSchedule() {
    const e = await this._rpcRequest('getLeaderSchedule', []),
      n = Fe(e, xhe)
    if ('error' in n) throw new ot(n.error, 'failed to get leader schedule')
    return n.result
  }
  async getMinimumBalanceForRentExemption(e, n) {
    const r = this._buildArgs([e], n),
      s = await this._rpcRequest('getMinimumBalanceForRentExemption', r),
      i = Fe(s, efe)
    return 'error' in i
      ? (console.warn('Unable to fetch minimum balance for rent exemption'), 0)
      : i.result
  }
  async getRecentBlockhashAndContext(e) {
    const {
      context: n,
      value: { blockhash: r }
    } = await this.getLatestBlockhashAndContext(e)
    return {
      context: n,
      value: {
        blockhash: r,
        feeCalculator: {
          get lamportsPerSignature() {
            throw new Error(
              'The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.'
            )
          },
          toJSON() {
            return {}
          }
        }
      }
    }
  }
  async getRecentPerformanceSamples(e) {
    const n = await this._rpcRequest('getRecentPerformanceSamples', e ? [e] : []),
      r = Fe(n, ffe)
    if ('error' in r) throw new ot(r.error, 'failed to get recent performance samples')
    return r.result
  }
  async getFeeCalculatorForBlockhash(e, n) {
    const r = this._buildArgs([e], n),
      s = await this._rpcRequest('getFeeCalculatorForBlockhash', r),
      i = Fe(s, pfe)
    if ('error' in i) throw new ot(i.error, 'failed to get fee calculator')
    const { context: o, value: a } = i.result
    return { context: o, value: a !== null ? a.feeCalculator : null }
  }
  async getFeeForMessage(e, n) {
    const r = Ir(e.serialize()).toString('base64'),
      s = this._buildArgs([r], n),
      i = await this._rpcRequest('getFeeForMessage', s),
      o = Fe(i, qn(ze(ae())))
    if ('error' in o) throw new ot(o.error, 'failed to get fee for message')
    if (o.result === null) throw new Error('invalid blockhash')
    return o.result
  }
  async getRecentPrioritizationFees(e) {
    var o
    const n =
        (o = e == null ? void 0 : e.lockedWritableAccounts) == null
          ? void 0
          : o.map(a => a.toBase58()),
      r = n != null && n.length ? [n] : [],
      s = await this._rpcRequest('getRecentPrioritizationFees', r),
      i = Fe(s, Che)
    if ('error' in i) throw new ot(i.error, 'failed to get recent prioritization fees')
    return i.result
  }
  async getRecentBlockhash(e) {
    try {
      return (await this.getRecentBlockhashAndContext(e)).value
    } catch (n) {
      throw new Error('failed to get recent blockhash: ' + n)
    }
  }
  async getLatestBlockhash(e) {
    try {
      return (await this.getLatestBlockhashAndContext(e)).value
    } catch (n) {
      throw new Error('failed to get recent blockhash: ' + n)
    }
  }
  async getLatestBlockhashAndContext(e) {
    const { commitment: n, config: r } = bn(e),
      s = this._buildArgs([], n, void 0, r),
      i = await this._rpcRequest('getLatestBlockhash', s),
      o = Fe(i, lfe)
    if ('error' in o) throw new ot(o.error, 'failed to get latest blockhash')
    return o.result
  }
  async isBlockhashValid(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = this._buildArgs([e], r, void 0, s),
      o = await this._rpcRequest('isBlockhashValid', i),
      a = Fe(o, dfe)
    if ('error' in a)
      throw new ot(a.error, 'failed to determine if the blockhash `' + e + '`is valid')
    return a.result
  }
  async getVersion() {
    const e = await this._rpcRequest('getVersion', []),
      n = Fe(e, Bt(ghe))
    if ('error' in n) throw new ot(n.error, 'failed to get version')
    return n.result
  }
  async getGenesisHash() {
    const e = await this._rpcRequest('getGenesisHash', []),
      n = Fe(e, Bt(De()))
    if ('error' in n) throw new ot(n.error, 'failed to get genesis hash')
    return n.result
  }
  async getBlock(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = this._buildArgsAtLeastConfirmed([e], r, void 0, s),
      o = await this._rpcRequest('getBlock', i)
    try {
      switch (s == null ? void 0 : s.transactionDetails) {
        case 'accounts': {
          const a = Fe(o, ife)
          if ('error' in a) throw a.error
          return a.result
        }
        case 'none': {
          const a = Fe(o, sfe)
          if ('error' in a) throw a.error
          return a.result
        }
        default: {
          const a = Fe(o, rfe)
          if ('error' in a) throw a.error
          const { result: c } = a
          return c
            ? {
                ...c,
                transactions: c.transactions.map(({ transaction: u, meta: l, version: d }) => ({
                  meta: l,
                  transaction: { ...u, message: qb(d, u.message) },
                  version: d
                }))
              }
            : null
        }
      }
    } catch (a) {
      throw new ot(a, 'failed to get confirmed block')
    }
  }
  async getParsedBlock(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = this._buildArgsAtLeastConfirmed([e], r, 'jsonParsed', s),
      o = await this._rpcRequest('getBlock', i)
    try {
      switch (s == null ? void 0 : s.transactionDetails) {
        case 'accounts': {
          const a = Fe(o, afe)
          if ('error' in a) throw a.error
          return a.result
        }
        case 'none': {
          const a = Fe(o, cfe)
          if ('error' in a) throw a.error
          return a.result
        }
        default: {
          const a = Fe(o, ofe)
          if ('error' in a) throw a.error
          return a.result
        }
      }
    } catch (a) {
      throw new ot(a, 'failed to get block')
    }
  }
  async getBlockProduction(e) {
    let n, r
    if (typeof e == 'string') r = e
    else if (e) {
      const { commitment: a, ...c } = e
      ;(r = a), (n = c)
    }
    const s = this._buildArgs([], r, 'base64', n),
      i = await this._rpcRequest('getBlockProduction', s),
      o = Fe(i, whe)
    if ('error' in o) throw new ot(o.error, 'failed to get block production information')
    return o.result
  }
  async getTransaction(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = this._buildArgsAtLeastConfirmed([e], r, void 0, s),
      o = await this._rpcRequest('getTransaction', i),
      a = Fe(o, zb)
    if ('error' in a) throw new ot(a.error, 'failed to get transaction')
    const c = a.result
    return (
      c && {
        ...c,
        transaction: { ...c.transaction, message: qb(c.version, c.transaction.message) }
      }
    )
  }
  async getParsedTransaction(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = this._buildArgsAtLeastConfirmed([e], r, 'jsonParsed', s),
      o = await this._rpcRequest('getTransaction', i),
      a = Fe(o, Eg)
    if ('error' in a) throw new ot(a.error, 'failed to get transaction')
    return a.result
  }
  async getParsedTransactions(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = e.map(c => ({
        methodName: 'getTransaction',
        args: this._buildArgsAtLeastConfirmed([c], r, 'jsonParsed', s)
      }))
    return (await this._rpcBatchRequest(i)).map(c => {
      const u = Fe(c, Eg)
      if ('error' in u) throw new ot(u.error, 'failed to get transactions')
      return u.result
    })
  }
  async getTransactions(e, n) {
    const { commitment: r, config: s } = bn(n),
      i = e.map(c => ({
        methodName: 'getTransaction',
        args: this._buildArgsAtLeastConfirmed([c], r, void 0, s)
      }))
    return (await this._rpcBatchRequest(i)).map(c => {
      const u = Fe(c, zb)
      if ('error' in u) throw new ot(u.error, 'failed to get transactions')
      const l = u.result
      return (
        l && {
          ...l,
          transaction: { ...l.transaction, message: qb(l.version, l.transaction.message) }
        }
      )
    })
  }
  async getConfirmedBlock(e, n) {
    const r = this._buildArgsAtLeastConfirmed([e], n),
      s = await this._rpcRequest('getBlock', r),
      i = Fe(s, ufe)
    if ('error' in i) throw new ot(i.error, 'failed to get confirmed block')
    const o = i.result
    if (!o) throw new Error('Confirmed block ' + e + ' not found')
    const a = {
      ...o,
      transactions: o.transactions.map(({ transaction: c, meta: u }) => {
        const l = new ea(c.message)
        return { meta: u, transaction: { ...c, message: l } }
      })
    }
    return {
      ...a,
      transactions: a.transactions.map(({ transaction: c, meta: u }) => ({
        meta: u,
        transaction: Kr.populate(c.message, c.signatures)
      }))
    }
  }
  async getBlocks(e, n, r) {
    const s = this._buildArgsAtLeastConfirmed(n !== void 0 ? [e, n] : [e], r),
      i = await this._rpcRequest('getBlocks', s),
      o = Fe(i, Bt(He(ae())))
    if ('error' in o) throw new ot(o.error, 'failed to get blocks')
    return o.result
  }
  async getBlockSignatures(e, n) {
    const r = this._buildArgsAtLeastConfirmed([e], n, void 0, {
        transactionDetails: 'signatures',
        rewards: !1
      }),
      s = await this._rpcRequest('getBlock', r),
      i = Fe(s, NT)
    if ('error' in i) throw new ot(i.error, 'failed to get block')
    const o = i.result
    if (!o) throw new Error('Block ' + e + ' not found')
    return o
  }
  async getConfirmedBlockSignatures(e, n) {
    const r = this._buildArgsAtLeastConfirmed([e], n, void 0, {
        transactionDetails: 'signatures',
        rewards: !1
      }),
      s = await this._rpcRequest('getBlock', r),
      i = Fe(s, NT)
    if ('error' in i) throw new ot(i.error, 'failed to get confirmed block')
    const o = i.result
    if (!o) throw new Error('Confirmed block ' + e + ' not found')
    return o
  }
  async getConfirmedTransaction(e, n) {
    const r = this._buildArgsAtLeastConfirmed([e], n),
      s = await this._rpcRequest('getTransaction', r),
      i = Fe(s, zb)
    if ('error' in i) throw new ot(i.error, 'failed to get transaction')
    const o = i.result
    if (!o) return o
    const a = new ea(o.transaction.message),
      c = o.transaction.signatures
    return { ...o, transaction: Kr.populate(a, c) }
  }
  async getParsedConfirmedTransaction(e, n) {
    const r = this._buildArgsAtLeastConfirmed([e], n, 'jsonParsed'),
      s = await this._rpcRequest('getTransaction', r),
      i = Fe(s, Eg)
    if ('error' in i) throw new ot(i.error, 'failed to get confirmed transaction')
    return i.result
  }
  async getParsedConfirmedTransactions(e, n) {
    const r = e.map(o => ({
      methodName: 'getTransaction',
      args: this._buildArgsAtLeastConfirmed([o], n, 'jsonParsed')
    }))
    return (await this._rpcBatchRequest(r)).map(o => {
      const a = Fe(o, Eg)
      if ('error' in a) throw new ot(a.error, 'failed to get confirmed transactions')
      return a.result
    })
  }
  async getConfirmedSignaturesForAddress(e, n, r) {
    let s = {},
      i = await this.getFirstAvailableBlock()
    for (; !('until' in s) && (n--, !(n <= 0 || n < i)); )
      try {
        const c = await this.getConfirmedBlockSignatures(n, 'finalized')
        c.signatures.length > 0 && (s.until = c.signatures[c.signatures.length - 1].toString())
      } catch (c) {
        if (c instanceof Error && c.message.includes('skipped')) continue
        throw c
      }
    let o = await this.getSlot('finalized')
    for (; !('before' in s) && (r++, !(r > o)); )
      try {
        const c = await this.getConfirmedBlockSignatures(r)
        c.signatures.length > 0 && (s.before = c.signatures[c.signatures.length - 1].toString())
      } catch (c) {
        if (c instanceof Error && c.message.includes('skipped')) continue
        throw c
      }
    return (await this.getConfirmedSignaturesForAddress2(e, s)).map(c => c.signature)
  }
  async getConfirmedSignaturesForAddress2(e, n, r) {
    const s = this._buildArgsAtLeastConfirmed([e.toBase58()], r, void 0, n),
      i = await this._rpcRequest('getConfirmedSignaturesForAddress2', s),
      o = Fe(i, Lhe)
    if ('error' in o) throw new ot(o.error, 'failed to get confirmed signatures for address')
    return o.result
  }
  async getSignaturesForAddress(e, n, r) {
    const s = this._buildArgsAtLeastConfirmed([e.toBase58()], r, void 0, n),
      i = await this._rpcRequest('getSignaturesForAddress', s),
      o = Fe(i, $he)
    if ('error' in o) throw new ot(o.error, 'failed to get signatures for address')
    return o.result
  }
  async getAddressLookupTable(e, n) {
    const { context: r, value: s } = await this.getAccountInfoAndContext(e, n)
    let i = null
    return (
      s !== null && (i = new ST({ key: e, state: ST.deserialize(s.data) })),
      { context: r, value: i }
    )
  }
  async getNonceAndContext(e, n) {
    const { context: r, value: s } = await this.getAccountInfoAndContext(e, n)
    let i = null
    return s !== null && (i = i_.fromAccountData(s.data)), { context: r, value: i }
  }
  async getNonce(e, n) {
    return await this.getNonceAndContext(e, n)
      .then(r => r.value)
      .catch(r => {
        throw new Error('failed to get nonce for account ' + e.toBase58() + ': ' + r)
      })
  }
  async requestAirdrop(e, n) {
    const r = await this._rpcRequest('requestAirdrop', [e.toBase58(), n]),
      s = Fe(r, gfe)
    if ('error' in s) throw new ot(s.error, `airdrop to ${e.toBase58()} failed`)
    return s.result
  }
  async _blockhashWithExpiryBlockHeight(e) {
    if (!e) {
      for (; this._pollingBlockhash; ) await ll(100)
      const r = Date.now() - this._blockhashInfo.lastFetch >= rhe
      if (this._blockhashInfo.latestBlockhash !== null && !r)
        return this._blockhashInfo.latestBlockhash
    }
    return await this._pollNewBlockhash()
  }
  async _pollNewBlockhash() {
    this._pollingBlockhash = !0
    try {
      const e = Date.now(),
        n = this._blockhashInfo.latestBlockhash,
        r = n ? n.blockhash : null
      for (let s = 0; s < 50; s++) {
        const i = await this.getLatestBlockhash('finalized')
        if (r !== i.blockhash)
          return (
            (this._blockhashInfo = {
              latestBlockhash: i,
              lastFetch: Date.now(),
              transactionSignatures: [],
              simulatedSignatures: []
            }),
            i
          )
        await ll(Hde / 2)
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - e}ms`)
    } finally {
      this._pollingBlockhash = !1
    }
  }
  async getStakeMinimumDelegation(e) {
    const { commitment: n, config: r } = bn(e),
      s = this._buildArgs([], n, 'base64', r),
      i = await this._rpcRequest('getStakeMinimumDelegation', s),
      o = Fe(i, qn(ae()))
    if ('error' in o) throw new ot(o.error, 'failed to get stake minimum delegation')
    return o.result
  }
  async simulateTransaction(e, n, r) {
    if ('message' in e) {
      const m = e.serialize(),
        b = Nt.Buffer.from(m).toString('base64')
      if (Array.isArray(n) || r !== void 0) throw new Error('Invalid arguments')
      const I = n || {}
      ;(I.encoding = 'base64'),
        'commitment' in I || (I.commitment = this.commitment),
        n &&
          typeof n == 'object' &&
          'innerInstructions' in n &&
          (I.innerInstructions = n.innerInstructions)
      const x = [b, I],
        _ = await this._rpcRequest('simulateTransaction', x),
        R = Fe(_, xT)
      if ('error' in R) throw new Error('failed to simulate transaction: ' + R.error.message)
      return R.result
    }
    let s
    if (e instanceof Kr) {
      let y = e
      ;(s = new Kr()),
        (s.feePayer = y.feePayer),
        (s.instructions = e.instructions),
        (s.nonceInfo = y.nonceInfo),
        (s.signatures = y.signatures)
    } else (s = Kr.populate(e)), (s._message = s._json = void 0)
    if (n !== void 0 && !Array.isArray(n)) throw new Error('Invalid arguments')
    const i = n
    if (s.nonceInfo && i) s.sign(...i)
    else {
      let y = this._disableBlockhashCaching
      for (;;) {
        const m = await this._blockhashWithExpiryBlockHeight(y)
        if (
          ((s.lastValidBlockHeight = m.lastValidBlockHeight), (s.recentBlockhash = m.blockhash), !i)
        )
          break
        if ((s.sign(...i), !s.signature)) throw new Error('!signature')
        const b = s.signature.toString('base64')
        if (
          !this._blockhashInfo.simulatedSignatures.includes(b) &&
          !this._blockhashInfo.transactionSignatures.includes(b)
        ) {
          this._blockhashInfo.simulatedSignatures.push(b)
          break
        } else y = !0
      }
    }
    const o = s._compile(),
      a = o.serialize(),
      u = s._serialize(a).toString('base64'),
      l = { encoding: 'base64', commitment: this.commitment }
    if (r) {
      const y = (Array.isArray(r) ? r : o.nonProgramIds()).map(m => m.toBase58())
      l.accounts = { encoding: 'base64', addresses: y }
    }
    i && (l.sigVerify = !0),
      n &&
        typeof n == 'object' &&
        'innerInstructions' in n &&
        (l.innerInstructions = n.innerInstructions)
    const d = [u, l],
      h = await this._rpcRequest('simulateTransaction', d),
      p = Fe(h, xT)
    if ('error' in p) {
      let y
      if ('data' in p.error && ((y = p.error.data.logs), y && Array.isArray(y))) {
        const m = `
    `,
          b = m + y.join(m)
        console.error(p.error.message, b)
      }
      throw new vT({
        action: 'simulate',
        signature: '',
        transactionMessage: p.error.message,
        logs: y
      })
    }
    return p.result
  }
  async sendTransaction(e, n, r) {
    if ('version' in e) {
      if (n && Array.isArray(n)) throw new Error('Invalid arguments')
      const o = e.serialize()
      return await this.sendRawTransaction(o, n)
    }
    if (n === void 0 || !Array.isArray(n)) throw new Error('Invalid arguments')
    const s = n
    if (e.nonceInfo) e.sign(...s)
    else {
      let o = this._disableBlockhashCaching
      for (;;) {
        const a = await this._blockhashWithExpiryBlockHeight(o)
        if (
          ((e.lastValidBlockHeight = a.lastValidBlockHeight),
          (e.recentBlockhash = a.blockhash),
          e.sign(...s),
          !e.signature)
        )
          throw new Error('!signature')
        const c = e.signature.toString('base64')
        if (this._blockhashInfo.transactionSignatures.includes(c)) o = !0
        else {
          this._blockhashInfo.transactionSignatures.push(c)
          break
        }
      }
    }
    const i = e.serialize()
    return await this.sendRawTransaction(i, r)
  }
  async sendRawTransaction(e, n) {
    const r = Ir(e).toString('base64')
    return await this.sendEncodedTransaction(r, n)
  }
  async sendEncodedTransaction(e, n) {
    const r = { encoding: 'base64' },
      s = n && n.skipPreflight,
      i = s === !0 ? 'processed' : (n && n.preflightCommitment) || this.commitment
    n && n.maxRetries != null && (r.maxRetries = n.maxRetries),
      n && n.minContextSlot != null && (r.minContextSlot = n.minContextSlot),
      s && (r.skipPreflight = s),
      i && (r.preflightCommitment = i)
    const o = [e, r],
      a = await this._rpcRequest('sendTransaction', o),
      c = Fe(a, mfe)
    if ('error' in c) {
      let u
      throw (
        ('data' in c.error && (u = c.error.data.logs),
        new vT({
          action: s ? 'send' : 'simulate',
          signature: '',
          transactionMessage: c.error.message,
          logs: u
        }))
      )
    }
    return c.result
  }
  _wsOnOpen() {
    ;(this._rpcWebSocketConnected = !0),
      (this._rpcWebSocketHeartbeat = setInterval(() => {
        ;(async () => {
          try {
            await this._rpcWebSocket.notify('ping')
          } catch {}
        })()
      }, 5e3)),
      this._updateSubscriptions()
  }
  _wsOnError(e) {
    ;(this._rpcWebSocketConnected = !1), console.error('ws error:', e.message)
  }
  _wsOnClose(e) {
    if (
      ((this._rpcWebSocketConnected = !1),
      (this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER),
      this._rpcWebSocketIdleTimeout &&
        (clearTimeout(this._rpcWebSocketIdleTimeout), (this._rpcWebSocketIdleTimeout = null)),
      this._rpcWebSocketHeartbeat &&
        (clearInterval(this._rpcWebSocketHeartbeat), (this._rpcWebSocketHeartbeat = null)),
      e === 1e3)
    ) {
      this._updateSubscriptions()
      return
    }
    ;(this._subscriptionCallbacksByServerSubscriptionId = {}),
      Object.entries(this._subscriptionsByHash).forEach(([n, r]) => {
        this._setSubscription(n, { ...r, state: 'pending' })
      })
  }
  _setSubscription(e, n) {
    var s
    const r = (s = this._subscriptionsByHash[e]) == null ? void 0 : s.state
    if (((this._subscriptionsByHash[e] = n), r !== n.state)) {
      const i = this._subscriptionStateChangeCallbacksByHash[e]
      i &&
        i.forEach(o => {
          try {
            o(n.state)
          } catch {}
        })
    }
  }
  _onSubscriptionStateChange(e, n) {
    var i
    const r = this._subscriptionHashByClientSubscriptionId[e]
    if (r == null) return () => {}
    const s = (i = this._subscriptionStateChangeCallbacksByHash)[r] || (i[r] = new Set())
    return (
      s.add(n),
      () => {
        s.delete(n), s.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[r]
      }
    )
  }
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      this._rpcWebSocketConnected &&
        ((this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null
          try {
            this._rpcWebSocket.close()
          } catch (r) {
            r instanceof Error && console.log(`Error when closing socket connection: ${r.message}`)
          }
        }, 500)))
      return
    }
    if (
      (this._rpcWebSocketIdleTimeout !== null &&
        (clearTimeout(this._rpcWebSocketIdleTimeout),
        (this._rpcWebSocketIdleTimeout = null),
        (this._rpcWebSocketConnected = !0)),
      !this._rpcWebSocketConnected)
    ) {
      this._rpcWebSocket.connect()
      return
    }
    const e = this._rpcWebSocketGeneration,
      n = () => e === this._rpcWebSocketGeneration
    await Promise.all(
      Object.keys(this._subscriptionsByHash).map(async r => {
        const s = this._subscriptionsByHash[r]
        if (s !== void 0)
          switch (s.state) {
            case 'pending':
            case 'unsubscribed':
              if (s.callbacks.size === 0) {
                delete this._subscriptionsByHash[r],
                  s.state === 'unsubscribed' &&
                    delete this._subscriptionCallbacksByServerSubscriptionId[
                      s.serverSubscriptionId
                    ],
                  await this._updateSubscriptions()
                return
              }
              await (async () => {
                const { args: i, method: o } = s
                try {
                  this._setSubscription(r, { ...s, state: 'subscribing' })
                  const a = await this._rpcWebSocket.call(o, i)
                  this._setSubscription(r, { ...s, serverSubscriptionId: a, state: 'subscribed' }),
                    (this._subscriptionCallbacksByServerSubscriptionId[a] = s.callbacks),
                    await this._updateSubscriptions()
                } catch (a) {
                  if (
                    (console.error(
                      `Received ${a instanceof Error ? '' : 'JSON-RPC '}error calling \`${o}\``,
                      { args: i, error: a }
                    ),
                    !n())
                  )
                    return
                  this._setSubscription(r, { ...s, state: 'pending' }),
                    await this._updateSubscriptions()
                }
              })()
              break
            case 'subscribed':
              s.callbacks.size === 0 &&
                (await (async () => {
                  const { serverSubscriptionId: i, unsubscribeMethod: o } = s
                  if (this._subscriptionsAutoDisposedByRpc.has(i))
                    this._subscriptionsAutoDisposedByRpc.delete(i)
                  else {
                    this._setSubscription(r, { ...s, state: 'unsubscribing' }),
                      this._setSubscription(r, { ...s, state: 'unsubscribing' })
                    try {
                      await this._rpcWebSocket.call(o, [i])
                    } catch (a) {
                      if ((a instanceof Error && console.error(`${o} error:`, a.message), !n()))
                        return
                      this._setSubscription(r, { ...s, state: 'subscribed' }),
                        await this._updateSubscriptions()
                      return
                    }
                  }
                  this._setSubscription(r, { ...s, state: 'unsubscribed' }),
                    await this._updateSubscriptions()
                })())
              break
          }
      })
    )
  }
  _handleServerNotification(e, n) {
    const r = this._subscriptionCallbacksByServerSubscriptionId[e]
    r !== void 0 &&
      r.forEach(s => {
        try {
          s(...n)
        } catch (i) {
          console.error(i)
        }
      })
  }
  _wsOnAccountNotification(e) {
    const { result: n, subscription: r } = Fe(e, Fhe)
    this._handleServerNotification(r, [n.value, n.context])
  }
  _makeSubscription(e, n) {
    const r = this._nextClientSubscriptionId++,
      s = _T([e.method, n]),
      i = this._subscriptionsByHash[s]
    return (
      i === void 0
        ? (this._subscriptionsByHash[s] = {
            ...e,
            args: n,
            callbacks: new Set([e.callback]),
            state: 'pending'
          })
        : i.callbacks.add(e.callback),
      (this._subscriptionHashByClientSubscriptionId[r] = s),
      (this._subscriptionDisposeFunctionsByClientSubscriptionId[r] = async () => {
        delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],
          delete this._subscriptionHashByClientSubscriptionId[r]
        const o = this._subscriptionsByHash[s]
        Tn(
          o !== void 0,
          `Could not find a \`Subscription\` when tearing down client subscription #${r}`
        ),
          o.callbacks.delete(e.callback),
          await this._updateSubscriptions()
      }),
      this._updateSubscriptions(),
      r
    )
  }
  onAccountChange(e, n, r) {
    const { commitment: s, config: i } = bn(r),
      o = this._buildArgs([e.toBase58()], s || this._commitment || 'finalized', 'base64', i)
    return this._makeSubscription(
      { callback: n, method: 'accountSubscribe', unsubscribeMethod: 'accountUnsubscribe' },
      o
    )
  }
  async removeAccountChangeListener(e) {
    await this._unsubscribeClientSubscription(e, 'account change')
  }
  _wsOnProgramAccountNotification(e) {
    const { result: n, subscription: r } = Fe(e, Hhe)
    this._handleServerNotification(r, [
      { accountId: n.value.pubkey, accountInfo: n.value.account },
      n.context
    ])
  }
  onProgramAccountChange(e, n, r, s) {
    const { commitment: i, config: o } = bn(r),
      a = this._buildArgs(
        [e.toBase58()],
        i || this._commitment || 'finalized',
        'base64',
        o || (s ? { filters: IT(s) } : void 0)
      )
    return this._makeSubscription(
      { callback: n, method: 'programSubscribe', unsubscribeMethod: 'programUnsubscribe' },
      a
    )
  }
  async removeProgramAccountChangeListener(e) {
    await this._unsubscribeClientSubscription(e, 'program account change')
  }
  onLogs(e, n, r) {
    const s = this._buildArgs(
      [typeof e == 'object' ? { mentions: [e.toString()] } : e],
      r || this._commitment || 'finalized'
    )
    return this._makeSubscription(
      { callback: n, method: 'logsSubscribe', unsubscribeMethod: 'logsUnsubscribe' },
      s
    )
  }
  async removeOnLogsListener(e) {
    await this._unsubscribeClientSubscription(e, 'logs')
  }
  _wsOnLogsNotification(e) {
    const { result: n, subscription: r } = Fe(e, wfe)
    this._handleServerNotification(r, [n.value, n.context])
  }
  _wsOnSlotNotification(e) {
    const { result: n, subscription: r } = Fe(e, zhe)
    this._handleServerNotification(r, [n])
  }
  onSlotChange(e) {
    return this._makeSubscription(
      { callback: e, method: 'slotSubscribe', unsubscribeMethod: 'slotUnsubscribe' },
      []
    )
  }
  async removeSlotChangeListener(e) {
    await this._unsubscribeClientSubscription(e, 'slot change')
  }
  _wsOnSlotUpdatesNotification(e) {
    const { result: n, subscription: r } = Fe(e, Khe)
    this._handleServerNotification(r, [n])
  }
  onSlotUpdate(e) {
    return this._makeSubscription(
      {
        callback: e,
        method: 'slotsUpdatesSubscribe',
        unsubscribeMethod: 'slotsUpdatesUnsubscribe'
      },
      []
    )
  }
  async removeSlotUpdateListener(e) {
    await this._unsubscribeClientSubscription(e, 'slot update')
  }
  async _unsubscribeClientSubscription(e, n) {
    const r = this._subscriptionDisposeFunctionsByClientSubscriptionId[e]
    r
      ? await r()
      : console.warn(
          `Ignored unsubscribe request because an active subscription with id \`${e}\` for '${n}' events could not be found.`
        )
  }
  _buildArgs(e, n, r, s) {
    const i = n || this._commitment
    if (i || r || s) {
      let o = {}
      r && (o.encoding = r), i && (o.commitment = i), s && (o = Object.assign(o, s)), e.push(o)
    }
    return e
  }
  _buildArgsAtLeastConfirmed(e, n, r, s) {
    const i = n || this._commitment
    if (i && !['confirmed', 'finalized'].includes(i))
      throw new Error(
        'Using Connection with default commitment: `' +
          this._commitment +
          '`, but method requires at least `confirmed`'
      )
    return this._buildArgs(e, n, r, s)
  }
  _wsOnSignatureNotification(e) {
    const { result: n, subscription: r } = Fe(e, Vhe)
    n.value !== 'receivedSignature' && this._subscriptionsAutoDisposedByRpc.add(r),
      this._handleServerNotification(
        r,
        n.value === 'receivedSignature'
          ? [{ type: 'received' }, n.context]
          : [{ type: 'status', result: n.value }, n.context]
      )
  }
  onSignature(e, n, r) {
    const s = this._buildArgs([e], r || this._commitment || 'finalized'),
      i = this._makeSubscription(
        {
          callback: (o, a) => {
            if (o.type === 'status') {
              n(o.result, a)
              try {
                this.removeSignatureListener(i)
              } catch {}
            }
          },
          method: 'signatureSubscribe',
          unsubscribeMethod: 'signatureUnsubscribe'
        },
        s
      )
    return i
  }
  onSignatureWithOptions(e, n, r) {
    const { commitment: s, ...i } = {
        ...r,
        commitment: (r && r.commitment) || this._commitment || 'finalized'
      },
      o = this._buildArgs([e], s, void 0, i),
      a = this._makeSubscription(
        {
          callback: (c, u) => {
            n(c, u)
            try {
              this.removeSignatureListener(a)
            } catch {}
          },
          method: 'signatureSubscribe',
          unsubscribeMethod: 'signatureUnsubscribe'
        },
        o
      )
    return a
  }
  async removeSignatureListener(e) {
    await this._unsubscribeClientSubscription(e, 'signature result')
  }
  _wsOnRootNotification(e) {
    const { result: n, subscription: r } = Fe(e, Ghe)
    this._handleServerNotification(r, [n])
  }
  onRootChange(e) {
    return this._makeSubscription(
      { callback: e, method: 'rootSubscribe', unsubscribeMethod: 'rootUnsubscribe' },
      []
    )
  }
  async removeRootChangeListener(e) {
    await this._unsubscribeClientSubscription(e, 'root change')
  }
}
Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: re.struct([re.u32('instruction'), fd('recentSlot'), re.u8('bumpSeed')])
  },
  FreezeLookupTable: { index: 1, layout: re.struct([re.u32('instruction')]) },
  ExtendLookupTable: {
    index: 2,
    layout: re.struct([
      re.u32('instruction'),
      fd(),
      re.seq(Lt(), re.offset(re.u32(), -8), 'addresses')
    ])
  },
  DeactivateLookupTable: { index: 3, layout: re.struct([re.u32('instruction')]) },
  CloseLookupTable: { index: 4, layout: re.struct([re.u32('instruction')]) }
})
new it('AddressLookupTab1e1111111111111111111111111')
const Ag = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: re.struct([re.u8('instruction'), re.u32('units'), re.u32('additionalFee')])
  },
  RequestHeapFrame: { index: 1, layout: re.struct([re.u8('instruction'), re.u32('bytes')]) },
  SetComputeUnitLimit: { index: 2, layout: re.struct([re.u8('instruction'), re.u32('units')]) },
  SetComputeUnitPrice: { index: 3, layout: re.struct([re.u8('instruction'), fd('microLamports')]) }
})
class Hv {
  constructor() {}
  static requestUnits(e) {
    const n = Ag.RequestUnits,
      r = Hr(n, e)
    return new rs({ keys: [], programId: this.programId, data: r })
  }
  static requestHeapFrame(e) {
    const n = Ag.RequestHeapFrame,
      r = Hr(n, e)
    return new rs({ keys: [], programId: this.programId, data: r })
  }
  static setComputeUnitLimit(e) {
    const n = Ag.SetComputeUnitLimit,
      r = Hr(n, e)
    return new rs({ keys: [], programId: this.programId, data: r })
  }
  static setComputeUnitPrice(e) {
    const n = Ag.SetComputeUnitPrice,
      r = Hr(n, { microLamports: BigInt(e.microLamports) })
    return new rs({ keys: [], programId: this.programId, data: r })
  }
}
Hv.programId = new it('ComputeBudget111111111111111111111111111111')
re.struct([
  re.u8('numSignatures'),
  re.u8('padding'),
  re.u16('signatureOffset'),
  re.u16('signatureInstructionIndex'),
  re.u16('publicKeyOffset'),
  re.u16('publicKeyInstructionIndex'),
  re.u16('messageDataOffset'),
  re.u16('messageDataSize'),
  re.u16('messageInstructionIndex')
])
new it('Ed25519SigVerify111111111111111111111111111')
I0.utils.isValidPrivateKey
I0.getPublicKey
re.struct([
  re.u8('numSignatures'),
  re.u16('signatureOffset'),
  re.u8('signatureInstructionIndex'),
  re.u16('ethAddressOffset'),
  re.u8('ethAddressInstructionIndex'),
  re.u16('messageDataOffset'),
  re.u16('messageDataSize'),
  re.u8('messageInstructionIndex'),
  re.blob(20, 'ethAddress'),
  re.blob(64, 'signature'),
  re.u8('recoveryId')
])
new it('KeccakSecp256k11111111111111111111111111111')
var I5
new it('StakeConfig11111111111111111111111111111111')
class x5 {
  constructor(e, n, r) {
    ;(this.unixTimestamp = void 0),
      (this.epoch = void 0),
      (this.custodian = void 0),
      (this.unixTimestamp = e),
      (this.epoch = n),
      (this.custodian = r)
  }
}
I5 = x5
x5.default = new I5(0, 0, it.default)
Object.freeze({
  Initialize: { index: 0, layout: re.struct([re.u32('instruction'), Bde(), Dde()]) },
  Authorize: {
    index: 1,
    layout: re.struct([
      re.u32('instruction'),
      Lt('newAuthorized'),
      re.u32('stakeAuthorizationType')
    ])
  },
  Delegate: { index: 2, layout: re.struct([re.u32('instruction')]) },
  Split: { index: 3, layout: re.struct([re.u32('instruction'), re.ns64('lamports')]) },
  Withdraw: { index: 4, layout: re.struct([re.u32('instruction'), re.ns64('lamports')]) },
  Deactivate: { index: 5, layout: re.struct([re.u32('instruction')]) },
  Merge: { index: 7, layout: re.struct([re.u32('instruction')]) },
  AuthorizeWithSeed: {
    index: 8,
    layout: re.struct([
      re.u32('instruction'),
      Lt('newAuthorized'),
      re.u32('stakeAuthorizationType'),
      vl('authoritySeed'),
      Lt('authorityOwner')
    ])
  }
})
new it('Stake11111111111111111111111111111111111111')
Object.freeze({
  InitializeAccount: { index: 0, layout: re.struct([re.u32('instruction'), Mde()]) },
  Authorize: {
    index: 1,
    layout: re.struct([re.u32('instruction'), Lt('newAuthorized'), re.u32('voteAuthorizationType')])
  },
  Withdraw: { index: 3, layout: re.struct([re.u32('instruction'), re.ns64('lamports')]) },
  UpdateValidatorIdentity: { index: 4, layout: re.struct([re.u32('instruction')]) },
  AuthorizeWithSeed: { index: 10, layout: re.struct([re.u32('instruction'), Ude()]) }
})
new it('Vote111111111111111111111111111111111111111')
new it('Va1idator1nfo111111111111111111111111111111')
Ce({
  name: De(),
  website: lt(De()),
  details: lt(De()),
  iconUrl: lt(De()),
  keybaseUsername: lt(De())
})
new it('Vote111111111111111111111111111111111111111')
re.struct([
  Lt('nodePubkey'),
  Lt('authorizedWithdrawer'),
  re.u8('commission'),
  re.nu64(),
  re.seq(
    re.struct([re.nu64('slot'), re.u32('confirmationCount')]),
    re.offset(re.u32(), -8),
    'votes'
  ),
  re.u8('rootSlotValid'),
  re.nu64('rootSlot'),
  re.nu64(),
  re.seq(
    re.struct([re.nu64('epoch'), Lt('authorizedVoter')]),
    re.offset(re.u32(), -8),
    'authorizedVoters'
  ),
  re.struct(
    [
      re.seq(
        re.struct([
          Lt('authorizedPubkey'),
          re.nu64('epochOfLastAuthorizedSwitch'),
          re.nu64('targetEpoch')
        ]),
        32,
        'buf'
      ),
      re.nu64('idx'),
      re.u8('isEmpty')
    ],
    'priorVoters'
  ),
  re.nu64(),
  re.seq(
    re.struct([re.nu64('epoch'), re.nu64('credits'), re.nu64('prevCredits')]),
    re.offset(re.u32(), -8),
    'epochCredits'
  ),
  re.struct([re.nu64('slot'), re.nu64('timestamp')], 'lastTimestamp')
])
const vfe = 1e9,
  bi = {
    UNIVERSAL_PROVIDER_RELAY_URL: 'wss://relay.walletconnect.org',
    HASH_PREFIX: 'SPL Name Service',
    ROOT_DOMAIN_ACCOUNT: new it('58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx'),
    NAME_PROGRAM_ID: new it('namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX'),
    REVERSE_LOOKUP_CLASS: new it('33m47vH6Eav6jr5Ry86XjhRft2jRBLDnDgPSHoquXi2Z'),
    DEFAULT_CHAIN: {
      id: '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
      caipNetworkId: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
      name: 'Solana',
      chainNamespace: Ae.CHAIN.SOLANA,
      nativeCurrency: { name: 'Solana', decimals: 9, symbol: 'SOL' },
      blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
      rpcUrls: { default: { http: [`${Ae.BLOCKCHAIN_API_RPC_URL}/v1`] } }
    },
    CHAIN_IDS: {
      Mainnet: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
      Devnet: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
      Testnet: 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
      Deprecated_Mainnet: 'solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ',
      Deprecated_Devnet: 'solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K'
    },
    LAMPORTS_PER_SOL: 1e9
  }
class py extends Error {
  constructor(e, n) {
    super(e), (this.error = n)
  }
}
class Efe extends py {
  constructor() {
    super(...arguments), (this.name = 'WalletAccountError')
  }
}
class Afe extends py {
  constructor() {
    super(...arguments), (this.name = 'WalletSendTransactionError')
  }
}
class PT extends py {
  constructor() {
    super(...arguments), (this.name = 'WalletSignTransactionError')
  }
}
class _fe extends py {
  constructor() {
    super(...arguments), (this.name = 'WalletSignMessageError')
  }
}
function nu(t) {
  return 'version' in t
}
const T5 = 'solana:signAndSendTransaction',
  Cfe = 'solana:signMessage',
  qv = 'solana:signTransaction',
  N5 = 'standard:connect',
  Sfe = 'standard:disconnect',
  P5 = 'standard:events'
function Ife(t) {
  return N5 in t.features && P5 in t.features && (T5 in t.features || qv in t.features)
}
function xfe(t) {
  if (typeof t == 'string') return `solana:${t}`
}
class gy {
  constructor() {
    this.listeners = {
      accountsChanged: [],
      chainChanged: [],
      connect: [],
      disconnect: [],
      pendingTransaction: [],
      auth_rpcRequest: [],
      auth_rpcSuccess: [],
      auth_rpcError: []
    }
  }
  on(e, n) {
    this.listeners[e].push(n)
  }
  removeListener(e, n) {
    this.listeners[e] = this.listeners[e].filter(r => r !== n)
  }
  emit(e, n) {
    this.listeners[e].forEach(r => r(n))
  }
}
class Tfe extends gy {
  constructor(e) {
    super(),
      (this.id = Ae.CONNECTOR_ID.AUTH),
      (this.name = Ae.CONNECTOR_NAMES.AUTH),
      (this.type = 'AUTH'),
      (this.chain = Ae.CHAIN.SOLANA),
      (this.provider = e.w3mFrameProvider),
      (this.requestedChains = e.chains),
      (this.getActiveChain = e.getActiveChain)
  }
  get publicKey() {
    var n
    const e = (n = this.provider.user) == null ? void 0 : n.address
    return e ? new it(e) : void 0
  }
  get chains() {
    const e = this.provider.getAvailableChainIds()
    return this.requestedChains.filter(n => e.includes(n.caipNetworkId))
  }
  async connect(e = {}) {
    var s, i
    const n = e.chainId || ((s = this.getActiveChain()) == null ? void 0 : s.id),
      r = (i = Ye.state.preferredAccountTypes) == null ? void 0 : i.solana
    if (
      (await this.provider.connect({ chainId: xfe(n), preferredAccountType: r }), !this.publicKey)
    )
      throw new Error('Failed to connect to the wallet')
    return this.emit('connect', this.publicKey), this.publicKey.toBase58()
  }
  async disconnect() {
    await this.provider.disconnect(), this.emit('disconnect', void 0)
  }
  async signMessage(e) {
    if (!this.publicKey) throw new Error('Wallet not connected')
    const n = await this.provider.request({
      method: 'solana_signMessage',
      params: { message: vs.encode(e), pubkey: this.publicKey.toBase58() }
    })
    return vs.decode(n.signature)
  }
  async signTransaction(e) {
    const n = await this.provider.request({
        method: 'solana_signTransaction',
        params: { transaction: this.serializeTransaction(e) }
      }),
      r = vs.decode(n.transaction)
    return nu(e) ? ic.deserialize(r) : Kr.from(r)
  }
  async signAndSendTransaction(e, n) {
    const r = this.serializeTransaction(e)
    return (
      await this.provider.request({
        method: 'solana_signAndSendTransaction',
        params: { transaction: r, options: n }
      })
    ).signature
  }
  async sendTransaction(e, n, r) {
    const s = await this.signTransaction(e)
    return await n.sendRawTransaction(s.serialize(), r)
  }
  async signAllTransactions(e) {
    return (
      await this.provider.request({
        method: 'solana_signAllTransactions',
        params: { transactions: e.map(r => this.serializeTransaction(r)) }
      })
    ).transactions.map((r, s) => {
      const i = e[s]
      if (!i) throw new Error('Invalid solana_signAllTransactions response')
      const o = vs.decode(r)
      return nu(i) ? ic.deserialize(o) : Kr.from(o)
    })
  }
  async request(e) {
    return this.provider.request({ method: e.method, params: e.params })
  }
  async getAccounts() {
    return this.publicKey
      ? Promise.resolve([
          { namespace: this.chain, address: this.publicKey.toBase58(), type: 'eoa' }
        ])
      : Promise.resolve([])
  }
  serializeTransaction(e) {
    return vs.encode(new Uint8Array(e.serialize({ verifySignatures: !1 })))
  }
}
class Nfe extends gy {
  constructor(e) {
    super(),
      (this.name = 'Coinbase Wallet'),
      (this.id = Vr.ConnectorExplorerIds[Ae.CONNECTOR_ID.COINBASE_SDK]),
      (this.explorerId = Vr.ConnectorExplorerIds[Ae.CONNECTOR_ID.COINBASE_SDK]),
      (this.type = 'ANNOUNCED'),
      (this.imageUrl =
        'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSI1MTIiIGN5PSI1MTIiIHI9IjUxMiIgZmlsbD0iIzAwNTJGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1MiA1MTJDMTUyIDcxMC44MjMgMzEzLjE3NyA4NzIgNTEyIDg3MkM3MTAuODIzIDg3MiA4NzIgNzEwLjgyMyA4NzIgNTEyQzg3MiAzMTMuMTc3IDcxMC44MjMgMTUyIDUxMiAxNTJDMzEzLjE3NyAxNTIgMTUyIDMxMy4xNzcgMTUyIDUxMlpNNDIwIDM5NkM0MDYuNzQ1IDM5NiAzOTYgNDA2Ljc0NSAzOTYgNDIwVjYwNEMzOTYgNjE3LjI1NSA0MDYuNzQ1IDYyOCA0MjAgNjI4SDYwNEM2MTcuMjU1IDYyOCA2MjggNjE3LjI1NSA2MjggNjA0VjQyMEM2MjggNDA2Ljc0NSA2MTcuMjU1IDM5NiA2MDQgMzk2SDQyMFoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo='),
      (this.chain = Ae.CHAIN.SOLANA),
      (this.provider = this),
      (this.coinbase = e.provider),
      (this.requestedChains = e.chains)
  }
  get chains() {
    return this.requestedChains.filter(e => e.id === jf.id)
  }
  get publicKey() {
    return this.coinbase.publicKey
  }
  get imageId() {
    return Vr.ConnectorImageIds[Ae.CONNECTOR_ID.COINBASE]
  }
  async connect() {
    try {
      await this.coinbase.connect()
      const e = this.getAccount(!0)
      return (
        this.coinbase.emit('connect', this.coinbase.publicKey),
        this.emit('connect', e),
        e.toBase58()
      )
    } catch (e) {
      throw (this.coinbase.emit('error', e), e)
    }
  }
  async disconnect() {
    await this.coinbase.disconnect(),
      this.coinbase.emit('disconnect', void 0),
      this.emit('disconnect', void 0)
  }
  async signMessage(e) {
    return (await this.coinbase.signMessage(e)).signature
  }
  async signTransaction(e) {
    return this.coinbase.signTransaction(e)
  }
  async signAndSendTransaction(e, n) {
    return (await this.coinbase.signAndSendTransaction(e, n)).signature
  }
  async sendTransaction(e, n, r) {
    const s = await this.signTransaction(e)
    return await n.sendRawTransaction(s.serialize(), r)
  }
  async signAllTransactions(e) {
    return await this.coinbase.signAllTransactions(e)
  }
  async request(e) {
    return Promise.reject(new Error('The "request" method is not supported on Coinbase Wallet'))
  }
  async getAccounts() {
    const e = this.getAccount()
    return e
      ? Promise.resolve([{ namespace: this.chain, address: e.toBase58(), type: 'eoa' }])
      : Promise.resolve([])
  }
  getAccount(e) {
    const n = this.coinbase.publicKey
    if (e && !n) throw new Error('Not connected')
    return n
  }
}
class RT extends Error {
  constructor(e) {
    super(`The wallet does not support the "${e}" feature`)
  }
}
class kT extends Error {
  constructor(e) {
    super(`The method "${e}" is not supported by the wallet`)
  }
}
class OT extends xp {
  constructor({ provider: e, chains: n, getActiveChain: r }) {
    super({ caipNetworks: n, namespace: 'solana', provider: e }),
      (this.eventEmitter = new gy()),
      (this.emit = this.eventEmitter.emit.bind(this.eventEmitter)),
      (this.on = this.eventEmitter.on.bind(this.eventEmitter)),
      (this.removeListener = this.eventEmitter.removeListener.bind(this.eventEmitter)),
      (this.getActiveChain = r)
  }
  get session() {
    return this.provider.session
  }
  get chains() {
    return this.sessionChains
      .map(e => {
        let n = e
        return (
          n === bi.CHAIN_IDS.Deprecated_Mainnet
            ? (n = bi.CHAIN_IDS.Mainnet)
            : n === bi.CHAIN_IDS.Deprecated_Devnet && (n = bi.CHAIN_IDS.Devnet),
          this.caipNetworks.find(r => r.caipNetworkId === n)
        )
      })
      .filter(Boolean)
  }
  get publicKey() {
    const e = this.getAccount(!1)
    if (e) return new it(e.publicKey)
  }
  async connect() {
    await super.connectWalletConnect()
    const e = this.getAccount(!0)
    return this.emit('connect', new it(e.publicKey)), e.address
  }
  async disconnect() {
    await super.disconnect(), this.emit('disconnect', void 0)
  }
  async signMessage(e) {
    this.checkIfMethodIsSupported('solana_signMessage')
    const n = await this.internalRequest('solana_signMessage', {
      message: vs.encode(e),
      pubkey: this.getAccount(!0).address
    })
    return vs.decode(n.signature)
  }
  async signTransaction(e) {
    this.checkIfMethodIsSupported('solana_signTransaction')
    const n = this.serializeTransaction(e),
      r = await this.internalRequest('solana_signTransaction', {
        transaction: n,
        pubkey: this.getAccount(!0).address,
        ...this.getRawRPCParams(e)
      })
    if ('signature' in r) {
      const i = vs.decode(r.signature)
      return e.addSignature(new it(this.getAccount(!0).publicKey), Buffer.from(i)), e
    }
    const s = Buffer.from(r.transaction, 'base64')
    return nu(e) ? ic.deserialize(new Uint8Array(s)) : Kr.from(s)
  }
  async signAndSendTransaction(e, n) {
    this.checkIfMethodIsSupported('solana_signAndSendTransaction')
    const r = this.serializeTransaction(e),
      s = await this.internalRequest('solana_signAndSendTransaction', {
        transaction: r,
        pubkey: this.getAccount(!0).address,
        sendOptions: n
      })
    return this.emit('pendingTransaction', void 0), s.signature
  }
  async sendTransaction(e, n, r) {
    const s = await this.signTransaction(e),
      i = await n.sendRawTransaction(s.serialize(), r)
    return this.emit('pendingTransaction', void 0), i
  }
  async signAllTransactions(e) {
    try {
      return (
        this.checkIfMethodIsSupported('solana_signAllTransactions'),
        (
          await this.internalRequest('solana_signAllTransactions', {
            transactions: e.map(r => this.serializeTransaction(r))
          })
        ).transactions.map((r, s) => {
          const i = e[s]
          if (!i) throw new Error('Invalid transactions response')
          const o = Buffer.from(r, 'base64')
          return nu(i)
            ? ic.deserialize(new Uint8Array(o))
            : (this.emit('pendingTransaction', void 0), Kr.from(o))
        })
      )
    } catch (n) {
      if (n instanceof kT) {
        const r = []
        for (const s of e) r.push(await this.signTransaction(s))
        return r
      }
      throw n
    }
  }
  request(e) {
    return this.internalRequest(e.method, e.params)
  }
  async getAccounts() {
    var n, r
    const e =
      ((r = (n = this.session) == null ? void 0 : n.namespaces.solana) == null
        ? void 0
        : r.accounts) || []
    return Promise.resolve(
      e.map(s => ({ namespace: this.chain, address: Bo.parseCaipAddress(s).address, type: 'eoa' }))
    )
  }
  internalRequest(e, n) {
    var i
    const r = this.chains.find(o => {
      var a
      return ((a = this.getActiveChain()) == null ? void 0 : a.id) === o.id
    })
    let s = r == null ? void 0 : r.caipNetworkId
    switch (s) {
      case bi.CHAIN_IDS.Mainnet:
        this.sessionChains.includes(bi.CHAIN_IDS.Mainnet) || (s = bi.CHAIN_IDS.Deprecated_Mainnet)
        break
      case bi.CHAIN_IDS.Devnet:
        this.sessionChains.includes(bi.CHAIN_IDS.Devnet) || (s = bi.CHAIN_IDS.Deprecated_Devnet)
        break
    }
    return (i = this.provider) == null ? void 0 : i.request({ method: e, params: n }, s)
  }
  get sessionChains() {
    var e
    return Od.getChainsFromNamespaces((e = this.session) == null ? void 0 : e.namespaces)
  }
  serializeTransaction(e) {
    return Buffer.from(new Uint8Array(e.serialize({ verifySignatures: !1 }))).toString('base64')
  }
  getAccount(e) {
    var s, i
    const n =
      (i = (s = this.session) == null ? void 0 : s.namespaces.solana) == null
        ? void 0
        : i.accounts[0]
    if (!n) {
      if (e) throw new Error('Account not found')
      return
    }
    const r = n.split(':')[2]
    if (!r) {
      if (e) throw new Error('Address not found')
      return
    }
    return { address: r, publicKey: vs.decode(r) }
  }
  getRawRPCParams(e) {
    var n
    return nu(e)
      ? {}
      : {
          feePayer: ((n = e.feePayer) == null ? void 0 : n.toBase58()) ?? '',
          instructions: e.instructions.map(r => ({
            data: vs.encode(new Uint8Array(r.data)),
            keys: r.keys.map(s => ({
              isWritable: s.isWritable,
              isSigner: s.isSigner,
              pubkey: s.pubkey.toBase58()
            })),
            programId: r.programId.toBase58()
          })),
          recentBlockhash: e.recentBlockhash ?? ''
        }
  }
  checkIfMethodIsSupported(e) {
    var n, r
    if (
      !(
        (r = (n = this.session) == null ? void 0 : n.namespaces.solana) != null &&
        r.methods.includes(e)
      )
    )
      throw new kT(e)
  }
}
const fh = xn({ connection: null }),
  sl = {
    state: fh,
    subscribeKey(t, e) {
      return Yr(fh, t, e)
    },
    subscribe(t) {
      return Qr(fh, () => t(fh))
    },
    setConnection(t) {
      fh.connection = tc(t)
    }
  },
  BT = { UNIT_PRICE_MICRO_LAMPORTS: 2e7, UNIT_LIMIT: 500 }
async function DT({ provider: t, to: e, value: n, connection: r }) {
  if (!t.publicKey) throw Error('No public key found')
  const s = new it(e),
    i = Math.floor(n * vfe),
    { blockhash: o, lastValidBlockHeight: a } = await r.getLatestBlockhash(),
    c = [
      Hv.setComputeUnitPrice({ microLamports: BT.UNIT_PRICE_MICRO_LAMPORTS }),
      Hv.setComputeUnitLimit({ units: BT.UNIT_LIMIT }),
      zf.transfer({ fromPubkey: t.publicKey, toPubkey: s, lamports: i })
    ]
  return new Kr({ feePayer: t.publicKey, blockhash: o, lastValidBlockHeight: a }).add(...c)
}
function Pfe(t) {
  switch (t) {
    case 'processed':
    case 'confirmed':
    case 'finalized':
    case void 0:
      return t
    case 'recent':
      return 'processed'
    case 'single':
    case 'singleGossip':
      return 'confirmed'
    case 'max':
    case 'root':
      return 'finalized'
    default:
      return
  }
}
const MT = { 'solana:mainnet': jf, 'solana:testnet': gce, 'solana:devnet': Mm }
class Rfe extends gy {
  constructor({ wallet: e, getActiveChain: n, requestedChains: r }) {
    super(),
      (this.chain = Ae.CHAIN.SOLANA),
      (this.provider = this),
      (this.wallet = e),
      (this.getActiveChain = n),
      (this.requestedChains = r),
      this.bindEvents()
  }
  get id() {
    const e = this.name
    return Vr.ConnectorExplorerIds[e] || e
  }
  get name() {
    return this.wallet.name === 'Trust' ? 'Trust Wallet' : this.wallet.name
  }
  get type() {
    return 'ANNOUNCED'
  }
  get explorerId() {
    return Vr.ConnectorExplorerIds[this.name]
  }
  get publicKey() {
    const e = this.getAccount(!1)
    if (e) return new it(e.publicKey)
  }
  get imageUrl() {
    return this.wallet.icon
  }
  get chains() {
    return this.wallet.chains
      .map(e =>
        this.requestedChains.find(n => {
          var r
          return n.id === e || n.id === ((r = MT[e]) == null ? void 0 : r.id)
        })
      )
      .filter(Boolean)
  }
  async connect() {
    await this.getWalletFeature(N5).connect()
    const n = this.getAccount(!0),
      r = new it(n.publicKey)
    return this.emit('connect', r), n.address
  }
  async disconnect() {
    await this.getWalletFeature(Sfe).disconnect(), this.emit('disconnect', void 0)
  }
  async signMessage(e) {
    const n = this.getWalletFeature(Cfe),
      r = this.getAccount(!0),
      [s] = await n.signMessage({ message: e, account: r })
    if (!s) throw new _fe('Empty result')
    return s.signature
  }
  async signTransaction(e) {
    const n = this.getWalletFeature(qv),
      r = this.getAccount(!0),
      s = this.serializeTransaction(e),
      [i] = await n.signTransaction({
        account: r,
        transaction: new Uint8Array(s),
        chain: this.getActiveChainName()
      })
    if (!i) throw new PT('Empty result')
    return (
      this.emit('pendingTransaction', void 0),
      nu(e) ? ic.deserialize(i.signedTransaction) : Kr.from(i.signedTransaction)
    )
  }
  async signAndSendTransaction(e, n) {
    const r = this.getWalletFeature(T5),
      s = this.getAccount(!0),
      [i] = await r.signAndSendTransaction({
        account: s,
        transaction: new Uint8Array(this.serializeTransaction(e)),
        options: { ...n, preflightCommitment: Pfe(n == null ? void 0 : n.preflightCommitment) },
        chain: this.getActiveChainName()
      })
    if (!i) throw new Afe('Empty result')
    return this.emit('pendingTransaction', void 0), vs.encode(i.signature)
  }
  async sendTransaction(e, n, r) {
    const s = await this.signTransaction(e)
    return await n.sendRawTransaction(s.serialize(), r)
  }
  async signAllTransactions(e) {
    const n = this.getWalletFeature(qv),
      r = this.getAccount(!0),
      s = this.getActiveChainName()
    return (
      await n.signTransaction(
        ...e.map(o => ({
          transaction: new Uint8Array(this.serializeTransaction(o)),
          account: r,
          chain: s
        }))
      )
    ).map(({ signedTransaction: o }, a) => {
      const c = e[a]
      if (!c) throw new PT('Invalid transaction signature response')
      return this.emit('pendingTransaction', void 0), nu(c) ? ic.deserialize(o) : Kr.from(o)
    })
  }
  async request(e) {
    return Promise.reject(new RT('request'))
  }
  async getAccounts() {
    return Promise.resolve(
      this.wallet.accounts.map(e => ({ namespace: this.chain, address: e.address, type: 'eoa' }))
    )
  }
  serializeTransaction(e) {
    return e.serialize({ verifySignatures: !1 })
  }
  getAccount(e) {
    const n = this.wallet.accounts[0]
    if (e && !n) throw new Efe()
    return n
  }
  getWalletFeature(e) {
    if (!(e in this.wallet.features)) throw new RT(e)
    return this.wallet.features[e]
  }
  getActiveChainName() {
    const e = Object.entries(MT).find(([, n]) => {
      var r
      return n.id === ((r = this.getActiveChain()) == null ? void 0 : r.id)
    })
    if (!e) throw new Error('Invalid chain id')
    return e[0]
  }
  bindEvents() {
    this.getWalletFeature(P5).on('change', n => {
      if (n.accounts) {
        const r = n.accounts[0]
        r && this.emit('accountsChanged', new it(r.publicKey))
      }
    })
  }
}
const { get: kfe, on: UT } = J8()
let ya = []
function Ofe(t, e, n) {
  const r = [
    UT('register', (...s) => {
      ;(ya = [...ya, ...LT(s, t, e)]), n(...ya)
    }),
    UT('unregister', (...s) => {
      ;(ya = ya.filter(i => s.some(o => o.name === i.wallet.name))), n(...ya)
    })
  ]
  return (ya = LT(kfe(), t, e)), n(...ya), () => r.forEach(s => s())
}
function LT(t, e, n) {
  return t.filter(Ife).map(r => new Rfe({ wallet: r, requestedChains: e, getActiveChain: n }))
}
class Bfe extends Y0 {
  constructor(e = {}) {
    super({ adapterType: Ae.ADAPTER_TYPES.SOLANA, namespace: Ae.CHAIN.SOLANA }),
      (this.balancePromises = {}),
      (this.providerHandlers = null),
      (this.connectionSettings = e.connectionSettings || 'confirmed'),
      (this.wallets = e.wallets)
  }
  construct(e) {
    var i, o
    super.construct(e)
    const n = Ke.getActiveCaipNetworkId(),
      r =
        ((i = e.networks) == null ? void 0 : i.find(a => a.caipNetworkId === n)) ||
        ((o = e.networks) == null ? void 0 : o[0]),
      s = r == null ? void 0 : r.rpcUrls.default.http[0]
    s && sl.setConnection(new hh(s, this.connectionSettings))
  }
  setAuthProvider(e) {
    this.addConnector(
      new Tfe({
        w3mFrameProvider: e,
        getActiveChain: () => ne.getCaipNetworkByNamespace(this.namespace),
        chains: this.getCaipNetworks()
      })
    )
  }
  syncConnectors(e, n) {
    e.projectId || qa.open(La.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, 'error')
    const r = () => n.getCaipNetwork(this.namespace)
    dt.isClient() &&
      'coinbaseSolana' in window &&
      this.addConnector(
        new Nfe({
          provider: window.coinbaseSolana,
          chains: this.getCaipNetworks(),
          getActiveChain: r
        })
      ),
      Ofe(this.getCaipNetworks(), r, this.addConnector.bind(this))
  }
  async getEnsAddress(e) {
    return { address: e.name }
  }
  async writeContract() {
    return Promise.resolve({ hash: '' })
  }
  async getCapabilities() {
    return Promise.resolve({})
  }
  async grantPermissions() {
    return Promise.resolve({})
  }
  async revokePermissions() {
    return Promise.resolve('0x')
  }
  async walletGetAssets(e) {
    return Promise.resolve({})
  }
  async getAccounts(e) {
    const n = this.connectors.find(r => r.id === e.id)
    return n ? { accounts: await n.getAccounts() } : { accounts: [] }
  }
  async signMessage(e) {
    const n = e.provider
    if (!n) throw new Error('connectionControllerClient:signMessage - provider is undefined')
    const r = await n.signMessage(new TextEncoder().encode(e.message))
    return { signature: vs.encode(r) }
  }
  async estimateGas(e) {
    const n = sl.state.connection
    if (!n || !e.provider) throw new Error('Connection is not set')
    const s = await (
      await DT({
        provider: e.provider,
        connection: n,
        to: '11111111111111111111111111111111',
        value: 1
      })
    ).getEstimatedFee(n)
    return { gas: BigInt(s || 0) }
  }
  async sendTransaction(e) {
    const n = sl.state.connection
    if (!n || !e.address || !e.provider) throw new Error('Connection is not set')
    const r = e.provider,
      s = await DT({ provider: r, connection: n, to: e.to, value: e.value }),
      i = await r.sendTransaction(s, n)
    return (
      await new Promise(o => {
        const a = setInterval(async () => {
          const c = await n.getSignatureStatus(i)
          c != null && c.value && (clearInterval(a), o())
        }, 1e3)
      }),
      { hash: i }
    )
  }
  parseUnits() {
    return 0n
  }
  formatUnits() {
    return ''
  }
  async connect(e) {
    var i, o
    const n = this.connectors.find(a => a.id === e.id)
    if (!n) throw new Error('Provider not found')
    const r =
      e.rpcUrl ||
      ((o = (i = this.getCaipNetworks()) == null ? void 0 : i.find(a => a.id === e.chainId)) == null
        ? void 0
        : o.rpcUrls.default.http[0])
    if (!r) throw new Error(`RPC URL not found for chainId: ${e.chainId}`)
    const s = await n.connect({ chainId: e.chainId })
    return (
      this.listenProviderEvents(n),
      sl.setConnection(new hh(r, this.connectionSettings)),
      this.emit('accountChanged', { address: s, chainId: e.chainId }),
      { id: n.id, address: s, chainId: e.chainId, provider: n, type: n.type }
    )
  }
  async getBalance(e) {
    var c, u, l, d
    const n = e.address,
      r = (c = this.getCaipNetworks()) == null ? void 0 : c.find(h => h.id === e.chainId)
    if (!n) return Promise.resolve({ balance: '0.00', symbol: 'SOL' })
    const s = new hh(
        (d =
          (l = (u = r == null ? void 0 : r.rpcUrls) == null ? void 0 : u.default) == null
            ? void 0
            : l.http) == null
          ? void 0
          : d[0],
        this.connectionSettings
      ),
      i = `${r == null ? void 0 : r.caipNetworkId}:${e.address}`,
      o = this.balancePromises[i]
    if (o) return o
    const a = Ke.getNativeBalanceCacheForCaipAddress(i)
    return a
      ? { balance: a.balance, symbol: a.symbol }
      : ((this.balancePromises[i] = new Promise(async h => {
          var p, y
          try {
            const b = ((await s.getBalance(new it(n))) / bi.LAMPORTS_PER_SOL).toString()
            if (
              (Ke.updateNativeBalanceCache({
                caipAddress: i,
                balance: b,
                symbol: ((p = e.caipNetwork) == null ? void 0 : p.nativeCurrency.symbol) || 'SOL',
                timestamp: Date.now()
              }),
              !e.caipNetwork)
            )
              throw new Error('caipNetwork is required')
            h({
              balance: b,
              symbol: (y = e.caipNetwork) == null ? void 0 : y.nativeCurrency.symbol
            })
          } catch {
            h({ balance: '0.00', symbol: 'SOL' })
          }
        }).finally(() => {
          delete this.balancePromises[i]
        })),
        this.balancePromises[i] || { balance: '0.00', symbol: 'SOL' })
  }
  async switchNetwork(e) {
    var r, s, i
    await super.switchNetwork(e)
    const { caipNetwork: n } = e
    ;(i =
      (s = (r = n == null ? void 0 : n.rpcUrls) == null ? void 0 : r.default) == null
        ? void 0
        : s.http) != null &&
      i[0] &&
      sl.setConnection(new hh(n.rpcUrls.default.http[0], this.connectionSettings))
  }
  listenProviderEvents(e) {
    const n = () => {
        this.removeProviderListeners(e), this.emit('disconnect')
      },
      r = s => {
        const i = s.toBase58()
        i && this.emit('accountChanged', { address: i })
      }
    e.on('disconnect', n),
      e.on('accountsChanged', r),
      e.on('connect', r),
      e.on('pendingTransaction', () => {
        this.emit('pendingTransactions')
      }),
      (this.providerHandlers = { disconnect: n, accountsChanged: r })
  }
  removeProviderListeners(e) {
    this.providerHandlers &&
      (e.removeListener('disconnect', this.providerHandlers.disconnect),
      e.removeListener('accountsChanged', this.providerHandlers.accountsChanged),
      e.removeListener('connect', this.providerHandlers.accountsChanged),
      (this.providerHandlers = null))
  }
  setUniversalProvider(e) {
    this.addConnector(
      new OT({
        provider: e,
        chains: this.getCaipNetworks(),
        getActiveChain: () => ne.getCaipNetworkByNamespace(this.namespace)
      })
    )
  }
  async connectWalletConnect(e) {
    var i, o
    const n = await super.connectWalletConnect(e),
      r =
        (o = (i = this.getCaipNetworks()) == null ? void 0 : i.find(a => a.id === e)) == null
          ? void 0
          : o.rpcUrls.default.http[0],
      s = new hh(r, this.connectionSettings)
    return sl.setConnection(s), n
  }
  async disconnect(e) {
    if (!e.provider || !e.providerType) throw new Error('Provider or providerType not provided')
    await e.provider.disconnect()
  }
  async getProfile() {
    return Promise.resolve({ profileName: void 0, profileImage: void 0 })
  }
  async syncConnection(e) {
    return this.connect({ ...e, type: '' })
  }
  getWalletConnectProvider(e) {
    return new OT({
      provider: e.provider,
      chains: e.caipNetworks,
      getActiveChain: () => ne.getCaipNetworkByNamespace(this.namespace)
    })
  }
}
var Dfe =
  'AEkU4AngDVgB0QKRAQYBOwDqATEAnwDbAIUApABsAOAAbwCRAEYAiQBPAHYAPgA+ACsANwAlAGMAHwAvACsAJQAWAC8AGwAiACIALwAUACsAEQAiAAsAGwARABcAGAA6ACkALAAsADUAFgAsABEAHQAhAA8AGwAdABUAFgAZAA0ADQAXABAAGQAUABIEqgYJAR4UFjfDBdMAsQCuPwFnAKUBA10jAK5/Ly8vLwE/pwUJ6/0HPwbkMQVXBVgAPSs5APa2EQbIwQuUCkEDyJ4zAsUKLwKOoQKG2D+Ob4kCxcsCg/IBH98JAPKtAUECLY0KP48A4wDiChUAF9S5yAwLPZ0EG3cA/QI5GL0P6wkGKekFBIFnDRsHLQCrAGmR76WcfwBbBpMjBukAGwA7DJMAWxVbqfu75wzbIM8IuykDsRQ7APcta6MAoX0YABcEJdcWAR0AuRnNBPoJIEw3CZcJiB4bVllM44NCABMADAAVAA5rVAAhAA4AR+4V2D3zOVjKleYuChAdX01YPewAEwAMABUADmsgXECXAMPrABsAOQzFABsVW6n7Adq4HB0FWwXiAtCfAsSwCkwcpGUUcxptTPUAuw1nAuEACy00iRfJkQKBewETGwC9DWcC4QALLQFIUCWRTAoDLfsFMgnXaRetAddDAEkrEncCMRYhAusnuTdrADnhAfUlAMcOy7UBG2OBALEFAAUAitNJBRvDHwcXAKgn0QGhKy0DmwBnAQoZPu03dAQYFwCqAccCIQDTKxJzOvNQsAWQOncnNUgF+icFWQVYr7gFaTtdQhI6WEGXe5NmX6H4CxMDxQcl8XcjBKNLAlNTAnUbqycBj6OlNVsDRRcEg2EJANEGqz8vIwcpAjldAGsBYR9xAIMdGQCVAUm3ACdpFwGvxQM3LSFDUwFvWQZlAmUA8UkXAykBBQBJQQCrAF0AcwArtQYH8+8ZjX8ACSEAKQCzG0cB0QHbBwsxl3iB6AAKABEANAA9ADgzd3nTwBBfEFwBTQlMbDoVCwKsD6YL5REVDNEqy9PYADSpB+sDUwfrA1MDUwfrB+sDUwfrA1MDUwNTA1McCvAa08AQXw9IBG0FjgWLBNYIgyZJEYEHKAjSVA10HhxHA0UA/CMlSRw7kzMLJUJMDE0DB/w2QmynfTgDRzGrVPWQogPLMk85bAEecRKgACoPcxw1tU5+ekdxoApLT661f0liTmcCvjqoP/gKIQmTb7t3TgY9EBcnoRDzDC8BsQE3DelL1ATtBjcExR95GRUPyZWYCKEt2QzpJt8unYBWI/EqfwXpS/A82QtJUWQPVQthCd86X4FKAx0BCSKHCtkNNQhpEO8KxWcN4RFBBzUD0UmWAKEG/QsNHTEVsSYMYqgLBTlzBvca8guLJqsTJXr4Bc8aHQZJASUa+wDLLuOFrFotXBhPWwX/CyEjwxSkUBwNIUCzeEQaFwcRJaUCjUNsSoNRMh6PIfI8OQ1iLg9ReAfxPAEZSwt9PJpGp0UKEc4+iT1EIkVMKAQxeywrJ4cJyw+BDLV8bgFVCR0JrQxtEy0REzfBCDUHFSmXICcRCB1GkWCWBPObA+8TzQMHBTsJPQcPA7EcKRMqFSUFCYEg0wLvNtEurwKLVnwBEwXHDyEf2xBMR9wO5QiXAmEDfyXnACkVHQATIpcIP18AW4/UUwEuxwjDamgjcANjFONdEW8HjQ5TB6McLxW7HN1wxF4HhgQon6sJVwFxCZUBWwTfCAU1V4ycID1nT4tUGJcgXUE7XfgCLQxhFZtEuYd0AocPZxIXATEBbwc1DP0CcxHpEWcQkQjnhgA1sTP0OiEESyF/IA0KIwNLbMoLIyb1DPRlAZ8SXgMINDl36menYLIgF/kHFTLBQVwh7QuOT8kMmBq9GD5UKhngB7sD7xrvJ+ZBUwX7A58POkkz6gS5C2UIhwk7AEUOnxMH0xhmCm2MzAEthwGzlQNTjX8Ca4sGMwcHAGMHgwV14QAZAqMInwABAMsDUwA1AqkHmQAVAIE9ATkDIysBHeECiwOPCC3HAZErAe8lBBe/DBEA8zNuRgLDrQKAZmaeBdlUAooCRTEBSSEEAUpDTQOrbd0A1wBHBg/bQwERp0bHFt8/AdtrJwDDAPcAATEHAT0ByQHvaQCzAVsLLQmer7EBSeUlAH8AEWcB0wKFANkAMQB77QFPAEkFVfUFzwJLRQENLRQnU10BtwMbAS8BCQB1BseJocUDGwRpB88CEBcV3QLvKgexAyLbE8lCwQK92lEAMhIKNAq1CrQfX/NcLwItbj1MAAofpD7DP0oFTTtPO1Q7TztUO087VDtPO1Q7TztUA5O73rveCmhfQWHnDKIN0ETEOkUT12BNYC4TxC2zFL0VyiVSGTkauCcBJeBVBQ8ALc9mLAgoNHEXuAA7KWSDPWOCHiwKRxzjU41U9C0XAK1LnjOrDagbEUQ8BUN16WImFgoKHgJkfQJiPldJq1c3HAKh8wJolAJmBQKfgDgXBwJmNwJmIgRqBHsDfw8Dfo45AjlzEzl+Oh8fAmwZAjIyOAYCbcMCbarrhi9jQScBYwDaAN0ARgEHlAyJAPoHvgAJsQJ3KwJ2njsCeUc/Ani2GVjXRapG0wJ8OwJ6xAJ9BQJ87AVVBRxH/Eh5XyAAJxFJVEpXERNKyALQ/QLQyEsjA4hLA4fiRMGRLgLynVz/AwOqS8pMKSHLTUhNqwKLOwKK1L0XAxk/YwGzAo4zAo5YPJN9Ao7VAo5YdFGwUzEGUtBUgQKT9wKTCADlABhVGlWrVcwCLBcpkYIy3XhiRTc1ApebAu+uWB2kAFUhApaLApZ4mAClWahaBX1JADcClrEClkpcQFzNApnHAplgXMZdAxUCnJc5vjqZApwSAp+XAp60hgAZCy0mCwKd7QKejgCxOWEwYesCns8CoGoBpQKemxsCnkqhY8RkIyEnAierAiZ6AqD3AqBIAqLZAqHAAqYrAqXKAqf7AHkCp+5oeGit/0VqGGrNAqzfAqyqAq1jAqz+AlcZAlXYArHd0wMfSmyTArK5CQKy5BNs3G1fbURbAyXJArZYNztujAMpQQK4WgK5QxECuSZzcDJw3QK9FQK71nCSAzINAr6Ecf4DM20CvhZzHnNLAsPHAsMAc350RzFBdNwDPKMDPJYDPbsCxXgCxkMCxgyFAshlTQLIQALJSwLJKgJkmQLdznh1XXiqeSFLzAMYn2b+AmHwGe+VIHsHXo5etw0Cz2cCz2grR0/O7w+bAMKpAs9vASXmA04OfkcBAtwjAtuGAtJLA1JYA1NbAP0DVYiAhTvHEulcQYIYgs+CyoOJAtrDAtnahAyERac4A4ahACsDZAqGbVX1AFEC32EC3rRvcwLiK+0QAfMsIwH0lwHyzoMC6+8C6Wx1Aur1AurgAPVDAbUC7oUC65iWppb/Au47A4XcmHVw3HGdAvL/AGUDjhKZjwL3DwORagOSgwL3lAL51QL4YpoYmqe3M5saA51/Av72ARcANZ8Yn68DBYkDpmYDptUAzcEDBmahhKIBBQMMRQELARsHaQZdtWMBALcEZ7sNhx6vCQATcTUAHwMvEkkDhXsBXyMdAIzrAB0A5p8Dm40IswYbn8EApwURu+kdPT4WeAVoNz5AK0IhQrRfcRFfvACWxQUyAJBMGZu5OyZgMhG6zw4vGMYYicn2BVcFWAVXBVgFYwVYBVcFWAVXBVgFVwVYBVcFWEYVCNeFZwICAgpkXukrBMkDsQYvu7sAuwSnuwDnQCkWsgVGPmk+cEI/QrZfdTdf6ABYETOrAIz+zGvL/KbnRno9JiMEKxYnNjV+bd9qwfEZwixpAWvXbjAXBV8FasnBybgIz0lbAAAACnxefYu+ADM/gQADFtEG5a0jBQCMwwsDAQ0A5WUdPSQfSkKxQrxBOCNfJ2A2JzgjCcE9CkQ/Qz54PoE+cD5xAolCvElCO1/LTk9qTQosa1QvagtuH1/gMzobCWebCmIjKzwdJkKrQrwrzAHL/F/JDh8uCQgJIn6d32o6LUoXyavJrAllwcvMCmBBXw/lEKMRAJONHUVCJRupbTnOOAozP0M+cEI/HAcKHUxHbFssLVrhvBIKfe0dK0I/HF0ISgkOM1RDQjcEO0OcLAqBGy1CPxv1CFMiIxgwMQAFj2HwXgpxZMlgC2AtI25DYBk5AhseYLMGAmsQZU5gTREBZOdgFWCVYH1gs2BLYJFoFhcGtQ7cVam8WgtDFqsBuyvNwQIfFQAcAx4BeQJsLzCVUoABigq4RxoA5CN0jgrKDaZN6gGbAoecTwVAXwD39wkANBZXDAulDCQfuq9HAE8MNAAVE58rggh6AtILS2URGwDYTgZ1BAoeWgAxALa4AZonCxZvqyQ4nxkBWwGGCfwD2e0PBqoGSga5AB3LValaCbthE4kLLT8OuwG7ASICR1ooKCggHh8hLBImBiEMjQBUAm5XkEmVAW4fD3FHAdN1D85RIBmpsE3qBxEFTF8A9/cKAHoGJGwKKwulODAtx69WDQsAX7wLAGNAlQh6AOpN7yIbvwAxALa4AZonLTsOzgKQGHtQu1jIdHKO16WbDvWZFT0b7AEpEFwSBg8bAccJOhCTBRArDDYLABEAs84BAgCkAOEAmIIABWtXLwAUAFsbxi5sdioNwRACOyQz0+EcHgsbfQJ7Ls6hHATBCqrxbAA3OS0Opge7CQAQOi7OERkAfavaHA+7GkcczaF3HgE9Kl8cAuugCAHCAULz5B9lAb4Jtwz6CDwKPgAFwAs9AksNuwi8DTwKvC7OoSoJPA67BZgBG2sKD4sa4QHDARELuxY7AKALOxC7BBige9wAO2sMPAACpgm8BRvQ9QUBvgH6bsoGewAHuwG7D00RErwBAQDqAQAAdBVbBhbLFPxvF7sYOwAuuwLrDlaouwAeuwJVICp/AAG7AALjAAg7FTwVuwAbuwG9KOClWw6/xAD0AGj7L7ZtvgNIo7vIqDsDAbuVJ0sAAlsACrsEAOfdGbsIGnsIoQUK/3AA37unuxjbGruji3lyBvupm4MAErsGGwsBvAAAhgBtuwYAC7unOwEaO7oIoZzKAbsL7QfAqTsA4XsBvwAA5QAVuwAG+wAJuwBpiwAauwAOuwIYu45pFfsAAVsADmsALkseAAa7ABe7CCEADUoBwgC3ryYBwAAAtAAOmwG+J+QAsloAHBsBv/7hCqEABcYLFRXbAAebAEK7AQIAabsAC3sAHbsACLsJoQAFygBunxnVAJEIIQAFygABOwAH2wAdmwghAAaaAAl7ABsrAG0bAOa7gAAIWwAUuwkhAAbKAOOLAAk7C6EOxPtfAAc7AG6cQEgARwADOwAJrQM3AAcbABl7Abv/Aab7AAobAAo7AAn7p+sGuwAJGwADCwAQOwAAFDsAEWsAD4sADesADbsAGQsGFhsAFTsAbpsWswG7ALoAEzsDAGkrCgDhSwACOwAEUgAXewUbAAbQABi7AAv7AF+7AGv7AOSLAbsAF3YBvAABcguhAAVKHgF7KFIAOUUA/gcNDHIAKCpwAaQFCF4BvF4jDAkHb0tsXyqJHzwUYi02A6EKtAHYABYC0QNuAXZyR1IUIQNPAhU+ASwGA3NGvHtSekAAKQAxAfsAUwrbAHuQLAErAHblDREyRgFKAFcFAAFQAQeKzAB4OwQgpQBaANYVAJVoNx+LAM1rsQDP1BYIwnVzGxhWHQnRAYiQqyJTU01IEjzCifkAfxw3QCkr4BGXTwByASksMClCGQ8DMFUE98XuAEtl3ABqAnECPxF6Osd4LjXVBgUAEBsdCggMKgQfHSlOU04IuboAChLNACYAARoAhgCJAI41AO4AtADgAJ08ALsAqwCmAKEA8gCfANMAnADrAQwBBwDAAHkAWgDLAM0BBwDXAOsAiACiATUA4wDYANUDAQcqM9TU1NS2wNzN0M5DMhcBTQFXL0cBVQFkAWMBVgFHS0NFaA0BThUHCAMyNgwHACINJCYpLDg6Oj09PT4/DkAeUVFRUVNTUlMpVFVXVlYcXWFhYGJhI2ZocG9ycnJycnJ0dHR0dHR0dHR0dHZ2d3Z1WwBA7ABFAJYAdAAuAGLyAIoAUwBTADMCc+kAh//y8gBgAI/sAJsASwBeAGD5+aoAgQCBAGUAUgCtAB4AsgB/AjwCPwD4AOMA+gD6AOQA+wDlAOUA5ADiACkCdwFNATwBOgFQAToBOgE6ATUBNAE0ATQBGAFUDwArCAAATRcKFgMVFg4AigCSAKIASwBkGAItAHAAaQCRAxIDJCoDHkE+RykAiwJLAMMCUwKgALoCkgKSApICkgKSApIChwKSApICkgKSApICkgKRApEClAKcApMCkgKSApACkAKQApACjgKRAnEB0AKTApsCkgKSApEWeQsA+gUDpwJdAjYXAVAQNQLeEQorEwFKNxNNkQF3pDwBZVkA/wM9RwEAAJMpHhiPagApYABpAC4AiQOUzIvwroRaBborDsIRAZ3VdCoLBCMxbAEzWmwBsgDdfoB/foB+gYKCfoOGhH6FiIaAh4KIgol+in6LfoyKjX6Ofo+CkH6RfpJ+k36Ug5WIloKXftoC2WzhAtdsAIJsJGygAINsbARCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAlmZsAKMDh2wAtGYBBWwAyVFsbADPbAIMbAD2WmwA9gEZAPYA9AD0APUA9AN8XmzUhCNlvwD2APQA9AD1APQcbGwAiVpsAPYAiQEZAPYAiQLsAPYAiQN8XmzUhCNlvxxsAPdabAEZAPYA9gD0APQA9QD0APcA9AD0APUA9AN8XmzUhCNlvxxsbACJWmwBGQD2AIkA9gCJAuwA9gCJA3xebNSEI2W/HGwCQwE2bAJKATlsAkvBbGwCV2xsA54C7AOeA54DnwOfA58DnwN8XmzUhCNlvxxsbACJWmwBGQOeAIkDngCJAuwDngCJA3xebNSEI2W/HGwEN2wAiQQ4AIkGjTFtIC9s1m4DJmwA/QDGWgJsbABVWv4UMgJsbACJAmwAVAEAuV5sAmxebGwAiV5sAmxebD3YAEls1gJsbEZFNiJ9FGVAe8xvEZKvxVfKZszAVTBzYBH2d1iyUXEHH7twNw7eZF5JJRHI5EgaRr5D20/3dfONrFLSq5qSrrgd2CEUq722WBQ/LzpA+bx1oREI5xy4BDSZNun0ZWORUJqInZSyMaioyvfSI0l5uFDzbWaQ28/zdB0hwR4OQZ0/jn9ALSLNikjFYGfqR389qtFlhD3a6KdIh97rhZYpywuLc7o8ql5/X8KCbPU3L/QlmCowhRXhsGDvg6wUNprA9bM/49uxlAj7ZVy3ouEY/BgFXBNyK0TLrSjZWeJm/T4nz6QGLT3cJNtWRZVZTvIdtaxMMJRHgig9+S11LjBh7Inr06ykoch1U097Rw0hvgmOrydQyaWcEQDg0RavuMuT0zYabUZl1e33HNSK1oNUCS03eh+9C2EvF3fq9h+XBaAMFuoWeZf+mfZgL4HzyiKDIUtfNU4oFu0aE9qt3VA3U4D3fOSrAcYVnjG3cSkp1vhXZnp3JQm4JknKdBitO2NVnGCYQwU3YMWHWB87NEd+4AHuOKI8BSIH92reW0pfs+kWCTJxDCbRjFv8Cfc4/DSBYJScJYTeAEgg9wTEvcwd/QuHRHqGzAQ4fXf5FUI1lPrO+fvEcPl4JInM1z9AtBT2bL4QYEREe7KiSnnxTwtmAFjn8lqT3mND8qTktX2F16Ae9cakqJ6/pEQsHURqyqWlRMCzKXRKfCHT7sYHWx9/T/ugYTFY6iVN3Btm58ATJR5alYZybKMWojwOw3HbFn23NFyeLl7+Er82RchyYuBoGQ3j7SAWNxiYvp5U+Fq/DEzB9cG5DlJWsqkosRze92OVlCtQEYo1S1lF72Z8xWc4ld/+fFcfTEDTFb9d8tJGQ75dpJEvcWyGmGBiTbiWDdGOcw93Dmxq5ISUrmasygONfHLvhgo83HQZenbdBtSzBkvYrCEQ/xEDMhMZsN6gqplx5jGG9mSQLhM81UEdEeJ59sdNJDAFy/gPyJoKlwPZgB/MkC/kICLiCB8va+nCdO2ry4aDfkmPFpF/H/SGQ3LJ6aAv9dtJ8DniHtLOckZix0BVb0iR5V3LAp521LBSIi6AtV7r2ZB/hQEvAw54EFNOQcFnl1xGUIc67tqK1INNwD2n/RbwgzO9h45LM6VMuN8V1ZNIQ6t+Xy3lTqyVCD5kqLy/t3/b8MLbgDg8JIWDkSZ+LrGhhr+gYpH+pr1TnCUnZPjpUdw6bSL6MWVXoDDciQDWECwU2e6VEpfrcOBbrSOijqGkEIoJPbpmeJLkcwbvA0yWIixQVjo0HnYh7fji+Dfdq1mtV1lG2Zz9R7eFMHS+FK7nybutu2fwzDpFldO2pZBshsHJWaltn3PWOoGJpCT2jE8EHOuC6FkejNWcfsWCqNqMLP9xTwcWArj2EiiI7D+EaDi7/2cqHL1gPiF6C/J7aUo7RQqogPZ11WqbyP97nsoMxPOC78wZMF7B1Y0g7JNXJV/nN1m4xx8hbqWz07KSaqr5hE4icB326DMR/vUKX9LoNjle/ZWtbUhrTAcsdgrLlG5Ne8aiR0bS/2ZhpNOVVxavWIZsEM/rd68EB4vjbbD13NkMK1qvMk74vGbSkL7ULO0sZ9R6APSCo6KH+Xn98wEdw1bCPAnDTaBsD6sidAGN58uiH4a3ovG1KyZAu2XtyGgF/vgWKGxw9R1lfAVcfuYE71DHuxtTzfGZnHaDpDGWmfEq0N4GawE7yIkaoz8jcmVmzJe1ydM8q0p08YIxFcY1YcqQc1djWBEoNETDFcgk5waRftEJasPREkrV++N/TOKkERF1fCLrXS8DFGYGRBeECMQRNEs0ES3FzUtXCcNxpYEM3Uei6XodZruXUIRnn+UXf2b/r7n1vQutoi6WoIbW7svDNWBbUWcDUc7F9SJK3bvSy9KIqhgyJHoW2Kpvv0J4ob14HFXGWWVsYXJzjwxS+SADShTgCRjhoDgjAYRGxwJ1Vonw+cpnCKhz8NQPrb0SFxHIRbmG95Q2hlC4mDxvPBRbkFa60cvWakd7f0kVBxxktzZ9agPJEWyA63RSHYVqt8cPrs2uFJ3rS3k9ETGKn5+A6F9IOrdZHfT1biEyUJKEvwzuscwshGCBJvd16TrefW03xVnJf4xvs72PdxrMidjJO8EiWyN/VWyB3fv9kc34YIuZTFtXGo9DuG3H1Uka5FgBMwDPEvRcSabi3WakNQkXFecJlFk6buLVk5YHpuKWTw6oF632FPPSVIVl5hgUAeHhj0t/sw/PEEvThLQDDFE34eCg/rLOyXT3r+L98oRKrlTO0MdALYQ3rRQqC7d822dJPGxF1K4J2TtfPSMFaCAg0n0NGk9yiaKKOJD1v2aBX9HUOIawjjfvwCmjHZJTR62R9c9x33JnBjWrN4QYEOmehy0oZMP9XM9Zyi6TYoe07PaLceRXcCWZiY/imRUWW6+mci7+wMxSdwMdbXckXtvhJH8sc4iQcTwm7yp+3f7CaesTTQB2qkgeXh+wFiSMXfMlH7Yil0OoZ2QTtRLTip2O0cLZ4SstqWHZ6H+8A2kZXhpm0kPbL9dUanTOvziqIUh6Ambwa3WrCb2eWbuCN3L1hgWUmjRC3JoL3dBhR3imSQI8xuCMfsszlji7cSShNSYdqCXPxEVwbqO9i5B6hf93YI7aeyI8jxgcVXK0I/klbvhSXjkjOIwZgPdVwmsFW7HGPLUAvDRuKm+itybRg7c8+Yqqjg824Qf+/NxsBSUNAK9KCoJpauFqK0XQULrWYj4FnxeKDuvr54iokpi+D57e6Y1zxRJJdsHnDR3JyraCUufHBRTKODWBVzthjm4k3/Hv+Q990XDVR+KW+TcJX045LW86EKhz/97aqj89A8ZvTk1//tczosU90loIPVaHuWegJU3wP//7XHcO7c0yQM2jM/IhQKrf8hiObHWiWDZManF8Uf/HzbmDfC2wT//aiZ4hGTv/xzgKwdb1sD6cGEkceow0s3b89/zg+3plyRm0HlZi886j5wUwFhdHiDTaBidZRo5cx/tMeLyguOATbzq17ydhzbrpxunuHx6lbFGiO97gsd4dk//7iCIo+Ew+hG2so5kvv+ITG4c1fzHPtu1Xn5QfUnqY3/uByVmB7gmnE/E+5zdm+6nDmoews5fr+NzThdSHzK4bBQOL9c4O8OI0xLSqjJ4lbniLJg1aFpQRLwaSMZmpkC9e/j6FOVrTQ6a/a4alGgfrl2ZL1sbHUQ3DOI7ntq9diHFfm3t1mul3rdJEJCHnlW/hlQntipMrpeMs7fUr6wK370D7VbXH0DUHzdYfRg/6Z11Ult1sffJS+heHbco15Sxy3+rDnPesqH1lajk0yu02hPUvEUqvcUXWXL7Ad0wNGMx5gOle4XJxq/r/YY0xdco2wRSEGwcT7YADlBrHc9ZbvzOL0QwyWCWWChB9Obg800v7tyBWaNvdwz+fL7Ph9i2irEeJkRgOzeEDw+JiD/V93vH9FgMEoFIJMoIuogmicZohf94SBuPn6hXaV9jP4VVVA/bu+Wg8S88GLtmEPSNRLdtlXx2XL/nuM8nKkhnlnjaropiKKLIH94pLIASci0pDBfj9Hi5BfaTSXQg5+PMjQX91Ktk4MOqK1K99l4BRPv5+vNovGZ3IxQv8ICvjV4/diThpoaM8uvd3D9d/DE477w3yAbW3IDm2i73pZ9aEj38JqS6h/s8/xgmUIVcuq2JTgefAyuoafzQxAuRASeg3NtG3ach/JEkyuX+JDt2PnDZTShUhyHHG3ttBg/6lhAchGjLJBtopj4e01MlCp2yqQRTr4sBBXru+lKaoanwYX8y2aWCJiR3KnhCOkYVFSvsO0oDRujUFOEptiNDTYrJoUbvOyvl4AhC9h3wORiTXK1MrpMfnvdnndnR/HRVSusMBgIxwrLdn3vq1VcncPiD0SquTx/kNmxeFyCT4uXVUd9AL+rSGmuq7OOCzDKeVPjiNWVaoP5KOFqYq5Xcuf/xW9S+u9eIq9GAtZWtQlgkRecjRtvG1NR4WXXpn+pwsTBTIy079Ikg8rSef1aVapIFcXCd6C2wHVjLXR+N0tw4Taw6x6H90BFRgNrtlq2up6hHKuV3inM5RJaQWZHd84e6RsKkk9po3dk9by54tpPw7cBkFas/G+GbHwuG+AwP55BZyXILTHCIVrPpXHEaUPYfL6nphJP1Rc10xG4UaCeY4IHCwuur8xmSQDgY4aVwhzWhjbtSHG8JO6P2i2nC9/0Bfx0zk6dYQq3aw7k5vIObD7SEKrxhz0fQ0+YTOfHW23CBNeZci1qNsUDhoeqmfyP6PvjoEjHk8QbrFyQVZPHVWijnb8YCM65iYNoEbvnchStZ/9cKg5Vd45j8KnB6UjzXl/bkyZx7VoD47ocUUi117WwgySSb4rXgLJ52Mv5XJbp3I+uBP81BUvOjy4Cacgi+GWWlC/8dwgqwiojjUBDnEOxyRyowwLQfytFra1OZS4XvRYr4uoamAfG3I/p2bA7G90yqKThH8Ke00Tqd+3l3dmJpaCZelBMYjGqNLVa3SM4+LQeL56gY6Bymy2LQPVOxjWfj5tq4o74swcxhyGJPynkS5xAjOXZP1/FAYcBT3u6qLoIkEfErwo4gozmyI1YCvM0oyI3ghjGPQSsof2sKUhq91WsKy9cYWN+4A2v4pG/Mxpdc6w6kI/HX7Xb0TuihmsiOy2wQIsrZbUmr3OBSUo6oDJNgQp+YqYkgTgYcWZDgawJw3DFfdzT//PhVUidgB2qa8uw/j9ToHBAS33iT8YLhhAfyXG0bQUFp7QmH7oQ3i6Flf4OTZLvJdh8pfuflmWu2ohm5pTiSg1pl3vq9uluTJwqXfh1hqy8e2iHoD+Y35gCIViTo6VOtK5dD8HYClucJucXASzwe2kPj4S4eYQtmkYHagXhAzp/F541xE8YFYqSPszDuz3soWzHy0p3E2jwZNQaIcGU9FNQwQxeDw0ZlK9dxXrj9IUHGUPTOyib8CqXmbZ7Ex54bn1rLx3qqAavu/gh6XjV0GmN1p+yyMK9HN5uYEvxgbAk43tsheREhyI+Q5WLIneKTGPmYiM/lxOp8fvqHy8YgXK0TlMiX0tliLI2JtfmWZP8eVV732sdYm+pcWzDzEmKLJZyeelyaZKkjPnnUO9keDwtgiLnmd5+t+Sr5y8brRnlvxcWEWfCqIALQYHvaXx6jTg4dAlye469uGwwOZVZCILLfGjaMg4LUCNMTtMSp1aC2y/3wR2t1v3w/iNBRQ+bNbtDqL2NAr7K4rUcyqbSpNrXZgAWXvjxBBtfYLK1uRYt3q2pfXJOAL0HtWcEwJLddOSJKV1SwvcvEuzg/4MPnA8MIUJOLqm3qI6wFyN99Ck6zYaV/zGSAzF/PGsaNa4vPLe5QnyuqVUnVQ6xELA6gbe53aGgeke+R/ycb2LJVyc7BhuzI90zA+c6wUDTb7NH//gdDSl2u/aW7lRJm8m1fLtPxcNuEM5JbkOCZKPM88HUsLRoC1pmKKlvWyeAXuxILbu0snpSxf8N+RgtLUSe5n2gdjOjoSTaN7mMZ7bF+cWk/MS8mFD4pcyl5UN7CbpFZH2a+Pm1VAnUTVfbw8qrmz1G9m5aKmRzY1SMhhPrlCn2t4uNUXNA3IFe6NOjSC1DEaAFZAfDlEkQCsbNhsZPj6NQPDSB3tLiTo0ZYoEbIeEIaKtU3Wk60rEszawTFuyHVd365LA/c/uarABN5M5rGq/dqTG3Ilye/5EKiYisisuzqNaZjmWv0z9TORc0CKbaTea214oNM9u2sXUZub/eqM3Pi/PjRSyQiOSwPWif2asTgu6hS6fb5UGosCWxdedMqdViIUUSSdIJx+qQ4KShfTT39VAWZbi+mB+iKICNwpt6cflY57Rcbs6d1kA26Iru73cuxYVlSvuJdcR5VfDYZRk8X0AXePROyw3Le6LaUdmTLzYsoNhhgQpd67xVNiHgk3pakmndeIAtTC4DCXy9oS6eU4CWxDdVmY53pKNbdAKmQsP37lrJZC6iDXMELGKcHjNuuZgcDyY8W/yv6ha3DX7OWm/35fpvhw55oitf4V+GULlcPWYyGGuVBdro19c8u0RDddDun40W7G5cSIzHLh/qZxb59R+EPY+wZ2XerkUim92hhXpKyW6WtAh6zQS97DrPyjCvKi3pCw96LeKynOpyjtsMQc2RmI/20zFOZcSa2AK++PoRcT6zeJyxlBZ7kk5mhqXGkLlM2hFKc+/T544xXP0Ua38Q6xdPTLTeG1PHnLMaOvksUQMrEFTB/lizCirmFQL8zYVU+OTeYQEFaITsBSMMYexS9HkajO2gGIf2micvntCZJsZQEwIH3/4JGJQGflBuH5rNXmnRRYXDQs3ZoEQoMtYDr1kFKUS/siiQSUxcTH9XYeBZiKDDFQoExREO9dddKQLO3BwMHvymCSTFyY+vxn3D27NDx6OlU092D5EDUwilttqVHpjJQDUceJYCLsK2swfXeNUVrBJT/w/sk+7si8rPtiMFis+oxvGdGQxirMBID700T39mULuNHzOyN+xBfcFACZcyngF1aSpv0JPkNUrAZTqfplv509cGXFUiEEm5dZb+OsP/blizqdK45/dSsIrufYTrCPY2lgJD6k6QljTfXVlHfYKSq+MsagyUcaMintyr95bD8kdTAeYNLNsMmo/Wdd8a2nStBP49ARIjqqpUHWY4q4mvO5Cq/CgCP+4/B+5zutGwX5pssgVLr1+fIM7WWLfiUQDk4c6ZdHZOWv5hG3g2dgQ5NXnpIY+BWwJpaouf25bXnjDzbHnQNofH/c6m+dEAS9Gs2h7pFRPKOBDnqswZ8KZjhId1ytHUTs533KwBoSiImoxKQUgZ7z6pA9QB3sZ8Cq0vwutJTTkfbX8AzCpm2cFXx/P22niUMHauU8IGc+78R6TsutoonoqFuoNA3l80t387YHMoL5KGAT1JO4zmx+vJ0LbLHlicHraSVYvJjnO9p++qnWgKw9OwFVVUagvZuf9qfiuum+hIicxP1q4zDnzkHsCNriLxBpxY9N+UOmqzdY1MunLMDgkMyi3uvnN3UBXJeZ8YLs5xr8QrOhimYoKuGBebZHAiBIkViv3DG8k2oNpp5OIgX6ulqaRN8V62QUPjn5tl1kPXhT9bcd8qIm8gi4or/FGbvQ6pgGSHmnayrugmf5E0upGxPRf/3xOtitGMaHLKJVm5zhglmVfI91o0yxhJZVS/5wQ8zfxK8Ylw0WmHXoGfRkoBRx9Hsnl/6sgTjAVwpmNuSeZtBwlX4qB8Bh8lxjqBDIuFGJ4I1wxN0XRlAAslzqMKwQfyA7OkuivCXfv+i+3XmhcBFM2n4jdT+NyUmBnQJPV3F2sZfKvJhUlXzSosFR4VevVVcOkFnnjdiRWc0TeSYxj41sJGYMbZTeLI3GvyZ8/gAAudQ1+4oFX+enX5V49MczGCYVBuoC4kHjp7ZVxj+clBwPr9k+v05SsezQK3enxLs1Nt/N7c7AImVUysjGou4iOohHo83Zs9/MI/OWB+OyXzOBD93NbApGHXrv8CVRHp2bwH+xB55cfNrdqFD35HSMx4iVmtzYAmSCIV8kXsHoq3DIb93riTWbubnjxbBW5zConVtbxLRStXHkIyAByaozME952Gc9aAdAbBpZSVCH88Uwb/4bPTVOVl+WoMYD7JIvK8VcMrJ8zHV4bbG0Dg7Kx17A4ej/ZcZ2Z5pVuVLUH1E/AccUTKm81SE+LQ6STTUDscUk0x2OWIbEORhg69tdoTGNkA1RfkGIRZHr5mCXOpLC55WWzCZoGPFUVtZRHwh0nq039CDdjEPo+JyaxSQAvDgR6Iqvxy0frrtEG1A385N81l05SSzN+IDm9bypF9m92EUqblnauZ5sjc37wRykOdl7w4o8WMgQsjii3EE/aJYDfHs1cH6DNBEujjcCc8qAefYFyIAURDcDnzun5UmkbBQsU4eu/W8I9nBE0qJKTdg2hwjq0+XV7a3TJ7R+alvJZCRia9lJ+grNB9dbrOmWEvUotMjvDhq4wV/kq4fvIBkzUGpDeYH74rne8uU3dgoNZdR9pUL6q9YDNRfOiF6Dyk+SYXQIghTjm9qR4tBHh0gnmF/9q3Qv22EzaLhSvDlDOxMrrCNRmLCl1jApzLrBCPn2mjn5zqK7OYK7VxOfQ5GfBfoPdyQwqFEgCVHkJ9oTnagRM3R0+rsuN5jQv9icCav/p1WqiEXSzCdLd/WEA6z6dDP7tPqPbeDYKAkVcz1lLGbFOC9b7cBd3MV0Ve8dZ89oR7OnxGS7uVpSry8banVZwpJg+nkH1jRBYa2BvBMY2xITH9ERXCjHzdZxs+ipdXP2DY7X+eWiBhtT2L0RRGTLPeazn5tpl4tu8iE2rWig731iuJDRbCHHy+g/Mb9+miAyVqfIpXT/iZeOxOxODO0hEpLM78I1+G2Z45yi3lS1K3m4WMQ559Lp4UML5vZUjYGJuxl+OPpUH5klpyBujkjprhei0TmUik10gjvNUp8mDkWlNKikmYspaVTqewbnOzJrmz8FLIpsT67EJLHIIfeDcWEfiP+DJrZ1jfxpoAb2abeMqLx+9RuZGzQoYtYVGgAWwEM9Kek2vPIeBNAKD6ao7nw6sgvfeLZPoXkbYO/tStHJdKzk+WFSFEU2NcALJAEP6S8pcnqqBBt57dwTrzQNCIdk2SocK4dLRbD/pu/VryKnm65ZYXiJCfHJk3mx9MRSl+nSK6OqEBSoGjz0/LADddwF/HqcfK3K3O+6YUGQcmj8pZL4PhZ6KrGkb8B38FmDvvLd3XQXbvS/FQmrXFTvJNkaN/FGo83KuS43BK1UfVnIqigGkCoP5fBda2MwAGTGNKX9K9t4Bx83pMFc5KSORmWKv+8VoVggWxoaBz3/9IBh6RwLd1tebwy89xvE5z6EEpXpDfrXWfRsMs6+ekUHH6idVosno55+xQ8Zqzelh0bxtJTgCcH3Z3/Cxlx9eNIS4JIFKOAVrDqbrXRszmY55a5+niJGHtkO3b6mnIDxLa1WXc7BAe33mt2KyM4Fbc3R6/WVTQN8QhlqAtave2WsQTqzWeSlKuGUVIJRqtObpv294rS0kDN1RKzdstZTXJebR2HlzsQ4P3NbMHUqFZMZw+/IKXnh4t+lY8qocp/B1oMszR03EFs3bPeND8QkItMvllObeCz3SZAjqZrobmLcrpFyQV7mwBjg3C3C8/bc5goQhv8j/IXMLGnt4mF7tybRDG5G0polxoUScQkPvmnga2/K+aapKeqSL0BTmo1Cm5g+booNOtdyKva2KoefRURaBk7113QKo3y+WTuFKtgETIK8HRluYS9DvlcciCDvnG8UaJRfZE2siZsiTHvRmN80xkUIInHeRZl5Re/+ATL6VhKFi8CZ/n/jbFV6T5pZ+Uoppvsi3qjacVFOJgWWfdlwVHKPW/TJO3na9hRM9bS2yo2rEsC6IBzRReVO6IesJU7PItzOamr+ROFfwGZmZ7ue8HNxAgLJKb7P3p8dMqk6Be5PJaT/5Rdc1deYVihWH9cjVKc9uz5EnfHqxLUkOO8iJUENBNVf5LyNy8zjLu/78k5WNTywiPfYeX3CPk7yc6CI3lum/CEZwfUaNpcI3KsPqfn2lmz3kd/acQjKA1ebkJaiuLD+epQ/Fc1llHXXMzofWzz/Kd29SNmOhcjMWw1jq1g3YfrXZ9rzXDYW4ZttfgfMi6oCUtBs0PkMVuxmq5lxEoCaSXPSqCJJ7MlKdRDidVt0AFlxk5cTdX++sBF2+E35mjwfm8ERVxH0FvuAQtsfA4V2G0TKTUxeyRGVjd/u6F1SvuAiU2/WaQjcNCU4Ep7VunXCYSbZj3U3wzu/LWM5MPlYuyQ3FOOCD/zt7K295hY2JhwF+ODDIZ676vGQFKveEQYkWj7lkK7rVmD7MhU0Y/tF8EcTTpo4/yqOufbd/zWIpMajnbDuWK2vn6OPPtz2rc9MIBNlPd8tt+yf+7SC4wqEPbozKMCwY5Bygx4JmoIEDsixWRDcdHd6S3/dZMHXOJAAv7+NIstl00crgSqHZKAEe4g3G4dzIV51EeZB01r7p8GNlfUnG/GjZgNGsqXZdYMBVtAtFNv3hJWPve4GvqZ2XxuiNkHTz5kxWgr0PjQdJlVywJ9Zf2ZvqeeTbolKtvK54re2Lq5BoyzfsRtvDfyao3kmyFzDQ88nM+qx83w74RDlkngtYiArI05Epre3GgBeSlMig0pE6RGQaFznKkGeb0SozLCyiOtxh7hgwZlbKbClzUUfC8ntMiHUOZE375RhTy9c4DA+oMLkUDkztSybZbdmP1xpaIbjUpPAHBq3cIq+CBFzbMlMMCCkUQ6d9LGV6GYCsYiEWZIy3nBnuxOYXeU4YTGDSin9e4/pCjPtQSHlg5LMEvIlF0ElthqrF129iK2RPBEWd3XWOl3SWV5uz5VUyZYp5kEFmz7QfP/B1W1BBzQ2iTGbSVT79lUHzcGXz3PJceSgz4uknETUwo0xffpr2KUvZF0i/r2sL3IFIClYx8CbIZE6Qt7MDJbOPB3xMScwaOcWG66IJfCnDkb0D2Mb+PHzX+oiCbxeTIogtyN+s2NJirNACk/OACSOTtV6vscwbzW4M168xqaI+RzR47S1nlV/rOoZnid87n/Ima2XYa3un3BuGAisNjb8eLMT9OnMtazQROFCuO1HiZXaOc0oUDbNC4eKLToOx8DzVhMgGA8XIAQ2x3b6I0uEyLssQjJX3QphcUMx4KsMgJ+72km4N2aqkBF2coKmUEt1eqIMGn+5txMT4kYVGd3ALO+y9Z4PP3d3l48JQK8s9ZZ/Qx/+NBKgBEJFlQ32psoJiihGO7FSYM5L81q72kaAYcilEFMG+ZK1BcMqELkflyCV7v8JEXLO4Rf/oZYNZHZVjJhfL6fnpP9Tio3Euue5uS7FMkfGOeRCTrBZ06Caev7tgufeTrX34Ur/Vvc+b8ksiIShNJtuF9WmYxOZ4xg8y6zTdy3KAB2y5kYkcRnXsptWwAFyKZ2I/QGySNeoQLkINUMloC+5L3WuMMx297Q1xUYLKqZ9XHavaobo6QQv4auMm+i84IhxRpPt9nUmcav9NcjCcP+TcMmxsQZ/F3mgeoA0fQgwvTsyXuuTaM3Sqtv2jaaajmaFQpK9W6uIbeqwvSDo34ZrY6elDUHwSCjHRRmlwmyy+eOra64Ssq0XSXYljMHtKY+FShcMkHsEUY/4Bw63dJ6KpwDaxmthlDdbdE+TvYF3v33cGSKqO+1H1pKYhJMvZD5ckQcHyNF8zrtiR5b0ko6NPGoRexUZTYP6VbUdn3zzxGBOi8Z0OqHjGqYxRXwN3mYi0GYEEZYq+Q3QvdKcEHILLLj8S+VFepSfErtmfZCdvxbfIifFSpEzKi+7VJsLMT+zEFeyp1OdwRC1VZrfTLIyR7xTPUcZFYPD9qI7D70uTb4hdpqPXsJIRNYbZtNwch1OI3trh3u2ScoQyM9POnInsUa+OovcwkUP1UfIzPb95n4BaF2ev57NHAej0+BVMF9/Cj9663HN2/JN3SQgslL914bKfiTTDFAz9PlQEL/dSv1H8xl3mtWxh1McFO9EJXlRDaKQDsyKO4vOJW90NFE6yw2tjbc2GeF95sbs0I9enAa6QwQVf/kJQhAD2BzUDKggOyjy1TEhED6sfk+418lQy3c/uj8aw8UEzZ6hIMCd8RohAkumMtIj9m73l2yPWoGHVTPaywkC7Yj9tBM1NxMgcrDwRtk4RO2WHT7Ql5kQCKdJj6kNuOTeyEBYBjLMhGz+O5/YGa84HEiTYEpZ6fFzy26GG2hWtTyteuYrhSyG56BjsT/wQeLRytpTY3D7sIMqZnJ9z1FDrfyjFlGl2TNw9BQysbaxOuwYYZs/7I6BANgkqCknWZC7/BBXvaeKwAmC959I+G39BUE9bExkNlbRoFRyEtNzv+NJ91FuisG3JCS6uYBeRnfv8AkAfKTeg9EYamqnsGfAV7d0f9DghHEQ5IsPGDIUhgoSj7obM4Bu5uhQ3/CYEDTHc92AsFvDK4XGrwUeGBWBHPlS+f4x+CxmmHz2sAGmSFNt65kwZC64mnaoWlu2310laYn8r62AqsR5dfjyK18MEdurdagldzfJtjFXlZs7St4QhdPiye6TPh2/ZAQLU/Fip5s7TDEM16KtRWrK9hmxnQ7bmfa/+7pa10Z8WDPK3NuJ+NN/RAbQ5vHx2uX0Lm7/w7cAEH/hvZA+mt7J7zGw7YtQYwnNN6dpgwkGjjrS3yQoeoYt1EnczmtmJfQZWzUlP3Hlg9Wzlr9IH23q3thGth+QNEANFettxKfskkGOlLk8AqoKJwDqOxAa6UzAx07plSSyNBJSGco9zjnC5gGbDoKvsMDuBR6bGRlGzJ+hFsGa/Izt78aI+WZ6dJlZKp4pGISuv9rV0sAS0MWEwCmfauO7oQZMiakHU35LBxiyJoOMddhUWgcZuC8r4Ksvn75TTcQXLJ7kWtYhGuGqPd9dZuFjBWQHNwosXY5snbHFQq72CvHXhIg+shQxycuLOuWYErwCLZeF24b7F78pO7xw4X6lIAR02hUOf5087Rl0nOaeb6CK4i/KA/EZv76ftOWZtjwxslNr0E/u8rWUmnf3amfg6UZmBAluuoj3Dd7UV+9IAJ6iYcDfSJlgmIImohjfIUMJ27z+opj50Ak9af2LCNrWrBJvMovA1OeNO+MF/MwZvnaCxTgG7Cw4QfSPF6AYCGFt21M8PySZFeV3t2Rqqs5JMzMYzGRgq4o+UaKRgBf9GHi/9X9HXA3wxkCsd/UhnHSh2zUVDiraio/6nP4y3XJqs8ABfALAtCYU7DHPMPRjgcM6Ad/HiSXDAbOdSMkvGZPAkHs8wuQTy6X2Ov/JFvcPuKfV3/r9Q28'
const $T = new Map([
    [8217, 'apostrophe'],
    [8260, 'fraction slash'],
    [12539, 'middle dot']
  ]),
  FT = 4
function Mfe(t) {
  let e = 0
  function n() {
    return (t[e++] << 8) | t[e++]
  }
  let r = n(),
    s = 1,
    i = [0, 1]
  for (let N = 1; N < r; N++) i.push((s += n()))
  let o = n(),
    a = e
  e += o
  let c = 0,
    u = 0
  function l() {
    return c == 0 && ((u = (u << 8) | t[e++]), (c = 8)), (u >> --c) & 1
  }
  const d = 31,
    h = 2 ** d,
    p = h >>> 1,
    y = p >> 1,
    m = h - 1
  let b = 0
  for (let N = 0; N < d; N++) b = (b << 1) | l()
  let I = [],
    x = 0,
    _ = h
  for (;;) {
    let N = Math.floor(((b - x + 1) * s - 1) / _),
      T = 0,
      M = r
    for (; M - T > 1; ) {
      let $ = (T + M) >>> 1
      N < i[$] ? (M = $) : (T = $)
    }
    if (T == 0) break
    I.push(T)
    let H = x + Math.floor((_ * i[T]) / s),
      B = x + Math.floor((_ * i[T + 1]) / s) - 1
    for (; ((H ^ B) & p) == 0; )
      (b = ((b << 1) & m) | l()), (H = (H << 1) & m), (B = ((B << 1) & m) | 1)
    for (; H & ~B & y; )
      (b = (b & p) | ((b << 1) & (m >>> 1)) | l()), (H = (H << 1) ^ p), (B = ((B ^ p) << 1) | p | 1)
    ;(x = H), (_ = 1 + B - H)
  }
  let R = r - 4
  return I.map(N => {
    switch (N - R) {
      case 3:
        return R + 65792 + ((t[a++] << 16) | (t[a++] << 8) | t[a++])
      case 2:
        return R + 256 + ((t[a++] << 8) | t[a++])
      case 1:
        return R + t[a++]
      default:
        return N - 1
    }
  })
}
function Ufe(t) {
  let e = 0
  return () => t[e++]
}
function R5(t) {
  return Ufe(Mfe(Lfe(t)))
}
function Lfe(t) {
  let e = []
  ;[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach(
    (s, i) => (e[s.charCodeAt(0)] = i)
  )
  let n = t.length,
    r = new Uint8Array((6 * n) >> 3)
  for (let s = 0, i = 0, o = 0, a = 0; s < n; s++)
    (a = (a << 6) | e[t.charCodeAt(s)]), (o += 6), o >= 8 && (r[i++] = a >> (o -= 8))
  return r
}
function $fe(t) {
  return t & 1 ? ~t >> 1 : t >> 1
}
function Ffe(t, e) {
  let n = Array(t)
  for (let r = 0, s = 0; r < t; r++) n[r] = s += $fe(e())
  return n
}
function Kf(t, e = 0) {
  let n = []
  for (;;) {
    let r = t(),
      s = t()
    if (!s) break
    e += r
    for (let i = 0; i < s; i++) n.push(e + i)
    e += s + 1
  }
  return n
}
function k5(t) {
  return Vf(() => {
    let e = Kf(t)
    if (e.length) return e
  })
}
function O5(t) {
  let e = []
  for (;;) {
    let n = t()
    if (n == 0) break
    e.push(jfe(n, t))
  }
  for (;;) {
    let n = t() - 1
    if (n < 0) break
    e.push(Hfe(n, t))
  }
  return e.flat()
}
function Vf(t) {
  let e = []
  for (;;) {
    let n = t(e.length)
    if (!n) break
    e.push(n)
  }
  return e
}
function B5(t, e, n) {
  let r = Array(t)
    .fill()
    .map(() => [])
  for (let s = 0; s < e; s++) Ffe(t, n).forEach((i, o) => r[o].push(i))
  return r
}
function jfe(t, e) {
  let n = 1 + e(),
    r = e(),
    s = Vf(e)
  return B5(s.length, 1 + t, e).flatMap((o, a) => {
    let [c, ...u] = o
    return Array(s[a])
      .fill()
      .map((l, d) => {
        let h = d * r
        return [c + d * n, u.map(p => p + h)]
      })
  })
}
function Hfe(t, e) {
  let n = 1 + e()
  return B5(n, 1 + t, e).map(s => [s[0], s.slice(1)])
}
function qfe(t) {
  let e = [],
    n = Kf(t)
  return s(r([]), []), e
  function r(i) {
    let o = t(),
      a = Vf(() => {
        let c = Kf(t).map(u => n[u])
        if (c.length) return r(c)
      })
    return { S: o, B: a, Q: i }
  }
  function s({ S: i, B: o }, a, c) {
    if (!(i & 4 && c === a[a.length - 1])) {
      i & 2 && (c = a[a.length - 1]), i & 1 && e.push(a)
      for (let u of o) for (let l of u.Q) s(u, [...a, l], c)
    }
  }
}
function zfe(t) {
  return t.toString(16).toUpperCase().padStart(2, '0')
}
function D5(t) {
  return `{${zfe(t)}}`
}
function Wfe(t) {
  let e = []
  for (let n = 0, r = t.length; n < r; ) {
    let s = t.codePointAt(n)
    ;(n += s < 65536 ? 1 : 2), e.push(s)
  }
  return e
}
function pd(t) {
  let n = t.length
  if (n < 4096) return String.fromCodePoint(...t)
  let r = []
  for (let s = 0; s < n; ) r.push(String.fromCodePoint(...t.slice(s, (s += 4096))))
  return r.join('')
}
function Kfe(t, e) {
  let n = t.length,
    r = n - e.length
  for (let s = 0; r == 0 && s < n; s++) r = t[s] - e[s]
  return r
}
var Vfe =
  'AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA'
const Gf = 44032,
  Wm = 4352,
  Km = 4449,
  Vm = 4519,
  M5 = 19,
  U5 = 21,
  gd = 28,
  Gm = U5 * gd,
  Gfe = M5 * Gm,
  Qfe = Gf + Gfe,
  Zfe = Wm + M5,
  Yfe = Km + U5,
  Jfe = Vm + gd
function _h(t) {
  return (t >> 24) & 255
}
function L5(t) {
  return t & 16777215
}
let zv, jT, Wv, Kg
function Xfe() {
  let t = R5(Vfe)
  ;(zv = new Map(k5(t).flatMap((e, n) => e.map(r => [r, (n + 1) << 24])))),
    (jT = new Set(Kf(t))),
    (Wv = new Map()),
    (Kg = new Map())
  for (let [e, n] of O5(t)) {
    if (!jT.has(e) && n.length == 2) {
      let [r, s] = n,
        i = Kg.get(r)
      i || ((i = new Map()), Kg.set(r, i)), i.set(s, e)
    }
    Wv.set(e, n.reverse())
  }
}
function $5(t) {
  return t >= Gf && t < Qfe
}
function epe(t, e) {
  if (t >= Wm && t < Zfe && e >= Km && e < Yfe) return Gf + (t - Wm) * Gm + (e - Km) * gd
  if ($5(t) && e > Vm && e < Jfe && (t - Gf) % gd == 0) return t + (e - Vm)
  {
    let n = Kg.get(t)
    return n && ((n = n.get(e)), n) ? n : -1
  }
}
function F5(t) {
  zv || Xfe()
  let e = [],
    n = [],
    r = !1
  function s(i) {
    let o = zv.get(i)
    o && ((r = !0), (i |= o)), e.push(i)
  }
  for (let i of t)
    for (;;) {
      if (i < 128) e.push(i)
      else if ($5(i)) {
        let o = i - Gf,
          a = (o / Gm) | 0,
          c = ((o % Gm) / gd) | 0,
          u = o % gd
        s(Wm + a), s(Km + c), u > 0 && s(Vm + u)
      } else {
        let o = Wv.get(i)
        o ? n.push(...o) : s(i)
      }
      if (!n.length) break
      i = n.pop()
    }
  if (r && e.length > 1) {
    let i = _h(e[0])
    for (let o = 1; o < e.length; o++) {
      let a = _h(e[o])
      if (a == 0 || i <= a) {
        i = a
        continue
      }
      let c = o - 1
      for (;;) {
        let u = e[c + 1]
        if (((e[c + 1] = e[c]), (e[c] = u), !c || ((i = _h(e[--c])), i <= a))) break
      }
      i = _h(e[o])
    }
  }
  return e
}
function tpe(t) {
  let e = [],
    n = [],
    r = -1,
    s = 0
  for (let i of t) {
    let o = _h(i),
      a = L5(i)
    if (r == -1) o == 0 ? (r = a) : e.push(a)
    else if (s > 0 && s >= o)
      o == 0 ? (e.push(r, ...n), (n.length = 0), (r = a)) : n.push(a), (s = o)
    else {
      let c = epe(r, a)
      c >= 0 ? (r = c) : s == 0 && o == 0 ? (e.push(r), (r = a)) : (n.push(a), (s = o))
    }
  }
  return r >= 0 && e.push(r, ...n), e
}
function j5(t) {
  return F5(t).map(L5)
}
function npe(t) {
  return tpe(F5(t))
}
const HT = 45,
  H5 = '.',
  q5 = 65039,
  z5 = 1,
  Qm = t => Array.from(t)
function Qf(t, e) {
  return t.P.has(e) || t.Q.has(e)
}
class rpe extends Array {
  get is_emoji() {
    return !0
  }
}
let Kv, W5, jc, Vv, K5, Ml, Wb, dl, Tc, qT, Gv
function u_() {
  if (Kv) return
  let t = R5(Dfe)
  const e = () => Kf(t),
    n = () => new Set(e()),
    r = (l, d) => d.forEach(h => l.add(h))
  ;(Kv = new Map(O5(t))),
    (W5 = n()),
    (jc = e()),
    (Vv = new Set(e().map(l => jc[l]))),
    (jc = new Set(jc)),
    (K5 = n()),
    n()
  let s = k5(t),
    i = t()
  const o = () => {
    let l = new Set()
    return e().forEach(d => r(l, s[d])), r(l, e()), l
  }
  ;(Ml = Vf(l => {
    let d = Vf(t).map(h => h + 96)
    if (d.length) {
      let h = l >= i
      ;(d[0] -= 32), (d = pd(d)), h && (d = `Restricted[${d}]`)
      let p = o(),
        y = o(),
        m = !t()
      return { N: d, P: p, Q: y, M: m, R: h }
    }
  })),
    (Wb = n()),
    (dl = new Map())
  let a = e()
    .concat(Qm(Wb))
    .sort((l, d) => l - d)
  a.forEach((l, d) => {
    let h = t(),
      p = (a[d] = h ? a[d - h] : { V: [], M: new Map() })
    p.V.push(l), Wb.has(l) || dl.set(l, p)
  })
  for (let { V: l, M: d } of new Set(dl.values())) {
    let h = []
    for (let y of l) {
      let m = Ml.filter(I => Qf(I, y)),
        b = h.find(({ G: I }) => m.some(x => I.has(x)))
      b || ((b = { G: new Set(), V: [] }), h.push(b)), b.V.push(y), r(b.G, m)
    }
    let p = h.flatMap(y => Qm(y.G))
    for (let { G: y, V: m } of h) {
      let b = new Set(p.filter(I => !y.has(I)))
      for (let I of m) d.set(I, b)
    }
  }
  Tc = new Set()
  let c = new Set()
  const u = l => (Tc.has(l) ? c.add(l) : Tc.add(l))
  for (let l of Ml) {
    for (let d of l.P) u(d)
    for (let d of l.Q) u(d)
  }
  for (let l of Tc) !dl.has(l) && !c.has(l) && dl.set(l, z5)
  r(Tc, j5(Tc)),
    (qT = qfe(t)
      .map(l => rpe.from(l))
      .sort(Kfe)),
    (Gv = new Map())
  for (let l of qT) {
    let d = [Gv]
    for (let h of l) {
      let p = d.map(y => {
        let m = y.get(h)
        return m || ((m = new Map()), y.set(h, m)), m
      })
      h === q5 ? d.push(...p) : (d = p)
    }
    for (let h of d) h.V = l
  }
}
function l_(t) {
  return (V5(t) ? '' : `${d_(my([t]))} `) + D5(t)
}
function d_(t) {
  return `"${t}"`
}
function spe(t) {
  if (t.length >= 4 && t[2] == HT && t[3] == HT)
    throw new Error(`invalid label extension: "${pd(t.slice(0, 4))}"`)
}
function ipe(t) {
  for (let n = t.lastIndexOf(95); n > 0; )
    if (t[--n] !== 95) throw new Error('underscore allowed only at start')
}
function ope(t) {
  let e = t[0],
    n = $T.get(e)
  if (n) throw jh(`leading ${n}`)
  let r = t.length,
    s = -1
  for (let i = 1; i < r; i++) {
    e = t[i]
    let o = $T.get(e)
    if (o) {
      if (s == i) throw jh(`${n} + ${o}`)
      ;(s = i + 1), (n = o)
    }
  }
  if (s == r) throw jh(`trailing ${n}`)
}
function my(t, e = 1 / 0, n = D5) {
  let r = []
  ape(t[0]) && r.push(''),
    t.length > e && ((e >>= 1), (t = [...t.slice(0, e), 8230, ...t.slice(-e)]))
  let s = 0,
    i = t.length
  for (let o = 0; o < i; o++) {
    let a = t[o]
    V5(a) && (r.push(pd(t.slice(s, o))), r.push(n(a)), (s = o + 1))
  }
  return r.push(pd(t.slice(s, i))), r.join('')
}
function ape(t, e) {
  return u_(), jc.has(t)
}
function V5(t) {
  return u_(), K5.has(t)
}
function cpe(t) {
  return hpe(upe(t, npe, gpe))
}
function upe(t, e, n) {
  if (!t) return []
  u_()
  let r = 0
  return t.split(H5).map(s => {
    let i = Wfe(s),
      o = { input: i, offset: r }
    r += i.length + 1
    try {
      let a = (o.tokens = ppe(i, e, n)),
        c = a.length,
        u
      if (!c) throw new Error('empty label')
      let l = (o.output = a.flat())
      if ((ipe(l), !(o.emoji = c > 1 || a[0].is_emoji) && l.every(h => h < 128)))
        spe(l), (u = 'ASCII')
      else {
        let h = a.flatMap(p => (p.is_emoji ? [] : p))
        if (!h.length) u = 'Emoji'
        else {
          if (jc.has(l[0])) throw jh('leading combining mark')
          for (let m = 1; m < c; m++) {
            let b = a[m]
            if (!b.is_emoji && jc.has(b[0]))
              throw jh(`emoji + combining mark: "${pd(a[m - 1])} + ${my([b[0]])}"`)
          }
          ope(l)
          let p = Qm(new Set(h)),
            [y] = dpe(p)
          fpe(y, h), lpe(y, p), (u = y.N)
        }
      }
      o.type = u
    } catch (a) {
      o.error = a
    }
    return o
  })
}
function lpe(t, e) {
  let n,
    r = []
  for (let s of e) {
    let i = dl.get(s)
    if (i === z5) return
    if (i) {
      let o = i.M.get(s)
      if (((n = n ? n.filter(a => o.has(a)) : Qm(o)), !n.length)) return
    } else r.push(s)
  }
  if (n) {
    for (let s of n)
      if (r.every(i => Qf(s, i))) throw new Error(`whole-script confusable: ${t.N}/${s.N}`)
  }
}
function dpe(t) {
  let e = Ml
  for (let n of t) {
    let r = e.filter(s => Qf(s, n))
    if (!r.length) throw Ml.some(s => Qf(s, n)) ? Q5(e[0], n) : G5(n)
    if (((e = r), r.length == 1)) break
  }
  return e
}
function hpe(t) {
  return t
    .map(({ input: e, error: n, output: r }) => {
      if (n) {
        let s = n.message
        throw new Error(t.length == 1 ? s : `Invalid label ${d_(my(e, 63))}: ${s}`)
      }
      return pd(r)
    })
    .join(H5)
}
function G5(t) {
  return new Error(`disallowed character: ${l_(t)}`)
}
function Q5(t, e) {
  let n = l_(e),
    r = Ml.find(s => s.P.has(e))
  return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${t.N} + ${n}`)
}
function jh(t) {
  return new Error(`illegal placement: ${t}`)
}
function fpe(t, e) {
  for (let n of e) if (!Qf(t, n)) throw Q5(t, n)
  if (t.M) {
    let n = j5(e)
    for (let r = 1, s = n.length; r < s; r++)
      if (Vv.has(n[r])) {
        let i = r + 1
        for (let o; i < s && Vv.has((o = n[i])); i++)
          for (let a = r; a < i; a++)
            if (n[a] == o) throw new Error(`duplicate non-spacing marks: ${l_(o)}`)
        if (i - r > FT)
          throw new Error(
            `excessive non-spacing marks: ${d_(my(n.slice(r - 1, i)))} (${i - r}/${FT})`
          )
        r = i
      }
  }
}
function ppe(t, e, n) {
  let r = [],
    s = []
  for (t = t.slice().reverse(); t.length; ) {
    let i = mpe(t)
    if (i) s.length && (r.push(e(s)), (s = [])), r.push(n(i))
    else {
      let o = t.pop()
      if (Tc.has(o)) s.push(o)
      else {
        let a = Kv.get(o)
        if (a) s.push(...a)
        else if (!W5.has(o)) throw G5(o)
      }
    }
  }
  return s.length && r.push(e(s)), r
}
function gpe(t) {
  return t.filter(e => e != q5)
}
function mpe(t, e) {
  let n = Gv,
    r,
    s = t.length
  for (; s && ((n = n.get(t[--s])), !!n); ) {
    let { V: i } = n
    i && ((r = i), (t.length = s))
  }
  return r
}
function ype(t) {
  return cpe(t)
}
function wpe(t) {
  return ype(t)
}
function bpe(t) {
  let e = [],
    n,
    r
  function s(a) {
    return yf.parseEvmChainId(a) || 1
  }
  function i() {
    return (
      n ||
        (n = tu.getInstance({
          projectId: t.options.projectId,
          enableLogger: t.options.enableAuthLogger,
          onTimeout: () => {
            qa.open(La.ALERT_ERRORS.SOCIALS_TIMEOUT, 'error')
          }
        })),
      n
    )
  }
  async function o(a = {}) {
    var m, b
    const c = i()
    let u = a.chainId
    if (a.isReconnecting) {
      const I = yf.parseEvmChainId(c.getLastUsedChainId() || ''),
        x = (m = t.chains) == null ? void 0 : m[0].id
      if (((u = I || x), !u)) throw new Error('ChainId not found in provider')
    }
    const l = (b = Ye.state.preferredAccountTypes) == null ? void 0 : b.eip155,
      {
        address: d,
        chainId: h,
        accounts: p
      } = await c.connect({ chainId: u, preferredAccountType: l })
    e = (p == null ? void 0 : p.map(I => I.address)) || [d]
    const y = s(h)
    return { accounts: e, account: d, chainId: y, chain: { id: y, unsuported: !1 } }
  }
  return a => ({
    id: Ae.CONNECTOR_ID.AUTH,
    name: Ae.CONNECTOR_NAMES.AUTH,
    type: 'AUTH',
    chain: Ae.CHAIN.EVM,
    async connect(c = {}) {
      if (r) return r
      r ||
        (r = new Promise(l => {
          l(o(c))
        }))
      const u = await r
      return (r = void 0), u
    },
    async disconnect() {
      await (await this.getProvider()).disconnect()
    },
    getAccounts() {
      return e != null && e.length
        ? (a.emitter.emit('change', { accounts: e }), Promise.resolve(e))
        : Promise.resolve([])
    },
    async getProvider() {
      return (
        this.provider ||
          (this.provider = tu.getInstance({
            projectId: t.options.projectId,
            enableLogger: t.options.enableAuthLogger,
            onTimeout: () => {
              qa.open(La.ALERT_ERRORS.SOCIALS_TIMEOUT, 'error')
            }
          })),
        Promise.resolve(this.provider)
      )
    },
    async getChainId() {
      const c = await this.getProvider(),
        { chainId: u } = await c.getChainId()
      return s(u)
    },
    async isAuthorized() {
      const c = await this.getProvider()
      return Promise.resolve(c.getLoginEmailUsed())
    },
    async switchChain({ chainId: c }) {
      var u, l
      try {
        const d = a.chains.find(m => m.id === c)
        if (!d) throw new ao(new Error('chain not found on connector.'))
        const h = await this.getProvider(),
          p = (u = Ye.state.preferredAccountTypes) == null ? void 0 : u.eip155,
          y = await h.connect({ chainId: c, preferredAccountType: p })
        return (
          (e = ((l = y == null ? void 0 : y.accounts) == null ? void 0 : l.map(m => m.address)) || [
            y.address
          ]),
          a.emitter.emit('change', { chainId: Number(c), accounts: e }),
          d
        )
      } catch (d) {
        throw d instanceof Error ? new ao(d) : d
      }
    },
    onAccountsChanged(c) {
      c.length === 0 ? this.onDisconnect() : a.emitter.emit('change', { accounts: c.map(Dc) })
    },
    onChainChanged(c) {
      const u = Number(c)
      a.emitter.emit('change', { chainId: u })
    },
    async onDisconnect(c) {
      await (await this.getProvider()).disconnect()
    }
  })
}
h_.type = 'walletConnect'
function h_(t, e) {
  const n = t.isNewChainsStale ?? !0
  let r, s, i, o, a, c, u
  return l => ({
    id: 'walletConnect',
    name: 'WalletConnect',
    type: h_.type,
    async setup() {
      const d = await this.getProvider().catch(() => null)
      d &&
        (o || ((o = this.onConnect.bind(this)), d.on('connect', o)),
        c || ((c = this.onSessionDelete.bind(this)), d.on('session_delete', c)))
    },
    async connect({ ...d } = {}) {
      var h, p, y
      try {
        const m = ne.getCaipNetworks(),
          b = await this.getProvider()
        if (!b) throw new Aa()
        a || ((a = this.onDisplayUri), b.on('display_uri', a))
        const I = await this.isChainsStale()
        b.session && I && (await b.disconnect())
        const x = Pe.state.universalProviderConfigOverride
        if (!b.session || I) {
          const B = Od.createNamespaces(m, x)
          await b.connect({
            optionalNamespaces: B,
            ...('pairingTopic' in d ? { pairingTopic: d.pairingTopic } : {})
          }),
            this.setRequestedChainsIds(m.map($ => Number($.id)))
        }
        const _ = await this.getAccounts(),
          R = await this.getChainId(),
          N =
            (y =
              (p = (h = b.session) == null ? void 0 : h.namespaces) == null ? void 0 : p.eip155) ==
            null
              ? void 0
              : y.chains,
          T = N == null ? void 0 : N.some(B => Number(B.split(':')[1]) === R)
        let M = 1
        T ? (M = R) : N != null && N[0] && (M = Number(N[0].split(':')[1])),
          a && (b.removeListener('display_uri', a), (a = void 0)),
          o && (b.removeListener('connect', o), (o = void 0)),
          s || ((s = this.onAccountsChanged.bind(this)), b.on('accountsChanged', s)),
          i || ((i = this.onChainChanged.bind(this)), b.on('chainChanged', i)),
          u || ((u = this.onDisconnect.bind(this)), b.on('disconnect', u)),
          c || ((c = this.onSessionDelete.bind(this)), b.on('session_delete', c))
        const H = x == null ? void 0 : x.defaultChain
        return b.setDefaultChain(H ?? `eip155:${M}`), { accounts: _, chainId: M }
      } catch (m) {
        throw /(user rejected|connection request reset)/i.test(m == null ? void 0 : m.message)
          ? new nr(m)
          : m
      }
    },
    async disconnect() {
      const d = await this.getProvider()
      try {
        await (d == null ? void 0 : d.disconnect())
      } catch (h) {
        if (!/No matching key/i.test(h.message)) throw h
      } finally {
        i && (d == null || d.removeListener('chainChanged', i), (i = void 0)),
          u && (d == null || d.removeListener('disconnect', u), (u = void 0)),
          o || ((o = this.onConnect.bind(this)), d == null || d.on('connect', o)),
          s && (d == null || d.removeListener('accountsChanged', s), (s = void 0)),
          c && (d == null || d.removeListener('session_delete', c), (c = void 0)),
          this.setRequestedChainsIds([])
      }
    },
    async getAccounts() {
      var y, m, b
      const d = await this.getProvider()
      if (!((y = d == null ? void 0 : d.session) != null && y.namespaces)) return []
      const h =
        (b = (m = d == null ? void 0 : d.session) == null ? void 0 : m.namespaces[Ae.CHAIN.EVM]) ==
        null
          ? void 0
          : b.accounts
      return (h == null ? void 0 : h.map(I => I.split(':')[2])) ?? []
    },
    async getProvider({ chainId: d } = {}) {
      var y, m
      r ||
        ((r = await e.getUniversalProvider()),
        r == null || r.events.setMaxListeners(Number.POSITIVE_INFINITY))
      const h = Ke.getActiveNamespace(),
        p = (y = e.getCaipNetwork()) == null ? void 0 : y.id
      if (d && p !== d && h) {
        const b = Ke.getStoredActiveCaipNetworkId(),
          I = e.getCaipNetworks(h),
          x = I == null ? void 0 : I.find(_ => _.id === b)
        x &&
          x.chainNamespace === Ae.CHAIN.EVM &&
          (await ((m = this.switchChain) == null
            ? void 0
            : m.call(this, { chainId: Number(x.id) })))
      }
      return r
    },
    async getChainId() {
      var m, b, I, x
      const d = (m = e.getCaipNetwork(Ae.CHAIN.EVM)) == null ? void 0 : m.id
      if (d) return d
      const p =
          (x =
            (I =
              (b = (await this.getProvider()).session) == null
                ? void 0
                : b.namespaces[Ae.CHAIN.EVM]) == null
              ? void 0
              : I.chains) == null
            ? void 0
            : x[0],
        y = ne.getCaipNetworks().find(_ => _.id === p)
      return y == null ? void 0 : y.id
    },
    async isAuthorized() {
      try {
        const [d, h] = await Promise.all([this.getAccounts(), this.getProvider()])
        return d.length
          ? (await this.isChainsStale()) && h.session
            ? (await h.disconnect().catch(() => {}), !1)
            : !0
          : !1
      } catch {
        return !1
      }
    },
    async switchChain({ addEthereumChainParameter: d, chainId: h }) {
      var m, b, I, x
      const p = await this.getProvider()
      if (!p) throw new Aa()
      const y = ne.getCaipNetworks().find(_ => _.id === h)
      if (!y) throw new ao(new gf())
      try {
        await p.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: Mt(h) }] }),
          y != null && y.caipNetworkId && p.setDefaultChain(y == null ? void 0 : y.caipNetworkId),
          l.emitter.emit('change', { chainId: Number(h) })
        const _ = await this.getRequestedChainsIds()
        return this.setRequestedChainsIds([..._, h]), { ...y, id: y.id }
      } catch (_) {
        const R = _
        if (/(?:user rejected)/iu.test(R.message)) throw new nr(R)
        try {
          let N
          d != null && d.blockExplorerUrls
            ? (N = d.blockExplorerUrls)
            : (N =
                (m = y.blockExplorers) != null && m.default.url
                  ? [(b = y.blockExplorers) == null ? void 0 : b.default.url]
                  : [])
          const T =
              ((x = (I = y.rpcUrls) == null ? void 0 : I.chainDefault) == null ? void 0 : x.http) ||
              [],
            M = {
              blockExplorerUrls: N,
              chainId: Mt(h),
              chainName: y.name,
              iconUrls: d == null ? void 0 : d.iconUrls,
              nativeCurrency: y.nativeCurrency,
              rpcUrls: T
            }
          await p.request({ method: 'wallet_addEthereumChain', params: [M] })
          const H = await this.getRequestedChainsIds()
          return this.setRequestedChainsIds([...H, h]), { ...y, id: y.id }
        } catch (N) {
          throw new nr(N)
        }
      }
    },
    onAccountsChanged(d) {
      d.length === 0
        ? this.onDisconnect()
        : l.emitter.emit('change', { accounts: d.map(h => Dc(h)) })
    },
    onChainChanged(d) {
      const h = Number(d)
      l.emitter.emit('change', { chainId: h })
    },
    onConnect(d) {
      this.setRequestedChainsIds(ne.getCaipNetworks().map(h => Number(h.id)))
    },
    async onDisconnect(d) {
      this.setRequestedChainsIds([]), l.emitter.emit('disconnect')
      const h = await this.getProvider()
      s && (h.removeListener('accountsChanged', s), (s = void 0)),
        i && (h.removeListener('chainChanged', i), (i = void 0)),
        u && (h.removeListener('disconnect', u), (u = void 0)),
        c && (h.removeListener('session_delete', c), (c = void 0)),
        o || ((o = this.onConnect.bind(this)), h.on('connect', o))
    },
    onDisplayUri(d) {
      l.emitter.emit('message', { type: 'display_uri', data: d })
    },
    onSessionDelete() {
      this.onDisconnect()
    },
    getNamespaceChainsIds() {
      var p, y, m
      if (!((p = r == null ? void 0 : r.session) != null && p.namespaces)) return []
      const d =
        (m = (y = r == null ? void 0 : r.session) == null ? void 0 : y.namespaces[Ae.CHAIN.EVM]) ==
        null
          ? void 0
          : m.accounts
      return (d == null ? void 0 : d.map(b => Number.parseInt(b.split(':')[1] ?? ''))) ?? []
    },
    async getRequestedChainsIds() {
      var h
      const d =
        (await ((h = l.storage) == null ? void 0 : h.getItem(this.requestedChainsStorageKey))) ?? []
      return [...new Set(d)]
    },
    async isChainsStale() {
      if (!n) return !1
      const d = l.chains.map(y => y.id),
        h = this.getNamespaceChainsIds()
      if (h.length && !h.some(y => d.includes(y))) return !1
      const p = await this.getRequestedChainsIds()
      return !d.every(y => p.includes(Number(y)))
    },
    async setRequestedChainsIds(d) {
      var h
      await ((h = l.storage) == null ? void 0 : h.setItem(this.requestedChainsStorageKey, d))
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`
    }
  })
}
const ph = xn({ pendingTransactions: 0 }),
  zT = {
    state: ph,
    subscribeKey(t, e) {
      return Yr(ph, t, e)
    },
    increase(t) {
      ph[t] += 1
    },
    decrease(t) {
      ph[t] -= 1
    },
    reset(t) {
      ph[t] = 0
    }
  }
function vpe(t) {
  try {
    return JSON.parse(t)
  } catch {
    throw new Error('Error parsing wallet capabilities')
  }
}
const Epe = { enable: !1, pollingInterval: 3e4 }
class Ape extends Y0 {
  constructor(e) {
    const n = Xi.extendCaipNetworks(e.networks, {
      projectId: e.projectId,
      customNetworkImageUrls: {},
      customRpcUrls: e.customRpcUrls
    })
    super({ projectId: e.projectId, adapterType: Ae.ADAPTER_TYPES.WAGMI, namespace: Ae.CHAIN.EVM }),
      (this.balancePromises = {}),
      (this.pendingTransactionsFilter = { ...Epe, ...(e.pendingTransactionsFilter ?? {}) }),
      this.createConfig({ ...e, networks: n }),
      this.setupWatchers()
  }
  async getAccounts(e) {
    var i
    const n = this.getWagmiConnector(e.id)
    if (!n) return { accounts: [] }
    if (n.id === Ae.CONNECTOR_ID.AUTH) {
      const o = n.provider
      if (!o.user) return { accounts: [] }
      const { address: a, accounts: c } = o.user
      return Promise.resolve({
        accounts: (c || [{ address: a, type: 'eoa' }]).map(u =>
          dt.createAccount('eip155', u.address, u.type)
        )
      })
    }
    const { addresses: r, address: s } = pm(this.wagmiConfig)
    return Promise.resolve({
      accounts:
        (i = r || [s]) == null ? void 0 : i.map(o => dt.createAccount('eip155', o || '', 'eoa'))
    })
  }
  getWagmiConnector(e) {
    return this.wagmiConfig.connectors.find(n => n.id === e)
  }
  createConfig(e) {
    this.wagmiChains = e.networks.filter(s => s.chainNamespace === Ae.CHAIN.EVM)
    const n = {},
      r = [...(e.connectors ?? [])]
    this.wagmiChains.forEach(s => {
      var a, c
      const i = (a = e.transports) == null ? void 0 : a[s.id],
        o = Xi.getCaipNetworkId(s)
      i
        ? (n[s.id] = Xi.extendWagmiTransports(s, e.projectId, i))
        : (n[s.id] = Xi.getViemTransport(
            s,
            e.projectId,
            (c = e.customRpcUrls) == null ? void 0 : c[o]
          ))
    }),
      (this.wagmiConfig = AH({ ...e, chains: this.wagmiChains, connectors: r, transports: n }))
  }
  setupWatchPendingTransactions() {
    if (!this.pendingTransactionsFilter.enable || this.unwatchPendingTransactions) return
    this.unwatchPendingTransactions = tH(this.wagmiConfig, {
      pollingInterval: this.pendingTransactionsFilter.pollingInterval,
      onError: () => {},
      onTransactions: () => {
        this.emit('pendingTransactions'), zT.increase('pendingTransactions')
      }
    })
    const e = zT.subscribeKey('pendingTransactions', n => {
      var r
      n >= Ae.LIMITS.PENDING_TRANSACTIONS &&
        ((r = this.unwatchPendingTransactions) == null || r.call(this), e())
    })
  }
  setupWatchers() {
    Xj(this.wagmiConfig, {
      onChange: (e, n) => {
        e.status === 'disconnected' && n.address && this.emit('disconnect'),
          e.status === 'connected' &&
            ((e.address !== (n == null ? void 0 : n.address) || n.status !== 'connected') &&
              (this.setupWatchPendingTransactions(),
              this.emit('accountChanged', { address: e.address, chainId: e.chainId })),
            e.chainId !== (n == null ? void 0 : n.chainId) &&
              this.emit('switchNetwork', { address: e.address, chainId: e.chainId }))
      }
    })
  }
  async addThirdPartyConnectors(e) {
    var r, s
    const n = []
    if (e.enableCoinbase !== !1)
      try {
        const { coinbaseWallet: i } = await qr(
          async () => {
            const { coinbaseWallet: o } = await import('./cRzXxlf2.js')
            return { coinbaseWallet: o }
          },
          [],
          import.meta.url
        )
        i &&
          n.push(
            i({
              version: '4',
              appName: ((r = e.metadata) == null ? void 0 : r.name) ?? 'Unknown',
              appLogoUrl: ((s = e.metadata) == null ? void 0 : s.icons[0]) ?? 'Unknown',
              preference: e.coinbasePreference ?? 'all'
            })
          )
      } catch (i) {
        console.error('Failed to import Coinbase Wallet SDK:', i)
      }
    n.forEach(i => {
      const o = this.wagmiConfig._internal.connectors.setup(i)
      this.wagmiConfig._internal.connectors.setState(a => [...a, o])
    })
  }
  addWagmiConnectors(e, n) {
    var o, a, c, u, l
    const r = []
    e.enableWalletConnect !== !1 && r.push(h_(e, n)),
      e.enableInjected !== !1 && r.push(T0({ shimDisconnect: !0 }))
    const s =
        ((o = e.features) == null ? void 0 : o.email) === void 0
          ? gr.DEFAULT_FEATURES.email
          : (a = e.features) == null
            ? void 0
            : a.email,
      i =
        (c = e.features) != null && c.socials
          ? ((l = (u = e.features) == null ? void 0 : u.socials) == null ? void 0 : l.length) > 0
          : gr.DEFAULT_FEATURES.socials
    ;(s || i) &&
      r.push(
        bpe({
          chains: this.wagmiChains,
          options: { projectId: e.projectId, enableAuthLogger: e.enableAuthLogger }
        })
      ),
      r.forEach(d => {
        const h = this.wagmiConfig._internal.connectors.setup(d)
        this.wagmiConfig._internal.connectors.setState(p => [...p, h])
      })
  }
  async signMessage(e) {
    try {
      return { signature: await Yj(this.wagmiConfig, { message: e.message, account: e.address }) }
    } catch {
      throw new Error('WagmiAdapter:signMessage - Sign message failed')
    }
  }
  async sendTransaction(e) {
    const { chainId: n } = pm(this.wagmiConfig),
      r = {
        account: e.address,
        to: e.to,
        value: e.value,
        gas: e.gas,
        gasPrice: e.gasPrice,
        data: e.data,
        chainId: n,
        type: 'legacy',
        parameters: ['nonce']
      }
    await Qj(this.wagmiConfig, r)
    const s = await Zj(this.wagmiConfig, r)
    return await nH(this.wagmiConfig, { hash: s, timeout: 25e3 }), { hash: s }
  }
  async writeContract(e) {
    var o
    const { caipNetwork: n, ...r } = e,
      s = Number(yf.caipNetworkIdToNumber(n.caipNetworkId))
    return {
      hash: await rH(this.wagmiConfig, {
        chain: (o = this.wagmiChains) == null ? void 0 : o[s],
        chainId: s,
        address: r.tokenAddress,
        account: r.fromAddress,
        abi: r.abi,
        functionName: r.method,
        args: r.args,
        __mode: 'prepared'
      })
    }
  }
  async getEnsAddress(e) {
    const { name: n, caipNetwork: r } = e
    try {
      if (!this.wagmiConfig)
        throw new Error(
          'networkControllerClient:getApprovedCaipNetworksData - wagmiConfig is undefined'
        )
      let s = !1,
        i = !1
      return (
        WH(n) && (i = (await Od.resolveReownName(n)) || !1),
        r.id === 1 && (s = await Kj(this.wagmiConfig, { name: wpe(n), chainId: r.id })),
        { address: s || i || !1 }
      )
    } catch {
      return { address: !1 }
    }
  }
  async estimateGas(e) {
    try {
      return {
        gas: await jj(this.wagmiConfig, {
          account: e.address,
          to: e.to,
          data: e.data,
          type: 'legacy'
        })
      }
    } catch {
      throw new Error('WagmiAdapter:estimateGas - error estimating gas')
    }
  }
  parseUnits(e) {
    return X7(e.value, e.decimals)
  }
  formatUnits(e) {
    return bd(e.value, e.decimals)
  }
  async addWagmiConnector(e, n) {
    var s
    if (e.id === Ae.CONNECTOR_ID.AUTH || e.id === Ae.CONNECTOR_ID.WALLET_CONNECT) return
    const r = await e.getProvider().catch(() => {})
    this.addConnector({
      id: e.id,
      explorerId: Vr.ConnectorExplorerIds[e.id],
      imageUrl: ((s = n == null ? void 0 : n.connectorImages) == null ? void 0 : s[e.id]) ?? e.icon,
      name: Vr.ConnectorNamesMap[e.id] ?? e.name,
      imageId: Vr.ConnectorImageIds[e.id],
      type: Vr.ConnectorTypesMap[e.type] ?? 'EXTERNAL',
      info: e.id === Ae.CONNECTOR_ID.INJECTED ? void 0 : { rdns: e.id },
      provider: r,
      chain: this.namespace,
      chains: []
    })
  }
  async syncConnectors(e, n) {
    eH(this.wagmiConfig, { onChange: r => r.forEach(s => this.addWagmiConnector(s, e)) }),
      await Promise.all(this.wagmiConfig.connectors.map(r => this.addWagmiConnector(r, e))),
      this.addWagmiConnectors(e, n),
      await this.addThirdPartyConnectors(e)
  }
  async syncConnection(e) {
    const { id: n } = e,
      s = gc(this.wagmiConfig).find(a => a.connector.id === n),
      i = this.getWagmiConnector(n),
      o = await (i == null ? void 0 : i.getProvider())
    return {
      chainId: Number(s == null ? void 0 : s.chainId),
      address: s == null ? void 0 : s.accounts[0],
      provider: o,
      type: s == null ? void 0 : s.connector.type,
      id: s == null ? void 0 : s.connector.id
    }
  }
  async connectWalletConnect(e) {
    const n = this.getWalletConnectConnector()
    await n.authenticate()
    const r = this.getWagmiConnector('walletConnect')
    if (!r) throw new Error('UniversalAdapter:connectWalletConnect - connector not found')
    const s = await rS(this.wagmiConfig, { connector: r, chainId: e ? Number(e) : void 0 })
    return (
      s.chainId !== Number(e) && (await oS(this.wagmiConfig, { chainId: s.chainId })),
      { clientId: await n.provider.client.core.crypto.getClientId() }
    )
  }
  async connect(e) {
    var u, l, d, h, p
    const { id: n, provider: r, type: s, info: i, chainId: o } = e,
      a = this.getWagmiConnector(n)
    if (!a) throw new Error('connectionControllerClient:connectExternal - connector is undefined')
    if (
      (r &&
        i &&
        a.id === Ae.CONNECTOR_ID.EIP6963 &&
        ((u = a.setEip6963Wallet) == null || u.call(a, { provider: r, info: i })),
      a.uid ===
        ((d = (l = this.wagmiConfig) == null ? void 0 : l.state) == null ? void 0 : d.current))
    ) {
      const y =
        (p = (h = this.wagmiConfig.state) == null ? void 0 : h.connections) == null
          ? void 0
          : p.get(a.uid)
      if (y)
        return {
          address: y == null ? void 0 : y.accounts[0],
          chainId: y == null ? void 0 : y.chainId,
          provider: r,
          type: s,
          id: n
        }
    }
    const c = await rS(this.wagmiConfig, { connector: a, chainId: o ? Number(o) : void 0 })
    return { address: c.accounts[0], chainId: c.chainId, provider: r, type: s, id: n }
  }
  async reconnect(e) {
    const { id: n } = e,
      r = this.getWagmiConnector(n)
    if (!r) throw new Error('connectionControllerClient:connectExternal - connector is undefined')
    await q1(this.wagmiConfig, { connectors: [r] })
  }
  async getBalance(e) {
    const n = e.address,
      r = this.getCaipNetworks().find(s => s.id === e.chainId)
    if (!n) return Promise.resolve({ balance: '0.00', symbol: 'ETH' })
    if (r && this.wagmiConfig) {
      const s = `${r.caipNetworkId}:${e.address}`,
        i = this.balancePromises[s]
      if (i) return i
      const o = Ke.getNativeBalanceCacheForCaipAddress(s)
      return o
        ? { balance: o.balance, symbol: o.symbol }
        : ((this.balancePromises[s] = new Promise(async a => {
            var c, u
            try {
              const l = Number(e.chainId),
                d = await Wj(this.wagmiConfig, {
                  address: e.address,
                  chainId: l,
                  token:
                    (u = (c = e.tokens) == null ? void 0 : c[r.caipNetworkId]) == null
                      ? void 0
                      : u.address
                })
              Ke.updateNativeBalanceCache({
                caipAddress: s,
                balance: d.formatted,
                symbol: d.symbol,
                timestamp: Date.now()
              }),
                a({ balance: d.formatted, symbol: d.symbol })
            } catch (l) {
              console.warn('Appkit:WagmiAdapter:getBalance - Error getting balance', l),
                a({ balance: '0.00', symbol: 'ETH' })
            }
          }).finally(() => {
            delete this.balancePromises[s]
          })),
          this.balancePromises[s] || { balance: '0.00', symbol: 'ETH' })
    }
    return { balance: '', symbol: '' }
  }
  async getProfile(e) {
    const n = e.chainId,
      r = await Gj(this.wagmiConfig, { address: e.address, chainId: n })
    if (r) {
      const s = await Vj(this.wagmiConfig, { name: r, chainId: n })
      return { profileName: r, profileImage: s ?? void 0 }
    }
    return { profileName: void 0, profileImage: void 0 }
  }
  getWalletConnectProvider() {
    var e
    return (e = this.getWagmiConnector('walletConnect')) == null ? void 0 : e.provider
  }
  async disconnect() {
    const e = gc(this.wagmiConfig)
    await Promise.all(
      e.map(async n => {
        const r = this.getWagmiConnector(n.connector.id)
        r && (await Fj(this.wagmiConfig, { connector: r }))
      })
    )
  }
  async switchNetwork(e) {
    await oS(this.wagmiConfig, { chainId: e.caipNetwork.id }), await super.switchNetwork(e)
  }
  async getCapabilities(e) {
    var a, c
    if (!this.wagmiConfig)
      throw new Error('connectionControllerClient:getCapabilities - wagmiConfig is undefined')
    const r = gc(this.wagmiConfig)[0],
      s = r ? this.getWagmiConnector(r.connector.id) : null
    if (!s) throw new Error('connectionControllerClient:getCapabilities - connector is undefined')
    const i = await s.getProvider()
    if (!i) throw new Error('connectionControllerClient:getCapabilities - provider is undefined')
    const o =
      (c = (a = i.session) == null ? void 0 : a.sessionProperties) == null ? void 0 : c.capabilities
    if (o) {
      const l = vpe(o)[e]
      if (l) return l
    }
    return await i.request({ method: 'wallet_getCapabilities', params: [e] })
  }
  async grantPermissions(e) {
    if (!this.wagmiConfig)
      throw new Error('connectionControllerClient:grantPermissions - wagmiConfig is undefined')
    const r = gc(this.wagmiConfig)[0],
      s = r ? this.getWagmiConnector(r.connector.id) : null
    if (!s) throw new Error('connectionControllerClient:grantPermissions - connector is undefined')
    const i = await s.getProvider()
    if (!i) throw new Error('connectionControllerClient:grantPermissions - provider is undefined')
    return i.request({ method: 'wallet_grantPermissions', params: e })
  }
  async revokePermissions(e) {
    if (!this.wagmiConfig)
      throw new Error('connectionControllerClient:revokePermissions - wagmiConfig is undefined')
    const r = gc(this.wagmiConfig)[0],
      s = r ? this.getWagmiConnector(r.connector.id) : null
    if (!s) throw new Error('connectionControllerClient:revokePermissions - connector is undefined')
    const i = await s.getProvider()
    if (!i) throw new Error('connectionControllerClient:revokePermissions - provider is undefined')
    return i.request({ method: 'wallet_revokePermissions', params: e })
  }
  async walletGetAssets(e) {
    if (!this.wagmiConfig)
      throw new Error('connectionControllerClient:walletGetAssets - wagmiConfig is undefined')
    const r = gc(this.wagmiConfig)[0],
      s = r ? this.getWagmiConnector(r.connector.id) : null
    if (!s) throw new Error('connectionControllerClient:walletGetAssets - connector is undefined')
    const i = await s.getProvider()
    if (!i) throw new Error('connectionControllerClient:walletGetAssets - provider is undefined')
    return i.request({ method: 'wallet_getAssets', params: [e] })
  }
  setUniversalProvider(e) {
    e.on('connect', () => {
      const n = gc(this.wagmiConfig),
        r = this.getWagmiConnector('walletConnect')
      r && !n.find(s => s.connector.id === r.id) && q1(this.wagmiConfig, { connectors: [r] })
    }),
      this.addConnector(
        new xp({ provider: e, caipNetworks: this.getCaipNetworks(), namespace: 'eip155' })
      )
  }
}
const Z5 = [M8, pce, fce, jf, Mm, Ip, Z0],
  Y5 = 'b56e18d47c72ab683b10814fe9495694',
  J5 = new Ape({ networks: Z5, projectId: Y5 }),
  _pe = new Bfe(),
  Cpe = new mle(),
  Spe = po(t => {
    t.vueApp.use(SH, { config: J5.wagmiConfig })
  }),
  Ipe = [bU, OU, MU, UU, LU, $U, jU, HU, yL, Spe]
function _g(t) {
  const e = wr((t == null ? void 0 : t.namespace) || ne.state.activeChain),
    n = wr(ne.state.chains),
    r = wr({
      allAccounts: [],
      address: void 0,
      caipAddress: void 0,
      status: void 0,
      isConnected: !1,
      embeddedWalletInfo: void 0
    })
  function s(a, c) {
    var h, p
    const u = c ? Et.getAuthConnector(c) : void 0,
      l = c ? ((h = a.get(c)) == null ? void 0 : h.accountState) : Ye.state
    ;(r.value.allAccounts = (l == null ? void 0 : l.allAccounts) || []),
      (r.value.address = dt.getPlainAddress(l == null ? void 0 : l.caipAddress)),
      (r.value.caipAddress = l == null ? void 0 : l.caipAddress),
      (r.value.status = l == null ? void 0 : l.status),
      (r.value.isConnected = !!(l != null && l.caipAddress))
    const d = c || ne.state.activeChain
    r.value.embeddedWalletInfo = u
      ? {
          user: l == null ? void 0 : l.user,
          authProvider: (l == null ? void 0 : l.socialProvider) ?? 'email',
          accountType: (p = l == null ? void 0 : l.preferredAccountTypes) == null ? void 0 : p[d],
          isSmartAccountDeployed: !!(l != null && l.smartAccountDeployed)
        }
      : void 0
  }
  const i = ne.subscribeKey('activeChain', a => {
      ;(e.value = (t == null ? void 0 : t.namespace) || a), s(n.value, e.value)
    }),
    o = ne.subscribe(a => {
      ;(n.value = a.chains), s(n.value, e.value)
    })
  return (
    fE(() => {
      s(n.value, e.value)
    }),
    uc(() => {
      o(), i()
    }),
    r
  )
}
function xpe() {
  async function t(e) {
    await pn.disconnect(e == null ? void 0 : e.namespace)
  }
  return { disconnect: t }
}
let qt
function Tpe(t) {
  t && (qt = t)
}
function f_() {
  if (!qt) throw new Error('Please call "createAppKit" before using "useAppKitTheme" hook')
  function t(i) {
    i && (qt == null || qt.setThemeMode(i))
  }
  function e(i) {
    i && (qt == null || qt.setThemeVariables(i))
  }
  const n = wr(qt.getThemeMode()),
    r = wr(qt.getThemeVariables()),
    s =
      qt == null
        ? void 0
        : qt.subscribeTheme(i => {
            ;(n.value = i.themeMode), (r.value = i.themeVariables)
          })
  return (
    uc(() => {
      s == null || s()
    }),
    zs({ setThemeMode: t, setThemeVariables: e, themeMode: n, themeVariables: r })
  )
}
function Npe() {
  if (!qt) throw new Error('Please call "createAppKit" before using "useAppKit" composable')
  async function t(n) {
    await (qt == null ? void 0 : qt.open(n))
  }
  async function e() {
    await (qt == null ? void 0 : qt.close())
  }
  return zs({ open: t, close: e })
}
function Ppe() {
  if (!qt) throw new Error('Please call "createAppKit" before using "useAppKit" composable')
  const t = wr(qt.getWalletInfo()),
    e = qt.subscribeWalletInfo(n => {
      t.value = n
    })
  return (
    uc(() => {
      e == null || e()
    }),
    zs({ walletInfo: t })
  )
}
function Rpe() {
  if (!qt) throw new Error('Please call "createAppKit" before using "useAppKitState" composable')
  const t = qt.getState(),
    e = wr(t.open),
    n = wr(t.selectedNetworkId),
    r =
      qt == null
        ? void 0
        : qt.subscribeState(s => {
            ;(e.value = s.open), (n.value = s.selectedNetworkId)
          })
  return (
    uc(() => {
      r == null || r()
    }),
    zs({ open: e, selectedNetworkId: n })
  )
}
function kpe() {
  if (!qt) throw new Error('Please call "createAppKit" before using "useAppKitEvents" composable')
  const t = zs(qt.getEvent()),
    e =
      qt == null
        ? void 0
        : qt.subscribeEvents(n => {
            ;(t.data = n.data), (t.timestamp = n.timestamp)
          })
  return (
    uc(() => {
      e == null || e()
    }),
    t
  )
}
let Hc
function Ope(t) {
  return (
    Hc ||
      ((Hc = new vce({ ...t, sdkVersion: dt.generateSdkVersion(t.adapters ?? [], 'html', Ece) })),
      Tpe(Hc)),
    Hc
  )
}
function X5() {
  var n, r
  const t = wr({
      caipNetwork: ne.state.activeCaipNetwork,
      chainId: (n = ne.state.activeCaipNetwork) == null ? void 0 : n.id,
      caipNetworkId: (r = ne.state.activeCaipNetwork) == null ? void 0 : r.caipNetworkId,
      switchNetwork: s => {
        Hc == null || Hc.switchNetwork(s)
      }
    }),
    e = ne.subscribeKey('activeCaipNetwork', s => {
      ;(t.value.caipNetwork = s),
        (t.value.chainId = s == null ? void 0 : s.id),
        (t.value.caipNetworkId = s == null ? void 0 : s.caipNetworkId)
    })
  return (
    uc(() => {
      e()
    }),
    t
  )
}
const p_ = (t, e) => {
    const n = t.__vccOpts || t
    for (const [r, s] of e) n[r] = s
    return n
  },
  Bpe = {
    name: 'ActionButton',
    setup() {
      const { disconnect: t } = xpe(),
        { open: e } = Npe(),
        n = X5(),
        r = f_()
      function s() {
        e()
      }
      function i() {
        n.value.switchNetwork(M8)
      }
      async function o() {
        try {
          await t()
        } catch (c) {
          console.error('Error during disconnect:', c)
        }
      }
      function a() {
        const c = r.themeMode === 'dark' ? 'light' : 'dark'
        r.setThemeMode(c), (document.body.className = c)
      }
      return {
        handleDisconnect: o,
        openAppKit: s,
        switchToNetwork: i,
        toggleTheme: a,
        themeState: r
      }
    }
  },
  Dpe = { class: 'action-button-list' },
  Mpe = {
    key: 0,
    xmlns: 'http://www.w3.org/2000/svg',
    width: '16',
    height: '16',
    viewBox: '0 0 32 32',
    fill: 'none'
  },
  Upe = {
    key: 1,
    xmlns: 'http://www.w3.org/2000/svg',
    width: '16',
    height: '16',
    viewBox: '0 0 32 32',
    fill: 'none'
  }
function Lpe(t, e, n, r, s, i) {
  return (
    os(),
    Zc('div', Dpe, [
      ht(
        'button',
        { onClick: e[0] || (e[0] = (...o) => r.openAppKit && r.openAppKit(...o)) },
        'Open'
      ),
      ht(
        'button',
        { onClick: e[1] || (e[1] = (...o) => r.handleDisconnect && r.handleDisconnect(...o)) },
        'Disconnect'
      ),
      ht(
        'button',
        { onClick: e[2] || (e[2] = (...o) => r.switchToNetwork && r.switchToNetwork(...o)) },
        'Switch to Ethereum'
      ),
      ht('button', { onClick: e[3] || (e[3] = (...o) => r.toggleTheme && r.toggleTheme(...o)) }, [
        r.themeState.themeMode === 'light'
          ? (os(),
            Zc(
              'svg',
              Mpe,
              e[4] ||
                (e[4] = [
                  ht(
                    'path',
                    {
                      d: 'M15 5V2C15 1.73478 15.1054 1.48043 15.2929 1.29289C15.4804 1.10536 15.7348 1 16 1C16.2652 1 16.5196 1.10536 16.7071 1.29289C16.8946 1.48043 17 1.73478 17 2V5C17 5.26522 16.8946 5.51957 16.7071 5.70711C16.5196 5.89464 16.2652 6 16 6C15.7348 6 15.4804 5.89464 15.2929 5.70711C15.1054 5.51957 15 5.26522 15 5ZM24 16C24 17.5823 23.5308 19.129 22.6518 20.4446C21.7727 21.7602 20.5233 22.7855 19.0615 23.391C17.5997 23.9965 15.9911 24.155 14.4393 23.8463C12.8874 23.5376 11.462 22.7757 10.3431 21.6569C9.22433 20.538 8.4624 19.1126 8.15372 17.5607C7.84504 16.0089 8.00346 14.4003 8.60896 12.9385C9.21447 11.4767 10.2398 10.2273 11.5554 9.34824C12.871 8.46919 14.4177 8 16 8C18.121 8.00232 20.1545 8.84591 21.6543 10.3457C23.1541 11.8455 23.9977 13.879 24 16ZM22 16C22 14.8133 21.6481 13.6533 20.9888 12.6666C20.3295 11.6799 19.3925 10.9108 18.2961 10.4567C17.1997 10.0026 15.9933 9.88378 14.8295 10.1153C13.6656 10.3468 12.5965 10.9182 11.7574 11.7574C10.9182 12.5965 10.3468 13.6656 10.1153 14.8295C9.88378 15.9933 10.0026 17.1997 10.4567 18.2961C10.9108 19.3925 11.6799 20.3295 12.6666 20.9888C13.6533 21.6481 14.8133 22 16 22C17.5908 21.9983 19.116 21.3657 20.2408 20.2408C21.3657 19.116 21.9983 17.5908 22 16ZM7.2925 8.7075C7.48014 8.89514 7.73464 9.00056 8 9.00056C8.26536 9.00056 8.51986 8.89514 8.7075 8.7075C8.89514 8.51986 9.00056 8.26536 9.00056 8C9.00056 7.73464 8.89514 7.48014 8.7075 7.2925L6.7075 5.2925C6.51986 5.10486 6.26536 4.99944 6 4.99944C5.73464 4.99944 5.48014 5.10486 5.2925 5.2925C5.10486 5.48014 4.99944 5.73464 4.99944 6C4.99944 6.26536 5.10486 6.51986 5.2925 6.7075L7.2925 8.7075ZM7.2925 23.2925L5.2925 25.2925C5.10486 25.4801 4.99944 25.7346 4.99944 26C4.99944 26.2654 5.10486 26.5199 5.2925 26.7075C5.48014 26.8951 5.73464 27.0006 6 27.0006C6.26536 27.0006 6.51986 26.8951 6.7075 26.7075L8.7075 24.7075C8.80041 24.6146 8.87411 24.5043 8.92439 24.3829C8.97468 24.2615 9.00056 24.1314 9.00056 24C9.00056 23.8686 8.97468 23.7385 8.92439 23.6171C8.87411 23.4957 8.80041 23.3854 8.7075 23.2925C8.61459 23.1996 8.50429 23.1259 8.3829 23.0756C8.2615 23.0253 8.13139 22.9994 8 22.9994C7.86861 22.9994 7.7385 23.0253 7.6171 23.0756C7.49571 23.1259 7.38541 23.1996 7.2925 23.2925ZM24 9C24.1314 9.0001 24.2615 8.97432 24.3829 8.92414C24.5042 8.87395 24.6146 8.80033 24.7075 8.7075L26.7075 6.7075C26.8951 6.51986 27.0006 6.26536 27.0006 6C27.0006 5.73464 26.8951 5.48014 26.7075 5.2925C26.5199 5.10486 26.2654 4.99944 26 4.99944C25.7346 4.99944 25.4801 5.10486 25.2925 5.2925L23.2925 7.2925C23.1525 7.43236 23.0571 7.61061 23.0185 7.80469C22.9798 7.99878 22.9996 8.19997 23.0754 8.38279C23.1511 8.56561 23.2794 8.72185 23.444 8.83172C23.6086 8.94159 23.8021 9.00016 24 9ZM24.7075 23.2925C24.5199 23.1049 24.2654 22.9994 24 22.9994C23.7346 22.9994 23.4801 23.1049 23.2925 23.2925C23.1049 23.4801 22.9994 23.7346 22.9994 24C22.9994 24.2654 23.1049 24.5199 23.2925 24.7075L25.2925 26.7075C25.3854 26.8004 25.4957 26.8741 25.6171 26.9244C25.7385 26.9747 25.8686 27.0006 26 27.0006C26.1314 27.0006 26.2615 26.9747 26.3829 26.9244C26.5043 26.8741 26.6146 26.8004 26.7075 26.7075C26.8004 26.6146 26.8741 26.5043 26.9244 26.3829C26.9747 26.2615 27.0006 26.1314 27.0006 26C27.0006 25.8686 26.9747 25.7385 26.9244 25.6171C26.8741 25.4957 26.8004 25.3854 26.7075 25.2925L24.7075 23.2925ZM6 16C6 15.7348 5.89464 15.4804 5.70711 15.2929C5.51957 15.1054 5.26522 15 5 15H2C1.73478 15 1.48043 15.1054 1.29289 15.2929C1.10536 15.4804 1 15.7348 1 16C1 16.2652 1.10536 16.5196 1.29289 16.7071C1.48043 16.8946 1.73478 17 2 17H5C5.26522 17 5.51957 16.8946 5.70711 16.7071C5.89464 16.5196 6 16.2652 6 16ZM16 26C15.7348 26 15.4804 26.1054 15.2929 26.2929C15.1054 26.4804 15 26.7348 15 27V30C15 30.2652 15.1054 30.5196 15.2929 30.7071C15.4804 30.8946 15.7348 31 16 31C16.2652 31 16.5196 30.8946 16.7071 30.7071C16.8946 30.5196 17 30.2652 17 30V27C17 26.7348 16.8946 26.4804 16.7071 26.2929C16.5196 26.1054 16.2652 26 16 26ZM30 15H27C26.7348 15 26.4804 15.1054 26.2929 15.2929C26.1054 15.4804 26 15.7348 26 16C26 16.2652 26.1054 16.5196 26.2929 16.7071C26.4804 16.8946 26.7348 17 27 17H30C30.2652 17 30.5196 16.8946 30.7071 16.7071C30.8946 16.5196 31 16.2652 31 16C31 15.7348 30.8946 15.4804 30.7071 15.2929C30.5196 15.1054 30.2652 15 30 15Z',
                      fill: 'currentColor'
                    },
                    null,
                    -1
                  )
                ])
            ))
          : D_('', !0),
        r.themeState.themeMode === 'dark'
          ? (os(),
            Zc(
              'svg',
              Upe,
              e[5] ||
                (e[5] = [
                  ht(
                    'path',
                    {
                      d: 'M29.1925 17.7788C29.0642 17.6503 28.9034 17.5591 28.7272 17.515C28.551 17.471 28.3662 17.4757 28.1925 17.5288C26.2857 18.1053 24.2583 18.1536 22.3262 17.6686C20.3941 17.1837 18.6298 16.1837 17.2212 14.7751C15.8126 13.3665 14.8126 11.6022 14.3277 9.67013C13.8427 7.73804 13.8911 5.71059 14.4675 3.8038C14.521 3.63006 14.5261 3.44501 14.4823 3.26857C14.4385 3.09213 14.3475 2.93097 14.2189 2.80241C14.0904 2.67386 13.9292 2.58279 13.7528 2.53898C13.5763 2.49518 13.3913 2.5003 13.2175 2.5538C10.5813 3.36136 8.26695 4.97979 6.60378 7.1788C5.14929 9.10987 4.26209 11.4083 4.04186 13.8158C3.82162 16.2233 4.27707 18.6445 5.35704 20.8074C6.437 22.9703 8.0987 24.7893 10.1554 26.0598C12.2122 27.3304 14.5825 28.0023 17 28.0001C19.8205 28.0087 22.5658 27.0919 24.815 25.3901C27.014 23.7269 28.6325 21.4125 29.44 18.7763C29.4929 18.6032 29.4978 18.419 29.4542 18.2433C29.4106 18.0677 29.3202 17.9071 29.1925 17.7788ZM23.6125 23.7926C21.4945 25.3879 18.8714 26.1644 16.2262 25.9792C13.581 25.794 11.0918 24.6595 9.2167 22.7845C7.34162 20.9096 6.20692 18.4205 6.02149 15.7753C5.83606 13.1301 6.61237 10.507 8.20753 8.3888C9.24678 7.01638 10.5904 5.90386 12.1325 5.1388C12.0447 5.75533 12.0004 6.37729 12 7.00005C12.0037 10.4467 13.3745 13.7512 15.8117 16.1884C18.2488 18.6256 21.5533 19.9964 25 20.0001C25.624 19.9999 26.2473 19.9556 26.865 19.8676C26.0993 21.41 24.9859 22.7536 23.6125 23.7926Z',
                      fill: 'currentColor'
                    },
                    null,
                    -1
                  )
                ])
            ))
          : D_('', !0)
      ])
    ])
  )
}
const $pe = p_(Bpe, [['render', Lpe]]),
  Fpe = {
    name: 'InfoList',
    setup() {
      const t = f_(),
        e = Rpe(),
        n = _g(),
        r = _g({ namespace: 'eip155' }),
        s = _g({ namespace: 'solana' }),
        i = _g({ namespace: 'bip122' }),
        o = X5(),
        a = kpe(),
        c = Ppe()
      return {
        themeState: t,
        appKitState: e,
        networkState: o,
        eventsState: a,
        accountState: n,
        evmAccountState: r,
        solanaAccountState: s,
        bitcoinAccountState: i,
        walletState: c
      }
    }
  },
  jpe = { class: 'code-container-wrapper' },
  Hpe = { class: 'code-container' },
  qpe = { class: 'code-container-content' },
  zpe = { class: 'code-container' },
  Wpe = { class: 'code-container-content' },
  Kpe = { class: 'code-container' },
  Vpe = { class: 'code-container-content' },
  Gpe = { class: 'code-container' },
  Qpe = { class: 'code-container-content' },
  Zpe = { class: 'code-container' },
  Ype = { class: 'code-container-content' },
  Jpe = { class: 'code-container' },
  Xpe = { class: 'code-container-content' },
  ege = { class: 'code-container' },
  tge = { class: 'code-container-content' },
  nge = { class: 'code-container' },
  rge = { class: 'code-container-content' },
  sge = { class: 'code-container' },
  ige = { class: 'code-container-content' }
function oge(t, e, n, r, s, i) {
  return (
    os(),
    Zc('div', jpe, [
      ht('section', Hpe, [
        e[0] || (e[0] = ht('h2', { class: 'code-container-title' }, 'useAppKitAccount() EVM', -1)),
        ht('div', qpe, [ht('pre', null, Hi(JSON.stringify(r.evmAccountState, null, 2)), 1)])
      ]),
      ht('section', zpe, [
        e[1] ||
          (e[1] = ht('h2', { class: 'code-container-title' }, 'useAppKitAccount() Solana', -1)),
        ht('div', Wpe, [ht('pre', null, Hi(JSON.stringify(r.solanaAccountState, null, 2)), 1)])
      ]),
      ht('section', Kpe, [
        e[2] ||
          (e[2] = ht('h2', { class: 'code-container-title' }, 'useAppKitAccount() Bitcoin', -1)),
        ht('div', Vpe, [ht('pre', null, Hi(JSON.stringify(r.bitcoinAccountState, null, 2)), 1)])
      ]),
      ht('section', Gpe, [
        e[3] || (e[3] = ht('h2', { class: 'code-container-title' }, 'useAppKitAccount()', -1)),
        ht('div', Qpe, [ht('pre', null, Hi(JSON.stringify(r.accountState, null, 2)), 1)])
      ]),
      ht('section', Zpe, [
        e[4] || (e[4] = ht('h2', { class: 'code-container-title' }, 'useAppKitNetwork()', -1)),
        ht('div', Ype, [ht('pre', null, Hi(JSON.stringify(r.networkState, null, 2)), 1)])
      ]),
      ht('section', Jpe, [
        e[5] || (e[5] = ht('h2', { class: 'code-container-title' }, 'useAppKitTheme()', -1)),
        ht('div', Xpe, [ht('pre', null, Hi(JSON.stringify(r.themeState, null, 2)), 1)])
      ]),
      ht('section', ege, [
        e[6] || (e[6] = ht('h2', { class: 'code-container-title' }, 'useAppKitState()', -1)),
        ht('div', tge, [ht('pre', null, Hi(JSON.stringify(r.appKitState, null, 2)), 1)])
      ]),
      ht('section', nge, [
        e[7] || (e[7] = ht('h2', { class: 'code-container-title' }, 'useAppKitEvents()', -1)),
        ht('div', rge, [ht('pre', null, Hi(JSON.stringify(r.eventsState, null, 2)), 1)])
      ]),
      ht('section', sge, [
        e[8] || (e[8] = ht('h2', { class: 'code-container-title' }, 'useWalletInfo()', -1)),
        ht('div', ige, [ht('pre', null, Hi(JSON.stringify(r.walletState, null, 2)), 1)])
      ])
    ])
  )
}
const age = p_(Fpe, [['render', oge]]),
  cge = { name: 'Footer' },
  uge = { className: 'footer' }
function lge(t, e, n, r, s, i) {
  return (
    os(),
    Zc(
      'div',
      uge,
      e[0] ||
        (e[0] = [
          K6(
            '<div class="footer-links"><a href="https://reown.com" target="_blank" rel="noreferrer">Reown</a>  <a href="https://docs.reown.com" target="_blank" rel="noreferrer">Docs</a>  <a href="https://github.com/reown-com/appkit" target="_blank" rel="noreferrer">GitHub</a>  <a href="https://cloud.reown.com" target="_blank" rel="noreferrer">Cloud</a></div><p class="warning">This project ID only works on localhost. Go to Cloud to get your own.</p>',
            2
          )
        ])
    )
  )
}
const dge = p_(cge, [['render', lge]]),
  hge = Symbol.for('nuxt:client-only'),
  fge = n0({
    name: 'ClientOnly',
    inheritAttrs: !1,
    props: ['fallback', 'placeholder', 'placeholderTag', 'fallbackTag'],
    setup(t, { slots: e, attrs: n }) {
      const r = wr(!1)
      return (
        fE(() => {
          r.value = !0
        }),
        pE(hge, !0),
        s => {
          var c
          if (r.value) return (c = e.default) == null ? void 0 : c.call(e)
          const i = e.fallback || e.placeholder
          if (i) return i()
          const o = s.fallback || s.placeholder || '',
            a = s.fallbackTag || s.placeholderTag || 'span'
          return Zc(a, n, o)
        }
      )
    }
  }),
  pge = _E('/appkit-logo.png'),
  gge = { class: 'page-container' },
  mge = { class: 'logo-container' },
  yge = ['src'],
  wge = { class: 'appkit-buttons-container' },
  bge = n0({
    __name: 'app',
    setup(t) {
      Ope({
        adapters: [J5, _pe, Cpe],
        networks: Z5,
        projectId: Y5,
        themeMode: 'light',
        features: { analytics: !0 },
        metadata: {
          name: 'AppKit Nuxt Wagmi Example',
          description: 'AppKit Nuxt Wagmi Example',
          url: 'https://reown.com/appkit',
          icons: ['https://avatars.githubusercontent.com/u/179229932?s=200&v=4']
        }
      })
      const e = f_()
      return (n, r) => {
        const s = C_('appkit-button'),
          i = C_('appkit-network-button'),
          o = $pe,
          a = age,
          c = dge,
          u = fge
        return (
          os(),
          Ia(u, null, {
            default: uE(() => [
              ht('div', gge, [
                ht('div', mge, [
                  ht(
                    'img',
                    {
                      src: Qn(e).themeMode === 'dark' ? '/reown-logo-white.png' : '/reown-logo.png',
                      alt: 'Reown',
                      width: '150'
                    },
                    null,
                    8,
                    yge
                  ),
                  r[0] || (r[0] = ht('img', { src: pge, alt: 'Reown', width: '150' }, null, -1))
                ]),
                r[1] ||
                  (r[1] = ht(
                    'h1',
                    { class: 'page-title' },
                    'Nuxt Wagmi-Solana-Bitcoin Example',
                    -1
                  )),
                ht('div', wge, [An(s), An(i)]),
                An(o),
                An(a),
                An(c)
              ])
            ]),
            _: 1
          })
        )
      }
    }
  }),
  vge = {
    __name: 'nuxt-error-page',
    props: { error: Object },
    setup(t) {
      const n = t.error
      n.stack &&
        n.stack
          .split(
            `
`
          )
          .splice(1)
          .map(d => ({
            text: d.replace('webpack:/', '').replace('.vue', '.js').trim(),
            internal:
              (d.includes('node_modules') && !d.includes('.cache')) ||
              d.includes('internal') ||
              d.includes('new Promise')
          }))
          .map(d => `<span class="stack${d.internal ? ' internal' : ''}">${d.text}</span>`).join(`
`)
      const r = Number(n.statusCode || 500),
        s = r === 404,
        i = n.statusMessage ?? (s ? 'Page Not Found' : 'Internal Server Error'),
        o = n.message || n.toString(),
        a = void 0,
        l = s
          ? __(() =>
              qr(() => import('./TVxiSsSt.js'), __vite__mapDeps([33, 34, 35]), import.meta.url)
            )
          : __(() =>
              qr(() => import('./DJuK5Oly.js'), __vite__mapDeps([36, 34, 37]), import.meta.url)
            )
      return (d, h) => (
        os(),
        Ia(
          Qn(l),
          fB(dP({ statusCode: Qn(r), statusMessage: Qn(i), description: Qn(o), stack: Qn(a) })),
          null,
          16
        )
      )
    }
  },
  Ege = { key: 0 },
  WT = {
    __name: 'nuxt-root',
    setup(t) {
      const e = () => null,
        n = Pr(),
        r = n.deferHydration()
      if (n.isHydrating) {
        const c = n.hooks.hookOnce('app:error', r)
        ru().beforeEach(c)
      }
      const s = !1
      pE(UP, LP()), n.hooks.callHookWith(c => c.map(u => u()), 'vue:setup')
      const i = TE(),
        o = !1
      UN((c, u, l) => {
        if (
          (n.hooks
            .callHook('vue:error', c, u, l)
            .catch(d => console.error('[nuxt] Error in `vue:error` hook', d)),
          D4(c) && (c.fatal || c.unhandled))
        )
          return n.runWithContext(() => O4(c)), !1
      })
      const a = !1
      return (c, u) => (
        os(),
        Ia(
          $6,
          { onResolve: Qn(r) },
          {
            default: uE(() => [
              Qn(o)
                ? (os(), Zc('div', Ege))
                : Qn(i)
                  ? (os(), Ia(Qn(vge), { key: 1, error: Qn(i) }, null, 8, ['error']))
                  : Qn(a)
                    ? (os(), Ia(Qn(e), { key: 2, context: Qn(a) }, null, 8, ['context']))
                    : Qn(s)
                      ? (os(), Ia(l6(Qn(s)), { key: 3 }))
                      : (os(), Ia(Qn(bge), { key: 4 }))
            ]),
            _: 1
          },
          8,
          ['onResolve']
        )
      )
    }
  }
let KT
{
  let t
  ;(KT = async function () {
    var o, a
    if (t) return t
    const r = !!(
        ((o = window.__NUXT__) == null ? void 0 : o.serverRendered) ??
        ((a = document.getElementById('__NUXT_DATA__')) == null ? void 0 : a.dataset.ssr) === 'true'
      )
        ? TD(WT)
        : xD(WT),
      s = jM({ vueApp: r })
    async function i(c) {
      var u
      await s.callHook('app:error', c), (u = s.payload).error || (u.error = NE(c))
    }
    ;(r.config.errorHandler = i),
      s.hook('app:suspense:resolve', () => {
        r.config.errorHandler === i && (r.config.errorHandler = void 0)
      })
    try {
      await zM(s, Ipe)
    } catch (c) {
      i(c)
    }
    try {
      await s.hooks.callHook('app:created', r),
        await s.hooks.callHook('app:beforeMount', r),
        r.mount(LM),
        await s.hooks.callHook('app:mounted', r),
        await aE()
    } catch (c) {
      i(c)
    }
    return r
  }),
    (t = KT().catch(e => {
      throw (console.error('Error while mounting app:', e), e)
    }))
}
export {
  Ye as $,
  uE as A,
  hP as B,
  Cge as C,
  WM as D,
  gE as E,
  xl as F,
  HP as G,
  Bge as H,
  Dc as I,
  gf as J,
  Mt as K,
  qr as L,
  T0 as M,
  Ol as N,
  Hg as O,
  Kn as P,
  Tme as Q,
  Et as R,
  ao as S,
  zr as T,
  nr as U,
  zo as V,
  gr as W,
  Ome as X,
  Ae as Y,
  b8 as Z,
  p_ as _,
  Pr as a,
  dt as a0,
  ne as a1,
  gn as a2,
  Jn as a3,
  Tr as a4,
  nn as a5,
  Bme as a6,
  js as a7,
  pn as a8,
  Pe as a9,
  Uv as aA,
  ld as aB,
  Se as aC,
  zE as aD,
  oi as aE,
  R9 as aF,
  y7 as aG,
  C3 as aH,
  su as aI,
  TR as aJ,
  Ph as aK,
  Yo as aL,
  ny as aM,
  zA as aN,
  Oge as aO,
  cm as aP,
  gA as aQ,
  X8 as aR,
  Mle as aS,
  N0 as aT,
  rq as aU,
  Dle as aV,
  WA as aW,
  Yi as aX,
  hH as aY,
  In as aa,
  jae as ab,
  Ke as ac,
  Jp as ad,
  ux as ae,
  tk as af,
  gt as ag,
  xn as ah,
  qa as ai,
  cx as aj,
  Yr as ak,
  Qr as al,
  Mge as am,
  yt as an,
  Uge as ao,
  gie as ap,
  _i as aq,
  Dme as ar,
  Nme as as,
  Mv as at,
  Fg as au,
  Mh as av,
  _u as aw,
  fr as ax,
  kme as ay,
  N8 as az,
  kE as b,
  pC as c,
  n0 as d,
  MN as e,
  Sge as f,
  C_ as g,
  rD as h,
  k4 as i,
  mP as j,
  o0 as k,
  IE as l,
  Gh as m,
  R4 as n,
  fE as o,
  SE as p,
  RP as q,
  wr as r,
  _ge as s,
  Zc as t,
  ru as u,
  os as v,
  l1 as w,
  ht as x,
  Hi as y,
  An as z
}
